<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Nef_3/group__PkgNef3IOFunctions.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=11">
<meta name="generator" content="Doxygen 1.9.6">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CGAL 6.0 - 3D Boolean Operations on Nef Polyhedra: I/O Functions</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/doxygen.css" rel="stylesheet" type="text/css">
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      },
      equationNumbers: { autoNumber: "AMS" }
  }
}
);
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
      <span class="left">
         <span id="MSearchSelect" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"> 
        </span>
        <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
      </span>
      <span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.svg" alt=""></a>
      </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CGAL 6.0 - 3D Boolean Operations on Nef Polyhedra
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search/",'.html');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__PkgNef3IOFunctions.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">I/O Functions<div class="ingroups"><a class="el" href="group__PkgNef3Ref.html">3D Boolean Operations on  Nef Polyhedra Reference</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader"> </h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2e47f1a21e5b35af36c7ef665c66e848"><td class="memTemplParams" colspan="2">template&lt;class Nef_polyhedron , class Polygon_mesh &gt; </td></tr>
<tr class="memitem:ga2e47f1a21e5b35af36c7ef665c66e848"><td class="memTemplItemLeft" align="right" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgNef3IOFunctions.html#ga2e47f1a21e5b35af36c7ef665c66e848">CGAL::convert_nef_polyhedron_to_polygon_mesh</a> (const Nef_polyhedron &amp;nef, Polygon_mesh &amp;pm, bool triangulate_all_faces=false)</td></tr>
<tr class="memdesc:ga2e47f1a21e5b35af36c7ef665c66e848"><td class="mdescLeft"> </td><td class="mdescRight">Converts an object of type <code><a class="el" href="classCGAL_1_1Nef__polyhedron__3.html" title="A 3D Nef polyhedron is a subset of the 3-dimensional space that is the result of forming complements ...">Nef_polyhedron_3</a></code> into a polygon mesh model of <code><a class="elRef" href="../BGL/classMutableFaceGraph.html">MutableFaceGraph</a></code>.  <br></td></tr>
<tr class="separator:ga2e47f1a21e5b35af36c7ef665c66e848"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga28a9eb4da0cd6153f0c16f7f9eaf6665"><td class="memTemplParams" colspan="2">template&lt;class Nef_polyhedron , typename PolygonRange , typename PointRange &gt; </td></tr>
<tr class="memitem:ga28a9eb4da0cd6153f0c16f7f9eaf6665"><td class="memTemplItemLeft" align="right" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgNef3IOFunctions.html#ga28a9eb4da0cd6153f0c16f7f9eaf6665">CGAL::convert_nef_polyhedron_to_polygon_soup</a> (const Nef_polyhedron &amp;nef, PointRange &amp;points, PolygonRange &amp;polygons, bool triangulate_all_faces=false)</td></tr>
<tr class="memdesc:ga28a9eb4da0cd6153f0c16f7f9eaf6665"><td class="mdescLeft"> </td><td class="mdescRight">Converts an object of type <code><a class="el" href="classCGAL_1_1Nef__polyhedron__3.html" title="A 3D Nef polyhedron is a subset of the 3-dimensional space that is the result of forming complements ...">Nef_polyhedron_3</a></code> into a polygon soup.  <br></td></tr>
<tr class="separator:ga28a9eb4da0cd6153f0c16f7f9eaf6665"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaf35d6aeb83886b4c84068aad3a2e66d0"><td class="memTemplParams" colspan="2">template&lt;class Traits &gt; </td></tr>
<tr class="memitem:gaf35d6aeb83886b4c84068aad3a2e66d0"><td class="memTemplItemLeft" align="right" valign="top">istream &amp; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgNef3IOFunctions.html#gaf35d6aeb83886b4c84068aad3a2e66d0">CGAL::operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="classCGAL_1_1Nef__polyhedron__3.html">CGAL::Nef_polyhedron_3</a>&lt; Traits &gt; &amp;N)</td></tr>
<tr class="memdesc:gaf35d6aeb83886b4c84068aad3a2e66d0"><td class="mdescLeft"> </td><td class="mdescRight">This operator reads a Nef polyhedron, which is given in the proprietary file format written by the input operator <em>in</em> and assigns it to <em>N</em>.  <br></td></tr>
<tr class="separator:gaf35d6aeb83886b4c84068aad3a2e66d0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga1a2f710b0de656d242dfecc2cfbdb28a"><td class="memTemplParams" colspan="2">template&lt;class Traits &gt; </td></tr>
<tr class="memitem:ga1a2f710b0de656d242dfecc2cfbdb28a"><td class="memTemplItemLeft" align="right" valign="top">ostream &amp; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgNef3IOFunctions.html#ga1a2f710b0de656d242dfecc2cfbdb28a">CGAL::operator&lt;&lt;</a> (std::ostream &amp;out, <a class="el" href="classCGAL_1_1Nef__polyhedron__3.html">CGAL::Nef_polyhedron_3</a>&lt; Traits &gt; &amp;N)</td></tr>
<tr class="memdesc:ga1a2f710b0de656d242dfecc2cfbdb28a"><td class="mdescLeft"> </td><td class="mdescRight">This operator writes the Nef polyhedron <code>N</code> to the output stream <code>out</code> using a proprietary file format.  <br></td></tr>
<tr class="separator:ga1a2f710b0de656d242dfecc2cfbdb28a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaeb31b20d2824c500c4a12e284667dfce"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="classCGAL_1_1Nef__polyhedron__3.html">Nef_polyhedron_3</a> &gt; </td></tr>
<tr class="memitem:gaeb31b20d2824c500c4a12e284667dfce"><td class="memTemplItemLeft" align="right" valign="top">std::size_t </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgNef3IOFunctions.html#gaeb31b20d2824c500c4a12e284667dfce">CGAL::OFF_to_nef_3</a> (std::istream &amp;in, <a class="el" href="classCGAL_1_1Nef__polyhedron__3.html">Nef_polyhedron_3</a> &amp;N)</td></tr>
<tr class="memdesc:gaeb31b20d2824c500c4a12e284667dfce"><td class="mdescLeft"> </td><td class="mdescRight">This function creates a 3D Nef polyhedron from an OFF file which is read from input stream <code>in</code>.  <br></td></tr>
<tr class="separator:gaeb31b20d2824c500c4a12e284667dfce"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga2e47f1a21e5b35af36c7ef665c66e848" name="ga2e47f1a21e5b35af36c7ef665c66e848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e47f1a21e5b35af36c7ef665c66e848">◆ </a></span>convert_nef_polyhedron_to_polygon_mesh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Nef_polyhedron , class Polygon_mesh &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CGAL::convert_nef_polyhedron_to_polygon_mesh </td>
          <td>(</td>
          <td class="paramtype">const Nef_polyhedron &amp; </td>
          <td class="paramname"><em>nef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Polygon_mesh &amp; </td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>triangulate_all_faces</em> = <code>false</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/boost/graph/convert_nef_polyhedron_to_polygon_mesh.h&gt;</code></p>

<p>Converts an object of type <code><a class="el" href="classCGAL_1_1Nef__polyhedron__3.html" title="A 3D Nef polyhedron is a subset of the 3-dimensional space that is the result of forming complements ...">Nef_polyhedron_3</a></code> into a polygon mesh model of <code><a class="elRef" href="../BGL/classMutableFaceGraph.html">MutableFaceGraph</a></code>. </p>
<p>Note that contrary to <code><a class="el" href="classCGAL_1_1Nef__polyhedron__3.html#ae1caa4106dbeaa8e59ff48c5e02260c6" title="converts N into a triangulated Polyhedron.">Nef_polyhedron_3::convert_to_polyhedron()</a></code>, the output is not triangulated (but faces with more than one connected component of the boundary). The polygon mesh can be triangulated by setting <code>triangulate_all_faces</code> to <code>true</code> or by calling the function <code>triangulate_faces()</code>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Nef_polyhedron</td><td>an object of type <code><a class="el" href="classCGAL_1_1Nef__polyhedron__3.html" title="A 3D Nef polyhedron is a subset of the 3-dimensional space that is the result of forming complements ...">Nef_polyhedron_3</a></code>. </td></tr>
    <tr><td class="paramname">Polygon_mesh</td><td>a model of <code><a class="elRef" href="../BGL/classMutableFaceGraph.html">MutableFaceGraph</a></code> with an internal property map for <code><a class="elRef" href="../BGL/group__PkgBGLProperties.html#ga247337f62916ade681347fa6f07251e1">CGAL::vertex_point_t</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<p>The points from <code>nef</code> to <code>pm</code> are converted using <code><a class="elRef" href="../Kernel_23/classCGAL_1_1Cartesian__converter.html">CGAL::Cartesian_converter</a>&lt;NefKernel, TargetKernel&gt;</code>. <code>NefKernel</code> and <code>TargetKernel</code> are deduced using <code><a class="elRef" href="../Kernel_23/structCGAL_1_1Kernel__traits.html">CGAL::Kernel_traits</a></code> from the point type of <code>nef</code> and the value type of the vertex_point_map of <code>tm</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nef</td><td>the input. </td></tr>
    <tr><td class="paramname">pm</td><td>the output. </td></tr>
    <tr><td class="paramname">triangulate_all_faces</td><td>indicates whether all the faces must be triangulated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>Polygon_mesh</code> must have an internal point property map with value type being <code><a class="el" href="classCGAL_1_1Nef__polyhedron__3.html#afc9ae4754ea1d424b3e9a46a387d52f0" title="location of vertices.">Nef_polyhedron_3::Point_3</a></code>. </dd>
<dd>
<code>nef.simple()</code> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Nef_3_2nef_3_to_surface_mesh_8cpp-example.html#a4">Nef_3/nef_3_to_surface_mesh.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga28a9eb4da0cd6153f0c16f7f9eaf6665" name="ga28a9eb4da0cd6153f0c16f7f9eaf6665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28a9eb4da0cd6153f0c16f7f9eaf6665">◆ </a></span>convert_nef_polyhedron_to_polygon_soup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Nef_polyhedron , typename PolygonRange , typename PointRange &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CGAL::convert_nef_polyhedron_to_polygon_soup </td>
          <td>(</td>
          <td class="paramtype">const Nef_polyhedron &amp; </td>
          <td class="paramname"><em>nef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointRange &amp; </td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PolygonRange &amp; </td>
          <td class="paramname"><em>polygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>triangulate_all_faces</em> = <code>false</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/boost/graph/convert_nef_polyhedron_to_polygon_mesh.h&gt;</code></p>

<p>Converts an object of type <code><a class="el" href="classCGAL_1_1Nef__polyhedron__3.html" title="A 3D Nef polyhedron is a subset of the 3-dimensional space that is the result of forming complements ...">Nef_polyhedron_3</a></code> into a polygon soup. </p>
<p>The polygons can be triangulated by setting <code>triangulate_all_faces</code> to <code>true</code>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Nef_polyhedron</td><td>an object of type <code><a class="el" href="classCGAL_1_1Nef__polyhedron__3.html" title="A 3D Nef polyhedron is a subset of the 3-dimensional space that is the result of forming complements ...">Nef_polyhedron_3</a></code>. </td></tr>
    <tr><td class="paramname">PointRange</td><td>a model of the concept <code><a class="elRef" href="../Manual/classBackInsertionSequence.html">BackInsertionSequence</a></code> whose <code>value_type</code> is the point type </td></tr>
    <tr><td class="paramname">PolygonRange</td><td>a model of the concept <code><a class="elRef" href="../Manual/classBackInsertionSequence.html">BackInsertionSequence</a></code> whose <code>value_type</code> is a model of the concept <code><a class="elRef" href="../Manual/classBackInsertionSequence.html">BackInsertionSequence</a></code> whose <code>value_type</code> is <code>std::size_t</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>The points from <code>nef</code> to <code>points</code> are converted using <code><a class="elRef" href="../Kernel_23/classCGAL_1_1Cartesian__converter.html">CGAL::Cartesian_converter</a>&lt;NefKernel, OutputKernel&gt;</code>. <code>NefKernel</code> and <code>OutputKernel</code> are deduced using <code><a class="elRef" href="../Kernel_23/structCGAL_1_1Kernel__traits.html">CGAL::Kernel_traits</a></code> from the point types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nef</td><td>the input. </td></tr>
    <tr><td class="paramname">points</td><td>the output points of the soup </td></tr>
    <tr><td class="paramname">polygons</td><td>the output polygons of the soup. </td></tr>
    <tr><td class="paramname">triangulate_all_faces</td><td>indicates whether all polygons must be triangulated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaeb31b20d2824c500c4a12e284667dfce" name="gaeb31b20d2824c500c4a12e284667dfce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb31b20d2824c500c4a12e284667dfce">◆ </a></span>OFF_to_nef_3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="classCGAL_1_1Nef__polyhedron__3.html">Nef_polyhedron_3</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t CGAL::OFF_to_nef_3 </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp; </td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Nef__polyhedron__3.html">Nef_polyhedron_3</a> &amp; </td>
          <td class="paramname"><em>N</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/OFF_to_nef_3.h&gt;</code></p>

<p>This function creates a 3D Nef polyhedron from an OFF file which is read from input stream <code>in</code>. </p>
<p>The purpose of <code>OFF_to_nef_3</code> is to create a Nef polyhedron from an OFF file that cannot be handled by the <code><a class="el" href="classCGAL_1_1Nef__polyhedron__3.html" title="A 3D Nef polyhedron is a subset of the 3-dimensional space that is the result of forming complements ...">Nef_polyhedron_3</a></code> constructors. It handles double coordinates while using a homogeneous kernel, non-coplanar facets, surfaces with boundaries, self-intersecting surfaces, and single facets. Every closed volume gets marked. The function returns the number of facets it could not handle.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classCGAL_1_1Nef__polyhedron__3.html" title="A 3D Nef polyhedron is a subset of the 3-dimensional space that is the result of forming complements ...">CGAL::Nef_polyhedron_3</a>&lt;Traits&gt;</code> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Nef_3_2complex_construction_8cpp-example.html#a2">Nef_3/complex_construction.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga1a2f710b0de656d242dfecc2cfbdb28a" name="ga1a2f710b0de656d242dfecc2cfbdb28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a2f710b0de656d242dfecc2cfbdb28a">◆ </a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ostream &amp; CGAL::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp; </td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Nef__polyhedron__3.html">CGAL::Nef_polyhedron_3</a>&lt; Traits &gt; &amp; </td>
          <td class="paramname"><em>N</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/IO/Nef_polyhedron_iostream_3.h&gt;</code></p>

<p>This operator writes the Nef polyhedron <code>N</code> to the output stream <code>out</code> using a proprietary file format. </p>
<p>It includes the complete incidence structure, the geometric data, and the marks of each item.</p>
<p>Using CGAL stream modifiers the following output formats can be chosen: ASCII (<code>set_ascii_mode()</code>), binary (<code>set_binary_mode()</code>) or pretty (<code>set_pretty_mode()</code>). The mandatory format is the ASCII format. It is recommended to use this format for file input and output.</p>
<p>As the output depends on the output operators of the geometric primitives provided by the traits class, it might not be possible that the input operator and output operators of different traits classes are not compatible. We recommend to use the CGAL kernels <code><a class="elRef" href="../Kernel_23/structCGAL_1_1Homogeneous.html">Homogeneous</a></code>, <code><a class="elRef" href="../Kernel_23/structCGAL_1_1Simple__homogeneous.html">Simple_homogeneous</a></code>, or <code><a class="elRef" href="../Nef_2/classCGAL_1_1Extended__homogeneous.html">Extended_homogeneous</a></code> parametrized with any exact number type that models \(\mathbb{Z}\) (e.g. <code><a class="elRef" href="../Number_types/classCGAL_1_1Gmpz.html">Gmpz</a></code> or <code><a class="elRef" href="../Number_types/classleda__integer.html">leda_integer</a></code>).</p>
<p>A bounded <code><a class="el" href="classCGAL_1_1Nef__polyhedron__3.html" title="A 3D Nef polyhedron is a subset of the 3-dimensional space that is the result of forming complements ...">Nef_polyhedron_3</a>&lt;<a class="elRef" href="../Nef_2/classCGAL_1_1Extended__homogeneous.html">Extended_homogeneous</a>&gt;</code> is automatically written as though <code><a class="el" href="classCGAL_1_1Nef__polyhedron__3.html" title="A 3D Nef polyhedron is a subset of the 3-dimensional space that is the result of forming complements ...">Nef_polyhedron_3</a>&lt;<a class="elRef" href="../Kernel_23/structCGAL_1_1Homogeneous.html">Homogeneous</a>&gt;</code> or <code><a class="el" href="classCGAL_1_1Nef__polyhedron__3.html" title="A 3D Nef polyhedron is a subset of the 3-dimensional space that is the result of forming complements ...">Nef_polyhedron_3</a>&lt;<a class="elRef" href="../Kernel_23/structCGAL_1_1Simple__homogeneous.html">Simple_homogeneous</a>&gt;</code> is used. As a result, the input operator of each of these types can read the output.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classCGAL_1_1Nef__polyhedron__3.html" title="A 3D Nef polyhedron is a subset of the 3-dimensional space that is the result of forming complements ...">CGAL::Nef_polyhedron_3</a>&lt;Traits&gt;</code> </dd></dl>

</div>
</div>
<a id="gaf35d6aeb83886b4c84068aad3a2e66d0" name="gaf35d6aeb83886b4c84068aad3a2e66d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf35d6aeb83886b4c84068aad3a2e66d0">◆ </a></span>operator&gt;&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">istream &amp; CGAL::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp; </td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Nef__polyhedron__3.html">CGAL::Nef_polyhedron_3</a>&lt; Traits &gt; &amp; </td>
          <td class="paramname"><em>N</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/IO/Nef_polyhedron_iostream_3.h&gt;</code></p>

<p>This operator reads a Nef polyhedron, which is given in the proprietary file format written by the input operator <em>in</em> and assigns it to <em>N</em>. </p>
<p>It includes the complete incidence structure, the geometric data, and the marks of each item.</p>
<p>It is recommended to use the CGAL kernels <code><a class="elRef" href="../Kernel_23/structCGAL_1_1Homogeneous.html">Homogeneous</a></code>, <code><a class="elRef" href="../Kernel_23/structCGAL_1_1Simple__homogeneous.html">Simple_homogeneous</a></code>, or <code><a class="elRef" href="../Nef_2/classCGAL_1_1Extended__homogeneous.html">Extended_homogeneous</a></code> parametrized with any exact number type that models \( \mathbb{Z}\) (e.g.<code><a class="elRef" href="../Number_types/classCGAL_1_1Gmpz.html">Gmpz</a></code> or <code><a class="elRef" href="../Number_types/classleda__integer.html">leda_integer</a></code>). The input and output iterators of Nef polyhedra parametrized with either of these kernels are compatible as long as the Nef polyhedron is bounded. An unbounded Nef polyhedron can only be read by a Nef polyhedron parametrized with an extended kernel. It is also recommended to use the CGAL stream modifier <code>set_ascii_mode()</code>.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classCGAL_1_1Nef__polyhedron__3.html" title="A 3D Nef polyhedron is a subset of the 3-dimensional space that is the result of forming complements ...">CGAL::Nef_polyhedron_3</a>&lt;Traits&gt;</code> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"></a> 1.9.6 </li>
  </ul>
</div>
</div>
</body>

</html>
