<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/BGL/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 5.6 - CGAL and the Boost Graph Library: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//&amp;lt;![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      }
  }
}
);
//]]&amp;gt;
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.6 - CGAL and the Boost Graph Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_CGAL_and_the_Boost_Graph_Library"></a><a class="anchor" id="chapterBGL"></a> </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Authors</dt><dd>Andreas Fabri, Fernando Cacciola, Philipp Moeller, and Ron Wein</dd></dl>
<p>Many geometric data structures can be interpreted as graphs as they consist of vertices and edges. This is the case for the halfedge data structure, for the polyhedral surface, for the arrangement, and for the 2D triangulation classes. With means of duality one can also interpret faces as vertices and edges between adjacent faces as edges of the dual graph.</p>
<p>The scope of CGAL is geometry and not graph algorithms. Nevertheless, this package provides the necessary classes and functions that enable using the algorithms of the <a href="https://www.boost.org/libs/graph/doc/index.html">Boost Graph Library</a> <a class="el" href="citelist.html#CITEREF_cgal:sll-bgl-02">[4]</a> (BGL for short) with CGAL data structures.</p>
<p>Furthermore, this package extends the BGL by introducing concepts such as <code><a class="el" href="classHalfedgeGraph.html" title="The concept HalfedgeGraph is a refinement of the BGL concept IncidenceGraph and adds the notion of a ...">HalfedgeGraph</a></code> and <code><a class="el" href="classFaceGraph.html" title="The concept FaceGraph refines the concept HalfedgeGraph. It adds the requirements for a graph to expl...">FaceGraph</a></code> allowing to handle <em>halfedges</em> and <em>faces</em>. These concepts reflect the design of the halfedge data structure described in Chapter <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgHalfedgeDS">Halfedge Data Structures</a>, with opposite halfedges and circular sequences of halfedges around vertices and around faces.</p>
<p>This chapter is organized as follows:</p><ul>
<li>The first section, Section <a class="el" href="index.html#BGLA">A Short Introduction to the Boost Graph Library</a>, summarizes the main ideas of the BGL.</li>
<li>Section <a class="el" href="index.html#BGLHeader">Header Files, Namespaces, and Naming Conventions</a> then explains where to find header files and the chosen naming conventions, as we blend two different libraries.</li>
<li>The four following sections give examples on how to use <a class="el" href="namespaceCGAL.html" title="CGAL Namespace. ">CGAL</a> graph and mesh data structures such as <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceMesh">Surface_mesh </a>, <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgPolyhedron">Polyhedron </a>, <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgArrangementOnSurface2">Arrangement_2 </a>, and the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgTriangulation2">2D triangulation </a> classes as models of the BGL concepts.</li>
<li>Starting with Section <a class="el" href="index.html#BGLExtensions">Extensions of the BGL</a>, we introduce new graph concepts, classes, and functions that extend the functionalities of the BGL.</li>
</ul>
<h1><a class="anchor" id="BGLA"></a>
A Short Introduction to the Boost Graph Library</h1>
<p>The algorithms of the BGL operate on models of various <em>graph concepts</em>. The <em>traits class</em> <code>boost::graph_traits</code> enable algorithms to determine the types of vertices and edges (similar to <code>std::iterator_traits</code> for iterators). <em>Free functions</em> that operate on graphs enable algorithms to obtain, for example, the source vertex of an edge, or all edges incident to a vertex. The algorithms use <em>property maps</em> to associate information with vertices and edges. The algorithms enable <em>visitors</em> to register callbacks that are called later on during the execution of the algorithms. Finally, the graph algorithms use the <em>named parameter</em> mechanism, which enables passing the arguments in arbitrary order.</p>
<h2><a class="anchor" id="BGLGraphConcepts"></a>
Graph Concepts</h2>
<p>The BGL introduces several <a href="https://www.boost.org/libs/graph/doc/graph_concepts.html">graph concepts</a>, which have different sets of characteristics and requirements. For example, iterating through all vertices or all edges in a graph, obtaining the outgoing or in-going edges of a vertex, inserting vertices and edges into a graph, and removing vertices and edges from a graph.</p>
<h2><a class="anchor" id="BGLTheGraphTraitsClass"></a>
The Graph Traits Class</h2>
<p>An algorithm operating on a graph model determines types with the help of the traits class <a href="https://www.boost.org/libs/graph/doc/graph_traits.html">boost::graph_traits</a>. Such types are the <code>vertex_descriptor</code>, which is similar to a vertex handle in CGAL data structures, or the <code>edge_descriptor</code>, which is similar to the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/HalfedgeDS.tag:../HalfedgeDS/" href="../HalfedgeDS/classHalfedgeDSHalfedge.html">halfedge handle </a> in the halfedge data structure or to the type <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Triangulation__2.html#ad28c6e0e0e65b8aaecb1ae76d8744b33">Edge </a> in 2D triangulations. There are also iterators, such as the <code>vertex_iterator</code>, which is similar to a vertex iterator in CGAL data structures, and the <code>out_edge_iterator</code>, which is similar to the edge circulator; it enables to iterate through the edges incident to a vertex. The iterators are similar and not equivalent, because their value type is a <code>vertex_descriptor</code>, whereas in CGAL handles, iterators, and circulators all have the same value type, namely the vertex or edge types.</p>
<p>Given a graph type <code>G</code>, definitions of descriptors and iterators look as follows:</p>
<div class="fragment"><div class="line">boost::graph_traits&lt;Graph&gt;::vertex_descriptor vd;</div><div class="line">boost::graph_traits&lt;Graph&gt;::edge_iterator ei;</div><div class="line">...</div></div><!-- fragment --><h2><a class="anchor" id="BGLFreeFunctionsforExploringaGraph"></a>
Free Functions for Exploring a Graph</h2>
<p>Algorithms obtain incidence information in graphs with the help of global functions such as:</p><ul>
<li><code>std::pair&lt;vertex_iterator,vertex_iterator&gt; vertices(const Graph&amp; g);</code> to obtain an iterator range providing access to all the vertices, or</li>
<li><code>int num_vertices(const Graph&amp;);</code> to obtain the number of vertices of a graph, or</li>
<li><code>vertex_descriptor source(edge_descriptor, const Graph&amp;);</code> to obtain the source vertex of an edge.</li>
</ul>
<p>Note, that the way we have written the types is a simplification; in reality, the signature of the first of the above functions is:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Graph&gt;::vertex_iterator vertex_iterator;</div><div class="line">std::pair&lt;vertex_iterator,vertex_iterator&gt; vertices(<span class="keyword">const</span> Graph&amp; g);</div></div><!-- fragment --><h2><a class="anchor" id="BGLPropertyMaps"></a>
Property Maps</h2>
<p>Another feature extensively used in the BGL is the <em>property map</em>, which is offered by the <a href="https://www.boost.org/libs/property_map/doc/property_map.html">Boost Property Map Library</a>. Property maps are a general purpose interface for mapping key objects to corresponding value objects.</p>
<p>The BGL uses property maps to associate information with vertices and edges. This mechanism uses a traits class (<code>boost::property_traits</code>) and free functions to read (<code>get</code>) and write (<code>put</code>) information in vertices, edges, and also in halfedges and faces for models of the CGAL graph concepts. For example, the BGL Dijksta's shortest path algorithm writes the predecessor of each vertex, as well as the distance to the source in such a property map.</p>
<p>Some default property maps are associated with the graph types. They are called <em>internal property maps</em> and can be retrieved using an overload of the function <code>get()</code>. For example, </p><div class="fragment"><div class="line">pm = <span class="keyword">get</span>(boost::vertex_index, g)</div></div><!-- fragment --><p> returns a property map that associates an index in the range <code>[0, num_vertices(g))</code> with each vertex of the graph. This reduces the number of parameters to pass. The data itself may be stored in the vertex or the edge, or it may be stored in an external data structure, or it may be computed on the fly. This is an implementation detail of a particular property map.</p>
<p>See also Chapter <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgPropertyMap">CGAL and Boost Property Maps</a>.</p>
<h2><a class="anchor" id="BGLVisitors"></a>
Visitors</h2>
<p>Visitors are objects that provide functions to be called at specified event points by the algorithm that they visit. The functions as well as the event points are algorithm-specific. Examples of such event points in graph algorithms are when a vertex is traversed the first time, or when all outgoing edges of a vertex have been traversed.<br />
</p>
<p>See also Section <a href="https://www.boost.org/libs/graph/doc/visitor_concepts.html">Visitor Concepts</a> in the BGL manual.</p>
<h2><a class="anchor" id="BGLNamedParameters"></a>
Named Parameters</h2>
<p>The notion of <em>named parameters</em> was introduced in the BGL, and allow the user to specify only those parameters which are really needed, by name, making the parameter ordering unimportant. See also <a href="https://www.boost.org/libs/graph/doc/bgl_named_params.html">this page</a> in the manual of the BGL for more information.</p>
<p>Say there is a function <code>f()</code> that takes 3 parameters called name, age and gender, and you have variables <code>n</code>, <code>a</code> and <code>g</code> to pass as parameters to that function. Without named parameters, you would call it like this: <code>f(n,a,g)</code>, whereas with named parameters, you call it like this: <code>f(name(n).age(a).gender(g))</code>. That is, you give each parameter a name by wrapping it into a function whose name matches that of the parameter. The entire list of named parameters is really a composition of function calls separated by a dot ("."). Thus, if the function takes a mix of mandatory and named parameters, you use a comma to separate the last non-named parameter from the first named parameters, like this: </p><div class="fragment"><div class="line">f(non_named_par0, non_named_par1, name(n).age(a).gender(g))</div></div><!-- fragment --><p> When you use named parameters, the ordering is irrelevant, so <code>f(name(n).age(a).gender(g))</code> is equivalent to <code>f(age(a).gender(g).name(n))</code>, and you can just omit any named parameter that has a default value.</p>
<p>The sequence of named parameters should start with <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL_1_1parameters.html">CGAL::parameters</a>::</code>.</p>
<h3><a class="anchor" id="BGLNamedParametersExample"></a>
Example</h3>
<p>Below is a sample call of a function that uses the optional BGL named parameters.</p>
<div class="fragment"><div class="line"><span class="comment">// pmesh : polygon mesh with patches to be refined</span></div><div class="line"><span class="comment">// faces : the range of faces defining the patches to refine</span></div><div class="line"><span class="comment">// faces_out : output iterator into which descriptors of new faces are put</span></div><div class="line"><span class="comment">// vertices_out : output iterator into which descriptors of new vertices are put</span></div><div class="line"><span class="comment">// vertex_point_map : the property map with the points associated to the vertices of `pmesh`</span></div><div class="line"><span class="comment">// density_control_factor : factor to control density of the output mesh</span></div><div class="line"><a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__meshing__grp.html#gafd90c169a7c17a1e503651f59a6dc57b">refine</a>(pmesh,</div><div class="line">       faces,</div><div class="line">       faces_out,</div><div class="line">       vertices_out,</div><div class="line">       CGAL::parameters::vertex_point_map(vpmap)</div><div class="line">                        .density_control_factor(d));</div></div><!-- fragment --><h1><a class="anchor" id="BGLHeader"></a>
Header Files, Namespaces, and Naming Conventions</h1>
<p>This package provides the necessary classes and functions that enable using CGAL data structures as models of the BGL graph concepts. To this end, we offer partial specializations of the <code>boost::graph_traits&lt;Graph&gt;</code> for various CGAL packages. For each such package, denoted <code>PACKAGE</code>, the partial specializations live in the namespace <code>boost</code> and are located in the header file <code>CGAL/boost/graph/graph_traits_PACKAGE.h</code>. Free functions are in the namespace <code><a class="el" href="namespaceCGAL.html" title="CGAL Namespace. ">CGAL</a></code>, and the compiler uses argument-dependent lookup to find them. Euler operations, described in Section <a class="el" href="index.html#BGLEulerOperations">Euler Operations</a>, are in the namespace <code>CGAL::Euler</code>, as the function <code><a class="el" href="classMutableFaceGraph.html#abf15bb91e6cdafb057514db8acf38a08">remove_face()</a></code> is at the same time a low-level and an Euler operation. Concerning the naming conventions, we have to use those of the BGL, as to fulfill the requirements of the concepts defined in the BGL.</p>
<p>Note that these partial specializations are often providing more than is required, making these classes not only models of the graph concepts of the BGL, but also models of the <a class="el" href="namespaceCGAL.html" title="CGAL Namespace. ">CGAL</a> graph concepts, that will be described in detail in Section <a class="el" href="index.html#BGLExtensions">Extensions of the BGL</a>. Correspondence tables between the types of a CGAL data structure and their BGL equivalents can be found in the <a class="el" href="group__PkgBGLTraits.html">Specializations of boost::graph_traits</a> documentation page.</p>
<p>We present in the following sections some examples of utilization of some CGAL data structures as BGL graphs.</p>
<h1><a class="anchor" id="BGLSurface_mesh"></a>
The Class Surface_mesh as Model of the Boost Graph Concept</h1>
<p>The class <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">Surface_mesh</a></code> is a model of most of the graph concepts of the BGL as well as the concepts provided by CGAL. A complete list can be found in the documentation of <a class="el" href="group__PkgBGLTraits.html#BGLSMGT">boost::graph_traits </a>. The examples show how to use some of the BGL algorithms with <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">Surface_mesh</a></code> and show how to use the concepts provided by CGAL to implement a simple algorithm.</p>
<h2><a class="anchor" id="BGLExampleMinimumSpanningTreeofaSurfaceMesh"></a>
Example: Minimum Spanning Tree of a Surface_mesh</h2>
<p>The following example program computes the minimum spanning tree on a surface mesh. More examples can be found in Chapters <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceMeshSimplification">Triangulated Surface Mesh Simplification</a>, <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceMeshSegmentation">Triangulated Surface Mesh Segmentation</a>, and <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceMeshDeformation">Triangulated Surface Mesh Deformation</a>.</p>
<p>The surface mesh class uses integer indices to address vertices and edges, and it comes with a built-in property mechanism that maps nicely on the BGL.</p>
<p><br />
<b>File</b> <a class="el" href="BGL_surface_mesh_2prim_8cpp-example.html">BGL_surface_mesh/prim.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/prim_minimum_spanning_tree.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>                       <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                                      Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point&gt;</a>                            Mesh;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::vertex_descriptor vertex_descriptor;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string filename = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/prim.off"</span>);</div><div class="line"></div><div class="line">  Mesh P;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__IO__grp.html#gac5b3295bd1b6375628a46d1fbaf7e881">CGAL::IO::read_polygon_mesh</a>(filename, P))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line">  Mesh::Property_map&lt;vertex_descriptor,vertex_descriptor&gt; <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__STLAlgos.html#ga6c5d40930db429775066babac7c35d7f">predecessor</a>;</div><div class="line">  predecessor = P.add_property_map&lt;vertex_descriptor,vertex_descriptor&gt;(<span class="stringliteral">"v:predecessor"</span>).first;</div><div class="line"></div><div class="line">  boost::prim_minimum_spanning_tree(P, predecessor, boost::root_vertex(*vertices(P).first));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"#VRML V2.0 utf8\n"</span></div><div class="line">    <span class="stringliteral">"DirectionalLight {\n"</span></div><div class="line">    <span class="stringliteral">"direction 0 -1 0\n"</span></div><div class="line">    <span class="stringliteral">"}\n"</span></div><div class="line">    <span class="stringliteral">"Shape {\n"</span></div><div class="line">    <span class="stringliteral">"  appearance Appearance {\n"</span></div><div class="line">    <span class="stringliteral">"    material Material { emissiveColor 1 0 0}}\n"</span></div><div class="line">    <span class="stringliteral">"    geometry\n"</span></div><div class="line">    <span class="stringliteral">"    IndexedLineSet {\n"</span></div><div class="line">    <span class="stringliteral">"      coord Coordinate {\n"</span></div><div class="line">    <span class="stringliteral">"        point [ \n"</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(vertex_descriptor vd : vertices(P)){</div><div class="line">    std::cout &lt;&lt;  <span class="stringliteral">"        "</span> &lt;&lt; P.point(vd) &lt;&lt; <span class="stringliteral">"\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"        ]\n"</span></div><div class="line">    <span class="stringliteral">"     }\n"</span></div><div class="line">    <span class="stringliteral">"      coordIndex [\n"</span>;</div><div class="line">  <span class="keywordflow">for</span>(vertex_descriptor vd : vertices(P)){</div><div class="line">    <span class="keywordflow">if</span>(predecessor[vd]!=vd){</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">"      "</span> &lt;&lt; std::size_t(vd) &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; std::size_t(predecessor[vd]) &lt;&lt;  <span class="stringliteral">", -1\n"</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"]\n"</span></div><div class="line">    <span class="stringliteral">"  }#IndexedLineSet\n"</span></div><div class="line">    <span class="stringliteral">"}# Shape\n"</span>;</div><div class="line"></div><div class="line">  P.remove_property_map(predecessor);</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="BGLPolyhedral"></a>
The Class Polyhedron_3 as Model of the Boost Graph Concept</h1>
<p>The class <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">Polyhedron_3</a></code> is a model of most of the graph concepts of the BGL as well as the concepts provided by CGAL. A complete list can be found in the documentation of <a class="el" href="group__PkgBGLTraits.html#BGLPolyGT">boost::graph_traits </a>. The examples show how to use some of the BGL algorithms with <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">Polyhedron_3</a></code> and show how to use the concepts provided by CGAL to implement a simple algorithm.</p>
<h2><a class="anchor" id="BGLExampleMinimumSpanningTreeofaPolyhedral"></a>
Example: Minimum Spanning Tree of a Polyhedral Surface</h2>
<p>The following example program computes the minimum spanning tree on a polyhedral surface. More examples can be found in the Chapter <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceMeshSimplification">Triangulated Surface Mesh Simplification</a>.</p>
<p><br />
<b>File</b> <a class="el" href="BGL_polyhedron_3_2kruskal_8cpp-example.html">BGL_polyhedron_3/kruskal.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/kruskal_min_spanning_tree.h&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>                       Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a>                                     Vector;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                                      Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;Kernel&gt;</a>                           Polyhedron;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt;::vertex_descriptor vertex_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt;::vertex_iterator   vertex_iterator;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt;::edge_descriptor   edge_descriptor;</div><div class="line"></div><div class="line"><span class="comment">// The BGL makes heavy use of indices associated to the vertices</span></div><div class="line"><span class="comment">// We use a std::map to store the index</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::map&lt;vertex_descriptor,int&gt; Vertex_index_map;</div><div class="line">Vertex_index_map vertex_index_map;</div><div class="line"></div><div class="line"><span class="comment">// A std::map is not a property map, because it is not lightweight</span></div><div class="line"><span class="keyword">typedef</span> boost::associative_property_map&lt;Vertex_index_map&gt; Vertex_index_pmap;</div><div class="line">Vertex_index_pmap vertex_index_pmap(vertex_index_map);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">kruskal(<span class="keyword">const</span> Polyhedron&amp; P)</div><div class="line">{</div><div class="line">  <span class="comment">// associate indices to the vertices</span></div><div class="line">  vertex_iterator vb, ve;</div><div class="line">  <span class="keywordtype">int</span> index = 0;</div><div class="line"></div><div class="line">  <span class="comment">// boost::tie assigns the first and second element of the std::pair</span></div><div class="line">  <span class="comment">// returned by boost::vertices to the variables vb and ve</span></div><div class="line">  <span class="keywordflow">for</span>(boost::tie(vb, ve)=vertices(P); vb!=ve; ++vb){</div><div class="line">    vertex_index_pmap[*vb]= index++;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// We use the default edge weight which is the length of the edge</span></div><div class="line">  <span class="comment">// This property map is defined in graph_traits_Polyhedron_3.h</span></div><div class="line"></div><div class="line">  <span class="comment">// In the function call you can see a named parameter: vertex_index_map</span></div><div class="line">  std::list&lt;edge_descriptor&gt; mst;</div><div class="line"></div><div class="line">  boost::kruskal_minimum_spanning_tree(P,</div><div class="line">                                       std::back_inserter(mst),</div><div class="line">                                       boost::vertex_index_map(vertex_index_pmap));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"#VRML V2.0 utf8\n"</span></div><div class="line">    <span class="stringliteral">"Shape {\n"</span></div><div class="line">    <span class="stringliteral">"  appearance Appearance {\n"</span></div><div class="line">    <span class="stringliteral">"    material Material { emissiveColor 1 0 0}}\n"</span></div><div class="line">    <span class="stringliteral">"    geometry\n"</span></div><div class="line">    <span class="stringliteral">"    IndexedLineSet {\n"</span></div><div class="line">    <span class="stringliteral">"      coord Coordinate {\n"</span></div><div class="line">    <span class="stringliteral">"        point [ \n"</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(boost::tie(vb, ve) = vertices(P); vb!=ve; ++vb){</div><div class="line">    std::cout &lt;&lt;  <span class="stringliteral">"        "</span> &lt;&lt; (*vb)-&gt;point() &lt;&lt; <span class="stringliteral">"\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"        ]\n"</span></div><div class="line">               <span class="stringliteral">"     }\n"</span></div><div class="line">    <span class="stringliteral">"      coordIndex [\n"</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(std::list&lt;edge_descriptor&gt;::iterator it = mst.begin(); it != mst.end(); ++it)</div><div class="line">  {</div><div class="line">    edge_descriptor e = *it ;</div><div class="line">    vertex_descriptor s = source(e,P);</div><div class="line">    vertex_descriptor t = target(e,P);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"      "</span> &lt;&lt; vertex_index_pmap[s] &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; vertex_index_pmap[t] &lt;&lt;  <span class="stringliteral">", -1\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"]\n"</span></div><div class="line">    <span class="stringliteral">"  }#IndexedLineSet\n"</span></div><div class="line">    <span class="stringliteral">"}# Shape\n"</span>;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">  Polyhedron P;</div><div class="line">  Point a(1,0,0);</div><div class="line">  Point b(0,1,0);</div><div class="line">  Point c(0,0,1);</div><div class="line">  Point d(0,0,0);</div><div class="line"></div><div class="line">  P.make_tetrahedron(a,b,c,d);</div><div class="line"></div><div class="line">  kruskal(P);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="BGLExampleUsingVerticesandEdgeswithanID"></a>
Example: Using Vertices, and Edges with an ID</h2>
<p>The following example program shows a call to the BGL Kruskal's minimum spanning tree algorithm accessing the <code>id()</code> field stored in a polyhedron vertex.</p>
<p>The main function illustrates the access to the <code>id()</code> field.</p>
<p><br />
<b>File</b> <a class="el" href="BGL_polyhedron_3_2kruskal_with_stored_id_8cpp-example.html">BGL_polyhedron_3/kruskal_with_stored_id.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_items_with_id_3.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/kruskal_min_spanning_tree.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>                               Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                                              Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;Kernel,CGAL::Polyhedron_items_with_id_3&gt;</a>  Polyhedron;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt;::vertex_descriptor vertex_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt;::vertex_iterator   vertex_iterator;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt;::edge_descriptor   edge_descriptor;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">kruskal( <span class="keyword">const</span> Polyhedron&amp; P)</div><div class="line">{</div><div class="line"></div><div class="line">  <span class="comment">// We use the default edge weight which is the length of the edge</span></div><div class="line">  <span class="comment">// This property map is defined in graph_traits_Polyhedron_3.h</span></div><div class="line"></div><div class="line">  <span class="comment">// This function call requires a vertex_index_map named parameter which</span></div><div class="line">  <span class="comment">// when  ommitted defaults to "get(vertex_index,graph)".</span></div><div class="line">  <span class="comment">// That default works here because the vertex type has an "id()" method</span></div><div class="line">  <span class="comment">// field which is used by the vertex_index internal property.</span></div><div class="line">  std::list&lt;edge_descriptor&gt; mst;</div><div class="line">  boost::kruskal_minimum_spanning_tree(P,std::back_inserter(mst));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"#VRML V2.0 utf8\n"</span></div><div class="line">    <span class="stringliteral">"Shape {\n"</span></div><div class="line">    <span class="stringliteral">"appearance Appearance {\n"</span></div><div class="line">    <span class="stringliteral">"material Material { emissiveColor 1 0 0}}\n"</span></div><div class="line">    <span class="stringliteral">"geometry\n"</span></div><div class="line">    <span class="stringliteral">"IndexedLineSet {\n"</span></div><div class="line">    <span class="stringliteral">"coord Coordinate {\n"</span></div><div class="line">    <span class="stringliteral">"point [ \n"</span>;</div><div class="line"></div><div class="line">  vertex_iterator vb, ve;</div><div class="line">  <span class="keywordflow">for</span>(boost::tie(vb,ve) = vertices(P); vb!=ve; ++vb){</div><div class="line">    std::cout &lt;&lt; (*vb)-&gt;point() &lt;&lt; <span class="stringliteral">"\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"]\n"</span></div><div class="line">    <span class="stringliteral">"}\n"</span></div><div class="line">    <span class="stringliteral">"coordIndex [\n"</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(std::list&lt;edge_descriptor&gt;::iterator it = mst.begin(); it != mst.end(); ++it){</div><div class="line">    std::cout &lt;&lt; source(*it,P)-&gt;id()</div><div class="line">              &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; target(*it,P)-&gt;id() &lt;&lt;  <span class="stringliteral">", -1\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"]\n"</span></div><div class="line">    <span class="stringliteral">"}#IndexedLineSet\n"</span></div><div class="line">    <span class="stringliteral">"}# Shape\n"</span>;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">  Polyhedron P;</div><div class="line"></div><div class="line">  Point a(1,0,0);</div><div class="line">  Point b(0,1,0);</div><div class="line">  Point c(0,0,1);</div><div class="line">  Point d(0,0,0);</div><div class="line"></div><div class="line">  P.make_tetrahedron(a,b,c,d);</div><div class="line"></div><div class="line">  <span class="comment">// associate indices to the vertices using the "id()" field of the vertex.</span></div><div class="line">  vertex_iterator vb, ve;</div><div class="line">  <span class="keywordtype">int</span> index = 0;</div><div class="line"></div><div class="line">  <span class="comment">// boost::tie assigns the first and second element of the std::pair</span></div><div class="line">  <span class="comment">// returned by boost::vertices to the variables vit and ve</span></div><div class="line">  <span class="keywordflow">for</span>(boost::tie(vb,ve)=vertices(P); vb!=ve; ++vb ){</div><div class="line">    vertex_descriptor  vd = *vb;</div><div class="line">    vd-&gt;id() = index++;</div><div class="line">  }</div><div class="line"></div><div class="line">  kruskal(P);</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="BGLTriangulations"></a>
Triangulations as Models of the Boost Graph Concept</h1>
<p>Triangulations have vertices and faces, allowing for a direct translation as a graph. A halfedge is defined as a pair of a face handle and the index of the edge. A complete list can be found in the documentation of <a class="el" href="group__PkgBGLTraits.html#BGLT2GT">boost::graph_traits </a>.</p>
<p>A classical example for an algorithm that is a combination of computational geometry and graph theory is the <em>Euclidean Minimum Spanning Tree</em> for a point set in the plane. It can be computed by running the minimum spanning tree algorithm on a Delaunay triangulation of the point set.</p>
<h2><a class="anchor" id="BGLExampleEuclideanMinimumSpanningTree"></a>
Example: Euclidean Minimum Spanning Tree</h2>
<p>In the following example we create a Delaunay triangulation and run Kruskal's minimum spanning tree algorithm on it. Because the vertex handles of the triangulation are not indices in an array, we have to provide a property map that maps vertex handles to integers in the range <code>[0, t.number_of_vertices())</code>.</p>
<p><br />
<b>File</b> <a class="el" href="BGL_triangulation_2_2emst_8cpp-example.html">BGL_triangulation_2/emst.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Delaunay_triangulation_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/graph_traits_Delaunay_triangulation_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/kruskal_min_spanning_tree.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>         K;</div><div class="line"><span class="keyword">typedef</span> K::Point_2                                                  Point;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2&lt;K&gt;</a>                           Triangulation;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Triangulation&gt;::vertex_descriptor       vertex_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Triangulation&gt;::vertex_iterator         vertex_iterator;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Triangulation&gt;::edge_descriptor         edge_descriptor;</div><div class="line"></div><div class="line"><span class="comment">// The BGL makes use of indices associated to the vertices</span></div><div class="line"><span class="comment">// We use a std::map to store the index</span></div><div class="line"><span class="keyword">typedef</span> std::map&lt;vertex_descriptor,int&gt;                             VertexIndexMap;</div><div class="line"></div><div class="line"><span class="comment">// A std::map is not a property map, because it is not lightweight</span></div><div class="line"><span class="keyword">typedef</span> boost::associative_property_map&lt;VertexIndexMap&gt;             VertexIdPropertyMap;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc,<span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename = (argc &gt; 1) ? argv[1] : <span class="stringliteral">"data/points.xy"</span>;</div><div class="line">  std::ifstream input(filename);</div><div class="line">  Triangulation tr;</div><div class="line"></div><div class="line">  Point p;</div><div class="line">  <span class="keywordflow">while</span>(input &gt;&gt; p)</div><div class="line">    tr.insert(p);</div><div class="line"></div><div class="line">  <span class="comment">// Associate indices to the vertices</span></div><div class="line">  VertexIndexMap vertex_id_map;</div><div class="line">  VertexIdPropertyMap vertex_index_pmap(vertex_id_map);</div><div class="line">  <span class="keywordtype">int</span> index = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(vertex_descriptor vd : vertices(tr))</div><div class="line">    vertex_id_map[vd] = index++;</div><div class="line"></div><div class="line">  <span class="comment">// We use the default edge weight which is the squared length of the edge</span></div><div class="line">  <span class="comment">// This property map is defined in graph_traits_Triangulation_2.h</span></div><div class="line"></div><div class="line">  <span class="comment">// In the function call you can see a named parameter: vertex_index_map</span></div><div class="line">  std::list&lt;edge_descriptor&gt; mst;</div><div class="line">  boost::kruskal_minimum_spanning_tree(tr, std::back_inserter(mst),</div><div class="line">                                       vertex_index_map(vertex_index_pmap));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The edges of the Euclidean mimimum spanning tree:"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span>(edge_descriptor ed : mst)</div><div class="line">  {</div><div class="line">    vertex_descriptor svd = source(ed, tr);</div><div class="line">    vertex_descriptor tvd = target(ed, tr);</div><div class="line">    Triangulation::Vertex_handle sv = svd;</div><div class="line">    Triangulation::Vertex_handle tv = tvd;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"[ "</span> &lt;&lt; sv-&gt;point() &lt;&lt; <span class="stringliteral">"  |  "</span> &lt;&lt; tv-&gt;point() &lt;&lt; <span class="stringliteral">" ] "</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="BGLExampleStoringtheVertexIDintheVertex"></a>
Example: Storing the Vertex ID in the Vertex</h2>
<p>The algorithms of the BGL extensively use of the indices of vertices. In the previous example we stored the indices in a <code>std::map</code> and turned that map in a property map. This property map was then passed as argument to the shortest path function.</p>
<p>If the user does not pass explicitly a property map, the graph algorithms use the property map returned by the call <code>get(boost::vertex_index,ft)</code>. This property map assumes that the vertex has a member function <code>id()</code> that returns a reference to an int. Therefore CGAL offers a class <code><a class="el" href="classCGAL_1_1Triangulation__vertex__base__with__id__2.html" title="The class Triangulation_vertex_base_with_id_2 is a model of the concept TriangulationVertexBase_2, the base vertex of a 2D-triangulation. ">Triangulation_vertex_base_with_id_2</a></code>. It is in the user's responsibility to set the indices properly.</p>
<p>The example further illustrates that the graph traits also works for the Delaunay triangulation.</p>
<p><br />
<b>File</b> <a class="el" href="BGL_triangulation_2_2dijkstra_with_internal_properties_8cpp-example.html">BGL_triangulation_2/dijkstra_with_internal_properties.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Delaunay_triangulation_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Triangulation_vertex_base_with_id_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/graph_traits_Delaunay_triangulation_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/dijkstra_shortest_paths.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>             K;</div><div class="line"><span class="keyword">typedef</span> K::Point_2                                                      Point;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Triangulation__vertex__base__with__id__2.html">CGAL::Triangulation_vertex_base_with_id_2&lt;K&gt;</a>                    Tvb;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Triangulation__face__base__2.html">CGAL::Triangulation_face_base_2&lt;K&gt;</a>                              Tfb;</div><div class="line"><span class="keyword">typedef</span> CGAL::Triangulation_data_structure_2&lt;Tvb, Tfb&gt;                  Tds;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2&lt;K, Tds&gt;</a>                          Triangulation;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Triangulation&gt;::vertex_descriptor           vertex_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Triangulation&gt;::vertex_iterator             vertex_iterator;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::property_map&lt;Triangulation, boost::vertex_index_t&gt;::type VertexIdPropertyMap;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc,<span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename = (argc &gt; 1) ? argv[1] : <span class="stringliteral">"data/points.xy"</span>;</div><div class="line">  std::ifstream input(filename);</div><div class="line">  Triangulation tr;</div><div class="line"></div><div class="line">  Point p;</div><div class="line">  <span class="keywordflow">while</span>(input &gt;&gt; p)</div><div class="line">    tr.insert(p);</div><div class="line"></div><div class="line">  <span class="comment">// associate indices to the vertices</span></div><div class="line">  <span class="keywordtype">int</span> index = 0;</div><div class="line">  <span class="keywordflow">for</span>(vertex_descriptor vd : vertices(tr))</div><div class="line">    vd-&gt;id()= index++;</div><div class="line"></div><div class="line">  VertexIdPropertyMap vertex_index_pmap = <span class="keyword">get</span>(boost::vertex_index, tr);</div><div class="line"></div><div class="line">  <span class="comment">// Dijkstra's shortest path needs property maps for the predecessor and distance</span></div><div class="line">  std::vector&lt;vertex_descriptor&gt; <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__STLAlgos.html#ga6c5d40930db429775066babac7c35d7f">predecessor</a>(num_vertices(tr));</div><div class="line">  boost::iterator_property_map&lt;std::vector&lt;vertex_descriptor&gt;::iterator, VertexIdPropertyMap&gt;</div><div class="line">    predecessor_pmap(predecessor.begin(), vertex_index_pmap);</div><div class="line"></div><div class="line">  std::vector&lt;double&gt; distance(num_vertices(tr));</div><div class="line">  boost::iterator_property_map&lt;std::vector&lt;double&gt;::iterator, VertexIdPropertyMap&gt;</div><div class="line">    distance_pmap(distance.begin(), vertex_index_pmap);</div><div class="line"></div><div class="line">  vertex_descriptor source = *vertices(tr).first;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"\nStart dijkstra_shortest_paths at "</span> &lt;&lt; source-&gt;point() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  boost::dijkstra_shortest_paths(tr, source, distance_map(distance_pmap)</div><div class="line">                                            .predecessor_map(predecessor_pmap));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(vertex_descriptor vd : vertices(tr))</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; vd-&gt;point() &lt;&lt; <span class="stringliteral">" ["</span> &lt;&lt; vd-&gt;id() &lt;&lt; <span class="stringliteral">"] "</span>;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">" has distance = "</span>  &lt;&lt; <span class="keyword">get</span>(distance_pmap,vd) &lt;&lt; <span class="stringliteral">" and predecessor "</span>;</div><div class="line"></div><div class="line">    vd = <span class="keyword">get</span>(predecessor_pmap,vd);</div><div class="line">    std::cout &lt;&lt; vd-&gt;point() &lt;&lt; <span class="stringliteral">" ["</span> &lt;&lt; vd-&gt;id() &lt;&lt; <span class="stringliteral">"]\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="BGLArrangements"></a>
Arrangements as Models of the Boost Graph Concept</h1>
<p>CGAL offers a partial specialization of the boost graph traits for its arrangement class as well as for its dual graph.</p>
<h2><a class="anchor" id="arr_sssecbgl_primal"></a>
Example for the Arrangement as Graph</h2>
<p>Arrangement instances are adapted to <em>boost</em> graphs by specializing the <code>boost::graph_traits</code> template for <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> instances. The graph-traits states the graph concepts that the arrangement class models (see below) and defines the types required by these concepts.</p>
<p>In this specialization the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> vertices correspond to the graph vertices, where two vertices are adjacent if there is at least one halfedge connecting them. More precisely, <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#a7cdc734c8b7109fe4f62b2467d05b5c3">Arrangement_2::Vertex_handle</a></code> is the graph-vertex type, while <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#adf9ae7012e73ea8f327ab59515b00828">Arrangement_2::Halfedge_handle</a></code> is the graph-edge type. As halfedges are directed, we consider the graph to be directed as well. Moreover, as several interior-disjoint \( x\)-monotone curves (say circular arcs) may share two common endpoints, inducing an arrangement with two vertices that are connected with several edges, we allow parallel edges in our <em>boost</em> graph.</p>
<p>Given an <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> instance, we can efficiently traverse its vertices and halfedges. Thus, the arrangement graph is a model of the concepts <code><a class="el" href="classVertexListGraph.html" title="Concept from the Boost Graph Library. See https://www.boost.org/libs/graph/doc/VertexListGraph.html. ">VertexListGraph</a></code> and <code><a class="el" href="classEdgeListGraph.html" title="Concept from the Boost Graph Library. See https://www.boost.org/libs/graph/doc/EdgeListGraph.html. ">EdgeListGraph</a></code> introduced by the BGL. At the same time, we use an iterator adapter of the circulator over the halfedges incident to a vertex (<code><a class="el" href="classCGAL_1_1Halfedge__around__target__circulator.html" title="A bidirectional circulator with value type boost::graph_traits&lt;Graph&gt;::halfedge_descriptor over all h...">Halfedge_around_target_circulator</a></code> - see Section <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/index.html#arr_sssectr_vertex">Traversal Methods for an Arrangement Vertex</a> of the chapter on arrangements), so it is possible to go over the ingoing and outgoing edges of a vertex in linear time. Thus, our arrangement graph is a model of the concept <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classBidirectionalGraph.html">BidirectionalGraph</a></code> (this concept refines <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classIncidenceGraph.html">IncidenceGraph</a></code>, which requires only the traversal of outgoing edges).</p>
<p>It is important to notice that the vertex descriptors we use are <code>Vertex_handle</code> objects and <em>not</em> vertex indices. However, in order to gain more efficiency in most BGL algorithm, it is better to have them indexed \( 0, 1, \ldots, (n-1)\), where \( n\) is the number of vertices. We therefore introduce the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__vertex__index__map.html">Arr_vertex_index_map</a>&lt;Arrangement&gt;</code> class-template, which maintains a mapping of vertex handles to indices, as required by the BGL. An instance of this class must be attached to a valid arrangement vertex when it is created. It uses the notification mechanism (see Section <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/index.html#arr_ssecnotif">The Notification Mechanism</a>) to automatically maintain the mapping of vertices to indices, even when new vertices are inserted into the arrangement or existing vertices are removed.</p>
<p>A complete description of the types correspondences can be found in the documentation of <a class="el" href="group__PkgBGLTraits.html#BGLArgtGT">boost::graph_traits </a>.</p>
<p>In most algorithm provided by the BGL, the output is given by <em>property maps</em>, such that each map entry corresponds to a vertex. For example, when we compute the shortest paths from a given source vertex \( s\) to all other vertices we can obtain a map of distances and a map of predecessors - namely for each \( v\) vertex we have its distance from \( s\) and a descriptor of the vertex that precedes \( v\) in the shortest path from \( s\). If the vertex descriptors are simply indices, one can use vectors to efficiently represent the property maps. As this is not the case with the arrangement graph, we offer the <code>Arr_vertex_property_map&lt;Arrangement,Type&gt;</code> template allows for an efficient mapping of <code>Vertex_handle</code> objects to properties of type <code>Type</code>. Note however that unlike the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__vertex__index__map.html">Arr_vertex_index_map</a></code> class, the vertex property-map class is not kept synchronized with the number of vertices in the arrangement, so it should not be reused in calls to the BGL functions in case the arrangement is modified in between these calls.</p>
<p><a class="anchor" id="fig__figex_bgl"></a></p><div class="image">
<img src="ex_bgl.png" alt="ex_bgl.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__figex_bgl">Figure 102.1</a> An arrangement of 7 line segments, as constructed by <code>bgl_primal_adapter.cpp</code> and <code>bgl_dual_adapter.cpp</code>. The breadth-first visit times for the arrangement faces, starting from the unbounded face \( f_0\), are shown in brackets.  </div> <br /> 
<p>In the following example we construct an arrangement of 7 line segments, as shown in <a class="el" href="index.html#fig__figex_bgl">Figure 102.1</a>, then use the BGL Dijkstra's shortest-paths algorithm to compute the graph distance of all vertices from the leftmost vertex in the arrangement \( v_0\). Note the usage of the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__vertex__index__map.html">Arr_vertex_index_map</a></code> and the <code>Arr_vertex_property_map</code> classes. The latter one, instantiated by the type <code>double</code> is used to map vertices to their distances from \( v_0\).</p>
<p><br />
<b>File</b> <a class="el" href="BGL_arrangement_2_2primal_8cpp-example.html">BGL_arrangement_2/primal.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Adapting an arrangement to a BGL graph.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_rational_nt.h"</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_segment_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/graph_traits_Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_vertex_index_map.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/dijkstra_shortest_paths.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;Number_type&gt;</a>                    Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__segment__traits__2.html">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</a>              Traits_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Point_2                               Point_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::X_monotone_curve_2                    Segment_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2&gt;</a>                   Arrangement_2;</div><div class="line"></div><div class="line"><span class="comment">// A functor used to compute the length of an edge.</span></div><div class="line"><span class="keyword">class </span>Edge_length_func</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">  <span class="comment">// Boost property type definitions:</span></div><div class="line">  <span class="keyword">typedef</span> boost::readable_property_map_tag        category;</div><div class="line">  <span class="keyword">typedef</span> <span class="keywordtype">double</span>                                  value_type;</div><div class="line">  <span class="keyword">typedef</span> value_type                              reference;</div><div class="line">  <span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#adf9ae7012e73ea8f327ab59515b00828">Arrangement_2::Halfedge_handle</a>          key_type;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> operator()(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#adf9ae7012e73ea8f327ab59515b00828">Arrangement_2::Halfedge_handle</a> e)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>     x1 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1f1bcd74fce34fd532445590bbda5cd5">CGAL::to_double</a> (e-&gt;source()-&gt;point().x());</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>     y1 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1f1bcd74fce34fd532445590bbda5cd5">CGAL::to_double</a> (e-&gt;source()-&gt;point().y());</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>     x2 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1f1bcd74fce34fd532445590bbda5cd5">CGAL::to_double</a> (e-&gt;target()-&gt;point().x());</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>     y2 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1f1bcd74fce34fd532445590bbda5cd5">CGAL::to_double</a> (e-&gt;target()-&gt;point().y());</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>     diff_x = x2 - x1;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>     diff_y = y2 - y1;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">std::sqrt</a>(diff_x*diff_x + diff_y*diff_y);</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> <span class="keyword">get</span>(<span class="keyword">const</span> Edge_length_func&amp; <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__measure__grp.html#gaaffc67e631d83a7da4b1096b782ead94">edge_length</a>, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#adf9ae7012e73ea8f327ab59515b00828">Arrangement_2::Halfedge_handle</a> e)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__measure__grp.html#gaaffc67e631d83a7da4b1096b782ead94">edge_length</a>(e);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Arrangement_2   arr;</div><div class="line"></div><div class="line">  <span class="comment">// Construct an arrangement of seven intersecting line segments.</span></div><div class="line">  <span class="comment">// We keep a handle for the vertex v_0 that corresponds to the point (1,1).</span></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#adf9ae7012e73ea8f327ab59515b00828">Arrangement_2::Halfedge_handle</a>  e =</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a> (arr, Segment_2 (Point_2 (1, 1),</div><div class="line">                                                   Point_2 (7, 1)));</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#a7cdc734c8b7109fe4f62b2467d05b5c3">Arrangement_2::Vertex_handle</a>    v0 = e-&gt;source();</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a> (arr, Segment_2 (Point_2 (1, 1), Point_2 (3, 7)));</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a> (arr, Segment_2 (Point_2 (1, 4), Point_2 (7, 1)));</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a> (arr, Segment_2 (Point_2 (2, 2), Point_2 (9, 3)));</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a> (arr, Segment_2 (Point_2 (2, 2), Point_2 (4, 4)));</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a> (arr, Segment_2 (Point_2 (7, 1), Point_2 (9, 3)));</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a> (arr, Segment_2 (Point_2 (3, 7), Point_2 (9, 3)));</div><div class="line"></div><div class="line">  <span class="comment">// Create a mapping of the arrangement vertices to indices.</span></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__vertex__index__map.html">CGAL::Arr_vertex_index_map&lt;Arrangement_2&gt;</a>        index_map(arr);</div><div class="line"></div><div class="line">  <span class="comment">// Perform Dijkstra's algorithm from the vertex v0.</span></div><div class="line">  Edge_length_func                                      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__measure__grp.html#gaaffc67e631d83a7da4b1096b782ead94">edge_length</a>;</div><div class="line"></div><div class="line">  boost::vector_property_map&lt;double, CGAL::Arr_vertex_index_map&lt;Arrangement_2&gt; &gt; dist_map(static_cast&lt;unsigned int&gt;(arr.number_of_vertices()), index_map);</div><div class="line">  boost::dijkstra_shortest_paths(arr, v0,</div><div class="line">                                 boost::vertex_index_map(index_map).</div><div class="line">                                 weight_map(edge_length).</div><div class="line">                                 distance_map(dist_map));</div><div class="line"></div><div class="line">  <span class="comment">// Print the results:</span></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#a658bc1f09608a7ba83e54309e56aa042">Arrangement_2::Vertex_iterator</a>      vit;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The distances of the arrangement vertices from ("</span></div><div class="line">            &lt;&lt; v0-&gt;point() &lt;&lt; <span class="stringliteral">") :"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (vit = arr.vertices_begin(); vit != arr.vertices_end(); ++vit)</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"("</span> &lt;&lt; vit-&gt;point() &lt;&lt; <span class="stringliteral">") at distance "</span></div><div class="line">              &lt;&lt; dist_map[vit] &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="arr_sssecbgl_dual"></a>
Example for the Dual of an Arrangement as Graph</h2>
<p>It is possible to give a dual graph representation for an arrangement instance, such that each arrangement face corresponds to a graph vertex and two vertices are adjacent iff the corresponding faces share a common edge on their boundaries. This is done by specializing the <code>boost::graph_traits</code> template for <code><a class="el" href="classCGAL_1_1Dual.html" title="The class template Dual is an adaptor that creates the dual view of a FaceGraph. ">Dual</a>&lt;<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&gt;</code> instances, where <code><a class="el" href="classCGAL_1_1Dual.html" title="The class template Dual is an adaptor that creates the dual view of a FaceGraph. ">Dual</a>&lt;<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&gt;</code> is a template specialization that gives a dual interpretation to an arrangement instance.</p>
<p>In dual representation, <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#afba61ea413272c8af10dcc4bdeb5ff63">Arrangement_2::Face_handle</a></code> is the graph-vertex type, while <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#adf9ae7012e73ea8f327ab59515b00828">Arrangement_2::Halfedge_handle</a></code> is the graph-edge type. We treat the graph edges as directed, such that a halfedge <code>e</code> is directed from \( f_1\), which is its incident face, to \( f_2\), which is the incident face of its twin halfedge. As two arrangement faces may share more than a single edge on their boundary, we allow parallel edges in our <em>boost</em> graph. As is the case in the primal graph, the dual arrangement graph is also a model of the concepts <code><a class="el" href="classVertexListGraph.html" title="Concept from the Boost Graph Library. See https://www.boost.org/libs/graph/doc/VertexListGraph.html. ">VertexListGraph</a></code>, <code><a class="el" href="classEdgeListGraph.html" title="Concept from the Boost Graph Library. See https://www.boost.org/libs/graph/doc/EdgeListGraph.html. ">EdgeListGraph</a></code> and <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classBidirectionalGraph.html">BidirectionalGraph</a></code> (thus also of <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classIncidenceGraph.html">IncidenceGraph</a></code>).</p>
<p>Since we use <code>Face_handle</code> objects as the vertex descriptors, we define the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__face__index__map.html">Arr_face_index_map</a>&lt;Arrangement&gt;</code> class-template, which maintains an efficient mapping of face handles to indices. We also provide the template <code>Arr_face_property_map&lt;Arrangement,Type&gt;</code> for associating arbitrary data with the arrangement faces.</p>
<p>In the following example we construct the same arrangement as in example <code>ex_bgl_primal_adapter.cpp</code> (see <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/index.html#fig__aos_fig-bgl_primal_adapter">Figure 34.48</a>), and perform breadth-first search on the graph faces, starting from the unbounded face. We extend the DCEL faces with an unsigned integer, marking the discover time of the face and use a breadth-first-search visitor to obtain these times and update the faces accordingly:</p>
<p><br />
<b>File</b> <a class="el" href="BGL_arrangement_2_2arrangement_dual_8cpp-example.html">BGL_arrangement_2/arrangement_dual.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Adapting the dual of an arrangement to a BGL graph.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_rational_nt.h"</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_segment_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_extended_dcel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/graph_traits_dual_arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_face_index_map.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;climits&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/breadth_first_search.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/graph/visitors.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_print.h"</span></div><div class="line"></div><div class="line"><span class="comment">// A property map that reads/writes the information to/from the extended</span></div><div class="line"><span class="comment">// face.</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Arrangement, <span class="keyword">class</span> Type&gt;</div><div class="line"><span class="keyword">class </span>Extended_face_property_map {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Arrangement::Face_handle       Face_handle;</div><div class="line"></div><div class="line">  <span class="comment">// Boost property type definitions.</span></div><div class="line">  <span class="keyword">typedef</span> boost::read_write_property_map_tag      category;</div><div class="line">  <span class="keyword">typedef</span> Type                                    value_type;</div><div class="line">  <span class="keyword">typedef</span> value_type&amp;                             reference;</div><div class="line">  <span class="keyword">typedef</span> Face_handle                             key_type;</div><div class="line"></div><div class="line">  <span class="comment">// The get function is required by the property map concept.</span></div><div class="line">  <span class="keyword">friend</span> reference <span class="keyword">get</span>(<span class="keyword">const</span> Extended_face_property_map&amp;, key_type key)</div><div class="line">  { <span class="keywordflow">return</span> key-&gt;data(); }</div><div class="line"></div><div class="line">  <span class="comment">// The put function is required by the property map concept.</span></div><div class="line">  <span class="keyword">friend</span> <span class="keywordtype">void</span> put(<span class="keyword">const</span> Extended_face_property_map&amp;, key_type key, value_type val)</div><div class="line">  { key-&gt;set_data(val); }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;Number_type&gt;</a>                         Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__segment__traits__2.html">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</a>                   Traits_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__face__extended__dcel.html">CGAL::Arr_face_extended_dcel&lt;Traits_2, unsigned int&gt;</a> Dcel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2, Dcel&gt;</a>                  Ex_arrangement;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Dual.html">CGAL::Dual&lt;Ex_arrangement&gt;</a>                           Dual_arrangement;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__face__index__map.html">CGAL::Arr_face_index_map&lt;Ex_arrangement&gt;</a>             Face_index_map;</div><div class="line"><span class="keyword">typedef</span> Extended_face_property_map&lt;Ex_arrangement,unsigned int&gt;</div><div class="line">                                                             Face_property_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>                                      Point_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Segment__2.html">Kernel::Segment_2</a>                                    Segment_2;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="comment">// Construct an arrangement of seven intersecting line segments.</span></div><div class="line">  Point_2 p1(1, 1), p2(1, 4), p3(2, 2), p4(3, 7), p5(4, 4), p6(7, 1), p7(9, 3);</div><div class="line">  Ex_arrangement  arr;</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a>(arr, Segment_2(p1, p6));</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a>(arr, Segment_2(p1, p4));  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a>(arr, Segment_2(p2, p6));</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a>(arr, Segment_2(p3, p7));  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a>(arr, Segment_2(p3, p5));</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a>(arr, Segment_2(p6, p7));  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a>(arr, Segment_2(p4, p7));</div><div class="line"></div><div class="line">  <span class="comment">// Create a mapping of the arrangement faces to indices.</span></div><div class="line">  Face_index_map  index_map(arr);</div><div class="line"></div><div class="line">  <span class="comment">// Perform breadth-first search from the unbounded face, using the event</span></div><div class="line">  <span class="comment">// visitor to associate each arrangement face with its discover time.</span></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    time = 0;</div><div class="line">  boost::breadth_first_search(Dual_arrangement(arr), arr.unbounded_face(),</div><div class="line">                              boost::vertex_index_map(index_map).visitor</div><div class="line">                              (boost::make_bfs_visitor</div><div class="line">                               (stamp_times(Face_property_map(), time,</div><div class="line">                                            boost::on_discover_vertex()))));</div><div class="line"></div><div class="line">  <span class="comment">// Print the discover time of each arrangement face.</span></div><div class="line">  Ex_arrangement::Face_iterator  fit;</div><div class="line">  <span class="keywordflow">for</span> (fit = arr.faces_begin(); fit != arr.faces_end(); ++fit) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Discover time "</span> &lt;&lt; fit-&gt;data() &lt;&lt; <span class="stringliteral">" for "</span>;</div><div class="line">    <span class="keywordflow">if</span> (fit != arr.unbounded_face()) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">"face "</span>;</div><div class="line">      print_ccb&lt;Ex_arrangement&gt;(fit-&gt;outer_ccb());</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> std::cout &lt;&lt; <span class="stringliteral">"the unbounded face."</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="BGLExtensions"></a>
Extensions of the BGL</h1>
<p>The previous sections introduced partial specializations and free functions so that several CGAL data structures are adapted as models of some of the BGL graph concepts. In this section, we introduce new concepts, iterators, and property maps inspired by the functionalities of the BGL.</p>
<h2><a class="anchor" id="BGLExtensionsGraphConcepts"></a>
Graph concepts</h2>
<p>In order to match <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgHalfedgeDS">Halfedge Data Structures</a> more closely and to enable writing generic algorithms which operate on data structures that have faces and halfedges, we define a set of new concepts to extend the <a href="https://www.boost.org/libs/graph/doc/graph_concepts.html">graph concepts of the BGL</a>:</p>
<ul>
<li><code><a class="el" href="classHalfedgeGraph.html" title="The concept HalfedgeGraph is a refinement of the BGL concept IncidenceGraph and adds the notion of a ...">HalfedgeGraph</a></code> refines <a href="https://www.boost.org/libs/graph/doc/Graph.html"><code>Graph</code></a> with operations to accommodate halfedge data structures: given a halfedge, say <code>h</code>, the concept <code><a class="el" href="classHalfedgeGraph.html" title="The concept HalfedgeGraph is a refinement of the BGL concept IncidenceGraph and adds the notion of a ...">HalfedgeGraph</a></code> requires the provision of the halfedge opposite to <code>h</code>, the halfedge that succeeds <code>h</code>, and the halfedge that precedes <code>h</code>.</li>
<li><code><a class="el" href="classHalfedgeListGraph.html" title="The concept HalfedgeListGraph refines the concept HalfedgeGraph and adds the requirements for travers...">HalfedgeListGraph</a></code> adds the requirement for efficient traversal of the halfedges of the graph.</li>
<li><code><a class="el" href="classMutableHalfedgeGraph.html" title="The concept MutableHalfedgeGraph refines the concept HalfedgeGraph and adds the requirements for oper...">MutableHalfedgeGraph</a></code> adds the requirement for operations to change next/previous relations and to adjust the target of a halfedge.</li>
<li><code><a class="el" href="classFaceGraph.html" title="The concept FaceGraph refines the concept HalfedgeGraph. It adds the requirements for a graph to expl...">FaceGraph</a></code> adds the requirements to explicitly handle faces in a graph, to provide quick access to the incident halfedges of a face, and to enable access from every halfedge to an adjacent face.</li>
<li><code><a class="el" href="classFaceListGraph.html" title="The concept FaceListGraph refines the concept FaceGraph and adds the requirement for traversal of all...">FaceListGraph</a></code> adds the requirement for efficient traversal of the faces of a graph.</li>
<li><code><a class="el" href="classMutableFaceGraph.html" title="The concept MutableFaceGraph refines the concepts FaceGraph and MutableHalfedgeGraph and adds the req...">MutableFaceGraph</a></code> adds requirements to change adjacency of faces and halfedges, and to remove and add faces.</li>
</ul>
<p>A summary of the expressions and types associated with each of these concepts as well as a refinement relation graph can be found in the <a class="el" href="group__PkgBGLConcepts.html">Concepts</a> documentation page.</p>
<h2><a class="anchor" id="BGLIteratorsAndCirculators"></a>
Iterators and Circulators</h2>
<p>By combining basic operations on graphs, we create various useful <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/devman_iterators_and_circulators.html">iterators and circulators</a> to traverse specific types of elements. For example:</p>
<ul>
<li>Starting at a halfedge <code>h</code> of a halfedge graph <code>g</code>, applying several times <code>next(h,g)</code> brings us back to the halfedge where we started. All halfedges traversed on the way are incident to the same face.</li>
<li>Using the composition of the functions <code>next(h,g)</code> and <code>opposite(h,g)</code> results in another cycle, namely the cycle of halfedges which are incident to the same vertex.</li>
</ul>
<p>A complete list of these traversal tools can be found in <a class="el" href="group__PkgBGLIterators.html">the reference manual</a>.</p>
<p>For convenience, two iterator and circulator types enable the traversal of all halfedges incident to a given face, and all halfedges having a given vertex as target. These types are not part of the concept <code><a class="el" href="classHalfedgeGraph.html" title="The concept HalfedgeGraph is a refinement of the BGL concept IncidenceGraph and adds the notion of a ...">HalfedgeGraph</a></code>, but they are class templates that work for any model of this concept.</p>
<h3><a class="anchor" id="BGLExampleIncidentVertices"></a>
Example: Finding Incident Vertices in a HalfedgeGraph</h3>
<p>The following example shows several functions to navigate in a <code><a class="el" href="classHalfedgeGraph.html" title="The concept HalfedgeGraph is a refinement of the BGL concept IncidenceGraph and adds the notion of a ...">HalfedgeGraph</a></code>. We have two implementations of the operation that finds the vertices adjacent to a vertex <code>v</code>.</p>
<p>Let us have a look at the first version. Given a vertex descriptor <code>vd</code>, we first call <code>halfedge(vd,g)</code> to obtain the halfedge with <code>vd</code> as target. Applying <code><a class="el" href="classEdgeListGraph.html#a8623c30b1f1b0fda831343463aaca433">source()</a></code> then gives us an adjacent vertex. We then get to the next halfedge with <code>vd</code> as target, by first going to the next halfedge around the face, and then going to the opposite halfedge.</p>
<p>The second version does the <code>next()</code> and <code>opposite()</code> jumping with an iterator. Note that when calling <code><a class="el" href="classEdgeListGraph.html#a8623c30b1f1b0fda831343463aaca433">source()</a></code> we have to dereference <code>hi</code>, as the function expects a halfedge descriptor and not a halfedge iterator. Also observe that <code><a class="el" href="group__PkgBGLIterators.html#ga2be4fd4d24b1e48e00a92f90f0f2923c" title="returns an iterator range over all halfedges with vertex target(h,g) as target. ">halfedges_around_target()</a></code> expects a halfedge, and not a vertex. This provides the user with the ability to start the traversal at a specific halfedge incident to the input vertex (and not the arbitrary incident halfedge stored in the vertex record.)</p>
<p><br />
<b>File</b> <a class="el" href="BGL_polyhedron_3_2incident_vertices_8cpp-example.html">BGL_polyhedron_3/incident_vertices.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/iterator.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;Kernel&gt;</a>     Polyhedron;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt; GraphTraits;</div><div class="line"><span class="keyword">typedef</span> GraphTraits::vertex_descriptor vertex_descriptor;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Halfedge__around__target__iterator.html">CGAL::Halfedge_around_target_iterator&lt;Polyhedron&gt;</a> halfedge_around_target_iterator;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> OutputIterator&gt;</div><div class="line"><a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classOutputIterator.html">OutputIterator</a></div><div class="line">adjacent_vertices_V1(<span class="keyword">const</span> Polyhedron&amp; g,</div><div class="line">                     vertex_descriptor vd,</div><div class="line">                     <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classOutputIterator.html">OutputIterator</a> out)</div><div class="line">{</div><div class="line">  <span class="keyword">typename</span> GraphTraits::halfedge_descriptor hb = halfedge(vd,g), done(hb);</div><div class="line">  <span class="keywordflow">do</span> {</div><div class="line">        *out++ = source(hb,g);</div><div class="line">        hb = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gad0a8110cb95f76bac65649bfe58c650b">opposite</a>(next(hb,g),g);</div><div class="line">  } <span class="keywordflow">while</span>(hb!= done);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> out;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> OutputIterator&gt;</div><div class="line"><a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classOutputIterator.html">OutputIterator</a></div><div class="line">adjacent_vertices_V2(<span class="keyword">const</span> Polyhedron&amp; g,</div><div class="line">                     vertex_descriptor vd,</div><div class="line">                     <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classOutputIterator.html">OutputIterator</a> out)</div><div class="line">{</div><div class="line">  halfedge_around_target_iterator hi, he;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(boost::tie(hi, he) = <a class="code" href="group__PkgBGLIterators.html#ga2be4fd4d24b1e48e00a92f90f0f2923c">halfedges_around_target</a>(halfedge(vd,g),g); hi != he; ++hi)</div><div class="line">  {</div><div class="line">    *out++ = source(*hi,g);</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> out;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::ifstream in((argc&gt;1)?argv[1]:<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/cube_poly.off"</span>));</div><div class="line">  Polyhedron P;</div><div class="line">  in &gt;&gt; P;</div><div class="line">  GraphTraits::vertex_iterator vi = vertices(P).first;</div><div class="line">  std::list&lt;vertex_descriptor&gt; V;</div><div class="line">  adjacent_vertices_V1(P, *vi, std::back_inserter(V));</div><div class="line">  ++vi;</div><div class="line">  adjacent_vertices_V2(P, *vi, std::back_inserter(V));</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"done\n"</span>;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="BGLExampleNormalHalfedgeGraph"></a>
Example: Calculating Facet Normals using HalfedgeGraph</h3>
<p>The following example program shows a simple algorithm for calculating facet normals for a polyhedron using the BGL API. A <a href="https://www.boost.org/libs/property_map/doc/vector_property_map.html">boost::vector_property_map</a> is used to to store the calculated normals instead of changing the Polyhedron items class.</p>
<p><br />
<b>File</b> <a class="el" href="BGL_polyhedron_3_2normals_8cpp-example.html">BGL_polyhedron_3/normals.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/graph/graph_traits.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_items_with_id_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>                               Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                                              Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a>                                             Vector;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;Kernel, CGAL::Polyhedron_items_with_id_3&gt;</a> Polyhedron;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <a class="code" href="classHalfedgeGraph.html">HalfedgeGraph</a>,</div><div class="line">         <span class="keyword">typename</span> PointMap,</div><div class="line">         <span class="keyword">typename</span> NormalMap&gt;</div><div class="line"><span class="keywordtype">void</span> calculate_face_normals(<span class="keyword">const</span> <a class="code" href="classHalfedgeGraph.html">HalfedgeGraph</a>&amp; g,</div><div class="line">                            PointMap pm,</div><div class="line">                            NormalMap nm)</div><div class="line">{</div><div class="line">  <span class="keyword">typedef</span> boost::graph_traits&lt;HalfedgeGraph&gt; GraphTraits;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> GraphTraits::face_iterator face_iterator;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> GraphTraits::halfedge_descriptor halfedge_descriptor;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::property_traits&lt;PointMap&gt;::value_type point;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::property_traits&lt;NormalMap&gt;::value_type <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__normal__grp.html#ga49a712e57564602ad468a3888784e971">normal</a>;</div><div class="line"></div><div class="line">  face_iterator fb, fe;</div><div class="line">  <span class="keywordflow">for</span>(boost::tie(fb, fe) = faces(g); fb != fe; ++fb)</div><div class="line">  {</div><div class="line">    halfedge_descriptor edg = halfedge(*fb, g);</div><div class="line">    halfedge_descriptor edgb = edg;</div><div class="line"></div><div class="line">    point p0 = pm[target(edg, g)];</div><div class="line">    edg = next(edg, g);</div><div class="line">    point p1 = pm[target(edg, g)];</div><div class="line">    edg = next(edg, g);</div><div class="line">    point p2 = pm[target(edg, g)];</div><div class="line">    edg = next(edg, g);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(edg == edgb) {</div><div class="line">      <span class="comment">// triangle</span></div><div class="line">      nm[*fb] = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__unit__normal__grp.html#gaeb8231145ba0cdde8e28fc4f983f23ef">CGAL::unit_normal</a>(p1, p2, p0);</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">      <span class="comment">// not a triangle</span></div><div class="line">      normal n(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga4a98ec6bd9dfd8fe8c46fea553b5d238">CGAL::NULL_VECTOR</a>);</div><div class="line"></div><div class="line">      <span class="keywordflow">do</span> {</div><div class="line">        n = n + <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__normal__grp.html#ga49a712e57564602ad468a3888784e971">CGAL::normal</a>(p1, p2, p0);</div><div class="line">        p0 = p1;</div><div class="line">        p1 = p2;</div><div class="line"></div><div class="line">        edg = next(edg, g);</div><div class="line">        p2 = pm[target(edg, g)];</div><div class="line">      } <span class="keywordflow">while</span>(edg != edgb);</div><div class="line"></div><div class="line">      nm[*fb] = n / <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">CGAL::sqrt</a>(n.squared_length());</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">typedef</span> boost::property_map&lt;</div><div class="line">    Polyhedron,</div><div class="line">    <a class="code" href="group__PkgBGLProperties.html#ga4d8b2f143dbc2547a5a307f76a48f8e0">CGAL::face_index_t</a></div><div class="line">    &gt;::const_type Face_index_map;</div><div class="line"></div><div class="line">  std::ifstream in((argc&gt;1)?argv[1]:<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/cube_poly.off"</span>));</div><div class="line">  Polyhedron P;</div><div class="line">  in &gt;&gt; P ;</div><div class="line"></div><div class="line">  <span class="comment">// initialize facet indices</span></div><div class="line">  std::size_t i = 0;</div><div class="line">  <span class="keywordflow">for</span>(Polyhedron::Facet_iterator it = P.facets_begin(); it != P.facets_end(); ++it, ++i)</div><div class="line">  {</div><div class="line">    it-&gt;id() = i;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Ad hoc property_map to store normals. Face_index_map is used to</span></div><div class="line">  <span class="comment">// map face_descriptors to a contiguous range of indices. See</span></div><div class="line">  <span class="comment">// http://www.boost.org/libs/property_map/doc/vector_property_map.html</span></div><div class="line">  <span class="comment">// for details.</span></div><div class="line">  boost::vector_property_map&lt;Vector, Face_index_map&gt;</div><div class="line">    normals(static_cast&lt;unsigned&gt;(num_faces(P)), <span class="keyword">get</span>(CGAL::face_index, P));</div><div class="line"></div><div class="line">  calculate_face_normals(</div><div class="line">    P <span class="comment">// Graph</span></div><div class="line">    , <span class="keyword">get</span>(CGAL::vertex_point, P) <span class="comment">// map from vertex_descriptor to point</span></div><div class="line">    , normals <span class="comment">// map from face_descriptor to Vector_3</span></div><div class="line">    );</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Normals"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span>(Polyhedron::Facet_iterator it = P.facets_begin(); it != P.facets_end(); ++it) {</div><div class="line">    <span class="comment">// Facet_iterator is a face_descriptor, so we can use it as the</span></div><div class="line">    <span class="comment">// key here</span></div><div class="line">    std::cout &lt;&lt; normals[it] &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="BGLProperties"></a>
Properties and Dynamic Properties</h2>
<p>As the concepts <code><a class="el" href="classHalfedgeGraph.html" title="The concept HalfedgeGraph is a refinement of the BGL concept IncidenceGraph and adds the notion of a ...">HalfedgeGraph</a></code> and <code><a class="el" href="classFaceGraph.html" title="The concept FaceGraph refines the concept HalfedgeGraph. It adds the requirements for a graph to expl...">FaceGraph</a></code> add the notion of halfedges and faces, as well as a geometric embedding of the vertices, we have to add property tags such as <code>face_index_t</code> and <code>vertex_point_t</code>.</p>
<p>We further add <em>dynamic properties</em> that enable the user to add properties to vertices, halfedges, edges, and faces on the fly. The lifetime of a dynamic property is bound to the lifetime of the property map: reference counting is used to delete the property when no map refers to it.</p>
<p>Dynamic property tags, such as <code><a class="el" href="structCGAL_1_1dynamic__vertex__property__t.html" title="Dynamic vertex property tag. ">dynamic_vertex_property_t</a></code>, are a generalization of <code>boost::vertex_index_t</code>, as they have a template parameter for the value type of the dynamic property map, and a default value. <code>boost::property_map&lt;G,T&gt;::type</code> is used to obtain the type of the dynamic property map for a graph of type <code>G</code>, for a dynamic property tag <code>T</code>. This type must be default constructible and assignable. As for ordinary properties, the function <code>get()</code> is overloaded and serves for retrieving a property map for a given graph and dynamic property tag, as well as for retrieving a value for a given key and property map.</p>
<p>The following example shows how to attach a <code>string</code> property to vertices and a <code>double</code> value to the halfedges of a graph.</p>
<p><br />
<b>File</b> <a class="el" href="Property_map_2dynamic_properties_8cpp-example.html">Property_map/dynamic_properties.cpp</a> </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> K;</div><div class="line"><span class="keyword">typedef</span> K::Point_3 Point_3;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point_3&gt;</a> Mesh;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Mesh mesh;</div><div class="line">  <a class="code" href="group__PkgBGLHelperFct.html#ga81ac0b6fbedf7889e0164aec540bd112">CGAL::make_triangle</a>(Point_3(0,0,0),Point_3(1,0,0),Point_3(1,1,0), mesh);</div><div class="line"></div><div class="line">  <span class="keyword">typedef</span> boost::property_map&lt;Mesh, CGAL::dynamic_vertex_property_t&lt;std::string&gt; &gt;::type VertexNameMap;</div><div class="line">  VertexNameMap vnm  = <span class="keyword">get</span>(<a class="code" href="structCGAL_1_1dynamic__vertex__property__t.html">CGAL::dynamic_vertex_property_t&lt;std::string&gt;</a>(), mesh);</div><div class="line">  put(vnm, *(vertices(mesh).first), <span class="stringliteral">"Paris"</span>);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="keyword">get</span>(vnm, *(vertices(mesh).first)) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keyword">typedef</span> boost::property_map&lt;Mesh, CGAL::dynamic_halfedge_property_t&lt;double&gt; &gt;::type TrafficDensityMap;</div><div class="line">  TrafficDensityMap tdm = <span class="keyword">get</span>(<a class="code" href="structCGAL_1_1dynamic__halfedge__property__t.html">CGAL::dynamic_halfedge_property_t&lt;double&gt;</a>(), mesh);</div><div class="line">  put(tdm, *(halfedges(mesh).first), 0.7);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="keyword">get</span>(tdm, *(halfedges(mesh).first)) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h2><a class="anchor" id="BGLGraphIO"></a>
Graph I/O</h2>
<p>Using a common graph concept enables having common input/output functions for all the models of this concept. The following file formats are supported for models of <code><a class="el" href="classFaceGraph.html" title="The concept FaceGraph refines the concept HalfedgeGraph. It adds the requirements for a graph to expl...">FaceGraph</a></code>:</p><ul>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/IOStreamSupportedFileFormats.html#IOStreamOFF">Object File Format (OFF)</a> (<code>.off</code>)</li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/IOStreamSupportedFileFormats.html#IOStreamOBJ">Wavefront Advanced Visualizer Object Format (OBJ)</a> (<code>.obj</code>)</li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/IOStreamSupportedFileFormats.html#IOStreamSTL">STereoLithography (STL) File Format</a> (<code>.stl</code>)</li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/IOStreamSupportedFileFormats.html#IOStreamPLY">Polygon File Format (PLY)</a> (<code>.ply</code>)</li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/IOStreamSupportedFileFormats.html#IOStreamGocad">GOCAD (TS) File Format</a> (<code>.ts</code>)</li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/IOStreamSupportedFileFormats.html#IOStreamVTK">VTK (VTU / VTP) File Formats</a> (<code>.vtp</code>)</li>
</ul>
<p>See the page <a class="el" href="group__PkgBGLIOFct.html">I/O Functions</a> for an exhaustive description of the I/O functions of this package.</p>
<h1><a class="anchor" id="BGLEulerOperations"></a>
Euler Operations</h1>
<p>There are two categories of mutating operations. The first category comprises low level operations that change incidences such as the target vertex of a halfedge. A halfedge graph might turn invalid by the application of inconsistent low lever operations. The second category of operations are called <em>Euler Operations</em>. These are high level operations such as adding a center vertex to a face, which means also adding halfedges and faces, and updating incidence information. The Euler operations enable manipulating models of <code><a class="el" href="classMutableFaceGraph.html" title="The concept MutableFaceGraph refines the concepts FaceGraph and MutableHalfedgeGraph and adds the req...">MutableFaceGraph</a></code>.</p>
<p>The complete list of Euler operations provided by this package can be found in <a class="el" href="group__PkgBGLEulerOperations.html">the reference manual</a>.</p>
<h1><a class="anchor" id="BGLGraphAdaptors"></a>
Graph Adaptors</h1>
<p>Graph adaptors are classes that build an interface over an existing graph to provide new functionalities. By operating almost entirely on the input graph, adaptors can avoid potentially expensive operations, both in term of time and memory.</p>
<h2><a class="anchor" id="BGLDual"></a>
The Dual Graph</h2>
<p>The <em>dual graph</em> of a <code><a class="el" href="classFaceGraph.html" title="The concept FaceGraph refines the concept HalfedgeGraph. It adds the requirements for a graph to expl...">FaceGraph</a></code> <code>G</code> is a graph that has a vertex for each face of <code>G</code>. The dual graph has an edge whenever two faces of <code>G</code> are separated from each other by an edge. Thus, each edge <code>e</code> of <code>G</code> has a corresponding dual edge, the edge that connects the two faces on either side of <code>e</code>. Computing the dual graph of a graph has many uses, for example when one wishes to compute the connected components of a mesh.</p>
<p>The class template <code><a class="el" href="classCGAL_1_1Dual.html" title="The class template Dual is an adaptor that creates the dual view of a FaceGraph. ">Dual</a></code> is an adaptor that creates the dual view of a <code><a class="el" href="classFaceGraph.html" title="The concept FaceGraph refines the concept HalfedgeGraph. It adds the requirements for a graph to expl...">FaceGraph</a></code>. Faces of the original graph correspond to vertices in the <code><a class="el" href="classCGAL_1_1Dual.html" title="The class template Dual is an adaptor that creates the dual view of a FaceGraph. ">Dual</a></code> and vice versa.</p>
<p>Note that border edges in a <code><a class="el" href="classCGAL_1_1Dual.html" title="The class template Dual is an adaptor that creates the dual view of a FaceGraph. ">Dual</a></code> have the <code>null_face</code> of the original graph as either source or target. This is unusual and might break other algorithms since edges are always assumed to have non-null vertices as a source and target. It is nevertheless possible to filter border edges using <a href="https://www.boost.org/libs/graph/doc/filtered_graph.html">boost::filtered_graph</a>, as shown in the following example.</p>
<p><br />
<b>File</b> <a class="el" href="BGL_surface_mesh_2surface_mesh_dual_8cpp-example.html">BGL_surface_mesh/surface_mesh_dual.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/Dual.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/helpers.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/graph/filtered_graph.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/graph/connected_components.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>             Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                            Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point&gt;</a>                  Mesh;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Dual.html">CGAL::Dual&lt;Mesh&gt;</a>                           Dual;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Dual&gt;::edge_descriptor edge_descriptor;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> G&gt;</div><div class="line"><span class="keyword">struct </span>noborder {</div><div class="line">  noborder() : g(nullptr) {} <span class="comment">// default-constructor required by filtered_graph</span></div><div class="line">  noborder(G&amp; g) : g(&amp;g) {}</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> edge_descriptor&amp; e)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{ <span class="keywordflow">return</span> !<a class="code" href="group__PkgBGLHelperFct.html#gad93e429ad24efeaddeb836c437e719ab">is_border</a>(e,*g); }</div><div class="line"></div><div class="line">  G* g;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// A dual border edge has a null_face as the source or target "vertex"</span></div><div class="line"><span class="comment">// BGL algorithms won't like that, so we remove border edges through a</span></div><div class="line"><span class="comment">// boost::filtered_graph.</span></div><div class="line"><span class="keyword">typedef</span> boost::filtered_graph&lt;Dual, noborder&lt;Mesh&gt; &gt;   FiniteDual;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::vertex_descriptor   vertex_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::face_descriptor     face_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::edge_descriptor     edge_descriptor;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/prim.off"</span>);</div><div class="line"></div><div class="line">  Mesh primal;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__IO__grp.html#gac5b3295bd1b6375628a46d1fbaf7e881">CGAL::IO::read_polygon_mesh</a>(filename, primal))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line">  Dual dual(primal);</div><div class="line">  FiniteDual finite_dual(dual,noborder&lt;Mesh&gt;(primal));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"dual has "</span> &lt;&lt; num_vertices(dual) &lt;&lt; <span class="stringliteral">" vertices"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The vertices of dual are faces in primal"</span>&lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span>(boost::graph_traits&lt;Dual&gt;::vertex_descriptor dvd : vertices(dual)) {</div><div class="line">    std::cout &lt;&lt; dvd &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The edges in primal and dual with source and target"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span>(edge_descriptor e : edges(dual)) {</div><div class="line">   std::cout &lt;&lt; e &lt;&lt; <span class="stringliteral">" in primal:  "</span> &lt;&lt; source(e,primal)      &lt;&lt; <span class="stringliteral">" -- "</span> &lt;&lt; target(e,primal)       &lt;&lt; <span class="stringliteral">"   "</span></div><div class="line">             &lt;&lt;      <span class="stringliteral">" in dual  :  "</span> &lt;&lt; source(e,finite_dual) &lt;&lt; <span class="stringliteral">" -- "</span> &lt;&lt; target(e,finite_dual)  &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"> std::cout &lt;&lt; <span class="stringliteral">"edges of the finite dual graph"</span> &lt;&lt; std::endl;</div><div class="line"> <span class="keywordflow">for</span>(boost::graph_traits&lt;FiniteDual&gt;::edge_descriptor e : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL.html#a266177f3e138c748f9906f7abb76320b">CGAL::make_range</a>(edges(finite_dual))) {</div><div class="line">   std::cout &lt;&lt; e &lt;&lt; <span class="stringliteral">"  "</span> &lt;&lt; source(e,primal) &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; source(e,finite_dual)  &lt;&lt; std::endl;</div><div class="line"> }</div><div class="line"></div><div class="line"> <span class="comment">// the storage of a property map is in primal</span></div><div class="line"> Mesh::Property_map&lt;face_descriptor,int&gt; fccmap;</div><div class="line"> fccmap = primal.add_property_map&lt;face_descriptor,<span class="keywordtype">int</span>&gt;(<span class="stringliteral">"f:CC"</span>).first;</div><div class="line"> <span class="keywordtype">int</span> num = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__keep__connected__components__grp.html#ga4b265482ec76e147764f0ca64a90b55d">connected_components</a>(finite_dual, fccmap);</div><div class="line"></div><div class="line"> std::cout &lt;&lt; <span class="stringliteral">"The graph has "</span> &lt;&lt; num &lt;&lt; <span class="stringliteral">" connected components (face connectivity)"</span> &lt;&lt; std::endl;</div><div class="line"> <span class="keywordflow">for</span>(face_descriptor f : faces(primal)) {</div><div class="line">   std::cout &lt;&lt; f &lt;&lt; <span class="stringliteral">" in connected component "</span> &lt;&lt; fccmap[f] &lt;&lt; std::endl;</div><div class="line"> }</div><div class="line"></div><div class="line"> Mesh::Property_map&lt;vertex_descriptor,int&gt; vccmap;</div><div class="line"> vccmap = primal.add_property_map&lt;vertex_descriptor,<span class="keywordtype">int</span>&gt;(<span class="stringliteral">"v:CC"</span>).first;</div><div class="line"> num = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__keep__connected__components__grp.html#ga4b265482ec76e147764f0ca64a90b55d">connected_components</a>(primal, vccmap);</div><div class="line"></div><div class="line"> std::cout &lt;&lt; <span class="stringliteral">"The graph has "</span> &lt;&lt; num &lt;&lt; <span class="stringliteral">" connected components (edge connectvity)"</span> &lt;&lt; std::endl;</div><div class="line"> <span class="keywordflow">for</span>(vertex_descriptor v : vertices(primal)) {</div><div class="line">   std::cout &lt;&lt; v &lt;&lt; <span class="stringliteral">" in connected component "</span> &lt;&lt; vccmap[v] &lt;&lt; std::endl;</div><div class="line"> }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="BGLSeamMesh"></a>
The Seam Mesh</h2>
<p>The class <code><a class="el" href="classCGAL_1_1Seam__mesh.html" title="This class is a data structure that takes a triangle mesh, further refered to as underlying mesh and ...">Seam_mesh</a></code> allows to mark edges of a mesh as <em>seam edges</em> so that they <em>virtually</em> become border edges when exploring a seam mesh with the BGL API. The input mesh is referred to as <em>underlying</em> mesh of the seam mesh. We denote <code>tm</code> and <code>sm</code> the underlying mesh and the seam mesh respectively.</p>
<p>Figure <a class="el" href="index.html#fig__fig_Seam_mesh_1">Figure 102.2</a> shows an example of mesh on which two edges, defined by the halfedge pairs <code>h2-h3</code> and <code>h6-h7</code>, are marked as seams. The introduction of virtual borders modifies the elementary BGL graph traversal operations: when we circulate around the target of <code>h7</code> in the underlying mesh, we traverse <code>h7</code>, <code>h1</code>, <code>h3</code>, <code>h5</code>, before arriving at <code>h7</code> again. However, when we circulate in the seam mesh, we traverse <code>h7</code>, <code>h1</code>, <code>h3*</code>, before arriving at <code>h7</code> again. Similarly, if we start at <code>h3</code>, we traverse <code>h3</code>, <code>h5</code>, <code>h7*</code>, and <code>h3</code> again.</p>
<p><a class="anchor" id="fig__fig_Seam_mesh_1"></a></p><div class="image">
<object type="image/svg+xml" data="seam_mesh_1.svg">seam_mesh_1.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__fig_Seam_mesh_1">Figure 102.2</a> A seam mesh with two seam edges <code>(h2, h3)</code> and <code>(h6, h7)</code>.  </div> <br /> 
<p>A vertex of the underlying mesh may correspond to multiple vertices in the seam mesh. For example in Figure <a class="el" href="index.html#fig__fig_Seam_mesh_1">Figure 102.2</a>, the target of <code>h7</code> corresponds to two vertices in the seam mesh, on either side of the virtual border created by the seam edges. For this reason, a vertex <code>v</code> of the seam mesh is internally represented as a halfedge <code>h</code> of the seam mesh. To obtain a canonical definition, the halfedge <code>h</code> is defined as the halfedge that has <code>v</code> as target, that lies on the seam, and that is not a border halfedge. The function <code>target(hd, sm)</code> will return this halfedge. For vertices <code>v</code> in the underlying mesh that are not on a seam edge, we choose <code>halfedge(v, tm)</code> as its canonical halfedge.</p>
<h3><a class="anchor" id="BGLSeamMeshTraversal"></a>
Seam Mesh Traversal</h3>
<p>Using the function <code>next(halfedge_descriptor, FaceGraph)</code>, we can walk around a face but also around a border of a mesh. For the seam mesh <code>sm</code> from Figure <a class="el" href="index.html#fig__fig_Seam_mesh_1">Figure 102.2</a>, we have <code>opposite(h2, sm) == h3*</code>, and it holds that <code>face(h3*, sm) == null_face()</code>. We can walk along this virtual border: starting at <code>h3*</code> and repeatedly calling <code>next(..,sm)</code>, we will traverse <code>h6*</code>, <code>h7*</code>, <code>h2*</code>, before reaching <code>h3*</code> again.</p>
<p>All other traversal functions, iterators, and circulators (see <a class="el" href="group__PkgBGLIterators.html">Iterators and Circulators</a>) can be used on a seam mesh, but their behavior is similarly modified by the (virtual and real) border edges of the seam mesh.</p>
<h3><a class="anchor" id="BGLSeamMeshNature"></a>
Seams</h3>
<p>A collection of seam edges, or simply a <em>seam</em>, is not necessarily a simple polyline as we can see in the next figure: </p><ul>
<li>
In <em>(a)</em>, the seam forms a tree. Consequently, we pass at a vertex as often as there are incident seam edges. </li>
<li>
In <em>(b)</em>, the seam has a vertex <code>v</code> on the border of the underlying mesh. While walking along the border of the seam mesh, we leave the border of the underlying mesh when we reach <code>v</code> and walk on a virtual border until we reach <code>v</code> again, from the other side of the seam. </li>
<li>
In <em>(c)</em>, the seam forms a closed polyline. While the first two define a single border, a cycle defines two borders and splits the set of faces in two connected components. Something similar happens when the seam touches the same border more than once. A seam can also connect different borders, potentially changing the genus of the mesh. Finally, a seam may have more than one connected component. </li>
</ul>
<p><a class="anchor" id="fig__fig_Seam_mesh_2"></a></p><div class="image">
<object type="image/svg+xml" data="seam_mesh_2.svg">seam_mesh_2.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__fig_Seam_mesh_2">Figure 102.3</a> Walking around a seam <em>(a)</em> with no seam vertex on the real border, <em>(b)</em> with a seam vertex on the real border, <em>(c)</em> with a closed polyline. Vertices of the seam mesh that are linked by a green dashed segment correspond to the same vertex in the underlying mesh.  </div> <br /> 
<p>Seam meshes are for example used in Chapter <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceMeshParameterization">Triangulated Surface Mesh Parameterization</a> to parameterize a topological sphere by first virtually cutting it into a topological disk.</p>
<h2><a class="anchor" id="BGLInheriting"></a>
Inheriting from a Model of a Face Graph Concept</h2>
<p>In order for a type <code>FG</code> to be a model of one of the face graph concepts, a specialization of <code>boost::graph_traits&lt;FG&gt;</code> must exist. When you derive a class from <code>FG</code> this graph traits class specialization does not match. For such cases, a header file consuming some user defined macros is provided to make the derived class a valid model of the same concept. See <code><a class="el" href="graph__traits__inheritance__macros_8h.html" title="Convenience header file defining the necessary specializations and overloads to make a class...">CGAL/boost/graph/graph_traits_inheritance_macros.h</a></code> for more details.</p>
<h1><a class="anchor" id="BGLPartitioning"></a>
Graph Partitioning</h1>
<p>For algorithms that operate locally, partitioning is often an easy way to parallelize the algorithm at little cost. The functions <code><a class="el" href="group__PkgBGLPartition.html#gaedf2c722ed8baf7d9b4df4cf0e9b86b5" title="computes a partition of the input triangular mesh into nparts parts, based on the mesh's nodal graph...">CGAL::METIS::partition_graph()</a></code> and <code><a class="el" href="group__PkgBGLPartition.html#gad72efc6b61c92ee8704858dc0b7062e9" title="computes a partition of the input triangular mesh into nparts parts, based on the mesh's dual graph...">CGAL::METIS::partition_dual_graph()</a></code> provide wrappers to the graph partitioning library METIS <a class="el" href="citelist.html#CITEREF_karypis1998fast">[3]</a>, allowing to split triangular meshes that are models of the concept <code><a class="el" href="classFaceListGraph.html" title="The concept FaceListGraph refines the concept FaceGraph and adds the requirement for traversal of all...">FaceListGraph</a></code> into a given number of subdomains.</p>
<p>The following example shows how to read, partition, and write a mesh using <code><a class="el" href="group__PkgBGLPartition.html#gad72efc6b61c92ee8704858dc0b7062e9" title="computes a partition of the input triangular mesh into nparts parts, based on the mesh's dual graph...">partition_dual_graph()</a></code>. The class template <code><a class="el" href="structCGAL_1_1Face__filtered__graph.html" title="The class Face_filtered_graph is an adaptor that creates a filtered view of a graph by restricting it...">CGAL::Face_filtered_graph</a></code> and the free function <code><a class="el" href="group__PkgBGLHelperFct.html#ga2682fb7d5f4ff4eb65607ae4118e31bc" title="copies a source model of FaceListGraph into a target model of a FaceListGraph. ">copy_face_graph()</a></code> are used to create an independent mesh from one of the subdomains of the partition. Note that the copy is optional as writing can be done directly using <code><a class="el" href="structCGAL_1_1Face__filtered__graph.html" title="The class Face_filtered_graph is an adaptor that creates a filtered view of a graph by restricting it...">Face_filtered_graph</a></code>.</p>
<p><br />
<b>File</b> <a class="el" href="BGL_surface_mesh_2surface_mesh_partition_8cpp-example.html">BGL_surface_mesh/surface_mesh_partition.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/Face_filtered_graph.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="partition_8h.html">CGAL/boost/graph/partition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/polygon_mesh_io.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>                           K;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;K::Point_3&gt;</a>                           SM;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string filename = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/blobby.off"</span>);</div><div class="line">  <span class="keywordtype">int</span> number_of_parts = (argc&gt;2) ? atoi(argv[2]) : 8;</div><div class="line"></div><div class="line">  SM sm;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__IO__grp.html#gac5b3295bd1b6375628a46d1fbaf7e881">CGAL::IO::read_polygon_mesh</a>(filename, sm))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// The vertex &lt;--&gt; partition_id property map</span></div><div class="line">  <span class="keyword">typedef</span> SM::Property_map&lt;SM::Vertex_index, std::size_t&gt;          Vertex_id_map;</div><div class="line">  Vertex_id_map vertex_pid_map = sm.add_property_map&lt;SM::Vertex_index, std::size_t&gt;(<span class="stringliteral">"v:pid"</span>).first;</div><div class="line"></div><div class="line">  <span class="comment">// The face &lt;--&gt; partition_id property map</span></div><div class="line">  <span class="keyword">typedef</span> SM::Property_map&lt;SM::Face_index, std::size_t&gt;            Face_id_map;</div><div class="line">  Face_id_map face_pid_map = sm.add_property_map&lt;SM::Face_index, std::size_t&gt;(<span class="stringliteral">"f:pid"</span>).first;</div><div class="line"></div><div class="line">  <span class="comment">// Partition the mesh</span></div><div class="line">  <a class="code" href="group__PkgBGLPartition.html#gad72efc6b61c92ee8704858dc0b7062e9">CGAL::METIS::partition_dual_graph</a>(sm, number_of_parts,</div><div class="line">                                    CGAL::parameters::vertex_partition_id_map(vertex_pid_map)</div><div class="line">                                                     .face_partition_id_map(face_pid_map));</div><div class="line"></div><div class="line">  <span class="comment">// Extract the part n°0 of the partition into a new, independent mesh</span></div><div class="line">  <span class="keyword">typedef</span> <a class="code" href="structCGAL_1_1Face__filtered__graph.html">CGAL::Face_filtered_graph&lt;SM&gt;</a>                            Filtered_graph;</div><div class="line">  Filtered_graph filtered_sm(sm, 0 <span class="comment">/*id of th part*/</span>, face_pid_map);</div><div class="line">  assert(filtered_sm.is_selection_valid());</div><div class="line">  SM part_sm;</div><div class="line">  <a class="code" href="group__PkgBGLHelperFct.html#ga2682fb7d5f4ff4eb65607ae4118e31bc">CGAL::copy_face_graph</a>(filtered_sm, part_sm);</div><div class="line"></div><div class="line">  <span class="comment">// Output the mesh extracted from subpart n°0</span></div><div class="line">  <a class="code" href="group__PkgBGLIOFct.html#gafa143949a33371dc6df8307be1ab8a66">CGAL::IO::write_polygon_mesh</a>(<span class="stringliteral">"sm_part_0.off"</span>, part_sm, CGAL::parameters::stream_precision(17));</div><div class="line"></div><div class="line">  <span class="comment">// Output all the vertices that are in the part n°0</span></div><div class="line">  std::ofstream outxyz(<span class="stringliteral">"out.xyz"</span>);</div><div class="line">  outxyz.precision(17);</div><div class="line">  boost::graph_traits&lt;SM&gt;::vertex_iterator vit, ve;</div><div class="line">  boost::tie(vit, ve) = vertices(sm);</div><div class="line">  <span class="keywordflow">for</span>(; vit!=ve; ++vit)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span>(<span class="keyword">get</span>(vertex_pid_map, *vit) == 0)</div><div class="line">      outxyz &lt;&lt; sm.point(*vit) &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><p>Using <a class="el" href="index.html#BGLNamedParameters">Named Parameters</a> some of the many options of METIS can be customized, as shown in <a class="el" href="BGL_polyhedron_3_2polyhedron_partition_8cpp-example.html">this example</a>.</p>
<h1><a class="anchor" id="BGLGraphcut"></a>
Graph Cut</h1>
<p>An optimal partition from a set of labels can be computed through a graph cut approach called alpha expansion <a class="el" href="citelist.html#CITEREF_Boykov2001FastApproximate">[1]</a>. CGAL provides <code><a class="el" href="group__PkgBGLPartition.html#gac0ae8f45718c0eb9b70ebddd5008515b" title="regularizes a partition of a graph into n labels using the alpha expansion algorithm ...">CGAL::alpha_expansion_graphcut()</a></code> which, for a graph \((V,E)\), computes the partition <code>f</code> that minimizes the following cost function:</p>
<p class="formulaDsp">
\[ \mathrm{C}(f) = \sum_{\{v0,v1\} \in E} C_E(v0,v1) + \sum_{v \in V} C_V(f_v) \]
</p>
<p>where \(C_E(v0,v1)\) is the edge cost of assigning a different label to \(v0\) and \(v1\), and \(C_V(f_v)\) is the vertex cost of assigning the label \(f\) to the vertex \(v\).</p>
<p>Three different implementations are provided and can be selected by using one of the following tags:</p>
<ul>
<li><code>CGAL::Alpha_expansion_boost_adjacency_list_tag</code> (default)</li>
<li><code>CGAL::Alpha_expansion_boost_compressed_sparse_raw_tag</code></li>
<li><code>CGAL::Alpha_expansion_MaxFlow_tag</code>, released under GPL license and provided by the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh_segmentation.tag:../Surface_mesh_segmentation/" href="../Surface_mesh_segmentation/group__PkgSurfaceMeshSegmentationRef.html">Triangulated Surface Mesh Segmentation Reference</a> package</li>
</ul>
<p>All these implementations produce the exact same result but behave differently in terms of timing and memory (see <a class="el" href="index.html#fig__alpha_exp">Figure 102.4</a>). The <em>MaxFlow</em> implementation is the fastest, but it grows rapidly in memory when increasing the complexity of the input graph and labeling; the <em>compressed sparse raw</em> (CSR) is very efficient from a memory point of view but becomes very slow as the complexity of the input graph and labeling increases; the <em>adjacency list</em> version provides a good compromise and is therefore the default implementation.</p>
<p><a class="anchor" id="fig__alpha_exp"></a></p><div class="image">
<img src="alpha_expansion.png" alt="alpha_expansion.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__alpha_exp">Figure 102.4</a> Comparison of time and memory consumed by the different alpha expansion implementations.  </div> <br /> 
<h2><a class="anchor" id="BGLGraphcutExample"></a>
Example</h2>
<p>The following example shows how to apply the alpha expansion algorithm to a <code>boost::adjacency_list</code> describing a 2D array with 3 labels "X", " " and "O":</p>
<p><br />
<b>File</b> <a class="el" href="BGL_graphcut_2alpha_expansion_example_8cpp-example.html">BGL_graphcut/alpha_expansion_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/alpha_expansion_graphcut.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/graph/adjacency_list.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>Vertex_property</div><div class="line">{</div><div class="line">  <span class="keywordtype">int</span> label;</div><div class="line">  std::vector&lt;double&gt; cost;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Edge_property</div><div class="line">{</div><div class="line">  <span class="keywordtype">double</span> weight;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">using</span> Graph = boost::adjacency_list &lt;boost::setS,</div><div class="line">                                     boost::vecS,</div><div class="line">                                     boost::undirectedS,</div><div class="line">                                     Vertex_property,</div><div class="line">                                     Edge_property&gt;;</div><div class="line"><span class="keyword">using</span> GT = boost::graph_traits&lt;Graph&gt;;</div><div class="line"><span class="keyword">using</span> vertex_descriptor = GT::vertex_descriptor;</div><div class="line"><span class="keyword">using</span> edge_descriptor = GT::edge_descriptor;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  std::array&lt;char, 3&gt; labels = { <span class="charliteral">'X'</span>, <span class="charliteral">' '</span>, <span class="charliteral">'O'</span> };</div><div class="line"></div><div class="line">  std::array&lt;std::array&lt;int, 6&gt;, 5&gt; input</div><div class="line">    = { { { 0, 2, 0, 1, 1, 1 },</div><div class="line">          { 0, 0, 1, 0, 1, 2 },</div><div class="line">          { 2, 0, 1, 1, 2, 2 },</div><div class="line">          { 0, 1, 1, 2, 2, 0 },</div><div class="line">          { 1, 1, 2, 0, 2, 2 } } };</div><div class="line"></div><div class="line">  std::array&lt;std::array&lt;vertex_descriptor, 6&gt;, 5&gt; vertices;</div><div class="line"></div><div class="line">  <span class="comment">// Init vertices from values</span></div><div class="line">  Graph g;</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; input.size(); ++ i)</div><div class="line">    <span class="keywordflow">for</span> (std::size_t j = 0; j &lt; input[i].size(); ++ j)</div><div class="line">    {</div><div class="line">      vertices[i][j] = boost::add_vertex(g);</div><div class="line">      g[vertices[i][j]].label = input[i][j];</div><div class="line"></div><div class="line">      <span class="comment">// Cost of assigning this vertex to any label is positive except</span></div><div class="line">      <span class="comment">// for current label which is 0 (favor init solution)</span></div><div class="line">      g[vertices[i][j]].cost.resize(3, 1);</div><div class="line">      g[vertices[i][j]].cost[std::size_t(input[i][j])] = 0;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="comment">// Display input values</span></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Input:"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; vertices.size(); ++ i)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (std::size_t j = 0; j &lt; vertices[i].size(); ++ j)</div><div class="line">      std::cerr &lt;&lt; labels[std::size_t(g[vertices[i][j]].label)];</div><div class="line">    std::cerr &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Init adjacency</span></div><div class="line">  <span class="keywordtype">double</span> weight = 0.5;</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; vertices.size(); ++ i)</div><div class="line">    <span class="keywordflow">for</span> (std::size_t j = 0; j &lt; vertices[i].size(); ++ j)</div><div class="line">    {</div><div class="line">      <span class="comment">// Neighbor vertices are connected</span></div><div class="line">      <span class="keywordflow">if</span> (i &lt; vertices.size() - 1)</div><div class="line">      {</div><div class="line">        edge_descriptor ed = <a class="code" href="group__PkgBGLEulerOperations.html#ga4661f850bc60686efeae2fc9d2ec3e65">boost::add_edge</a> (vertices[i][j], vertices[i+1][j], g).first;</div><div class="line">        g[ed].weight = weight;</div><div class="line">      }</div><div class="line">      <span class="keywordflow">if</span> (j &lt; vertices[i].size() - 1)</div><div class="line">      {</div><div class="line">        edge_descriptor ed = <a class="code" href="group__PkgBGLEulerOperations.html#ga4661f850bc60686efeae2fc9d2ec3e65">boost::add_edge</a> (vertices[i][j], vertices[i][j+1], g).first;</div><div class="line">        g[ed].weight = weight;</div><div class="line">      }</div><div class="line">    }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">"Alpha expansion..."</span> &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line">  <a class="code" href="group__PkgBGLPartition.html#gac0ae8f45718c0eb9b70ebddd5008515b">CGAL::alpha_expansion_graphcut</a> (g,</div><div class="line">                                  <span class="keyword">get</span> (&amp;Edge_property::weight, g),</div><div class="line">                                  <span class="keyword">get</span> (&amp;Vertex_property::cost, g),</div><div class="line">                                  <span class="keyword">get</span> (&amp;Vertex_property::label, g),</div><div class="line">                                  CGAL::parameters::vertex_index_map (<span class="keyword">get</span> (boost::vertex_index, g)));</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Display output graph</span></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Output:"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; vertices.size(); ++ i)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (std::size_t j = 0; j &lt; vertices[i].size(); ++ j)</div><div class="line">      std::cerr &lt;&lt; labels[std::size_t(g[vertices[i][j]].label)];</div><div class="line">    std::cerr &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>The output of this program shows how the initial 2D array is regularized spatially:</p>
<div class="fragment"><div class="line">Input:</div><div class="line">XOX</div><div class="line">XX X O</div><div class="line">OX  OO</div><div class="line">X  OOX</div><div class="line">  OXOO</div><div class="line"></div><div class="line">Alpha expansion...</div><div class="line"></div><div class="line">Output:</div><div class="line">XXX</div><div class="line">XX   O</div><div class="line">XX  OO</div><div class="line">X  OOO</div><div class="line">  OOOO</div></div><!-- fragment --><h2><a class="anchor" id="BGLGraphcutRegularizeSelection"></a>
Application to Regularization of the Borders of a Face Selection</h2>
<p>Manually selecting faces on a triangle mesh may create irregular borders (sawtooth) because of the shape of the triangles. Such borders can be regularized using the alpha expansion algorithm.</p>
<p>CGAL provides a function <code><a class="el" href="group__PkgBGLSelectionFct.html#gab638686b319f3b902c199d4b79df84e6" title="regularizes a selection in order to minimize the length of the border of the selection. ">CGAL::regularize_face_selection_borders()</a></code> to apply this algorithm to the borders of a face selection on a <code><a class="el" href="classFaceGraph.html" title="The concept FaceGraph refines the concept HalfedgeGraph. It adds the requirements for a graph to expl...">FaceGraph</a></code>. <a class="el" href="index.html#fig__regularization_fig">Figure 102.5</a> shows how this function affects a selection depending on the parameters.</p>
<p><a class="anchor" id="fig__regularization_fig"></a></p><div class="image">
<img src="regularize_selection.png" alt="regularize_selection.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__regularization_fig">Figure 102.5</a> Regularization of the borders of a face selection using alpha expansion. Different outputs are shown for different weight parameters, with and without preventing unselection.  </div> <br /> 
<p>The following example shows how to apply this alpha expansion regularization to the borders of a face selection of a <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh</a></code> object:</p>
<p><br />
<b>File</b> <a class="el" href="BGL_graphcut_2face_selection_borders_regularization_example_8cpp-example.html">BGL_graphcut/face_selection_borders_regularization_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/selection.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/OFF.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> Kernel = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> Mesh = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Kernel::Point_3&gt;</a>;</div><div class="line"><span class="keyword">using</span> Face_index = Mesh::Face_index;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::ifstream in((argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/blobby.off"</span>));</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!in)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: could not read input file"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  Mesh mesh;</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga7396bef8d41fe287d52d19ddbb83a3e4">CGAL::IO::read_OFF</a> (in, mesh);</div><div class="line"></div><div class="line">  std::unordered_map&lt;Face_index, bool&gt; is_selected_map;</div><div class="line"></div><div class="line">  <span class="comment">// randomly select 1/3 of faces</span></div><div class="line">  std::size_t nb_selected_before = 0;</div><div class="line">  CGAL::Random rand;</div><div class="line">  <span class="keywordflow">for</span> (Face_index fi : faces(mesh))</div><div class="line">  {</div><div class="line">    <span class="keywordtype">bool</span> selected = (rand.get_double() &lt; 1. / 3.);</div><div class="line">    is_selected_map[fi] = selected;</div><div class="line">    <span class="keywordflow">if</span> (selected)</div><div class="line">      nb_selected_before ++;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; nb_selected_before &lt;&lt; <span class="stringliteral">" selected before regularization"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgBGLSelectionFct.html#gab638686b319f3b902c199d4b79df84e6">CGAL::regularize_face_selection_borders</a> (mesh,</div><div class="line">                                           boost::make_assoc_property_map(is_selected_map),</div><div class="line">                                           0.5); <span class="comment">// using weight = 0.5</span></div><div class="line"></div><div class="line">  std::size_t nb_selected_after = 0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; sel : is_selected_map)</div><div class="line">    <span class="keywordflow">if</span> (sel.second)</div><div class="line">      ++ nb_selected_after;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; nb_selected_after &lt;&lt; <span class="stringliteral">" selected after regularization"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jun 27 2022 09:16:02 for CGAL 5.6 - CGAL and the Boost Graph Library by
    <a href="https://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>
</html><html xmlns="http://www.w3.org/1999/xhtml"><body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.6 - CGAL and the Boost Graph Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_CGAL_and_the_Boost_Graph_Library"></a><a class="anchor" id="chapterBGL"></a> </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Authors</dt><dd>Andreas Fabri, Fernando Cacciola, Philipp Moeller, and Ron Wein</dd></dl>
<p>Many geometric data structures can be interpreted as graphs as they consist of vertices and edges. This is the case for the halfedge data structure, for the polyhedral surface, for the arrangement, and for the 2D triangulation classes. With means of duality one can also interpret faces as vertices and edges between adjacent faces as edges of the dual graph.</p>
<p>The scope of CGAL is geometry and not graph algorithms. Nevertheless, this package provides the necessary classes and functions that enable using the algorithms of the <a href="https://www.boost.org/libs/graph/doc/index.html">Boost Graph Library</a> <a class="el" href="citelist.html#CITEREF_cgal:sll-bgl-02">[4]</a> (BGL for short) with CGAL data structures.</p>
<p>Furthermore, this package extends the BGL by introducing concepts such as <code><a class="el" href="classHalfedgeGraph.html" title="The concept HalfedgeGraph is a refinement of the BGL concept IncidenceGraph and adds the notion of a ...">HalfedgeGraph</a></code> and <code><a class="el" href="classFaceGraph.html" title="The concept FaceGraph refines the concept HalfedgeGraph. It adds the requirements for a graph to expl...">FaceGraph</a></code> allowing to handle <em>halfedges</em> and <em>faces</em>. These concepts reflect the design of the halfedge data structure described in Chapter <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgHalfedgeDS">Halfedge Data Structures</a>, with opposite halfedges and circular sequences of halfedges around vertices and around faces.</p>
<p>This chapter is organized as follows:</p><ul>
<li>The first section, Section <a class="el" href="index.html#BGLA">A Short Introduction to the Boost Graph Library</a>, summarizes the main ideas of the BGL.</li>
<li>Section <a class="el" href="index.html#BGLHeader">Header Files, Namespaces, and Naming Conventions</a> then explains where to find header files and the chosen naming conventions, as we blend two different libraries.</li>
<li>The four following sections give examples on how to use <a class="el" href="namespaceCGAL.html" title="CGAL Namespace. ">CGAL</a> graph and mesh data structures such as <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceMesh">Surface_mesh </a>, <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgPolyhedron">Polyhedron </a>, <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgArrangementOnSurface2">Arrangement_2 </a>, and the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgTriangulation2">2D triangulation </a> classes as models of the BGL concepts.</li>
<li>Starting with Section <a class="el" href="index.html#BGLExtensions">Extensions of the BGL</a>, we introduce new graph concepts, classes, and functions that extend the functionalities of the BGL.</li>
</ul>
<h1><a class="anchor" id="BGLA"></a>
A Short Introduction to the Boost Graph Library</h1>
<p>The algorithms of the BGL operate on models of various <em>graph concepts</em>. The <em>traits class</em> <code>boost::graph_traits</code> enable algorithms to determine the types of vertices and edges (similar to <code>std::iterator_traits</code> for iterators). <em>Free functions</em> that operate on graphs enable algorithms to obtain, for example, the source vertex of an edge, or all edges incident to a vertex. The algorithms use <em>property maps</em> to associate information with vertices and edges. The algorithms enable <em>visitors</em> to register callbacks that are called later on during the execution of the algorithms. Finally, the graph algorithms use the <em>named parameter</em> mechanism, which enables passing the arguments in arbitrary order.</p>
<h2><a class="anchor" id="BGLGraphConcepts"></a>
Graph Concepts</h2>
<p>The BGL introduces several <a href="https://www.boost.org/libs/graph/doc/graph_concepts.html">graph concepts</a>, which have different sets of characteristics and requirements. For example, iterating through all vertices or all edges in a graph, obtaining the outgoing or in-going edges of a vertex, inserting vertices and edges into a graph, and removing vertices and edges from a graph.</p>
<h2><a class="anchor" id="BGLTheGraphTraitsClass"></a>
The Graph Traits Class</h2>
<p>An algorithm operating on a graph model determines types with the help of the traits class <a href="https://www.boost.org/libs/graph/doc/graph_traits.html">boost::graph_traits</a>. Such types are the <code>vertex_descriptor</code>, which is similar to a vertex handle in CGAL data structures, or the <code>edge_descriptor</code>, which is similar to the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/HalfedgeDS.tag:../HalfedgeDS/" href="../HalfedgeDS/classHalfedgeDSHalfedge.html">halfedge handle </a> in the halfedge data structure or to the type <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Triangulation__2.html#ad28c6e0e0e65b8aaecb1ae76d8744b33">Edge </a> in 2D triangulations. There are also iterators, such as the <code>vertex_iterator</code>, which is similar to a vertex iterator in CGAL data structures, and the <code>out_edge_iterator</code>, which is similar to the edge circulator; it enables to iterate through the edges incident to a vertex. The iterators are similar and not equivalent, because their value type is a <code>vertex_descriptor</code>, whereas in CGAL handles, iterators, and circulators all have the same value type, namely the vertex or edge types.</p>
<p>Given a graph type <code>G</code>, definitions of descriptors and iterators look as follows:</p>
<div class="fragment"><div class="line">boost::graph_traits&lt;Graph&gt;::vertex_descriptor vd;</div><div class="line">boost::graph_traits&lt;Graph&gt;::edge_iterator ei;</div><div class="line">...</div></div><!-- fragment --><h2><a class="anchor" id="BGLFreeFunctionsforExploringaGraph"></a>
Free Functions for Exploring a Graph</h2>
<p>Algorithms obtain incidence information in graphs with the help of global functions such as:</p><ul>
<li><code>std::pair&lt;vertex_iterator,vertex_iterator&gt; vertices(const Graph&amp; g);</code> to obtain an iterator range providing access to all the vertices, or</li>
<li><code>int num_vertices(const Graph&amp;);</code> to obtain the number of vertices of a graph, or</li>
<li><code>vertex_descriptor source(edge_descriptor, const Graph&amp;);</code> to obtain the source vertex of an edge.</li>
</ul>
<p>Note, that the way we have written the types is a simplification; in reality, the signature of the first of the above functions is:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Graph&gt;::vertex_iterator vertex_iterator;</div><div class="line">std::pair&lt;vertex_iterator,vertex_iterator&gt; vertices(<span class="keyword">const</span> Graph&amp; g);</div></div><!-- fragment --><h2><a class="anchor" id="BGLPropertyMaps"></a>
Property Maps</h2>
<p>Another feature extensively used in the BGL is the <em>property map</em>, which is offered by the <a href="https://www.boost.org/libs/property_map/doc/property_map.html">Boost Property Map Library</a>. Property maps are a general purpose interface for mapping key objects to corresponding value objects.</p>
<p>The BGL uses property maps to associate information with vertices and edges. This mechanism uses a traits class (<code>boost::property_traits</code>) and free functions to read (<code>get</code>) and write (<code>put</code>) information in vertices, edges, and also in halfedges and faces for models of the CGAL graph concepts. For example, the BGL Dijksta's shortest path algorithm writes the predecessor of each vertex, as well as the distance to the source in such a property map.</p>
<p>Some default property maps are associated with the graph types. They are called <em>internal property maps</em> and can be retrieved using an overload of the function <code>get()</code>. For example, </p><div class="fragment"><div class="line">pm = <span class="keyword">get</span>(boost::vertex_index, g)</div></div><!-- fragment --><p> returns a property map that associates an index in the range <code>[0, num_vertices(g))</code> with each vertex of the graph. This reduces the number of parameters to pass. The data itself may be stored in the vertex or the edge, or it may be stored in an external data structure, or it may be computed on the fly. This is an implementation detail of a particular property map.</p>
<p>See also Chapter <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgPropertyMap">CGAL and Boost Property Maps</a>.</p>
<h2><a class="anchor" id="BGLVisitors"></a>
Visitors</h2>
<p>Visitors are objects that provide functions to be called at specified event points by the algorithm that they visit. The functions as well as the event points are algorithm-specific. Examples of such event points in graph algorithms are when a vertex is traversed the first time, or when all outgoing edges of a vertex have been traversed.<br />
</p>
<p>See also Section <a href="https://www.boost.org/libs/graph/doc/visitor_concepts.html">Visitor Concepts</a> in the BGL manual.</p>
<h2><a class="anchor" id="BGLNamedParameters"></a>
Named Parameters</h2>
<p>The notion of <em>named parameters</em> was introduced in the BGL, and allow the user to specify only those parameters which are really needed, by name, making the parameter ordering unimportant. See also <a href="https://www.boost.org/libs/graph/doc/bgl_named_params.html">this page</a> in the manual of the BGL for more information.</p>
<p>Say there is a function <code>f()</code> that takes 3 parameters called name, age and gender, and you have variables <code>n</code>, <code>a</code> and <code>g</code> to pass as parameters to that function. Without named parameters, you would call it like this: <code>f(n,a,g)</code>, whereas with named parameters, you call it like this: <code>f(name(n).age(a).gender(g))</code>. That is, you give each parameter a name by wrapping it into a function whose name matches that of the parameter. The entire list of named parameters is really a composition of function calls separated by a dot ("."). Thus, if the function takes a mix of mandatory and named parameters, you use a comma to separate the last non-named parameter from the first named parameters, like this: </p><div class="fragment"><div class="line">f(non_named_par0, non_named_par1, name(n).age(a).gender(g))</div></div><!-- fragment --><p> When you use named parameters, the ordering is irrelevant, so <code>f(name(n).age(a).gender(g))</code> is equivalent to <code>f(age(a).gender(g).name(n))</code>, and you can just omit any named parameter that has a default value.</p>
<p>The sequence of named parameters should start with <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL_1_1parameters.html">CGAL::parameters</a>::</code>.</p>
<h3><a class="anchor" id="BGLNamedParametersExample"></a>
Example</h3>
<p>Below is a sample call of a function that uses the optional BGL named parameters.</p>
<div class="fragment"><div class="line"><span class="comment">// pmesh : polygon mesh with patches to be refined</span></div><div class="line"><span class="comment">// faces : the range of faces defining the patches to refine</span></div><div class="line"><span class="comment">// faces_out : output iterator into which descriptors of new faces are put</span></div><div class="line"><span class="comment">// vertices_out : output iterator into which descriptors of new vertices are put</span></div><div class="line"><span class="comment">// vertex_point_map : the property map with the points associated to the vertices of `pmesh`</span></div><div class="line"><span class="comment">// density_control_factor : factor to control density of the output mesh</span></div><div class="line"><a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__meshing__grp.html#gafd90c169a7c17a1e503651f59a6dc57b">refine</a>(pmesh,</div><div class="line">       faces,</div><div class="line">       faces_out,</div><div class="line">       vertices_out,</div><div class="line">       CGAL::parameters::vertex_point_map(vpmap)</div><div class="line">                        .density_control_factor(d));</div></div><!-- fragment --><h1><a class="anchor" id="BGLHeader"></a>
Header Files, Namespaces, and Naming Conventions</h1>
<p>This package provides the necessary classes and functions that enable using CGAL data structures as models of the BGL graph concepts. To this end, we offer partial specializations of the <code>boost::graph_traits&lt;Graph&gt;</code> for various CGAL packages. For each such package, denoted <code>PACKAGE</code>, the partial specializations live in the namespace <code>boost</code> and are located in the header file <code>CGAL/boost/graph/graph_traits_PACKAGE.h</code>. Free functions are in the namespace <code><a class="el" href="namespaceCGAL.html" title="CGAL Namespace. ">CGAL</a></code>, and the compiler uses argument-dependent lookup to find them. Euler operations, described in Section <a class="el" href="index.html#BGLEulerOperations">Euler Operations</a>, are in the namespace <code>CGAL::Euler</code>, as the function <code><a class="el" href="classMutableFaceGraph.html#abf15bb91e6cdafb057514db8acf38a08">remove_face()</a></code> is at the same time a low-level and an Euler operation. Concerning the naming conventions, we have to use those of the BGL, as to fulfill the requirements of the concepts defined in the BGL.</p>
<p>Note that these partial specializations are often providing more than is required, making these classes not only models of the graph concepts of the BGL, but also models of the <a class="el" href="namespaceCGAL.html" title="CGAL Namespace. ">CGAL</a> graph concepts, that will be described in detail in Section <a class="el" href="index.html#BGLExtensions">Extensions of the BGL</a>. Correspondence tables between the types of a CGAL data structure and their BGL equivalents can be found in the <a class="el" href="group__PkgBGLTraits.html">Specializations of boost::graph_traits</a> documentation page.</p>
<p>We present in the following sections some examples of utilization of some CGAL data structures as BGL graphs.</p>
<h1><a class="anchor" id="BGLSurface_mesh"></a>
The Class Surface_mesh as Model of the Boost Graph Concept</h1>
<p>The class <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">Surface_mesh</a></code> is a model of most of the graph concepts of the BGL as well as the concepts provided by CGAL. A complete list can be found in the documentation of <a class="el" href="group__PkgBGLTraits.html#BGLSMGT">boost::graph_traits </a>. The examples show how to use some of the BGL algorithms with <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">Surface_mesh</a></code> and show how to use the concepts provided by CGAL to implement a simple algorithm.</p>
<h2><a class="anchor" id="BGLExampleMinimumSpanningTreeofaSurfaceMesh"></a>
Example: Minimum Spanning Tree of a Surface_mesh</h2>
<p>The following example program computes the minimum spanning tree on a surface mesh. More examples can be found in Chapters <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceMeshSimplification">Triangulated Surface Mesh Simplification</a>, <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceMeshSegmentation">Triangulated Surface Mesh Segmentation</a>, and <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceMeshDeformation">Triangulated Surface Mesh Deformation</a>.</p>
<p>The surface mesh class uses integer indices to address vertices and edges, and it comes with a built-in property mechanism that maps nicely on the BGL.</p>
<p><br />
<b>File</b> <a class="el" href="BGL_surface_mesh_2prim_8cpp-example.html">BGL_surface_mesh/prim.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/prim_minimum_spanning_tree.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>                       <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                                      Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point&gt;</a>                            Mesh;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::vertex_descriptor vertex_descriptor;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string filename = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/prim.off"</span>);</div><div class="line"></div><div class="line">  Mesh P;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__IO__grp.html#gac5b3295bd1b6375628a46d1fbaf7e881">CGAL::IO::read_polygon_mesh</a>(filename, P))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line">  Mesh::Property_map&lt;vertex_descriptor,vertex_descriptor&gt; <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__STLAlgos.html#ga6c5d40930db429775066babac7c35d7f">predecessor</a>;</div><div class="line">  predecessor = P.add_property_map&lt;vertex_descriptor,vertex_descriptor&gt;(<span class="stringliteral">"v:predecessor"</span>).first;</div><div class="line"></div><div class="line">  boost::prim_minimum_spanning_tree(P, predecessor, boost::root_vertex(*vertices(P).first));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"#VRML V2.0 utf8\n"</span></div><div class="line">    <span class="stringliteral">"DirectionalLight {\n"</span></div><div class="line">    <span class="stringliteral">"direction 0 -1 0\n"</span></div><div class="line">    <span class="stringliteral">"}\n"</span></div><div class="line">    <span class="stringliteral">"Shape {\n"</span></div><div class="line">    <span class="stringliteral">"  appearance Appearance {\n"</span></div><div class="line">    <span class="stringliteral">"    material Material { emissiveColor 1 0 0}}\n"</span></div><div class="line">    <span class="stringliteral">"    geometry\n"</span></div><div class="line">    <span class="stringliteral">"    IndexedLineSet {\n"</span></div><div class="line">    <span class="stringliteral">"      coord Coordinate {\n"</span></div><div class="line">    <span class="stringliteral">"        point [ \n"</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(vertex_descriptor vd : vertices(P)){</div><div class="line">    std::cout &lt;&lt;  <span class="stringliteral">"        "</span> &lt;&lt; P.point(vd) &lt;&lt; <span class="stringliteral">"\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"        ]\n"</span></div><div class="line">    <span class="stringliteral">"     }\n"</span></div><div class="line">    <span class="stringliteral">"      coordIndex [\n"</span>;</div><div class="line">  <span class="keywordflow">for</span>(vertex_descriptor vd : vertices(P)){</div><div class="line">    <span class="keywordflow">if</span>(predecessor[vd]!=vd){</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">"      "</span> &lt;&lt; std::size_t(vd) &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; std::size_t(predecessor[vd]) &lt;&lt;  <span class="stringliteral">", -1\n"</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"]\n"</span></div><div class="line">    <span class="stringliteral">"  }#IndexedLineSet\n"</span></div><div class="line">    <span class="stringliteral">"}# Shape\n"</span>;</div><div class="line"></div><div class="line">  P.remove_property_map(predecessor);</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="BGLPolyhedral"></a>
The Class Polyhedron_3 as Model of the Boost Graph Concept</h1>
<p>The class <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">Polyhedron_3</a></code> is a model of most of the graph concepts of the BGL as well as the concepts provided by CGAL. A complete list can be found in the documentation of <a class="el" href="group__PkgBGLTraits.html#BGLPolyGT">boost::graph_traits </a>. The examples show how to use some of the BGL algorithms with <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">Polyhedron_3</a></code> and show how to use the concepts provided by CGAL to implement a simple algorithm.</p>
<h2><a class="anchor" id="BGLExampleMinimumSpanningTreeofaPolyhedral"></a>
Example: Minimum Spanning Tree of a Polyhedral Surface</h2>
<p>The following example program computes the minimum spanning tree on a polyhedral surface. More examples can be found in the Chapter <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceMeshSimplification">Triangulated Surface Mesh Simplification</a>.</p>
<p><br />
<b>File</b> <a class="el" href="BGL_polyhedron_3_2kruskal_8cpp-example.html">BGL_polyhedron_3/kruskal.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/kruskal_min_spanning_tree.h&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>                       Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a>                                     Vector;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                                      Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;Kernel&gt;</a>                           Polyhedron;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt;::vertex_descriptor vertex_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt;::vertex_iterator   vertex_iterator;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt;::edge_descriptor   edge_descriptor;</div><div class="line"></div><div class="line"><span class="comment">// The BGL makes heavy use of indices associated to the vertices</span></div><div class="line"><span class="comment">// We use a std::map to store the index</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::map&lt;vertex_descriptor,int&gt; Vertex_index_map;</div><div class="line">Vertex_index_map vertex_index_map;</div><div class="line"></div><div class="line"><span class="comment">// A std::map is not a property map, because it is not lightweight</span></div><div class="line"><span class="keyword">typedef</span> boost::associative_property_map&lt;Vertex_index_map&gt; Vertex_index_pmap;</div><div class="line">Vertex_index_pmap vertex_index_pmap(vertex_index_map);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">kruskal(<span class="keyword">const</span> Polyhedron&amp; P)</div><div class="line">{</div><div class="line">  <span class="comment">// associate indices to the vertices</span></div><div class="line">  vertex_iterator vb, ve;</div><div class="line">  <span class="keywordtype">int</span> index = 0;</div><div class="line"></div><div class="line">  <span class="comment">// boost::tie assigns the first and second element of the std::pair</span></div><div class="line">  <span class="comment">// returned by boost::vertices to the variables vb and ve</span></div><div class="line">  <span class="keywordflow">for</span>(boost::tie(vb, ve)=vertices(P); vb!=ve; ++vb){</div><div class="line">    vertex_index_pmap[*vb]= index++;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// We use the default edge weight which is the length of the edge</span></div><div class="line">  <span class="comment">// This property map is defined in graph_traits_Polyhedron_3.h</span></div><div class="line"></div><div class="line">  <span class="comment">// In the function call you can see a named parameter: vertex_index_map</span></div><div class="line">  std::list&lt;edge_descriptor&gt; mst;</div><div class="line"></div><div class="line">  boost::kruskal_minimum_spanning_tree(P,</div><div class="line">                                       std::back_inserter(mst),</div><div class="line">                                       boost::vertex_index_map(vertex_index_pmap));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"#VRML V2.0 utf8\n"</span></div><div class="line">    <span class="stringliteral">"Shape {\n"</span></div><div class="line">    <span class="stringliteral">"  appearance Appearance {\n"</span></div><div class="line">    <span class="stringliteral">"    material Material { emissiveColor 1 0 0}}\n"</span></div><div class="line">    <span class="stringliteral">"    geometry\n"</span></div><div class="line">    <span class="stringliteral">"    IndexedLineSet {\n"</span></div><div class="line">    <span class="stringliteral">"      coord Coordinate {\n"</span></div><div class="line">    <span class="stringliteral">"        point [ \n"</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(boost::tie(vb, ve) = vertices(P); vb!=ve; ++vb){</div><div class="line">    std::cout &lt;&lt;  <span class="stringliteral">"        "</span> &lt;&lt; (*vb)-&gt;point() &lt;&lt; <span class="stringliteral">"\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"        ]\n"</span></div><div class="line">               <span class="stringliteral">"     }\n"</span></div><div class="line">    <span class="stringliteral">"      coordIndex [\n"</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(std::list&lt;edge_descriptor&gt;::iterator it = mst.begin(); it != mst.end(); ++it)</div><div class="line">  {</div><div class="line">    edge_descriptor e = *it ;</div><div class="line">    vertex_descriptor s = source(e,P);</div><div class="line">    vertex_descriptor t = target(e,P);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"      "</span> &lt;&lt; vertex_index_pmap[s] &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; vertex_index_pmap[t] &lt;&lt;  <span class="stringliteral">", -1\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"]\n"</span></div><div class="line">    <span class="stringliteral">"  }#IndexedLineSet\n"</span></div><div class="line">    <span class="stringliteral">"}# Shape\n"</span>;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">  Polyhedron P;</div><div class="line">  Point a(1,0,0);</div><div class="line">  Point b(0,1,0);</div><div class="line">  Point c(0,0,1);</div><div class="line">  Point d(0,0,0);</div><div class="line"></div><div class="line">  P.make_tetrahedron(a,b,c,d);</div><div class="line"></div><div class="line">  kruskal(P);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="BGLExampleUsingVerticesandEdgeswithanID"></a>
Example: Using Vertices, and Edges with an ID</h2>
<p>The following example program shows a call to the BGL Kruskal's minimum spanning tree algorithm accessing the <code>id()</code> field stored in a polyhedron vertex.</p>
<p>The main function illustrates the access to the <code>id()</code> field.</p>
<p><br />
<b>File</b> <a class="el" href="BGL_polyhedron_3_2kruskal_with_stored_id_8cpp-example.html">BGL_polyhedron_3/kruskal_with_stored_id.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_items_with_id_3.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/kruskal_min_spanning_tree.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>                               Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                                              Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;Kernel,CGAL::Polyhedron_items_with_id_3&gt;</a>  Polyhedron;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt;::vertex_descriptor vertex_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt;::vertex_iterator   vertex_iterator;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt;::edge_descriptor   edge_descriptor;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">kruskal( <span class="keyword">const</span> Polyhedron&amp; P)</div><div class="line">{</div><div class="line"></div><div class="line">  <span class="comment">// We use the default edge weight which is the length of the edge</span></div><div class="line">  <span class="comment">// This property map is defined in graph_traits_Polyhedron_3.h</span></div><div class="line"></div><div class="line">  <span class="comment">// This function call requires a vertex_index_map named parameter which</span></div><div class="line">  <span class="comment">// when  ommitted defaults to "get(vertex_index,graph)".</span></div><div class="line">  <span class="comment">// That default works here because the vertex type has an "id()" method</span></div><div class="line">  <span class="comment">// field which is used by the vertex_index internal property.</span></div><div class="line">  std::list&lt;edge_descriptor&gt; mst;</div><div class="line">  boost::kruskal_minimum_spanning_tree(P,std::back_inserter(mst));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"#VRML V2.0 utf8\n"</span></div><div class="line">    <span class="stringliteral">"Shape {\n"</span></div><div class="line">    <span class="stringliteral">"appearance Appearance {\n"</span></div><div class="line">    <span class="stringliteral">"material Material { emissiveColor 1 0 0}}\n"</span></div><div class="line">    <span class="stringliteral">"geometry\n"</span></div><div class="line">    <span class="stringliteral">"IndexedLineSet {\n"</span></div><div class="line">    <span class="stringliteral">"coord Coordinate {\n"</span></div><div class="line">    <span class="stringliteral">"point [ \n"</span>;</div><div class="line"></div><div class="line">  vertex_iterator vb, ve;</div><div class="line">  <span class="keywordflow">for</span>(boost::tie(vb,ve) = vertices(P); vb!=ve; ++vb){</div><div class="line">    std::cout &lt;&lt; (*vb)-&gt;point() &lt;&lt; <span class="stringliteral">"\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"]\n"</span></div><div class="line">    <span class="stringliteral">"}\n"</span></div><div class="line">    <span class="stringliteral">"coordIndex [\n"</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(std::list&lt;edge_descriptor&gt;::iterator it = mst.begin(); it != mst.end(); ++it){</div><div class="line">    std::cout &lt;&lt; source(*it,P)-&gt;id()</div><div class="line">              &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; target(*it,P)-&gt;id() &lt;&lt;  <span class="stringliteral">", -1\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"]\n"</span></div><div class="line">    <span class="stringliteral">"}#IndexedLineSet\n"</span></div><div class="line">    <span class="stringliteral">"}# Shape\n"</span>;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">  Polyhedron P;</div><div class="line"></div><div class="line">  Point a(1,0,0);</div><div class="line">  Point b(0,1,0);</div><div class="line">  Point c(0,0,1);</div><div class="line">  Point d(0,0,0);</div><div class="line"></div><div class="line">  P.make_tetrahedron(a,b,c,d);</div><div class="line"></div><div class="line">  <span class="comment">// associate indices to the vertices using the "id()" field of the vertex.</span></div><div class="line">  vertex_iterator vb, ve;</div><div class="line">  <span class="keywordtype">int</span> index = 0;</div><div class="line"></div><div class="line">  <span class="comment">// boost::tie assigns the first and second element of the std::pair</span></div><div class="line">  <span class="comment">// returned by boost::vertices to the variables vit and ve</span></div><div class="line">  <span class="keywordflow">for</span>(boost::tie(vb,ve)=vertices(P); vb!=ve; ++vb ){</div><div class="line">    vertex_descriptor  vd = *vb;</div><div class="line">    vd-&gt;id() = index++;</div><div class="line">  }</div><div class="line"></div><div class="line">  kruskal(P);</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="BGLTriangulations"></a>
Triangulations as Models of the Boost Graph Concept</h1>
<p>Triangulations have vertices and faces, allowing for a direct translation as a graph. A halfedge is defined as a pair of a face handle and the index of the edge. A complete list can be found in the documentation of <a class="el" href="group__PkgBGLTraits.html#BGLT2GT">boost::graph_traits </a>.</p>
<p>A classical example for an algorithm that is a combination of computational geometry and graph theory is the <em>Euclidean Minimum Spanning Tree</em> for a point set in the plane. It can be computed by running the minimum spanning tree algorithm on a Delaunay triangulation of the point set.</p>
<h2><a class="anchor" id="BGLExampleEuclideanMinimumSpanningTree"></a>
Example: Euclidean Minimum Spanning Tree</h2>
<p>In the following example we create a Delaunay triangulation and run Kruskal's minimum spanning tree algorithm on it. Because the vertex handles of the triangulation are not indices in an array, we have to provide a property map that maps vertex handles to integers in the range <code>[0, t.number_of_vertices())</code>.</p>
<p><br />
<b>File</b> <a class="el" href="BGL_triangulation_2_2emst_8cpp-example.html">BGL_triangulation_2/emst.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Delaunay_triangulation_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/graph_traits_Delaunay_triangulation_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/kruskal_min_spanning_tree.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>         K;</div><div class="line"><span class="keyword">typedef</span> K::Point_2                                                  Point;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2&lt;K&gt;</a>                           Triangulation;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Triangulation&gt;::vertex_descriptor       vertex_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Triangulation&gt;::vertex_iterator         vertex_iterator;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Triangulation&gt;::edge_descriptor         edge_descriptor;</div><div class="line"></div><div class="line"><span class="comment">// The BGL makes use of indices associated to the vertices</span></div><div class="line"><span class="comment">// We use a std::map to store the index</span></div><div class="line"><span class="keyword">typedef</span> std::map&lt;vertex_descriptor,int&gt;                             VertexIndexMap;</div><div class="line"></div><div class="line"><span class="comment">// A std::map is not a property map, because it is not lightweight</span></div><div class="line"><span class="keyword">typedef</span> boost::associative_property_map&lt;VertexIndexMap&gt;             VertexIdPropertyMap;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc,<span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename = (argc &gt; 1) ? argv[1] : <span class="stringliteral">"data/points.xy"</span>;</div><div class="line">  std::ifstream input(filename);</div><div class="line">  Triangulation tr;</div><div class="line"></div><div class="line">  Point p;</div><div class="line">  <span class="keywordflow">while</span>(input &gt;&gt; p)</div><div class="line">    tr.insert(p);</div><div class="line"></div><div class="line">  <span class="comment">// Associate indices to the vertices</span></div><div class="line">  VertexIndexMap vertex_id_map;</div><div class="line">  VertexIdPropertyMap vertex_index_pmap(vertex_id_map);</div><div class="line">  <span class="keywordtype">int</span> index = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(vertex_descriptor vd : vertices(tr))</div><div class="line">    vertex_id_map[vd] = index++;</div><div class="line"></div><div class="line">  <span class="comment">// We use the default edge weight which is the squared length of the edge</span></div><div class="line">  <span class="comment">// This property map is defined in graph_traits_Triangulation_2.h</span></div><div class="line"></div><div class="line">  <span class="comment">// In the function call you can see a named parameter: vertex_index_map</span></div><div class="line">  std::list&lt;edge_descriptor&gt; mst;</div><div class="line">  boost::kruskal_minimum_spanning_tree(tr, std::back_inserter(mst),</div><div class="line">                                       vertex_index_map(vertex_index_pmap));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The edges of the Euclidean mimimum spanning tree:"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span>(edge_descriptor ed : mst)</div><div class="line">  {</div><div class="line">    vertex_descriptor svd = source(ed, tr);</div><div class="line">    vertex_descriptor tvd = target(ed, tr);</div><div class="line">    Triangulation::Vertex_handle sv = svd;</div><div class="line">    Triangulation::Vertex_handle tv = tvd;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"[ "</span> &lt;&lt; sv-&gt;point() &lt;&lt; <span class="stringliteral">"  |  "</span> &lt;&lt; tv-&gt;point() &lt;&lt; <span class="stringliteral">" ] "</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="BGLExampleStoringtheVertexIDintheVertex"></a>
Example: Storing the Vertex ID in the Vertex</h2>
<p>The algorithms of the BGL extensively use of the indices of vertices. In the previous example we stored the indices in a <code>std::map</code> and turned that map in a property map. This property map was then passed as argument to the shortest path function.</p>
<p>If the user does not pass explicitly a property map, the graph algorithms use the property map returned by the call <code>get(boost::vertex_index,ft)</code>. This property map assumes that the vertex has a member function <code>id()</code> that returns a reference to an int. Therefore CGAL offers a class <code><a class="el" href="classCGAL_1_1Triangulation__vertex__base__with__id__2.html" title="The class Triangulation_vertex_base_with_id_2 is a model of the concept TriangulationVertexBase_2, the base vertex of a 2D-triangulation. ">Triangulation_vertex_base_with_id_2</a></code>. It is in the user's responsibility to set the indices properly.</p>
<p>The example further illustrates that the graph traits also works for the Delaunay triangulation.</p>
<p><br />
<b>File</b> <a class="el" href="BGL_triangulation_2_2dijkstra_with_internal_properties_8cpp-example.html">BGL_triangulation_2/dijkstra_with_internal_properties.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Delaunay_triangulation_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Triangulation_vertex_base_with_id_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/graph_traits_Delaunay_triangulation_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/dijkstra_shortest_paths.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>             K;</div><div class="line"><span class="keyword">typedef</span> K::Point_2                                                      Point;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Triangulation__vertex__base__with__id__2.html">CGAL::Triangulation_vertex_base_with_id_2&lt;K&gt;</a>                    Tvb;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Triangulation__face__base__2.html">CGAL::Triangulation_face_base_2&lt;K&gt;</a>                              Tfb;</div><div class="line"><span class="keyword">typedef</span> CGAL::Triangulation_data_structure_2&lt;Tvb, Tfb&gt;                  Tds;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2&lt;K, Tds&gt;</a>                          Triangulation;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Triangulation&gt;::vertex_descriptor           vertex_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Triangulation&gt;::vertex_iterator             vertex_iterator;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::property_map&lt;Triangulation, boost::vertex_index_t&gt;::type VertexIdPropertyMap;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc,<span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename = (argc &gt; 1) ? argv[1] : <span class="stringliteral">"data/points.xy"</span>;</div><div class="line">  std::ifstream input(filename);</div><div class="line">  Triangulation tr;</div><div class="line"></div><div class="line">  Point p;</div><div class="line">  <span class="keywordflow">while</span>(input &gt;&gt; p)</div><div class="line">    tr.insert(p);</div><div class="line"></div><div class="line">  <span class="comment">// associate indices to the vertices</span></div><div class="line">  <span class="keywordtype">int</span> index = 0;</div><div class="line">  <span class="keywordflow">for</span>(vertex_descriptor vd : vertices(tr))</div><div class="line">    vd-&gt;id()= index++;</div><div class="line"></div><div class="line">  VertexIdPropertyMap vertex_index_pmap = <span class="keyword">get</span>(boost::vertex_index, tr);</div><div class="line"></div><div class="line">  <span class="comment">// Dijkstra's shortest path needs property maps for the predecessor and distance</span></div><div class="line">  std::vector&lt;vertex_descriptor&gt; <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__STLAlgos.html#ga6c5d40930db429775066babac7c35d7f">predecessor</a>(num_vertices(tr));</div><div class="line">  boost::iterator_property_map&lt;std::vector&lt;vertex_descriptor&gt;::iterator, VertexIdPropertyMap&gt;</div><div class="line">    predecessor_pmap(predecessor.begin(), vertex_index_pmap);</div><div class="line"></div><div class="line">  std::vector&lt;double&gt; distance(num_vertices(tr));</div><div class="line">  boost::iterator_property_map&lt;std::vector&lt;double&gt;::iterator, VertexIdPropertyMap&gt;</div><div class="line">    distance_pmap(distance.begin(), vertex_index_pmap);</div><div class="line"></div><div class="line">  vertex_descriptor source = *vertices(tr).first;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"\nStart dijkstra_shortest_paths at "</span> &lt;&lt; source-&gt;point() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  boost::dijkstra_shortest_paths(tr, source, distance_map(distance_pmap)</div><div class="line">                                            .predecessor_map(predecessor_pmap));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(vertex_descriptor vd : vertices(tr))</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; vd-&gt;point() &lt;&lt; <span class="stringliteral">" ["</span> &lt;&lt; vd-&gt;id() &lt;&lt; <span class="stringliteral">"] "</span>;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">" has distance = "</span>  &lt;&lt; <span class="keyword">get</span>(distance_pmap,vd) &lt;&lt; <span class="stringliteral">" and predecessor "</span>;</div><div class="line"></div><div class="line">    vd = <span class="keyword">get</span>(predecessor_pmap,vd);</div><div class="line">    std::cout &lt;&lt; vd-&gt;point() &lt;&lt; <span class="stringliteral">" ["</span> &lt;&lt; vd-&gt;id() &lt;&lt; <span class="stringliteral">"]\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="BGLArrangements"></a>
Arrangements as Models of the Boost Graph Concept</h1>
<p>CGAL offers a partial specialization of the boost graph traits for its arrangement class as well as for its dual graph.</p>
<h2><a class="anchor" id="arr_sssecbgl_primal"></a>
Example for the Arrangement as Graph</h2>
<p>Arrangement instances are adapted to <em>boost</em> graphs by specializing the <code>boost::graph_traits</code> template for <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> instances. The graph-traits states the graph concepts that the arrangement class models (see below) and defines the types required by these concepts.</p>
<p>In this specialization the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> vertices correspond to the graph vertices, where two vertices are adjacent if there is at least one halfedge connecting them. More precisely, <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#a7cdc734c8b7109fe4f62b2467d05b5c3">Arrangement_2::Vertex_handle</a></code> is the graph-vertex type, while <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#adf9ae7012e73ea8f327ab59515b00828">Arrangement_2::Halfedge_handle</a></code> is the graph-edge type. As halfedges are directed, we consider the graph to be directed as well. Moreover, as several interior-disjoint \( x\)-monotone curves (say circular arcs) may share two common endpoints, inducing an arrangement with two vertices that are connected with several edges, we allow parallel edges in our <em>boost</em> graph.</p>
<p>Given an <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> instance, we can efficiently traverse its vertices and halfedges. Thus, the arrangement graph is a model of the concepts <code><a class="el" href="classVertexListGraph.html" title="Concept from the Boost Graph Library. See https://www.boost.org/libs/graph/doc/VertexListGraph.html. ">VertexListGraph</a></code> and <code><a class="el" href="classEdgeListGraph.html" title="Concept from the Boost Graph Library. See https://www.boost.org/libs/graph/doc/EdgeListGraph.html. ">EdgeListGraph</a></code> introduced by the BGL. At the same time, we use an iterator adapter of the circulator over the halfedges incident to a vertex (<code><a class="el" href="classCGAL_1_1Halfedge__around__target__circulator.html" title="A bidirectional circulator with value type boost::graph_traits&lt;Graph&gt;::halfedge_descriptor over all h...">Halfedge_around_target_circulator</a></code> - see Section <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/index.html#arr_sssectr_vertex">Traversal Methods for an Arrangement Vertex</a> of the chapter on arrangements), so it is possible to go over the ingoing and outgoing edges of a vertex in linear time. Thus, our arrangement graph is a model of the concept <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classBidirectionalGraph.html">BidirectionalGraph</a></code> (this concept refines <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classIncidenceGraph.html">IncidenceGraph</a></code>, which requires only the traversal of outgoing edges).</p>
<p>It is important to notice that the vertex descriptors we use are <code>Vertex_handle</code> objects and <em>not</em> vertex indices. However, in order to gain more efficiency in most BGL algorithm, it is better to have them indexed \( 0, 1, \ldots, (n-1)\), where \( n\) is the number of vertices. We therefore introduce the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__vertex__index__map.html">Arr_vertex_index_map</a>&lt;Arrangement&gt;</code> class-template, which maintains a mapping of vertex handles to indices, as required by the BGL. An instance of this class must be attached to a valid arrangement vertex when it is created. It uses the notification mechanism (see Section <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/index.html#arr_ssecnotif">The Notification Mechanism</a>) to automatically maintain the mapping of vertices to indices, even when new vertices are inserted into the arrangement or existing vertices are removed.</p>
<p>A complete description of the types correspondences can be found in the documentation of <a class="el" href="group__PkgBGLTraits.html#BGLArgtGT">boost::graph_traits </a>.</p>
<p>In most algorithm provided by the BGL, the output is given by <em>property maps</em>, such that each map entry corresponds to a vertex. For example, when we compute the shortest paths from a given source vertex \( s\) to all other vertices we can obtain a map of distances and a map of predecessors - namely for each \( v\) vertex we have its distance from \( s\) and a descriptor of the vertex that precedes \( v\) in the shortest path from \( s\). If the vertex descriptors are simply indices, one can use vectors to efficiently represent the property maps. As this is not the case with the arrangement graph, we offer the <code>Arr_vertex_property_map&lt;Arrangement,Type&gt;</code> template allows for an efficient mapping of <code>Vertex_handle</code> objects to properties of type <code>Type</code>. Note however that unlike the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__vertex__index__map.html">Arr_vertex_index_map</a></code> class, the vertex property-map class is not kept synchronized with the number of vertices in the arrangement, so it should not be reused in calls to the BGL functions in case the arrangement is modified in between these calls.</p>
<p><a class="anchor" id="fig__figex_bgl"></a></p><div class="image">
<img src="ex_bgl.png" alt="ex_bgl.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__figex_bgl">Figure 102.1</a> An arrangement of 7 line segments, as constructed by <code>bgl_primal_adapter.cpp</code> and <code>bgl_dual_adapter.cpp</code>. The breadth-first visit times for the arrangement faces, starting from the unbounded face \( f_0\), are shown in brackets.  </div> <br /> 
<p>In the following example we construct an arrangement of 7 line segments, as shown in <a class="el" href="index.html#fig__figex_bgl">Figure 102.1</a>, then use the BGL Dijkstra's shortest-paths algorithm to compute the graph distance of all vertices from the leftmost vertex in the arrangement \( v_0\). Note the usage of the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__vertex__index__map.html">Arr_vertex_index_map</a></code> and the <code>Arr_vertex_property_map</code> classes. The latter one, instantiated by the type <code>double</code> is used to map vertices to their distances from \( v_0\).</p>
<p><br />
<b>File</b> <a class="el" href="BGL_arrangement_2_2primal_8cpp-example.html">BGL_arrangement_2/primal.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Adapting an arrangement to a BGL graph.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_rational_nt.h"</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_segment_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/graph_traits_Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_vertex_index_map.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/dijkstra_shortest_paths.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;Number_type&gt;</a>                    Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__segment__traits__2.html">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</a>              Traits_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Point_2                               Point_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::X_monotone_curve_2                    Segment_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2&gt;</a>                   Arrangement_2;</div><div class="line"></div><div class="line"><span class="comment">// A functor used to compute the length of an edge.</span></div><div class="line"><span class="keyword">class </span>Edge_length_func</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">  <span class="comment">// Boost property type definitions:</span></div><div class="line">  <span class="keyword">typedef</span> boost::readable_property_map_tag        category;</div><div class="line">  <span class="keyword">typedef</span> <span class="keywordtype">double</span>                                  value_type;</div><div class="line">  <span class="keyword">typedef</span> value_type                              reference;</div><div class="line">  <span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#adf9ae7012e73ea8f327ab59515b00828">Arrangement_2::Halfedge_handle</a>          key_type;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> operator()(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#adf9ae7012e73ea8f327ab59515b00828">Arrangement_2::Halfedge_handle</a> e)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>     x1 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1f1bcd74fce34fd532445590bbda5cd5">CGAL::to_double</a> (e-&gt;source()-&gt;point().x());</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>     y1 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1f1bcd74fce34fd532445590bbda5cd5">CGAL::to_double</a> (e-&gt;source()-&gt;point().y());</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>     x2 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1f1bcd74fce34fd532445590bbda5cd5">CGAL::to_double</a> (e-&gt;target()-&gt;point().x());</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>     y2 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1f1bcd74fce34fd532445590bbda5cd5">CGAL::to_double</a> (e-&gt;target()-&gt;point().y());</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>     diff_x = x2 - x1;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>     diff_y = y2 - y1;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">std::sqrt</a>(diff_x*diff_x + diff_y*diff_y);</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> <span class="keyword">get</span>(<span class="keyword">const</span> Edge_length_func&amp; <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__measure__grp.html#gaaffc67e631d83a7da4b1096b782ead94">edge_length</a>, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#adf9ae7012e73ea8f327ab59515b00828">Arrangement_2::Halfedge_handle</a> e)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__measure__grp.html#gaaffc67e631d83a7da4b1096b782ead94">edge_length</a>(e);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Arrangement_2   arr;</div><div class="line"></div><div class="line">  <span class="comment">// Construct an arrangement of seven intersecting line segments.</span></div><div class="line">  <span class="comment">// We keep a handle for the vertex v_0 that corresponds to the point (1,1).</span></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#adf9ae7012e73ea8f327ab59515b00828">Arrangement_2::Halfedge_handle</a>  e =</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a> (arr, Segment_2 (Point_2 (1, 1),</div><div class="line">                                                   Point_2 (7, 1)));</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#a7cdc734c8b7109fe4f62b2467d05b5c3">Arrangement_2::Vertex_handle</a>    v0 = e-&gt;source();</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a> (arr, Segment_2 (Point_2 (1, 1), Point_2 (3, 7)));</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a> (arr, Segment_2 (Point_2 (1, 4), Point_2 (7, 1)));</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a> (arr, Segment_2 (Point_2 (2, 2), Point_2 (9, 3)));</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a> (arr, Segment_2 (Point_2 (2, 2), Point_2 (4, 4)));</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a> (arr, Segment_2 (Point_2 (7, 1), Point_2 (9, 3)));</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a> (arr, Segment_2 (Point_2 (3, 7), Point_2 (9, 3)));</div><div class="line"></div><div class="line">  <span class="comment">// Create a mapping of the arrangement vertices to indices.</span></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__vertex__index__map.html">CGAL::Arr_vertex_index_map&lt;Arrangement_2&gt;</a>        index_map(arr);</div><div class="line"></div><div class="line">  <span class="comment">// Perform Dijkstra's algorithm from the vertex v0.</span></div><div class="line">  Edge_length_func                                      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__measure__grp.html#gaaffc67e631d83a7da4b1096b782ead94">edge_length</a>;</div><div class="line"></div><div class="line">  boost::vector_property_map&lt;double, CGAL::Arr_vertex_index_map&lt;Arrangement_2&gt; &gt; dist_map(static_cast&lt;unsigned int&gt;(arr.number_of_vertices()), index_map);</div><div class="line">  boost::dijkstra_shortest_paths(arr, v0,</div><div class="line">                                 boost::vertex_index_map(index_map).</div><div class="line">                                 weight_map(edge_length).</div><div class="line">                                 distance_map(dist_map));</div><div class="line"></div><div class="line">  <span class="comment">// Print the results:</span></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#a658bc1f09608a7ba83e54309e56aa042">Arrangement_2::Vertex_iterator</a>      vit;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The distances of the arrangement vertices from ("</span></div><div class="line">            &lt;&lt; v0-&gt;point() &lt;&lt; <span class="stringliteral">") :"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (vit = arr.vertices_begin(); vit != arr.vertices_end(); ++vit)</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"("</span> &lt;&lt; vit-&gt;point() &lt;&lt; <span class="stringliteral">") at distance "</span></div><div class="line">              &lt;&lt; dist_map[vit] &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="arr_sssecbgl_dual"></a>
Example for the Dual of an Arrangement as Graph</h2>
<p>It is possible to give a dual graph representation for an arrangement instance, such that each arrangement face corresponds to a graph vertex and two vertices are adjacent iff the corresponding faces share a common edge on their boundaries. This is done by specializing the <code>boost::graph_traits</code> template for <code><a class="el" href="classCGAL_1_1Dual.html" title="The class template Dual is an adaptor that creates the dual view of a FaceGraph. ">Dual</a>&lt;<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&gt;</code> instances, where <code><a class="el" href="classCGAL_1_1Dual.html" title="The class template Dual is an adaptor that creates the dual view of a FaceGraph. ">Dual</a>&lt;<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&gt;</code> is a template specialization that gives a dual interpretation to an arrangement instance.</p>
<p>In dual representation, <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#afba61ea413272c8af10dcc4bdeb5ff63">Arrangement_2::Face_handle</a></code> is the graph-vertex type, while <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#adf9ae7012e73ea8f327ab59515b00828">Arrangement_2::Halfedge_handle</a></code> is the graph-edge type. We treat the graph edges as directed, such that a halfedge <code>e</code> is directed from \( f_1\), which is its incident face, to \( f_2\), which is the incident face of its twin halfedge. As two arrangement faces may share more than a single edge on their boundary, we allow parallel edges in our <em>boost</em> graph. As is the case in the primal graph, the dual arrangement graph is also a model of the concepts <code><a class="el" href="classVertexListGraph.html" title="Concept from the Boost Graph Library. See https://www.boost.org/libs/graph/doc/VertexListGraph.html. ">VertexListGraph</a></code>, <code><a class="el" href="classEdgeListGraph.html" title="Concept from the Boost Graph Library. See https://www.boost.org/libs/graph/doc/EdgeListGraph.html. ">EdgeListGraph</a></code> and <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classBidirectionalGraph.html">BidirectionalGraph</a></code> (thus also of <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classIncidenceGraph.html">IncidenceGraph</a></code>).</p>
<p>Since we use <code>Face_handle</code> objects as the vertex descriptors, we define the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__face__index__map.html">Arr_face_index_map</a>&lt;Arrangement&gt;</code> class-template, which maintains an efficient mapping of face handles to indices. We also provide the template <code>Arr_face_property_map&lt;Arrangement,Type&gt;</code> for associating arbitrary data with the arrangement faces.</p>
<p>In the following example we construct the same arrangement as in example <code>ex_bgl_primal_adapter.cpp</code> (see <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/index.html#fig__aos_fig-bgl_primal_adapter">Figure 34.48</a>), and perform breadth-first search on the graph faces, starting from the unbounded face. We extend the DCEL faces with an unsigned integer, marking the discover time of the face and use a breadth-first-search visitor to obtain these times and update the faces accordingly:</p>
<p><br />
<b>File</b> <a class="el" href="BGL_arrangement_2_2arrangement_dual_8cpp-example.html">BGL_arrangement_2/arrangement_dual.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Adapting the dual of an arrangement to a BGL graph.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_rational_nt.h"</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_segment_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_extended_dcel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/graph_traits_dual_arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_face_index_map.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;climits&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/breadth_first_search.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/graph/visitors.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_print.h"</span></div><div class="line"></div><div class="line"><span class="comment">// A property map that reads/writes the information to/from the extended</span></div><div class="line"><span class="comment">// face.</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Arrangement, <span class="keyword">class</span> Type&gt;</div><div class="line"><span class="keyword">class </span>Extended_face_property_map {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Arrangement::Face_handle       Face_handle;</div><div class="line"></div><div class="line">  <span class="comment">// Boost property type definitions.</span></div><div class="line">  <span class="keyword">typedef</span> boost::read_write_property_map_tag      category;</div><div class="line">  <span class="keyword">typedef</span> Type                                    value_type;</div><div class="line">  <span class="keyword">typedef</span> value_type&amp;                             reference;</div><div class="line">  <span class="keyword">typedef</span> Face_handle                             key_type;</div><div class="line"></div><div class="line">  <span class="comment">// The get function is required by the property map concept.</span></div><div class="line">  <span class="keyword">friend</span> reference <span class="keyword">get</span>(<span class="keyword">const</span> Extended_face_property_map&amp;, key_type key)</div><div class="line">  { <span class="keywordflow">return</span> key-&gt;data(); }</div><div class="line"></div><div class="line">  <span class="comment">// The put function is required by the property map concept.</span></div><div class="line">  <span class="keyword">friend</span> <span class="keywordtype">void</span> put(<span class="keyword">const</span> Extended_face_property_map&amp;, key_type key, value_type val)</div><div class="line">  { key-&gt;set_data(val); }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;Number_type&gt;</a>                         Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__segment__traits__2.html">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</a>                   Traits_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__face__extended__dcel.html">CGAL::Arr_face_extended_dcel&lt;Traits_2, unsigned int&gt;</a> Dcel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2, Dcel&gt;</a>                  Ex_arrangement;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Dual.html">CGAL::Dual&lt;Ex_arrangement&gt;</a>                           Dual_arrangement;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__face__index__map.html">CGAL::Arr_face_index_map&lt;Ex_arrangement&gt;</a>             Face_index_map;</div><div class="line"><span class="keyword">typedef</span> Extended_face_property_map&lt;Ex_arrangement,unsigned int&gt;</div><div class="line">                                                             Face_property_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>                                      Point_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Segment__2.html">Kernel::Segment_2</a>                                    Segment_2;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="comment">// Construct an arrangement of seven intersecting line segments.</span></div><div class="line">  Point_2 p1(1, 1), p2(1, 4), p3(2, 2), p4(3, 7), p5(4, 4), p6(7, 1), p7(9, 3);</div><div class="line">  Ex_arrangement  arr;</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a>(arr, Segment_2(p1, p6));</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a>(arr, Segment_2(p1, p4));  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a>(arr, Segment_2(p2, p6));</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a>(arr, Segment_2(p3, p7));  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a>(arr, Segment_2(p3, p5));</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a>(arr, Segment_2(p6, p7));  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a>(arr, Segment_2(p4, p7));</div><div class="line"></div><div class="line">  <span class="comment">// Create a mapping of the arrangement faces to indices.</span></div><div class="line">  Face_index_map  index_map(arr);</div><div class="line"></div><div class="line">  <span class="comment">// Perform breadth-first search from the unbounded face, using the event</span></div><div class="line">  <span class="comment">// visitor to associate each arrangement face with its discover time.</span></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    time = 0;</div><div class="line">  boost::breadth_first_search(Dual_arrangement(arr), arr.unbounded_face(),</div><div class="line">                              boost::vertex_index_map(index_map).visitor</div><div class="line">                              (boost::make_bfs_visitor</div><div class="line">                               (stamp_times(Face_property_map(), time,</div><div class="line">                                            boost::on_discover_vertex()))));</div><div class="line"></div><div class="line">  <span class="comment">// Print the discover time of each arrangement face.</span></div><div class="line">  Ex_arrangement::Face_iterator  fit;</div><div class="line">  <span class="keywordflow">for</span> (fit = arr.faces_begin(); fit != arr.faces_end(); ++fit) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Discover time "</span> &lt;&lt; fit-&gt;data() &lt;&lt; <span class="stringliteral">" for "</span>;</div><div class="line">    <span class="keywordflow">if</span> (fit != arr.unbounded_face()) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">"face "</span>;</div><div class="line">      print_ccb&lt;Ex_arrangement&gt;(fit-&gt;outer_ccb());</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> std::cout &lt;&lt; <span class="stringliteral">"the unbounded face."</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="BGLExtensions"></a>
Extensions of the BGL</h1>
<p>The previous sections introduced partial specializations and free functions so that several CGAL data structures are adapted as models of some of the BGL graph concepts. In this section, we introduce new concepts, iterators, and property maps inspired by the functionalities of the BGL.</p>
<h2><a class="anchor" id="BGLExtensionsGraphConcepts"></a>
Graph concepts</h2>
<p>In order to match <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgHalfedgeDS">Halfedge Data Structures</a> more closely and to enable writing generic algorithms which operate on data structures that have faces and halfedges, we define a set of new concepts to extend the <a href="https://www.boost.org/libs/graph/doc/graph_concepts.html">graph concepts of the BGL</a>:</p>
<ul>
<li><code><a class="el" href="classHalfedgeGraph.html" title="The concept HalfedgeGraph is a refinement of the BGL concept IncidenceGraph and adds the notion of a ...">HalfedgeGraph</a></code> refines <a href="https://www.boost.org/libs/graph/doc/Graph.html"><code>Graph</code></a> with operations to accommodate halfedge data structures: given a halfedge, say <code>h</code>, the concept <code><a class="el" href="classHalfedgeGraph.html" title="The concept HalfedgeGraph is a refinement of the BGL concept IncidenceGraph and adds the notion of a ...">HalfedgeGraph</a></code> requires the provision of the halfedge opposite to <code>h</code>, the halfedge that succeeds <code>h</code>, and the halfedge that precedes <code>h</code>.</li>
<li><code><a class="el" href="classHalfedgeListGraph.html" title="The concept HalfedgeListGraph refines the concept HalfedgeGraph and adds the requirements for travers...">HalfedgeListGraph</a></code> adds the requirement for efficient traversal of the halfedges of the graph.</li>
<li><code><a class="el" href="classMutableHalfedgeGraph.html" title="The concept MutableHalfedgeGraph refines the concept HalfedgeGraph and adds the requirements for oper...">MutableHalfedgeGraph</a></code> adds the requirement for operations to change next/previous relations and to adjust the target of a halfedge.</li>
<li><code><a class="el" href="classFaceGraph.html" title="The concept FaceGraph refines the concept HalfedgeGraph. It adds the requirements for a graph to expl...">FaceGraph</a></code> adds the requirements to explicitly handle faces in a graph, to provide quick access to the incident halfedges of a face, and to enable access from every halfedge to an adjacent face.</li>
<li><code><a class="el" href="classFaceListGraph.html" title="The concept FaceListGraph refines the concept FaceGraph and adds the requirement for traversal of all...">FaceListGraph</a></code> adds the requirement for efficient traversal of the faces of a graph.</li>
<li><code><a class="el" href="classMutableFaceGraph.html" title="The concept MutableFaceGraph refines the concepts FaceGraph and MutableHalfedgeGraph and adds the req...">MutableFaceGraph</a></code> adds requirements to change adjacency of faces and halfedges, and to remove and add faces.</li>
</ul>
<p>A summary of the expressions and types associated with each of these concepts as well as a refinement relation graph can be found in the <a class="el" href="group__PkgBGLConcepts.html">Concepts</a> documentation page.</p>
<h2><a class="anchor" id="BGLIteratorsAndCirculators"></a>
Iterators and Circulators</h2>
<p>By combining basic operations on graphs, we create various useful <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/devman_iterators_and_circulators.html">iterators and circulators</a> to traverse specific types of elements. For example:</p>
<ul>
<li>Starting at a halfedge <code>h</code> of a halfedge graph <code>g</code>, applying several times <code>next(h,g)</code> brings us back to the halfedge where we started. All halfedges traversed on the way are incident to the same face.</li>
<li>Using the composition of the functions <code>next(h,g)</code> and <code>opposite(h,g)</code> results in another cycle, namely the cycle of halfedges which are incident to the same vertex.</li>
</ul>
<p>A complete list of these traversal tools can be found in <a class="el" href="group__PkgBGLIterators.html">the reference manual</a>.</p>
<p>For convenience, two iterator and circulator types enable the traversal of all halfedges incident to a given face, and all halfedges having a given vertex as target. These types are not part of the concept <code><a class="el" href="classHalfedgeGraph.html" title="The concept HalfedgeGraph is a refinement of the BGL concept IncidenceGraph and adds the notion of a ...">HalfedgeGraph</a></code>, but they are class templates that work for any model of this concept.</p>
<h3><a class="anchor" id="BGLExampleIncidentVertices"></a>
Example: Finding Incident Vertices in a HalfedgeGraph</h3>
<p>The following example shows several functions to navigate in a <code><a class="el" href="classHalfedgeGraph.html" title="The concept HalfedgeGraph is a refinement of the BGL concept IncidenceGraph and adds the notion of a ...">HalfedgeGraph</a></code>. We have two implementations of the operation that finds the vertices adjacent to a vertex <code>v</code>.</p>
<p>Let us have a look at the first version. Given a vertex descriptor <code>vd</code>, we first call <code>halfedge(vd,g)</code> to obtain the halfedge with <code>vd</code> as target. Applying <code><a class="el" href="classEdgeListGraph.html#a8623c30b1f1b0fda831343463aaca433">source()</a></code> then gives us an adjacent vertex. We then get to the next halfedge with <code>vd</code> as target, by first going to the next halfedge around the face, and then going to the opposite halfedge.</p>
<p>The second version does the <code>next()</code> and <code>opposite()</code> jumping with an iterator. Note that when calling <code><a class="el" href="classEdgeListGraph.html#a8623c30b1f1b0fda831343463aaca433">source()</a></code> we have to dereference <code>hi</code>, as the function expects a halfedge descriptor and not a halfedge iterator. Also observe that <code><a class="el" href="group__PkgBGLIterators.html#ga2be4fd4d24b1e48e00a92f90f0f2923c" title="returns an iterator range over all halfedges with vertex target(h,g) as target. ">halfedges_around_target()</a></code> expects a halfedge, and not a vertex. This provides the user with the ability to start the traversal at a specific halfedge incident to the input vertex (and not the arbitrary incident halfedge stored in the vertex record.)</p>
<p><br />
<b>File</b> <a class="el" href="BGL_polyhedron_3_2incident_vertices_8cpp-example.html">BGL_polyhedron_3/incident_vertices.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/iterator.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;Kernel&gt;</a>     Polyhedron;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt; GraphTraits;</div><div class="line"><span class="keyword">typedef</span> GraphTraits::vertex_descriptor vertex_descriptor;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Halfedge__around__target__iterator.html">CGAL::Halfedge_around_target_iterator&lt;Polyhedron&gt;</a> halfedge_around_target_iterator;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> OutputIterator&gt;</div><div class="line"><a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classOutputIterator.html">OutputIterator</a></div><div class="line">adjacent_vertices_V1(<span class="keyword">const</span> Polyhedron&amp; g,</div><div class="line">                     vertex_descriptor vd,</div><div class="line">                     <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classOutputIterator.html">OutputIterator</a> out)</div><div class="line">{</div><div class="line">  <span class="keyword">typename</span> GraphTraits::halfedge_descriptor hb = halfedge(vd,g), done(hb);</div><div class="line">  <span class="keywordflow">do</span> {</div><div class="line">        *out++ = source(hb,g);</div><div class="line">        hb = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gad0a8110cb95f76bac65649bfe58c650b">opposite</a>(next(hb,g),g);</div><div class="line">  } <span class="keywordflow">while</span>(hb!= done);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> out;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> OutputIterator&gt;</div><div class="line"><a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classOutputIterator.html">OutputIterator</a></div><div class="line">adjacent_vertices_V2(<span class="keyword">const</span> Polyhedron&amp; g,</div><div class="line">                     vertex_descriptor vd,</div><div class="line">                     <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classOutputIterator.html">OutputIterator</a> out)</div><div class="line">{</div><div class="line">  halfedge_around_target_iterator hi, he;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(boost::tie(hi, he) = <a class="code" href="group__PkgBGLIterators.html#ga2be4fd4d24b1e48e00a92f90f0f2923c">halfedges_around_target</a>(halfedge(vd,g),g); hi != he; ++hi)</div><div class="line">  {</div><div class="line">    *out++ = source(*hi,g);</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> out;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::ifstream in((argc&gt;1)?argv[1]:<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/cube_poly.off"</span>));</div><div class="line">  Polyhedron P;</div><div class="line">  in &gt;&gt; P;</div><div class="line">  GraphTraits::vertex_iterator vi = vertices(P).first;</div><div class="line">  std::list&lt;vertex_descriptor&gt; V;</div><div class="line">  adjacent_vertices_V1(P, *vi, std::back_inserter(V));</div><div class="line">  ++vi;</div><div class="line">  adjacent_vertices_V2(P, *vi, std::back_inserter(V));</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"done\n"</span>;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="BGLExampleNormalHalfedgeGraph"></a>
Example: Calculating Facet Normals using HalfedgeGraph</h3>
<p>The following example program shows a simple algorithm for calculating facet normals for a polyhedron using the BGL API. A <a href="https://www.boost.org/libs/property_map/doc/vector_property_map.html">boost::vector_property_map</a> is used to to store the calculated normals instead of changing the Polyhedron items class.</p>
<p><br />
<b>File</b> <a class="el" href="BGL_polyhedron_3_2normals_8cpp-example.html">BGL_polyhedron_3/normals.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/graph/graph_traits.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_items_with_id_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>                               Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                                              Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a>                                             Vector;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;Kernel, CGAL::Polyhedron_items_with_id_3&gt;</a> Polyhedron;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <a class="code" href="classHalfedgeGraph.html">HalfedgeGraph</a>,</div><div class="line">         <span class="keyword">typename</span> PointMap,</div><div class="line">         <span class="keyword">typename</span> NormalMap&gt;</div><div class="line"><span class="keywordtype">void</span> calculate_face_normals(<span class="keyword">const</span> <a class="code" href="classHalfedgeGraph.html">HalfedgeGraph</a>&amp; g,</div><div class="line">                            PointMap pm,</div><div class="line">                            NormalMap nm)</div><div class="line">{</div><div class="line">  <span class="keyword">typedef</span> boost::graph_traits&lt;HalfedgeGraph&gt; GraphTraits;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> GraphTraits::face_iterator face_iterator;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> GraphTraits::halfedge_descriptor halfedge_descriptor;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::property_traits&lt;PointMap&gt;::value_type point;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::property_traits&lt;NormalMap&gt;::value_type <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__normal__grp.html#ga49a712e57564602ad468a3888784e971">normal</a>;</div><div class="line"></div><div class="line">  face_iterator fb, fe;</div><div class="line">  <span class="keywordflow">for</span>(boost::tie(fb, fe) = faces(g); fb != fe; ++fb)</div><div class="line">  {</div><div class="line">    halfedge_descriptor edg = halfedge(*fb, g);</div><div class="line">    halfedge_descriptor edgb = edg;</div><div class="line"></div><div class="line">    point p0 = pm[target(edg, g)];</div><div class="line">    edg = next(edg, g);</div><div class="line">    point p1 = pm[target(edg, g)];</div><div class="line">    edg = next(edg, g);</div><div class="line">    point p2 = pm[target(edg, g)];</div><div class="line">    edg = next(edg, g);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(edg == edgb) {</div><div class="line">      <span class="comment">// triangle</span></div><div class="line">      nm[*fb] = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__unit__normal__grp.html#gaeb8231145ba0cdde8e28fc4f983f23ef">CGAL::unit_normal</a>(p1, p2, p0);</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">      <span class="comment">// not a triangle</span></div><div class="line">      normal n(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga4a98ec6bd9dfd8fe8c46fea553b5d238">CGAL::NULL_VECTOR</a>);</div><div class="line"></div><div class="line">      <span class="keywordflow">do</span> {</div><div class="line">        n = n + <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__normal__grp.html#ga49a712e57564602ad468a3888784e971">CGAL::normal</a>(p1, p2, p0);</div><div class="line">        p0 = p1;</div><div class="line">        p1 = p2;</div><div class="line"></div><div class="line">        edg = next(edg, g);</div><div class="line">        p2 = pm[target(edg, g)];</div><div class="line">      } <span class="keywordflow">while</span>(edg != edgb);</div><div class="line"></div><div class="line">      nm[*fb] = n / <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">CGAL::sqrt</a>(n.squared_length());</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">typedef</span> boost::property_map&lt;</div><div class="line">    Polyhedron,</div><div class="line">    <a class="code" href="group__PkgBGLProperties.html#ga4d8b2f143dbc2547a5a307f76a48f8e0">CGAL::face_index_t</a></div><div class="line">    &gt;::const_type Face_index_map;</div><div class="line"></div><div class="line">  std::ifstream in((argc&gt;1)?argv[1]:<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/cube_poly.off"</span>));</div><div class="line">  Polyhedron P;</div><div class="line">  in &gt;&gt; P ;</div><div class="line"></div><div class="line">  <span class="comment">// initialize facet indices</span></div><div class="line">  std::size_t i = 0;</div><div class="line">  <span class="keywordflow">for</span>(Polyhedron::Facet_iterator it = P.facets_begin(); it != P.facets_end(); ++it, ++i)</div><div class="line">  {</div><div class="line">    it-&gt;id() = i;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Ad hoc property_map to store normals. Face_index_map is used to</span></div><div class="line">  <span class="comment">// map face_descriptors to a contiguous range of indices. See</span></div><div class="line">  <span class="comment">// http://www.boost.org/libs/property_map/doc/vector_property_map.html</span></div><div class="line">  <span class="comment">// for details.</span></div><div class="line">  boost::vector_property_map&lt;Vector, Face_index_map&gt;</div><div class="line">    normals(static_cast&lt;unsigned&gt;(num_faces(P)), <span class="keyword">get</span>(CGAL::face_index, P));</div><div class="line"></div><div class="line">  calculate_face_normals(</div><div class="line">    P <span class="comment">// Graph</span></div><div class="line">    , <span class="keyword">get</span>(CGAL::vertex_point, P) <span class="comment">// map from vertex_descriptor to point</span></div><div class="line">    , normals <span class="comment">// map from face_descriptor to Vector_3</span></div><div class="line">    );</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Normals"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span>(Polyhedron::Facet_iterator it = P.facets_begin(); it != P.facets_end(); ++it) {</div><div class="line">    <span class="comment">// Facet_iterator is a face_descriptor, so we can use it as the</span></div><div class="line">    <span class="comment">// key here</span></div><div class="line">    std::cout &lt;&lt; normals[it] &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="BGLProperties"></a>
Properties and Dynamic Properties</h2>
<p>As the concepts <code><a class="el" href="classHalfedgeGraph.html" title="The concept HalfedgeGraph is a refinement of the BGL concept IncidenceGraph and adds the notion of a ...">HalfedgeGraph</a></code> and <code><a class="el" href="classFaceGraph.html" title="The concept FaceGraph refines the concept HalfedgeGraph. It adds the requirements for a graph to expl...">FaceGraph</a></code> add the notion of halfedges and faces, as well as a geometric embedding of the vertices, we have to add property tags such as <code>face_index_t</code> and <code>vertex_point_t</code>.</p>
<p>We further add <em>dynamic properties</em> that enable the user to add properties to vertices, halfedges, edges, and faces on the fly. The lifetime of a dynamic property is bound to the lifetime of the property map: reference counting is used to delete the property when no map refers to it.</p>
<p>Dynamic property tags, such as <code><a class="el" href="structCGAL_1_1dynamic__vertex__property__t.html" title="Dynamic vertex property tag. ">dynamic_vertex_property_t</a></code>, are a generalization of <code>boost::vertex_index_t</code>, as they have a template parameter for the value type of the dynamic property map, and a default value. <code>boost::property_map&lt;G,T&gt;::type</code> is used to obtain the type of the dynamic property map for a graph of type <code>G</code>, for a dynamic property tag <code>T</code>. This type must be default constructible and assignable. As for ordinary properties, the function <code>get()</code> is overloaded and serves for retrieving a property map for a given graph and dynamic property tag, as well as for retrieving a value for a given key and property map.</p>
<p>The following example shows how to attach a <code>string</code> property to vertices and a <code>double</code> value to the halfedges of a graph.</p>
<p><br />
<b>File</b> <a class="el" href="Property_map_2dynamic_properties_8cpp-example.html">Property_map/dynamic_properties.cpp</a> </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> K;</div><div class="line"><span class="keyword">typedef</span> K::Point_3 Point_3;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point_3&gt;</a> Mesh;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Mesh mesh;</div><div class="line">  <a class="code" href="group__PkgBGLHelperFct.html#ga81ac0b6fbedf7889e0164aec540bd112">CGAL::make_triangle</a>(Point_3(0,0,0),Point_3(1,0,0),Point_3(1,1,0), mesh);</div><div class="line"></div><div class="line">  <span class="keyword">typedef</span> boost::property_map&lt;Mesh, CGAL::dynamic_vertex_property_t&lt;std::string&gt; &gt;::type VertexNameMap;</div><div class="line">  VertexNameMap vnm  = <span class="keyword">get</span>(<a class="code" href="structCGAL_1_1dynamic__vertex__property__t.html">CGAL::dynamic_vertex_property_t&lt;std::string&gt;</a>(), mesh);</div><div class="line">  put(vnm, *(vertices(mesh).first), <span class="stringliteral">"Paris"</span>);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="keyword">get</span>(vnm, *(vertices(mesh).first)) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keyword">typedef</span> boost::property_map&lt;Mesh, CGAL::dynamic_halfedge_property_t&lt;double&gt; &gt;::type TrafficDensityMap;</div><div class="line">  TrafficDensityMap tdm = <span class="keyword">get</span>(<a class="code" href="structCGAL_1_1dynamic__halfedge__property__t.html">CGAL::dynamic_halfedge_property_t&lt;double&gt;</a>(), mesh);</div><div class="line">  put(tdm, *(halfedges(mesh).first), 0.7);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="keyword">get</span>(tdm, *(halfedges(mesh).first)) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h2><a class="anchor" id="BGLGraphIO"></a>
Graph I/O</h2>
<p>Using a common graph concept enables having common input/output functions for all the models of this concept. The following file formats are supported for models of <code><a class="el" href="classFaceGraph.html" title="The concept FaceGraph refines the concept HalfedgeGraph. It adds the requirements for a graph to expl...">FaceGraph</a></code>:</p><ul>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/IOStreamSupportedFileFormats.html#IOStreamOFF">Object File Format (OFF)</a> (<code>.off</code>)</li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/IOStreamSupportedFileFormats.html#IOStreamOBJ">Wavefront Advanced Visualizer Object Format (OBJ)</a> (<code>.obj</code>)</li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/IOStreamSupportedFileFormats.html#IOStreamSTL">STereoLithography (STL) File Format</a> (<code>.stl</code>)</li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/IOStreamSupportedFileFormats.html#IOStreamPLY">Polygon File Format (PLY)</a> (<code>.ply</code>)</li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/IOStreamSupportedFileFormats.html#IOStreamGocad">GOCAD (TS) File Format</a> (<code>.ts</code>)</li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/IOStreamSupportedFileFormats.html#IOStreamVTK">VTK (VTU / VTP) File Formats</a> (<code>.vtp</code>)</li>
</ul>
<p>See the page <a class="el" href="group__PkgBGLIOFct.html">I/O Functions</a> for an exhaustive description of the I/O functions of this package.</p>
<h1><a class="anchor" id="BGLEulerOperations"></a>
Euler Operations</h1>
<p>There are two categories of mutating operations. The first category comprises low level operations that change incidences such as the target vertex of a halfedge. A halfedge graph might turn invalid by the application of inconsistent low lever operations. The second category of operations are called <em>Euler Operations</em>. These are high level operations such as adding a center vertex to a face, which means also adding halfedges and faces, and updating incidence information. The Euler operations enable manipulating models of <code><a class="el" href="classMutableFaceGraph.html" title="The concept MutableFaceGraph refines the concepts FaceGraph and MutableHalfedgeGraph and adds the req...">MutableFaceGraph</a></code>.</p>
<p>The complete list of Euler operations provided by this package can be found in <a class="el" href="group__PkgBGLEulerOperations.html">the reference manual</a>.</p>
<h1><a class="anchor" id="BGLGraphAdaptors"></a>
Graph Adaptors</h1>
<p>Graph adaptors are classes that build an interface over an existing graph to provide new functionalities. By operating almost entirely on the input graph, adaptors can avoid potentially expensive operations, both in term of time and memory.</p>
<h2><a class="anchor" id="BGLDual"></a>
The Dual Graph</h2>
<p>The <em>dual graph</em> of a <code><a class="el" href="classFaceGraph.html" title="The concept FaceGraph refines the concept HalfedgeGraph. It adds the requirements for a graph to expl...">FaceGraph</a></code> <code>G</code> is a graph that has a vertex for each face of <code>G</code>. The dual graph has an edge whenever two faces of <code>G</code> are separated from each other by an edge. Thus, each edge <code>e</code> of <code>G</code> has a corresponding dual edge, the edge that connects the two faces on either side of <code>e</code>. Computing the dual graph of a graph has many uses, for example when one wishes to compute the connected components of a mesh.</p>
<p>The class template <code><a class="el" href="classCGAL_1_1Dual.html" title="The class template Dual is an adaptor that creates the dual view of a FaceGraph. ">Dual</a></code> is an adaptor that creates the dual view of a <code><a class="el" href="classFaceGraph.html" title="The concept FaceGraph refines the concept HalfedgeGraph. It adds the requirements for a graph to expl...">FaceGraph</a></code>. Faces of the original graph correspond to vertices in the <code><a class="el" href="classCGAL_1_1Dual.html" title="The class template Dual is an adaptor that creates the dual view of a FaceGraph. ">Dual</a></code> and vice versa.</p>
<p>Note that border edges in a <code><a class="el" href="classCGAL_1_1Dual.html" title="The class template Dual is an adaptor that creates the dual view of a FaceGraph. ">Dual</a></code> have the <code>null_face</code> of the original graph as either source or target. This is unusual and might break other algorithms since edges are always assumed to have non-null vertices as a source and target. It is nevertheless possible to filter border edges using <a href="https://www.boost.org/libs/graph/doc/filtered_graph.html">boost::filtered_graph</a>, as shown in the following example.</p>
<p><br />
<b>File</b> <a class="el" href="BGL_surface_mesh_2surface_mesh_dual_8cpp-example.html">BGL_surface_mesh/surface_mesh_dual.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/Dual.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/helpers.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/graph/filtered_graph.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/graph/connected_components.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>             Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                            Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point&gt;</a>                  Mesh;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Dual.html">CGAL::Dual&lt;Mesh&gt;</a>                           Dual;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Dual&gt;::edge_descriptor edge_descriptor;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> G&gt;</div><div class="line"><span class="keyword">struct </span>noborder {</div><div class="line">  noborder() : g(nullptr) {} <span class="comment">// default-constructor required by filtered_graph</span></div><div class="line">  noborder(G&amp; g) : g(&amp;g) {}</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> edge_descriptor&amp; e)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{ <span class="keywordflow">return</span> !<a class="code" href="group__PkgBGLHelperFct.html#gad93e429ad24efeaddeb836c437e719ab">is_border</a>(e,*g); }</div><div class="line"></div><div class="line">  G* g;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// A dual border edge has a null_face as the source or target "vertex"</span></div><div class="line"><span class="comment">// BGL algorithms won't like that, so we remove border edges through a</span></div><div class="line"><span class="comment">// boost::filtered_graph.</span></div><div class="line"><span class="keyword">typedef</span> boost::filtered_graph&lt;Dual, noborder&lt;Mesh&gt; &gt;   FiniteDual;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::vertex_descriptor   vertex_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::face_descriptor     face_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::edge_descriptor     edge_descriptor;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/prim.off"</span>);</div><div class="line"></div><div class="line">  Mesh primal;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__IO__grp.html#gac5b3295bd1b6375628a46d1fbaf7e881">CGAL::IO::read_polygon_mesh</a>(filename, primal))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line">  Dual dual(primal);</div><div class="line">  FiniteDual finite_dual(dual,noborder&lt;Mesh&gt;(primal));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"dual has "</span> &lt;&lt; num_vertices(dual) &lt;&lt; <span class="stringliteral">" vertices"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The vertices of dual are faces in primal"</span>&lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span>(boost::graph_traits&lt;Dual&gt;::vertex_descriptor dvd : vertices(dual)) {</div><div class="line">    std::cout &lt;&lt; dvd &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The edges in primal and dual with source and target"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span>(edge_descriptor e : edges(dual)) {</div><div class="line">   std::cout &lt;&lt; e &lt;&lt; <span class="stringliteral">" in primal:  "</span> &lt;&lt; source(e,primal)      &lt;&lt; <span class="stringliteral">" -- "</span> &lt;&lt; target(e,primal)       &lt;&lt; <span class="stringliteral">"   "</span></div><div class="line">             &lt;&lt;      <span class="stringliteral">" in dual  :  "</span> &lt;&lt; source(e,finite_dual) &lt;&lt; <span class="stringliteral">" -- "</span> &lt;&lt; target(e,finite_dual)  &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"> std::cout &lt;&lt; <span class="stringliteral">"edges of the finite dual graph"</span> &lt;&lt; std::endl;</div><div class="line"> <span class="keywordflow">for</span>(boost::graph_traits&lt;FiniteDual&gt;::edge_descriptor e : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL.html#a266177f3e138c748f9906f7abb76320b">CGAL::make_range</a>(edges(finite_dual))) {</div><div class="line">   std::cout &lt;&lt; e &lt;&lt; <span class="stringliteral">"  "</span> &lt;&lt; source(e,primal) &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; source(e,finite_dual)  &lt;&lt; std::endl;</div><div class="line"> }</div><div class="line"></div><div class="line"> <span class="comment">// the storage of a property map is in primal</span></div><div class="line"> Mesh::Property_map&lt;face_descriptor,int&gt; fccmap;</div><div class="line"> fccmap = primal.add_property_map&lt;face_descriptor,<span class="keywordtype">int</span>&gt;(<span class="stringliteral">"f:CC"</span>).first;</div><div class="line"> <span class="keywordtype">int</span> num = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__keep__connected__components__grp.html#ga4b265482ec76e147764f0ca64a90b55d">connected_components</a>(finite_dual, fccmap);</div><div class="line"></div><div class="line"> std::cout &lt;&lt; <span class="stringliteral">"The graph has "</span> &lt;&lt; num &lt;&lt; <span class="stringliteral">" connected components (face connectivity)"</span> &lt;&lt; std::endl;</div><div class="line"> <span class="keywordflow">for</span>(face_descriptor f : faces(primal)) {</div><div class="line">   std::cout &lt;&lt; f &lt;&lt; <span class="stringliteral">" in connected component "</span> &lt;&lt; fccmap[f] &lt;&lt; std::endl;</div><div class="line"> }</div><div class="line"></div><div class="line"> Mesh::Property_map&lt;vertex_descriptor,int&gt; vccmap;</div><div class="line"> vccmap = primal.add_property_map&lt;vertex_descriptor,<span class="keywordtype">int</span>&gt;(<span class="stringliteral">"v:CC"</span>).first;</div><div class="line"> num = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__keep__connected__components__grp.html#ga4b265482ec76e147764f0ca64a90b55d">connected_components</a>(primal, vccmap);</div><div class="line"></div><div class="line"> std::cout &lt;&lt; <span class="stringliteral">"The graph has "</span> &lt;&lt; num &lt;&lt; <span class="stringliteral">" connected components (edge connectvity)"</span> &lt;&lt; std::endl;</div><div class="line"> <span class="keywordflow">for</span>(vertex_descriptor v : vertices(primal)) {</div><div class="line">   std::cout &lt;&lt; v &lt;&lt; <span class="stringliteral">" in connected component "</span> &lt;&lt; vccmap[v] &lt;&lt; std::endl;</div><div class="line"> }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="BGLSeamMesh"></a>
The Seam Mesh</h2>
<p>The class <code><a class="el" href="classCGAL_1_1Seam__mesh.html" title="This class is a data structure that takes a triangle mesh, further refered to as underlying mesh and ...">Seam_mesh</a></code> allows to mark edges of a mesh as <em>seam edges</em> so that they <em>virtually</em> become border edges when exploring a seam mesh with the BGL API. The input mesh is referred to as <em>underlying</em> mesh of the seam mesh. We denote <code>tm</code> and <code>sm</code> the underlying mesh and the seam mesh respectively.</p>
<p>Figure <a class="el" href="index.html#fig__fig_Seam_mesh_1">Figure 102.2</a> shows an example of mesh on which two edges, defined by the halfedge pairs <code>h2-h3</code> and <code>h6-h7</code>, are marked as seams. The introduction of virtual borders modifies the elementary BGL graph traversal operations: when we circulate around the target of <code>h7</code> in the underlying mesh, we traverse <code>h7</code>, <code>h1</code>, <code>h3</code>, <code>h5</code>, before arriving at <code>h7</code> again. However, when we circulate in the seam mesh, we traverse <code>h7</code>, <code>h1</code>, <code>h3*</code>, before arriving at <code>h7</code> again. Similarly, if we start at <code>h3</code>, we traverse <code>h3</code>, <code>h5</code>, <code>h7*</code>, and <code>h3</code> again.</p>
<p><a class="anchor" id="fig__fig_Seam_mesh_1"></a></p><div class="image">
<object type="image/svg+xml" data="seam_mesh_1.svg">seam_mesh_1.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__fig_Seam_mesh_1">Figure 102.2</a> A seam mesh with two seam edges <code>(h2, h3)</code> and <code>(h6, h7)</code>.  </div> <br /> 
<p>A vertex of the underlying mesh may correspond to multiple vertices in the seam mesh. For example in Figure <a class="el" href="index.html#fig__fig_Seam_mesh_1">Figure 102.2</a>, the target of <code>h7</code> corresponds to two vertices in the seam mesh, on either side of the virtual border created by the seam edges. For this reason, a vertex <code>v</code> of the seam mesh is internally represented as a halfedge <code>h</code> of the seam mesh. To obtain a canonical definition, the halfedge <code>h</code> is defined as the halfedge that has <code>v</code> as target, that lies on the seam, and that is not a border halfedge. The function <code>target(hd, sm)</code> will return this halfedge. For vertices <code>v</code> in the underlying mesh that are not on a seam edge, we choose <code>halfedge(v, tm)</code> as its canonical halfedge.</p>
<h3><a class="anchor" id="BGLSeamMeshTraversal"></a>
Seam Mesh Traversal</h3>
<p>Using the function <code>next(halfedge_descriptor, FaceGraph)</code>, we can walk around a face but also around a border of a mesh. For the seam mesh <code>sm</code> from Figure <a class="el" href="index.html#fig__fig_Seam_mesh_1">Figure 102.2</a>, we have <code>opposite(h2, sm) == h3*</code>, and it holds that <code>face(h3*, sm) == null_face()</code>. We can walk along this virtual border: starting at <code>h3*</code> and repeatedly calling <code>next(..,sm)</code>, we will traverse <code>h6*</code>, <code>h7*</code>, <code>h2*</code>, before reaching <code>h3*</code> again.</p>
<p>All other traversal functions, iterators, and circulators (see <a class="el" href="group__PkgBGLIterators.html">Iterators and Circulators</a>) can be used on a seam mesh, but their behavior is similarly modified by the (virtual and real) border edges of the seam mesh.</p>
<h3><a class="anchor" id="BGLSeamMeshNature"></a>
Seams</h3>
<p>A collection of seam edges, or simply a <em>seam</em>, is not necessarily a simple polyline as we can see in the next figure: </p><ul>
<li>
In <em>(a)</em>, the seam forms a tree. Consequently, we pass at a vertex as often as there are incident seam edges. </li>
<li>
In <em>(b)</em>, the seam has a vertex <code>v</code> on the border of the underlying mesh. While walking along the border of the seam mesh, we leave the border of the underlying mesh when we reach <code>v</code> and walk on a virtual border until we reach <code>v</code> again, from the other side of the seam. </li>
<li>
In <em>(c)</em>, the seam forms a closed polyline. While the first two define a single border, a cycle defines two borders and splits the set of faces in two connected components. Something similar happens when the seam touches the same border more than once. A seam can also connect different borders, potentially changing the genus of the mesh. Finally, a seam may have more than one connected component. </li>
</ul>
<p><a class="anchor" id="fig__fig_Seam_mesh_2"></a></p><div class="image">
<object type="image/svg+xml" data="seam_mesh_2.svg">seam_mesh_2.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__fig_Seam_mesh_2">Figure 102.3</a> Walking around a seam <em>(a)</em> with no seam vertex on the real border, <em>(b)</em> with a seam vertex on the real border, <em>(c)</em> with a closed polyline. Vertices of the seam mesh that are linked by a green dashed segment correspond to the same vertex in the underlying mesh.  </div> <br /> 
<p>Seam meshes are for example used in Chapter <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceMeshParameterization">Triangulated Surface Mesh Parameterization</a> to parameterize a topological sphere by first virtually cutting it into a topological disk.</p>
<h2><a class="anchor" id="BGLInheriting"></a>
Inheriting from a Model of a Face Graph Concept</h2>
<p>In order for a type <code>FG</code> to be a model of one of the face graph concepts, a specialization of <code>boost::graph_traits&lt;FG&gt;</code> must exist. When you derive a class from <code>FG</code> this graph traits class specialization does not match. For such cases, a header file consuming some user defined macros is provided to make the derived class a valid model of the same concept. See <code><a class="el" href="graph__traits__inheritance__macros_8h.html" title="Convenience header file defining the necessary specializations and overloads to make a class...">CGAL/boost/graph/graph_traits_inheritance_macros.h</a></code> for more details.</p>
<h1><a class="anchor" id="BGLPartitioning"></a>
Graph Partitioning</h1>
<p>For algorithms that operate locally, partitioning is often an easy way to parallelize the algorithm at little cost. The functions <code><a class="el" href="group__PkgBGLPartition.html#gaedf2c722ed8baf7d9b4df4cf0e9b86b5" title="computes a partition of the input triangular mesh into nparts parts, based on the mesh's nodal graph...">CGAL::METIS::partition_graph()</a></code> and <code><a class="el" href="group__PkgBGLPartition.html#gad72efc6b61c92ee8704858dc0b7062e9" title="computes a partition of the input triangular mesh into nparts parts, based on the mesh's dual graph...">CGAL::METIS::partition_dual_graph()</a></code> provide wrappers to the graph partitioning library METIS <a class="el" href="citelist.html#CITEREF_karypis1998fast">[3]</a>, allowing to split triangular meshes that are models of the concept <code><a class="el" href="classFaceListGraph.html" title="The concept FaceListGraph refines the concept FaceGraph and adds the requirement for traversal of all...">FaceListGraph</a></code> into a given number of subdomains.</p>
<p>The following example shows how to read, partition, and write a mesh using <code><a class="el" href="group__PkgBGLPartition.html#gad72efc6b61c92ee8704858dc0b7062e9" title="computes a partition of the input triangular mesh into nparts parts, based on the mesh's dual graph...">partition_dual_graph()</a></code>. The class template <code><a class="el" href="structCGAL_1_1Face__filtered__graph.html" title="The class Face_filtered_graph is an adaptor that creates a filtered view of a graph by restricting it...">CGAL::Face_filtered_graph</a></code> and the free function <code><a class="el" href="group__PkgBGLHelperFct.html#ga2682fb7d5f4ff4eb65607ae4118e31bc" title="copies a source model of FaceListGraph into a target model of a FaceListGraph. ">copy_face_graph()</a></code> are used to create an independent mesh from one of the subdomains of the partition. Note that the copy is optional as writing can be done directly using <code><a class="el" href="structCGAL_1_1Face__filtered__graph.html" title="The class Face_filtered_graph is an adaptor that creates a filtered view of a graph by restricting it...">Face_filtered_graph</a></code>.</p>
<p><br />
<b>File</b> <a class="el" href="BGL_surface_mesh_2surface_mesh_partition_8cpp-example.html">BGL_surface_mesh/surface_mesh_partition.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/Face_filtered_graph.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="partition_8h.html">CGAL/boost/graph/partition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/polygon_mesh_io.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>                           K;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;K::Point_3&gt;</a>                           SM;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string filename = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/blobby.off"</span>);</div><div class="line">  <span class="keywordtype">int</span> number_of_parts = (argc&gt;2) ? atoi(argv[2]) : 8;</div><div class="line"></div><div class="line">  SM sm;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__IO__grp.html#gac5b3295bd1b6375628a46d1fbaf7e881">CGAL::IO::read_polygon_mesh</a>(filename, sm))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// The vertex &lt;--&gt; partition_id property map</span></div><div class="line">  <span class="keyword">typedef</span> SM::Property_map&lt;SM::Vertex_index, std::size_t&gt;          Vertex_id_map;</div><div class="line">  Vertex_id_map vertex_pid_map = sm.add_property_map&lt;SM::Vertex_index, std::size_t&gt;(<span class="stringliteral">"v:pid"</span>).first;</div><div class="line"></div><div class="line">  <span class="comment">// The face &lt;--&gt; partition_id property map</span></div><div class="line">  <span class="keyword">typedef</span> SM::Property_map&lt;SM::Face_index, std::size_t&gt;            Face_id_map;</div><div class="line">  Face_id_map face_pid_map = sm.add_property_map&lt;SM::Face_index, std::size_t&gt;(<span class="stringliteral">"f:pid"</span>).first;</div><div class="line"></div><div class="line">  <span class="comment">// Partition the mesh</span></div><div class="line">  <a class="code" href="group__PkgBGLPartition.html#gad72efc6b61c92ee8704858dc0b7062e9">CGAL::METIS::partition_dual_graph</a>(sm, number_of_parts,</div><div class="line">                                    CGAL::parameters::vertex_partition_id_map(vertex_pid_map)</div><div class="line">                                                     .face_partition_id_map(face_pid_map));</div><div class="line"></div><div class="line">  <span class="comment">// Extract the part n°0 of the partition into a new, independent mesh</span></div><div class="line">  <span class="keyword">typedef</span> <a class="code" href="structCGAL_1_1Face__filtered__graph.html">CGAL::Face_filtered_graph&lt;SM&gt;</a>                            Filtered_graph;</div><div class="line">  Filtered_graph filtered_sm(sm, 0 <span class="comment">/*id of th part*/</span>, face_pid_map);</div><div class="line">  assert(filtered_sm.is_selection_valid());</div><div class="line">  SM part_sm;</div><div class="line">  <a class="code" href="group__PkgBGLHelperFct.html#ga2682fb7d5f4ff4eb65607ae4118e31bc">CGAL::copy_face_graph</a>(filtered_sm, part_sm);</div><div class="line"></div><div class="line">  <span class="comment">// Output the mesh extracted from subpart n°0</span></div><div class="line">  <a class="code" href="group__PkgBGLIOFct.html#gafa143949a33371dc6df8307be1ab8a66">CGAL::IO::write_polygon_mesh</a>(<span class="stringliteral">"sm_part_0.off"</span>, part_sm, CGAL::parameters::stream_precision(17));</div><div class="line"></div><div class="line">  <span class="comment">// Output all the vertices that are in the part n°0</span></div><div class="line">  std::ofstream outxyz(<span class="stringliteral">"out.xyz"</span>);</div><div class="line">  outxyz.precision(17);</div><div class="line">  boost::graph_traits&lt;SM&gt;::vertex_iterator vit, ve;</div><div class="line">  boost::tie(vit, ve) = vertices(sm);</div><div class="line">  <span class="keywordflow">for</span>(; vit!=ve; ++vit)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span>(<span class="keyword">get</span>(vertex_pid_map, *vit) == 0)</div><div class="line">      outxyz &lt;&lt; sm.point(*vit) &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><p>Using <a class="el" href="index.html#BGLNamedParameters">Named Parameters</a> some of the many options of METIS can be customized, as shown in <a class="el" href="BGL_polyhedron_3_2polyhedron_partition_8cpp-example.html">this example</a>.</p>
<h1><a class="anchor" id="BGLGraphcut"></a>
Graph Cut</h1>
<p>An optimal partition from a set of labels can be computed through a graph cut approach called alpha expansion <a class="el" href="citelist.html#CITEREF_Boykov2001FastApproximate">[1]</a>. CGAL provides <code><a class="el" href="group__PkgBGLPartition.html#gac0ae8f45718c0eb9b70ebddd5008515b" title="regularizes a partition of a graph into n labels using the alpha expansion algorithm ...">CGAL::alpha_expansion_graphcut()</a></code> which, for a graph \((V,E)\), computes the partition <code>f</code> that minimizes the following cost function:</p>
<p class="formulaDsp">
\[ \mathrm{C}(f) = \sum_{\{v0,v1\} \in E} C_E(v0,v1) + \sum_{v \in V} C_V(f_v) \]
</p>
<p>where \(C_E(v0,v1)\) is the edge cost of assigning a different label to \(v0\) and \(v1\), and \(C_V(f_v)\) is the vertex cost of assigning the label \(f\) to the vertex \(v\).</p>
<p>Three different implementations are provided and can be selected by using one of the following tags:</p>
<ul>
<li><code>CGAL::Alpha_expansion_boost_adjacency_list_tag</code> (default)</li>
<li><code>CGAL::Alpha_expansion_boost_compressed_sparse_raw_tag</code></li>
<li><code>CGAL::Alpha_expansion_MaxFlow_tag</code>, released under GPL license and provided by the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh_segmentation.tag:../Surface_mesh_segmentation/" href="../Surface_mesh_segmentation/group__PkgSurfaceMeshSegmentationRef.html">Triangulated Surface Mesh Segmentation Reference</a> package</li>
</ul>
<p>All these implementations produce the exact same result but behave differently in terms of timing and memory (see <a class="el" href="index.html#fig__alpha_exp">Figure 102.4</a>). The <em>MaxFlow</em> implementation is the fastest, but it grows rapidly in memory when increasing the complexity of the input graph and labeling; the <em>compressed sparse raw</em> (CSR) is very efficient from a memory point of view but becomes very slow as the complexity of the input graph and labeling increases; the <em>adjacency list</em> version provides a good compromise and is therefore the default implementation.</p>
<p><a class="anchor" id="fig__alpha_exp"></a></p><div class="image">
<img src="alpha_expansion.png" alt="alpha_expansion.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__alpha_exp">Figure 102.4</a> Comparison of time and memory consumed by the different alpha expansion implementations.  </div> <br /> 
<h2><a class="anchor" id="BGLGraphcutExample"></a>
Example</h2>
<p>The following example shows how to apply the alpha expansion algorithm to a <code>boost::adjacency_list</code> describing a 2D array with 3 labels "X", " " and "O":</p>
<p><br />
<b>File</b> <a class="el" href="BGL_graphcut_2alpha_expansion_example_8cpp-example.html">BGL_graphcut/alpha_expansion_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/alpha_expansion_graphcut.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/graph/adjacency_list.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>Vertex_property</div><div class="line">{</div><div class="line">  <span class="keywordtype">int</span> label;</div><div class="line">  std::vector&lt;double&gt; cost;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Edge_property</div><div class="line">{</div><div class="line">  <span class="keywordtype">double</span> weight;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">using</span> Graph = boost::adjacency_list &lt;boost::setS,</div><div class="line">                                     boost::vecS,</div><div class="line">                                     boost::undirectedS,</div><div class="line">                                     Vertex_property,</div><div class="line">                                     Edge_property&gt;;</div><div class="line"><span class="keyword">using</span> GT = boost::graph_traits&lt;Graph&gt;;</div><div class="line"><span class="keyword">using</span> vertex_descriptor = GT::vertex_descriptor;</div><div class="line"><span class="keyword">using</span> edge_descriptor = GT::edge_descriptor;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  std::array&lt;char, 3&gt; labels = { <span class="charliteral">'X'</span>, <span class="charliteral">' '</span>, <span class="charliteral">'O'</span> };</div><div class="line"></div><div class="line">  std::array&lt;std::array&lt;int, 6&gt;, 5&gt; input</div><div class="line">    = { { { 0, 2, 0, 1, 1, 1 },</div><div class="line">          { 0, 0, 1, 0, 1, 2 },</div><div class="line">          { 2, 0, 1, 1, 2, 2 },</div><div class="line">          { 0, 1, 1, 2, 2, 0 },</div><div class="line">          { 1, 1, 2, 0, 2, 2 } } };</div><div class="line"></div><div class="line">  std::array&lt;std::array&lt;vertex_descriptor, 6&gt;, 5&gt; vertices;</div><div class="line"></div><div class="line">  <span class="comment">// Init vertices from values</span></div><div class="line">  Graph g;</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; input.size(); ++ i)</div><div class="line">    <span class="keywordflow">for</span> (std::size_t j = 0; j &lt; input[i].size(); ++ j)</div><div class="line">    {</div><div class="line">      vertices[i][j] = boost::add_vertex(g);</div><div class="line">      g[vertices[i][j]].label = input[i][j];</div><div class="line"></div><div class="line">      <span class="comment">// Cost of assigning this vertex to any label is positive except</span></div><div class="line">      <span class="comment">// for current label which is 0 (favor init solution)</span></div><div class="line">      g[vertices[i][j]].cost.resize(3, 1);</div><div class="line">      g[vertices[i][j]].cost[std::size_t(input[i][j])] = 0;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="comment">// Display input values</span></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Input:"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; vertices.size(); ++ i)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (std::size_t j = 0; j &lt; vertices[i].size(); ++ j)</div><div class="line">      std::cerr &lt;&lt; labels[std::size_t(g[vertices[i][j]].label)];</div><div class="line">    std::cerr &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Init adjacency</span></div><div class="line">  <span class="keywordtype">double</span> weight = 0.5;</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; vertices.size(); ++ i)</div><div class="line">    <span class="keywordflow">for</span> (std::size_t j = 0; j &lt; vertices[i].size(); ++ j)</div><div class="line">    {</div><div class="line">      <span class="comment">// Neighbor vertices are connected</span></div><div class="line">      <span class="keywordflow">if</span> (i &lt; vertices.size() - 1)</div><div class="line">      {</div><div class="line">        edge_descriptor ed = <a class="code" href="group__PkgBGLEulerOperations.html#ga4661f850bc60686efeae2fc9d2ec3e65">boost::add_edge</a> (vertices[i][j], vertices[i+1][j], g).first;</div><div class="line">        g[ed].weight = weight;</div><div class="line">      }</div><div class="line">      <span class="keywordflow">if</span> (j &lt; vertices[i].size() - 1)</div><div class="line">      {</div><div class="line">        edge_descriptor ed = <a class="code" href="group__PkgBGLEulerOperations.html#ga4661f850bc60686efeae2fc9d2ec3e65">boost::add_edge</a> (vertices[i][j], vertices[i][j+1], g).first;</div><div class="line">        g[ed].weight = weight;</div><div class="line">      }</div><div class="line">    }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">"Alpha expansion..."</span> &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line">  <a class="code" href="group__PkgBGLPartition.html#gac0ae8f45718c0eb9b70ebddd5008515b">CGAL::alpha_expansion_graphcut</a> (g,</div><div class="line">                                  <span class="keyword">get</span> (&amp;Edge_property::weight, g),</div><div class="line">                                  <span class="keyword">get</span> (&amp;Vertex_property::cost, g),</div><div class="line">                                  <span class="keyword">get</span> (&amp;Vertex_property::label, g),</div><div class="line">                                  CGAL::parameters::vertex_index_map (<span class="keyword">get</span> (boost::vertex_index, g)));</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Display output graph</span></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Output:"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; vertices.size(); ++ i)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (std::size_t j = 0; j &lt; vertices[i].size(); ++ j)</div><div class="line">      std::cerr &lt;&lt; labels[std::size_t(g[vertices[i][j]].label)];</div><div class="line">    std::cerr &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>The output of this program shows how the initial 2D array is regularized spatially:</p>
<div class="fragment"><div class="line">Input:</div><div class="line">XOX</div><div class="line">XX X O</div><div class="line">OX  OO</div><div class="line">X  OOX</div><div class="line">  OXOO</div><div class="line"></div><div class="line">Alpha expansion...</div><div class="line"></div><div class="line">Output:</div><div class="line">XXX</div><div class="line">XX   O</div><div class="line">XX  OO</div><div class="line">X  OOO</div><div class="line">  OOOO</div></div><!-- fragment --><h2><a class="anchor" id="BGLGraphcutRegularizeSelection"></a>
Application to Regularization of the Borders of a Face Selection</h2>
<p>Manually selecting faces on a triangle mesh may create irregular borders (sawtooth) because of the shape of the triangles. Such borders can be regularized using the alpha expansion algorithm.</p>
<p>CGAL provides a function <code><a class="el" href="group__PkgBGLSelectionFct.html#gab638686b319f3b902c199d4b79df84e6" title="regularizes a selection in order to minimize the length of the border of the selection. ">CGAL::regularize_face_selection_borders()</a></code> to apply this algorithm to the borders of a face selection on a <code><a class="el" href="classFaceGraph.html" title="The concept FaceGraph refines the concept HalfedgeGraph. It adds the requirements for a graph to expl...">FaceGraph</a></code>. <a class="el" href="index.html#fig__regularization_fig">Figure 102.5</a> shows how this function affects a selection depending on the parameters.</p>
<p><a class="anchor" id="fig__regularization_fig"></a></p><div class="image">
<img src="regularize_selection.png" alt="regularize_selection.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__regularization_fig">Figure 102.5</a> Regularization of the borders of a face selection using alpha expansion. Different outputs are shown for different weight parameters, with and without preventing unselection.  </div> <br /> 
<p>The following example shows how to apply this alpha expansion regularization to the borders of a face selection of a <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh</a></code> object:</p>
<p><br />
<b>File</b> <a class="el" href="BGL_graphcut_2face_selection_borders_regularization_example_8cpp-example.html">BGL_graphcut/face_selection_borders_regularization_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/selection.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/OFF.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> Kernel = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> Mesh = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Kernel::Point_3&gt;</a>;</div><div class="line"><span class="keyword">using</span> Face_index = Mesh::Face_index;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::ifstream in((argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/blobby.off"</span>));</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!in)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: could not read input file"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  Mesh mesh;</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga7396bef8d41fe287d52d19ddbb83a3e4">CGAL::IO::read_OFF</a> (in, mesh);</div><div class="line"></div><div class="line">  std::unordered_map&lt;Face_index, bool&gt; is_selected_map;</div><div class="line"></div><div class="line">  <span class="comment">// randomly select 1/3 of faces</span></div><div class="line">  std::size_t nb_selected_before = 0;</div><div class="line">  CGAL::Random rand;</div><div class="line">  <span class="keywordflow">for</span> (Face_index fi : faces(mesh))</div><div class="line">  {</div><div class="line">    <span class="keywordtype">bool</span> selected = (rand.get_double() &lt; 1. / 3.);</div><div class="line">    is_selected_map[fi] = selected;</div><div class="line">    <span class="keywordflow">if</span> (selected)</div><div class="line">      nb_selected_before ++;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; nb_selected_before &lt;&lt; <span class="stringliteral">" selected before regularization"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgBGLSelectionFct.html#gab638686b319f3b902c199d4b79df84e6">CGAL::regularize_face_selection_borders</a> (mesh,</div><div class="line">                                           boost::make_assoc_property_map(is_selected_map),</div><div class="line">                                           0.5); <span class="comment">// using weight = 0.5</span></div><div class="line"></div><div class="line">  std::size_t nb_selected_after = 0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; sel : is_selected_map)</div><div class="line">    <span class="keywordflow">if</span> (sel.second)</div><div class="line">      ++ nb_selected_after;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; nb_selected_after &lt;&lt; <span class="stringliteral">" selected after regularization"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jun 27 2022 09:16:02 for CGAL 5.6 - CGAL and the Boost Graph Library by
    <a href="https://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>
</html>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.6 - CGAL and the Boost Graph Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_CGAL_and_the_Boost_Graph_Library"></a><a class="anchor" id="chapterBGL"></a> </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Authors</dt><dd>Andreas Fabri, Fernando Cacciola, Philipp Moeller, and Ron Wein</dd></dl>
<p>Many geometric data structures can be interpreted as graphs as they consist of vertices and edges. This is the case for the halfedge data structure, for the polyhedral surface, for the arrangement, and for the 2D triangulation classes. With means of duality one can also interpret faces as vertices and edges between adjacent faces as edges of the dual graph.</p>
<p>The scope of CGAL is geometry and not graph algorithms. Nevertheless, this package provides the necessary classes and functions that enable using the algorithms of the <a href="https://www.boost.org/libs/graph/doc/index.html">Boost Graph Library</a> <a class="el" href="citelist.html#CITEREF_cgal:sll-bgl-02">[4]</a> (BGL for short) with CGAL data structures.</p>
<p>Furthermore, this package extends the BGL by introducing concepts such as <code><a class="el" href="classHalfedgeGraph.html" title="The concept HalfedgeGraph is a refinement of the BGL concept IncidenceGraph and adds the notion of a ...">HalfedgeGraph</a></code> and <code><a class="el" href="classFaceGraph.html" title="The concept FaceGraph refines the concept HalfedgeGraph. It adds the requirements for a graph to expl...">FaceGraph</a></code> allowing to handle <em>halfedges</em> and <em>faces</em>. These concepts reflect the design of the halfedge data structure described in Chapter <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgHalfedgeDS">Halfedge Data Structures</a>, with opposite halfedges and circular sequences of halfedges around vertices and around faces.</p>
<p>This chapter is organized as follows:</p><ul>
<li>The first section, Section <a class="el" href="index.html#BGLA">A Short Introduction to the Boost Graph Library</a>, summarizes the main ideas of the BGL.</li>
<li>Section <a class="el" href="index.html#BGLHeader">Header Files, Namespaces, and Naming Conventions</a> then explains where to find header files and the chosen naming conventions, as we blend two different libraries.</li>
<li>The four following sections give examples on how to use <a class="el" href="namespaceCGAL.html" title="CGAL Namespace. ">CGAL</a> graph and mesh data structures such as <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceMesh">Surface_mesh </a>, <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgPolyhedron">Polyhedron </a>, <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgArrangementOnSurface2">Arrangement_2 </a>, and the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgTriangulation2">2D triangulation </a> classes as models of the BGL concepts.</li>
<li>Starting with Section <a class="el" href="index.html#BGLExtensions">Extensions of the BGL</a>, we introduce new graph concepts, classes, and functions that extend the functionalities of the BGL.</li>
</ul>
<h1><a class="anchor" id="BGLA"></a>
A Short Introduction to the Boost Graph Library</h1>
<p>The algorithms of the BGL operate on models of various <em>graph concepts</em>. The <em>traits class</em> <code>boost::graph_traits</code> enable algorithms to determine the types of vertices and edges (similar to <code>std::iterator_traits</code> for iterators). <em>Free functions</em> that operate on graphs enable algorithms to obtain, for example, the source vertex of an edge, or all edges incident to a vertex. The algorithms use <em>property maps</em> to associate information with vertices and edges. The algorithms enable <em>visitors</em> to register callbacks that are called later on during the execution of the algorithms. Finally, the graph algorithms use the <em>named parameter</em> mechanism, which enables passing the arguments in arbitrary order.</p>
<h2><a class="anchor" id="BGLGraphConcepts"></a>
Graph Concepts</h2>
<p>The BGL introduces several <a href="https://www.boost.org/libs/graph/doc/graph_concepts.html">graph concepts</a>, which have different sets of characteristics and requirements. For example, iterating through all vertices or all edges in a graph, obtaining the outgoing or in-going edges of a vertex, inserting vertices and edges into a graph, and removing vertices and edges from a graph.</p>
<h2><a class="anchor" id="BGLTheGraphTraitsClass"></a>
The Graph Traits Class</h2>
<p>An algorithm operating on a graph model determines types with the help of the traits class <a href="https://www.boost.org/libs/graph/doc/graph_traits.html">boost::graph_traits</a>. Such types are the <code>vertex_descriptor</code>, which is similar to a vertex handle in CGAL data structures, or the <code>edge_descriptor</code>, which is similar to the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/HalfedgeDS.tag:../HalfedgeDS/" href="../HalfedgeDS/classHalfedgeDSHalfedge.html">halfedge handle </a> in the halfedge data structure or to the type <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Triangulation__2.html#ad28c6e0e0e65b8aaecb1ae76d8744b33">Edge </a> in 2D triangulations. There are also iterators, such as the <code>vertex_iterator</code>, which is similar to a vertex iterator in CGAL data structures, and the <code>out_edge_iterator</code>, which is similar to the edge circulator; it enables to iterate through the edges incident to a vertex. The iterators are similar and not equivalent, because their value type is a <code>vertex_descriptor</code>, whereas in CGAL handles, iterators, and circulators all have the same value type, namely the vertex or edge types.</p>
<p>Given a graph type <code>G</code>, definitions of descriptors and iterators look as follows:</p>
<div class="fragment"><div class="line">boost::graph_traits&lt;Graph&gt;::vertex_descriptor vd;</div><div class="line">boost::graph_traits&lt;Graph&gt;::edge_iterator ei;</div><div class="line">...</div></div><!-- fragment --><h2><a class="anchor" id="BGLFreeFunctionsforExploringaGraph"></a>
Free Functions for Exploring a Graph</h2>
<p>Algorithms obtain incidence information in graphs with the help of global functions such as:</p><ul>
<li><code>std::pair&lt;vertex_iterator,vertex_iterator&gt; vertices(const Graph&amp; g);</code> to obtain an iterator range providing access to all the vertices, or</li>
<li><code>int num_vertices(const Graph&amp;);</code> to obtain the number of vertices of a graph, or</li>
<li><code>vertex_descriptor source(edge_descriptor, const Graph&amp;);</code> to obtain the source vertex of an edge.</li>
</ul>
<p>Note, that the way we have written the types is a simplification; in reality, the signature of the first of the above functions is:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Graph&gt;::vertex_iterator vertex_iterator;</div><div class="line">std::pair&lt;vertex_iterator,vertex_iterator&gt; vertices(<span class="keyword">const</span> Graph&amp; g);</div></div><!-- fragment --><h2><a class="anchor" id="BGLPropertyMaps"></a>
Property Maps</h2>
<p>Another feature extensively used in the BGL is the <em>property map</em>, which is offered by the <a href="https://www.boost.org/libs/property_map/doc/property_map.html">Boost Property Map Library</a>. Property maps are a general purpose interface for mapping key objects to corresponding value objects.</p>
<p>The BGL uses property maps to associate information with vertices and edges. This mechanism uses a traits class (<code>boost::property_traits</code>) and free functions to read (<code>get</code>) and write (<code>put</code>) information in vertices, edges, and also in halfedges and faces for models of the CGAL graph concepts. For example, the BGL Dijksta's shortest path algorithm writes the predecessor of each vertex, as well as the distance to the source in such a property map.</p>
<p>Some default property maps are associated with the graph types. They are called <em>internal property maps</em> and can be retrieved using an overload of the function <code>get()</code>. For example, </p><div class="fragment"><div class="line">pm = <span class="keyword">get</span>(boost::vertex_index, g)</div></div><!-- fragment --><p> returns a property map that associates an index in the range <code>[0, num_vertices(g))</code> with each vertex of the graph. This reduces the number of parameters to pass. The data itself may be stored in the vertex or the edge, or it may be stored in an external data structure, or it may be computed on the fly. This is an implementation detail of a particular property map.</p>
<p>See also Chapter <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgPropertyMap">CGAL and Boost Property Maps</a>.</p>
<h2><a class="anchor" id="BGLVisitors"></a>
Visitors</h2>
<p>Visitors are objects that provide functions to be called at specified event points by the algorithm that they visit. The functions as well as the event points are algorithm-specific. Examples of such event points in graph algorithms are when a vertex is traversed the first time, or when all outgoing edges of a vertex have been traversed.<br />
</p>
<p>See also Section <a href="https://www.boost.org/libs/graph/doc/visitor_concepts.html">Visitor Concepts</a> in the BGL manual.</p>
<h2><a class="anchor" id="BGLNamedParameters"></a>
Named Parameters</h2>
<p>The notion of <em>named parameters</em> was introduced in the BGL, and allow the user to specify only those parameters which are really needed, by name, making the parameter ordering unimportant. See also <a href="https://www.boost.org/libs/graph/doc/bgl_named_params.html">this page</a> in the manual of the BGL for more information.</p>
<p>Say there is a function <code>f()</code> that takes 3 parameters called name, age and gender, and you have variables <code>n</code>, <code>a</code> and <code>g</code> to pass as parameters to that function. Without named parameters, you would call it like this: <code>f(n,a,g)</code>, whereas with named parameters, you call it like this: <code>f(name(n).age(a).gender(g))</code>. That is, you give each parameter a name by wrapping it into a function whose name matches that of the parameter. The entire list of named parameters is really a composition of function calls separated by a dot ("."). Thus, if the function takes a mix of mandatory and named parameters, you use a comma to separate the last non-named parameter from the first named parameters, like this: </p><div class="fragment"><div class="line">f(non_named_par0, non_named_par1, name(n).age(a).gender(g))</div></div><!-- fragment --><p> When you use named parameters, the ordering is irrelevant, so <code>f(name(n).age(a).gender(g))</code> is equivalent to <code>f(age(a).gender(g).name(n))</code>, and you can just omit any named parameter that has a default value.</p>
<p>The sequence of named parameters should start with <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL_1_1parameters.html">CGAL::parameters</a>::</code>.</p>
<h3><a class="anchor" id="BGLNamedParametersExample"></a>
Example</h3>
<p>Below is a sample call of a function that uses the optional BGL named parameters.</p>
<div class="fragment"><div class="line"><span class="comment">// pmesh : polygon mesh with patches to be refined</span></div><div class="line"><span class="comment">// faces : the range of faces defining the patches to refine</span></div><div class="line"><span class="comment">// faces_out : output iterator into which descriptors of new faces are put</span></div><div class="line"><span class="comment">// vertices_out : output iterator into which descriptors of new vertices are put</span></div><div class="line"><span class="comment">// vertex_point_map : the property map with the points associated to the vertices of `pmesh`</span></div><div class="line"><span class="comment">// density_control_factor : factor to control density of the output mesh</span></div><div class="line"><a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__meshing__grp.html#gafd90c169a7c17a1e503651f59a6dc57b">refine</a>(pmesh,</div><div class="line">       faces,</div><div class="line">       faces_out,</div><div class="line">       vertices_out,</div><div class="line">       CGAL::parameters::vertex_point_map(vpmap)</div><div class="line">                        .density_control_factor(d));</div></div><!-- fragment --><h1><a class="anchor" id="BGLHeader"></a>
Header Files, Namespaces, and Naming Conventions</h1>
<p>This package provides the necessary classes and functions that enable using CGAL data structures as models of the BGL graph concepts. To this end, we offer partial specializations of the <code>boost::graph_traits&lt;Graph&gt;</code> for various CGAL packages. For each such package, denoted <code>PACKAGE</code>, the partial specializations live in the namespace <code>boost</code> and are located in the header file <code>CGAL/boost/graph/graph_traits_PACKAGE.h</code>. Free functions are in the namespace <code><a class="el" href="namespaceCGAL.html" title="CGAL Namespace. ">CGAL</a></code>, and the compiler uses argument-dependent lookup to find them. Euler operations, described in Section <a class="el" href="index.html#BGLEulerOperations">Euler Operations</a>, are in the namespace <code>CGAL::Euler</code>, as the function <code><a class="el" href="classMutableFaceGraph.html#abf15bb91e6cdafb057514db8acf38a08">remove_face()</a></code> is at the same time a low-level and an Euler operation. Concerning the naming conventions, we have to use those of the BGL, as to fulfill the requirements of the concepts defined in the BGL.</p>
<p>Note that these partial specializations are often providing more than is required, making these classes not only models of the graph concepts of the BGL, but also models of the <a class="el" href="namespaceCGAL.html" title="CGAL Namespace. ">CGAL</a> graph concepts, that will be described in detail in Section <a class="el" href="index.html#BGLExtensions">Extensions of the BGL</a>. Correspondence tables between the types of a CGAL data structure and their BGL equivalents can be found in the <a class="el" href="group__PkgBGLTraits.html">Specializations of boost::graph_traits</a> documentation page.</p>
<p>We present in the following sections some examples of utilization of some CGAL data structures as BGL graphs.</p>
<h1><a class="anchor" id="BGLSurface_mesh"></a>
The Class Surface_mesh as Model of the Boost Graph Concept</h1>
<p>The class <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">Surface_mesh</a></code> is a model of most of the graph concepts of the BGL as well as the concepts provided by CGAL. A complete list can be found in the documentation of <a class="el" href="group__PkgBGLTraits.html#BGLSMGT">boost::graph_traits </a>. The examples show how to use some of the BGL algorithms with <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">Surface_mesh</a></code> and show how to use the concepts provided by CGAL to implement a simple algorithm.</p>
<h2><a class="anchor" id="BGLExampleMinimumSpanningTreeofaSurfaceMesh"></a>
Example: Minimum Spanning Tree of a Surface_mesh</h2>
<p>The following example program computes the minimum spanning tree on a surface mesh. More examples can be found in Chapters <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceMeshSimplification">Triangulated Surface Mesh Simplification</a>, <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceMeshSegmentation">Triangulated Surface Mesh Segmentation</a>, and <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceMeshDeformation">Triangulated Surface Mesh Deformation</a>.</p>
<p>The surface mesh class uses integer indices to address vertices and edges, and it comes with a built-in property mechanism that maps nicely on the BGL.</p>
<p><br />
<b>File</b> <a class="el" href="BGL_surface_mesh_2prim_8cpp-example.html">BGL_surface_mesh/prim.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/prim_minimum_spanning_tree.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>                       <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                                      Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point&gt;</a>                            Mesh;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::vertex_descriptor vertex_descriptor;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string filename = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/prim.off"</span>);</div><div class="line"></div><div class="line">  Mesh P;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__IO__grp.html#gac5b3295bd1b6375628a46d1fbaf7e881">CGAL::IO::read_polygon_mesh</a>(filename, P))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line">  Mesh::Property_map&lt;vertex_descriptor,vertex_descriptor&gt; <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__STLAlgos.html#ga6c5d40930db429775066babac7c35d7f">predecessor</a>;</div><div class="line">  predecessor = P.add_property_map&lt;vertex_descriptor,vertex_descriptor&gt;(<span class="stringliteral">"v:predecessor"</span>).first;</div><div class="line"></div><div class="line">  boost::prim_minimum_spanning_tree(P, predecessor, boost::root_vertex(*vertices(P).first));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"#VRML V2.0 utf8\n"</span></div><div class="line">    <span class="stringliteral">"DirectionalLight {\n"</span></div><div class="line">    <span class="stringliteral">"direction 0 -1 0\n"</span></div><div class="line">    <span class="stringliteral">"}\n"</span></div><div class="line">    <span class="stringliteral">"Shape {\n"</span></div><div class="line">    <span class="stringliteral">"  appearance Appearance {\n"</span></div><div class="line">    <span class="stringliteral">"    material Material { emissiveColor 1 0 0}}\n"</span></div><div class="line">    <span class="stringliteral">"    geometry\n"</span></div><div class="line">    <span class="stringliteral">"    IndexedLineSet {\n"</span></div><div class="line">    <span class="stringliteral">"      coord Coordinate {\n"</span></div><div class="line">    <span class="stringliteral">"        point [ \n"</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(vertex_descriptor vd : vertices(P)){</div><div class="line">    std::cout &lt;&lt;  <span class="stringliteral">"        "</span> &lt;&lt; P.point(vd) &lt;&lt; <span class="stringliteral">"\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"        ]\n"</span></div><div class="line">    <span class="stringliteral">"     }\n"</span></div><div class="line">    <span class="stringliteral">"      coordIndex [\n"</span>;</div><div class="line">  <span class="keywordflow">for</span>(vertex_descriptor vd : vertices(P)){</div><div class="line">    <span class="keywordflow">if</span>(predecessor[vd]!=vd){</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">"      "</span> &lt;&lt; std::size_t(vd) &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; std::size_t(predecessor[vd]) &lt;&lt;  <span class="stringliteral">", -1\n"</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"]\n"</span></div><div class="line">    <span class="stringliteral">"  }#IndexedLineSet\n"</span></div><div class="line">    <span class="stringliteral">"}# Shape\n"</span>;</div><div class="line"></div><div class="line">  P.remove_property_map(predecessor);</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="BGLPolyhedral"></a>
The Class Polyhedron_3 as Model of the Boost Graph Concept</h1>
<p>The class <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">Polyhedron_3</a></code> is a model of most of the graph concepts of the BGL as well as the concepts provided by CGAL. A complete list can be found in the documentation of <a class="el" href="group__PkgBGLTraits.html#BGLPolyGT">boost::graph_traits </a>. The examples show how to use some of the BGL algorithms with <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">Polyhedron_3</a></code> and show how to use the concepts provided by CGAL to implement a simple algorithm.</p>
<h2><a class="anchor" id="BGLExampleMinimumSpanningTreeofaPolyhedral"></a>
Example: Minimum Spanning Tree of a Polyhedral Surface</h2>
<p>The following example program computes the minimum spanning tree on a polyhedral surface. More examples can be found in the Chapter <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceMeshSimplification">Triangulated Surface Mesh Simplification</a>.</p>
<p><br />
<b>File</b> <a class="el" href="BGL_polyhedron_3_2kruskal_8cpp-example.html">BGL_polyhedron_3/kruskal.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/kruskal_min_spanning_tree.h&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>                       Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a>                                     Vector;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                                      Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;Kernel&gt;</a>                           Polyhedron;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt;::vertex_descriptor vertex_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt;::vertex_iterator   vertex_iterator;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt;::edge_descriptor   edge_descriptor;</div><div class="line"></div><div class="line"><span class="comment">// The BGL makes heavy use of indices associated to the vertices</span></div><div class="line"><span class="comment">// We use a std::map to store the index</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::map&lt;vertex_descriptor,int&gt; Vertex_index_map;</div><div class="line">Vertex_index_map vertex_index_map;</div><div class="line"></div><div class="line"><span class="comment">// A std::map is not a property map, because it is not lightweight</span></div><div class="line"><span class="keyword">typedef</span> boost::associative_property_map&lt;Vertex_index_map&gt; Vertex_index_pmap;</div><div class="line">Vertex_index_pmap vertex_index_pmap(vertex_index_map);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">kruskal(<span class="keyword">const</span> Polyhedron&amp; P)</div><div class="line">{</div><div class="line">  <span class="comment">// associate indices to the vertices</span></div><div class="line">  vertex_iterator vb, ve;</div><div class="line">  <span class="keywordtype">int</span> index = 0;</div><div class="line"></div><div class="line">  <span class="comment">// boost::tie assigns the first and second element of the std::pair</span></div><div class="line">  <span class="comment">// returned by boost::vertices to the variables vb and ve</span></div><div class="line">  <span class="keywordflow">for</span>(boost::tie(vb, ve)=vertices(P); vb!=ve; ++vb){</div><div class="line">    vertex_index_pmap[*vb]= index++;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// We use the default edge weight which is the length of the edge</span></div><div class="line">  <span class="comment">// This property map is defined in graph_traits_Polyhedron_3.h</span></div><div class="line"></div><div class="line">  <span class="comment">// In the function call you can see a named parameter: vertex_index_map</span></div><div class="line">  std::list&lt;edge_descriptor&gt; mst;</div><div class="line"></div><div class="line">  boost::kruskal_minimum_spanning_tree(P,</div><div class="line">                                       std::back_inserter(mst),</div><div class="line">                                       boost::vertex_index_map(vertex_index_pmap));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"#VRML V2.0 utf8\n"</span></div><div class="line">    <span class="stringliteral">"Shape {\n"</span></div><div class="line">    <span class="stringliteral">"  appearance Appearance {\n"</span></div><div class="line">    <span class="stringliteral">"    material Material { emissiveColor 1 0 0}}\n"</span></div><div class="line">    <span class="stringliteral">"    geometry\n"</span></div><div class="line">    <span class="stringliteral">"    IndexedLineSet {\n"</span></div><div class="line">    <span class="stringliteral">"      coord Coordinate {\n"</span></div><div class="line">    <span class="stringliteral">"        point [ \n"</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(boost::tie(vb, ve) = vertices(P); vb!=ve; ++vb){</div><div class="line">    std::cout &lt;&lt;  <span class="stringliteral">"        "</span> &lt;&lt; (*vb)-&gt;point() &lt;&lt; <span class="stringliteral">"\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"        ]\n"</span></div><div class="line">               <span class="stringliteral">"     }\n"</span></div><div class="line">    <span class="stringliteral">"      coordIndex [\n"</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(std::list&lt;edge_descriptor&gt;::iterator it = mst.begin(); it != mst.end(); ++it)</div><div class="line">  {</div><div class="line">    edge_descriptor e = *it ;</div><div class="line">    vertex_descriptor s = source(e,P);</div><div class="line">    vertex_descriptor t = target(e,P);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"      "</span> &lt;&lt; vertex_index_pmap[s] &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; vertex_index_pmap[t] &lt;&lt;  <span class="stringliteral">", -1\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"]\n"</span></div><div class="line">    <span class="stringliteral">"  }#IndexedLineSet\n"</span></div><div class="line">    <span class="stringliteral">"}# Shape\n"</span>;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">  Polyhedron P;</div><div class="line">  Point a(1,0,0);</div><div class="line">  Point b(0,1,0);</div><div class="line">  Point c(0,0,1);</div><div class="line">  Point d(0,0,0);</div><div class="line"></div><div class="line">  P.make_tetrahedron(a,b,c,d);</div><div class="line"></div><div class="line">  kruskal(P);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="BGLExampleUsingVerticesandEdgeswithanID"></a>
Example: Using Vertices, and Edges with an ID</h2>
<p>The following example program shows a call to the BGL Kruskal's minimum spanning tree algorithm accessing the <code>id()</code> field stored in a polyhedron vertex.</p>
<p>The main function illustrates the access to the <code>id()</code> field.</p>
<p><br />
<b>File</b> <a class="el" href="BGL_polyhedron_3_2kruskal_with_stored_id_8cpp-example.html">BGL_polyhedron_3/kruskal_with_stored_id.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_items_with_id_3.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/kruskal_min_spanning_tree.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>                               Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                                              Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;Kernel,CGAL::Polyhedron_items_with_id_3&gt;</a>  Polyhedron;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt;::vertex_descriptor vertex_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt;::vertex_iterator   vertex_iterator;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt;::edge_descriptor   edge_descriptor;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">kruskal( <span class="keyword">const</span> Polyhedron&amp; P)</div><div class="line">{</div><div class="line"></div><div class="line">  <span class="comment">// We use the default edge weight which is the length of the edge</span></div><div class="line">  <span class="comment">// This property map is defined in graph_traits_Polyhedron_3.h</span></div><div class="line"></div><div class="line">  <span class="comment">// This function call requires a vertex_index_map named parameter which</span></div><div class="line">  <span class="comment">// when  ommitted defaults to "get(vertex_index,graph)".</span></div><div class="line">  <span class="comment">// That default works here because the vertex type has an "id()" method</span></div><div class="line">  <span class="comment">// field which is used by the vertex_index internal property.</span></div><div class="line">  std::list&lt;edge_descriptor&gt; mst;</div><div class="line">  boost::kruskal_minimum_spanning_tree(P,std::back_inserter(mst));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"#VRML V2.0 utf8\n"</span></div><div class="line">    <span class="stringliteral">"Shape {\n"</span></div><div class="line">    <span class="stringliteral">"appearance Appearance {\n"</span></div><div class="line">    <span class="stringliteral">"material Material { emissiveColor 1 0 0}}\n"</span></div><div class="line">    <span class="stringliteral">"geometry\n"</span></div><div class="line">    <span class="stringliteral">"IndexedLineSet {\n"</span></div><div class="line">    <span class="stringliteral">"coord Coordinate {\n"</span></div><div class="line">    <span class="stringliteral">"point [ \n"</span>;</div><div class="line"></div><div class="line">  vertex_iterator vb, ve;</div><div class="line">  <span class="keywordflow">for</span>(boost::tie(vb,ve) = vertices(P); vb!=ve; ++vb){</div><div class="line">    std::cout &lt;&lt; (*vb)-&gt;point() &lt;&lt; <span class="stringliteral">"\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"]\n"</span></div><div class="line">    <span class="stringliteral">"}\n"</span></div><div class="line">    <span class="stringliteral">"coordIndex [\n"</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(std::list&lt;edge_descriptor&gt;::iterator it = mst.begin(); it != mst.end(); ++it){</div><div class="line">    std::cout &lt;&lt; source(*it,P)-&gt;id()</div><div class="line">              &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; target(*it,P)-&gt;id() &lt;&lt;  <span class="stringliteral">", -1\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"]\n"</span></div><div class="line">    <span class="stringliteral">"}#IndexedLineSet\n"</span></div><div class="line">    <span class="stringliteral">"}# Shape\n"</span>;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">  Polyhedron P;</div><div class="line"></div><div class="line">  Point a(1,0,0);</div><div class="line">  Point b(0,1,0);</div><div class="line">  Point c(0,0,1);</div><div class="line">  Point d(0,0,0);</div><div class="line"></div><div class="line">  P.make_tetrahedron(a,b,c,d);</div><div class="line"></div><div class="line">  <span class="comment">// associate indices to the vertices using the "id()" field of the vertex.</span></div><div class="line">  vertex_iterator vb, ve;</div><div class="line">  <span class="keywordtype">int</span> index = 0;</div><div class="line"></div><div class="line">  <span class="comment">// boost::tie assigns the first and second element of the std::pair</span></div><div class="line">  <span class="comment">// returned by boost::vertices to the variables vit and ve</span></div><div class="line">  <span class="keywordflow">for</span>(boost::tie(vb,ve)=vertices(P); vb!=ve; ++vb ){</div><div class="line">    vertex_descriptor  vd = *vb;</div><div class="line">    vd-&gt;id() = index++;</div><div class="line">  }</div><div class="line"></div><div class="line">  kruskal(P);</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="BGLTriangulations"></a>
Triangulations as Models of the Boost Graph Concept</h1>
<p>Triangulations have vertices and faces, allowing for a direct translation as a graph. A halfedge is defined as a pair of a face handle and the index of the edge. A complete list can be found in the documentation of <a class="el" href="group__PkgBGLTraits.html#BGLT2GT">boost::graph_traits </a>.</p>
<p>A classical example for an algorithm that is a combination of computational geometry and graph theory is the <em>Euclidean Minimum Spanning Tree</em> for a point set in the plane. It can be computed by running the minimum spanning tree algorithm on a Delaunay triangulation of the point set.</p>
<h2><a class="anchor" id="BGLExampleEuclideanMinimumSpanningTree"></a>
Example: Euclidean Minimum Spanning Tree</h2>
<p>In the following example we create a Delaunay triangulation and run Kruskal's minimum spanning tree algorithm on it. Because the vertex handles of the triangulation are not indices in an array, we have to provide a property map that maps vertex handles to integers in the range <code>[0, t.number_of_vertices())</code>.</p>
<p><br />
<b>File</b> <a class="el" href="BGL_triangulation_2_2emst_8cpp-example.html">BGL_triangulation_2/emst.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Delaunay_triangulation_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/graph_traits_Delaunay_triangulation_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/kruskal_min_spanning_tree.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>         K;</div><div class="line"><span class="keyword">typedef</span> K::Point_2                                                  Point;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2&lt;K&gt;</a>                           Triangulation;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Triangulation&gt;::vertex_descriptor       vertex_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Triangulation&gt;::vertex_iterator         vertex_iterator;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Triangulation&gt;::edge_descriptor         edge_descriptor;</div><div class="line"></div><div class="line"><span class="comment">// The BGL makes use of indices associated to the vertices</span></div><div class="line"><span class="comment">// We use a std::map to store the index</span></div><div class="line"><span class="keyword">typedef</span> std::map&lt;vertex_descriptor,int&gt;                             VertexIndexMap;</div><div class="line"></div><div class="line"><span class="comment">// A std::map is not a property map, because it is not lightweight</span></div><div class="line"><span class="keyword">typedef</span> boost::associative_property_map&lt;VertexIndexMap&gt;             VertexIdPropertyMap;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc,<span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename = (argc &gt; 1) ? argv[1] : <span class="stringliteral">"data/points.xy"</span>;</div><div class="line">  std::ifstream input(filename);</div><div class="line">  Triangulation tr;</div><div class="line"></div><div class="line">  Point p;</div><div class="line">  <span class="keywordflow">while</span>(input &gt;&gt; p)</div><div class="line">    tr.insert(p);</div><div class="line"></div><div class="line">  <span class="comment">// Associate indices to the vertices</span></div><div class="line">  VertexIndexMap vertex_id_map;</div><div class="line">  VertexIdPropertyMap vertex_index_pmap(vertex_id_map);</div><div class="line">  <span class="keywordtype">int</span> index = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(vertex_descriptor vd : vertices(tr))</div><div class="line">    vertex_id_map[vd] = index++;</div><div class="line"></div><div class="line">  <span class="comment">// We use the default edge weight which is the squared length of the edge</span></div><div class="line">  <span class="comment">// This property map is defined in graph_traits_Triangulation_2.h</span></div><div class="line"></div><div class="line">  <span class="comment">// In the function call you can see a named parameter: vertex_index_map</span></div><div class="line">  std::list&lt;edge_descriptor&gt; mst;</div><div class="line">  boost::kruskal_minimum_spanning_tree(tr, std::back_inserter(mst),</div><div class="line">                                       vertex_index_map(vertex_index_pmap));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The edges of the Euclidean mimimum spanning tree:"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span>(edge_descriptor ed : mst)</div><div class="line">  {</div><div class="line">    vertex_descriptor svd = source(ed, tr);</div><div class="line">    vertex_descriptor tvd = target(ed, tr);</div><div class="line">    Triangulation::Vertex_handle sv = svd;</div><div class="line">    Triangulation::Vertex_handle tv = tvd;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"[ "</span> &lt;&lt; sv-&gt;point() &lt;&lt; <span class="stringliteral">"  |  "</span> &lt;&lt; tv-&gt;point() &lt;&lt; <span class="stringliteral">" ] "</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="BGLExampleStoringtheVertexIDintheVertex"></a>
Example: Storing the Vertex ID in the Vertex</h2>
<p>The algorithms of the BGL extensively use of the indices of vertices. In the previous example we stored the indices in a <code>std::map</code> and turned that map in a property map. This property map was then passed as argument to the shortest path function.</p>
<p>If the user does not pass explicitly a property map, the graph algorithms use the property map returned by the call <code>get(boost::vertex_index,ft)</code>. This property map assumes that the vertex has a member function <code>id()</code> that returns a reference to an int. Therefore CGAL offers a class <code><a class="el" href="classCGAL_1_1Triangulation__vertex__base__with__id__2.html" title="The class Triangulation_vertex_base_with_id_2 is a model of the concept TriangulationVertexBase_2, the base vertex of a 2D-triangulation. ">Triangulation_vertex_base_with_id_2</a></code>. It is in the user's responsibility to set the indices properly.</p>
<p>The example further illustrates that the graph traits also works for the Delaunay triangulation.</p>
<p><br />
<b>File</b> <a class="el" href="BGL_triangulation_2_2dijkstra_with_internal_properties_8cpp-example.html">BGL_triangulation_2/dijkstra_with_internal_properties.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Delaunay_triangulation_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Triangulation_vertex_base_with_id_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/graph_traits_Delaunay_triangulation_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/dijkstra_shortest_paths.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>             K;</div><div class="line"><span class="keyword">typedef</span> K::Point_2                                                      Point;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Triangulation__vertex__base__with__id__2.html">CGAL::Triangulation_vertex_base_with_id_2&lt;K&gt;</a>                    Tvb;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Triangulation__face__base__2.html">CGAL::Triangulation_face_base_2&lt;K&gt;</a>                              Tfb;</div><div class="line"><span class="keyword">typedef</span> CGAL::Triangulation_data_structure_2&lt;Tvb, Tfb&gt;                  Tds;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2&lt;K, Tds&gt;</a>                          Triangulation;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Triangulation&gt;::vertex_descriptor           vertex_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Triangulation&gt;::vertex_iterator             vertex_iterator;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::property_map&lt;Triangulation, boost::vertex_index_t&gt;::type VertexIdPropertyMap;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc,<span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename = (argc &gt; 1) ? argv[1] : <span class="stringliteral">"data/points.xy"</span>;</div><div class="line">  std::ifstream input(filename);</div><div class="line">  Triangulation tr;</div><div class="line"></div><div class="line">  Point p;</div><div class="line">  <span class="keywordflow">while</span>(input &gt;&gt; p)</div><div class="line">    tr.insert(p);</div><div class="line"></div><div class="line">  <span class="comment">// associate indices to the vertices</span></div><div class="line">  <span class="keywordtype">int</span> index = 0;</div><div class="line">  <span class="keywordflow">for</span>(vertex_descriptor vd : vertices(tr))</div><div class="line">    vd-&gt;id()= index++;</div><div class="line"></div><div class="line">  VertexIdPropertyMap vertex_index_pmap = <span class="keyword">get</span>(boost::vertex_index, tr);</div><div class="line"></div><div class="line">  <span class="comment">// Dijkstra's shortest path needs property maps for the predecessor and distance</span></div><div class="line">  std::vector&lt;vertex_descriptor&gt; <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__STLAlgos.html#ga6c5d40930db429775066babac7c35d7f">predecessor</a>(num_vertices(tr));</div><div class="line">  boost::iterator_property_map&lt;std::vector&lt;vertex_descriptor&gt;::iterator, VertexIdPropertyMap&gt;</div><div class="line">    predecessor_pmap(predecessor.begin(), vertex_index_pmap);</div><div class="line"></div><div class="line">  std::vector&lt;double&gt; distance(num_vertices(tr));</div><div class="line">  boost::iterator_property_map&lt;std::vector&lt;double&gt;::iterator, VertexIdPropertyMap&gt;</div><div class="line">    distance_pmap(distance.begin(), vertex_index_pmap);</div><div class="line"></div><div class="line">  vertex_descriptor source = *vertices(tr).first;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"\nStart dijkstra_shortest_paths at "</span> &lt;&lt; source-&gt;point() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  boost::dijkstra_shortest_paths(tr, source, distance_map(distance_pmap)</div><div class="line">                                            .predecessor_map(predecessor_pmap));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(vertex_descriptor vd : vertices(tr))</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; vd-&gt;point() &lt;&lt; <span class="stringliteral">" ["</span> &lt;&lt; vd-&gt;id() &lt;&lt; <span class="stringliteral">"] "</span>;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">" has distance = "</span>  &lt;&lt; <span class="keyword">get</span>(distance_pmap,vd) &lt;&lt; <span class="stringliteral">" and predecessor "</span>;</div><div class="line"></div><div class="line">    vd = <span class="keyword">get</span>(predecessor_pmap,vd);</div><div class="line">    std::cout &lt;&lt; vd-&gt;point() &lt;&lt; <span class="stringliteral">" ["</span> &lt;&lt; vd-&gt;id() &lt;&lt; <span class="stringliteral">"]\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="BGLArrangements"></a>
Arrangements as Models of the Boost Graph Concept</h1>
<p>CGAL offers a partial specialization of the boost graph traits for its arrangement class as well as for its dual graph.</p>
<h2><a class="anchor" id="arr_sssecbgl_primal"></a>
Example for the Arrangement as Graph</h2>
<p>Arrangement instances are adapted to <em>boost</em> graphs by specializing the <code>boost::graph_traits</code> template for <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> instances. The graph-traits states the graph concepts that the arrangement class models (see below) and defines the types required by these concepts.</p>
<p>In this specialization the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> vertices correspond to the graph vertices, where two vertices are adjacent if there is at least one halfedge connecting them. More precisely, <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#a7cdc734c8b7109fe4f62b2467d05b5c3">Arrangement_2::Vertex_handle</a></code> is the graph-vertex type, while <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#adf9ae7012e73ea8f327ab59515b00828">Arrangement_2::Halfedge_handle</a></code> is the graph-edge type. As halfedges are directed, we consider the graph to be directed as well. Moreover, as several interior-disjoint \( x\)-monotone curves (say circular arcs) may share two common endpoints, inducing an arrangement with two vertices that are connected with several edges, we allow parallel edges in our <em>boost</em> graph.</p>
<p>Given an <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> instance, we can efficiently traverse its vertices and halfedges. Thus, the arrangement graph is a model of the concepts <code><a class="el" href="classVertexListGraph.html" title="Concept from the Boost Graph Library. See https://www.boost.org/libs/graph/doc/VertexListGraph.html. ">VertexListGraph</a></code> and <code><a class="el" href="classEdgeListGraph.html" title="Concept from the Boost Graph Library. See https://www.boost.org/libs/graph/doc/EdgeListGraph.html. ">EdgeListGraph</a></code> introduced by the BGL. At the same time, we use an iterator adapter of the circulator over the halfedges incident to a vertex (<code><a class="el" href="classCGAL_1_1Halfedge__around__target__circulator.html" title="A bidirectional circulator with value type boost::graph_traits&lt;Graph&gt;::halfedge_descriptor over all h...">Halfedge_around_target_circulator</a></code> - see Section <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/index.html#arr_sssectr_vertex">Traversal Methods for an Arrangement Vertex</a> of the chapter on arrangements), so it is possible to go over the ingoing and outgoing edges of a vertex in linear time. Thus, our arrangement graph is a model of the concept <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classBidirectionalGraph.html">BidirectionalGraph</a></code> (this concept refines <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classIncidenceGraph.html">IncidenceGraph</a></code>, which requires only the traversal of outgoing edges).</p>
<p>It is important to notice that the vertex descriptors we use are <code>Vertex_handle</code> objects and <em>not</em> vertex indices. However, in order to gain more efficiency in most BGL algorithm, it is better to have them indexed \( 0, 1, \ldots, (n-1)\), where \( n\) is the number of vertices. We therefore introduce the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__vertex__index__map.html">Arr_vertex_index_map</a>&lt;Arrangement&gt;</code> class-template, which maintains a mapping of vertex handles to indices, as required by the BGL. An instance of this class must be attached to a valid arrangement vertex when it is created. It uses the notification mechanism (see Section <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/index.html#arr_ssecnotif">The Notification Mechanism</a>) to automatically maintain the mapping of vertices to indices, even when new vertices are inserted into the arrangement or existing vertices are removed.</p>
<p>A complete description of the types correspondences can be found in the documentation of <a class="el" href="group__PkgBGLTraits.html#BGLArgtGT">boost::graph_traits </a>.</p>
<p>In most algorithm provided by the BGL, the output is given by <em>property maps</em>, such that each map entry corresponds to a vertex. For example, when we compute the shortest paths from a given source vertex \( s\) to all other vertices we can obtain a map of distances and a map of predecessors - namely for each \( v\) vertex we have its distance from \( s\) and a descriptor of the vertex that precedes \( v\) in the shortest path from \( s\). If the vertex descriptors are simply indices, one can use vectors to efficiently represent the property maps. As this is not the case with the arrangement graph, we offer the <code>Arr_vertex_property_map&lt;Arrangement,Type&gt;</code> template allows for an efficient mapping of <code>Vertex_handle</code> objects to properties of type <code>Type</code>. Note however that unlike the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__vertex__index__map.html">Arr_vertex_index_map</a></code> class, the vertex property-map class is not kept synchronized with the number of vertices in the arrangement, so it should not be reused in calls to the BGL functions in case the arrangement is modified in between these calls.</p>
<p><a class="anchor" id="fig__figex_bgl"></a></p><div class="image">
<img src="ex_bgl.png" alt="ex_bgl.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__figex_bgl">Figure 102.1</a> An arrangement of 7 line segments, as constructed by <code>bgl_primal_adapter.cpp</code> and <code>bgl_dual_adapter.cpp</code>. The breadth-first visit times for the arrangement faces, starting from the unbounded face \( f_0\), are shown in brackets.  </div> <br /> 
<p>In the following example we construct an arrangement of 7 line segments, as shown in <a class="el" href="index.html#fig__figex_bgl">Figure 102.1</a>, then use the BGL Dijkstra's shortest-paths algorithm to compute the graph distance of all vertices from the leftmost vertex in the arrangement \( v_0\). Note the usage of the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__vertex__index__map.html">Arr_vertex_index_map</a></code> and the <code>Arr_vertex_property_map</code> classes. The latter one, instantiated by the type <code>double</code> is used to map vertices to their distances from \( v_0\).</p>
<p><br />
<b>File</b> <a class="el" href="BGL_arrangement_2_2primal_8cpp-example.html">BGL_arrangement_2/primal.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Adapting an arrangement to a BGL graph.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_rational_nt.h"</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_segment_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/graph_traits_Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_vertex_index_map.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/dijkstra_shortest_paths.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;Number_type&gt;</a>                    Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__segment__traits__2.html">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</a>              Traits_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Point_2                               Point_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::X_monotone_curve_2                    Segment_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2&gt;</a>                   Arrangement_2;</div><div class="line"></div><div class="line"><span class="comment">// A functor used to compute the length of an edge.</span></div><div class="line"><span class="keyword">class </span>Edge_length_func</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">  <span class="comment">// Boost property type definitions:</span></div><div class="line">  <span class="keyword">typedef</span> boost::readable_property_map_tag        category;</div><div class="line">  <span class="keyword">typedef</span> <span class="keywordtype">double</span>                                  value_type;</div><div class="line">  <span class="keyword">typedef</span> value_type                              reference;</div><div class="line">  <span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#adf9ae7012e73ea8f327ab59515b00828">Arrangement_2::Halfedge_handle</a>          key_type;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> operator()(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#adf9ae7012e73ea8f327ab59515b00828">Arrangement_2::Halfedge_handle</a> e)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>     x1 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1f1bcd74fce34fd532445590bbda5cd5">CGAL::to_double</a> (e-&gt;source()-&gt;point().x());</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>     y1 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1f1bcd74fce34fd532445590bbda5cd5">CGAL::to_double</a> (e-&gt;source()-&gt;point().y());</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>     x2 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1f1bcd74fce34fd532445590bbda5cd5">CGAL::to_double</a> (e-&gt;target()-&gt;point().x());</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>     y2 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1f1bcd74fce34fd532445590bbda5cd5">CGAL::to_double</a> (e-&gt;target()-&gt;point().y());</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>     diff_x = x2 - x1;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>     diff_y = y2 - y1;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">std::sqrt</a>(diff_x*diff_x + diff_y*diff_y);</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> <span class="keyword">get</span>(<span class="keyword">const</span> Edge_length_func&amp; <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__measure__grp.html#gaaffc67e631d83a7da4b1096b782ead94">edge_length</a>, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#adf9ae7012e73ea8f327ab59515b00828">Arrangement_2::Halfedge_handle</a> e)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__measure__grp.html#gaaffc67e631d83a7da4b1096b782ead94">edge_length</a>(e);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Arrangement_2   arr;</div><div class="line"></div><div class="line">  <span class="comment">// Construct an arrangement of seven intersecting line segments.</span></div><div class="line">  <span class="comment">// We keep a handle for the vertex v_0 that corresponds to the point (1,1).</span></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#adf9ae7012e73ea8f327ab59515b00828">Arrangement_2::Halfedge_handle</a>  e =</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a> (arr, Segment_2 (Point_2 (1, 1),</div><div class="line">                                                   Point_2 (7, 1)));</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#a7cdc734c8b7109fe4f62b2467d05b5c3">Arrangement_2::Vertex_handle</a>    v0 = e-&gt;source();</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a> (arr, Segment_2 (Point_2 (1, 1), Point_2 (3, 7)));</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a> (arr, Segment_2 (Point_2 (1, 4), Point_2 (7, 1)));</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a> (arr, Segment_2 (Point_2 (2, 2), Point_2 (9, 3)));</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a> (arr, Segment_2 (Point_2 (2, 2), Point_2 (4, 4)));</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a> (arr, Segment_2 (Point_2 (7, 1), Point_2 (9, 3)));</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a> (arr, Segment_2 (Point_2 (3, 7), Point_2 (9, 3)));</div><div class="line"></div><div class="line">  <span class="comment">// Create a mapping of the arrangement vertices to indices.</span></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__vertex__index__map.html">CGAL::Arr_vertex_index_map&lt;Arrangement_2&gt;</a>        index_map(arr);</div><div class="line"></div><div class="line">  <span class="comment">// Perform Dijkstra's algorithm from the vertex v0.</span></div><div class="line">  Edge_length_func                                      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__measure__grp.html#gaaffc67e631d83a7da4b1096b782ead94">edge_length</a>;</div><div class="line"></div><div class="line">  boost::vector_property_map&lt;double, CGAL::Arr_vertex_index_map&lt;Arrangement_2&gt; &gt; dist_map(static_cast&lt;unsigned int&gt;(arr.number_of_vertices()), index_map);</div><div class="line">  boost::dijkstra_shortest_paths(arr, v0,</div><div class="line">                                 boost::vertex_index_map(index_map).</div><div class="line">                                 weight_map(edge_length).</div><div class="line">                                 distance_map(dist_map));</div><div class="line"></div><div class="line">  <span class="comment">// Print the results:</span></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#a658bc1f09608a7ba83e54309e56aa042">Arrangement_2::Vertex_iterator</a>      vit;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The distances of the arrangement vertices from ("</span></div><div class="line">            &lt;&lt; v0-&gt;point() &lt;&lt; <span class="stringliteral">") :"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (vit = arr.vertices_begin(); vit != arr.vertices_end(); ++vit)</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"("</span> &lt;&lt; vit-&gt;point() &lt;&lt; <span class="stringliteral">") at distance "</span></div><div class="line">              &lt;&lt; dist_map[vit] &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="arr_sssecbgl_dual"></a>
Example for the Dual of an Arrangement as Graph</h2>
<p>It is possible to give a dual graph representation for an arrangement instance, such that each arrangement face corresponds to a graph vertex and two vertices are adjacent iff the corresponding faces share a common edge on their boundaries. This is done by specializing the <code>boost::graph_traits</code> template for <code><a class="el" href="classCGAL_1_1Dual.html" title="The class template Dual is an adaptor that creates the dual view of a FaceGraph. ">Dual</a>&lt;<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&gt;</code> instances, where <code><a class="el" href="classCGAL_1_1Dual.html" title="The class template Dual is an adaptor that creates the dual view of a FaceGraph. ">Dual</a>&lt;<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&gt;</code> is a template specialization that gives a dual interpretation to an arrangement instance.</p>
<p>In dual representation, <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#afba61ea413272c8af10dcc4bdeb5ff63">Arrangement_2::Face_handle</a></code> is the graph-vertex type, while <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#adf9ae7012e73ea8f327ab59515b00828">Arrangement_2::Halfedge_handle</a></code> is the graph-edge type. We treat the graph edges as directed, such that a halfedge <code>e</code> is directed from \( f_1\), which is its incident face, to \( f_2\), which is the incident face of its twin halfedge. As two arrangement faces may share more than a single edge on their boundary, we allow parallel edges in our <em>boost</em> graph. As is the case in the primal graph, the dual arrangement graph is also a model of the concepts <code><a class="el" href="classVertexListGraph.html" title="Concept from the Boost Graph Library. See https://www.boost.org/libs/graph/doc/VertexListGraph.html. ">VertexListGraph</a></code>, <code><a class="el" href="classEdgeListGraph.html" title="Concept from the Boost Graph Library. See https://www.boost.org/libs/graph/doc/EdgeListGraph.html. ">EdgeListGraph</a></code> and <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classBidirectionalGraph.html">BidirectionalGraph</a></code> (thus also of <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classIncidenceGraph.html">IncidenceGraph</a></code>).</p>
<p>Since we use <code>Face_handle</code> objects as the vertex descriptors, we define the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__face__index__map.html">Arr_face_index_map</a>&lt;Arrangement&gt;</code> class-template, which maintains an efficient mapping of face handles to indices. We also provide the template <code>Arr_face_property_map&lt;Arrangement,Type&gt;</code> for associating arbitrary data with the arrangement faces.</p>
<p>In the following example we construct the same arrangement as in example <code>ex_bgl_primal_adapter.cpp</code> (see <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/index.html#fig__aos_fig-bgl_primal_adapter">Figure 34.48</a>), and perform breadth-first search on the graph faces, starting from the unbounded face. We extend the DCEL faces with an unsigned integer, marking the discover time of the face and use a breadth-first-search visitor to obtain these times and update the faces accordingly:</p>
<p><br />
<b>File</b> <a class="el" href="BGL_arrangement_2_2arrangement_dual_8cpp-example.html">BGL_arrangement_2/arrangement_dual.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Adapting the dual of an arrangement to a BGL graph.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_rational_nt.h"</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_segment_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_extended_dcel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/graph_traits_dual_arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_face_index_map.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;climits&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/breadth_first_search.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/graph/visitors.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_print.h"</span></div><div class="line"></div><div class="line"><span class="comment">// A property map that reads/writes the information to/from the extended</span></div><div class="line"><span class="comment">// face.</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Arrangement, <span class="keyword">class</span> Type&gt;</div><div class="line"><span class="keyword">class </span>Extended_face_property_map {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Arrangement::Face_handle       Face_handle;</div><div class="line"></div><div class="line">  <span class="comment">// Boost property type definitions.</span></div><div class="line">  <span class="keyword">typedef</span> boost::read_write_property_map_tag      category;</div><div class="line">  <span class="keyword">typedef</span> Type                                    value_type;</div><div class="line">  <span class="keyword">typedef</span> value_type&amp;                             reference;</div><div class="line">  <span class="keyword">typedef</span> Face_handle                             key_type;</div><div class="line"></div><div class="line">  <span class="comment">// The get function is required by the property map concept.</span></div><div class="line">  <span class="keyword">friend</span> reference <span class="keyword">get</span>(<span class="keyword">const</span> Extended_face_property_map&amp;, key_type key)</div><div class="line">  { <span class="keywordflow">return</span> key-&gt;data(); }</div><div class="line"></div><div class="line">  <span class="comment">// The put function is required by the property map concept.</span></div><div class="line">  <span class="keyword">friend</span> <span class="keywordtype">void</span> put(<span class="keyword">const</span> Extended_face_property_map&amp;, key_type key, value_type val)</div><div class="line">  { key-&gt;set_data(val); }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;Number_type&gt;</a>                         Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__segment__traits__2.html">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</a>                   Traits_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__face__extended__dcel.html">CGAL::Arr_face_extended_dcel&lt;Traits_2, unsigned int&gt;</a> Dcel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2, Dcel&gt;</a>                  Ex_arrangement;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Dual.html">CGAL::Dual&lt;Ex_arrangement&gt;</a>                           Dual_arrangement;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__face__index__map.html">CGAL::Arr_face_index_map&lt;Ex_arrangement&gt;</a>             Face_index_map;</div><div class="line"><span class="keyword">typedef</span> Extended_face_property_map&lt;Ex_arrangement,unsigned int&gt;</div><div class="line">                                                             Face_property_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>                                      Point_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Segment__2.html">Kernel::Segment_2</a>                                    Segment_2;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="comment">// Construct an arrangement of seven intersecting line segments.</span></div><div class="line">  Point_2 p1(1, 1), p2(1, 4), p3(2, 2), p4(3, 7), p5(4, 4), p6(7, 1), p7(9, 3);</div><div class="line">  Ex_arrangement  arr;</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a>(arr, Segment_2(p1, p6));</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a>(arr, Segment_2(p1, p4));  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a>(arr, Segment_2(p2, p6));</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a>(arr, Segment_2(p3, p7));  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a>(arr, Segment_2(p3, p5));</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a>(arr, Segment_2(p6, p7));  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a>(arr, Segment_2(p4, p7));</div><div class="line"></div><div class="line">  <span class="comment">// Create a mapping of the arrangement faces to indices.</span></div><div class="line">  Face_index_map  index_map(arr);</div><div class="line"></div><div class="line">  <span class="comment">// Perform breadth-first search from the unbounded face, using the event</span></div><div class="line">  <span class="comment">// visitor to associate each arrangement face with its discover time.</span></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    time = 0;</div><div class="line">  boost::breadth_first_search(Dual_arrangement(arr), arr.unbounded_face(),</div><div class="line">                              boost::vertex_index_map(index_map).visitor</div><div class="line">                              (boost::make_bfs_visitor</div><div class="line">                               (stamp_times(Face_property_map(), time,</div><div class="line">                                            boost::on_discover_vertex()))));</div><div class="line"></div><div class="line">  <span class="comment">// Print the discover time of each arrangement face.</span></div><div class="line">  Ex_arrangement::Face_iterator  fit;</div><div class="line">  <span class="keywordflow">for</span> (fit = arr.faces_begin(); fit != arr.faces_end(); ++fit) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Discover time "</span> &lt;&lt; fit-&gt;data() &lt;&lt; <span class="stringliteral">" for "</span>;</div><div class="line">    <span class="keywordflow">if</span> (fit != arr.unbounded_face()) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">"face "</span>;</div><div class="line">      print_ccb&lt;Ex_arrangement&gt;(fit-&gt;outer_ccb());</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> std::cout &lt;&lt; <span class="stringliteral">"the unbounded face."</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="BGLExtensions"></a>
Extensions of the BGL</h1>
<p>The previous sections introduced partial specializations and free functions so that several CGAL data structures are adapted as models of some of the BGL graph concepts. In this section, we introduce new concepts, iterators, and property maps inspired by the functionalities of the BGL.</p>
<h2><a class="anchor" id="BGLExtensionsGraphConcepts"></a>
Graph concepts</h2>
<p>In order to match <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgHalfedgeDS">Halfedge Data Structures</a> more closely and to enable writing generic algorithms which operate on data structures that have faces and halfedges, we define a set of new concepts to extend the <a href="https://www.boost.org/libs/graph/doc/graph_concepts.html">graph concepts of the BGL</a>:</p>
<ul>
<li><code><a class="el" href="classHalfedgeGraph.html" title="The concept HalfedgeGraph is a refinement of the BGL concept IncidenceGraph and adds the notion of a ...">HalfedgeGraph</a></code> refines <a href="https://www.boost.org/libs/graph/doc/Graph.html"><code>Graph</code></a> with operations to accommodate halfedge data structures: given a halfedge, say <code>h</code>, the concept <code><a class="el" href="classHalfedgeGraph.html" title="The concept HalfedgeGraph is a refinement of the BGL concept IncidenceGraph and adds the notion of a ...">HalfedgeGraph</a></code> requires the provision of the halfedge opposite to <code>h</code>, the halfedge that succeeds <code>h</code>, and the halfedge that precedes <code>h</code>.</li>
<li><code><a class="el" href="classHalfedgeListGraph.html" title="The concept HalfedgeListGraph refines the concept HalfedgeGraph and adds the requirements for travers...">HalfedgeListGraph</a></code> adds the requirement for efficient traversal of the halfedges of the graph.</li>
<li><code><a class="el" href="classMutableHalfedgeGraph.html" title="The concept MutableHalfedgeGraph refines the concept HalfedgeGraph and adds the requirements for oper...">MutableHalfedgeGraph</a></code> adds the requirement for operations to change next/previous relations and to adjust the target of a halfedge.</li>
<li><code><a class="el" href="classFaceGraph.html" title="The concept FaceGraph refines the concept HalfedgeGraph. It adds the requirements for a graph to expl...">FaceGraph</a></code> adds the requirements to explicitly handle faces in a graph, to provide quick access to the incident halfedges of a face, and to enable access from every halfedge to an adjacent face.</li>
<li><code><a class="el" href="classFaceListGraph.html" title="The concept FaceListGraph refines the concept FaceGraph and adds the requirement for traversal of all...">FaceListGraph</a></code> adds the requirement for efficient traversal of the faces of a graph.</li>
<li><code><a class="el" href="classMutableFaceGraph.html" title="The concept MutableFaceGraph refines the concepts FaceGraph and MutableHalfedgeGraph and adds the req...">MutableFaceGraph</a></code> adds requirements to change adjacency of faces and halfedges, and to remove and add faces.</li>
</ul>
<p>A summary of the expressions and types associated with each of these concepts as well as a refinement relation graph can be found in the <a class="el" href="group__PkgBGLConcepts.html">Concepts</a> documentation page.</p>
<h2><a class="anchor" id="BGLIteratorsAndCirculators"></a>
Iterators and Circulators</h2>
<p>By combining basic operations on graphs, we create various useful <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/devman_iterators_and_circulators.html">iterators and circulators</a> to traverse specific types of elements. For example:</p>
<ul>
<li>Starting at a halfedge <code>h</code> of a halfedge graph <code>g</code>, applying several times <code>next(h,g)</code> brings us back to the halfedge where we started. All halfedges traversed on the way are incident to the same face.</li>
<li>Using the composition of the functions <code>next(h,g)</code> and <code>opposite(h,g)</code> results in another cycle, namely the cycle of halfedges which are incident to the same vertex.</li>
</ul>
<p>A complete list of these traversal tools can be found in <a class="el" href="group__PkgBGLIterators.html">the reference manual</a>.</p>
<p>For convenience, two iterator and circulator types enable the traversal of all halfedges incident to a given face, and all halfedges having a given vertex as target. These types are not part of the concept <code><a class="el" href="classHalfedgeGraph.html" title="The concept HalfedgeGraph is a refinement of the BGL concept IncidenceGraph and adds the notion of a ...">HalfedgeGraph</a></code>, but they are class templates that work for any model of this concept.</p>
<h3><a class="anchor" id="BGLExampleIncidentVertices"></a>
Example: Finding Incident Vertices in a HalfedgeGraph</h3>
<p>The following example shows several functions to navigate in a <code><a class="el" href="classHalfedgeGraph.html" title="The concept HalfedgeGraph is a refinement of the BGL concept IncidenceGraph and adds the notion of a ...">HalfedgeGraph</a></code>. We have two implementations of the operation that finds the vertices adjacent to a vertex <code>v</code>.</p>
<p>Let us have a look at the first version. Given a vertex descriptor <code>vd</code>, we first call <code>halfedge(vd,g)</code> to obtain the halfedge with <code>vd</code> as target. Applying <code><a class="el" href="classEdgeListGraph.html#a8623c30b1f1b0fda831343463aaca433">source()</a></code> then gives us an adjacent vertex. We then get to the next halfedge with <code>vd</code> as target, by first going to the next halfedge around the face, and then going to the opposite halfedge.</p>
<p>The second version does the <code>next()</code> and <code>opposite()</code> jumping with an iterator. Note that when calling <code><a class="el" href="classEdgeListGraph.html#a8623c30b1f1b0fda831343463aaca433">source()</a></code> we have to dereference <code>hi</code>, as the function expects a halfedge descriptor and not a halfedge iterator. Also observe that <code><a class="el" href="group__PkgBGLIterators.html#ga2be4fd4d24b1e48e00a92f90f0f2923c" title="returns an iterator range over all halfedges with vertex target(h,g) as target. ">halfedges_around_target()</a></code> expects a halfedge, and not a vertex. This provides the user with the ability to start the traversal at a specific halfedge incident to the input vertex (and not the arbitrary incident halfedge stored in the vertex record.)</p>
<p><br />
<b>File</b> <a class="el" href="BGL_polyhedron_3_2incident_vertices_8cpp-example.html">BGL_polyhedron_3/incident_vertices.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/iterator.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;Kernel&gt;</a>     Polyhedron;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt; GraphTraits;</div><div class="line"><span class="keyword">typedef</span> GraphTraits::vertex_descriptor vertex_descriptor;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Halfedge__around__target__iterator.html">CGAL::Halfedge_around_target_iterator&lt;Polyhedron&gt;</a> halfedge_around_target_iterator;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> OutputIterator&gt;</div><div class="line"><a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classOutputIterator.html">OutputIterator</a></div><div class="line">adjacent_vertices_V1(<span class="keyword">const</span> Polyhedron&amp; g,</div><div class="line">                     vertex_descriptor vd,</div><div class="line">                     <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classOutputIterator.html">OutputIterator</a> out)</div><div class="line">{</div><div class="line">  <span class="keyword">typename</span> GraphTraits::halfedge_descriptor hb = halfedge(vd,g), done(hb);</div><div class="line">  <span class="keywordflow">do</span> {</div><div class="line">        *out++ = source(hb,g);</div><div class="line">        hb = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gad0a8110cb95f76bac65649bfe58c650b">opposite</a>(next(hb,g),g);</div><div class="line">  } <span class="keywordflow">while</span>(hb!= done);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> out;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> OutputIterator&gt;</div><div class="line"><a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classOutputIterator.html">OutputIterator</a></div><div class="line">adjacent_vertices_V2(<span class="keyword">const</span> Polyhedron&amp; g,</div><div class="line">                     vertex_descriptor vd,</div><div class="line">                     <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classOutputIterator.html">OutputIterator</a> out)</div><div class="line">{</div><div class="line">  halfedge_around_target_iterator hi, he;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(boost::tie(hi, he) = <a class="code" href="group__PkgBGLIterators.html#ga2be4fd4d24b1e48e00a92f90f0f2923c">halfedges_around_target</a>(halfedge(vd,g),g); hi != he; ++hi)</div><div class="line">  {</div><div class="line">    *out++ = source(*hi,g);</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> out;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::ifstream in((argc&gt;1)?argv[1]:<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/cube_poly.off"</span>));</div><div class="line">  Polyhedron P;</div><div class="line">  in &gt;&gt; P;</div><div class="line">  GraphTraits::vertex_iterator vi = vertices(P).first;</div><div class="line">  std::list&lt;vertex_descriptor&gt; V;</div><div class="line">  adjacent_vertices_V1(P, *vi, std::back_inserter(V));</div><div class="line">  ++vi;</div><div class="line">  adjacent_vertices_V2(P, *vi, std::back_inserter(V));</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"done\n"</span>;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="BGLExampleNormalHalfedgeGraph"></a>
Example: Calculating Facet Normals using HalfedgeGraph</h3>
<p>The following example program shows a simple algorithm for calculating facet normals for a polyhedron using the BGL API. A <a href="https://www.boost.org/libs/property_map/doc/vector_property_map.html">boost::vector_property_map</a> is used to to store the calculated normals instead of changing the Polyhedron items class.</p>
<p><br />
<b>File</b> <a class="el" href="BGL_polyhedron_3_2normals_8cpp-example.html">BGL_polyhedron_3/normals.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/graph/graph_traits.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_items_with_id_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>                               Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                                              Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a>                                             Vector;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;Kernel, CGAL::Polyhedron_items_with_id_3&gt;</a> Polyhedron;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <a class="code" href="classHalfedgeGraph.html">HalfedgeGraph</a>,</div><div class="line">         <span class="keyword">typename</span> PointMap,</div><div class="line">         <span class="keyword">typename</span> NormalMap&gt;</div><div class="line"><span class="keywordtype">void</span> calculate_face_normals(<span class="keyword">const</span> <a class="code" href="classHalfedgeGraph.html">HalfedgeGraph</a>&amp; g,</div><div class="line">                            PointMap pm,</div><div class="line">                            NormalMap nm)</div><div class="line">{</div><div class="line">  <span class="keyword">typedef</span> boost::graph_traits&lt;HalfedgeGraph&gt; GraphTraits;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> GraphTraits::face_iterator face_iterator;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> GraphTraits::halfedge_descriptor halfedge_descriptor;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::property_traits&lt;PointMap&gt;::value_type point;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::property_traits&lt;NormalMap&gt;::value_type <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__normal__grp.html#ga49a712e57564602ad468a3888784e971">normal</a>;</div><div class="line"></div><div class="line">  face_iterator fb, fe;</div><div class="line">  <span class="keywordflow">for</span>(boost::tie(fb, fe) = faces(g); fb != fe; ++fb)</div><div class="line">  {</div><div class="line">    halfedge_descriptor edg = halfedge(*fb, g);</div><div class="line">    halfedge_descriptor edgb = edg;</div><div class="line"></div><div class="line">    point p0 = pm[target(edg, g)];</div><div class="line">    edg = next(edg, g);</div><div class="line">    point p1 = pm[target(edg, g)];</div><div class="line">    edg = next(edg, g);</div><div class="line">    point p2 = pm[target(edg, g)];</div><div class="line">    edg = next(edg, g);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(edg == edgb) {</div><div class="line">      <span class="comment">// triangle</span></div><div class="line">      nm[*fb] = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__unit__normal__grp.html#gaeb8231145ba0cdde8e28fc4f983f23ef">CGAL::unit_normal</a>(p1, p2, p0);</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">      <span class="comment">// not a triangle</span></div><div class="line">      normal n(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga4a98ec6bd9dfd8fe8c46fea553b5d238">CGAL::NULL_VECTOR</a>);</div><div class="line"></div><div class="line">      <span class="keywordflow">do</span> {</div><div class="line">        n = n + <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__normal__grp.html#ga49a712e57564602ad468a3888784e971">CGAL::normal</a>(p1, p2, p0);</div><div class="line">        p0 = p1;</div><div class="line">        p1 = p2;</div><div class="line"></div><div class="line">        edg = next(edg, g);</div><div class="line">        p2 = pm[target(edg, g)];</div><div class="line">      } <span class="keywordflow">while</span>(edg != edgb);</div><div class="line"></div><div class="line">      nm[*fb] = n / <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">CGAL::sqrt</a>(n.squared_length());</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">typedef</span> boost::property_map&lt;</div><div class="line">    Polyhedron,</div><div class="line">    <a class="code" href="group__PkgBGLProperties.html#ga4d8b2f143dbc2547a5a307f76a48f8e0">CGAL::face_index_t</a></div><div class="line">    &gt;::const_type Face_index_map;</div><div class="line"></div><div class="line">  std::ifstream in((argc&gt;1)?argv[1]:<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/cube_poly.off"</span>));</div><div class="line">  Polyhedron P;</div><div class="line">  in &gt;&gt; P ;</div><div class="line"></div><div class="line">  <span class="comment">// initialize facet indices</span></div><div class="line">  std::size_t i = 0;</div><div class="line">  <span class="keywordflow">for</span>(Polyhedron::Facet_iterator it = P.facets_begin(); it != P.facets_end(); ++it, ++i)</div><div class="line">  {</div><div class="line">    it-&gt;id() = i;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Ad hoc property_map to store normals. Face_index_map is used to</span></div><div class="line">  <span class="comment">// map face_descriptors to a contiguous range of indices. See</span></div><div class="line">  <span class="comment">// http://www.boost.org/libs/property_map/doc/vector_property_map.html</span></div><div class="line">  <span class="comment">// for details.</span></div><div class="line">  boost::vector_property_map&lt;Vector, Face_index_map&gt;</div><div class="line">    normals(static_cast&lt;unsigned&gt;(num_faces(P)), <span class="keyword">get</span>(CGAL::face_index, P));</div><div class="line"></div><div class="line">  calculate_face_normals(</div><div class="line">    P <span class="comment">// Graph</span></div><div class="line">    , <span class="keyword">get</span>(CGAL::vertex_point, P) <span class="comment">// map from vertex_descriptor to point</span></div><div class="line">    , normals <span class="comment">// map from face_descriptor to Vector_3</span></div><div class="line">    );</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Normals"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span>(Polyhedron::Facet_iterator it = P.facets_begin(); it != P.facets_end(); ++it) {</div><div class="line">    <span class="comment">// Facet_iterator is a face_descriptor, so we can use it as the</span></div><div class="line">    <span class="comment">// key here</span></div><div class="line">    std::cout &lt;&lt; normals[it] &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="BGLProperties"></a>
Properties and Dynamic Properties</h2>
<p>As the concepts <code><a class="el" href="classHalfedgeGraph.html" title="The concept HalfedgeGraph is a refinement of the BGL concept IncidenceGraph and adds the notion of a ...">HalfedgeGraph</a></code> and <code><a class="el" href="classFaceGraph.html" title="The concept FaceGraph refines the concept HalfedgeGraph. It adds the requirements for a graph to expl...">FaceGraph</a></code> add the notion of halfedges and faces, as well as a geometric embedding of the vertices, we have to add property tags such as <code>face_index_t</code> and <code>vertex_point_t</code>.</p>
<p>We further add <em>dynamic properties</em> that enable the user to add properties to vertices, halfedges, edges, and faces on the fly. The lifetime of a dynamic property is bound to the lifetime of the property map: reference counting is used to delete the property when no map refers to it.</p>
<p>Dynamic property tags, such as <code><a class="el" href="structCGAL_1_1dynamic__vertex__property__t.html" title="Dynamic vertex property tag. ">dynamic_vertex_property_t</a></code>, are a generalization of <code>boost::vertex_index_t</code>, as they have a template parameter for the value type of the dynamic property map, and a default value. <code>boost::property_map&lt;G,T&gt;::type</code> is used to obtain the type of the dynamic property map for a graph of type <code>G</code>, for a dynamic property tag <code>T</code>. This type must be default constructible and assignable. As for ordinary properties, the function <code>get()</code> is overloaded and serves for retrieving a property map for a given graph and dynamic property tag, as well as for retrieving a value for a given key and property map.</p>
<p>The following example shows how to attach a <code>string</code> property to vertices and a <code>double</code> value to the halfedges of a graph.</p>
<p><br />
<b>File</b> <a class="el" href="Property_map_2dynamic_properties_8cpp-example.html">Property_map/dynamic_properties.cpp</a> </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> K;</div><div class="line"><span class="keyword">typedef</span> K::Point_3 Point_3;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point_3&gt;</a> Mesh;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Mesh mesh;</div><div class="line">  <a class="code" href="group__PkgBGLHelperFct.html#ga81ac0b6fbedf7889e0164aec540bd112">CGAL::make_triangle</a>(Point_3(0,0,0),Point_3(1,0,0),Point_3(1,1,0), mesh);</div><div class="line"></div><div class="line">  <span class="keyword">typedef</span> boost::property_map&lt;Mesh, CGAL::dynamic_vertex_property_t&lt;std::string&gt; &gt;::type VertexNameMap;</div><div class="line">  VertexNameMap vnm  = <span class="keyword">get</span>(<a class="code" href="structCGAL_1_1dynamic__vertex__property__t.html">CGAL::dynamic_vertex_property_t&lt;std::string&gt;</a>(), mesh);</div><div class="line">  put(vnm, *(vertices(mesh).first), <span class="stringliteral">"Paris"</span>);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="keyword">get</span>(vnm, *(vertices(mesh).first)) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keyword">typedef</span> boost::property_map&lt;Mesh, CGAL::dynamic_halfedge_property_t&lt;double&gt; &gt;::type TrafficDensityMap;</div><div class="line">  TrafficDensityMap tdm = <span class="keyword">get</span>(<a class="code" href="structCGAL_1_1dynamic__halfedge__property__t.html">CGAL::dynamic_halfedge_property_t&lt;double&gt;</a>(), mesh);</div><div class="line">  put(tdm, *(halfedges(mesh).first), 0.7);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="keyword">get</span>(tdm, *(halfedges(mesh).first)) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h2><a class="anchor" id="BGLGraphIO"></a>
Graph I/O</h2>
<p>Using a common graph concept enables having common input/output functions for all the models of this concept. The following file formats are supported for models of <code><a class="el" href="classFaceGraph.html" title="The concept FaceGraph refines the concept HalfedgeGraph. It adds the requirements for a graph to expl...">FaceGraph</a></code>:</p><ul>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/IOStreamSupportedFileFormats.html#IOStreamOFF">Object File Format (OFF)</a> (<code>.off</code>)</li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/IOStreamSupportedFileFormats.html#IOStreamOBJ">Wavefront Advanced Visualizer Object Format (OBJ)</a> (<code>.obj</code>)</li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/IOStreamSupportedFileFormats.html#IOStreamSTL">STereoLithography (STL) File Format</a> (<code>.stl</code>)</li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/IOStreamSupportedFileFormats.html#IOStreamPLY">Polygon File Format (PLY)</a> (<code>.ply</code>)</li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/IOStreamSupportedFileFormats.html#IOStreamGocad">GOCAD (TS) File Format</a> (<code>.ts</code>)</li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/IOStreamSupportedFileFormats.html#IOStreamVTK">VTK (VTU / VTP) File Formats</a> (<code>.vtp</code>)</li>
</ul>
<p>See the page <a class="el" href="group__PkgBGLIOFct.html">I/O Functions</a> for an exhaustive description of the I/O functions of this package.</p>
<h1><a class="anchor" id="BGLEulerOperations"></a>
Euler Operations</h1>
<p>There are two categories of mutating operations. The first category comprises low level operations that change incidences such as the target vertex of a halfedge. A halfedge graph might turn invalid by the application of inconsistent low lever operations. The second category of operations are called <em>Euler Operations</em>. These are high level operations such as adding a center vertex to a face, which means also adding halfedges and faces, and updating incidence information. The Euler operations enable manipulating models of <code><a class="el" href="classMutableFaceGraph.html" title="The concept MutableFaceGraph refines the concepts FaceGraph and MutableHalfedgeGraph and adds the req...">MutableFaceGraph</a></code>.</p>
<p>The complete list of Euler operations provided by this package can be found in <a class="el" href="group__PkgBGLEulerOperations.html">the reference manual</a>.</p>
<h1><a class="anchor" id="BGLGraphAdaptors"></a>
Graph Adaptors</h1>
<p>Graph adaptors are classes that build an interface over an existing graph to provide new functionalities. By operating almost entirely on the input graph, adaptors can avoid potentially expensive operations, both in term of time and memory.</p>
<h2><a class="anchor" id="BGLDual"></a>
The Dual Graph</h2>
<p>The <em>dual graph</em> of a <code><a class="el" href="classFaceGraph.html" title="The concept FaceGraph refines the concept HalfedgeGraph. It adds the requirements for a graph to expl...">FaceGraph</a></code> <code>G</code> is a graph that has a vertex for each face of <code>G</code>. The dual graph has an edge whenever two faces of <code>G</code> are separated from each other by an edge. Thus, each edge <code>e</code> of <code>G</code> has a corresponding dual edge, the edge that connects the two faces on either side of <code>e</code>. Computing the dual graph of a graph has many uses, for example when one wishes to compute the connected components of a mesh.</p>
<p>The class template <code><a class="el" href="classCGAL_1_1Dual.html" title="The class template Dual is an adaptor that creates the dual view of a FaceGraph. ">Dual</a></code> is an adaptor that creates the dual view of a <code><a class="el" href="classFaceGraph.html" title="The concept FaceGraph refines the concept HalfedgeGraph. It adds the requirements for a graph to expl...">FaceGraph</a></code>. Faces of the original graph correspond to vertices in the <code><a class="el" href="classCGAL_1_1Dual.html" title="The class template Dual is an adaptor that creates the dual view of a FaceGraph. ">Dual</a></code> and vice versa.</p>
<p>Note that border edges in a <code><a class="el" href="classCGAL_1_1Dual.html" title="The class template Dual is an adaptor that creates the dual view of a FaceGraph. ">Dual</a></code> have the <code>null_face</code> of the original graph as either source or target. This is unusual and might break other algorithms since edges are always assumed to have non-null vertices as a source and target. It is nevertheless possible to filter border edges using <a href="https://www.boost.org/libs/graph/doc/filtered_graph.html">boost::filtered_graph</a>, as shown in the following example.</p>
<p><br />
<b>File</b> <a class="el" href="BGL_surface_mesh_2surface_mesh_dual_8cpp-example.html">BGL_surface_mesh/surface_mesh_dual.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/Dual.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/helpers.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/graph/filtered_graph.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/graph/connected_components.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>             Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                            Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point&gt;</a>                  Mesh;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Dual.html">CGAL::Dual&lt;Mesh&gt;</a>                           Dual;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Dual&gt;::edge_descriptor edge_descriptor;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> G&gt;</div><div class="line"><span class="keyword">struct </span>noborder {</div><div class="line">  noborder() : g(nullptr) {} <span class="comment">// default-constructor required by filtered_graph</span></div><div class="line">  noborder(G&amp; g) : g(&amp;g) {}</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> edge_descriptor&amp; e)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{ <span class="keywordflow">return</span> !<a class="code" href="group__PkgBGLHelperFct.html#gad93e429ad24efeaddeb836c437e719ab">is_border</a>(e,*g); }</div><div class="line"></div><div class="line">  G* g;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// A dual border edge has a null_face as the source or target "vertex"</span></div><div class="line"><span class="comment">// BGL algorithms won't like that, so we remove border edges through a</span></div><div class="line"><span class="comment">// boost::filtered_graph.</span></div><div class="line"><span class="keyword">typedef</span> boost::filtered_graph&lt;Dual, noborder&lt;Mesh&gt; &gt;   FiniteDual;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::vertex_descriptor   vertex_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::face_descriptor     face_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::edge_descriptor     edge_descriptor;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/prim.off"</span>);</div><div class="line"></div><div class="line">  Mesh primal;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__IO__grp.html#gac5b3295bd1b6375628a46d1fbaf7e881">CGAL::IO::read_polygon_mesh</a>(filename, primal))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line">  Dual dual(primal);</div><div class="line">  FiniteDual finite_dual(dual,noborder&lt;Mesh&gt;(primal));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"dual has "</span> &lt;&lt; num_vertices(dual) &lt;&lt; <span class="stringliteral">" vertices"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The vertices of dual are faces in primal"</span>&lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span>(boost::graph_traits&lt;Dual&gt;::vertex_descriptor dvd : vertices(dual)) {</div><div class="line">    std::cout &lt;&lt; dvd &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The edges in primal and dual with source and target"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span>(edge_descriptor e : edges(dual)) {</div><div class="line">   std::cout &lt;&lt; e &lt;&lt; <span class="stringliteral">" in primal:  "</span> &lt;&lt; source(e,primal)      &lt;&lt; <span class="stringliteral">" -- "</span> &lt;&lt; target(e,primal)       &lt;&lt; <span class="stringliteral">"   "</span></div><div class="line">             &lt;&lt;      <span class="stringliteral">" in dual  :  "</span> &lt;&lt; source(e,finite_dual) &lt;&lt; <span class="stringliteral">" -- "</span> &lt;&lt; target(e,finite_dual)  &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"> std::cout &lt;&lt; <span class="stringliteral">"edges of the finite dual graph"</span> &lt;&lt; std::endl;</div><div class="line"> <span class="keywordflow">for</span>(boost::graph_traits&lt;FiniteDual&gt;::edge_descriptor e : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL.html#a266177f3e138c748f9906f7abb76320b">CGAL::make_range</a>(edges(finite_dual))) {</div><div class="line">   std::cout &lt;&lt; e &lt;&lt; <span class="stringliteral">"  "</span> &lt;&lt; source(e,primal) &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; source(e,finite_dual)  &lt;&lt; std::endl;</div><div class="line"> }</div><div class="line"></div><div class="line"> <span class="comment">// the storage of a property map is in primal</span></div><div class="line"> Mesh::Property_map&lt;face_descriptor,int&gt; fccmap;</div><div class="line"> fccmap = primal.add_property_map&lt;face_descriptor,<span class="keywordtype">int</span>&gt;(<span class="stringliteral">"f:CC"</span>).first;</div><div class="line"> <span class="keywordtype">int</span> num = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__keep__connected__components__grp.html#ga4b265482ec76e147764f0ca64a90b55d">connected_components</a>(finite_dual, fccmap);</div><div class="line"></div><div class="line"> std::cout &lt;&lt; <span class="stringliteral">"The graph has "</span> &lt;&lt; num &lt;&lt; <span class="stringliteral">" connected components (face connectivity)"</span> &lt;&lt; std::endl;</div><div class="line"> <span class="keywordflow">for</span>(face_descriptor f : faces(primal)) {</div><div class="line">   std::cout &lt;&lt; f &lt;&lt; <span class="stringliteral">" in connected component "</span> &lt;&lt; fccmap[f] &lt;&lt; std::endl;</div><div class="line"> }</div><div class="line"></div><div class="line"> Mesh::Property_map&lt;vertex_descriptor,int&gt; vccmap;</div><div class="line"> vccmap = primal.add_property_map&lt;vertex_descriptor,<span class="keywordtype">int</span>&gt;(<span class="stringliteral">"v:CC"</span>).first;</div><div class="line"> num = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__keep__connected__components__grp.html#ga4b265482ec76e147764f0ca64a90b55d">connected_components</a>(primal, vccmap);</div><div class="line"></div><div class="line"> std::cout &lt;&lt; <span class="stringliteral">"The graph has "</span> &lt;&lt; num &lt;&lt; <span class="stringliteral">" connected components (edge connectvity)"</span> &lt;&lt; std::endl;</div><div class="line"> <span class="keywordflow">for</span>(vertex_descriptor v : vertices(primal)) {</div><div class="line">   std::cout &lt;&lt; v &lt;&lt; <span class="stringliteral">" in connected component "</span> &lt;&lt; vccmap[v] &lt;&lt; std::endl;</div><div class="line"> }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="BGLSeamMesh"></a>
The Seam Mesh</h2>
<p>The class <code><a class="el" href="classCGAL_1_1Seam__mesh.html" title="This class is a data structure that takes a triangle mesh, further refered to as underlying mesh and ...">Seam_mesh</a></code> allows to mark edges of a mesh as <em>seam edges</em> so that they <em>virtually</em> become border edges when exploring a seam mesh with the BGL API. The input mesh is referred to as <em>underlying</em> mesh of the seam mesh. We denote <code>tm</code> and <code>sm</code> the underlying mesh and the seam mesh respectively.</p>
<p>Figure <a class="el" href="index.html#fig__fig_Seam_mesh_1">Figure 102.2</a> shows an example of mesh on which two edges, defined by the halfedge pairs <code>h2-h3</code> and <code>h6-h7</code>, are marked as seams. The introduction of virtual borders modifies the elementary BGL graph traversal operations: when we circulate around the target of <code>h7</code> in the underlying mesh, we traverse <code>h7</code>, <code>h1</code>, <code>h3</code>, <code>h5</code>, before arriving at <code>h7</code> again. However, when we circulate in the seam mesh, we traverse <code>h7</code>, <code>h1</code>, <code>h3*</code>, before arriving at <code>h7</code> again. Similarly, if we start at <code>h3</code>, we traverse <code>h3</code>, <code>h5</code>, <code>h7*</code>, and <code>h3</code> again.</p>
<p><a class="anchor" id="fig__fig_Seam_mesh_1"></a></p><div class="image">
<object type="image/svg+xml" data="seam_mesh_1.svg">seam_mesh_1.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__fig_Seam_mesh_1">Figure 102.2</a> A seam mesh with two seam edges <code>(h2, h3)</code> and <code>(h6, h7)</code>.  </div> <br /> 
<p>A vertex of the underlying mesh may correspond to multiple vertices in the seam mesh. For example in Figure <a class="el" href="index.html#fig__fig_Seam_mesh_1">Figure 102.2</a>, the target of <code>h7</code> corresponds to two vertices in the seam mesh, on either side of the virtual border created by the seam edges. For this reason, a vertex <code>v</code> of the seam mesh is internally represented as a halfedge <code>h</code> of the seam mesh. To obtain a canonical definition, the halfedge <code>h</code> is defined as the halfedge that has <code>v</code> as target, that lies on the seam, and that is not a border halfedge. The function <code>target(hd, sm)</code> will return this halfedge. For vertices <code>v</code> in the underlying mesh that are not on a seam edge, we choose <code>halfedge(v, tm)</code> as its canonical halfedge.</p>
<h3><a class="anchor" id="BGLSeamMeshTraversal"></a>
Seam Mesh Traversal</h3>
<p>Using the function <code>next(halfedge_descriptor, FaceGraph)</code>, we can walk around a face but also around a border of a mesh. For the seam mesh <code>sm</code> from Figure <a class="el" href="index.html#fig__fig_Seam_mesh_1">Figure 102.2</a>, we have <code>opposite(h2, sm) == h3*</code>, and it holds that <code>face(h3*, sm) == null_face()</code>. We can walk along this virtual border: starting at <code>h3*</code> and repeatedly calling <code>next(..,sm)</code>, we will traverse <code>h6*</code>, <code>h7*</code>, <code>h2*</code>, before reaching <code>h3*</code> again.</p>
<p>All other traversal functions, iterators, and circulators (see <a class="el" href="group__PkgBGLIterators.html">Iterators and Circulators</a>) can be used on a seam mesh, but their behavior is similarly modified by the (virtual and real) border edges of the seam mesh.</p>
<h3><a class="anchor" id="BGLSeamMeshNature"></a>
Seams</h3>
<p>A collection of seam edges, or simply a <em>seam</em>, is not necessarily a simple polyline as we can see in the next figure: </p><ul>
<li>
In <em>(a)</em>, the seam forms a tree. Consequently, we pass at a vertex as often as there are incident seam edges. </li>
<li>
In <em>(b)</em>, the seam has a vertex <code>v</code> on the border of the underlying mesh. While walking along the border of the seam mesh, we leave the border of the underlying mesh when we reach <code>v</code> and walk on a virtual border until we reach <code>v</code> again, from the other side of the seam. </li>
<li>
In <em>(c)</em>, the seam forms a closed polyline. While the first two define a single border, a cycle defines two borders and splits the set of faces in two connected components. Something similar happens when the seam touches the same border more than once. A seam can also connect different borders, potentially changing the genus of the mesh. Finally, a seam may have more than one connected component. </li>
</ul>
<p><a class="anchor" id="fig__fig_Seam_mesh_2"></a></p><div class="image">
<object type="image/svg+xml" data="seam_mesh_2.svg">seam_mesh_2.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__fig_Seam_mesh_2">Figure 102.3</a> Walking around a seam <em>(a)</em> with no seam vertex on the real border, <em>(b)</em> with a seam vertex on the real border, <em>(c)</em> with a closed polyline. Vertices of the seam mesh that are linked by a green dashed segment correspond to the same vertex in the underlying mesh.  </div> <br /> 
<p>Seam meshes are for example used in Chapter <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceMeshParameterization">Triangulated Surface Mesh Parameterization</a> to parameterize a topological sphere by first virtually cutting it into a topological disk.</p>
<h2><a class="anchor" id="BGLInheriting"></a>
Inheriting from a Model of a Face Graph Concept</h2>
<p>In order for a type <code>FG</code> to be a model of one of the face graph concepts, a specialization of <code>boost::graph_traits&lt;FG&gt;</code> must exist. When you derive a class from <code>FG</code> this graph traits class specialization does not match. For such cases, a header file consuming some user defined macros is provided to make the derived class a valid model of the same concept. See <code><a class="el" href="graph__traits__inheritance__macros_8h.html" title="Convenience header file defining the necessary specializations and overloads to make a class...">CGAL/boost/graph/graph_traits_inheritance_macros.h</a></code> for more details.</p>
<h1><a class="anchor" id="BGLPartitioning"></a>
Graph Partitioning</h1>
<p>For algorithms that operate locally, partitioning is often an easy way to parallelize the algorithm at little cost. The functions <code><a class="el" href="group__PkgBGLPartition.html#gaedf2c722ed8baf7d9b4df4cf0e9b86b5" title="computes a partition of the input triangular mesh into nparts parts, based on the mesh's nodal graph...">CGAL::METIS::partition_graph()</a></code> and <code><a class="el" href="group__PkgBGLPartition.html#gad72efc6b61c92ee8704858dc0b7062e9" title="computes a partition of the input triangular mesh into nparts parts, based on the mesh's dual graph...">CGAL::METIS::partition_dual_graph()</a></code> provide wrappers to the graph partitioning library METIS <a class="el" href="citelist.html#CITEREF_karypis1998fast">[3]</a>, allowing to split triangular meshes that are models of the concept <code><a class="el" href="classFaceListGraph.html" title="The concept FaceListGraph refines the concept FaceGraph and adds the requirement for traversal of all...">FaceListGraph</a></code> into a given number of subdomains.</p>
<p>The following example shows how to read, partition, and write a mesh using <code><a class="el" href="group__PkgBGLPartition.html#gad72efc6b61c92ee8704858dc0b7062e9" title="computes a partition of the input triangular mesh into nparts parts, based on the mesh's dual graph...">partition_dual_graph()</a></code>. The class template <code><a class="el" href="structCGAL_1_1Face__filtered__graph.html" title="The class Face_filtered_graph is an adaptor that creates a filtered view of a graph by restricting it...">CGAL::Face_filtered_graph</a></code> and the free function <code><a class="el" href="group__PkgBGLHelperFct.html#ga2682fb7d5f4ff4eb65607ae4118e31bc" title="copies a source model of FaceListGraph into a target model of a FaceListGraph. ">copy_face_graph()</a></code> are used to create an independent mesh from one of the subdomains of the partition. Note that the copy is optional as writing can be done directly using <code><a class="el" href="structCGAL_1_1Face__filtered__graph.html" title="The class Face_filtered_graph is an adaptor that creates a filtered view of a graph by restricting it...">Face_filtered_graph</a></code>.</p>
<p><br />
<b>File</b> <a class="el" href="BGL_surface_mesh_2surface_mesh_partition_8cpp-example.html">BGL_surface_mesh/surface_mesh_partition.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/Face_filtered_graph.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="partition_8h.html">CGAL/boost/graph/partition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/polygon_mesh_io.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>                           K;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;K::Point_3&gt;</a>                           SM;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string filename = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/blobby.off"</span>);</div><div class="line">  <span class="keywordtype">int</span> number_of_parts = (argc&gt;2) ? atoi(argv[2]) : 8;</div><div class="line"></div><div class="line">  SM sm;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__IO__grp.html#gac5b3295bd1b6375628a46d1fbaf7e881">CGAL::IO::read_polygon_mesh</a>(filename, sm))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// The vertex &lt;--&gt; partition_id property map</span></div><div class="line">  <span class="keyword">typedef</span> SM::Property_map&lt;SM::Vertex_index, std::size_t&gt;          Vertex_id_map;</div><div class="line">  Vertex_id_map vertex_pid_map = sm.add_property_map&lt;SM::Vertex_index, std::size_t&gt;(<span class="stringliteral">"v:pid"</span>).first;</div><div class="line"></div><div class="line">  <span class="comment">// The face &lt;--&gt; partition_id property map</span></div><div class="line">  <span class="keyword">typedef</span> SM::Property_map&lt;SM::Face_index, std::size_t&gt;            Face_id_map;</div><div class="line">  Face_id_map face_pid_map = sm.add_property_map&lt;SM::Face_index, std::size_t&gt;(<span class="stringliteral">"f:pid"</span>).first;</div><div class="line"></div><div class="line">  <span class="comment">// Partition the mesh</span></div><div class="line">  <a class="code" href="group__PkgBGLPartition.html#gad72efc6b61c92ee8704858dc0b7062e9">CGAL::METIS::partition_dual_graph</a>(sm, number_of_parts,</div><div class="line">                                    CGAL::parameters::vertex_partition_id_map(vertex_pid_map)</div><div class="line">                                                     .face_partition_id_map(face_pid_map));</div><div class="line"></div><div class="line">  <span class="comment">// Extract the part n°0 of the partition into a new, independent mesh</span></div><div class="line">  <span class="keyword">typedef</span> <a class="code" href="structCGAL_1_1Face__filtered__graph.html">CGAL::Face_filtered_graph&lt;SM&gt;</a>                            Filtered_graph;</div><div class="line">  Filtered_graph filtered_sm(sm, 0 <span class="comment">/*id of th part*/</span>, face_pid_map);</div><div class="line">  assert(filtered_sm.is_selection_valid());</div><div class="line">  SM part_sm;</div><div class="line">  <a class="code" href="group__PkgBGLHelperFct.html#ga2682fb7d5f4ff4eb65607ae4118e31bc">CGAL::copy_face_graph</a>(filtered_sm, part_sm);</div><div class="line"></div><div class="line">  <span class="comment">// Output the mesh extracted from subpart n°0</span></div><div class="line">  <a class="code" href="group__PkgBGLIOFct.html#gafa143949a33371dc6df8307be1ab8a66">CGAL::IO::write_polygon_mesh</a>(<span class="stringliteral">"sm_part_0.off"</span>, part_sm, CGAL::parameters::stream_precision(17));</div><div class="line"></div><div class="line">  <span class="comment">// Output all the vertices that are in the part n°0</span></div><div class="line">  std::ofstream outxyz(<span class="stringliteral">"out.xyz"</span>);</div><div class="line">  outxyz.precision(17);</div><div class="line">  boost::graph_traits&lt;SM&gt;::vertex_iterator vit, ve;</div><div class="line">  boost::tie(vit, ve) = vertices(sm);</div><div class="line">  <span class="keywordflow">for</span>(; vit!=ve; ++vit)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span>(<span class="keyword">get</span>(vertex_pid_map, *vit) == 0)</div><div class="line">      outxyz &lt;&lt; sm.point(*vit) &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><p>Using <a class="el" href="index.html#BGLNamedParameters">Named Parameters</a> some of the many options of METIS can be customized, as shown in <a class="el" href="BGL_polyhedron_3_2polyhedron_partition_8cpp-example.html">this example</a>.</p>
<h1><a class="anchor" id="BGLGraphcut"></a>
Graph Cut</h1>
<p>An optimal partition from a set of labels can be computed through a graph cut approach called alpha expansion <a class="el" href="citelist.html#CITEREF_Boykov2001FastApproximate">[1]</a>. CGAL provides <code><a class="el" href="group__PkgBGLPartition.html#gac0ae8f45718c0eb9b70ebddd5008515b" title="regularizes a partition of a graph into n labels using the alpha expansion algorithm ...">CGAL::alpha_expansion_graphcut()</a></code> which, for a graph \((V,E)\), computes the partition <code>f</code> that minimizes the following cost function:</p>
<p class="formulaDsp">
\[ \mathrm{C}(f) = \sum_{\{v0,v1\} \in E} C_E(v0,v1) + \sum_{v \in V} C_V(f_v) \]
</p>
<p>where \(C_E(v0,v1)\) is the edge cost of assigning a different label to \(v0\) and \(v1\), and \(C_V(f_v)\) is the vertex cost of assigning the label \(f\) to the vertex \(v\).</p>
<p>Three different implementations are provided and can be selected by using one of the following tags:</p>
<ul>
<li><code>CGAL::Alpha_expansion_boost_adjacency_list_tag</code> (default)</li>
<li><code>CGAL::Alpha_expansion_boost_compressed_sparse_raw_tag</code></li>
<li><code>CGAL::Alpha_expansion_MaxFlow_tag</code>, released under GPL license and provided by the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh_segmentation.tag:../Surface_mesh_segmentation/" href="../Surface_mesh_segmentation/group__PkgSurfaceMeshSegmentationRef.html">Triangulated Surface Mesh Segmentation Reference</a> package</li>
</ul>
<p>All these implementations produce the exact same result but behave differently in terms of timing and memory (see <a class="el" href="index.html#fig__alpha_exp">Figure 102.4</a>). The <em>MaxFlow</em> implementation is the fastest, but it grows rapidly in memory when increasing the complexity of the input graph and labeling; the <em>compressed sparse raw</em> (CSR) is very efficient from a memory point of view but becomes very slow as the complexity of the input graph and labeling increases; the <em>adjacency list</em> version provides a good compromise and is therefore the default implementation.</p>
<p><a class="anchor" id="fig__alpha_exp"></a></p><div class="image">
<img src="alpha_expansion.png" alt="alpha_expansion.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__alpha_exp">Figure 102.4</a> Comparison of time and memory consumed by the different alpha expansion implementations.  </div> <br /> 
<h2><a class="anchor" id="BGLGraphcutExample"></a>
Example</h2>
<p>The following example shows how to apply the alpha expansion algorithm to a <code>boost::adjacency_list</code> describing a 2D array with 3 labels "X", " " and "O":</p>
<p><br />
<b>File</b> <a class="el" href="BGL_graphcut_2alpha_expansion_example_8cpp-example.html">BGL_graphcut/alpha_expansion_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/alpha_expansion_graphcut.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/graph/adjacency_list.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>Vertex_property</div><div class="line">{</div><div class="line">  <span class="keywordtype">int</span> label;</div><div class="line">  std::vector&lt;double&gt; cost;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Edge_property</div><div class="line">{</div><div class="line">  <span class="keywordtype">double</span> weight;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">using</span> Graph = boost::adjacency_list &lt;boost::setS,</div><div class="line">                                     boost::vecS,</div><div class="line">                                     boost::undirectedS,</div><div class="line">                                     Vertex_property,</div><div class="line">                                     Edge_property&gt;;</div><div class="line"><span class="keyword">using</span> GT = boost::graph_traits&lt;Graph&gt;;</div><div class="line"><span class="keyword">using</span> vertex_descriptor = GT::vertex_descriptor;</div><div class="line"><span class="keyword">using</span> edge_descriptor = GT::edge_descriptor;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  std::array&lt;char, 3&gt; labels = { <span class="charliteral">'X'</span>, <span class="charliteral">' '</span>, <span class="charliteral">'O'</span> };</div><div class="line"></div><div class="line">  std::array&lt;std::array&lt;int, 6&gt;, 5&gt; input</div><div class="line">    = { { { 0, 2, 0, 1, 1, 1 },</div><div class="line">          { 0, 0, 1, 0, 1, 2 },</div><div class="line">          { 2, 0, 1, 1, 2, 2 },</div><div class="line">          { 0, 1, 1, 2, 2, 0 },</div><div class="line">          { 1, 1, 2, 0, 2, 2 } } };</div><div class="line"></div><div class="line">  std::array&lt;std::array&lt;vertex_descriptor, 6&gt;, 5&gt; vertices;</div><div class="line"></div><div class="line">  <span class="comment">// Init vertices from values</span></div><div class="line">  Graph g;</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; input.size(); ++ i)</div><div class="line">    <span class="keywordflow">for</span> (std::size_t j = 0; j &lt; input[i].size(); ++ j)</div><div class="line">    {</div><div class="line">      vertices[i][j] = boost::add_vertex(g);</div><div class="line">      g[vertices[i][j]].label = input[i][j];</div><div class="line"></div><div class="line">      <span class="comment">// Cost of assigning this vertex to any label is positive except</span></div><div class="line">      <span class="comment">// for current label which is 0 (favor init solution)</span></div><div class="line">      g[vertices[i][j]].cost.resize(3, 1);</div><div class="line">      g[vertices[i][j]].cost[std::size_t(input[i][j])] = 0;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="comment">// Display input values</span></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Input:"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; vertices.size(); ++ i)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (std::size_t j = 0; j &lt; vertices[i].size(); ++ j)</div><div class="line">      std::cerr &lt;&lt; labels[std::size_t(g[vertices[i][j]].label)];</div><div class="line">    std::cerr &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Init adjacency</span></div><div class="line">  <span class="keywordtype">double</span> weight = 0.5;</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; vertices.size(); ++ i)</div><div class="line">    <span class="keywordflow">for</span> (std::size_t j = 0; j &lt; vertices[i].size(); ++ j)</div><div class="line">    {</div><div class="line">      <span class="comment">// Neighbor vertices are connected</span></div><div class="line">      <span class="keywordflow">if</span> (i &lt; vertices.size() - 1)</div><div class="line">      {</div><div class="line">        edge_descriptor ed = <a class="code" href="group__PkgBGLEulerOperations.html#ga4661f850bc60686efeae2fc9d2ec3e65">boost::add_edge</a> (vertices[i][j], vertices[i+1][j], g).first;</div><div class="line">        g[ed].weight = weight;</div><div class="line">      }</div><div class="line">      <span class="keywordflow">if</span> (j &lt; vertices[i].size() - 1)</div><div class="line">      {</div><div class="line">        edge_descriptor ed = <a class="code" href="group__PkgBGLEulerOperations.html#ga4661f850bc60686efeae2fc9d2ec3e65">boost::add_edge</a> (vertices[i][j], vertices[i][j+1], g).first;</div><div class="line">        g[ed].weight = weight;</div><div class="line">      }</div><div class="line">    }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">"Alpha expansion..."</span> &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line">  <a class="code" href="group__PkgBGLPartition.html#gac0ae8f45718c0eb9b70ebddd5008515b">CGAL::alpha_expansion_graphcut</a> (g,</div><div class="line">                                  <span class="keyword">get</span> (&amp;Edge_property::weight, g),</div><div class="line">                                  <span class="keyword">get</span> (&amp;Vertex_property::cost, g),</div><div class="line">                                  <span class="keyword">get</span> (&amp;Vertex_property::label, g),</div><div class="line">                                  CGAL::parameters::vertex_index_map (<span class="keyword">get</span> (boost::vertex_index, g)));</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Display output graph</span></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Output:"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; vertices.size(); ++ i)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (std::size_t j = 0; j &lt; vertices[i].size(); ++ j)</div><div class="line">      std::cerr &lt;&lt; labels[std::size_t(g[vertices[i][j]].label)];</div><div class="line">    std::cerr &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>The output of this program shows how the initial 2D array is regularized spatially:</p>
<div class="fragment"><div class="line">Input:</div><div class="line">XOX</div><div class="line">XX X O</div><div class="line">OX  OO</div><div class="line">X  OOX</div><div class="line">  OXOO</div><div class="line"></div><div class="line">Alpha expansion...</div><div class="line"></div><div class="line">Output:</div><div class="line">XXX</div><div class="line">XX   O</div><div class="line">XX  OO</div><div class="line">X  OOO</div><div class="line">  OOOO</div></div><!-- fragment --><h2><a class="anchor" id="BGLGraphcutRegularizeSelection"></a>
Application to Regularization of the Borders of a Face Selection</h2>
<p>Manually selecting faces on a triangle mesh may create irregular borders (sawtooth) because of the shape of the triangles. Such borders can be regularized using the alpha expansion algorithm.</p>
<p>CGAL provides a function <code><a class="el" href="group__PkgBGLSelectionFct.html#gab638686b319f3b902c199d4b79df84e6" title="regularizes a selection in order to minimize the length of the border of the selection. ">CGAL::regularize_face_selection_borders()</a></code> to apply this algorithm to the borders of a face selection on a <code><a class="el" href="classFaceGraph.html" title="The concept FaceGraph refines the concept HalfedgeGraph. It adds the requirements for a graph to expl...">FaceGraph</a></code>. <a class="el" href="index.html#fig__regularization_fig">Figure 102.5</a> shows how this function affects a selection depending on the parameters.</p>
<p><a class="anchor" id="fig__regularization_fig"></a></p><div class="image">
<img src="regularize_selection.png" alt="regularize_selection.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__regularization_fig">Figure 102.5</a> Regularization of the borders of a face selection using alpha expansion. Different outputs are shown for different weight parameters, with and without preventing unselection.  </div> <br /> 
<p>The following example shows how to apply this alpha expansion regularization to the borders of a face selection of a <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh</a></code> object:</p>
<p><br />
<b>File</b> <a class="el" href="BGL_graphcut_2face_selection_borders_regularization_example_8cpp-example.html">BGL_graphcut/face_selection_borders_regularization_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/selection.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/OFF.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> Kernel = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> Mesh = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Kernel::Point_3&gt;</a>;</div><div class="line"><span class="keyword">using</span> Face_index = Mesh::Face_index;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::ifstream in((argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/blobby.off"</span>));</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!in)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: could not read input file"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  Mesh mesh;</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga7396bef8d41fe287d52d19ddbb83a3e4">CGAL::IO::read_OFF</a> (in, mesh);</div><div class="line"></div><div class="line">  std::unordered_map&lt;Face_index, bool&gt; is_selected_map;</div><div class="line"></div><div class="line">  <span class="comment">// randomly select 1/3 of faces</span></div><div class="line">  std::size_t nb_selected_before = 0;</div><div class="line">  CGAL::Random rand;</div><div class="line">  <span class="keywordflow">for</span> (Face_index fi : faces(mesh))</div><div class="line">  {</div><div class="line">    <span class="keywordtype">bool</span> selected = (rand.get_double() &lt; 1. / 3.);</div><div class="line">    is_selected_map[fi] = selected;</div><div class="line">    <span class="keywordflow">if</span> (selected)</div><div class="line">      nb_selected_before ++;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; nb_selected_before &lt;&lt; <span class="stringliteral">" selected before regularization"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgBGLSelectionFct.html#gab638686b319f3b902c199d4b79df84e6">CGAL::regularize_face_selection_borders</a> (mesh,</div><div class="line">                                           boost::make_assoc_property_map(is_selected_map),</div><div class="line">                                           0.5); <span class="comment">// using weight = 0.5</span></div><div class="line"></div><div class="line">  std::size_t nb_selected_after = 0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; sel : is_selected_map)</div><div class="line">    <span class="keywordflow">if</span> (sel.second)</div><div class="line">      ++ nb_selected_after;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; nb_selected_after &lt;&lt; <span class="stringliteral">" selected after regularization"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jun 27 2022 09:16:02 for CGAL 5.6 - CGAL and the Boost Graph Library by
    <a href="https://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>
</html><html xmlns="http://www.w3.org/1999/xhtml"><body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.6 - CGAL and the Boost Graph Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_CGAL_and_the_Boost_Graph_Library"></a><a class="anchor" id="chapterBGL"></a> </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Authors</dt><dd>Andreas Fabri, Fernando Cacciola, Philipp Moeller, and Ron Wein</dd></dl>
<p>Many geometric data structures can be interpreted as graphs as they consist of vertices and edges. This is the case for the halfedge data structure, for the polyhedral surface, for the arrangement, and for the 2D triangulation classes. With means of duality one can also interpret faces as vertices and edges between adjacent faces as edges of the dual graph.</p>
<p>The scope of CGAL is geometry and not graph algorithms. Nevertheless, this package provides the necessary classes and functions that enable using the algorithms of the <a href="https://www.boost.org/libs/graph/doc/index.html">Boost Graph Library</a> <a class="el" href="citelist.html#CITEREF_cgal:sll-bgl-02">[4]</a> (BGL for short) with CGAL data structures.</p>
<p>Furthermore, this package extends the BGL by introducing concepts such as <code><a class="el" href="classHalfedgeGraph.html" title="The concept HalfedgeGraph is a refinement of the BGL concept IncidenceGraph and adds the notion of a ...">HalfedgeGraph</a></code> and <code><a class="el" href="classFaceGraph.html" title="The concept FaceGraph refines the concept HalfedgeGraph. It adds the requirements for a graph to expl...">FaceGraph</a></code> allowing to handle <em>halfedges</em> and <em>faces</em>. These concepts reflect the design of the halfedge data structure described in Chapter <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgHalfedgeDS">Halfedge Data Structures</a>, with opposite halfedges and circular sequences of halfedges around vertices and around faces.</p>
<p>This chapter is organized as follows:</p><ul>
<li>The first section, Section <a class="el" href="index.html#BGLA">A Short Introduction to the Boost Graph Library</a>, summarizes the main ideas of the BGL.</li>
<li>Section <a class="el" href="index.html#BGLHeader">Header Files, Namespaces, and Naming Conventions</a> then explains where to find header files and the chosen naming conventions, as we blend two different libraries.</li>
<li>The four following sections give examples on how to use <a class="el" href="namespaceCGAL.html" title="CGAL Namespace. ">CGAL</a> graph and mesh data structures such as <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceMesh">Surface_mesh </a>, <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgPolyhedron">Polyhedron </a>, <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgArrangementOnSurface2">Arrangement_2 </a>, and the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgTriangulation2">2D triangulation </a> classes as models of the BGL concepts.</li>
<li>Starting with Section <a class="el" href="index.html#BGLExtensions">Extensions of the BGL</a>, we introduce new graph concepts, classes, and functions that extend the functionalities of the BGL.</li>
</ul>
<h1><a class="anchor" id="BGLA"></a>
A Short Introduction to the Boost Graph Library</h1>
<p>The algorithms of the BGL operate on models of various <em>graph concepts</em>. The <em>traits class</em> <code>boost::graph_traits</code> enable algorithms to determine the types of vertices and edges (similar to <code>std::iterator_traits</code> for iterators). <em>Free functions</em> that operate on graphs enable algorithms to obtain, for example, the source vertex of an edge, or all edges incident to a vertex. The algorithms use <em>property maps</em> to associate information with vertices and edges. The algorithms enable <em>visitors</em> to register callbacks that are called later on during the execution of the algorithms. Finally, the graph algorithms use the <em>named parameter</em> mechanism, which enables passing the arguments in arbitrary order.</p>
<h2><a class="anchor" id="BGLGraphConcepts"></a>
Graph Concepts</h2>
<p>The BGL introduces several <a href="https://www.boost.org/libs/graph/doc/graph_concepts.html">graph concepts</a>, which have different sets of characteristics and requirements. For example, iterating through all vertices or all edges in a graph, obtaining the outgoing or in-going edges of a vertex, inserting vertices and edges into a graph, and removing vertices and edges from a graph.</p>
<h2><a class="anchor" id="BGLTheGraphTraitsClass"></a>
The Graph Traits Class</h2>
<p>An algorithm operating on a graph model determines types with the help of the traits class <a href="https://www.boost.org/libs/graph/doc/graph_traits.html">boost::graph_traits</a>. Such types are the <code>vertex_descriptor</code>, which is similar to a vertex handle in CGAL data structures, or the <code>edge_descriptor</code>, which is similar to the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/HalfedgeDS.tag:../HalfedgeDS/" href="../HalfedgeDS/classHalfedgeDSHalfedge.html">halfedge handle </a> in the halfedge data structure or to the type <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Triangulation__2.html#ad28c6e0e0e65b8aaecb1ae76d8744b33">Edge </a> in 2D triangulations. There are also iterators, such as the <code>vertex_iterator</code>, which is similar to a vertex iterator in CGAL data structures, and the <code>out_edge_iterator</code>, which is similar to the edge circulator; it enables to iterate through the edges incident to a vertex. The iterators are similar and not equivalent, because their value type is a <code>vertex_descriptor</code>, whereas in CGAL handles, iterators, and circulators all have the same value type, namely the vertex or edge types.</p>
<p>Given a graph type <code>G</code>, definitions of descriptors and iterators look as follows:</p>
<div class="fragment"><div class="line">boost::graph_traits&lt;Graph&gt;::vertex_descriptor vd;</div><div class="line">boost::graph_traits&lt;Graph&gt;::edge_iterator ei;</div><div class="line">...</div></div><!-- fragment --><h2><a class="anchor" id="BGLFreeFunctionsforExploringaGraph"></a>
Free Functions for Exploring a Graph</h2>
<p>Algorithms obtain incidence information in graphs with the help of global functions such as:</p><ul>
<li><code>std::pair&lt;vertex_iterator,vertex_iterator&gt; vertices(const Graph&amp; g);</code> to obtain an iterator range providing access to all the vertices, or</li>
<li><code>int num_vertices(const Graph&amp;);</code> to obtain the number of vertices of a graph, or</li>
<li><code>vertex_descriptor source(edge_descriptor, const Graph&amp;);</code> to obtain the source vertex of an edge.</li>
</ul>
<p>Note, that the way we have written the types is a simplification; in reality, the signature of the first of the above functions is:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Graph&gt;::vertex_iterator vertex_iterator;</div><div class="line">std::pair&lt;vertex_iterator,vertex_iterator&gt; vertices(<span class="keyword">const</span> Graph&amp; g);</div></div><!-- fragment --><h2><a class="anchor" id="BGLPropertyMaps"></a>
Property Maps</h2>
<p>Another feature extensively used in the BGL is the <em>property map</em>, which is offered by the <a href="https://www.boost.org/libs/property_map/doc/property_map.html">Boost Property Map Library</a>. Property maps are a general purpose interface for mapping key objects to corresponding value objects.</p>
<p>The BGL uses property maps to associate information with vertices and edges. This mechanism uses a traits class (<code>boost::property_traits</code>) and free functions to read (<code>get</code>) and write (<code>put</code>) information in vertices, edges, and also in halfedges and faces for models of the CGAL graph concepts. For example, the BGL Dijksta's shortest path algorithm writes the predecessor of each vertex, as well as the distance to the source in such a property map.</p>
<p>Some default property maps are associated with the graph types. They are called <em>internal property maps</em> and can be retrieved using an overload of the function <code>get()</code>. For example, </p><div class="fragment"><div class="line">pm = <span class="keyword">get</span>(boost::vertex_index, g)</div></div><!-- fragment --><p> returns a property map that associates an index in the range <code>[0, num_vertices(g))</code> with each vertex of the graph. This reduces the number of parameters to pass. The data itself may be stored in the vertex or the edge, or it may be stored in an external data structure, or it may be computed on the fly. This is an implementation detail of a particular property map.</p>
<p>See also Chapter <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgPropertyMap">CGAL and Boost Property Maps</a>.</p>
<h2><a class="anchor" id="BGLVisitors"></a>
Visitors</h2>
<p>Visitors are objects that provide functions to be called at specified event points by the algorithm that they visit. The functions as well as the event points are algorithm-specific. Examples of such event points in graph algorithms are when a vertex is traversed the first time, or when all outgoing edges of a vertex have been traversed.<br />
</p>
<p>See also Section <a href="https://www.boost.org/libs/graph/doc/visitor_concepts.html">Visitor Concepts</a> in the BGL manual.</p>
<h2><a class="anchor" id="BGLNamedParameters"></a>
Named Parameters</h2>
<p>The notion of <em>named parameters</em> was introduced in the BGL, and allow the user to specify only those parameters which are really needed, by name, making the parameter ordering unimportant. See also <a href="https://www.boost.org/libs/graph/doc/bgl_named_params.html">this page</a> in the manual of the BGL for more information.</p>
<p>Say there is a function <code>f()</code> that takes 3 parameters called name, age and gender, and you have variables <code>n</code>, <code>a</code> and <code>g</code> to pass as parameters to that function. Without named parameters, you would call it like this: <code>f(n,a,g)</code>, whereas with named parameters, you call it like this: <code>f(name(n).age(a).gender(g))</code>. That is, you give each parameter a name by wrapping it into a function whose name matches that of the parameter. The entire list of named parameters is really a composition of function calls separated by a dot ("."). Thus, if the function takes a mix of mandatory and named parameters, you use a comma to separate the last non-named parameter from the first named parameters, like this: </p><div class="fragment"><div class="line">f(non_named_par0, non_named_par1, name(n).age(a).gender(g))</div></div><!-- fragment --><p> When you use named parameters, the ordering is irrelevant, so <code>f(name(n).age(a).gender(g))</code> is equivalent to <code>f(age(a).gender(g).name(n))</code>, and you can just omit any named parameter that has a default value.</p>
<p>The sequence of named parameters should start with <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL_1_1parameters.html">CGAL::parameters</a>::</code>.</p>
<h3><a class="anchor" id="BGLNamedParametersExample"></a>
Example</h3>
<p>Below is a sample call of a function that uses the optional BGL named parameters.</p>
<div class="fragment"><div class="line"><span class="comment">// pmesh : polygon mesh with patches to be refined</span></div><div class="line"><span class="comment">// faces : the range of faces defining the patches to refine</span></div><div class="line"><span class="comment">// faces_out : output iterator into which descriptors of new faces are put</span></div><div class="line"><span class="comment">// vertices_out : output iterator into which descriptors of new vertices are put</span></div><div class="line"><span class="comment">// vertex_point_map : the property map with the points associated to the vertices of `pmesh`</span></div><div class="line"><span class="comment">// density_control_factor : factor to control density of the output mesh</span></div><div class="line"><a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__meshing__grp.html#gafd90c169a7c17a1e503651f59a6dc57b">refine</a>(pmesh,</div><div class="line">       faces,</div><div class="line">       faces_out,</div><div class="line">       vertices_out,</div><div class="line">       CGAL::parameters::vertex_point_map(vpmap)</div><div class="line">                        .density_control_factor(d));</div></div><!-- fragment --><h1><a class="anchor" id="BGLHeader"></a>
Header Files, Namespaces, and Naming Conventions</h1>
<p>This package provides the necessary classes and functions that enable using CGAL data structures as models of the BGL graph concepts. To this end, we offer partial specializations of the <code>boost::graph_traits&lt;Graph&gt;</code> for various CGAL packages. For each such package, denoted <code>PACKAGE</code>, the partial specializations live in the namespace <code>boost</code> and are located in the header file <code>CGAL/boost/graph/graph_traits_PACKAGE.h</code>. Free functions are in the namespace <code><a class="el" href="namespaceCGAL.html" title="CGAL Namespace. ">CGAL</a></code>, and the compiler uses argument-dependent lookup to find them. Euler operations, described in Section <a class="el" href="index.html#BGLEulerOperations">Euler Operations</a>, are in the namespace <code>CGAL::Euler</code>, as the function <code><a class="el" href="classMutableFaceGraph.html#abf15bb91e6cdafb057514db8acf38a08">remove_face()</a></code> is at the same time a low-level and an Euler operation. Concerning the naming conventions, we have to use those of the BGL, as to fulfill the requirements of the concepts defined in the BGL.</p>
<p>Note that these partial specializations are often providing more than is required, making these classes not only models of the graph concepts of the BGL, but also models of the <a class="el" href="namespaceCGAL.html" title="CGAL Namespace. ">CGAL</a> graph concepts, that will be described in detail in Section <a class="el" href="index.html#BGLExtensions">Extensions of the BGL</a>. Correspondence tables between the types of a CGAL data structure and their BGL equivalents can be found in the <a class="el" href="group__PkgBGLTraits.html">Specializations of boost::graph_traits</a> documentation page.</p>
<p>We present in the following sections some examples of utilization of some CGAL data structures as BGL graphs.</p>
<h1><a class="anchor" id="BGLSurface_mesh"></a>
The Class Surface_mesh as Model of the Boost Graph Concept</h1>
<p>The class <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">Surface_mesh</a></code> is a model of most of the graph concepts of the BGL as well as the concepts provided by CGAL. A complete list can be found in the documentation of <a class="el" href="group__PkgBGLTraits.html#BGLSMGT">boost::graph_traits </a>. The examples show how to use some of the BGL algorithms with <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">Surface_mesh</a></code> and show how to use the concepts provided by CGAL to implement a simple algorithm.</p>
<h2><a class="anchor" id="BGLExampleMinimumSpanningTreeofaSurfaceMesh"></a>
Example: Minimum Spanning Tree of a Surface_mesh</h2>
<p>The following example program computes the minimum spanning tree on a surface mesh. More examples can be found in Chapters <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceMeshSimplification">Triangulated Surface Mesh Simplification</a>, <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceMeshSegmentation">Triangulated Surface Mesh Segmentation</a>, and <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceMeshDeformation">Triangulated Surface Mesh Deformation</a>.</p>
<p>The surface mesh class uses integer indices to address vertices and edges, and it comes with a built-in property mechanism that maps nicely on the BGL.</p>
<p><br />
<b>File</b> <a class="el" href="BGL_surface_mesh_2prim_8cpp-example.html">BGL_surface_mesh/prim.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/prim_minimum_spanning_tree.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>                       <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                                      Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point&gt;</a>                            Mesh;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::vertex_descriptor vertex_descriptor;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string filename = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/prim.off"</span>);</div><div class="line"></div><div class="line">  Mesh P;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__IO__grp.html#gac5b3295bd1b6375628a46d1fbaf7e881">CGAL::IO::read_polygon_mesh</a>(filename, P))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line">  Mesh::Property_map&lt;vertex_descriptor,vertex_descriptor&gt; <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__STLAlgos.html#ga6c5d40930db429775066babac7c35d7f">predecessor</a>;</div><div class="line">  predecessor = P.add_property_map&lt;vertex_descriptor,vertex_descriptor&gt;(<span class="stringliteral">"v:predecessor"</span>).first;</div><div class="line"></div><div class="line">  boost::prim_minimum_spanning_tree(P, predecessor, boost::root_vertex(*vertices(P).first));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"#VRML V2.0 utf8\n"</span></div><div class="line">    <span class="stringliteral">"DirectionalLight {\n"</span></div><div class="line">    <span class="stringliteral">"direction 0 -1 0\n"</span></div><div class="line">    <span class="stringliteral">"}\n"</span></div><div class="line">    <span class="stringliteral">"Shape {\n"</span></div><div class="line">    <span class="stringliteral">"  appearance Appearance {\n"</span></div><div class="line">    <span class="stringliteral">"    material Material { emissiveColor 1 0 0}}\n"</span></div><div class="line">    <span class="stringliteral">"    geometry\n"</span></div><div class="line">    <span class="stringliteral">"    IndexedLineSet {\n"</span></div><div class="line">    <span class="stringliteral">"      coord Coordinate {\n"</span></div><div class="line">    <span class="stringliteral">"        point [ \n"</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(vertex_descriptor vd : vertices(P)){</div><div class="line">    std::cout &lt;&lt;  <span class="stringliteral">"        "</span> &lt;&lt; P.point(vd) &lt;&lt; <span class="stringliteral">"\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"        ]\n"</span></div><div class="line">    <span class="stringliteral">"     }\n"</span></div><div class="line">    <span class="stringliteral">"      coordIndex [\n"</span>;</div><div class="line">  <span class="keywordflow">for</span>(vertex_descriptor vd : vertices(P)){</div><div class="line">    <span class="keywordflow">if</span>(predecessor[vd]!=vd){</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">"      "</span> &lt;&lt; std::size_t(vd) &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; std::size_t(predecessor[vd]) &lt;&lt;  <span class="stringliteral">", -1\n"</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"]\n"</span></div><div class="line">    <span class="stringliteral">"  }#IndexedLineSet\n"</span></div><div class="line">    <span class="stringliteral">"}# Shape\n"</span>;</div><div class="line"></div><div class="line">  P.remove_property_map(predecessor);</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="BGLPolyhedral"></a>
The Class Polyhedron_3 as Model of the Boost Graph Concept</h1>
<p>The class <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">Polyhedron_3</a></code> is a model of most of the graph concepts of the BGL as well as the concepts provided by CGAL. A complete list can be found in the documentation of <a class="el" href="group__PkgBGLTraits.html#BGLPolyGT">boost::graph_traits </a>. The examples show how to use some of the BGL algorithms with <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">Polyhedron_3</a></code> and show how to use the concepts provided by CGAL to implement a simple algorithm.</p>
<h2><a class="anchor" id="BGLExampleMinimumSpanningTreeofaPolyhedral"></a>
Example: Minimum Spanning Tree of a Polyhedral Surface</h2>
<p>The following example program computes the minimum spanning tree on a polyhedral surface. More examples can be found in the Chapter <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceMeshSimplification">Triangulated Surface Mesh Simplification</a>.</p>
<p><br />
<b>File</b> <a class="el" href="BGL_polyhedron_3_2kruskal_8cpp-example.html">BGL_polyhedron_3/kruskal.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/kruskal_min_spanning_tree.h&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>                       Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a>                                     Vector;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                                      Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;Kernel&gt;</a>                           Polyhedron;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt;::vertex_descriptor vertex_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt;::vertex_iterator   vertex_iterator;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt;::edge_descriptor   edge_descriptor;</div><div class="line"></div><div class="line"><span class="comment">// The BGL makes heavy use of indices associated to the vertices</span></div><div class="line"><span class="comment">// We use a std::map to store the index</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::map&lt;vertex_descriptor,int&gt; Vertex_index_map;</div><div class="line">Vertex_index_map vertex_index_map;</div><div class="line"></div><div class="line"><span class="comment">// A std::map is not a property map, because it is not lightweight</span></div><div class="line"><span class="keyword">typedef</span> boost::associative_property_map&lt;Vertex_index_map&gt; Vertex_index_pmap;</div><div class="line">Vertex_index_pmap vertex_index_pmap(vertex_index_map);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">kruskal(<span class="keyword">const</span> Polyhedron&amp; P)</div><div class="line">{</div><div class="line">  <span class="comment">// associate indices to the vertices</span></div><div class="line">  vertex_iterator vb, ve;</div><div class="line">  <span class="keywordtype">int</span> index = 0;</div><div class="line"></div><div class="line">  <span class="comment">// boost::tie assigns the first and second element of the std::pair</span></div><div class="line">  <span class="comment">// returned by boost::vertices to the variables vb and ve</span></div><div class="line">  <span class="keywordflow">for</span>(boost::tie(vb, ve)=vertices(P); vb!=ve; ++vb){</div><div class="line">    vertex_index_pmap[*vb]= index++;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// We use the default edge weight which is the length of the edge</span></div><div class="line">  <span class="comment">// This property map is defined in graph_traits_Polyhedron_3.h</span></div><div class="line"></div><div class="line">  <span class="comment">// In the function call you can see a named parameter: vertex_index_map</span></div><div class="line">  std::list&lt;edge_descriptor&gt; mst;</div><div class="line"></div><div class="line">  boost::kruskal_minimum_spanning_tree(P,</div><div class="line">                                       std::back_inserter(mst),</div><div class="line">                                       boost::vertex_index_map(vertex_index_pmap));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"#VRML V2.0 utf8\n"</span></div><div class="line">    <span class="stringliteral">"Shape {\n"</span></div><div class="line">    <span class="stringliteral">"  appearance Appearance {\n"</span></div><div class="line">    <span class="stringliteral">"    material Material { emissiveColor 1 0 0}}\n"</span></div><div class="line">    <span class="stringliteral">"    geometry\n"</span></div><div class="line">    <span class="stringliteral">"    IndexedLineSet {\n"</span></div><div class="line">    <span class="stringliteral">"      coord Coordinate {\n"</span></div><div class="line">    <span class="stringliteral">"        point [ \n"</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(boost::tie(vb, ve) = vertices(P); vb!=ve; ++vb){</div><div class="line">    std::cout &lt;&lt;  <span class="stringliteral">"        "</span> &lt;&lt; (*vb)-&gt;point() &lt;&lt; <span class="stringliteral">"\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"        ]\n"</span></div><div class="line">               <span class="stringliteral">"     }\n"</span></div><div class="line">    <span class="stringliteral">"      coordIndex [\n"</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(std::list&lt;edge_descriptor&gt;::iterator it = mst.begin(); it != mst.end(); ++it)</div><div class="line">  {</div><div class="line">    edge_descriptor e = *it ;</div><div class="line">    vertex_descriptor s = source(e,P);</div><div class="line">    vertex_descriptor t = target(e,P);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"      "</span> &lt;&lt; vertex_index_pmap[s] &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; vertex_index_pmap[t] &lt;&lt;  <span class="stringliteral">", -1\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"]\n"</span></div><div class="line">    <span class="stringliteral">"  }#IndexedLineSet\n"</span></div><div class="line">    <span class="stringliteral">"}# Shape\n"</span>;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">  Polyhedron P;</div><div class="line">  Point a(1,0,0);</div><div class="line">  Point b(0,1,0);</div><div class="line">  Point c(0,0,1);</div><div class="line">  Point d(0,0,0);</div><div class="line"></div><div class="line">  P.make_tetrahedron(a,b,c,d);</div><div class="line"></div><div class="line">  kruskal(P);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="BGLExampleUsingVerticesandEdgeswithanID"></a>
Example: Using Vertices, and Edges with an ID</h2>
<p>The following example program shows a call to the BGL Kruskal's minimum spanning tree algorithm accessing the <code>id()</code> field stored in a polyhedron vertex.</p>
<p>The main function illustrates the access to the <code>id()</code> field.</p>
<p><br />
<b>File</b> <a class="el" href="BGL_polyhedron_3_2kruskal_with_stored_id_8cpp-example.html">BGL_polyhedron_3/kruskal_with_stored_id.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_items_with_id_3.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/kruskal_min_spanning_tree.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>                               Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                                              Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;Kernel,CGAL::Polyhedron_items_with_id_3&gt;</a>  Polyhedron;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt;::vertex_descriptor vertex_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt;::vertex_iterator   vertex_iterator;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt;::edge_descriptor   edge_descriptor;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">kruskal( <span class="keyword">const</span> Polyhedron&amp; P)</div><div class="line">{</div><div class="line"></div><div class="line">  <span class="comment">// We use the default edge weight which is the length of the edge</span></div><div class="line">  <span class="comment">// This property map is defined in graph_traits_Polyhedron_3.h</span></div><div class="line"></div><div class="line">  <span class="comment">// This function call requires a vertex_index_map named parameter which</span></div><div class="line">  <span class="comment">// when  ommitted defaults to "get(vertex_index,graph)".</span></div><div class="line">  <span class="comment">// That default works here because the vertex type has an "id()" method</span></div><div class="line">  <span class="comment">// field which is used by the vertex_index internal property.</span></div><div class="line">  std::list&lt;edge_descriptor&gt; mst;</div><div class="line">  boost::kruskal_minimum_spanning_tree(P,std::back_inserter(mst));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"#VRML V2.0 utf8\n"</span></div><div class="line">    <span class="stringliteral">"Shape {\n"</span></div><div class="line">    <span class="stringliteral">"appearance Appearance {\n"</span></div><div class="line">    <span class="stringliteral">"material Material { emissiveColor 1 0 0}}\n"</span></div><div class="line">    <span class="stringliteral">"geometry\n"</span></div><div class="line">    <span class="stringliteral">"IndexedLineSet {\n"</span></div><div class="line">    <span class="stringliteral">"coord Coordinate {\n"</span></div><div class="line">    <span class="stringliteral">"point [ \n"</span>;</div><div class="line"></div><div class="line">  vertex_iterator vb, ve;</div><div class="line">  <span class="keywordflow">for</span>(boost::tie(vb,ve) = vertices(P); vb!=ve; ++vb){</div><div class="line">    std::cout &lt;&lt; (*vb)-&gt;point() &lt;&lt; <span class="stringliteral">"\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"]\n"</span></div><div class="line">    <span class="stringliteral">"}\n"</span></div><div class="line">    <span class="stringliteral">"coordIndex [\n"</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(std::list&lt;edge_descriptor&gt;::iterator it = mst.begin(); it != mst.end(); ++it){</div><div class="line">    std::cout &lt;&lt; source(*it,P)-&gt;id()</div><div class="line">              &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; target(*it,P)-&gt;id() &lt;&lt;  <span class="stringliteral">", -1\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"]\n"</span></div><div class="line">    <span class="stringliteral">"}#IndexedLineSet\n"</span></div><div class="line">    <span class="stringliteral">"}# Shape\n"</span>;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">  Polyhedron P;</div><div class="line"></div><div class="line">  Point a(1,0,0);</div><div class="line">  Point b(0,1,0);</div><div class="line">  Point c(0,0,1);</div><div class="line">  Point d(0,0,0);</div><div class="line"></div><div class="line">  P.make_tetrahedron(a,b,c,d);</div><div class="line"></div><div class="line">  <span class="comment">// associate indices to the vertices using the "id()" field of the vertex.</span></div><div class="line">  vertex_iterator vb, ve;</div><div class="line">  <span class="keywordtype">int</span> index = 0;</div><div class="line"></div><div class="line">  <span class="comment">// boost::tie assigns the first and second element of the std::pair</span></div><div class="line">  <span class="comment">// returned by boost::vertices to the variables vit and ve</span></div><div class="line">  <span class="keywordflow">for</span>(boost::tie(vb,ve)=vertices(P); vb!=ve; ++vb ){</div><div class="line">    vertex_descriptor  vd = *vb;</div><div class="line">    vd-&gt;id() = index++;</div><div class="line">  }</div><div class="line"></div><div class="line">  kruskal(P);</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="BGLTriangulations"></a>
Triangulations as Models of the Boost Graph Concept</h1>
<p>Triangulations have vertices and faces, allowing for a direct translation as a graph. A halfedge is defined as a pair of a face handle and the index of the edge. A complete list can be found in the documentation of <a class="el" href="group__PkgBGLTraits.html#BGLT2GT">boost::graph_traits </a>.</p>
<p>A classical example for an algorithm that is a combination of computational geometry and graph theory is the <em>Euclidean Minimum Spanning Tree</em> for a point set in the plane. It can be computed by running the minimum spanning tree algorithm on a Delaunay triangulation of the point set.</p>
<h2><a class="anchor" id="BGLExampleEuclideanMinimumSpanningTree"></a>
Example: Euclidean Minimum Spanning Tree</h2>
<p>In the following example we create a Delaunay triangulation and run Kruskal's minimum spanning tree algorithm on it. Because the vertex handles of the triangulation are not indices in an array, we have to provide a property map that maps vertex handles to integers in the range <code>[0, t.number_of_vertices())</code>.</p>
<p><br />
<b>File</b> <a class="el" href="BGL_triangulation_2_2emst_8cpp-example.html">BGL_triangulation_2/emst.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Delaunay_triangulation_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/graph_traits_Delaunay_triangulation_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/kruskal_min_spanning_tree.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>         K;</div><div class="line"><span class="keyword">typedef</span> K::Point_2                                                  Point;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2&lt;K&gt;</a>                           Triangulation;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Triangulation&gt;::vertex_descriptor       vertex_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Triangulation&gt;::vertex_iterator         vertex_iterator;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Triangulation&gt;::edge_descriptor         edge_descriptor;</div><div class="line"></div><div class="line"><span class="comment">// The BGL makes use of indices associated to the vertices</span></div><div class="line"><span class="comment">// We use a std::map to store the index</span></div><div class="line"><span class="keyword">typedef</span> std::map&lt;vertex_descriptor,int&gt;                             VertexIndexMap;</div><div class="line"></div><div class="line"><span class="comment">// A std::map is not a property map, because it is not lightweight</span></div><div class="line"><span class="keyword">typedef</span> boost::associative_property_map&lt;VertexIndexMap&gt;             VertexIdPropertyMap;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc,<span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename = (argc &gt; 1) ? argv[1] : <span class="stringliteral">"data/points.xy"</span>;</div><div class="line">  std::ifstream input(filename);</div><div class="line">  Triangulation tr;</div><div class="line"></div><div class="line">  Point p;</div><div class="line">  <span class="keywordflow">while</span>(input &gt;&gt; p)</div><div class="line">    tr.insert(p);</div><div class="line"></div><div class="line">  <span class="comment">// Associate indices to the vertices</span></div><div class="line">  VertexIndexMap vertex_id_map;</div><div class="line">  VertexIdPropertyMap vertex_index_pmap(vertex_id_map);</div><div class="line">  <span class="keywordtype">int</span> index = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(vertex_descriptor vd : vertices(tr))</div><div class="line">    vertex_id_map[vd] = index++;</div><div class="line"></div><div class="line">  <span class="comment">// We use the default edge weight which is the squared length of the edge</span></div><div class="line">  <span class="comment">// This property map is defined in graph_traits_Triangulation_2.h</span></div><div class="line"></div><div class="line">  <span class="comment">// In the function call you can see a named parameter: vertex_index_map</span></div><div class="line">  std::list&lt;edge_descriptor&gt; mst;</div><div class="line">  boost::kruskal_minimum_spanning_tree(tr, std::back_inserter(mst),</div><div class="line">                                       vertex_index_map(vertex_index_pmap));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The edges of the Euclidean mimimum spanning tree:"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span>(edge_descriptor ed : mst)</div><div class="line">  {</div><div class="line">    vertex_descriptor svd = source(ed, tr);</div><div class="line">    vertex_descriptor tvd = target(ed, tr);</div><div class="line">    Triangulation::Vertex_handle sv = svd;</div><div class="line">    Triangulation::Vertex_handle tv = tvd;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"[ "</span> &lt;&lt; sv-&gt;point() &lt;&lt; <span class="stringliteral">"  |  "</span> &lt;&lt; tv-&gt;point() &lt;&lt; <span class="stringliteral">" ] "</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="BGLExampleStoringtheVertexIDintheVertex"></a>
Example: Storing the Vertex ID in the Vertex</h2>
<p>The algorithms of the BGL extensively use of the indices of vertices. In the previous example we stored the indices in a <code>std::map</code> and turned that map in a property map. This property map was then passed as argument to the shortest path function.</p>
<p>If the user does not pass explicitly a property map, the graph algorithms use the property map returned by the call <code>get(boost::vertex_index,ft)</code>. This property map assumes that the vertex has a member function <code>id()</code> that returns a reference to an int. Therefore CGAL offers a class <code><a class="el" href="classCGAL_1_1Triangulation__vertex__base__with__id__2.html" title="The class Triangulation_vertex_base_with_id_2 is a model of the concept TriangulationVertexBase_2, the base vertex of a 2D-triangulation. ">Triangulation_vertex_base_with_id_2</a></code>. It is in the user's responsibility to set the indices properly.</p>
<p>The example further illustrates that the graph traits also works for the Delaunay triangulation.</p>
<p><br />
<b>File</b> <a class="el" href="BGL_triangulation_2_2dijkstra_with_internal_properties_8cpp-example.html">BGL_triangulation_2/dijkstra_with_internal_properties.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Delaunay_triangulation_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Triangulation_vertex_base_with_id_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/graph_traits_Delaunay_triangulation_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/dijkstra_shortest_paths.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>             K;</div><div class="line"><span class="keyword">typedef</span> K::Point_2                                                      Point;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Triangulation__vertex__base__with__id__2.html">CGAL::Triangulation_vertex_base_with_id_2&lt;K&gt;</a>                    Tvb;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Triangulation__face__base__2.html">CGAL::Triangulation_face_base_2&lt;K&gt;</a>                              Tfb;</div><div class="line"><span class="keyword">typedef</span> CGAL::Triangulation_data_structure_2&lt;Tvb, Tfb&gt;                  Tds;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2&lt;K, Tds&gt;</a>                          Triangulation;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Triangulation&gt;::vertex_descriptor           vertex_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Triangulation&gt;::vertex_iterator             vertex_iterator;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::property_map&lt;Triangulation, boost::vertex_index_t&gt;::type VertexIdPropertyMap;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc,<span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename = (argc &gt; 1) ? argv[1] : <span class="stringliteral">"data/points.xy"</span>;</div><div class="line">  std::ifstream input(filename);</div><div class="line">  Triangulation tr;</div><div class="line"></div><div class="line">  Point p;</div><div class="line">  <span class="keywordflow">while</span>(input &gt;&gt; p)</div><div class="line">    tr.insert(p);</div><div class="line"></div><div class="line">  <span class="comment">// associate indices to the vertices</span></div><div class="line">  <span class="keywordtype">int</span> index = 0;</div><div class="line">  <span class="keywordflow">for</span>(vertex_descriptor vd : vertices(tr))</div><div class="line">    vd-&gt;id()= index++;</div><div class="line"></div><div class="line">  VertexIdPropertyMap vertex_index_pmap = <span class="keyword">get</span>(boost::vertex_index, tr);</div><div class="line"></div><div class="line">  <span class="comment">// Dijkstra's shortest path needs property maps for the predecessor and distance</span></div><div class="line">  std::vector&lt;vertex_descriptor&gt; <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__STLAlgos.html#ga6c5d40930db429775066babac7c35d7f">predecessor</a>(num_vertices(tr));</div><div class="line">  boost::iterator_property_map&lt;std::vector&lt;vertex_descriptor&gt;::iterator, VertexIdPropertyMap&gt;</div><div class="line">    predecessor_pmap(predecessor.begin(), vertex_index_pmap);</div><div class="line"></div><div class="line">  std::vector&lt;double&gt; distance(num_vertices(tr));</div><div class="line">  boost::iterator_property_map&lt;std::vector&lt;double&gt;::iterator, VertexIdPropertyMap&gt;</div><div class="line">    distance_pmap(distance.begin(), vertex_index_pmap);</div><div class="line"></div><div class="line">  vertex_descriptor source = *vertices(tr).first;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"\nStart dijkstra_shortest_paths at "</span> &lt;&lt; source-&gt;point() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  boost::dijkstra_shortest_paths(tr, source, distance_map(distance_pmap)</div><div class="line">                                            .predecessor_map(predecessor_pmap));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(vertex_descriptor vd : vertices(tr))</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; vd-&gt;point() &lt;&lt; <span class="stringliteral">" ["</span> &lt;&lt; vd-&gt;id() &lt;&lt; <span class="stringliteral">"] "</span>;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">" has distance = "</span>  &lt;&lt; <span class="keyword">get</span>(distance_pmap,vd) &lt;&lt; <span class="stringliteral">" and predecessor "</span>;</div><div class="line"></div><div class="line">    vd = <span class="keyword">get</span>(predecessor_pmap,vd);</div><div class="line">    std::cout &lt;&lt; vd-&gt;point() &lt;&lt; <span class="stringliteral">" ["</span> &lt;&lt; vd-&gt;id() &lt;&lt; <span class="stringliteral">"]\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="BGLArrangements"></a>
Arrangements as Models of the Boost Graph Concept</h1>
<p>CGAL offers a partial specialization of the boost graph traits for its arrangement class as well as for its dual graph.</p>
<h2><a class="anchor" id="arr_sssecbgl_primal"></a>
Example for the Arrangement as Graph</h2>
<p>Arrangement instances are adapted to <em>boost</em> graphs by specializing the <code>boost::graph_traits</code> template for <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> instances. The graph-traits states the graph concepts that the arrangement class models (see below) and defines the types required by these concepts.</p>
<p>In this specialization the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> vertices correspond to the graph vertices, where two vertices are adjacent if there is at least one halfedge connecting them. More precisely, <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#a7cdc734c8b7109fe4f62b2467d05b5c3">Arrangement_2::Vertex_handle</a></code> is the graph-vertex type, while <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#adf9ae7012e73ea8f327ab59515b00828">Arrangement_2::Halfedge_handle</a></code> is the graph-edge type. As halfedges are directed, we consider the graph to be directed as well. Moreover, as several interior-disjoint \( x\)-monotone curves (say circular arcs) may share two common endpoints, inducing an arrangement with two vertices that are connected with several edges, we allow parallel edges in our <em>boost</em> graph.</p>
<p>Given an <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> instance, we can efficiently traverse its vertices and halfedges. Thus, the arrangement graph is a model of the concepts <code><a class="el" href="classVertexListGraph.html" title="Concept from the Boost Graph Library. See https://www.boost.org/libs/graph/doc/VertexListGraph.html. ">VertexListGraph</a></code> and <code><a class="el" href="classEdgeListGraph.html" title="Concept from the Boost Graph Library. See https://www.boost.org/libs/graph/doc/EdgeListGraph.html. ">EdgeListGraph</a></code> introduced by the BGL. At the same time, we use an iterator adapter of the circulator over the halfedges incident to a vertex (<code><a class="el" href="classCGAL_1_1Halfedge__around__target__circulator.html" title="A bidirectional circulator with value type boost::graph_traits&lt;Graph&gt;::halfedge_descriptor over all h...">Halfedge_around_target_circulator</a></code> - see Section <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/index.html#arr_sssectr_vertex">Traversal Methods for an Arrangement Vertex</a> of the chapter on arrangements), so it is possible to go over the ingoing and outgoing edges of a vertex in linear time. Thus, our arrangement graph is a model of the concept <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classBidirectionalGraph.html">BidirectionalGraph</a></code> (this concept refines <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classIncidenceGraph.html">IncidenceGraph</a></code>, which requires only the traversal of outgoing edges).</p>
<p>It is important to notice that the vertex descriptors we use are <code>Vertex_handle</code> objects and <em>not</em> vertex indices. However, in order to gain more efficiency in most BGL algorithm, it is better to have them indexed \( 0, 1, \ldots, (n-1)\), where \( n\) is the number of vertices. We therefore introduce the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__vertex__index__map.html">Arr_vertex_index_map</a>&lt;Arrangement&gt;</code> class-template, which maintains a mapping of vertex handles to indices, as required by the BGL. An instance of this class must be attached to a valid arrangement vertex when it is created. It uses the notification mechanism (see Section <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/index.html#arr_ssecnotif">The Notification Mechanism</a>) to automatically maintain the mapping of vertices to indices, even when new vertices are inserted into the arrangement or existing vertices are removed.</p>
<p>A complete description of the types correspondences can be found in the documentation of <a class="el" href="group__PkgBGLTraits.html#BGLArgtGT">boost::graph_traits </a>.</p>
<p>In most algorithm provided by the BGL, the output is given by <em>property maps</em>, such that each map entry corresponds to a vertex. For example, when we compute the shortest paths from a given source vertex \( s\) to all other vertices we can obtain a map of distances and a map of predecessors - namely for each \( v\) vertex we have its distance from \( s\) and a descriptor of the vertex that precedes \( v\) in the shortest path from \( s\). If the vertex descriptors are simply indices, one can use vectors to efficiently represent the property maps. As this is not the case with the arrangement graph, we offer the <code>Arr_vertex_property_map&lt;Arrangement,Type&gt;</code> template allows for an efficient mapping of <code>Vertex_handle</code> objects to properties of type <code>Type</code>. Note however that unlike the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__vertex__index__map.html">Arr_vertex_index_map</a></code> class, the vertex property-map class is not kept synchronized with the number of vertices in the arrangement, so it should not be reused in calls to the BGL functions in case the arrangement is modified in between these calls.</p>
<p><a class="anchor" id="fig__figex_bgl"></a></p><div class="image">
<img src="ex_bgl.png" alt="ex_bgl.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__figex_bgl">Figure 102.1</a> An arrangement of 7 line segments, as constructed by <code>bgl_primal_adapter.cpp</code> and <code>bgl_dual_adapter.cpp</code>. The breadth-first visit times for the arrangement faces, starting from the unbounded face \( f_0\), are shown in brackets.  </div> <br /> 
<p>In the following example we construct an arrangement of 7 line segments, as shown in <a class="el" href="index.html#fig__figex_bgl">Figure 102.1</a>, then use the BGL Dijkstra's shortest-paths algorithm to compute the graph distance of all vertices from the leftmost vertex in the arrangement \( v_0\). Note the usage of the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__vertex__index__map.html">Arr_vertex_index_map</a></code> and the <code>Arr_vertex_property_map</code> classes. The latter one, instantiated by the type <code>double</code> is used to map vertices to their distances from \( v_0\).</p>
<p><br />
<b>File</b> <a class="el" href="BGL_arrangement_2_2primal_8cpp-example.html">BGL_arrangement_2/primal.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Adapting an arrangement to a BGL graph.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_rational_nt.h"</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_segment_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/graph_traits_Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_vertex_index_map.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/dijkstra_shortest_paths.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;Number_type&gt;</a>                    Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__segment__traits__2.html">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</a>              Traits_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Point_2                               Point_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::X_monotone_curve_2                    Segment_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2&gt;</a>                   Arrangement_2;</div><div class="line"></div><div class="line"><span class="comment">// A functor used to compute the length of an edge.</span></div><div class="line"><span class="keyword">class </span>Edge_length_func</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">  <span class="comment">// Boost property type definitions:</span></div><div class="line">  <span class="keyword">typedef</span> boost::readable_property_map_tag        category;</div><div class="line">  <span class="keyword">typedef</span> <span class="keywordtype">double</span>                                  value_type;</div><div class="line">  <span class="keyword">typedef</span> value_type                              reference;</div><div class="line">  <span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#adf9ae7012e73ea8f327ab59515b00828">Arrangement_2::Halfedge_handle</a>          key_type;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> operator()(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#adf9ae7012e73ea8f327ab59515b00828">Arrangement_2::Halfedge_handle</a> e)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>     x1 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1f1bcd74fce34fd532445590bbda5cd5">CGAL::to_double</a> (e-&gt;source()-&gt;point().x());</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>     y1 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1f1bcd74fce34fd532445590bbda5cd5">CGAL::to_double</a> (e-&gt;source()-&gt;point().y());</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>     x2 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1f1bcd74fce34fd532445590bbda5cd5">CGAL::to_double</a> (e-&gt;target()-&gt;point().x());</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>     y2 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1f1bcd74fce34fd532445590bbda5cd5">CGAL::to_double</a> (e-&gt;target()-&gt;point().y());</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>     diff_x = x2 - x1;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>     diff_y = y2 - y1;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">std::sqrt</a>(diff_x*diff_x + diff_y*diff_y);</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> <span class="keyword">get</span>(<span class="keyword">const</span> Edge_length_func&amp; <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__measure__grp.html#gaaffc67e631d83a7da4b1096b782ead94">edge_length</a>, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#adf9ae7012e73ea8f327ab59515b00828">Arrangement_2::Halfedge_handle</a> e)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__measure__grp.html#gaaffc67e631d83a7da4b1096b782ead94">edge_length</a>(e);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Arrangement_2   arr;</div><div class="line"></div><div class="line">  <span class="comment">// Construct an arrangement of seven intersecting line segments.</span></div><div class="line">  <span class="comment">// We keep a handle for the vertex v_0 that corresponds to the point (1,1).</span></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#adf9ae7012e73ea8f327ab59515b00828">Arrangement_2::Halfedge_handle</a>  e =</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a> (arr, Segment_2 (Point_2 (1, 1),</div><div class="line">                                                   Point_2 (7, 1)));</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#a7cdc734c8b7109fe4f62b2467d05b5c3">Arrangement_2::Vertex_handle</a>    v0 = e-&gt;source();</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a> (arr, Segment_2 (Point_2 (1, 1), Point_2 (3, 7)));</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a> (arr, Segment_2 (Point_2 (1, 4), Point_2 (7, 1)));</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a> (arr, Segment_2 (Point_2 (2, 2), Point_2 (9, 3)));</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a> (arr, Segment_2 (Point_2 (2, 2), Point_2 (4, 4)));</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a> (arr, Segment_2 (Point_2 (7, 1), Point_2 (9, 3)));</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a> (arr, Segment_2 (Point_2 (3, 7), Point_2 (9, 3)));</div><div class="line"></div><div class="line">  <span class="comment">// Create a mapping of the arrangement vertices to indices.</span></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__vertex__index__map.html">CGAL::Arr_vertex_index_map&lt;Arrangement_2&gt;</a>        index_map(arr);</div><div class="line"></div><div class="line">  <span class="comment">// Perform Dijkstra's algorithm from the vertex v0.</span></div><div class="line">  Edge_length_func                                      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__measure__grp.html#gaaffc67e631d83a7da4b1096b782ead94">edge_length</a>;</div><div class="line"></div><div class="line">  boost::vector_property_map&lt;double, CGAL::Arr_vertex_index_map&lt;Arrangement_2&gt; &gt; dist_map(static_cast&lt;unsigned int&gt;(arr.number_of_vertices()), index_map);</div><div class="line">  boost::dijkstra_shortest_paths(arr, v0,</div><div class="line">                                 boost::vertex_index_map(index_map).</div><div class="line">                                 weight_map(edge_length).</div><div class="line">                                 distance_map(dist_map));</div><div class="line"></div><div class="line">  <span class="comment">// Print the results:</span></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#a658bc1f09608a7ba83e54309e56aa042">Arrangement_2::Vertex_iterator</a>      vit;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The distances of the arrangement vertices from ("</span></div><div class="line">            &lt;&lt; v0-&gt;point() &lt;&lt; <span class="stringliteral">") :"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (vit = arr.vertices_begin(); vit != arr.vertices_end(); ++vit)</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"("</span> &lt;&lt; vit-&gt;point() &lt;&lt; <span class="stringliteral">") at distance "</span></div><div class="line">              &lt;&lt; dist_map[vit] &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="arr_sssecbgl_dual"></a>
Example for the Dual of an Arrangement as Graph</h2>
<p>It is possible to give a dual graph representation for an arrangement instance, such that each arrangement face corresponds to a graph vertex and two vertices are adjacent iff the corresponding faces share a common edge on their boundaries. This is done by specializing the <code>boost::graph_traits</code> template for <code><a class="el" href="classCGAL_1_1Dual.html" title="The class template Dual is an adaptor that creates the dual view of a FaceGraph. ">Dual</a>&lt;<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&gt;</code> instances, where <code><a class="el" href="classCGAL_1_1Dual.html" title="The class template Dual is an adaptor that creates the dual view of a FaceGraph. ">Dual</a>&lt;<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&gt;</code> is a template specialization that gives a dual interpretation to an arrangement instance.</p>
<p>In dual representation, <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#afba61ea413272c8af10dcc4bdeb5ff63">Arrangement_2::Face_handle</a></code> is the graph-vertex type, while <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html#adf9ae7012e73ea8f327ab59515b00828">Arrangement_2::Halfedge_handle</a></code> is the graph-edge type. We treat the graph edges as directed, such that a halfedge <code>e</code> is directed from \( f_1\), which is its incident face, to \( f_2\), which is the incident face of its twin halfedge. As two arrangement faces may share more than a single edge on their boundary, we allow parallel edges in our <em>boost</em> graph. As is the case in the primal graph, the dual arrangement graph is also a model of the concepts <code><a class="el" href="classVertexListGraph.html" title="Concept from the Boost Graph Library. See https://www.boost.org/libs/graph/doc/VertexListGraph.html. ">VertexListGraph</a></code>, <code><a class="el" href="classEdgeListGraph.html" title="Concept from the Boost Graph Library. See https://www.boost.org/libs/graph/doc/EdgeListGraph.html. ">EdgeListGraph</a></code> and <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classBidirectionalGraph.html">BidirectionalGraph</a></code> (thus also of <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classIncidenceGraph.html">IncidenceGraph</a></code>).</p>
<p>Since we use <code>Face_handle</code> objects as the vertex descriptors, we define the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__face__index__map.html">Arr_face_index_map</a>&lt;Arrangement&gt;</code> class-template, which maintains an efficient mapping of face handles to indices. We also provide the template <code>Arr_face_property_map&lt;Arrangement,Type&gt;</code> for associating arbitrary data with the arrangement faces.</p>
<p>In the following example we construct the same arrangement as in example <code>ex_bgl_primal_adapter.cpp</code> (see <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/index.html#fig__aos_fig-bgl_primal_adapter">Figure 34.48</a>), and perform breadth-first search on the graph faces, starting from the unbounded face. We extend the DCEL faces with an unsigned integer, marking the discover time of the face and use a breadth-first-search visitor to obtain these times and update the faces accordingly:</p>
<p><br />
<b>File</b> <a class="el" href="BGL_arrangement_2_2arrangement_dual_8cpp-example.html">BGL_arrangement_2/arrangement_dual.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Adapting the dual of an arrangement to a BGL graph.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_rational_nt.h"</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_segment_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_extended_dcel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/graph_traits_dual_arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_face_index_map.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;climits&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/breadth_first_search.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/graph/visitors.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_print.h"</span></div><div class="line"></div><div class="line"><span class="comment">// A property map that reads/writes the information to/from the extended</span></div><div class="line"><span class="comment">// face.</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Arrangement, <span class="keyword">class</span> Type&gt;</div><div class="line"><span class="keyword">class </span>Extended_face_property_map {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Arrangement::Face_handle       Face_handle;</div><div class="line"></div><div class="line">  <span class="comment">// Boost property type definitions.</span></div><div class="line">  <span class="keyword">typedef</span> boost::read_write_property_map_tag      category;</div><div class="line">  <span class="keyword">typedef</span> Type                                    value_type;</div><div class="line">  <span class="keyword">typedef</span> value_type&amp;                             reference;</div><div class="line">  <span class="keyword">typedef</span> Face_handle                             key_type;</div><div class="line"></div><div class="line">  <span class="comment">// The get function is required by the property map concept.</span></div><div class="line">  <span class="keyword">friend</span> reference <span class="keyword">get</span>(<span class="keyword">const</span> Extended_face_property_map&amp;, key_type key)</div><div class="line">  { <span class="keywordflow">return</span> key-&gt;data(); }</div><div class="line"></div><div class="line">  <span class="comment">// The put function is required by the property map concept.</span></div><div class="line">  <span class="keyword">friend</span> <span class="keywordtype">void</span> put(<span class="keyword">const</span> Extended_face_property_map&amp;, key_type key, value_type val)</div><div class="line">  { key-&gt;set_data(val); }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;Number_type&gt;</a>                         Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__segment__traits__2.html">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</a>                   Traits_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__face__extended__dcel.html">CGAL::Arr_face_extended_dcel&lt;Traits_2, unsigned int&gt;</a> Dcel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2, Dcel&gt;</a>                  Ex_arrangement;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Dual.html">CGAL::Dual&lt;Ex_arrangement&gt;</a>                           Dual_arrangement;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/classCGAL_1_1Arr__face__index__map.html">CGAL::Arr_face_index_map&lt;Ex_arrangement&gt;</a>             Face_index_map;</div><div class="line"><span class="keyword">typedef</span> Extended_face_property_map&lt;Ex_arrangement,unsigned int&gt;</div><div class="line">                                                             Face_property_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>                                      Point_2;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Segment__2.html">Kernel::Segment_2</a>                                    Segment_2;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="comment">// Construct an arrangement of seven intersecting line segments.</span></div><div class="line">  Point_2 p1(1, 1), p2(1, 4), p3(2, 2), p4(3, 7), p5(4, 4), p6(7, 1), p7(9, 3);</div><div class="line">  Ex_arrangement  arr;</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a>(arr, Segment_2(p1, p6));</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a>(arr, Segment_2(p1, p4));  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a>(arr, Segment_2(p2, p6));</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a>(arr, Segment_2(p3, p7));  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a>(arr, Segment_2(p3, p5));</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a>(arr, Segment_2(p6, p7));  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Arrangement_on_surface_2.tag:../Arrangement_on_surface_2/" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2Insert.html#gab9fcd6cd172ef1c36d36f4693f2ec128">insert</a>(arr, Segment_2(p4, p7));</div><div class="line"></div><div class="line">  <span class="comment">// Create a mapping of the arrangement faces to indices.</span></div><div class="line">  Face_index_map  index_map(arr);</div><div class="line"></div><div class="line">  <span class="comment">// Perform breadth-first search from the unbounded face, using the event</span></div><div class="line">  <span class="comment">// visitor to associate each arrangement face with its discover time.</span></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    time = 0;</div><div class="line">  boost::breadth_first_search(Dual_arrangement(arr), arr.unbounded_face(),</div><div class="line">                              boost::vertex_index_map(index_map).visitor</div><div class="line">                              (boost::make_bfs_visitor</div><div class="line">                               (stamp_times(Face_property_map(), time,</div><div class="line">                                            boost::on_discover_vertex()))));</div><div class="line"></div><div class="line">  <span class="comment">// Print the discover time of each arrangement face.</span></div><div class="line">  Ex_arrangement::Face_iterator  fit;</div><div class="line">  <span class="keywordflow">for</span> (fit = arr.faces_begin(); fit != arr.faces_end(); ++fit) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Discover time "</span> &lt;&lt; fit-&gt;data() &lt;&lt; <span class="stringliteral">" for "</span>;</div><div class="line">    <span class="keywordflow">if</span> (fit != arr.unbounded_face()) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">"face "</span>;</div><div class="line">      print_ccb&lt;Ex_arrangement&gt;(fit-&gt;outer_ccb());</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> std::cout &lt;&lt; <span class="stringliteral">"the unbounded face."</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="BGLExtensions"></a>
Extensions of the BGL</h1>
<p>The previous sections introduced partial specializations and free functions so that several CGAL data structures are adapted as models of some of the BGL graph concepts. In this section, we introduce new concepts, iterators, and property maps inspired by the functionalities of the BGL.</p>
<h2><a class="anchor" id="BGLExtensionsGraphConcepts"></a>
Graph concepts</h2>
<p>In order to match <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgHalfedgeDS">Halfedge Data Structures</a> more closely and to enable writing generic algorithms which operate on data structures that have faces and halfedges, we define a set of new concepts to extend the <a href="https://www.boost.org/libs/graph/doc/graph_concepts.html">graph concepts of the BGL</a>:</p>
<ul>
<li><code><a class="el" href="classHalfedgeGraph.html" title="The concept HalfedgeGraph is a refinement of the BGL concept IncidenceGraph and adds the notion of a ...">HalfedgeGraph</a></code> refines <a href="https://www.boost.org/libs/graph/doc/Graph.html"><code>Graph</code></a> with operations to accommodate halfedge data structures: given a halfedge, say <code>h</code>, the concept <code><a class="el" href="classHalfedgeGraph.html" title="The concept HalfedgeGraph is a refinement of the BGL concept IncidenceGraph and adds the notion of a ...">HalfedgeGraph</a></code> requires the provision of the halfedge opposite to <code>h</code>, the halfedge that succeeds <code>h</code>, and the halfedge that precedes <code>h</code>.</li>
<li><code><a class="el" href="classHalfedgeListGraph.html" title="The concept HalfedgeListGraph refines the concept HalfedgeGraph and adds the requirements for travers...">HalfedgeListGraph</a></code> adds the requirement for efficient traversal of the halfedges of the graph.</li>
<li><code><a class="el" href="classMutableHalfedgeGraph.html" title="The concept MutableHalfedgeGraph refines the concept HalfedgeGraph and adds the requirements for oper...">MutableHalfedgeGraph</a></code> adds the requirement for operations to change next/previous relations and to adjust the target of a halfedge.</li>
<li><code><a class="el" href="classFaceGraph.html" title="The concept FaceGraph refines the concept HalfedgeGraph. It adds the requirements for a graph to expl...">FaceGraph</a></code> adds the requirements to explicitly handle faces in a graph, to provide quick access to the incident halfedges of a face, and to enable access from every halfedge to an adjacent face.</li>
<li><code><a class="el" href="classFaceListGraph.html" title="The concept FaceListGraph refines the concept FaceGraph and adds the requirement for traversal of all...">FaceListGraph</a></code> adds the requirement for efficient traversal of the faces of a graph.</li>
<li><code><a class="el" href="classMutableFaceGraph.html" title="The concept MutableFaceGraph refines the concepts FaceGraph and MutableHalfedgeGraph and adds the req...">MutableFaceGraph</a></code> adds requirements to change adjacency of faces and halfedges, and to remove and add faces.</li>
</ul>
<p>A summary of the expressions and types associated with each of these concepts as well as a refinement relation graph can be found in the <a class="el" href="group__PkgBGLConcepts.html">Concepts</a> documentation page.</p>
<h2><a class="anchor" id="BGLIteratorsAndCirculators"></a>
Iterators and Circulators</h2>
<p>By combining basic operations on graphs, we create various useful <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/devman_iterators_and_circulators.html">iterators and circulators</a> to traverse specific types of elements. For example:</p>
<ul>
<li>Starting at a halfedge <code>h</code> of a halfedge graph <code>g</code>, applying several times <code>next(h,g)</code> brings us back to the halfedge where we started. All halfedges traversed on the way are incident to the same face.</li>
<li>Using the composition of the functions <code>next(h,g)</code> and <code>opposite(h,g)</code> results in another cycle, namely the cycle of halfedges which are incident to the same vertex.</li>
</ul>
<p>A complete list of these traversal tools can be found in <a class="el" href="group__PkgBGLIterators.html">the reference manual</a>.</p>
<p>For convenience, two iterator and circulator types enable the traversal of all halfedges incident to a given face, and all halfedges having a given vertex as target. These types are not part of the concept <code><a class="el" href="classHalfedgeGraph.html" title="The concept HalfedgeGraph is a refinement of the BGL concept IncidenceGraph and adds the notion of a ...">HalfedgeGraph</a></code>, but they are class templates that work for any model of this concept.</p>
<h3><a class="anchor" id="BGLExampleIncidentVertices"></a>
Example: Finding Incident Vertices in a HalfedgeGraph</h3>
<p>The following example shows several functions to navigate in a <code><a class="el" href="classHalfedgeGraph.html" title="The concept HalfedgeGraph is a refinement of the BGL concept IncidenceGraph and adds the notion of a ...">HalfedgeGraph</a></code>. We have two implementations of the operation that finds the vertices adjacent to a vertex <code>v</code>.</p>
<p>Let us have a look at the first version. Given a vertex descriptor <code>vd</code>, we first call <code>halfedge(vd,g)</code> to obtain the halfedge with <code>vd</code> as target. Applying <code><a class="el" href="classEdgeListGraph.html#a8623c30b1f1b0fda831343463aaca433">source()</a></code> then gives us an adjacent vertex. We then get to the next halfedge with <code>vd</code> as target, by first going to the next halfedge around the face, and then going to the opposite halfedge.</p>
<p>The second version does the <code>next()</code> and <code>opposite()</code> jumping with an iterator. Note that when calling <code><a class="el" href="classEdgeListGraph.html#a8623c30b1f1b0fda831343463aaca433">source()</a></code> we have to dereference <code>hi</code>, as the function expects a halfedge descriptor and not a halfedge iterator. Also observe that <code><a class="el" href="group__PkgBGLIterators.html#ga2be4fd4d24b1e48e00a92f90f0f2923c" title="returns an iterator range over all halfedges with vertex target(h,g) as target. ">halfedges_around_target()</a></code> expects a halfedge, and not a vertex. This provides the user with the ability to start the traversal at a specific halfedge incident to the input vertex (and not the arbitrary incident halfedge stored in the vertex record.)</p>
<p><br />
<b>File</b> <a class="el" href="BGL_polyhedron_3_2incident_vertices_8cpp-example.html">BGL_polyhedron_3/incident_vertices.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/iterator.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;Kernel&gt;</a>     Polyhedron;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Polyhedron&gt; GraphTraits;</div><div class="line"><span class="keyword">typedef</span> GraphTraits::vertex_descriptor vertex_descriptor;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Halfedge__around__target__iterator.html">CGAL::Halfedge_around_target_iterator&lt;Polyhedron&gt;</a> halfedge_around_target_iterator;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> OutputIterator&gt;</div><div class="line"><a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classOutputIterator.html">OutputIterator</a></div><div class="line">adjacent_vertices_V1(<span class="keyword">const</span> Polyhedron&amp; g,</div><div class="line">                     vertex_descriptor vd,</div><div class="line">                     <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classOutputIterator.html">OutputIterator</a> out)</div><div class="line">{</div><div class="line">  <span class="keyword">typename</span> GraphTraits::halfedge_descriptor hb = halfedge(vd,g), done(hb);</div><div class="line">  <span class="keywordflow">do</span> {</div><div class="line">        *out++ = source(hb,g);</div><div class="line">        hb = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gad0a8110cb95f76bac65649bfe58c650b">opposite</a>(next(hb,g),g);</div><div class="line">  } <span class="keywordflow">while</span>(hb!= done);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> out;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> OutputIterator&gt;</div><div class="line"><a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classOutputIterator.html">OutputIterator</a></div><div class="line">adjacent_vertices_V2(<span class="keyword">const</span> Polyhedron&amp; g,</div><div class="line">                     vertex_descriptor vd,</div><div class="line">                     <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classOutputIterator.html">OutputIterator</a> out)</div><div class="line">{</div><div class="line">  halfedge_around_target_iterator hi, he;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(boost::tie(hi, he) = <a class="code" href="group__PkgBGLIterators.html#ga2be4fd4d24b1e48e00a92f90f0f2923c">halfedges_around_target</a>(halfedge(vd,g),g); hi != he; ++hi)</div><div class="line">  {</div><div class="line">    *out++ = source(*hi,g);</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> out;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::ifstream in((argc&gt;1)?argv[1]:<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/cube_poly.off"</span>));</div><div class="line">  Polyhedron P;</div><div class="line">  in &gt;&gt; P;</div><div class="line">  GraphTraits::vertex_iterator vi = vertices(P).first;</div><div class="line">  std::list&lt;vertex_descriptor&gt; V;</div><div class="line">  adjacent_vertices_V1(P, *vi, std::back_inserter(V));</div><div class="line">  ++vi;</div><div class="line">  adjacent_vertices_V2(P, *vi, std::back_inserter(V));</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"done\n"</span>;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="BGLExampleNormalHalfedgeGraph"></a>
Example: Calculating Facet Normals using HalfedgeGraph</h3>
<p>The following example program shows a simple algorithm for calculating facet normals for a polyhedron using the BGL API. A <a href="https://www.boost.org/libs/property_map/doc/vector_property_map.html">boost::vector_property_map</a> is used to to store the calculated normals instead of changing the Polyhedron items class.</p>
<p><br />
<b>File</b> <a class="el" href="BGL_polyhedron_3_2normals_8cpp-example.html">BGL_polyhedron_3/normals.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/graph/graph_traits.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_items_with_id_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>                               Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                                              Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a>                                             Vector;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;Kernel, CGAL::Polyhedron_items_with_id_3&gt;</a> Polyhedron;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <a class="code" href="classHalfedgeGraph.html">HalfedgeGraph</a>,</div><div class="line">         <span class="keyword">typename</span> PointMap,</div><div class="line">         <span class="keyword">typename</span> NormalMap&gt;</div><div class="line"><span class="keywordtype">void</span> calculate_face_normals(<span class="keyword">const</span> <a class="code" href="classHalfedgeGraph.html">HalfedgeGraph</a>&amp; g,</div><div class="line">                            PointMap pm,</div><div class="line">                            NormalMap nm)</div><div class="line">{</div><div class="line">  <span class="keyword">typedef</span> boost::graph_traits&lt;HalfedgeGraph&gt; GraphTraits;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> GraphTraits::face_iterator face_iterator;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> GraphTraits::halfedge_descriptor halfedge_descriptor;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::property_traits&lt;PointMap&gt;::value_type point;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::property_traits&lt;NormalMap&gt;::value_type <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__normal__grp.html#ga49a712e57564602ad468a3888784e971">normal</a>;</div><div class="line"></div><div class="line">  face_iterator fb, fe;</div><div class="line">  <span class="keywordflow">for</span>(boost::tie(fb, fe) = faces(g); fb != fe; ++fb)</div><div class="line">  {</div><div class="line">    halfedge_descriptor edg = halfedge(*fb, g);</div><div class="line">    halfedge_descriptor edgb = edg;</div><div class="line"></div><div class="line">    point p0 = pm[target(edg, g)];</div><div class="line">    edg = next(edg, g);</div><div class="line">    point p1 = pm[target(edg, g)];</div><div class="line">    edg = next(edg, g);</div><div class="line">    point p2 = pm[target(edg, g)];</div><div class="line">    edg = next(edg, g);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(edg == edgb) {</div><div class="line">      <span class="comment">// triangle</span></div><div class="line">      nm[*fb] = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__unit__normal__grp.html#gaeb8231145ba0cdde8e28fc4f983f23ef">CGAL::unit_normal</a>(p1, p2, p0);</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">      <span class="comment">// not a triangle</span></div><div class="line">      normal n(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga4a98ec6bd9dfd8fe8c46fea553b5d238">CGAL::NULL_VECTOR</a>);</div><div class="line"></div><div class="line">      <span class="keywordflow">do</span> {</div><div class="line">        n = n + <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__normal__grp.html#ga49a712e57564602ad468a3888784e971">CGAL::normal</a>(p1, p2, p0);</div><div class="line">        p0 = p1;</div><div class="line">        p1 = p2;</div><div class="line"></div><div class="line">        edg = next(edg, g);</div><div class="line">        p2 = pm[target(edg, g)];</div><div class="line">      } <span class="keywordflow">while</span>(edg != edgb);</div><div class="line"></div><div class="line">      nm[*fb] = n / <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">CGAL::sqrt</a>(n.squared_length());</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">typedef</span> boost::property_map&lt;</div><div class="line">    Polyhedron,</div><div class="line">    <a class="code" href="group__PkgBGLProperties.html#ga4d8b2f143dbc2547a5a307f76a48f8e0">CGAL::face_index_t</a></div><div class="line">    &gt;::const_type Face_index_map;</div><div class="line"></div><div class="line">  std::ifstream in((argc&gt;1)?argv[1]:<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/cube_poly.off"</span>));</div><div class="line">  Polyhedron P;</div><div class="line">  in &gt;&gt; P ;</div><div class="line"></div><div class="line">  <span class="comment">// initialize facet indices</span></div><div class="line">  std::size_t i = 0;</div><div class="line">  <span class="keywordflow">for</span>(Polyhedron::Facet_iterator it = P.facets_begin(); it != P.facets_end(); ++it, ++i)</div><div class="line">  {</div><div class="line">    it-&gt;id() = i;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Ad hoc property_map to store normals. Face_index_map is used to</span></div><div class="line">  <span class="comment">// map face_descriptors to a contiguous range of indices. See</span></div><div class="line">  <span class="comment">// http://www.boost.org/libs/property_map/doc/vector_property_map.html</span></div><div class="line">  <span class="comment">// for details.</span></div><div class="line">  boost::vector_property_map&lt;Vector, Face_index_map&gt;</div><div class="line">    normals(static_cast&lt;unsigned&gt;(num_faces(P)), <span class="keyword">get</span>(CGAL::face_index, P));</div><div class="line"></div><div class="line">  calculate_face_normals(</div><div class="line">    P <span class="comment">// Graph</span></div><div class="line">    , <span class="keyword">get</span>(CGAL::vertex_point, P) <span class="comment">// map from vertex_descriptor to point</span></div><div class="line">    , normals <span class="comment">// map from face_descriptor to Vector_3</span></div><div class="line">    );</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Normals"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span>(Polyhedron::Facet_iterator it = P.facets_begin(); it != P.facets_end(); ++it) {</div><div class="line">    <span class="comment">// Facet_iterator is a face_descriptor, so we can use it as the</span></div><div class="line">    <span class="comment">// key here</span></div><div class="line">    std::cout &lt;&lt; normals[it] &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="BGLProperties"></a>
Properties and Dynamic Properties</h2>
<p>As the concepts <code><a class="el" href="classHalfedgeGraph.html" title="The concept HalfedgeGraph is a refinement of the BGL concept IncidenceGraph and adds the notion of a ...">HalfedgeGraph</a></code> and <code><a class="el" href="classFaceGraph.html" title="The concept FaceGraph refines the concept HalfedgeGraph. It adds the requirements for a graph to expl...">FaceGraph</a></code> add the notion of halfedges and faces, as well as a geometric embedding of the vertices, we have to add property tags such as <code>face_index_t</code> and <code>vertex_point_t</code>.</p>
<p>We further add <em>dynamic properties</em> that enable the user to add properties to vertices, halfedges, edges, and faces on the fly. The lifetime of a dynamic property is bound to the lifetime of the property map: reference counting is used to delete the property when no map refers to it.</p>
<p>Dynamic property tags, such as <code><a class="el" href="structCGAL_1_1dynamic__vertex__property__t.html" title="Dynamic vertex property tag. ">dynamic_vertex_property_t</a></code>, are a generalization of <code>boost::vertex_index_t</code>, as they have a template parameter for the value type of the dynamic property map, and a default value. <code>boost::property_map&lt;G,T&gt;::type</code> is used to obtain the type of the dynamic property map for a graph of type <code>G</code>, for a dynamic property tag <code>T</code>. This type must be default constructible and assignable. As for ordinary properties, the function <code>get()</code> is overloaded and serves for retrieving a property map for a given graph and dynamic property tag, as well as for retrieving a value for a given key and property map.</p>
<p>The following example shows how to attach a <code>string</code> property to vertices and a <code>double</code> value to the halfedges of a graph.</p>
<p><br />
<b>File</b> <a class="el" href="Property_map_2dynamic_properties_8cpp-example.html">Property_map/dynamic_properties.cpp</a> </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> K;</div><div class="line"><span class="keyword">typedef</span> K::Point_3 Point_3;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point_3&gt;</a> Mesh;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  Mesh mesh;</div><div class="line">  <a class="code" href="group__PkgBGLHelperFct.html#ga81ac0b6fbedf7889e0164aec540bd112">CGAL::make_triangle</a>(Point_3(0,0,0),Point_3(1,0,0),Point_3(1,1,0), mesh);</div><div class="line"></div><div class="line">  <span class="keyword">typedef</span> boost::property_map&lt;Mesh, CGAL::dynamic_vertex_property_t&lt;std::string&gt; &gt;::type VertexNameMap;</div><div class="line">  VertexNameMap vnm  = <span class="keyword">get</span>(<a class="code" href="structCGAL_1_1dynamic__vertex__property__t.html">CGAL::dynamic_vertex_property_t&lt;std::string&gt;</a>(), mesh);</div><div class="line">  put(vnm, *(vertices(mesh).first), <span class="stringliteral">"Paris"</span>);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="keyword">get</span>(vnm, *(vertices(mesh).first)) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keyword">typedef</span> boost::property_map&lt;Mesh, CGAL::dynamic_halfedge_property_t&lt;double&gt; &gt;::type TrafficDensityMap;</div><div class="line">  TrafficDensityMap tdm = <span class="keyword">get</span>(<a class="code" href="structCGAL_1_1dynamic__halfedge__property__t.html">CGAL::dynamic_halfedge_property_t&lt;double&gt;</a>(), mesh);</div><div class="line">  put(tdm, *(halfedges(mesh).first), 0.7);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="keyword">get</span>(tdm, *(halfedges(mesh).first)) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h2><a class="anchor" id="BGLGraphIO"></a>
Graph I/O</h2>
<p>Using a common graph concept enables having common input/output functions for all the models of this concept. The following file formats are supported for models of <code><a class="el" href="classFaceGraph.html" title="The concept FaceGraph refines the concept HalfedgeGraph. It adds the requirements for a graph to expl...">FaceGraph</a></code>:</p><ul>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/IOStreamSupportedFileFormats.html#IOStreamOFF">Object File Format (OFF)</a> (<code>.off</code>)</li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/IOStreamSupportedFileFormats.html#IOStreamOBJ">Wavefront Advanced Visualizer Object Format (OBJ)</a> (<code>.obj</code>)</li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/IOStreamSupportedFileFormats.html#IOStreamSTL">STereoLithography (STL) File Format</a> (<code>.stl</code>)</li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/IOStreamSupportedFileFormats.html#IOStreamPLY">Polygon File Format (PLY)</a> (<code>.ply</code>)</li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/IOStreamSupportedFileFormats.html#IOStreamGocad">GOCAD (TS) File Format</a> (<code>.ts</code>)</li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/IOStreamSupportedFileFormats.html#IOStreamVTK">VTK (VTU / VTP) File Formats</a> (<code>.vtp</code>)</li>
</ul>
<p>See the page <a class="el" href="group__PkgBGLIOFct.html">I/O Functions</a> for an exhaustive description of the I/O functions of this package.</p>
<h1><a class="anchor" id="BGLEulerOperations"></a>
Euler Operations</h1>
<p>There are two categories of mutating operations. The first category comprises low level operations that change incidences such as the target vertex of a halfedge. A halfedge graph might turn invalid by the application of inconsistent low lever operations. The second category of operations are called <em>Euler Operations</em>. These are high level operations such as adding a center vertex to a face, which means also adding halfedges and faces, and updating incidence information. The Euler operations enable manipulating models of <code><a class="el" href="classMutableFaceGraph.html" title="The concept MutableFaceGraph refines the concepts FaceGraph and MutableHalfedgeGraph and adds the req...">MutableFaceGraph</a></code>.</p>
<p>The complete list of Euler operations provided by this package can be found in <a class="el" href="group__PkgBGLEulerOperations.html">the reference manual</a>.</p>
<h1><a class="anchor" id="BGLGraphAdaptors"></a>
Graph Adaptors</h1>
<p>Graph adaptors are classes that build an interface over an existing graph to provide new functionalities. By operating almost entirely on the input graph, adaptors can avoid potentially expensive operations, both in term of time and memory.</p>
<h2><a class="anchor" id="BGLDual"></a>
The Dual Graph</h2>
<p>The <em>dual graph</em> of a <code><a class="el" href="classFaceGraph.html" title="The concept FaceGraph refines the concept HalfedgeGraph. It adds the requirements for a graph to expl...">FaceGraph</a></code> <code>G</code> is a graph that has a vertex for each face of <code>G</code>. The dual graph has an edge whenever two faces of <code>G</code> are separated from each other by an edge. Thus, each edge <code>e</code> of <code>G</code> has a corresponding dual edge, the edge that connects the two faces on either side of <code>e</code>. Computing the dual graph of a graph has many uses, for example when one wishes to compute the connected components of a mesh.</p>
<p>The class template <code><a class="el" href="classCGAL_1_1Dual.html" title="The class template Dual is an adaptor that creates the dual view of a FaceGraph. ">Dual</a></code> is an adaptor that creates the dual view of a <code><a class="el" href="classFaceGraph.html" title="The concept FaceGraph refines the concept HalfedgeGraph. It adds the requirements for a graph to expl...">FaceGraph</a></code>. Faces of the original graph correspond to vertices in the <code><a class="el" href="classCGAL_1_1Dual.html" title="The class template Dual is an adaptor that creates the dual view of a FaceGraph. ">Dual</a></code> and vice versa.</p>
<p>Note that border edges in a <code><a class="el" href="classCGAL_1_1Dual.html" title="The class template Dual is an adaptor that creates the dual view of a FaceGraph. ">Dual</a></code> have the <code>null_face</code> of the original graph as either source or target. This is unusual and might break other algorithms since edges are always assumed to have non-null vertices as a source and target. It is nevertheless possible to filter border edges using <a href="https://www.boost.org/libs/graph/doc/filtered_graph.html">boost::filtered_graph</a>, as shown in the following example.</p>
<p><br />
<b>File</b> <a class="el" href="BGL_surface_mesh_2surface_mesh_dual_8cpp-example.html">BGL_surface_mesh/surface_mesh_dual.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/Dual.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/helpers.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/graph/filtered_graph.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/graph/connected_components.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>             Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                            Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point&gt;</a>                  Mesh;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Dual.html">CGAL::Dual&lt;Mesh&gt;</a>                           Dual;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Dual&gt;::edge_descriptor edge_descriptor;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> G&gt;</div><div class="line"><span class="keyword">struct </span>noborder {</div><div class="line">  noborder() : g(nullptr) {} <span class="comment">// default-constructor required by filtered_graph</span></div><div class="line">  noborder(G&amp; g) : g(&amp;g) {}</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> edge_descriptor&amp; e)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{ <span class="keywordflow">return</span> !<a class="code" href="group__PkgBGLHelperFct.html#gad93e429ad24efeaddeb836c437e719ab">is_border</a>(e,*g); }</div><div class="line"></div><div class="line">  G* g;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// A dual border edge has a null_face as the source or target "vertex"</span></div><div class="line"><span class="comment">// BGL algorithms won't like that, so we remove border edges through a</span></div><div class="line"><span class="comment">// boost::filtered_graph.</span></div><div class="line"><span class="keyword">typedef</span> boost::filtered_graph&lt;Dual, noborder&lt;Mesh&gt; &gt;   FiniteDual;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::vertex_descriptor   vertex_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::face_descriptor     face_descriptor;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::edge_descriptor     edge_descriptor;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/prim.off"</span>);</div><div class="line"></div><div class="line">  Mesh primal;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__IO__grp.html#gac5b3295bd1b6375628a46d1fbaf7e881">CGAL::IO::read_polygon_mesh</a>(filename, primal))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line">  Dual dual(primal);</div><div class="line">  FiniteDual finite_dual(dual,noborder&lt;Mesh&gt;(primal));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"dual has "</span> &lt;&lt; num_vertices(dual) &lt;&lt; <span class="stringliteral">" vertices"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The vertices of dual are faces in primal"</span>&lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span>(boost::graph_traits&lt;Dual&gt;::vertex_descriptor dvd : vertices(dual)) {</div><div class="line">    std::cout &lt;&lt; dvd &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The edges in primal and dual with source and target"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span>(edge_descriptor e : edges(dual)) {</div><div class="line">   std::cout &lt;&lt; e &lt;&lt; <span class="stringliteral">" in primal:  "</span> &lt;&lt; source(e,primal)      &lt;&lt; <span class="stringliteral">" -- "</span> &lt;&lt; target(e,primal)       &lt;&lt; <span class="stringliteral">"   "</span></div><div class="line">             &lt;&lt;      <span class="stringliteral">" in dual  :  "</span> &lt;&lt; source(e,finite_dual) &lt;&lt; <span class="stringliteral">" -- "</span> &lt;&lt; target(e,finite_dual)  &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"> std::cout &lt;&lt; <span class="stringliteral">"edges of the finite dual graph"</span> &lt;&lt; std::endl;</div><div class="line"> <span class="keywordflow">for</span>(boost::graph_traits&lt;FiniteDual&gt;::edge_descriptor e : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL.html#a266177f3e138c748f9906f7abb76320b">CGAL::make_range</a>(edges(finite_dual))) {</div><div class="line">   std::cout &lt;&lt; e &lt;&lt; <span class="stringliteral">"  "</span> &lt;&lt; source(e,primal) &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; source(e,finite_dual)  &lt;&lt; std::endl;</div><div class="line"> }</div><div class="line"></div><div class="line"> <span class="comment">// the storage of a property map is in primal</span></div><div class="line"> Mesh::Property_map&lt;face_descriptor,int&gt; fccmap;</div><div class="line"> fccmap = primal.add_property_map&lt;face_descriptor,<span class="keywordtype">int</span>&gt;(<span class="stringliteral">"f:CC"</span>).first;</div><div class="line"> <span class="keywordtype">int</span> num = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__keep__connected__components__grp.html#ga4b265482ec76e147764f0ca64a90b55d">connected_components</a>(finite_dual, fccmap);</div><div class="line"></div><div class="line"> std::cout &lt;&lt; <span class="stringliteral">"The graph has "</span> &lt;&lt; num &lt;&lt; <span class="stringliteral">" connected components (face connectivity)"</span> &lt;&lt; std::endl;</div><div class="line"> <span class="keywordflow">for</span>(face_descriptor f : faces(primal)) {</div><div class="line">   std::cout &lt;&lt; f &lt;&lt; <span class="stringliteral">" in connected component "</span> &lt;&lt; fccmap[f] &lt;&lt; std::endl;</div><div class="line"> }</div><div class="line"></div><div class="line"> Mesh::Property_map&lt;vertex_descriptor,int&gt; vccmap;</div><div class="line"> vccmap = primal.add_property_map&lt;vertex_descriptor,<span class="keywordtype">int</span>&gt;(<span class="stringliteral">"v:CC"</span>).first;</div><div class="line"> num = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__keep__connected__components__grp.html#ga4b265482ec76e147764f0ca64a90b55d">connected_components</a>(primal, vccmap);</div><div class="line"></div><div class="line"> std::cout &lt;&lt; <span class="stringliteral">"The graph has "</span> &lt;&lt; num &lt;&lt; <span class="stringliteral">" connected components (edge connectvity)"</span> &lt;&lt; std::endl;</div><div class="line"> <span class="keywordflow">for</span>(vertex_descriptor v : vertices(primal)) {</div><div class="line">   std::cout &lt;&lt; v &lt;&lt; <span class="stringliteral">" in connected component "</span> &lt;&lt; vccmap[v] &lt;&lt; std::endl;</div><div class="line"> }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="BGLSeamMesh"></a>
The Seam Mesh</h2>
<p>The class <code><a class="el" href="classCGAL_1_1Seam__mesh.html" title="This class is a data structure that takes a triangle mesh, further refered to as underlying mesh and ...">Seam_mesh</a></code> allows to mark edges of a mesh as <em>seam edges</em> so that they <em>virtually</em> become border edges when exploring a seam mesh with the BGL API. The input mesh is referred to as <em>underlying</em> mesh of the seam mesh. We denote <code>tm</code> and <code>sm</code> the underlying mesh and the seam mesh respectively.</p>
<p>Figure <a class="el" href="index.html#fig__fig_Seam_mesh_1">Figure 102.2</a> shows an example of mesh on which two edges, defined by the halfedge pairs <code>h2-h3</code> and <code>h6-h7</code>, are marked as seams. The introduction of virtual borders modifies the elementary BGL graph traversal operations: when we circulate around the target of <code>h7</code> in the underlying mesh, we traverse <code>h7</code>, <code>h1</code>, <code>h3</code>, <code>h5</code>, before arriving at <code>h7</code> again. However, when we circulate in the seam mesh, we traverse <code>h7</code>, <code>h1</code>, <code>h3*</code>, before arriving at <code>h7</code> again. Similarly, if we start at <code>h3</code>, we traverse <code>h3</code>, <code>h5</code>, <code>h7*</code>, and <code>h3</code> again.</p>
<p><a class="anchor" id="fig__fig_Seam_mesh_1"></a></p><div class="image">
<object type="image/svg+xml" data="seam_mesh_1.svg">seam_mesh_1.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__fig_Seam_mesh_1">Figure 102.2</a> A seam mesh with two seam edges <code>(h2, h3)</code> and <code>(h6, h7)</code>.  </div> <br /> 
<p>A vertex of the underlying mesh may correspond to multiple vertices in the seam mesh. For example in Figure <a class="el" href="index.html#fig__fig_Seam_mesh_1">Figure 102.2</a>, the target of <code>h7</code> corresponds to two vertices in the seam mesh, on either side of the virtual border created by the seam edges. For this reason, a vertex <code>v</code> of the seam mesh is internally represented as a halfedge <code>h</code> of the seam mesh. To obtain a canonical definition, the halfedge <code>h</code> is defined as the halfedge that has <code>v</code> as target, that lies on the seam, and that is not a border halfedge. The function <code>target(hd, sm)</code> will return this halfedge. For vertices <code>v</code> in the underlying mesh that are not on a seam edge, we choose <code>halfedge(v, tm)</code> as its canonical halfedge.</p>
<h3><a class="anchor" id="BGLSeamMeshTraversal"></a>
Seam Mesh Traversal</h3>
<p>Using the function <code>next(halfedge_descriptor, FaceGraph)</code>, we can walk around a face but also around a border of a mesh. For the seam mesh <code>sm</code> from Figure <a class="el" href="index.html#fig__fig_Seam_mesh_1">Figure 102.2</a>, we have <code>opposite(h2, sm) == h3*</code>, and it holds that <code>face(h3*, sm) == null_face()</code>. We can walk along this virtual border: starting at <code>h3*</code> and repeatedly calling <code>next(..,sm)</code>, we will traverse <code>h6*</code>, <code>h7*</code>, <code>h2*</code>, before reaching <code>h3*</code> again.</p>
<p>All other traversal functions, iterators, and circulators (see <a class="el" href="group__PkgBGLIterators.html">Iterators and Circulators</a>) can be used on a seam mesh, but their behavior is similarly modified by the (virtual and real) border edges of the seam mesh.</p>
<h3><a class="anchor" id="BGLSeamMeshNature"></a>
Seams</h3>
<p>A collection of seam edges, or simply a <em>seam</em>, is not necessarily a simple polyline as we can see in the next figure: </p><ul>
<li>
In <em>(a)</em>, the seam forms a tree. Consequently, we pass at a vertex as often as there are incident seam edges. </li>
<li>
In <em>(b)</em>, the seam has a vertex <code>v</code> on the border of the underlying mesh. While walking along the border of the seam mesh, we leave the border of the underlying mesh when we reach <code>v</code> and walk on a virtual border until we reach <code>v</code> again, from the other side of the seam. </li>
<li>
In <em>(c)</em>, the seam forms a closed polyline. While the first two define a single border, a cycle defines two borders and splits the set of faces in two connected components. Something similar happens when the seam touches the same border more than once. A seam can also connect different borders, potentially changing the genus of the mesh. Finally, a seam may have more than one connected component. </li>
</ul>
<p><a class="anchor" id="fig__fig_Seam_mesh_2"></a></p><div class="image">
<object type="image/svg+xml" data="seam_mesh_2.svg">seam_mesh_2.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__fig_Seam_mesh_2">Figure 102.3</a> Walking around a seam <em>(a)</em> with no seam vertex on the real border, <em>(b)</em> with a seam vertex on the real border, <em>(c)</em> with a closed polyline. Vertices of the seam mesh that are linked by a green dashed segment correspond to the same vertex in the underlying mesh.  </div> <br /> 
<p>Seam meshes are for example used in Chapter <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceMeshParameterization">Triangulated Surface Mesh Parameterization</a> to parameterize a topological sphere by first virtually cutting it into a topological disk.</p>
<h2><a class="anchor" id="BGLInheriting"></a>
Inheriting from a Model of a Face Graph Concept</h2>
<p>In order for a type <code>FG</code> to be a model of one of the face graph concepts, a specialization of <code>boost::graph_traits&lt;FG&gt;</code> must exist. When you derive a class from <code>FG</code> this graph traits class specialization does not match. For such cases, a header file consuming some user defined macros is provided to make the derived class a valid model of the same concept. See <code><a class="el" href="graph__traits__inheritance__macros_8h.html" title="Convenience header file defining the necessary specializations and overloads to make a class...">CGAL/boost/graph/graph_traits_inheritance_macros.h</a></code> for more details.</p>
<h1><a class="anchor" id="BGLPartitioning"></a>
Graph Partitioning</h1>
<p>For algorithms that operate locally, partitioning is often an easy way to parallelize the algorithm at little cost. The functions <code><a class="el" href="group__PkgBGLPartition.html#gaedf2c722ed8baf7d9b4df4cf0e9b86b5" title="computes a partition of the input triangular mesh into nparts parts, based on the mesh's nodal graph...">CGAL::METIS::partition_graph()</a></code> and <code><a class="el" href="group__PkgBGLPartition.html#gad72efc6b61c92ee8704858dc0b7062e9" title="computes a partition of the input triangular mesh into nparts parts, based on the mesh's dual graph...">CGAL::METIS::partition_dual_graph()</a></code> provide wrappers to the graph partitioning library METIS <a class="el" href="citelist.html#CITEREF_karypis1998fast">[3]</a>, allowing to split triangular meshes that are models of the concept <code><a class="el" href="classFaceListGraph.html" title="The concept FaceListGraph refines the concept FaceGraph and adds the requirement for traversal of all...">FaceListGraph</a></code> into a given number of subdomains.</p>
<p>The following example shows how to read, partition, and write a mesh using <code><a class="el" href="group__PkgBGLPartition.html#gad72efc6b61c92ee8704858dc0b7062e9" title="computes a partition of the input triangular mesh into nparts parts, based on the mesh's dual graph...">partition_dual_graph()</a></code>. The class template <code><a class="el" href="structCGAL_1_1Face__filtered__graph.html" title="The class Face_filtered_graph is an adaptor that creates a filtered view of a graph by restricting it...">CGAL::Face_filtered_graph</a></code> and the free function <code><a class="el" href="group__PkgBGLHelperFct.html#ga2682fb7d5f4ff4eb65607ae4118e31bc" title="copies a source model of FaceListGraph into a target model of a FaceListGraph. ">copy_face_graph()</a></code> are used to create an independent mesh from one of the subdomains of the partition. Note that the copy is optional as writing can be done directly using <code><a class="el" href="structCGAL_1_1Face__filtered__graph.html" title="The class Face_filtered_graph is an adaptor that creates a filtered view of a graph by restricting it...">Face_filtered_graph</a></code>.</p>
<p><br />
<b>File</b> <a class="el" href="BGL_surface_mesh_2surface_mesh_partition_8cpp-example.html">BGL_surface_mesh/surface_mesh_partition.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/Face_filtered_graph.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="partition_8h.html">CGAL/boost/graph/partition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/polygon_mesh_io.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>                           K;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;K::Point_3&gt;</a>                           SM;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string filename = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/blobby.off"</span>);</div><div class="line">  <span class="keywordtype">int</span> number_of_parts = (argc&gt;2) ? atoi(argv[2]) : 8;</div><div class="line"></div><div class="line">  SM sm;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__IO__grp.html#gac5b3295bd1b6375628a46d1fbaf7e881">CGAL::IO::read_polygon_mesh</a>(filename, sm))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// The vertex &lt;--&gt; partition_id property map</span></div><div class="line">  <span class="keyword">typedef</span> SM::Property_map&lt;SM::Vertex_index, std::size_t&gt;          Vertex_id_map;</div><div class="line">  Vertex_id_map vertex_pid_map = sm.add_property_map&lt;SM::Vertex_index, std::size_t&gt;(<span class="stringliteral">"v:pid"</span>).first;</div><div class="line"></div><div class="line">  <span class="comment">// The face &lt;--&gt; partition_id property map</span></div><div class="line">  <span class="keyword">typedef</span> SM::Property_map&lt;SM::Face_index, std::size_t&gt;            Face_id_map;</div><div class="line">  Face_id_map face_pid_map = sm.add_property_map&lt;SM::Face_index, std::size_t&gt;(<span class="stringliteral">"f:pid"</span>).first;</div><div class="line"></div><div class="line">  <span class="comment">// Partition the mesh</span></div><div class="line">  <a class="code" href="group__PkgBGLPartition.html#gad72efc6b61c92ee8704858dc0b7062e9">CGAL::METIS::partition_dual_graph</a>(sm, number_of_parts,</div><div class="line">                                    CGAL::parameters::vertex_partition_id_map(vertex_pid_map)</div><div class="line">                                                     .face_partition_id_map(face_pid_map));</div><div class="line"></div><div class="line">  <span class="comment">// Extract the part n°0 of the partition into a new, independent mesh</span></div><div class="line">  <span class="keyword">typedef</span> <a class="code" href="structCGAL_1_1Face__filtered__graph.html">CGAL::Face_filtered_graph&lt;SM&gt;</a>                            Filtered_graph;</div><div class="line">  Filtered_graph filtered_sm(sm, 0 <span class="comment">/*id of th part*/</span>, face_pid_map);</div><div class="line">  assert(filtered_sm.is_selection_valid());</div><div class="line">  SM part_sm;</div><div class="line">  <a class="code" href="group__PkgBGLHelperFct.html#ga2682fb7d5f4ff4eb65607ae4118e31bc">CGAL::copy_face_graph</a>(filtered_sm, part_sm);</div><div class="line"></div><div class="line">  <span class="comment">// Output the mesh extracted from subpart n°0</span></div><div class="line">  <a class="code" href="group__PkgBGLIOFct.html#gafa143949a33371dc6df8307be1ab8a66">CGAL::IO::write_polygon_mesh</a>(<span class="stringliteral">"sm_part_0.off"</span>, part_sm, CGAL::parameters::stream_precision(17));</div><div class="line"></div><div class="line">  <span class="comment">// Output all the vertices that are in the part n°0</span></div><div class="line">  std::ofstream outxyz(<span class="stringliteral">"out.xyz"</span>);</div><div class="line">  outxyz.precision(17);</div><div class="line">  boost::graph_traits&lt;SM&gt;::vertex_iterator vit, ve;</div><div class="line">  boost::tie(vit, ve) = vertices(sm);</div><div class="line">  <span class="keywordflow">for</span>(; vit!=ve; ++vit)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span>(<span class="keyword">get</span>(vertex_pid_map, *vit) == 0)</div><div class="line">      outxyz &lt;&lt; sm.point(*vit) &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><p>Using <a class="el" href="index.html#BGLNamedParameters">Named Parameters</a> some of the many options of METIS can be customized, as shown in <a class="el" href="BGL_polyhedron_3_2polyhedron_partition_8cpp-example.html">this example</a>.</p>
<h1><a class="anchor" id="BGLGraphcut"></a>
Graph Cut</h1>
<p>An optimal partition from a set of labels can be computed through a graph cut approach called alpha expansion <a class="el" href="citelist.html#CITEREF_Boykov2001FastApproximate">[1]</a>. CGAL provides <code><a class="el" href="group__PkgBGLPartition.html#gac0ae8f45718c0eb9b70ebddd5008515b" title="regularizes a partition of a graph into n labels using the alpha expansion algorithm ...">CGAL::alpha_expansion_graphcut()</a></code> which, for a graph \((V,E)\), computes the partition <code>f</code> that minimizes the following cost function:</p>
<p class="formulaDsp">
\[ \mathrm{C}(f) = \sum_{\{v0,v1\} \in E} C_E(v0,v1) + \sum_{v \in V} C_V(f_v) \]
</p>
<p>where \(C_E(v0,v1)\) is the edge cost of assigning a different label to \(v0\) and \(v1\), and \(C_V(f_v)\) is the vertex cost of assigning the label \(f\) to the vertex \(v\).</p>
<p>Three different implementations are provided and can be selected by using one of the following tags:</p>
<ul>
<li><code>CGAL::Alpha_expansion_boost_adjacency_list_tag</code> (default)</li>
<li><code>CGAL::Alpha_expansion_boost_compressed_sparse_raw_tag</code></li>
<li><code>CGAL::Alpha_expansion_MaxFlow_tag</code>, released under GPL license and provided by the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh_segmentation.tag:../Surface_mesh_segmentation/" href="../Surface_mesh_segmentation/group__PkgSurfaceMeshSegmentationRef.html">Triangulated Surface Mesh Segmentation Reference</a> package</li>
</ul>
<p>All these implementations produce the exact same result but behave differently in terms of timing and memory (see <a class="el" href="index.html#fig__alpha_exp">Figure 102.4</a>). The <em>MaxFlow</em> implementation is the fastest, but it grows rapidly in memory when increasing the complexity of the input graph and labeling; the <em>compressed sparse raw</em> (CSR) is very efficient from a memory point of view but becomes very slow as the complexity of the input graph and labeling increases; the <em>adjacency list</em> version provides a good compromise and is therefore the default implementation.</p>
<p><a class="anchor" id="fig__alpha_exp"></a></p><div class="image">
<img src="alpha_expansion.png" alt="alpha_expansion.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__alpha_exp">Figure 102.4</a> Comparison of time and memory consumed by the different alpha expansion implementations.  </div> <br /> 
<h2><a class="anchor" id="BGLGraphcutExample"></a>
Example</h2>
<p>The following example shows how to apply the alpha expansion algorithm to a <code>boost::adjacency_list</code> describing a 2D array with 3 labels "X", " " and "O":</p>
<p><br />
<b>File</b> <a class="el" href="BGL_graphcut_2alpha_expansion_example_8cpp-example.html">BGL_graphcut/alpha_expansion_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/alpha_expansion_graphcut.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/graph/adjacency_list.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>Vertex_property</div><div class="line">{</div><div class="line">  <span class="keywordtype">int</span> label;</div><div class="line">  std::vector&lt;double&gt; cost;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Edge_property</div><div class="line">{</div><div class="line">  <span class="keywordtype">double</span> weight;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">using</span> Graph = boost::adjacency_list &lt;boost::setS,</div><div class="line">                                     boost::vecS,</div><div class="line">                                     boost::undirectedS,</div><div class="line">                                     Vertex_property,</div><div class="line">                                     Edge_property&gt;;</div><div class="line"><span class="keyword">using</span> GT = boost::graph_traits&lt;Graph&gt;;</div><div class="line"><span class="keyword">using</span> vertex_descriptor = GT::vertex_descriptor;</div><div class="line"><span class="keyword">using</span> edge_descriptor = GT::edge_descriptor;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  std::array&lt;char, 3&gt; labels = { <span class="charliteral">'X'</span>, <span class="charliteral">' '</span>, <span class="charliteral">'O'</span> };</div><div class="line"></div><div class="line">  std::array&lt;std::array&lt;int, 6&gt;, 5&gt; input</div><div class="line">    = { { { 0, 2, 0, 1, 1, 1 },</div><div class="line">          { 0, 0, 1, 0, 1, 2 },</div><div class="line">          { 2, 0, 1, 1, 2, 2 },</div><div class="line">          { 0, 1, 1, 2, 2, 0 },</div><div class="line">          { 1, 1, 2, 0, 2, 2 } } };</div><div class="line"></div><div class="line">  std::array&lt;std::array&lt;vertex_descriptor, 6&gt;, 5&gt; vertices;</div><div class="line"></div><div class="line">  <span class="comment">// Init vertices from values</span></div><div class="line">  Graph g;</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; input.size(); ++ i)</div><div class="line">    <span class="keywordflow">for</span> (std::size_t j = 0; j &lt; input[i].size(); ++ j)</div><div class="line">    {</div><div class="line">      vertices[i][j] = boost::add_vertex(g);</div><div class="line">      g[vertices[i][j]].label = input[i][j];</div><div class="line"></div><div class="line">      <span class="comment">// Cost of assigning this vertex to any label is positive except</span></div><div class="line">      <span class="comment">// for current label which is 0 (favor init solution)</span></div><div class="line">      g[vertices[i][j]].cost.resize(3, 1);</div><div class="line">      g[vertices[i][j]].cost[std::size_t(input[i][j])] = 0;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="comment">// Display input values</span></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Input:"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; vertices.size(); ++ i)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (std::size_t j = 0; j &lt; vertices[i].size(); ++ j)</div><div class="line">      std::cerr &lt;&lt; labels[std::size_t(g[vertices[i][j]].label)];</div><div class="line">    std::cerr &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Init adjacency</span></div><div class="line">  <span class="keywordtype">double</span> weight = 0.5;</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; vertices.size(); ++ i)</div><div class="line">    <span class="keywordflow">for</span> (std::size_t j = 0; j &lt; vertices[i].size(); ++ j)</div><div class="line">    {</div><div class="line">      <span class="comment">// Neighbor vertices are connected</span></div><div class="line">      <span class="keywordflow">if</span> (i &lt; vertices.size() - 1)</div><div class="line">      {</div><div class="line">        edge_descriptor ed = <a class="code" href="group__PkgBGLEulerOperations.html#ga4661f850bc60686efeae2fc9d2ec3e65">boost::add_edge</a> (vertices[i][j], vertices[i+1][j], g).first;</div><div class="line">        g[ed].weight = weight;</div><div class="line">      }</div><div class="line">      <span class="keywordflow">if</span> (j &lt; vertices[i].size() - 1)</div><div class="line">      {</div><div class="line">        edge_descriptor ed = <a class="code" href="group__PkgBGLEulerOperations.html#ga4661f850bc60686efeae2fc9d2ec3e65">boost::add_edge</a> (vertices[i][j], vertices[i][j+1], g).first;</div><div class="line">        g[ed].weight = weight;</div><div class="line">      }</div><div class="line">    }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">"Alpha expansion..."</span> &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line">  <a class="code" href="group__PkgBGLPartition.html#gac0ae8f45718c0eb9b70ebddd5008515b">CGAL::alpha_expansion_graphcut</a> (g,</div><div class="line">                                  <span class="keyword">get</span> (&amp;Edge_property::weight, g),</div><div class="line">                                  <span class="keyword">get</span> (&amp;Vertex_property::cost, g),</div><div class="line">                                  <span class="keyword">get</span> (&amp;Vertex_property::label, g),</div><div class="line">                                  CGAL::parameters::vertex_index_map (<span class="keyword">get</span> (boost::vertex_index, g)));</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Display output graph</span></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Output:"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; vertices.size(); ++ i)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (std::size_t j = 0; j &lt; vertices[i].size(); ++ j)</div><div class="line">      std::cerr &lt;&lt; labels[std::size_t(g[vertices[i][j]].label)];</div><div class="line">    std::cerr &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>The output of this program shows how the initial 2D array is regularized spatially:</p>
<div class="fragment"><div class="line">Input:</div><div class="line">XOX</div><div class="line">XX X O</div><div class="line">OX  OO</div><div class="line">X  OOX</div><div class="line">  OXOO</div><div class="line"></div><div class="line">Alpha expansion...</div><div class="line"></div><div class="line">Output:</div><div class="line">XXX</div><div class="line">XX   O</div><div class="line">XX  OO</div><div class="line">X  OOO</div><div class="line">  OOOO</div></div><!-- fragment --><h2><a class="anchor" id="BGLGraphcutRegularizeSelection"></a>
Application to Regularization of the Borders of a Face Selection</h2>
<p>Manually selecting faces on a triangle mesh may create irregular borders (sawtooth) because of the shape of the triangles. Such borders can be regularized using the alpha expansion algorithm.</p>
<p>CGAL provides a function <code><a class="el" href="group__PkgBGLSelectionFct.html#gab638686b319f3b902c199d4b79df84e6" title="regularizes a selection in order to minimize the length of the border of the selection. ">CGAL::regularize_face_selection_borders()</a></code> to apply this algorithm to the borders of a face selection on a <code><a class="el" href="classFaceGraph.html" title="The concept FaceGraph refines the concept HalfedgeGraph. It adds the requirements for a graph to expl...">FaceGraph</a></code>. <a class="el" href="index.html#fig__regularization_fig">Figure 102.5</a> shows how this function affects a selection depending on the parameters.</p>
<p><a class="anchor" id="fig__regularization_fig"></a></p><div class="image">
<img src="regularize_selection.png" alt="regularize_selection.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__regularization_fig">Figure 102.5</a> Regularization of the borders of a face selection using alpha expansion. Different outputs are shown for different weight parameters, with and without preventing unselection.  </div> <br /> 
<p>The following example shows how to apply this alpha expansion regularization to the borders of a face selection of a <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh</a></code> object:</p>
<p><br />
<b>File</b> <a class="el" href="BGL_graphcut_2face_selection_borders_regularization_example_8cpp-example.html">BGL_graphcut/face_selection_borders_regularization_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/selection.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/OFF.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> Kernel = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> Mesh = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Kernel::Point_3&gt;</a>;</div><div class="line"><span class="keyword">using</span> Face_index = Mesh::Face_index;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::ifstream in((argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/blobby.off"</span>));</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!in)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: could not read input file"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  Mesh mesh;</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga7396bef8d41fe287d52d19ddbb83a3e4">CGAL::IO::read_OFF</a> (in, mesh);</div><div class="line"></div><div class="line">  std::unordered_map&lt;Face_index, bool&gt; is_selected_map;</div><div class="line"></div><div class="line">  <span class="comment">// randomly select 1/3 of faces</span></div><div class="line">  std::size_t nb_selected_before = 0;</div><div class="line">  CGAL::Random rand;</div><div class="line">  <span class="keywordflow">for</span> (Face_index fi : faces(mesh))</div><div class="line">  {</div><div class="line">    <span class="keywordtype">bool</span> selected = (rand.get_double() &lt; 1. / 3.);</div><div class="line">    is_selected_map[fi] = selected;</div><div class="line">    <span class="keywordflow">if</span> (selected)</div><div class="line">      nb_selected_before ++;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; nb_selected_before &lt;&lt; <span class="stringliteral">" selected before regularization"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgBGLSelectionFct.html#gab638686b319f3b902c199d4b79df84e6">CGAL::regularize_face_selection_borders</a> (mesh,</div><div class="line">                                           boost::make_assoc_property_map(is_selected_map),</div><div class="line">                                           0.5); <span class="comment">// using weight = 0.5</span></div><div class="line"></div><div class="line">  std::size_t nb_selected_after = 0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; sel : is_selected_map)</div><div class="line">    <span class="keywordflow">if</span> (sel.second)</div><div class="line">      ++ nb_selected_after;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; nb_selected_after &lt;&lt; <span class="stringliteral">" selected after regularization"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jun 27 2022 09:16:02 for CGAL 5.6 - CGAL and the Boost Graph Library by
    <a href="https://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>
</html>

</html>
