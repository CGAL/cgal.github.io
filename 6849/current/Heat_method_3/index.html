<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Heat_method_3/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=11">
<meta name="generator" content="Doxygen 1.9.6">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CGAL 6.0 - The Heat Method: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/doxygen.css" rel="stylesheet" type="text/css">
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      },
      equationNumbers: { autoNumber: "AMS" }
  }
}
);
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
      <span class="left">
         <span id="MSearchSelect" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()">Â 
        </span>
        <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
      </span>
      <span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.svg" alt=""></a>
      </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CGAL 6.0 - The Heat Method
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search/",'.html');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">User Manual </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_HeatMethod"></a></p> <div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Author</dt><dd>Christina Vaz, Keenan Crane, Andreas Fabri</dd></dl>
<div class="image">
<img src="octopus.png" alt="">
</div>
<h1><a class="anchor" id="sec_HM_introduction"></a>
Introduction</h1>
<p>The <em>heat method</em> is an algorithm that solves the single- or multiple-source shortest path problem by returning an approximation of the <em>geodesic distance</em> for all vertices of a triangle mesh to the closest vertex in a given set of source vertices. The geodesic distance between two vertices of a mesh is the distance when walking on the surface, potentially through the interior of faces. Two vertices that are close in 3D space may be far away on the surface, for example on neighboring arms of the octopus. In the figures we color code the distance as a gradient red/green corresponding to close/far from the source vertices.</p>
<p>The heat method is highly efficient, since the algorithm boils down to two standard sparse linear algebra problems. It is especially useful in situations where one wishes to perform repeated distance queries on a fixed domain, since precomputation done for the first query can be reused.</p>
<p>As a rule of thumb, the method works well on triangle meshes, which are Delaunay, though in practice may also work fine for meshes that are far from Delaunay. In order to ensure good behavior, we enable a preprocessing step that constructs an <em>intrinsic Delaunay triangulation (iDT)</em>; this triangulation does not change the input geometry, but generally improves the quality of the solution. The cost of this preprocessing step roughly doubles the overall preprocessing cost.</p>
<p><a class="anchor" id="fig__landscape_meshes"></a> </p><div class="image">
<img src="landscape.jpg" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__landscape_meshes">Figure 89.1</a> Isolines placed on a mesh without and with iDT remeshing. </p> </div> <p> <br>
</p>
<p>In the next section we give some examples. Section <a class="el" href="index.html#sec_HM_definitions">Theoretical Background</a> presents the mathematical theory of the Heat method. The last section is about the <a class="el" href="index.html#sec_HM_history">Implementation History</a>.</p>
<p>Note that this package depends on the third party <a class="elRef" href="../Manual/thirdparty.html#thirdpartyEigen">Eigen</a> library (3.3 or greater), or another model of the concept <code><a class="elRef" href="../Solver_interface/classSparseLinearAlgebraWithFactorTraits__d.html">SparseLinearAlgebraWithFactorTraits_d</a></code>. This implementation is based on <a class="el" href="citelist.html#CITEREF_cgal:cww-ghnac-13">[1]</a> , <a class="el" href="citelist.html#CITEREF_cgal:fsbs-acidt-06">[2]</a> , and <a class="el" href="citelist.html#CITEREF_cgal:sc-lntm-20">[3]</a></p>
<p>This package is related to the package <a class="elRef" href="../Manual/packages.html#PkgSurfaceMeshShortestPath">Triangulated Surface Mesh Shortest Paths</a>. Both deal with geodesic distances. The heat method package computes for every vertex of a mesh an approximate distance to one or several source vertices. The geodesic shortest path package computes the exact shortest path between any two points on the surface.</p>
<h1><a class="anchor" id="sec_HM_examples"></a>
Examples</h1>
<p>We give examples for the free function <code><a class="el" href="group__PkgHeatMethodRef.html#ga7e2e30c0e5039e224b19b2e26c02216d" title="computes for each vertex of the triangle mesh tm the estimated geodesic distance to a given source ve...">CGAL::Heat_method_3::estimate_geodesic_distances()</a></code>, for the class template <code><a class="el" href="classCGAL_1_1Heat__method__3_1_1Surface__mesh__geodesic__distances__3.html" title="Class Surface_mesh_geodesic_distances_3 computes estimated geodesic distances for a set of source ver...">CGAL::Heat_method_3::Surface_mesh_geodesic_distances_3</a></code>, with and without the use of intrinsic Delaunay triangulation.</p>
<h2><a class="anchor" id="HM_example_Free_function"></a>
Using a Free Function</h2>
<p>The first example calls the free function <code><a class="el" href="group__PkgHeatMethodRef.html#ga7e2e30c0e5039e224b19b2e26c02216d" title="computes for each vertex of the triangle mesh tm the estimated geodesic distance to a given source ve...">Heat_method_3::estimate_geodesic_distances()</a></code>, which computes for all vertices of a triangle mesh the distances to a single source vertex.</p>
<p>The distances are written into an internal property map of the surface mesh.</p>
<p><br>
<b>File</b> <a class="el" href="Heat_method_3_2heat_method_8cpp-example.html">Heat_method_3/heat_method.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Heat_method_3/Surface_mesh_geodesic_distances_3.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_structRef" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>                       <a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                                      Point_3;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point_3&gt;</a>                          Triangle_mesh;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Triangle_mesh&gt;::vertex_descriptor vertex_descriptor;</div>
<div class="line"><span class="keyword">typedef</span> Triangle_mesh::Property_map&lt;vertex_descriptor,double&gt; Vertex_distance_map;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : <a class="code hl_functionRef" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/elephant.off"</span>);</div>
<div class="line"> </div>
<div class="line">  Triangle_mesh tm;</div>
<div class="line">  <span class="keywordflow">if</span>(!<a class="code hl_functionRef" href="../BGL/group__PkgBGLIOFct.html#ga49f5b5e6fbfcbfaaac7604c88e10915c">CGAL::IO::read_polygon_mesh</a>(filename, tm) ||</div>
<div class="line">     <a class="code hl_functionRef" href="../BGL/group__PkgBGLHelperFct.html#gab6e6f18e6de73b9f85e38d0b56145172">CGAL::is_empty</a>(tm) || !<a class="code hl_functionRef" href="../BGL/group__PkgBGLHelperFct.html#ga11883d231eec1b58f37efe4acedd9588">CGAL::is_triangle_mesh</a>(tm))</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input file."</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//property map for the distance values to the source set</span></div>
<div class="line">  Vertex_distance_map vertex_distance = tm.add_property_map&lt;vertex_descriptor, <span class="keywordtype">double</span>&gt;(<span class="stringliteral">"v:distance"</span>, 0).first;</div>
<div class="line"> </div>
<div class="line">  vertex_descriptor source = *(vertices(tm).first);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="group__PkgHeatMethodRef.html#ga7e2e30c0e5039e224b19b2e26c02216d">CGAL::Heat_method_3::estimate_geodesic_distances</a>(tm, vertex_distance, source) ;</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Source vertex "</span> &lt;&lt; source &lt;&lt; <span class="stringliteral">" at: "</span> &lt;&lt; tm.point(source) &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">for</span>(vertex_descriptor vd : vertices(tm))</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; vd &lt;&lt; <span class="stringliteral">" ("</span>&lt;&lt; tm.point(vd) &lt;&lt; <span class="stringliteral">")"</span></div>
<div class="line">              &lt;&lt;  <span class="stringliteral">" is at distance "</span> &lt;&lt; get(vertex_distance, vd) &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassCGAL_1_1Surface__mesh_html"><div class="ttname"><a href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh</a></div></div>
<div class="ttc" id="aclassKernel_1_1Point__3_html"><div class="ttname"><a href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a></div></div>
<div class="ttc" id="agroup__PkgBGLHelperFct_html_ga11883d231eec1b58f37efe4acedd9588"><div class="ttname"><a href="../BGL/group__PkgBGLHelperFct.html#ga11883d231eec1b58f37efe4acedd9588">CGAL::is_triangle_mesh</a></div><div class="ttdeci">bool is_triangle_mesh(const FaceGraph &amp;g)</div></div>
<div class="ttc" id="agroup__PkgBGLHelperFct_html_gab6e6f18e6de73b9f85e38d0b56145172"><div class="ttname"><a href="../BGL/group__PkgBGLHelperFct.html#gab6e6f18e6de73b9f85e38d0b56145172">CGAL::is_empty</a></div><div class="ttdeci">bool is_empty(const FaceGraph &amp;g)</div></div>
<div class="ttc" id="agroup__PkgBGLIOFct_html_ga49f5b5e6fbfcbfaaac7604c88e10915c"><div class="ttname"><a href="../BGL/group__PkgBGLIOFct.html#ga49f5b5e6fbfcbfaaac7604c88e10915c">CGAL::IO::read_polygon_mesh</a></div><div class="ttdeci">bool read_polygon_mesh(const std::string &amp;fname, Graph &amp;g, const NamedParameters &amp;np=parameters::default_values())</div></div>
<div class="ttc" id="agroup__PkgHeatMethodRef_html_ga7e2e30c0e5039e224b19b2e26c02216d"><div class="ttname"><a href="group__PkgHeatMethodRef.html#ga7e2e30c0e5039e224b19b2e26c02216d">CGAL::Heat_method_3::estimate_geodesic_distances</a></div><div class="ttdeci">void estimate_geodesic_distances(const TriangleMesh &amp;tm, VertexDistanceMap vdm, typename boost::graph_traits&lt; TriangleMesh &gt;::vertex_descriptor source, Mode)</div><div class="ttdoc">computes for each vertex of the triangle mesh tm the estimated geodesic distance to a given source ve...</div><div class="ttdef"><b>Definition:</b> Surface_mesh_geodesic_distances_3.h:907</div></div>
<div class="ttc" id="anamespaceCGAL_html_acdae9a147ad2a3998cc21f88bc292dac"><div class="ttname"><a href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a></div><div class="ttdeci">std::string data_file_path(const std::string &amp;filename)</div></div>
<div class="ttc" id="anamespaceKernel_html"><div class="ttname"><a href="../Kernel_23/namespaceKernel.html">Kernel</a></div></div>
<div class="ttc" id="astructCGAL_1_1Simple__cartesian_html"><div class="ttname"><a href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian</a></div></div>
</div><!-- fragment --><p>For a <code><a class="elRef" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">Polyhedron_3</a></code> you can either add a data field to the vertex type, or, as shown in the following example, create a <code>boost::unordered_map</code> and pass it to the function <code>boost::make_assoc_property_map()</code>, which generates a vertex distance property map.</p>
<p><br>
<b>File</b> <a class="el" href="Heat_method_3_2heat_method_polyhedron_8cpp-example.html">Heat_method_3/heat_method_polyhedron.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Heat_method_3/Surface_mesh_geodesic_distances_3.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;unordered_map&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_structRef" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>                       <a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                                      Point_3;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;Kernel&gt;</a>                           Triangle_mesh;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Triangle_mesh&gt;::vertex_descriptor vertex_descriptor;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  Triangle_mesh tm;</div>
<div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : <a class="code hl_functionRef" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/elephant.off"</span>);</div>
<div class="line">  std::ifstream input(filename);</div>
<div class="line">  <span class="keywordflow">if</span> (!input || !(input &gt;&gt; tm) || tm.is_empty()) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Not a valid off file."</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// map for the distance values to the source set</span></div>
<div class="line">  std::unordered_map&lt;vertex_descriptor, double&gt; vertex_distance;</div>
<div class="line"> </div>
<div class="line">  vertex_descriptor source = *(vertices(tm).first);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="group__PkgHeatMethodRef.html#ga7e2e30c0e5039e224b19b2e26c02216d">CGAL::Heat_method_3::estimate_geodesic_distances</a>(tm,</div>
<div class="line">                                                   boost::make_assoc_property_map(vertex_distance),</div>
<div class="line">                                                   source) ;</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Source vertex at: "</span> &lt;&lt; source-&gt;point() &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">for</span>(vertex_descriptor vd : vertices(tm)){</div>
<div class="line">    std::cout &lt;&lt; vd-&gt;point() &lt;&lt; <span class="stringliteral">"  is at distance "</span> &lt;&lt; vertex_distance[vd] &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassCGAL_1_1Polyhedron__3_html"><div class="ttname"><a href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="HM_example_Class"></a>
Using the Heat Method Class</h2>
<p>The following example shows the heat method class. It can be used when one adds and removes source vertices. It performs a precomputation, which depend only on the input mesh and not the particular set of source vertices. In the example we compute the distances to one source, add the farthest vertex as a second source vertex, and then compute the distances with respect to these two sources.</p>
<p><br>
<b>File</b> <a class="el" href="Heat_method_3_2heat_method_surface_mesh_8cpp-example.html">Heat_method_3/heat_method_surface_mesh.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Heat_method_3/Surface_mesh_geodesic_distances_3.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_structRef" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>                       <a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                                      Point_3;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point_3&gt;</a>                          Triangle_mesh;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Triangle_mesh&gt;::vertex_descriptor vertex_descriptor;</div>
<div class="line"><span class="keyword">typedef</span> Triangle_mesh::Property_map&lt;vertex_descriptor,double&gt; Vertex_distance_map;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classCGAL_1_1Heat__method__3_1_1Surface__mesh__geodesic__distances__3.html">CGAL::Heat_method_3::Surface_mesh_geodesic_distances_3&lt;Triangle_mesh&gt;</a> Heat_method;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : <a class="code hl_functionRef" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/larger_sphere.off"</span>);</div>
<div class="line"> </div>
<div class="line">  Triangle_mesh tm;</div>
<div class="line">  <span class="keywordflow">if</span>(!<a class="code hl_functionRef" href="../BGL/group__PkgBGLIOFct.html#ga49f5b5e6fbfcbfaaac7604c88e10915c">CGAL::IO::read_polygon_mesh</a>(filename, tm) ||</div>
<div class="line">     <a class="code hl_functionRef" href="../BGL/group__PkgBGLHelperFct.html#gab6e6f18e6de73b9f85e38d0b56145172">CGAL::is_empty</a>(tm) || !<a class="code hl_functionRef" href="../BGL/group__PkgBGLHelperFct.html#ga11883d231eec1b58f37efe4acedd9588">CGAL::is_triangle_mesh</a>(tm))</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input file."</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//property map for the distance values to the source set</span></div>
<div class="line">  Vertex_distance_map vertex_distance = tm.add_property_map&lt;vertex_descriptor, <span class="keywordtype">double</span>&gt;(<span class="stringliteral">"v:distance"</span>, 0).first;</div>
<div class="line"> </div>
<div class="line">  Heat_method hm(tm);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//add the first vertex as the source set</span></div>
<div class="line">  vertex_descriptor source = *(vertices(tm).first);</div>
<div class="line">  hm.add_source(source);</div>
<div class="line">  hm.estimate_geodesic_distances(vertex_distance);</div>
<div class="line"> </div>
<div class="line">  Point_3 sp = tm.point(source);</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"source: "</span> &lt;&lt; sp  &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; source &lt;&lt; std::endl;</div>
<div class="line">  vertex_descriptor vfar;</div>
<div class="line">  <span class="keywordtype">double</span> sdistance = 0;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span>(vertex_descriptor vd : vertices(tm)){</div>
<div class="line">    std::cout &lt;&lt; vd &lt;&lt; <span class="stringliteral">"  is at distance "</span> &lt;&lt; get(vertex_distance, vd) &lt;&lt; <span class="stringliteral">" to "</span> &lt;&lt; source &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">if</span>(get(vertex_distance, vd) &gt; sdistance){</div>
<div class="line">      vfar = vd;</div>
<div class="line">      sdistance = get(vertex_distance, vd);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"vfar: "</span> &lt;&lt; tm.point(vfar) &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; vfar &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  hm.add_source(vfar);</div>
<div class="line">  hm.estimate_geodesic_distances(vertex_distance);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span>(vertex_descriptor vd : vertices(tm)){</div>
<div class="line">    std::cout &lt;&lt; vd &lt;&lt; <span class="stringliteral">"  is at distance "</span> &lt;&lt; get(vertex_distance, vd) &lt;&lt; <span class="stringliteral">"to the set of two sources"</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"done"</span> &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassCGAL_1_1Heat__method__3_1_1Surface__mesh__geodesic__distances__3_html"><div class="ttname"><a href="classCGAL_1_1Heat__method__3_1_1Surface__mesh__geodesic__distances__3.html">CGAL::Heat_method_3::Surface_mesh_geodesic_distances_3</a></div><div class="ttdoc">Class Surface_mesh_geodesic_distances_3 computes estimated geodesic distances for a set of source ver...</div><div class="ttdef"><b>Definition:</b> Surface_mesh_geodesic_distances_3.h:756</div></div>
</div><!-- fragment --><h2><a class="anchor" id="HM_example_Intrinsic"></a>
Switching off the Intrinsic Delaunay Triangulation</h2>
<p>The following example shows the heat method on a triangle mesh without using the intrinsic Delaunay triangulation (iDT) algorithm, for example because by construction your meshes have a good quality (Poor quality in this case means that the input is far from Delaunay, though even in this case one may still get good results without iDT, depending on the specific geometry of the surface). The iDT algorithm is switched off by the template parameter <code><a class="el" href="structCGAL_1_1Heat__method__3_1_1Direct.html" title="A tag class used to specify that the heat method is applied to the input mesh.">Heat_method_3::Direct</a></code>.</p>
<p><br>
<b>File</b> <a class="el" href="Heat_method_3_2heat_method_surface_mesh_direct_8cpp-example.html">Heat_method_3/heat_method_surface_mesh_direct.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Heat_method_3/Surface_mesh_geodesic_distances_3.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_structRef" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>                       <a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                                      Point_3;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point_3&gt;</a>                          Triangle_mesh;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Triangle_mesh&gt;::vertex_descriptor vertex_descriptor;</div>
<div class="line"><span class="keyword">typedef</span> Triangle_mesh::Property_map&lt;vertex_descriptor,double&gt; Vertex_distance_map;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classCGAL_1_1Heat__method__3_1_1Surface__mesh__geodesic__distances__3.html">CGAL::Heat_method_3::Surface_mesh_geodesic_distances_3&lt;Triangle_mesh, CGAL::Heat_method_3::Direct&gt;</a> Heat_method_idt;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : <a class="code hl_functionRef" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/elephant.off"</span>);</div>
<div class="line"> </div>
<div class="line">  Triangle_mesh tm;</div>
<div class="line">  <span class="keywordflow">if</span>(!<a class="code hl_functionRef" href="../BGL/group__PkgBGLIOFct.html#ga49f5b5e6fbfcbfaaac7604c88e10915c">CGAL::IO::read_polygon_mesh</a>(filename, tm) ||</div>
<div class="line">     <a class="code hl_functionRef" href="../BGL/group__PkgBGLHelperFct.html#gab6e6f18e6de73b9f85e38d0b56145172">CGAL::is_empty</a>(tm) || !<a class="code hl_functionRef" href="../BGL/group__PkgBGLHelperFct.html#ga11883d231eec1b58f37efe4acedd9588">CGAL::is_triangle_mesh</a>(tm))</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input file."</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">   <span class="comment">//property map for the distance values to the source set</span></div>
<div class="line">  Vertex_distance_map vertex_distance = tm.add_property_map&lt;vertex_descriptor,<span class="keywordtype">double</span>&gt;(<span class="stringliteral">"v:distance"</span>,0).first;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//pass in the idt object and its vertex_distance_map</span></div>
<div class="line">  Heat_method_idt hm_idt(tm);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//add the first vertex as the source set</span></div>
<div class="line">  vertex_descriptor source = *(vertices(tm).first);</div>
<div class="line">  hm_idt.add_source(source);</div>
<div class="line">  hm_idt.estimate_geodesic_distances(vertex_distance);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span>(vertex_descriptor vd : vertices(tm)){</div>
<div class="line">    std::cout &lt;&lt; vd &lt;&lt; <span class="stringliteral">"  is at distance "</span> &lt;&lt; get(vertex_distance, vd) &lt;&lt; <span class="stringliteral">" from "</span> &lt;&lt; source &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="sec_HM_definitions"></a>
Theoretical Background</h1>
<p>Section <a class="el" href="index.html#Subsection_HM_Definitions_Intro">The Heat Method Algorithm</a> gives an overview of the theory needed by the Heat method. Section <a class="el" href="index.html#Subsection_HM_IDT_Definitions">Intrinsic Delaunay Triangulation</a> gives the background needed for the Intrinsic Delaunay triangulation.</p>
<h2><a class="anchor" id="Subsection_HM_Definitions_Intro"></a>
The Heat Method Algorithm</h2>
<p>For a detailed overview of the heat method, the reader may consult <a class="el" href="citelist.html#CITEREF_cgal:cww-ghnac-13">[1]</a> to read the original article. In the sequel, we introduce the basic notions so as to explain our algorithms. In general, the heat method is applicable to any setting if there exists a gradient operator \( \nabla\), a divergence operator \(\nabla \cdot\) and a Laplace operator \(\Delta = \nabla \cdot
\nabla\), which are standard derivatives from vector calculus.</p>
<p>The Heat Method consists of three main steps:</p><ol type="1">
<li>Integrate the heat flow \( \dot u = \Delta u\) for some fixed time \(t\).</li>
<li>Evaluate the vector field \( X = -\nabla u_t / |\nabla u_t| \).</li>
<li>Solve the Poisson Equation \( \Delta \phi = \nabla \cdot X \).</li>
</ol>
<p>The function \( \phi \) is an approximation of the distance to the given source set and approaches the true distance as t goes to zero. The algorithm must then be translated in to a discrete algorithm by replacing the derivatives in space and time with approximations.</p>
<p>The heat equation can be discretized in time using a single backward <a class="elRef" href="../BGL/group__PkgBGLEulerOperations.html">Euler</a> step. This means the following equation must be solved:</p>
<p>\((id-t\Delta)u_t = \delta_{\gamma}(x) \) where \(\delta_{\gamma}(x)\) is a Dirac delta encoding an "infinite" spike of heat (1 if x is in the source set \(\gamma\), 0 otherwise), where id is the identity operator.</p>
<p>The spatial discretization depends on the choice of discrete surface representation. For this package, we use triangle meshes exclusively. Let \( u \in \R^{|V|}\) specify a piecewise linear function on a triangulated surface with vertices \(V\), edges \(E\) and faces \(F\). A standard discretization of the Laplacian at vertex \(i\) is:</p>
<p>\( {Lu}_i = \frac{1}{2A_i} \sum_{j}(cot \alpha_{ij} + cot \beta_{ij})(u_j-u_i)\) where \(A_i\) is one third the area of all triangles incident on vertex \(i\).</p>
<p>The sum is taken over all of the neighboring vertices \(j\). Further, \(\alpha_{ij}\) and \(\beta_{ij}\) are the angles opposing the corresponding edge \(ij\). We express this operation via a matrix \(L = M^{-1}L_c\) where \(M \in
R^{|V|x|V|}\) is a diagonal matrix containing the vertex areas and \(L_c \in R^{|V|x|V|} \) is the cotan operator representing the remaining sum.</p>
<p>From this, the symmetric positive-definite system \((M-tL_C)u = \delta_{\gamma}\) can be solved to find \(u\) where \(\delta_{\gamma}\) is the Kronecker delta over \(\gamma\).</p>
<p>Next, the gradient in a given triangle can be expressed as</p>
<p>\(\nabla u = \frac{1}{2 A_f} \sum_i u_i ( N \times e_i ) \)</p>
<p>where \(A_f\) is the area of the triangle, \(N\) is its outward unit normal, \(e_i\) is the \(i\)th edge vector (oriented counter-clockwise), and \(u_i\) is the value of \(u\) at the opposing vertex. The integrated divergence associated with vertex \(i\) can be written as</p>
<p>\(\nabla \cdot X = \frac{1}{2} \sum_j cot\theta_1 (e_1 \cdot X_j) + cot \theta_2 (e_2 \cdot X_j)\)</p>
<p>where the sum is taken over incident triangles \(j\) each with a vector \(X_j\), \(e_1\) and \(e_2\) are the two edge vectors of triangle \(j\) containing \(i\) and \(\theta_1\), \(\theta_2\) are the opposing angles.</p>
<p>Finally, let \(b \in R^{|V|}\) be the integrated divergences of the normalized vector field X. Thus, solving the symmetric Poisson problem \( L_c \phi = b\) computes the final distance function.</p>
<h2><a class="anchor" id="Subsection_HM_IDT_Definitions"></a>
Intrinsic Delaunay Triangulation</h2>
<p>The standard discretization of the cotan Laplace operator uses the cotangents of the angles in the triangle mesh. The intrinsic Delaunay algorithm constructs an alternative triangulation of the same polyhedral surface, which in turn yields a different (typically more accurate) cotan Laplace operator. Conceptually, the edges of the iDT still connect pairs of vertices from the original (input) surface, but are now allowed to be geodesic paths along the polyhedron and do not have to correspond to edges of the input triangulation. These paths are not stored explicitly; instead, we simply keep track of their lengths as the triangulation is updated. These lengths are sufficient to determine areas and angles of the intrinsic triangles, and in turn, the new cotan Laplace matrix.</p>
<p>An edge of a mesh is locally Delaunay if the sum of opposite angles is not smaller than pi, or equivalently, if the cotangents of the opposing angles are non-negative. A mesh is Delaunay if all of its edges are locally Delaunay.</p>
<p>A standard algorithm to convert a given planar triangulation into a Delaunay triangulation is to flip non-Delaunay edges in a mesh until the mesh is Delaunay. Similarly, the intrinsic Delaunay triangulation of a simplicial surface is constructed by performing intrinsic edge flips.</p>
<p>Let \( K = (V,E,T) \) be a 2-manifold triangle mesh, where \(V\) is the vertex set, \( E \) is the edge set and \( T \) is the face set (triangle set). Let \( L \) be the set of Euclidean distances, where \( L(e_{ij}) = l_{ij} = || p_i - p_j || \) , where \( p_i \) and \( p_j \) are the point positions \( \in R^3 \) of vertices \( i \) and \( j \) respectively. Then, let the pair \( (K,L) \) be the input to the iDT algorithm, which returns the pair \((\tilde K, \tilde L)\), which are the intrinsic Delaunay mesh and the intrinsic lengths. The algorithm is as follows: </p><pre class="fragment">        \code
         for all edge e in E : Mark(e)
         Stack s &lt;-- E
         while !Empty(s) do
           edge(ij) = Pop(s) and Unmark(edge(ij))
            if !Delaunay(edge(ij)) then
              edge(kl) = Flip(edge(ij)) and compute the new length length(kl) using the Cosine Theorem
               for all edge e in {edge(kj), edge(jl), edge(li), edge(ik)} do
                 if !Mark(e) then
                   Mark(e) and Push(s,e)
                 end if
              end for
            end if
          end while
        return (~K,~L)
        \endcode
</pre><p>The new \((\tilde K, \tilde L)\) are then used to implement the heat method as usual.</p>
<p>We already in the beginning gave an example where the intrinsic Delaunay triangulation improves the results. The mesh was obtained by giving elevation to a 2D triangulation, which lead to highly elongated triangles.</p>
<p>The situation is similar for any triangle mesh that has faces with very small angles as can be seen in the figures below.</p>
<p><a class="anchor" id="fig__circle_box"></a> </p><div class="image">
<img src="red_circle_box_without_idt_bottom.png" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__circle_box">Figure 89.2</a> Isolines placed on a mesh without iDT remeshing </p> </div> <p> <br>
 <a class="anchor" id="fig__circle_box_idt"></a> </p><div class="image">
<img src="red_circle_box_with_idt_bottom.png" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__circle_box_idt">Figure 89.3</a> Isolines placed on a mesh with iDT remeshing </p> </div> <p> <br>
</p>
<h1><a class="anchor" id="sec_HM_Performance"></a>
Performance</h1>
<p>The time complexity of the algorithm is determined primarily by the choice of linear solver. In the current implementation, Cholesky prefactorization is roughly \(O(N^{1.5})\) and computation of distances is roughly \(O(N)\), where \( N\) is the number of vertices in the triangulation. The algorithm uses two \( N \times N\) matrices, both with the same pattern of non-zeros (in average 7 non-zeros per row/column). The cost of computation is independent of the size of the source set. Primitive operations include sparse numerical linear algebra (in double precision), and basic arithmetic operations (including square roots).</p>
<p>We perform the benchmark on an Intel Core i7-7700HQ, 2.8HGz, and compiled with Visual Studio 2013.</p>
<center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">Number of triangles   </th><th class="markdownTableHeadRight">Initialization iDT (sec)   </th><th class="markdownTableHeadRight">Distance computation iDT (sec)   </th><th class="markdownTableHeadRight">Initialization Direct (sec)   </th><th class="markdownTableHeadRight">Distance computation Direct (sec)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">30,000   </td><td class="markdownTableBodyRight">0.18   </td><td class="markdownTableBodyRight">0.02   </td><td class="markdownTableBodyRight">0.12   </td><td class="markdownTableBodyRight">0.01    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">200,000   </td><td class="markdownTableBodyRight">1.82   </td><td class="markdownTableBodyRight">1.31   </td><td class="markdownTableBodyRight">1.32   </td><td class="markdownTableBodyRight">0.11    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">500,000   </td><td class="markdownTableBodyRight">10.45   </td><td class="markdownTableBodyRight">0.75   </td><td class="markdownTableBodyRight">8.07   </td><td class="markdownTableBodyRight">0.55    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">1,800,000   </td><td class="markdownTableBodyRight">38.91   </td><td class="markdownTableBodyRight">2.24   </td><td class="markdownTableBodyRight">35.68   </td><td class="markdownTableBodyRight">1.1   </td></tr>
</table>
</center><center></center><h1><a class="anchor" id="sec_HM_history"></a>
Implementation History</h1>
<p>This package was developed by Christina Vaz, Keenan Crane and Andreas Fabri as a project of the Google Summer of Code 2018. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"></a> 1.9.6 </li>
  </ul>
</div>
</div>
</body>


</html>
