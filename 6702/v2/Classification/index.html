<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Classification/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 5.6 - Classification: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//&amp;lt;![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      }
  }
}
);
//]]&amp;gt;
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.6 - Classification
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Classification"></a> </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Authors</dt><dd>Simon Giraudot, Florent Lafarge</dd></dl>
<p>This component implements the algorithm described in <a class="el" href="citelist.html#CITEREF_cgal:lm-clscm-12">[4]</a> (section 2), generalized to handle different types of data, multiple features and multiple labels. It classifies a data set into a user-defined set of labels, such as <em>ground</em>, <em>vegetation</em> and <em>buildings</em>. A flexible API is provided so that users can classify any type of data which they can index and for which they can compute relevant features, compute their own local features on the input data set and define their own labels.</p>
<h1><a class="anchor" id="Classification_Organization"></a>
Package Organization</h1>
<p>Classification of data sets is achieved as follows (see Figure <a class="el" href="index.html#fig__Classification_organization_fig">Figure 84.1</a>):</p>
<ul>
<li>some analysis is performed on the input data set;</li>
<li>features are computed based on this analysis;</li>
<li>a set of labels (for example: <em>ground</em>, <em>building</em>, <em>vegetation</em>) is defined by the user;</li>
<li>a classifier is defined and trained: from the set of values taken by the features at an input item, it measures the likelihood of this item to belong to one label or another;</li>
<li>classification is computed itemwise using the classifier;</li>
<li>additional regularization can be used by smoothing either locally or globally through a <em>graph cut</em> <a class="el" href="citelist.html#CITEREF_Boykov2001FastApproximate">[1]</a> approach.</li>
</ul>
<p><a class="anchor" id="fig__Classification_organization_fig"></a></p><div class="image">
<object type="image/svg+xml" data="organization.svg">organization.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Classification_organization_fig">Figure 84.1</a> Organization of the package.  </div> <br /> 
<p>This package is designed to be easily extended by users: more specifically, features and labels can be defined by users to handle any data they need to classify.</p>
<p>Currently, CGAL provides data structures to handle classification of point sets, surface meshes and clusters.</p>
<h1><a class="anchor" id="Classification_structures"></a>
Common Data Structures</h1>
<h2><a class="anchor" id="Classification_labels"></a>
Label Set</h2>
<p>A label represents how an item should be classified, for example: <em>vegetation</em>, <em>building</em>, <em>road</em>, etc. In CGAL, a label has a name, an index (in a label set), a standard index (for example, the index of the label in the ASPRS standard) and a color. It is simply identified by a <a class="el" href="classCGAL_1_1Classification_1_1Label__handle.html">Label_handle</a>. Note that names, standard indices and colors are not used for identification: two labels in the same set can have the same name, standard index and color but not the same handle.</p>
<p>If labels are initialized with their names only, standard indices and colors can be deduced in some cases (see <a class="el" href="classCGAL_1_1Classification_1_1Label__set.html#afaa0d2e86c20b0c7ef19ce5e3f6b1104">Label_set::add()</a>).</p>
<p>The following code snippet shows how to add labels to the classification object:</p>
<div class="fragment"><div class="line"></div><div class="line">  Label_set labels;</div><div class="line"></div><div class="line">  <span class="comment">// Init name only</span></div><div class="line">  Label_handle ground = labels.add (<span class="stringliteral">"ground"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Init name and color</span></div><div class="line">  Label_handle vegetation = labels.add (<span class="stringliteral">"vegetation"</span>, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a>(0,255,0));</div><div class="line"></div><div class="line">  <span class="comment">// Init name, Color and standard index (here, ASPRS building index)</span></div><div class="line">  Label_handle roof = labels.add (<span class="stringliteral">"roof"</span>, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a> (255, 0, 0), 6);</div><div class="line"></div></div><!-- fragment --> <h2><a class="anchor" id="Classification_features"></a>
Feature Set</h2>
<p>Features are defined as scalar fields that associate each input item with a specific value. Note that in order to limit memory consumption, we use the type <code>float</code> for these scalar values (as well as for every floating point value in this package). A feature has a name and is identified by a <a class="el" href="classCGAL_1_1Classification_1_1Feature__handle.html">Feature_handle</a>.</p>
<p>The computation of features and their addition to the feature set is done in a single step using the <a class="el" href="classCGAL_1_1Classification_1_1Feature__set.html#a2d7dc5beaa908425dcf000ed441aa4bf">Feature_set::add&lt;Feature&gt;()</a> method. If CGAL was linked with <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartyTBB">Intel TBB</a>, features can be computed in parallel (see below).</p>
<p>CGAL provides some predefined features (see <a class="el" href="index.html#Classification_point_sets">Point Set Classification</a> for example). In the following code snippet, a subset of these predefined features are instantiated (in parallel if <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartyTBB">Intel TBB</a> is available). Note that all the predefined features can also be automatically generated in multiple scales (see <a class="el" href="index.html#Classification_point_sets">Point Set Classification</a> for example).</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="keywordtype">float</span> radius_neighbors = 1.7f;</div><div class="line">  <span class="keywordtype">float</span> radius_dtm = 15.0f;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Computing features"</span> &lt;&lt; std::endl;</div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  features.begin_parallel_additions(); <span class="comment">// No effect in sequential mode</span></div><div class="line"></div><div class="line">  Feature_handle distance_to_plane = features.add&lt;Distance_to_plane&gt; (pts, Pmap(), eigen);</div><div class="line">  Feature_handle dispersion = features.add&lt;Dispersion&gt; (pts, Pmap(), grid,</div><div class="line">                                                        radius_neighbors);</div><div class="line">  Feature_handle elevation = features.add&lt;Elevation&gt; (pts, Pmap(), grid,</div><div class="line">                                                      radius_dtm);</div><div class="line"></div><div class="line">  features.end_parallel_additions(); <span class="comment">// No effect in sequential mode</span></div><div class="line"></div></div><!-- fragment --><p> Users may want to define their own features, especially if the input data set comes with additional properties that were not anticipated by CGAL. A user-defined feature must inherit from <a class="el" href="classCGAL_1_1Classification_1_1Feature__base.html">Feature_base</a> and provide a method <a class="el" href="classCGAL_1_1Classification_1_1Feature__base.html#a601e16c0026bd33f28fc8bfd68b30461">value()</a> that associates a scalar value to each input item.</p>
<p>The following example shows how to define a feature that discriminates points that lie inside a 2D box from the others:</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="comment">// User-defined feature that identifies a specific area of the 3D</span></div><div class="line"><span class="comment">// space. This feature takes value 1 for points that lie inside the</span></div><div class="line"><span class="comment">// area and 0 for the others.</span></div><div class="line"><span class="keyword">class </span>My_feature : <span class="keyword">public</span> <a class="code" href="classCGAL_1_1Classification_1_1Feature__base.html">CGAL::Classification::Feature_base</a></div><div class="line">{</div><div class="line">  <span class="keyword">const</span> Point_range&amp; range;</div><div class="line">  <span class="keywordtype">double</span> xmin, xmax, ymin, ymax;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  My_feature (<span class="keyword">const</span> Point_range&amp; range,</div><div class="line">              <span class="keywordtype">double</span> xmin, <span class="keywordtype">double</span> xmax, <span class="keywordtype">double</span> ymin, <span class="keywordtype">double</span> ymax)</div><div class="line">    : range (range), xmin(xmin), xmax(xmax), ymin(ymin), ymax(ymax)</div><div class="line">  {</div><div class="line">    this-&gt;set_name (<span class="stringliteral">"my_feature"</span>);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">float</span> value (std::size_t pt_index)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (xmin &lt; range[pt_index].x() &amp;&amp; range[pt_index].x() &lt; xmax &amp;&amp;</div><div class="line">        ymin &lt; range[pt_index].y() &amp;&amp; range[pt_index].y() &lt; ymax)</div><div class="line">      <span class="keywordflow">return</span> 1.f;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <span class="keywordflow">return</span> 0.f;</div><div class="line">  }</div><div class="line"></div><div class="line">};</div><div class="line"></div></div><!-- fragment --><p> This feature can then be instantiated from the feature set the same way as the others:</p>
<div class="fragment"><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Computing features"</span> &lt;&lt; std::endl;</div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  <span class="comment">// Feature that identifies points whose x coordinate is between -20</span></div><div class="line">  <span class="comment">// and 20 and whose y coordinate is between -15 and 15</span></div><div class="line">  Feature_handle my_feature = features.add&lt;My_feature&gt; (pts, -20., 20., -15., 15.);</div><div class="line"></div></div><!-- fragment --> <h1><a class="anchor" id="Classification_structures_specialized"></a>
Specialized Data Structures</h1>
<p>Classification is based on the computation of local features. These features can take advantage of shared data structures that are precomputed and stored separately. Both these features and the underlying data structures depend on the type of data that needs to be classified. CGAL provides data structures to classify point sets, surface meshes and clusters.</p>
<h2><a class="anchor" id="Classification_point_sets"></a>
Point Set Classification</h2>
<p>CGAL provides the following structures:</p>
<ul>
<li><a class="el" href="classCGAL_1_1Classification_1_1Point__set__neighborhood.html">Point_set_neighborhood</a> stores spatial searching structures and provides adapted queries for points;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Local__eigen__analysis.html">Local_eigen_analysis</a> precomputes covariance matrices on local neighborhoods of points and stores the associated eigenvectors and eigenvalues;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Planimetric__grid.html">Planimetric_grid</a> is a 2D grid used for digital terrain modeling.</li>
</ul>
<p>Most of these data structures depend on a scale parameter. CGAL provides a method to estimate the average spacing based on a number of neighbors (see <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga8b330397a3fb68176c851fd7d214b513">CGAL::compute_average_spacing()</a>), which usually provides satisfying results in the absence of noise. In the presence of noise, <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga28fe6443638647be0874b283085eb2cd">CGAL::estimate_global_range_scale()</a> provides an estimation of the smallest scale such that the point set has the local dimension of a surface (this method is both robust to noise and outliers, see <a class="el" href="index.html#Classification_sowf_result">Result</a>).</p>
<p>The eigen analysis can be used to estimate normals. Note however that this analysis (based on Principal Component Analysis) might not be robust to a high level of noise. CGAL also provides more robust normal estimation functions (see for example <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga078e25209373cab0e1f3524202489771">CGAL::jet_estimate_normals()</a>).</p>
<p>The following code snippet shows how to instantiate such data structures from an input PLY point set (the <a class="el" href="index.html#Classification_example_general">full example</a> is given at the end of the manual).</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/b9.ply"</span>);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Reading input"</span> &lt;&lt; std::endl;</div><div class="line">  std::vector&lt;Point&gt; pts;</div><div class="line">  <span class="keywordflow">if</span> (!(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(filename, std::back_inserter(pts),</div><div class="line">                              <span class="comment">// the PLY reader expects a binary file by default</span></div><div class="line">                              CGAL::parameters::use_binary_mode(<span class="keyword">false</span>))))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read "</span> &lt;&lt; filename &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">float</span> grid_resolution = 0.34f;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> number_of_neighbors = 6;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Computing useful structures"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  Iso_cuboid_3 bbox = CGAL::bounding_box (pts.begin(), pts.end());</div><div class="line"></div><div class="line">  Planimetric_grid grid (pts, Pmap(), bbox, grid_resolution);</div><div class="line">  Neighborhood neighborhood (pts, Pmap());</div><div class="line">  Local_eigen_analysis eigen</div><div class="line">    = Local_eigen_analysis::create_from_point_set</div><div class="line">    (pts, Pmap(), neighborhood.k_neighbor_query(number_of_neighbors));</div><div class="line"></div></div><!-- fragment --><p> CGAL provides some predefined features:</p>
<ul>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Distance__to__plane.html">Distance_to_plane</a> measures how far away a point is from a locally estimated plane;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Eigenvalue.html">Eigenvalue</a> measures one of the three local eigenvalues;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Elevation.html">Elevation</a> computes the local distance to an estimation of the ground;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Elevation.html">Height_above</a> computes the distance between the local highest point and the point;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Elevation.html">Height_below</a> computes the distance between the point and the local lowest point;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Vertical__dispersion.html">Vertical_dispersion</a> computes how noisy the point set is on a local Z-cylinder;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Elevation.html">Vertical_range</a> computes the distance between the local highest and lowest points;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Verticality.html">Verticality</a> compares the local normal vector to the vertical vector.</li>
</ul>
<p>These features are designed for point sets but can easily be used with surface meshes as well (see <a class="el" href="index.html#Classification_meshes">Mesh Classification</a>). For more details about how these different features can help to identify one label or the other, please refer to their associated reference manual pages.</p>
<p>In addition, if the input data set has additional properties, these can also be used as features. For example, CGAL provides the following features:</p>
<ul>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Color__channel.html">Color_channel</a> uses input color information if available;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Echo__scatter.html">Echo_scatter</a> uses the number of returns (echo) provided by most LIDAR scanners if available;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Simple__feature.html">Simple_feature</a> uses any property map applicable to the input range and whose value type is castable to <code>float</code> (useful if an additional property of the input set should be used as is, for example an <code>intensity</code> measurement).</li>
</ul>
<p>Users commonly want to use all predefined features to get the best result possible. CGAL provides a class <a class="el" href="classCGAL_1_1Classification_1_1Point__set__feature__generator.html">Point_set_feature_generator</a> that performs the following operations:</p>
<ul>
<li>it estimates the smallest relevant scale;</li>
<li>it generates all needed analysis structures and provides access to them;</li>
<li>it generates all possible features (among all the CGAL predefined ones) based on which property maps are available (they use colors if available, etc.).</li>
</ul>
<p>Multiple scales that are sequentially larger can be used to increase the quality of the results <a class="el" href="citelist.html#CITEREF_cgal:hws-fsso3-16">[3]</a>.</p>
<p>Note that using this class in order to generate features is not mandatory, as features and data structures can all be handled by hand. It is mainly provided to make the specific case of point sets simpler to handle. Users can still add their own features within their feature set.</p>
<p>Some data structure instantiated by the generator will be used by feature: for this reason, the generator should be instantiated <em>within the same scope</em> as the feature set and should not be deleted before the feature set.</p>
<p>The following snippet shows how to use the point set feature generator:</p>
<div class="fragment"><div class="line"></div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  std::size_t number_of_scales = 5;</div><div class="line">  Feature_generator generator (pts, pts.point_map(), number_of_scales);</div><div class="line"></div><div class="line">  features.begin_parallel_additions();</div><div class="line">  generator.generate_point_based_features (features);</div><div class="line">  features.end_parallel_additions();</div><div class="line"></div></div><!-- fragment --><p> <a class="anchor" id="fig__Classification_point_set_fig"></a></p><div class="image">
<img src="point_set.png" alt="point_set.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Classification_point_set_fig">Figure 84.2</a> Example of point set classification (left: input, right: output). <em>Ground</em> is grey, <em>roofs</em> are orange, <em>vegetation</em> is green.  </div> <br /> 
<h2><a class="anchor" id="Classification_meshes"></a>
Mesh Classification</h2>
<p>Classification of mesh is performed by considering the face of a mesh as an atomic element that should be assign one label or another. Some structures such as neighborhood or Eigen analysis are significantly different from their equivalent for point sets; other data structures from point sets can be directly used by viewing the mesh as a point set through the use of a property map that associates each face with a representative point.</p>
<p>Hereafter, a <em>mesh</em> refers to a model of <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/classFaceListGraph.html">FaceListGraph</a></code>.</p>
<p>CGAL provides the following structures:</p>
<ul>
<li><a class="el" href="classCGAL_1_1Classification_1_1Face__descriptor__to__center__of__mass__map.html">Face_descriptor_to_center_of_mass_map</a> is a property map that takes the face of a mesh as key type and returns the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__3.html">CGAL::Point_3</a></code> located at the center of mass of the face. It is useful to apply point set structures and features to surface meshes;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Face__descriptor__to__face__descriptor__with__bbox__map.html">Face_descriptor_to_face_descriptor_with_bbox_map</a> is a property map that takes the face of a mesh as key type and returns the same face along with its bounding box as a value type. It is useful to call <code><a class="el" href="group__PkgClassificationMain.html#ga2a4c1b0816b81b628dc9023e104449eb" title="runs the classification algorithm with a global regularization based on a graph cut. ">CGAL::Classification::classify_with_graphcut()</a></code> which requires objects that provide a <code>bbox()</code> method (see <a class="el" href="index.html#Classification_classification_functions">Classification Functions</a>);</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Mesh__neighborhood.html">Mesh_neighborhood</a> provides adapted queries for surface meshes;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Local__eigen__analysis.html">Local_eigen_analysis</a> precomputes covariance matrices on local neighborhoods of triangles and stores the associated eigenvectors and eigenvalues (it is the same object as for point sets called with a different named constructor);</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Planimetric__grid.html">Planimetric_grid</a> is the 2D grid used for digital terrain modeling of point sets, it can be used with meshes through <a class="el" href="classCGAL_1_1Classification_1_1Face__descriptor__to__center__of__mass__map.html">Face_descriptor_to_center_of_mass_map</a>.</li>
</ul>
<p>The point set features can be used for mesh classification as well:</p>
<ul>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Eigenvalue.html">Eigenvalue</a> takes the <a class="el" href="classCGAL_1_1Classification_1_1Local__eigen__analysis.html">Local_eigen_analysis</a> object computed on faces as input;</li>
<li>the other ones are computed by considering the mesh as a point set.</li>
</ul>
<p>Similarly to <a class="el" href="classCGAL_1_1Classification_1_1Point__set__feature__generator.html">Point_set_feature_generator</a>, CGAL provides a class <a class="el" href="classCGAL_1_1Classification_1_1Mesh__feature__generator.html">Mesh_feature_generator</a> that estimates the smallest scale automatically and computes all predefined features on several scales. As for point sets, using this class in order to generate features is not mandatory, as features and data structures can all be handled by hand. It is mainly provided to make the specific case of meshes simpler to handle. Users can still add their own features within their feature set.</p>
<p>The following snippet shows how to use the mesh feature generator:</p>
<div class="fragment"><div class="line"></div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  Face_point_map face_point_map (&amp;mesh); <span class="comment">// Associates each face to its center of mass</span></div><div class="line"></div><div class="line">  std::size_t number_of_scales = 5;</div><div class="line">  Feature_generator generator (mesh, face_point_map, number_of_scales);</div><div class="line"></div><div class="line">  features.begin_parallel_additions();</div><div class="line">  generator.generate_point_based_features (features); <span class="comment">// Features that consider the mesh as a point set</span></div><div class="line">  generator.generate_face_based_features (features);  <span class="comment">// Features computed directly on mesh faces</span></div><div class="line">  features.end_parallel_additions();</div><div class="line"></div></div><!-- fragment --><p> The <a class="el" href="index.html#Classification_example_mesh">full example</a> is given at the end of the manual.</p>
<p><a class="anchor" id="fig__Classification_mesh_fig"></a></p><div class="image">
<img src="mesh.png" alt="mesh.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Classification_mesh_fig">Figure 84.3</a> Example of mesh classification (left: input, right: output). <em>Ground</em> is grey, <em>roofs</em> are orange, <em>vegetation</em> is green.  </div> <br /> 
<h2><a class="anchor" id="Classification_clusters"></a>
Cluster Classification</h2>
<p>Classifying clusters of items instead of raw sets of items can have several advantages:</p>
<ul>
<li>if the data set is very large, using clusters can drastically decrease the complexity and thus the need for computation time and memory;</li>
<li>clusters are more complex objects than raw items (isolated points or triangles of a mesh) and thus provide additional information (size of cluster, spatial consistency, etc.);</li>
<li>by construction, the output classification is less noisy (if all points of a facade are in the same cluster, then they are guaranteed to all be classified in the same label).</li>
</ul>
<p>For example, when dealing with urban scenes that typically contain large planar sections, it may be more efficient to first detect planes (with <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Region__growing.html">CGAL::Shape_detection::Region_growing</a></code> or <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Efficient__RANSAC.html">CGAL::Shape_detection::Efficient_RANSAC</a></code> for example) and then to classify each subset of points belonging to a specific plane as clusters.</p>
<p>CGAL provides some tools to classify clusters:</p>
<ul>
<li>the class <code><a class="el" href="classCGAL_1_1Classification_1_1Cluster.html" title="Class that represent a cluster of items to be classified as a single atomic object. ">CGAL::Classification::Cluster</a></code> can be used to represent a cluster of items (points, for example);</li>
<li>the function <code><a class="el" href="group__PkgClassificationCluster.html#ga6c0c1a27071cf5ebfac967d6847cbbf9" title="Given a set of cluster indices, segments the input range into Cluster objects. ">CGAL::Classification::create_clusters_from_indices()</a></code> takes indices over items as input (for example, shape indices taken from shape detection) and generates one cluster per index.</li>
</ul>
<p>The following snippet shows how to create classification clusters from a shape detection algorithm (<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Region__growing.html">Region Growing</a>):</p>
<div class="fragment"><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Detecting planes and creating clusters"</span> &lt;&lt; std::endl;</div><div class="line">  t.start();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> search_sphere_radius  = 1.0;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> max_distance_to_plane = 1.0;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> max_accepted_angle    = 25.0;</div><div class="line">  <span class="keyword">const</span> std::size_t min_region_size  = 10;</div><div class="line"></div><div class="line">  Neighbor_query neighbor_query (</div><div class="line">    pts, CGAL::parameters::sphere_radius(search_sphere_radius)</div><div class="line">                          .point_map(pts.point_map()));</div><div class="line">  Region_type region_type(</div><div class="line">    pts, CGAL::parameters::maximum_distance(max_distance_to_plane)</div><div class="line">                          .maximum_angle(max_accepted_angle)</div><div class="line">                          .minimum_region_size(min_region_size)</div><div class="line">                          .point_map(pts.point_map())</div><div class="line">                          .normal_map(pts.normal_map()));</div><div class="line">  Region_growing region_growing (</div><div class="line">    pts, neighbor_query, region_type);</div><div class="line"></div><div class="line">  std::vector&lt;Cluster&gt; clusters;</div><div class="line">  region_growing.detect</div><div class="line">    (boost::make_function_output_iterator</div><div class="line">     ([&amp;](<span class="keyword">const</span> std::vector&lt;std::size_t&gt;&amp; region) -&gt; <span class="keywordtype">void</span> {</div><div class="line"></div><div class="line">        <span class="comment">// Create a new cluster.</span></div><div class="line">        Classification::Cluster&lt;Point_set, Pmap&gt; cluster (pts, pts.point_map());</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> std::size_t idx : region)</div><div class="line">          cluster.insert(idx);</div><div class="line">        clusters.push_back(cluster);</div><div class="line">      }));</div><div class="line"></div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; clusters.size() &lt;&lt; <span class="stringliteral">" clusters created in "</span></div><div class="line">            &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div><div class="line"></div></div><!-- fragment --><p> The class <a class="el" href="classCGAL_1_1Classification_1_1Local__eigen__analysis.html">Local_eigen_analysis</a> can also take point clusters as input:</p>
<div class="fragment"><div class="line"></div><div class="line">  Local_eigen_analysis eigen = Local_eigen_analysis::create_from_point_clusters (clusters);</div><div class="line"></div></div><!-- fragment --><p> As clusters are based on simple items, users can compute cluster features based on statistics over the itemwise features:</p>
<ul>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Cluster__mean__of__feature.html">Cluster_mean_of_feature</a> computes, for a cluster, the mean value of an itemwise feature over the inliers of this cluster;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Cluster__variance__of__feature.html">Cluster_variance_of_feature</a> computes, for a cluster, the variance of an itemwise feature over the inliers of this cluster.</li>
</ul>
<p>Some additional features are provided specifically for clusters:</p>
<ul>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Cluster__size.html">Cluster_size</a> uses the number of items in a cluster;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Cluster__vertical__extent.html">Cluster_vertical_extent</a> computes the length of the smallest interval on the <code>Z</code> axis that contains all the items of a cluster;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Eigenvalue.html">Eigenvalue</a>, similarly to point sets and meshes, can use the <a class="el" href="classCGAL_1_1Classification_1_1Local__eigen__analysis.html">Local_eigen_analysis</a> object computed on clusters.</li>
</ul>
<p>The following snippet shows, from a pointwise feature set, how to generate the statistical features from a pointwise feature set (along with these latest cluster features):</p>
<div class="fragment"><div class="line"></div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  <span class="comment">// First, compute means of features.</span></div><div class="line">  features.begin_parallel_additions();</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; pointwise_features.size(); ++ i)</div><div class="line">    features.add&lt;Feature::Cluster_mean_of_feature&gt; (clusters, pointwise_features[i]);</div><div class="line">  features.end_parallel_additions();</div><div class="line"></div><div class="line">  <span class="comment">// Then, compute variances of features (and remaining cluster features).</span></div><div class="line">  features.begin_parallel_additions();</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; pointwise_features.size(); ++ i)</div><div class="line">    features.add&lt;Feature::Cluster_variance_of_feature&gt; (clusters,</div><div class="line">                                                        pointwise_features[i], <span class="comment">// i^th feature</span></div><div class="line">                                                        features[i]);          <span class="comment">// mean of i^th feature</span></div><div class="line"></div><div class="line">  features.add&lt;Feature::Cluster_size&gt; (clusters);</div><div class="line">  features.add&lt;Feature::Cluster_vertical_extent&gt; (clusters);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; 3; ++ i)</div><div class="line">    features.add&lt;Feature::Eigenvalue&gt; (clusters, eigen, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(i));</div><div class="line"></div><div class="line">  features.end_parallel_additions();</div><div class="line"></div></div><!-- fragment --><p> The <a class="el" href="index.html#Classification_example_cluster">full example</a> is given at the end of the manual.</p>
<p><a class="anchor" id="fig__Classification_cluster_fig"></a></p><div class="image">
<img src="clusters.png" alt="clusters.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Classification_cluster_fig">Figure 84.4</a> Example of cluster classification mesh (left: input, middle: clusters computed from region growing, right: output). <em>Ground</em> is grey, <em>roofs</em> are orange, <em>vegetation</em> is green, points not assigned to a cluster are <em>black</em>.  </div> <br /> 
<h1><a class="anchor" id="Classification_classifiers"></a>
Classifiers</h1>
<p>Classification relies on a classifier: this classifier is an object that, from the set of values taken by the features at an input item, computes the probability that an input item belongs to one label or another. A model of the concept <code><a class="el" href="classCGAL_1_1Classification_1_1Classifier.html" title="Concept describing a classifier used by classification functions (see CGAL::Classification::classify(...">CGAL::Classification::Classifier</a></code> must take the index of an input item and store the probability associated to each label in a vector. If a classifier returns the value 1 for a pair of label and input item, it means that this item belongs to this label with certainty; values close to 0 mean that this item is not likely to belong to this label.</p>
<p>CGAL provides three models for this concept, <a class="el" href="classCGAL_1_1Classification_1_1ETHZ_1_1Random__forest__classifier.html">ETHZ::Random_forest_classifier</a>, <a class="el" href="classCGAL_1_1Classification_1_1OpenCV_1_1Random__forest__classifier.html">OpenCV::Random_forest_classifier</a>, and <a class="el" href="classCGAL_1_1Classification_1_1Sum__of__weighted__features__classifier.html">Sum_of_weighted_features_classifier</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Currently, <a class="el" href="classCGAL_1_1Classification_1_1ETHZ_1_1Random__forest__classifier.html">ETHZ::Random_forest_classifier</a> is the best classifier available in CGAL and we strongly advise users to use it.</dd></dl>
<p>To perform classification based on four classifiers, please refer to <a class="el" href="index.html#Classification_classification_functions">Classification Functions</a>.</p>
<h2><a class="anchor" id="Classification_ETHZ_random_forest"></a>
ETHZ Random Forest</h2>
<p>CGAL provides <a class="el" href="classCGAL_1_1Classification_1_1ETHZ_1_1Random__forest__classifier.html">ETHZ::Random_forest_classifier</a>, a classifier based on the Random Forest Template Library developed by Stefan Walk at ETH Zurich <a class="el" href="citelist.html#CITEREF_cgal:w-erftl-14">[2]</a> (the library is distributed under the MIT license and is included with the CGAL release, the user does not have to install anything more). This classifier uses a ground truth training set to construct several decision trees that are then used to assign a label to each input item.</p>
<p>This classifier cannot be set up by hand and requires a ground truth training set. The training algorithm is fast but usually requires a high number of inliers. The training algorithm uses more memory at runtime and the configuration files are larger than those produced by <a class="el" href="classCGAL_1_1Classification_1_1Sum__of__weighted__features__classifier.html">Sum_of_weighted_features_classifier</a>, but the output quality is usually significantly better, especially in the cases where many labels are used (more than five).</p>
<p>An <a class="el" href="index.html#Classification_example_ethz_random_forest">example</a> shows how to use this classifier. For more details about the algorithm, please refer to README provided in the <a href="https://ethz.ch/content/dam/ethz/special-interest/baug/igp/photogrammetry-remote-sensing-dam/documents/sourcecode-and-datasets/Random%20Forest/rforest.zip">ETH Zurich's code archive</a>.</p>
<h3><a class="anchor" id="Classification_ETHZ_random_forest_deprecated"></a>
Deprecated IO</h3>
<p>The <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/namespaceCGAL_1_1IO.html">IO</a> functions of this classifier were changed in CGAL 5.2. Configurations generated from previous versions are not valid anymore and should be converted first as shown in the following example:</p>
<p><br />
<b>File</b> <a class="el" href="Classification_2example_deprecated_conversion_8cpp-example.html">Classification/example_deprecated_conversion.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Classification/ETHZ/Random_forest_classifier.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (argc != 3)</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Usage: "</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">" input.gz output.bin"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">  {</div><div class="line">    std::ifstream ifile (argv[1], std::ios_base::binary);</div><div class="line">    std::ofstream ofile (argv[2], std::ios_base::binary);</div><div class="line"></div><div class="line">    <a class="code" href="classCGAL_1_1Classification_1_1ETHZ_1_1Random__forest__classifier.html#a99154673a7b517e7d141e6d3678a65c8">CGAL::Classification::ETHZ::Random_forest_classifier::</a></div><div class="line"><a class="code" href="classCGAL_1_1Classification_1_1ETHZ_1_1Random__forest__classifier.html#a99154673a7b517e7d141e6d3678a65c8">      convert_deprecated_configuration_to_new_format</a>(ifile, ofile);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Classification_OpenCV_random_forest"></a>
OpenCV Random Forest</h2>
<p>The second classifier is <a class="el" href="classCGAL_1_1Classification_1_1OpenCV_1_1Random__forest__classifier.html">OpenCV::Random_forest_classifier</a>. It uses the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartyOpenCV">OpenCV</a> library, more specifically the <a href="https://docs.opencv.org/2.4/modules/ml/doc/random_trees.html">Random Trees</a> package.</p>
<p>Note that this classifier usually produces results with a lower quality than <a class="el" href="classCGAL_1_1Classification_1_1ETHZ_1_1Random__forest__classifier.html">ETHZ::Random_forest_classifier</a>. It is provided for the sake of completeness and for testing purposes, but if you are not sure what to use, we advise using the ETHZ Random Forest instead.</p>
<p>An <a class="el" href="index.html#Classification_example_opencv_random_forest">example</a> shows how to use this classifier. For more details about the algorithm, please refer to <a href="https://docs.opencv.org/2.4/modules/ml/doc/random_trees.html">the official documentation</a> of OpenCV.</p>
<h2><a class="anchor" id="Classification_sowf"></a>
Sum of Weighted Features</h2>
<p>This latest classifier defines the following attributes:</p>
<ul>
<li>a weight applied to each feature;</li>
<li>an effect applied to each pair of feature and label.</li>
</ul>
<p>For each label, the classifier computes an energy as a sum of features normalized with both their weight and the effect they have on this specific label.</p>
<p>The main advantage of this classifier is that it can be set up by hand. Nevertheless, it also embeds a training algorithm.</p>
<h3><a class="anchor" id="Classification_sowf_weights_effects"></a>
Weights and Effects</h3>
<p>Each feature is assigned a weight that measures its strength with respect to the other features.</p>
<p>Each pair of feature and label is assigned an effect that can either be:</p>
<ul>
<li><a class="el" href="classCGAL_1_1Classification_1_1Sum__of__weighted__features__classifier.html#a6aab054f8adf32f1e05b693f5caf9512a9f79d37660f7ace2f1c3a790edb4171a">FAVORING</a>: the label is favored by high values of the feature;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Sum__of__weighted__features__classifier.html#a6aab054f8adf32f1e05b693f5caf9512aafe5766bc7d9202e9e856491e311d954">NEUTRAL</a>: the label is not affected by the feature;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Sum__of__weighted__features__classifier.html#a6aab054f8adf32f1e05b693f5caf9512a2dd2e92685af72202d0875fb898f391e">PENALIZING</a>: the label is favored by low values of the feature.</li>
</ul>
<p>For example, <em>vegetation</em> is expected to have a high distance to plane and have a color close to green (if colors are available); <em>facades</em> have a low distance to plane and a low verticality; etc.</p>
<p>Let \(x=(x_i)_{i=1..N}\) be a potential classification result with \(N\) the number of input items and \(x_i\) the class of the \(i^{th}\) item (for example: <em>vegetation</em>, <em>ground</em>, etc.). Let \(f_j(i)\) be the raw value of the \(j^{th}\) feature at the \(i^{th}\) item and \(w_j\) be the weight of this feature. We define the normalized value \(F_j(x_i) \in [0:1]\) of the \(j^{th}\) feature at the \(i^{th}\) item as follows:</p>
<p class="formulaDsp">
\begin{eqnarray*} F_j(x_i) = &amp; (1 - \min(\max(0,\frac{f_j(i)}{w_j}), 1)) &amp; \mbox{if } f_j \mbox{ favors } x_i \\ &amp; 0.5 &amp; \mbox{if } f_j \mbox{ is neutral for } x_i \\ &amp; \min(\max(0,\frac{f_j(i)}{w_j}), 1) &amp; \mbox{if } f_j \mbox{ penalizes } x_i \end{eqnarray*}
</p>
<p>The itemwise energy measures the coherence of the label \(x_i\) at the \(i^{th}\) item and is defined as:</p>
<p class="formulaDsp">
\[ E_{di}(x_i) = \sum_{j = 1..N_f} F_j(x_i) \]
</p>
<p>The following code snippet shows how to define the weights and effects of features and labels:</p>
<div class="fragment"><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Setting weights"</span> &lt;&lt; std::endl;</div><div class="line">  Classifier classifier (labels, features);</div><div class="line">  classifier.set_weight (distance_to_plane, 6.75e-2f);</div><div class="line">  classifier.set_weight (dispersion, 5.45e-1f);</div><div class="line">  classifier.set_weight (elevation, 1.47e1f);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Setting effects"</span> &lt;&lt; std::endl;</div><div class="line">  classifier.set_effect (ground, distance_to_plane, Classifier::NEUTRAL);</div><div class="line">  classifier.set_effect (ground, dispersion, Classifier::NEUTRAL);</div><div class="line">  classifier.set_effect (ground, elevation, Classifier::PENALIZING);</div><div class="line"></div><div class="line">  classifier.set_effect (vegetation, distance_to_plane,  Classifier::FAVORING);</div><div class="line">  classifier.set_effect (vegetation, dispersion, Classifier::FAVORING);</div><div class="line">  classifier.set_effect (vegetation, elevation, Classifier::NEUTRAL);</div><div class="line"></div><div class="line">  classifier.set_effect (roof, distance_to_plane,  Classifier::NEUTRAL);</div><div class="line">  classifier.set_effect (roof, dispersion, Classifier::NEUTRAL);</div><div class="line">  classifier.set_effect (roof, elevation, Classifier::FAVORING);</div><div class="line"></div></div><!-- fragment --> <h3><a class="anchor" id="Classification_sowf_training"></a>
Training</h3>
<p>Each feature has a specific weight and each pair of feature-label has a specific effect. This means that the number of parameters to set up can quickly explode: if 6 features are used to classify between 4 labels, 30 parameters have to be set up (6 weights + 6x4 feature-label relationships).</p>
<p>Though it is possible to set them up one by one, CGAL also provides a method <a class="el" href="classCGAL_1_1Classification_1_1Sum__of__weighted__features__classifier.html#a11bcf5a1416f0fd2c4855af9c73797cc">train()</a> that requires a small set of ground truth items provided by users. More specifically, users must provide, for each label they want to classify, a set of known inliers among the input data set (for example, selecting one roof, one tree and one section of the ground). The training algorithm works as follows:</p>
<ul>
<li>for each feature, a range of weights is tested: the effect each feature has on each label is estimated. For a given weight, if a feature has the same effect on each label, it is non-relevant for classification. The range of weights such that the feature is relevant is estimated;</li>
<li>for each feature, uniformly picked weight values are tested and their effects are estimated;</li>
<li>each inlier provided by the user is classified using this set of weights and effects;</li>
<li>the mean intersection-over-union (see <a class="el" href="index.html#Classification_evaluation">Evaluation</a>) is used to evaluate the quality of this set of weights and effects;</li>
<li>the same mechanism is repeated until all features' ranges have been tested. Weights are only changed one by one, the other ones are kept to the values that gave the latest best score.</li>
</ul>
<p>This usually converges to a satisfying solution (see Figure <a class="el" href="index.html#fig__Classification_trainer_fig">Figure 84.5</a>). The number of trials is user defined, set to 300 by default. Using at least 10 times the number of features is advised (for example, at least 300 iterations if 30 features are used). If the solution is not satisfying, more inliers can be selected, for example, in a region that the user identifies as misclassified with the current configuration. The training algorithm keeps, as initialization, the best weights found at the previous round and carries on trying new weights by taking new inliers into account.</p>
<p><a class="anchor" id="fig__Classification_trainer_fig"></a></p><div class="image">
<img src="classif_training.png" alt="classif_training.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Classification_trainer_fig">Figure 84.5</a> Example of evolution of the mean intersection-over-union. The purple curve is the score computed at the current iteration, green curve is the best score found so far.  </div> <br /> 
<h3><a class="anchor" id="Classification_sowf_result"></a>
Result</h3>
<p>Figure <a class="el" href="index.html#fig__Classification_sowf_result_fig">Figure 84.6</a> shows an example of output on a defect-laden point set. The accuracy on this example is 0.97 with a mean intersection-over-union of 0.85 (see section <a class="el" href="index.html#Classification_evaluation">Evaluation</a>).</p>
<p><a class="anchor" id="fig__Classification_sowf_result_fig"></a></p><div class="image">
<img src="noise_outliers.png" alt="noise_outliers.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Classification_sowf_result_fig">Figure 84.6</a> Example of classification on a point set with medium noise and outliers (left: input, right: output). <em>Ground</em> is orange, <em>roofs</em> are pink, <em>vegetation</em> is green. Outliers are classified with an additional label <em>outlier</em> in black.  </div> <br /> 
<h1><a class="anchor" id="Classification_classification_functions"></a>
Classification Functions</h1>
<p>Classification is performed by minimizing an energy over the input data set that may include regularization. CGAL provides three different methods for classification, ranging from high speed / low quality to low speed / high quality:</p>
<ul>
<li><code><a class="el" href="group__PkgClassificationMain.html#gaea3ed82bf801bc9fbd00b63da48df73e" title="runs the classification algorithm without any regularization. ">CGAL::Classification::classify()</a></code></li>
<li><code><a class="el" href="group__PkgClassificationMain.html#ga266e487bd1ab9dd4036e3fbd2ec4e8a0" title="runs the classification algorithm with a local smoothing. ">CGAL::Classification::classify_with_local_smoothing()</a></code></li>
<li><code><a class="el" href="group__PkgClassificationMain.html#ga2a4c1b0816b81b628dc9023e104449eb" title="runs the classification algorithm with a global regularization based on a graph cut. ">CGAL::Classification::classify_with_graphcut()</a></code></li>
</ul>
<p>On a point set of 3 millions of points, the first method takes about 4 seconds, the second about 40 seconds and the third about 2 minutes.</p>
<p><a class="anchor" id="fig__Classification_image"></a></p><div class="image">
<img src="classif.png" alt="classif.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Classification_image">Figure 84.7</a> Top-Left: input point set. Top-Right: raw output classification represented by a set of colors (<em>ground</em> is orange, <em>facades</em> are blue, <em>roofs</em> are pink and <em>vegetation</em> is green). Bottom-Left: output classification using local smoothing. Bottom-Right: output classification using graphcut.  </div> <br /> 
<p>Mathematical details are provided hereafter.</p>
<h2><a class="anchor" id="Classification_classify"></a>
Raw Classification</h2>
<ul>
<li><code><a class="el" href="group__PkgClassificationMain.html#gaea3ed82bf801bc9fbd00b63da48df73e" title="runs the classification algorithm without any regularization. ">CGAL::Classification::classify()</a></code>: this is the fastest method that provides acceptable but usually noisy results (see Figure <a class="el" href="index.html#fig__Classification_image">Figure 84.7</a>, top-right).</li>
</ul>
<p>Let \(x=(x_i)_{i=1..N}\) be a potential classification result with \(N\) the number of input items and \(x_i\) the label of the \(i^{th}\) item (for example: <em>vegetation</em>, <em>ground</em>, etc.). The classification is performed by minimizing the following energy:</p>
<p class="formulaDsp">
\[ E(x) = \sum_{i = 1..N} E_{di}(x_i) \]
</p>
<p>This energy is a sum of itemwise energies provided by the classifier and involves no regularization.</p>
<p>The following snippet shows how to classify points based on a label set and a classifier. The result is stored in <code>label_indices</code>, following the same order as the input set and providing for each point the index (in the label set) of its assigned label.</p>
<div class="fragment"><div class="line">  std::vector&lt;int&gt; label_indices (pts.size(), -1);</div><div class="line"></div><div class="line">  CGAL::Real_timer t;</div><div class="line">  t.start();</div><div class="line">  Classification::classify&lt;CGAL::Parallel_if_available_tag&gt; (pts, labels, classifier, label_indices);</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Raw classification performed in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div></div><!-- fragment --> <h2><a class="anchor" id="Classification_smoothing"></a>
Local Regularization</h2>
<ul>
<li><p class="startli"><code><a class="el" href="group__PkgClassificationMain.html#ga266e487bd1ab9dd4036e3fbd2ec4e8a0" title="runs the classification algorithm with a local smoothing. ">CGAL::Classification::classify_with_local_smoothing()</a></code>: this method is a tradeoff between quality and efficiency (see Figure <a class="el" href="index.html#fig__Classification_image">Figure 84.7</a>, bottom-left). The minimized energy is defined as follows:</p>
<p class="formulaDsp">
\[ E(x) = \sum_{i = 1..N} E_{si}(x_i) \]
</p>
</li>
</ul>
<p>The energy \(E_{si}(x_i)\) is defined on a small local neighborhood \(Nb(i)\) of the \(i^{th}\) item (including itself):</p>
<p class="formulaDsp">
\[ E_{si}(x_i) = \frac{\sum_{k \in Nb(i)} E_{di}(x_k)}{\left| Nb(i) \right|} \]
</p>
<p>This allows to eliminate local noisy variations of assigned labels. Increasing the size of the neighborhood increases the noise reduction at the cost of higher computation times.</p>
<p>The following snippet shows how to classify points using local smoothing by providing a model of <code><a class="el" href="classCGAL_1_1Classification_1_1NeighborQuery.html" title="Concept describing a neighbor query used for classification. ">CGAL::Classification::NeighborQuery</a></code>.</p>
<div class="fragment"><div class="line">  t.start();</div><div class="line">  Classification::classify_with_local_smoothing&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (pts, Pmap(), labels, classifier,</div><div class="line">     neighborhood.sphere_neighbor_query(radius_neighbors),</div><div class="line">     label_indices);</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classification with local smoothing performed in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div></div><!-- fragment --> <h2><a class="anchor" id="Classification_graphcut"></a>
Global Regularization (Graph Cut)</h2>
<ul>
<li><p class="startli"><code><a class="el" href="group__PkgClassificationMain.html#ga2a4c1b0816b81b628dc9023e104449eb" title="runs the classification algorithm with a global regularization based on a graph cut. ">CGAL::Classification::classify_with_graphcut()</a></code>: this method offers the best quality but requires longer computation time (see Figure <a class="el" href="index.html#fig__Classification_image">Figure 84.7</a>, bottom-right). The total energy that is minimized is the sum of the partial data term \(E_{di}(x_i)\) and of a pairwise interaction energy defined by the standard Potts model <a class="el" href="citelist.html#CITEREF_cgal:l-mrfmi-09">[5]</a> :</p>
<p class="formulaDsp">
\[ E(x) = \sum_{i = 1..N} E_{di}(x_i) + \gamma \sum_{i \sim j} \mathbf{1}_{x_i \neq x_j} \]
</p>
</li>
</ul>
<p>where \(\gamma&gt;0\) is the parameter of the Potts model that quantifies the strengh of the regularization, \(i \sim j\) represents the pairs of neighboring items and \(\mathbf{1}_{\{.\}}\) the characteristic function.</p>
<p>A <em>graph cut</em> based algorithm (alpha expansion) is used to quickly reach an approximate solution close to the global optimum of this energy.</p>
<p>This method allows to consistently segment the input data set in piecewise constant parts and to correct large wrongly classified clusters. Increasing \(\gamma\) produces more regular result with a constant computation time.</p>
<p>To speed up computations, the input domain can be subdivided into smaller subsets such that several smaller graph cuts are applied instead of a big one. The computation of these smaller graph cuts can be done in parallel. Increasing the number of subsets allows for faster computation times but can also reduce the quality of the results.</p>
<p>The following snippet shows how to classify points using a graph cut regularization providing a model of <code><a class="el" href="classCGAL_1_1Classification_1_1NeighborQuery.html" title="Concept describing a neighbor query used for classification. ">CGAL::Classification::NeighborQuery</a></code>, a strengh parameter \(\gamma\) and a number of subdivisions.</p>
<div class="fragment"><div class="line">  t.start();</div><div class="line">  Classification::classify_with_graphcut&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (pts, Pmap(), labels, classifier,</div><div class="line">     neighborhood.k_neighbor_query(12),</div><div class="line">     0.2f, 4, label_indices);</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classification with graphcut performed in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div></div><!-- fragment --> <h1><a class="anchor" id="Classification_evaluation"></a>
Evaluation</h1>
<p>The class <a class="el" href="classCGAL_1_1Classification_1_1Evaluation.html">Evaluation</a> allows users to evaluate the reliability of the classification with respect to a provided ground truth. The following measurements are available:</p>
<ul>
<li><a class="el" href="classCGAL_1_1Classification_1_1Evaluation.html#a040d137ec34590b2e2364d42264a901e">precision()</a> computes, for one label, the ratio of true positives over the total number of detected positives;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Evaluation.html#a40cd95adcd26d7b16cd6daaf56dfba27">recall()</a> computes, for one label, the ratio of true positives over the total number of provided inliers of this label;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Evaluation.html#a8de98452ad8bafc018b18d75e1e55a47">f1_score()</a> is the harmonic mean of precision and recall;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Evaluation.html#a2d4513d5a5256fda156d5b4fd1ddfbe7">intersection_over_union()</a> computes the ratio of true positives over the union of the detected positives and of the provided inliers;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Evaluation.html#ac2c9a217607e34f38541d10adc77b336">accuracy()</a> computes the ratio of all true positives over the total number of provided inliers;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Evaluation.html#aca8eaa6bf226fc44a3740b376acce804">mean_f1_score()</a>;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Evaluation.html#aae3761d28e2b0585c8715edbff790c14">mean_intersection_over_union()</a>.</li>
</ul>
<p>All these values range from 0 (poor quality) to 1 (perfect quality).</p>
<h1><a class="anchor" id="Classification_examples"></a>
Full Examples</h1>
<h2><a class="anchor" id="Classification_example_general"></a>
Simple Point Set Classification</h2>
<p>The following example:</p>
<ul>
<li>reads an input file (LIDAR point set in PLY format);</li>
<li>computes useful structures from this input;</li>
<li>computes features from the input and the precomputed structures;</li>
<li>defines 3 labels (<em>vegetation</em>, <em>ground</em> and <em>roof</em>);</li>
<li>sets up the classification classifier <a class="el" href="classCGAL_1_1Classification_1_1Sum__of__weighted__features__classifier.html">Sum_of_weighted_features_classifier</a>;</li>
<li>classifies the point set with the 3 different methods (this is for the sake of the example: each method overwrites the previous result, users should only call one of the methods);</li>
<li>saves the result in a colored PLY format.</li>
</ul>
<p><br />
<b>File</b> <a class="el" href="Classification_2example_classification_8cpp-example.html">Classification/example_classification.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#if defined (_MSC_VER) &amp;&amp; !defined (_WIN64)</span></div><div class="line"><span class="preprocessor">#pragma warning(disable:4244) // boost::number_distance::distance()</span></div><div class="line">                              <span class="comment">// converts 64 to 32 bits integers</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Classification.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/bounding_box.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/tags.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_ply_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a> Concurrency_tag;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::Iso_cuboid_3</a> Iso_cuboid_3;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> CGAL::Identity_property_map&lt;Point&gt; Pmap;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Classification = <a class="code" href="namespaceCGAL_1_1Classification.html">CGAL::Classification</a>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Sum_of_weighted_features_classifier Classifier;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Planimetric_grid&lt;Kernel, Point_range, Pmap&gt;             Planimetric_grid;</div><div class="line"><span class="keyword">typedef</span> Classification::Point_set_neighborhood&lt;Kernel, Point_range, Pmap&gt;       Neighborhood;</div><div class="line"><span class="keyword">typedef</span> Classification::Local_eigen_analysis                                    Local_eigen_analysis;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Label_handle                                            Label_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_handle                                          Feature_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Label_set                                               Label_set;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_set                                             Feature_set;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Feature::Distance_to_plane&lt;Point_range, Pmap&gt;           Distance_to_plane;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature::Elevation&lt;Kernel, Point_range, Pmap&gt;           Elevation;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature::Vertical_dispersion&lt;Kernel, Point_range, Pmap&gt; Dispersion;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/b9.ply"</span>);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Reading input"</span> &lt;&lt; std::endl;</div><div class="line">  std::vector&lt;Point&gt; pts;</div><div class="line">  <span class="keywordflow">if</span> (!(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(filename, std::back_inserter(pts),</div><div class="line">                              <span class="comment">// the PLY reader expects a binary file by default</span></div><div class="line">                              CGAL::parameters::use_binary_mode(<span class="keyword">false</span>))))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read "</span> &lt;&lt; filename &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">float</span> grid_resolution = 0.34f;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> number_of_neighbors = 6;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Computing useful structures"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  Iso_cuboid_3 bbox = CGAL::bounding_box (pts.begin(), pts.end());</div><div class="line"></div><div class="line">  Planimetric_grid grid (pts, Pmap(), bbox, grid_resolution);</div><div class="line">  Neighborhood neighborhood (pts, Pmap());</div><div class="line">  Local_eigen_analysis eigen</div><div class="line">    = Local_eigen_analysis::create_from_point_set</div><div class="line">    (pts, Pmap(), neighborhood.k_neighbor_query(number_of_neighbors));</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">float</span> radius_neighbors = 1.7f;</div><div class="line">  <span class="keywordtype">float</span> radius_dtm = 15.0f;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Computing features"</span> &lt;&lt; std::endl;</div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  features.begin_parallel_additions(); <span class="comment">// No effect in sequential mode</span></div><div class="line"></div><div class="line">  Feature_handle distance_to_plane = features.add&lt;Distance_to_plane&gt; (pts, Pmap(), eigen);</div><div class="line">  Feature_handle dispersion = features.add&lt;Dispersion&gt; (pts, Pmap(), grid,</div><div class="line">                                                        radius_neighbors);</div><div class="line">  Feature_handle elevation = features.add&lt;Elevation&gt; (pts, Pmap(), grid,</div><div class="line">                                                      radius_dtm);</div><div class="line"></div><div class="line">  features.end_parallel_additions(); <span class="comment">// No effect in sequential mode</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  Label_set labels;</div><div class="line"></div><div class="line">  <span class="comment">// Init name only</span></div><div class="line">  Label_handle ground = labels.add (<span class="stringliteral">"ground"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Init name and color</span></div><div class="line">  Label_handle vegetation = labels.add (<span class="stringliteral">"vegetation"</span>, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a>(0,255,0));</div><div class="line"></div><div class="line">  <span class="comment">// Init name, Color and standard index (here, ASPRS building index)</span></div><div class="line">  Label_handle roof = labels.add (<span class="stringliteral">"roof"</span>, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a> (255, 0, 0), 6);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Setting weights"</span> &lt;&lt; std::endl;</div><div class="line">  Classifier classifier (labels, features);</div><div class="line">  classifier.set_weight (distance_to_plane, 6.75e-2f);</div><div class="line">  classifier.set_weight (dispersion, 5.45e-1f);</div><div class="line">  classifier.set_weight (elevation, 1.47e1f);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Setting effects"</span> &lt;&lt; std::endl;</div><div class="line">  classifier.set_effect (ground, distance_to_plane, Classifier::NEUTRAL);</div><div class="line">  classifier.set_effect (ground, dispersion, Classifier::NEUTRAL);</div><div class="line">  classifier.set_effect (ground, elevation, Classifier::PENALIZING);</div><div class="line"></div><div class="line">  classifier.set_effect (vegetation, distance_to_plane,  Classifier::FAVORING);</div><div class="line">  classifier.set_effect (vegetation, dispersion, Classifier::FAVORING);</div><div class="line">  classifier.set_effect (vegetation, elevation, Classifier::NEUTRAL);</div><div class="line"></div><div class="line">  classifier.set_effect (roof, distance_to_plane,  Classifier::NEUTRAL);</div><div class="line">  classifier.set_effect (roof, dispersion, Classifier::NEUTRAL);</div><div class="line">  classifier.set_effect (roof, elevation, Classifier::FAVORING);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Run classification</span></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classifying"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::vector&lt;int&gt; label_indices (pts.size(), -1);</div><div class="line"></div><div class="line">  CGAL::Real_timer t;</div><div class="line">  t.start();</div><div class="line">  Classification::classify&lt;CGAL::Parallel_if_available_tag&gt; (pts, labels, classifier, label_indices);</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Raw classification performed in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div><div class="line"></div><div class="line">  t.start();</div><div class="line">  Classification::classify_with_local_smoothing&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (pts, Pmap(), labels, classifier,</div><div class="line">     neighborhood.sphere_neighbor_query(radius_neighbors),</div><div class="line">     label_indices);</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classification with local smoothing performed in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div><div class="line"></div><div class="line">  t.start();</div><div class="line">  Classification::classify_with_graphcut&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (pts, Pmap(), labels, classifier,</div><div class="line">     neighborhood.k_neighbor_query(12),</div><div class="line">     0.2f, 4, label_indices);</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classification with graphcut performed in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save the output in a colored PLY format</span></div><div class="line"></div><div class="line">  std::vector&lt;unsigned char&gt; red, green, blue;</div><div class="line">  red.reserve(pts.size());</div><div class="line">  green.reserve(pts.size());</div><div class="line">  blue.reserve(pts.size());</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; pts.size(); ++ i)</div><div class="line">  {</div><div class="line">    Label_handle label = labels[std::size_t(label_indices[i])];</div><div class="line">    <span class="keywordtype">unsigned</span> r = 0, g = 0, b = 0;</div><div class="line">    <span class="keywordflow">if</span> (label == ground)</div><div class="line">    {</div><div class="line">      r = 245; g = 180; b = 0;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (label == vegetation)</div><div class="line">    {</div><div class="line">      r = 0; g = 255; b = 27;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (label == roof)</div><div class="line">    {</div><div class="line">      r = 255; g = 0; b = 170;</div><div class="line">    }</div><div class="line">    red.push_back(r);</div><div class="line">    green.push_back(g);</div><div class="line">    blue.push_back(b);</div><div class="line">  }</div><div class="line"></div><div class="line">  std::ofstream f (<span class="stringliteral">"classification.ply"</span>);</div><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3IOPly.html#gac1fd90a9d5266e631c68cb31bfe31516">CGAL::IO::write_PLY_with_properties</a></div><div class="line">    (f, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL.html#a266177f3e138c748f9906f7abb76320b">CGAL::make_range</a> (boost::counting_iterator&lt;std::size_t&gt;(0),</div><div class="line">                          boost::counting_iterator&lt;std::size_t&gt;(pts.size())),</div><div class="line">     <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3IOPly.html#ga241c6df9d93e26ec7254ef6366cb7e5b">CGAL::make_ply_point_writer</a> (CGAL::make_property_map(pts)),</div><div class="line">     std::make_pair(CGAL::make_property_map(red), CGAL::PLY_property&lt;unsigned char&gt;(<span class="stringliteral">"red"</span>)),</div><div class="line">     std::make_pair(CGAL::make_property_map(green), CGAL::PLY_property&lt;unsigned char&gt;(<span class="stringliteral">"green"</span>)),</div><div class="line">     std::make_pair(CGAL::make_property_map(blue), CGAL::PLY_property&lt;unsigned char&gt;(<span class="stringliteral">"blue"</span>)));</div><div class="line"></div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"All done"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Classification_example_feeature"></a>
Defining a Custom Feature</h2>
<p>The following example shows how to define a custom feature and how to integrate it in the CGAL classification framework.</p>
<p><br />
<b>File</b> <a class="el" href="Classification_2example_feature_8cpp-example.html">Classification/example_feature.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#if defined (_MSC_VER) &amp;&amp; !defined (_WIN64)</span></div><div class="line"><span class="preprocessor">#pragma warning(disable:4244) // boost::number_distance::distance()</span></div><div class="line">                              <span class="comment">// converts 64 to 32 bits integers</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Classification.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::Iso_cuboid_3</a> Iso_cuboid_3;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> CGAL::Identity_property_map&lt;Point&gt; Pmap;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Classification = <a class="code" href="namespaceCGAL_1_1Classification.html">CGAL::Classification</a>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Sum_of_weighted_features_classifier                      Classifier;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Point_set_neighborhood&lt;Kernel, Point_range, Pmap&gt;       Neighborhood;</div><div class="line"><span class="keyword">typedef</span> Classification::Local_eigen_analysis                                    Local_eigen_analysis;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Label_handle                                            Label_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_handle                                          Feature_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Label_set                                               Label_set;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_set                                             Feature_set;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Feature::Verticality&lt;Kernel&gt;                            Verticality;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// User-defined feature that identifies a specific area of the 3D</span></div><div class="line"><span class="comment">// space. This feature takes value 1 for points that lie inside the</span></div><div class="line"><span class="comment">// area and 0 for the others.</span></div><div class="line"><span class="keyword">class </span>My_feature : <span class="keyword">public</span> <a class="code" href="classCGAL_1_1Classification_1_1Feature__base.html">CGAL::Classification::Feature_base</a></div><div class="line">{</div><div class="line">  <span class="keyword">const</span> Point_range&amp; range;</div><div class="line">  <span class="keywordtype">double</span> xmin, xmax, ymin, ymax;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  My_feature (<span class="keyword">const</span> Point_range&amp; range,</div><div class="line">              <span class="keywordtype">double</span> xmin, <span class="keywordtype">double</span> xmax, <span class="keywordtype">double</span> ymin, <span class="keywordtype">double</span> ymax)</div><div class="line">    : range (range), xmin(xmin), xmax(xmax), ymin(ymin), ymax(ymax)</div><div class="line">  {</div><div class="line">    this-&gt;set_name (<span class="stringliteral">"my_feature"</span>);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">float</span> value (std::size_t pt_index)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (xmin &lt; range[pt_index].x() &amp;&amp; range[pt_index].x() &lt; xmax &amp;&amp;</div><div class="line">        ymin &lt; range[pt_index].y() &amp;&amp; range[pt_index].y() &lt; ymax)</div><div class="line">      <span class="keywordflow">return</span> 1.f;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <span class="keywordflow">return</span> 0.f;</div><div class="line">  }</div><div class="line"></div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::string filename (argc &gt; 1 ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/b9.ply"</span>));</div><div class="line">  std::vector&lt;Point&gt; pts;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Reading input"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">if</span> (!(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(filename, std::back_inserter(pts),</div><div class="line">                              <span class="comment">// the PLY reader expects a binary file by default</span></div><div class="line">                              CGAL::parameters::use_binary_mode(<span class="keyword">false</span>))))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read "</span> &lt;&lt; filename &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  Neighborhood neighborhood (pts, Pmap());</div><div class="line">  Local_eigen_analysis eigen</div><div class="line">    = Local_eigen_analysis::create_from_point_set (pts, Pmap(), neighborhood.k_neighbor_query(6));</div><div class="line"></div><div class="line">  Label_set labels;</div><div class="line">  Label_handle a = labels.add (<span class="stringliteral">"label_A"</span>);</div><div class="line">  Label_handle b = labels.add (<span class="stringliteral">"label_B"</span>);</div><div class="line"></div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Computing features"</span> &lt;&lt; std::endl;</div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  <span class="comment">// Feature that identifies points whose x coordinate is between -20</span></div><div class="line">  <span class="comment">// and 20 and whose y coordinate is between -15 and 15</span></div><div class="line">  Feature_handle my_feature = features.add&lt;My_feature&gt; (pts, -20., 20., -15., 15.);</div><div class="line"></div><div class="line"></div><div class="line">  Feature_handle verticality = features.add&lt;Verticality&gt; (pts, eigen);</div><div class="line"></div><div class="line">  Classifier classifier (labels, features);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Setting weights"</span> &lt;&lt; std::endl;</div><div class="line">  classifier.set_weight(verticality, 0.5);</div><div class="line">  classifier.set_weight(my_feature, 0.25);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Setting up labels"</span> &lt;&lt; std::endl;</div><div class="line">  classifier.set_effect (a, verticality, Classifier::FAVORING);</div><div class="line">  classifier.set_effect (a, my_feature, Classifier::FAVORING);</div><div class="line">  classifier.set_effect (b, verticality, Classifier::PENALIZING);</div><div class="line">  classifier.set_effect (b, my_feature, Classifier::PENALIZING);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classifying"</span> &lt;&lt; std::endl;</div><div class="line">  std::vector&lt;int&gt; label_indices(pts.size(), -1);</div><div class="line">  Classification::classify_with_graphcut&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (pts, Pmap(), labels, classifier,</div><div class="line">     neighborhood.k_neighbor_query(12),</div><div class="line">     0.5, 1, label_indices);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"All done"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Classification_example_training"></a>
Feature Generation and Training</h2>
<p>The following example:</p>
<ul>
<li>reads a point set with a training set (embedded as a PLY feature <em>label</em>);</li>
<li>automatically generates features on 5 scales;</li>
<li>trains the classifier <a class="el" href="classCGAL_1_1Classification_1_1Sum__of__weighted__features__classifier.html">Sum_of_weighted_features_classifier</a> using 800 trials;</li>
<li>runs the algorithm using the graphcut regularization;</li>
<li>prints some evaluation measurements;</li>
<li>saves the configuration of the classifier for further use.</li>
</ul>
<p><br />
<b>File</b> <a class="el" href="Classification_2example_generation_and_training_8cpp-example.html">Classification/example_generation_and_training.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#if defined (_MSC_VER) &amp;&amp; !defined (_WIN64)</span></div><div class="line"><span class="preprocessor">#pragma warning(disable:4244) // boost::number_distance::distance()</span></div><div class="line">                              <span class="comment">// converts 64 to 32 bits integers</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Classification.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3/IO.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> CGAL::Point_set_3&lt;Point&gt; Point_set;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::Iso_cuboid_3</a> Iso_cuboid_3;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Point_set::Point_map Pmap;</div><div class="line"><span class="keyword">typedef</span> Point_set::Property_map&lt;int&gt; Imap;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Classification = <a class="code" href="namespaceCGAL_1_1Classification.html">CGAL::Classification</a>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Label_handle                                            Label_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_handle                                          Feature_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Label_set                                               Label_set;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_set                                             Feature_set;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Sum_of_weighted_features_classifier                     Classifier;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Point_set_feature_generator&lt;Kernel, Point_set, Pmap&gt;    Feature_generator;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::string filename (argc &gt; 1 ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/b9_training.ply"</span>));</div><div class="line">  std::ifstream in (filename.c_str(), std::ios::binary);</div><div class="line">  Point_set pts;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Reading input"</span> &lt;&lt; std::endl;</div><div class="line">  in &gt;&gt; pts;</div><div class="line"></div><div class="line">  Imap label_map;</div><div class="line">  <span class="keywordtype">bool</span> lm_found = <span class="keyword">false</span>;</div><div class="line">  std::tie (label_map, lm_found) = pts.property_map&lt;<span class="keywordtype">int</span>&gt; (<span class="stringliteral">"label"</span>);</div><div class="line">  <span class="keywordflow">if</span> (!lm_found)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: \"label\" property not found in input file."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Generating features"</span> &lt;&lt; std::endl;</div><div class="line">  CGAL::Real_timer t;</div><div class="line">  t.start();</div><div class="line"></div><div class="line"></div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  std::size_t number_of_scales = 5;</div><div class="line">  Feature_generator generator (pts, pts.point_map(), number_of_scales);</div><div class="line"></div><div class="line">  features.begin_parallel_additions();</div><div class="line">  generator.generate_point_based_features (features);</div><div class="line">  features.end_parallel_additions();</div><div class="line"></div><div class="line"></div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; features.size() &lt;&lt; <span class="stringliteral">" feature(s) generated in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  Label_set labels = { <span class="stringliteral">"ground"</span>, <span class="stringliteral">"vegetation"</span>, <span class="stringliteral">"roof"</span> };</div><div class="line"></div><div class="line">  Classifier classifier (labels, features);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Training"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div><div class="line">  t.start();</div><div class="line">  classifier.train&lt;<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a>&gt; (pts.range(label_map), 800);</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  t.reset();</div><div class="line">  t.start();</div><div class="line">  std::vector&lt;int&gt; label_indices(pts.size(), -1);</div><div class="line">  Classification::classify_with_graphcut&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (pts, pts.point_map(), labels, classifier,</div><div class="line">     generator.neighborhood().k_neighbor_query(12),</div><div class="line">     0.2f, 10, label_indices);</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classification with graphcut done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Precision, recall, F1 scores and IoU:"</span> &lt;&lt; std::endl;</div><div class="line">  Classification::Evaluation evaluation (labels, pts.range(label_map), label_indices);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (Label_handle l : labels)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">" * "</span> &lt;&lt; l-&gt;name() &lt;&lt; <span class="stringliteral">": "</span></div><div class="line">              &lt;&lt; evaluation.precision(l) &lt;&lt; <span class="stringliteral">" ; "</span></div><div class="line">              &lt;&lt; evaluation.recall(l) &lt;&lt; <span class="stringliteral">" ; "</span></div><div class="line">              &lt;&lt; evaluation.f1_score(l) &lt;&lt; <span class="stringliteral">" ; "</span></div><div class="line">              &lt;&lt; evaluation.intersection_over_union(l) &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Accuracy = "</span> &lt;&lt; evaluation.accuracy() &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">"Mean F1 score = "</span> &lt;&lt; evaluation.mean_f1_score() &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">"Mean IoU = "</span> &lt;&lt; evaluation.mean_intersection_over_union() &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">  std::ofstream fconfig (<span class="stringliteral">"config.xml"</span>);</div><div class="line">  classifier.save_configuration (fconfig);</div><div class="line">  fconfig.close();</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"All done"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Classification_example_ethz_random_forest"></a>
ETHZ Random Forest</h2>
<p>The following example shows how to use the classifier <a class="el" href="classCGAL_1_1Classification_1_1ETHZ_1_1Random__forest__classifier.html">ETHZ::Random_forest_classifier</a> using an input training set.</p>
<p><br />
<b>File</b> <a class="el" href="Classification_2example_ethz_random_forest_8cpp-example.html">Classification/example_ethz_random_forest.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#if defined (_MSC_VER) &amp;&amp; !defined (_WIN64)</span></div><div class="line"><span class="preprocessor">#pragma warning(disable:4244) // boost::number_distance::distance()</span></div><div class="line">                              <span class="comment">// converts 64 to 32 bits integers</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Classification.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3/IO.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> CGAL::Point_set_3&lt;Point&gt; Point_set;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::Iso_cuboid_3</a> Iso_cuboid_3;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Point_set::Point_map Pmap;</div><div class="line"><span class="keyword">typedef</span> Point_set::Property_map&lt;int&gt; Imap;</div><div class="line"><span class="keyword">typedef</span> Point_set::Property_map&lt;unsigned char&gt; UCmap;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Classification = <a class="code" href="namespaceCGAL_1_1Classification.html">CGAL::Classification</a>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Label_handle                                            Label_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_handle                                          Feature_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Label_set                                               Label_set;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_set                                             Feature_set;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Point_set_feature_generator&lt;Kernel, Point_set, Pmap&gt;    Feature_generator;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::string filename = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/b9_training.ply"</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1)</div><div class="line">    filename = argv[1];</div><div class="line"></div><div class="line">  std::ifstream in (filename.c_str(), std::ios::binary);</div><div class="line">  Point_set pts;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Reading input"</span> &lt;&lt; std::endl;</div><div class="line">  in &gt;&gt; pts;</div><div class="line"></div><div class="line">  Imap label_map;</div><div class="line">  <span class="keywordtype">bool</span> lm_found = <span class="keyword">false</span>;</div><div class="line">  std::tie (label_map, lm_found) = pts.property_map&lt;<span class="keywordtype">int</span>&gt; (<span class="stringliteral">"label"</span>);</div><div class="line">  <span class="keywordflow">if</span> (!lm_found)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: \"label\" property not found in input file."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Generating features"</span> &lt;&lt; std::endl;</div><div class="line">  CGAL::Real_timer t;</div><div class="line">  t.start();</div><div class="line">  Feature_generator generator (pts, pts.point_map(),</div><div class="line">                               5);  <span class="comment">// using 5 scales</span></div><div class="line"></div><div class="line">  features.begin_parallel_additions();</div><div class="line">  generator.generate_point_based_features (features);</div><div class="line">  features.end_parallel_additions();</div><div class="line"></div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Add labels</span></div><div class="line">  Label_set labels;</div><div class="line">  Label_handle ground = labels.add (<span class="stringliteral">"ground"</span>);</div><div class="line">  Label_handle vegetation = labels.add (<span class="stringliteral">"vegetation"</span>);</div><div class="line">  Label_handle roof = labels.add (<span class="stringliteral">"roof"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Check if ground truth is valid for this label set</span></div><div class="line">  <span class="keywordflow">if</span> (!labels.is_valid_ground_truth (pts.range(label_map), <span class="keyword">true</span>))</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line"></div><div class="line">  std::vector&lt;int&gt; label_indices(pts.size(), -1);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Using ETHZ Random Forest Classifier"</span> &lt;&lt; std::endl;</div><div class="line">  Classification::ETHZ::Random_forest_classifier classifier (labels, features);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Training"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div><div class="line">  t.start();</div><div class="line">  classifier.train (pts.range(label_map));</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  t.reset();</div><div class="line">  t.start();</div><div class="line">  Classification::classify_with_graphcut&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (pts, pts.point_map(), labels, classifier,</div><div class="line">     generator.neighborhood().k_neighbor_query(12),</div><div class="line">     0.2f, 1, label_indices);</div><div class="line">  t.stop();</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classification with graphcut done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Precision, recall, F1 scores and IoU:"</span> &lt;&lt; std::endl;</div><div class="line">  Classification::Evaluation evaluation (labels, pts.range(label_map), label_indices);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (Label_handle l : labels)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">" * "</span> &lt;&lt; l-&gt;name() &lt;&lt; <span class="stringliteral">": "</span></div><div class="line">              &lt;&lt; evaluation.precision(l) &lt;&lt; <span class="stringliteral">" ; "</span></div><div class="line">              &lt;&lt; evaluation.recall(l) &lt;&lt; <span class="stringliteral">" ; "</span></div><div class="line">              &lt;&lt; evaluation.f1_score(l) &lt;&lt; <span class="stringliteral">" ; "</span></div><div class="line">              &lt;&lt; evaluation.intersection_over_union(l) &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Accuracy = "</span> &lt;&lt; evaluation.accuracy() &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">"Mean F1 score = "</span> &lt;&lt; evaluation.mean_f1_score() &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">"Mean IoU = "</span> &lt;&lt; evaluation.mean_intersection_over_union() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Color point set according to class</span></div><div class="line">  UCmap red = pts.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"red"</span>, 0).first;</div><div class="line">  UCmap green = pts.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"green"</span>, 0).first;</div><div class="line">  UCmap blue = pts.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"blue"</span>, 0).first;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; label_indices.size(); ++ i)</div><div class="line">  {</div><div class="line">    label_map[i] = label_indices[i]; <span class="comment">// update label map with computed classification</span></div><div class="line"></div><div class="line">    Label_handle label = labels[label_indices[i]];</div><div class="line">    <span class="keyword">const</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a>&amp; color = label-&gt;color();</div><div class="line">    red[i] = color.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html#af428aec48cc6ce23776b5f8cdf2a7883">red</a>();</div><div class="line">    green[i] = color.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html#afc04b32226660e92c55c5855d7ae0c5f">green</a>();</div><div class="line">    blue[i] = color.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html#aee7a7d6b78b2045840c4a292c26500df">blue</a>();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Save configuration for later use</span></div><div class="line">  std::ofstream fconfig (<span class="stringliteral">"ethz_random_forest.bin"</span>, std::ios_base::binary);</div><div class="line">  classifier.save_configuration(fconfig);</div><div class="line"></div><div class="line">  <span class="comment">// Write result</span></div><div class="line">  std::ofstream f (<span class="stringliteral">"classification.ply"</span>);</div><div class="line">  f.precision(18);</div><div class="line">  f &lt;&lt; pts;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"All done"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Classification_example_opencv_random_forest"></a>
OpenCV Random Forest</h2>
<p>The following example shows how to use the classifier <a class="el" href="classCGAL_1_1Classification_1_1OpenCV_1_1Random__forest__classifier.html">OpenCV::Random_forest_classifier</a> using an input training set.</p>
<p><br />
<b>File</b> <a class="el" href="Classification_2example_opencv_random_forest_8cpp-example.html">Classification/example_opencv_random_forest.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#if defined (_MSC_VER) &amp;&amp; !defined (_WIN64)</span></div><div class="line"><span class="preprocessor">#pragma warning(disable:4244) // boost::number_distance::distance()</span></div><div class="line">                              <span class="comment">// converts 64 to 32 bits integers</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Classification.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3/IO.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> CGAL::Point_set_3&lt;Point&gt; Point_set;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::Iso_cuboid_3</a> Iso_cuboid_3;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Point_set::Point_map Pmap;</div><div class="line"><span class="keyword">typedef</span> Point_set::Property_map&lt;int&gt; Imap;</div><div class="line"><span class="keyword">typedef</span> Point_set::Property_map&lt;unsigned char&gt; UCmap;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Classification = <a class="code" href="namespaceCGAL_1_1Classification.html">CGAL::Classification</a>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Label_handle                                            Label_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_handle                                          Feature_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Label_set                                               Label_set;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_set                                             Feature_set;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Point_set_feature_generator&lt;Kernel, Point_set, Pmap&gt;    Feature_generator;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::string filename = (argc &gt; 1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/b9_training.ply"</span>);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Reading input"</span> &lt;&lt; std::endl;</div><div class="line">  std::ifstream in (filename.c_str(), std::ios::binary);</div><div class="line">  Point_set pts;</div><div class="line">  in &gt;&gt; pts;</div><div class="line"></div><div class="line">  Imap label_map;</div><div class="line">  <span class="keywordtype">bool</span> lm_found = <span class="keyword">false</span>;</div><div class="line">  std::tie (label_map, lm_found) = pts.property_map&lt;<span class="keywordtype">int</span>&gt; (<span class="stringliteral">"label"</span>);</div><div class="line">  <span class="keywordflow">if</span> (!lm_found)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: \"label\" property not found in input file."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Generating features"</span> &lt;&lt; std::endl;</div><div class="line">  CGAL::Real_timer t;</div><div class="line">  t.start();</div><div class="line">  Feature_generator generator (pts, pts.point_map(),</div><div class="line">                               5);  <span class="comment">// using 5 scales</span></div><div class="line"></div><div class="line">  features.begin_parallel_additions();</div><div class="line">  generator.generate_point_based_features (features);</div><div class="line">  features.end_parallel_additions();</div><div class="line"></div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Add labels</span></div><div class="line">  Label_set labels;</div><div class="line">  Label_handle ground = labels.add (<span class="stringliteral">"ground"</span>);</div><div class="line">  Label_handle vegetation = labels.add (<span class="stringliteral">"vegetation"</span>);</div><div class="line">  Label_handle roof = labels.add (<span class="stringliteral">"roof"</span>);</div><div class="line"></div><div class="line">  std::vector&lt;int&gt; label_indices(pts.size(), -1);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Using OpenCV Random Forest Classifier"</span> &lt;&lt; std::endl;</div><div class="line">  Classification::OpenCV::Random_forest_classifier classifier (labels, features);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Training"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div><div class="line">  t.start();</div><div class="line">  classifier.train (pts.range(label_map));</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  t.reset();</div><div class="line">  t.start();</div><div class="line">  Classification::classify_with_graphcut&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (pts, pts.point_map(), labels, classifier,</div><div class="line">     generator.neighborhood().k_neighbor_query(12),</div><div class="line">     0.2f, 1, label_indices);</div><div class="line">  t.stop();</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classification with graphcut done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Precision, recall, F1 scores and IoU:"</span> &lt;&lt; std::endl;</div><div class="line">  Classification::Evaluation evaluation (labels, pts.range(label_map), label_indices);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (Label_handle l : labels)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">" * "</span> &lt;&lt; l-&gt;name() &lt;&lt; <span class="stringliteral">": "</span></div><div class="line">              &lt;&lt; evaluation.precision(l) &lt;&lt; <span class="stringliteral">" ; "</span></div><div class="line">              &lt;&lt; evaluation.recall(l) &lt;&lt; <span class="stringliteral">" ; "</span></div><div class="line">              &lt;&lt; evaluation.f1_score(l) &lt;&lt; <span class="stringliteral">" ; "</span></div><div class="line">              &lt;&lt; evaluation.intersection_over_union(l) &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Accuracy = "</span> &lt;&lt; evaluation.accuracy() &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">"Mean F1 score = "</span> &lt;&lt; evaluation.mean_f1_score() &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">"Mean IoU = "</span> &lt;&lt; evaluation.mean_intersection_over_union() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Color point set according to class</span></div><div class="line">  UCmap red = pts.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"red"</span>, 0).first;</div><div class="line">  UCmap green = pts.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"green"</span>, 0).first;</div><div class="line">  UCmap blue = pts.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"blue"</span>, 0).first;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; label_indices.size(); ++ i)</div><div class="line">  {</div><div class="line">    label_map[i] = label_indices[i]; <span class="comment">// update label map with computed classification</span></div><div class="line"></div><div class="line">    Label_handle label = labels[label_indices[i]];</div><div class="line">    <span class="keyword">const</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a>&amp; color = label-&gt;color();</div><div class="line">    red[i] = color.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html#af428aec48cc6ce23776b5f8cdf2a7883">red</a>();</div><div class="line">    green[i] = color.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html#afc04b32226660e92c55c5855d7ae0c5f">green</a>();</div><div class="line">    blue[i] = color.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html#aee7a7d6b78b2045840c4a292c26500df">blue</a>();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Write result</span></div><div class="line">  std::ofstream f (<span class="stringliteral">"classification.ply"</span>);</div><div class="line">  f.precision(18);</div><div class="line">  f &lt;&lt; pts;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"All done"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Classification_example_mesh"></a>
Mesh Classification</h2>
<p>The following example:</p>
<ul>
<li>reads a mesh in OFF format;</li>
<li>automatically generates features on 5 scales;</li>
<li>loads a configuration file for classifier <a class="el" href="classCGAL_1_1Classification_1_1ETHZ_1_1Random__forest__classifier.html">ETHZ::Random_forest_classifier</a>;</li>
<li>runs the algorithm using the graphcut regularization.</li>
</ul>
<p><br />
<b>File</b> <a class="el" href="Classification_2example_mesh_classification_8cpp-example.html">Classification/example_mesh_classification.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#if defined (_MSC_VER) &amp;&amp; !defined (_WIN64)</span></div><div class="line"><span class="preprocessor">#pragma warning(disable:4244) // boost::number_distance::distance()</span></div><div class="line">                              <span class="comment">// converts 64 to 32 bits integers</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Classification.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> CGAL::Surface_mesh&lt;Point&gt; Mesh;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Classification = <a class="code" href="namespaceCGAL_1_1Classification.html">CGAL::Classification</a>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Label_handle                                            Label_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_handle                                          Feature_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Label_set                                               Label_set;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_set                                             Feature_set;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Face_descriptor_to_center_of_mass_map&lt;Mesh&gt;             Face_point_map;</div><div class="line"><span class="keyword">typedef</span> Classification::Face_descriptor_to_face_descriptor_with_bbox_map&lt;Mesh&gt;  Face_with_bbox_map;</div><div class="line"><span class="keyword">typedef</span> Classification::Mesh_feature_generator&lt;Kernel, Mesh, Face_point_map&gt;    Feature_generator;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::string filename = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/b9_mesh.off"</span>);</div><div class="line">  std::string filename_config = <span class="stringliteral">"data/b9_mesh_config.bin"</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1)</div><div class="line">    filename = argv[1];</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 2)</div><div class="line">    filename_config = argv[2];</div><div class="line"></div><div class="line">  Mesh mesh;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLIOFct.html#ga49f5b5e6fbfcbfaaac7604c88e10915c">CGAL::IO::read_polygon_mesh</a>(filename, mesh,</div><div class="line">                                  <span class="comment">// the PLY reader expects a binary file by default</span></div><div class="line">                                  CGAL::parameters::use_binary_mode(<span class="keyword">false</span>)))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Generating features"</span> &lt;&lt; std::endl;</div><div class="line">  CGAL::Real_timer t;</div><div class="line">  t.start();</div><div class="line"></div><div class="line"></div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  Face_point_map face_point_map (&amp;mesh); <span class="comment">// Associates each face to its center of mass</span></div><div class="line"></div><div class="line">  std::size_t number_of_scales = 5;</div><div class="line">  Feature_generator generator (mesh, face_point_map, number_of_scales);</div><div class="line"></div><div class="line">  features.begin_parallel_additions();</div><div class="line">  generator.generate_point_based_features (features); <span class="comment">// Features that consider the mesh as a point set</span></div><div class="line">  generator.generate_face_based_features (features);  <span class="comment">// Features computed directly on mesh faces</span></div><div class="line">  features.end_parallel_additions();</div><div class="line"></div><div class="line"></div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  Label_set labels = { <span class="stringliteral">"ground"</span>, <span class="stringliteral">"vegetation"</span>, <span class="stringliteral">"roof"</span> };</div><div class="line"></div><div class="line">  std::vector&lt;int&gt; label_indices(mesh.number_of_faces(), -1);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Using ETHZ Random Forest Classifier"</span> &lt;&lt; std::endl;</div><div class="line">  Classification::ETHZ::Random_forest_classifier classifier (labels, features);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Loading configuration"</span> &lt;&lt; std::endl;</div><div class="line">  std::ifstream in_config (filename_config, std::ios_base::in | std::ios_base::binary);</div><div class="line">  classifier.load_configuration (in_config);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classifying with graphcut"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div><div class="line">  t.start();</div><div class="line">  Classification::classify_with_graphcut&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (mesh.faces(), Face_with_bbox_map(&amp;mesh), labels, classifier,</div><div class="line">     generator.neighborhood().n_ring_neighbor_query(2),</div><div class="line">     0.2f, 1, label_indices);</div><div class="line">  t.stop();</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classification with graphcut done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Classification_example_cluster"></a>
Cluster Classification</h2>
<p>The following example:</p>
<ul>
<li>reads a point set in PLY format;</li>
<li>estimates the normal vectors of the point set;</li>
<li>automatically generates pointwise features on 5 scales;</li>
<li>detects plane using the algorithm <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Region__growing.html">CGAL::Shape_detection::Region_growing</a></code>;</li>
<li>creates <a class="el" href="classCGAL_1_1Classification_1_1Cluster.html">Cluster</a> objects from these detected planes;</li>
<li>computes cluster features from the pointwise features;</li>
<li>loads a configuration file for classifier <a class="el" href="classCGAL_1_1Classification_1_1ETHZ_1_1Random__forest__classifier.html">ETHZ::Random_forest_classifier</a>;</li>
<li>runs the algorithm using the raw algorithm.</li>
</ul>
<p><br />
<b>File</b> <a class="el" href="Classification_2example_cluster_classification_8cpp-example.html">Classification/example_cluster_classification.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#if defined (_MSC_VER) &amp;&amp; !defined (_WIN64)</span></div><div class="line"><span class="preprocessor">#pragma warning(disable:4244) // boost::number_distance::distance()</span></div><div class="line">                              <span class="comment">// converts 64 to 32 bits integers</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/iterator/function_output_iterator.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Classification.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3/IO.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/jet_estimate_normals.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/Region__growing_8h.html">CGAL/Shape_detection/Region_growing.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::Iso_cuboid_3</a>           Iso_cuboid_3;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> CGAL::Point_set_3&lt;Point&gt; Point_set;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Point_set::Point_map                   Pmap;</div><div class="line"><span class="keyword">typedef</span> Point_set::Vector_map                  Vmap;</div><div class="line"><span class="keyword">typedef</span> Point_set::Property_map&lt;int&gt;           Imap;</div><div class="line"><span class="keyword">typedef</span> Point_set::Property_map&lt;unsigned char&gt; UCmap;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Point__set_1_1Sphere__neighbor__query.html">CGAL::Shape_detection::Point_set::Sphere_neighbor_query&lt;Kernel, Point_set, Pmap&gt;</a>                Neighbor_query;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Point__set_1_1Least__squares__plane__fit__region.html">CGAL::Shape_detection::Point_set::Least_squares_plane_fit_region&lt;Kernel, Point_set, Pmap, Vmap&gt;</a> Region_type;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Region__growing.html">CGAL::Shape_detection::Region_growing&lt;Point_set, Neighbor_query, Region_type&gt;</a>                   Region_growing;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Classification = <a class="code" href="namespaceCGAL_1_1Classification.html">CGAL::Classification</a>;</div><div class="line"><span class="keyword">namespace </span>Feature = <a class="code" href="namespaceCGAL_1_1Classification_1_1Feature.html">CGAL::Classification::Feature</a>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Label_handle   Label_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_handle Feature_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Label_set      Label_set;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_set    Feature_set;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Local_eigen_analysis                                 Local_eigen_analysis;</div><div class="line"><span class="keyword">typedef</span> Classification::Point_set_feature_generator&lt;Kernel, Point_set, Pmap&gt; Feature_generator;</div><div class="line"><span class="keyword">typedef</span> Classification::Cluster&lt;Point_set, Pmap&gt;                             Cluster;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::string filename        = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/b9.ply"</span>);</div><div class="line">  std::string filename_config = <span class="stringliteral">"data/b9_clusters_config.bin"</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1)</div><div class="line">    filename = argv[1];</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 2)</div><div class="line">    filename_config = argv[2];</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Reading input"</span> &lt;&lt; std::endl;</div><div class="line">  Point_set pts;</div><div class="line">  <span class="keywordflow">if</span>(!(CGAL::IO::read_point_set(filename, pts,</div><div class="line">                                <span class="comment">// the PLY reader expects a binary file by default</span></div><div class="line">                                CGAL::parameters::use_binary_mode(<span class="keyword">true</span>))))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read "</span> &lt;&lt; filename &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Estimating normals"</span> &lt;&lt; std::endl;</div><div class="line">  CGAL::Real_timer t;</div><div class="line">  t.start();</div><div class="line">  pts.add_normal_map();</div><div class="line">  CGAL::jet_estimate_normals&lt;CGAL::Parallel_if_available_tag&gt; (pts, 12);</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div><div class="line"></div><div class="line">  Feature_set pointwise_features;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Generating pointwise features"</span> &lt;&lt; std::endl;</div><div class="line">  t.start();</div><div class="line">  Feature_generator generator (pts, pts.point_map(), 5); <span class="comment">// using 5 scales</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef CGAL_LINKED_WITH_TBB</span></div><div class="line">  pointwise_features.begin_parallel_additions();</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">  generator.generate_point_based_features (pointwise_features);</div><div class="line"></div><div class="line">  <span class="comment">// Generator should only be used with variables defined at the scope</span></div><div class="line">  <span class="comment">// of the generator object, thus we instantiate the normal map</span></div><div class="line">  <span class="comment">// outside of the function</span></div><div class="line">  Vmap normal_map = pts.normal_map();</div><div class="line">  generator.generate_normal_based_features (pointwise_features, normal_map);</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef CGAL_LINKED_WITH_TBB</span></div><div class="line">  pointwise_features.end_parallel_additions();</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Detecting planes and creating clusters"</span> &lt;&lt; std::endl;</div><div class="line">  t.start();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> search_sphere_radius  = 1.0;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> max_distance_to_plane = 1.0;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> max_accepted_angle    = 25.0;</div><div class="line">  <span class="keyword">const</span> std::size_t min_region_size  = 10;</div><div class="line"></div><div class="line">  Neighbor_query neighbor_query (</div><div class="line">    pts, CGAL::parameters::sphere_radius(search_sphere_radius)</div><div class="line">                          .point_map(pts.point_map()));</div><div class="line">  Region_type region_type(</div><div class="line">    pts, CGAL::parameters::maximum_distance(max_distance_to_plane)</div><div class="line">                          .maximum_angle(max_accepted_angle)</div><div class="line">                          .minimum_region_size(min_region_size)</div><div class="line">                          .point_map(pts.point_map())</div><div class="line">                          .normal_map(pts.normal_map()));</div><div class="line">  Region_growing region_growing (</div><div class="line">    pts, neighbor_query, region_type);</div><div class="line"></div><div class="line">  std::vector&lt;Cluster&gt; clusters;</div><div class="line">  region_growing.detect</div><div class="line">    (boost::make_function_output_iterator</div><div class="line">     ([&amp;](<span class="keyword">const</span> std::vector&lt;std::size_t&gt;&amp; region) -&gt; <span class="keywordtype">void</span> {</div><div class="line"></div><div class="line">        <span class="comment">// Create a new cluster.</span></div><div class="line">        Classification::Cluster&lt;Point_set, Pmap&gt; cluster (pts, pts.point_map());</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> std::size_t idx : region)</div><div class="line">          cluster.insert(idx);</div><div class="line">        clusters.push_back(cluster);</div><div class="line">      }));</div><div class="line"></div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; clusters.size() &lt;&lt; <span class="stringliteral">" clusters created in "</span></div><div class="line">            &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div><div class="line"></div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Computing cluster features"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">  Local_eigen_analysis eigen = Local_eigen_analysis::create_from_point_clusters (clusters);</div><div class="line"></div><div class="line"></div><div class="line">  t.start();</div><div class="line"></div><div class="line"></div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  <span class="comment">// First, compute means of features.</span></div><div class="line">  features.begin_parallel_additions();</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; pointwise_features.size(); ++ i)</div><div class="line">    features.add&lt;Feature::Cluster_mean_of_feature&gt; (clusters, pointwise_features[i]);</div><div class="line">  features.end_parallel_additions();</div><div class="line"></div><div class="line">  <span class="comment">// Then, compute variances of features (and remaining cluster features).</span></div><div class="line">  features.begin_parallel_additions();</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; pointwise_features.size(); ++ i)</div><div class="line">    features.add&lt;Feature::Cluster_variance_of_feature&gt; (clusters,</div><div class="line">                                                        pointwise_features[i], <span class="comment">// i^th feature</span></div><div class="line">                                                        features[i]);          <span class="comment">// mean of i^th feature</span></div><div class="line"></div><div class="line">  features.add&lt;Feature::Cluster_size&gt; (clusters);</div><div class="line">  features.add&lt;Feature::Cluster_vertical_extent&gt; (clusters);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; 3; ++ i)</div><div class="line">    features.add&lt;Feature::Eigenvalue&gt; (clusters, eigen, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(i));</div><div class="line"></div><div class="line">  features.end_parallel_additions();</div><div class="line"></div><div class="line"></div><div class="line">  t.stop();</div><div class="line"></div><div class="line">  Label_set labels = { <span class="stringliteral">"ground"</span>, <span class="stringliteral">"vegetation"</span>, <span class="stringliteral">"roof"</span> };</div><div class="line"></div><div class="line">  std::vector&lt;int&gt; label_indices(clusters.size(), -1);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Using ETHZ Random Forest Classifier"</span> &lt;&lt; std::endl;</div><div class="line">  Classification::ETHZ::Random_forest_classifier classifier (labels, features);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Loading configuration"</span> &lt;&lt; std::endl;</div><div class="line">  std::ifstream in_config (filename_config, std::ios_base::in | std::ios_base::binary);</div><div class="line">  classifier.load_configuration (in_config);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classifying"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div><div class="line">  t.start();</div><div class="line">  Classification::classify&lt;CGAL::Parallel_if_available_tag&gt; (clusters, labels, classifier, label_indices);</div><div class="line">  t.stop();</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classification done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Classification_history"></a>
History</h1>
<p>This package is based on a research code by <a href="https://www-sop.inria.fr/members/Florent.Lafarge/">Florent Lafarge</a> that was generalized, extended and packaged by <a href="http://geometryfactory.com/who-we-are/">Simon Giraudot</a> in CGAL 4.12. Classification of surface meshes and of clusters were introduced in CGAL 4.13. The Neural Network classifier was introduced in CGAL 4.14. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Jul 5 2022 09:51:36 for CGAL 5.6 - Classification by
    <a href="https://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>
</html><html xmlns="http://www.w3.org/1999/xhtml"><body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.6 - Classification
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Classification"></a> </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Authors</dt><dd>Simon Giraudot, Florent Lafarge</dd></dl>
<p>This component implements the algorithm described in <a class="el" href="citelist.html#CITEREF_cgal:lm-clscm-12">[4]</a> (section 2), generalized to handle different types of data, multiple features and multiple labels. It classifies a data set into a user-defined set of labels, such as <em>ground</em>, <em>vegetation</em> and <em>buildings</em>. A flexible API is provided so that users can classify any type of data which they can index and for which they can compute relevant features, compute their own local features on the input data set and define their own labels.</p>
<h1><a class="anchor" id="Classification_Organization"></a>
Package Organization</h1>
<p>Classification of data sets is achieved as follows (see Figure <a class="el" href="index.html#fig__Classification_organization_fig">Figure 84.1</a>):</p>
<ul>
<li>some analysis is performed on the input data set;</li>
<li>features are computed based on this analysis;</li>
<li>a set of labels (for example: <em>ground</em>, <em>building</em>, <em>vegetation</em>) is defined by the user;</li>
<li>a classifier is defined and trained: from the set of values taken by the features at an input item, it measures the likelihood of this item to belong to one label or another;</li>
<li>classification is computed itemwise using the classifier;</li>
<li>additional regularization can be used by smoothing either locally or globally through a <em>graph cut</em> <a class="el" href="citelist.html#CITEREF_Boykov2001FastApproximate">[1]</a> approach.</li>
</ul>
<p><a class="anchor" id="fig__Classification_organization_fig"></a></p><div class="image">
<object type="image/svg+xml" data="organization.svg">organization.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Classification_organization_fig">Figure 84.1</a> Organization of the package.  </div> <br /> 
<p>This package is designed to be easily extended by users: more specifically, features and labels can be defined by users to handle any data they need to classify.</p>
<p>Currently, CGAL provides data structures to handle classification of point sets, surface meshes and clusters.</p>
<h1><a class="anchor" id="Classification_structures"></a>
Common Data Structures</h1>
<h2><a class="anchor" id="Classification_labels"></a>
Label Set</h2>
<p>A label represents how an item should be classified, for example: <em>vegetation</em>, <em>building</em>, <em>road</em>, etc. In CGAL, a label has a name, an index (in a label set), a standard index (for example, the index of the label in the ASPRS standard) and a color. It is simply identified by a <a class="el" href="classCGAL_1_1Classification_1_1Label__handle.html">Label_handle</a>. Note that names, standard indices and colors are not used for identification: two labels in the same set can have the same name, standard index and color but not the same handle.</p>
<p>If labels are initialized with their names only, standard indices and colors can be deduced in some cases (see <a class="el" href="classCGAL_1_1Classification_1_1Label__set.html#afaa0d2e86c20b0c7ef19ce5e3f6b1104">Label_set::add()</a>).</p>
<p>The following code snippet shows how to add labels to the classification object:</p>
<div class="fragment"><div class="line"></div><div class="line">  Label_set labels;</div><div class="line"></div><div class="line">  <span class="comment">// Init name only</span></div><div class="line">  Label_handle ground = labels.add (<span class="stringliteral">"ground"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Init name and color</span></div><div class="line">  Label_handle vegetation = labels.add (<span class="stringliteral">"vegetation"</span>, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a>(0,255,0));</div><div class="line"></div><div class="line">  <span class="comment">// Init name, Color and standard index (here, ASPRS building index)</span></div><div class="line">  Label_handle roof = labels.add (<span class="stringliteral">"roof"</span>, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a> (255, 0, 0), 6);</div><div class="line"></div></div><!-- fragment --> <h2><a class="anchor" id="Classification_features"></a>
Feature Set</h2>
<p>Features are defined as scalar fields that associate each input item with a specific value. Note that in order to limit memory consumption, we use the type <code>float</code> for these scalar values (as well as for every floating point value in this package). A feature has a name and is identified by a <a class="el" href="classCGAL_1_1Classification_1_1Feature__handle.html">Feature_handle</a>.</p>
<p>The computation of features and their addition to the feature set is done in a single step using the <a class="el" href="classCGAL_1_1Classification_1_1Feature__set.html#a2d7dc5beaa908425dcf000ed441aa4bf">Feature_set::add&lt;Feature&gt;()</a> method. If CGAL was linked with <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartyTBB">Intel TBB</a>, features can be computed in parallel (see below).</p>
<p>CGAL provides some predefined features (see <a class="el" href="index.html#Classification_point_sets">Point Set Classification</a> for example). In the following code snippet, a subset of these predefined features are instantiated (in parallel if <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartyTBB">Intel TBB</a> is available). Note that all the predefined features can also be automatically generated in multiple scales (see <a class="el" href="index.html#Classification_point_sets">Point Set Classification</a> for example).</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="keywordtype">float</span> radius_neighbors = 1.7f;</div><div class="line">  <span class="keywordtype">float</span> radius_dtm = 15.0f;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Computing features"</span> &lt;&lt; std::endl;</div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  features.begin_parallel_additions(); <span class="comment">// No effect in sequential mode</span></div><div class="line"></div><div class="line">  Feature_handle distance_to_plane = features.add&lt;Distance_to_plane&gt; (pts, Pmap(), eigen);</div><div class="line">  Feature_handle dispersion = features.add&lt;Dispersion&gt; (pts, Pmap(), grid,</div><div class="line">                                                        radius_neighbors);</div><div class="line">  Feature_handle elevation = features.add&lt;Elevation&gt; (pts, Pmap(), grid,</div><div class="line">                                                      radius_dtm);</div><div class="line"></div><div class="line">  features.end_parallel_additions(); <span class="comment">// No effect in sequential mode</span></div><div class="line"></div></div><!-- fragment --><p> Users may want to define their own features, especially if the input data set comes with additional properties that were not anticipated by CGAL. A user-defined feature must inherit from <a class="el" href="classCGAL_1_1Classification_1_1Feature__base.html">Feature_base</a> and provide a method <a class="el" href="classCGAL_1_1Classification_1_1Feature__base.html#a601e16c0026bd33f28fc8bfd68b30461">value()</a> that associates a scalar value to each input item.</p>
<p>The following example shows how to define a feature that discriminates points that lie inside a 2D box from the others:</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="comment">// User-defined feature that identifies a specific area of the 3D</span></div><div class="line"><span class="comment">// space. This feature takes value 1 for points that lie inside the</span></div><div class="line"><span class="comment">// area and 0 for the others.</span></div><div class="line"><span class="keyword">class </span>My_feature : <span class="keyword">public</span> <a class="code" href="classCGAL_1_1Classification_1_1Feature__base.html">CGAL::Classification::Feature_base</a></div><div class="line">{</div><div class="line">  <span class="keyword">const</span> Point_range&amp; range;</div><div class="line">  <span class="keywordtype">double</span> xmin, xmax, ymin, ymax;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  My_feature (<span class="keyword">const</span> Point_range&amp; range,</div><div class="line">              <span class="keywordtype">double</span> xmin, <span class="keywordtype">double</span> xmax, <span class="keywordtype">double</span> ymin, <span class="keywordtype">double</span> ymax)</div><div class="line">    : range (range), xmin(xmin), xmax(xmax), ymin(ymin), ymax(ymax)</div><div class="line">  {</div><div class="line">    this-&gt;set_name (<span class="stringliteral">"my_feature"</span>);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">float</span> value (std::size_t pt_index)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (xmin &lt; range[pt_index].x() &amp;&amp; range[pt_index].x() &lt; xmax &amp;&amp;</div><div class="line">        ymin &lt; range[pt_index].y() &amp;&amp; range[pt_index].y() &lt; ymax)</div><div class="line">      <span class="keywordflow">return</span> 1.f;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <span class="keywordflow">return</span> 0.f;</div><div class="line">  }</div><div class="line"></div><div class="line">};</div><div class="line"></div></div><!-- fragment --><p> This feature can then be instantiated from the feature set the same way as the others:</p>
<div class="fragment"><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Computing features"</span> &lt;&lt; std::endl;</div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  <span class="comment">// Feature that identifies points whose x coordinate is between -20</span></div><div class="line">  <span class="comment">// and 20 and whose y coordinate is between -15 and 15</span></div><div class="line">  Feature_handle my_feature = features.add&lt;My_feature&gt; (pts, -20., 20., -15., 15.);</div><div class="line"></div></div><!-- fragment --> <h1><a class="anchor" id="Classification_structures_specialized"></a>
Specialized Data Structures</h1>
<p>Classification is based on the computation of local features. These features can take advantage of shared data structures that are precomputed and stored separately. Both these features and the underlying data structures depend on the type of data that needs to be classified. CGAL provides data structures to classify point sets, surface meshes and clusters.</p>
<h2><a class="anchor" id="Classification_point_sets"></a>
Point Set Classification</h2>
<p>CGAL provides the following structures:</p>
<ul>
<li><a class="el" href="classCGAL_1_1Classification_1_1Point__set__neighborhood.html">Point_set_neighborhood</a> stores spatial searching structures and provides adapted queries for points;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Local__eigen__analysis.html">Local_eigen_analysis</a> precomputes covariance matrices on local neighborhoods of points and stores the associated eigenvectors and eigenvalues;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Planimetric__grid.html">Planimetric_grid</a> is a 2D grid used for digital terrain modeling.</li>
</ul>
<p>Most of these data structures depend on a scale parameter. CGAL provides a method to estimate the average spacing based on a number of neighbors (see <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga8b330397a3fb68176c851fd7d214b513">CGAL::compute_average_spacing()</a>), which usually provides satisfying results in the absence of noise. In the presence of noise, <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga28fe6443638647be0874b283085eb2cd">CGAL::estimate_global_range_scale()</a> provides an estimation of the smallest scale such that the point set has the local dimension of a surface (this method is both robust to noise and outliers, see <a class="el" href="index.html#Classification_sowf_result">Result</a>).</p>
<p>The eigen analysis can be used to estimate normals. Note however that this analysis (based on Principal Component Analysis) might not be robust to a high level of noise. CGAL also provides more robust normal estimation functions (see for example <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga078e25209373cab0e1f3524202489771">CGAL::jet_estimate_normals()</a>).</p>
<p>The following code snippet shows how to instantiate such data structures from an input PLY point set (the <a class="el" href="index.html#Classification_example_general">full example</a> is given at the end of the manual).</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/b9.ply"</span>);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Reading input"</span> &lt;&lt; std::endl;</div><div class="line">  std::vector&lt;Point&gt; pts;</div><div class="line">  <span class="keywordflow">if</span> (!(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(filename, std::back_inserter(pts),</div><div class="line">                              <span class="comment">// the PLY reader expects a binary file by default</span></div><div class="line">                              CGAL::parameters::use_binary_mode(<span class="keyword">false</span>))))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read "</span> &lt;&lt; filename &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">float</span> grid_resolution = 0.34f;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> number_of_neighbors = 6;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Computing useful structures"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  Iso_cuboid_3 bbox = CGAL::bounding_box (pts.begin(), pts.end());</div><div class="line"></div><div class="line">  Planimetric_grid grid (pts, Pmap(), bbox, grid_resolution);</div><div class="line">  Neighborhood neighborhood (pts, Pmap());</div><div class="line">  Local_eigen_analysis eigen</div><div class="line">    = Local_eigen_analysis::create_from_point_set</div><div class="line">    (pts, Pmap(), neighborhood.k_neighbor_query(number_of_neighbors));</div><div class="line"></div></div><!-- fragment --><p> CGAL provides some predefined features:</p>
<ul>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Distance__to__plane.html">Distance_to_plane</a> measures how far away a point is from a locally estimated plane;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Eigenvalue.html">Eigenvalue</a> measures one of the three local eigenvalues;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Elevation.html">Elevation</a> computes the local distance to an estimation of the ground;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Elevation.html">Height_above</a> computes the distance between the local highest point and the point;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Elevation.html">Height_below</a> computes the distance between the point and the local lowest point;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Vertical__dispersion.html">Vertical_dispersion</a> computes how noisy the point set is on a local Z-cylinder;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Elevation.html">Vertical_range</a> computes the distance between the local highest and lowest points;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Verticality.html">Verticality</a> compares the local normal vector to the vertical vector.</li>
</ul>
<p>These features are designed for point sets but can easily be used with surface meshes as well (see <a class="el" href="index.html#Classification_meshes">Mesh Classification</a>). For more details about how these different features can help to identify one label or the other, please refer to their associated reference manual pages.</p>
<p>In addition, if the input data set has additional properties, these can also be used as features. For example, CGAL provides the following features:</p>
<ul>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Color__channel.html">Color_channel</a> uses input color information if available;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Echo__scatter.html">Echo_scatter</a> uses the number of returns (echo) provided by most LIDAR scanners if available;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Simple__feature.html">Simple_feature</a> uses any property map applicable to the input range and whose value type is castable to <code>float</code> (useful if an additional property of the input set should be used as is, for example an <code>intensity</code> measurement).</li>
</ul>
<p>Users commonly want to use all predefined features to get the best result possible. CGAL provides a class <a class="el" href="classCGAL_1_1Classification_1_1Point__set__feature__generator.html">Point_set_feature_generator</a> that performs the following operations:</p>
<ul>
<li>it estimates the smallest relevant scale;</li>
<li>it generates all needed analysis structures and provides access to them;</li>
<li>it generates all possible features (among all the CGAL predefined ones) based on which property maps are available (they use colors if available, etc.).</li>
</ul>
<p>Multiple scales that are sequentially larger can be used to increase the quality of the results <a class="el" href="citelist.html#CITEREF_cgal:hws-fsso3-16">[3]</a>.</p>
<p>Note that using this class in order to generate features is not mandatory, as features and data structures can all be handled by hand. It is mainly provided to make the specific case of point sets simpler to handle. Users can still add their own features within their feature set.</p>
<p>Some data structure instantiated by the generator will be used by feature: for this reason, the generator should be instantiated <em>within the same scope</em> as the feature set and should not be deleted before the feature set.</p>
<p>The following snippet shows how to use the point set feature generator:</p>
<div class="fragment"><div class="line"></div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  std::size_t number_of_scales = 5;</div><div class="line">  Feature_generator generator (pts, pts.point_map(), number_of_scales);</div><div class="line"></div><div class="line">  features.begin_parallel_additions();</div><div class="line">  generator.generate_point_based_features (features);</div><div class="line">  features.end_parallel_additions();</div><div class="line"></div></div><!-- fragment --><p> <a class="anchor" id="fig__Classification_point_set_fig"></a></p><div class="image">
<img src="point_set.png" alt="point_set.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Classification_point_set_fig">Figure 84.2</a> Example of point set classification (left: input, right: output). <em>Ground</em> is grey, <em>roofs</em> are orange, <em>vegetation</em> is green.  </div> <br /> 
<h2><a class="anchor" id="Classification_meshes"></a>
Mesh Classification</h2>
<p>Classification of mesh is performed by considering the face of a mesh as an atomic element that should be assign one label or another. Some structures such as neighborhood or Eigen analysis are significantly different from their equivalent for point sets; other data structures from point sets can be directly used by viewing the mesh as a point set through the use of a property map that associates each face with a representative point.</p>
<p>Hereafter, a <em>mesh</em> refers to a model of <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/classFaceListGraph.html">FaceListGraph</a></code>.</p>
<p>CGAL provides the following structures:</p>
<ul>
<li><a class="el" href="classCGAL_1_1Classification_1_1Face__descriptor__to__center__of__mass__map.html">Face_descriptor_to_center_of_mass_map</a> is a property map that takes the face of a mesh as key type and returns the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__3.html">CGAL::Point_3</a></code> located at the center of mass of the face. It is useful to apply point set structures and features to surface meshes;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Face__descriptor__to__face__descriptor__with__bbox__map.html">Face_descriptor_to_face_descriptor_with_bbox_map</a> is a property map that takes the face of a mesh as key type and returns the same face along with its bounding box as a value type. It is useful to call <code><a class="el" href="group__PkgClassificationMain.html#ga2a4c1b0816b81b628dc9023e104449eb" title="runs the classification algorithm with a global regularization based on a graph cut. ">CGAL::Classification::classify_with_graphcut()</a></code> which requires objects that provide a <code>bbox()</code> method (see <a class="el" href="index.html#Classification_classification_functions">Classification Functions</a>);</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Mesh__neighborhood.html">Mesh_neighborhood</a> provides adapted queries for surface meshes;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Local__eigen__analysis.html">Local_eigen_analysis</a> precomputes covariance matrices on local neighborhoods of triangles and stores the associated eigenvectors and eigenvalues (it is the same object as for point sets called with a different named constructor);</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Planimetric__grid.html">Planimetric_grid</a> is the 2D grid used for digital terrain modeling of point sets, it can be used with meshes through <a class="el" href="classCGAL_1_1Classification_1_1Face__descriptor__to__center__of__mass__map.html">Face_descriptor_to_center_of_mass_map</a>.</li>
</ul>
<p>The point set features can be used for mesh classification as well:</p>
<ul>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Eigenvalue.html">Eigenvalue</a> takes the <a class="el" href="classCGAL_1_1Classification_1_1Local__eigen__analysis.html">Local_eigen_analysis</a> object computed on faces as input;</li>
<li>the other ones are computed by considering the mesh as a point set.</li>
</ul>
<p>Similarly to <a class="el" href="classCGAL_1_1Classification_1_1Point__set__feature__generator.html">Point_set_feature_generator</a>, CGAL provides a class <a class="el" href="classCGAL_1_1Classification_1_1Mesh__feature__generator.html">Mesh_feature_generator</a> that estimates the smallest scale automatically and computes all predefined features on several scales. As for point sets, using this class in order to generate features is not mandatory, as features and data structures can all be handled by hand. It is mainly provided to make the specific case of meshes simpler to handle. Users can still add their own features within their feature set.</p>
<p>The following snippet shows how to use the mesh feature generator:</p>
<div class="fragment"><div class="line"></div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  Face_point_map face_point_map (&amp;mesh); <span class="comment">// Associates each face to its center of mass</span></div><div class="line"></div><div class="line">  std::size_t number_of_scales = 5;</div><div class="line">  Feature_generator generator (mesh, face_point_map, number_of_scales);</div><div class="line"></div><div class="line">  features.begin_parallel_additions();</div><div class="line">  generator.generate_point_based_features (features); <span class="comment">// Features that consider the mesh as a point set</span></div><div class="line">  generator.generate_face_based_features (features);  <span class="comment">// Features computed directly on mesh faces</span></div><div class="line">  features.end_parallel_additions();</div><div class="line"></div></div><!-- fragment --><p> The <a class="el" href="index.html#Classification_example_mesh">full example</a> is given at the end of the manual.</p>
<p><a class="anchor" id="fig__Classification_mesh_fig"></a></p><div class="image">
<img src="mesh.png" alt="mesh.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Classification_mesh_fig">Figure 84.3</a> Example of mesh classification (left: input, right: output). <em>Ground</em> is grey, <em>roofs</em> are orange, <em>vegetation</em> is green.  </div> <br /> 
<h2><a class="anchor" id="Classification_clusters"></a>
Cluster Classification</h2>
<p>Classifying clusters of items instead of raw sets of items can have several advantages:</p>
<ul>
<li>if the data set is very large, using clusters can drastically decrease the complexity and thus the need for computation time and memory;</li>
<li>clusters are more complex objects than raw items (isolated points or triangles of a mesh) and thus provide additional information (size of cluster, spatial consistency, etc.);</li>
<li>by construction, the output classification is less noisy (if all points of a facade are in the same cluster, then they are guaranteed to all be classified in the same label).</li>
</ul>
<p>For example, when dealing with urban scenes that typically contain large planar sections, it may be more efficient to first detect planes (with <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Region__growing.html">CGAL::Shape_detection::Region_growing</a></code> or <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Efficient__RANSAC.html">CGAL::Shape_detection::Efficient_RANSAC</a></code> for example) and then to classify each subset of points belonging to a specific plane as clusters.</p>
<p>CGAL provides some tools to classify clusters:</p>
<ul>
<li>the class <code><a class="el" href="classCGAL_1_1Classification_1_1Cluster.html" title="Class that represent a cluster of items to be classified as a single atomic object. ">CGAL::Classification::Cluster</a></code> can be used to represent a cluster of items (points, for example);</li>
<li>the function <code><a class="el" href="group__PkgClassificationCluster.html#ga6c0c1a27071cf5ebfac967d6847cbbf9" title="Given a set of cluster indices, segments the input range into Cluster objects. ">CGAL::Classification::create_clusters_from_indices()</a></code> takes indices over items as input (for example, shape indices taken from shape detection) and generates one cluster per index.</li>
</ul>
<p>The following snippet shows how to create classification clusters from a shape detection algorithm (<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Region__growing.html">Region Growing</a>):</p>
<div class="fragment"><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Detecting planes and creating clusters"</span> &lt;&lt; std::endl;</div><div class="line">  t.start();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> search_sphere_radius  = 1.0;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> max_distance_to_plane = 1.0;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> max_accepted_angle    = 25.0;</div><div class="line">  <span class="keyword">const</span> std::size_t min_region_size  = 10;</div><div class="line"></div><div class="line">  Neighbor_query neighbor_query (</div><div class="line">    pts, CGAL::parameters::sphere_radius(search_sphere_radius)</div><div class="line">                          .point_map(pts.point_map()));</div><div class="line">  Region_type region_type(</div><div class="line">    pts, CGAL::parameters::maximum_distance(max_distance_to_plane)</div><div class="line">                          .maximum_angle(max_accepted_angle)</div><div class="line">                          .minimum_region_size(min_region_size)</div><div class="line">                          .point_map(pts.point_map())</div><div class="line">                          .normal_map(pts.normal_map()));</div><div class="line">  Region_growing region_growing (</div><div class="line">    pts, neighbor_query, region_type);</div><div class="line"></div><div class="line">  std::vector&lt;Cluster&gt; clusters;</div><div class="line">  region_growing.detect</div><div class="line">    (boost::make_function_output_iterator</div><div class="line">     ([&amp;](<span class="keyword">const</span> std::vector&lt;std::size_t&gt;&amp; region) -&gt; <span class="keywordtype">void</span> {</div><div class="line"></div><div class="line">        <span class="comment">// Create a new cluster.</span></div><div class="line">        Classification::Cluster&lt;Point_set, Pmap&gt; cluster (pts, pts.point_map());</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> std::size_t idx : region)</div><div class="line">          cluster.insert(idx);</div><div class="line">        clusters.push_back(cluster);</div><div class="line">      }));</div><div class="line"></div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; clusters.size() &lt;&lt; <span class="stringliteral">" clusters created in "</span></div><div class="line">            &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div><div class="line"></div></div><!-- fragment --><p> The class <a class="el" href="classCGAL_1_1Classification_1_1Local__eigen__analysis.html">Local_eigen_analysis</a> can also take point clusters as input:</p>
<div class="fragment"><div class="line"></div><div class="line">  Local_eigen_analysis eigen = Local_eigen_analysis::create_from_point_clusters (clusters);</div><div class="line"></div></div><!-- fragment --><p> As clusters are based on simple items, users can compute cluster features based on statistics over the itemwise features:</p>
<ul>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Cluster__mean__of__feature.html">Cluster_mean_of_feature</a> computes, for a cluster, the mean value of an itemwise feature over the inliers of this cluster;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Cluster__variance__of__feature.html">Cluster_variance_of_feature</a> computes, for a cluster, the variance of an itemwise feature over the inliers of this cluster.</li>
</ul>
<p>Some additional features are provided specifically for clusters:</p>
<ul>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Cluster__size.html">Cluster_size</a> uses the number of items in a cluster;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Cluster__vertical__extent.html">Cluster_vertical_extent</a> computes the length of the smallest interval on the <code>Z</code> axis that contains all the items of a cluster;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Eigenvalue.html">Eigenvalue</a>, similarly to point sets and meshes, can use the <a class="el" href="classCGAL_1_1Classification_1_1Local__eigen__analysis.html">Local_eigen_analysis</a> object computed on clusters.</li>
</ul>
<p>The following snippet shows, from a pointwise feature set, how to generate the statistical features from a pointwise feature set (along with these latest cluster features):</p>
<div class="fragment"><div class="line"></div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  <span class="comment">// First, compute means of features.</span></div><div class="line">  features.begin_parallel_additions();</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; pointwise_features.size(); ++ i)</div><div class="line">    features.add&lt;Feature::Cluster_mean_of_feature&gt; (clusters, pointwise_features[i]);</div><div class="line">  features.end_parallel_additions();</div><div class="line"></div><div class="line">  <span class="comment">// Then, compute variances of features (and remaining cluster features).</span></div><div class="line">  features.begin_parallel_additions();</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; pointwise_features.size(); ++ i)</div><div class="line">    features.add&lt;Feature::Cluster_variance_of_feature&gt; (clusters,</div><div class="line">                                                        pointwise_features[i], <span class="comment">// i^th feature</span></div><div class="line">                                                        features[i]);          <span class="comment">// mean of i^th feature</span></div><div class="line"></div><div class="line">  features.add&lt;Feature::Cluster_size&gt; (clusters);</div><div class="line">  features.add&lt;Feature::Cluster_vertical_extent&gt; (clusters);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; 3; ++ i)</div><div class="line">    features.add&lt;Feature::Eigenvalue&gt; (clusters, eigen, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(i));</div><div class="line"></div><div class="line">  features.end_parallel_additions();</div><div class="line"></div></div><!-- fragment --><p> The <a class="el" href="index.html#Classification_example_cluster">full example</a> is given at the end of the manual.</p>
<p><a class="anchor" id="fig__Classification_cluster_fig"></a></p><div class="image">
<img src="clusters.png" alt="clusters.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Classification_cluster_fig">Figure 84.4</a> Example of cluster classification mesh (left: input, middle: clusters computed from region growing, right: output). <em>Ground</em> is grey, <em>roofs</em> are orange, <em>vegetation</em> is green, points not assigned to a cluster are <em>black</em>.  </div> <br /> 
<h1><a class="anchor" id="Classification_classifiers"></a>
Classifiers</h1>
<p>Classification relies on a classifier: this classifier is an object that, from the set of values taken by the features at an input item, computes the probability that an input item belongs to one label or another. A model of the concept <code><a class="el" href="classCGAL_1_1Classification_1_1Classifier.html" title="Concept describing a classifier used by classification functions (see CGAL::Classification::classify(...">CGAL::Classification::Classifier</a></code> must take the index of an input item and store the probability associated to each label in a vector. If a classifier returns the value 1 for a pair of label and input item, it means that this item belongs to this label with certainty; values close to 0 mean that this item is not likely to belong to this label.</p>
<p>CGAL provides three models for this concept, <a class="el" href="classCGAL_1_1Classification_1_1ETHZ_1_1Random__forest__classifier.html">ETHZ::Random_forest_classifier</a>, <a class="el" href="classCGAL_1_1Classification_1_1OpenCV_1_1Random__forest__classifier.html">OpenCV::Random_forest_classifier</a>, and <a class="el" href="classCGAL_1_1Classification_1_1Sum__of__weighted__features__classifier.html">Sum_of_weighted_features_classifier</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Currently, <a class="el" href="classCGAL_1_1Classification_1_1ETHZ_1_1Random__forest__classifier.html">ETHZ::Random_forest_classifier</a> is the best classifier available in CGAL and we strongly advise users to use it.</dd></dl>
<p>To perform classification based on four classifiers, please refer to <a class="el" href="index.html#Classification_classification_functions">Classification Functions</a>.</p>
<h2><a class="anchor" id="Classification_ETHZ_random_forest"></a>
ETHZ Random Forest</h2>
<p>CGAL provides <a class="el" href="classCGAL_1_1Classification_1_1ETHZ_1_1Random__forest__classifier.html">ETHZ::Random_forest_classifier</a>, a classifier based on the Random Forest Template Library developed by Stefan Walk at ETH Zurich <a class="el" href="citelist.html#CITEREF_cgal:w-erftl-14">[2]</a> (the library is distributed under the MIT license and is included with the CGAL release, the user does not have to install anything more). This classifier uses a ground truth training set to construct several decision trees that are then used to assign a label to each input item.</p>
<p>This classifier cannot be set up by hand and requires a ground truth training set. The training algorithm is fast but usually requires a high number of inliers. The training algorithm uses more memory at runtime and the configuration files are larger than those produced by <a class="el" href="classCGAL_1_1Classification_1_1Sum__of__weighted__features__classifier.html">Sum_of_weighted_features_classifier</a>, but the output quality is usually significantly better, especially in the cases where many labels are used (more than five).</p>
<p>An <a class="el" href="index.html#Classification_example_ethz_random_forest">example</a> shows how to use this classifier. For more details about the algorithm, please refer to README provided in the <a href="https://ethz.ch/content/dam/ethz/special-interest/baug/igp/photogrammetry-remote-sensing-dam/documents/sourcecode-and-datasets/Random%20Forest/rforest.zip">ETH Zurich's code archive</a>.</p>
<h3><a class="anchor" id="Classification_ETHZ_random_forest_deprecated"></a>
Deprecated IO</h3>
<p>The <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/namespaceCGAL_1_1IO.html">IO</a> functions of this classifier were changed in CGAL 5.2. Configurations generated from previous versions are not valid anymore and should be converted first as shown in the following example:</p>
<p><br />
<b>File</b> <a class="el" href="Classification_2example_deprecated_conversion_8cpp-example.html">Classification/example_deprecated_conversion.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Classification/ETHZ/Random_forest_classifier.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (argc != 3)</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Usage: "</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">" input.gz output.bin"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">  {</div><div class="line">    std::ifstream ifile (argv[1], std::ios_base::binary);</div><div class="line">    std::ofstream ofile (argv[2], std::ios_base::binary);</div><div class="line"></div><div class="line">    <a class="code" href="classCGAL_1_1Classification_1_1ETHZ_1_1Random__forest__classifier.html#a99154673a7b517e7d141e6d3678a65c8">CGAL::Classification::ETHZ::Random_forest_classifier::</a></div><div class="line"><a class="code" href="classCGAL_1_1Classification_1_1ETHZ_1_1Random__forest__classifier.html#a99154673a7b517e7d141e6d3678a65c8">      convert_deprecated_configuration_to_new_format</a>(ifile, ofile);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Classification_OpenCV_random_forest"></a>
OpenCV Random Forest</h2>
<p>The second classifier is <a class="el" href="classCGAL_1_1Classification_1_1OpenCV_1_1Random__forest__classifier.html">OpenCV::Random_forest_classifier</a>. It uses the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartyOpenCV">OpenCV</a> library, more specifically the <a href="https://docs.opencv.org/2.4/modules/ml/doc/random_trees.html">Random Trees</a> package.</p>
<p>Note that this classifier usually produces results with a lower quality than <a class="el" href="classCGAL_1_1Classification_1_1ETHZ_1_1Random__forest__classifier.html">ETHZ::Random_forest_classifier</a>. It is provided for the sake of completeness and for testing purposes, but if you are not sure what to use, we advise using the ETHZ Random Forest instead.</p>
<p>An <a class="el" href="index.html#Classification_example_opencv_random_forest">example</a> shows how to use this classifier. For more details about the algorithm, please refer to <a href="https://docs.opencv.org/2.4/modules/ml/doc/random_trees.html">the official documentation</a> of OpenCV.</p>
<h2><a class="anchor" id="Classification_sowf"></a>
Sum of Weighted Features</h2>
<p>This latest classifier defines the following attributes:</p>
<ul>
<li>a weight applied to each feature;</li>
<li>an effect applied to each pair of feature and label.</li>
</ul>
<p>For each label, the classifier computes an energy as a sum of features normalized with both their weight and the effect they have on this specific label.</p>
<p>The main advantage of this classifier is that it can be set up by hand. Nevertheless, it also embeds a training algorithm.</p>
<h3><a class="anchor" id="Classification_sowf_weights_effects"></a>
Weights and Effects</h3>
<p>Each feature is assigned a weight that measures its strength with respect to the other features.</p>
<p>Each pair of feature and label is assigned an effect that can either be:</p>
<ul>
<li><a class="el" href="classCGAL_1_1Classification_1_1Sum__of__weighted__features__classifier.html#a6aab054f8adf32f1e05b693f5caf9512a9f79d37660f7ace2f1c3a790edb4171a">FAVORING</a>: the label is favored by high values of the feature;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Sum__of__weighted__features__classifier.html#a6aab054f8adf32f1e05b693f5caf9512aafe5766bc7d9202e9e856491e311d954">NEUTRAL</a>: the label is not affected by the feature;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Sum__of__weighted__features__classifier.html#a6aab054f8adf32f1e05b693f5caf9512a2dd2e92685af72202d0875fb898f391e">PENALIZING</a>: the label is favored by low values of the feature.</li>
</ul>
<p>For example, <em>vegetation</em> is expected to have a high distance to plane and have a color close to green (if colors are available); <em>facades</em> have a low distance to plane and a low verticality; etc.</p>
<p>Let \(x=(x_i)_{i=1..N}\) be a potential classification result with \(N\) the number of input items and \(x_i\) the class of the \(i^{th}\) item (for example: <em>vegetation</em>, <em>ground</em>, etc.). Let \(f_j(i)\) be the raw value of the \(j^{th}\) feature at the \(i^{th}\) item and \(w_j\) be the weight of this feature. We define the normalized value \(F_j(x_i) \in [0:1]\) of the \(j^{th}\) feature at the \(i^{th}\) item as follows:</p>
<p class="formulaDsp">
\begin{eqnarray*} F_j(x_i) = &amp; (1 - \min(\max(0,\frac{f_j(i)}{w_j}), 1)) &amp; \mbox{if } f_j \mbox{ favors } x_i \\ &amp; 0.5 &amp; \mbox{if } f_j \mbox{ is neutral for } x_i \\ &amp; \min(\max(0,\frac{f_j(i)}{w_j}), 1) &amp; \mbox{if } f_j \mbox{ penalizes } x_i \end{eqnarray*}
</p>
<p>The itemwise energy measures the coherence of the label \(x_i\) at the \(i^{th}\) item and is defined as:</p>
<p class="formulaDsp">
\[ E_{di}(x_i) = \sum_{j = 1..N_f} F_j(x_i) \]
</p>
<p>The following code snippet shows how to define the weights and effects of features and labels:</p>
<div class="fragment"><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Setting weights"</span> &lt;&lt; std::endl;</div><div class="line">  Classifier classifier (labels, features);</div><div class="line">  classifier.set_weight (distance_to_plane, 6.75e-2f);</div><div class="line">  classifier.set_weight (dispersion, 5.45e-1f);</div><div class="line">  classifier.set_weight (elevation, 1.47e1f);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Setting effects"</span> &lt;&lt; std::endl;</div><div class="line">  classifier.set_effect (ground, distance_to_plane, Classifier::NEUTRAL);</div><div class="line">  classifier.set_effect (ground, dispersion, Classifier::NEUTRAL);</div><div class="line">  classifier.set_effect (ground, elevation, Classifier::PENALIZING);</div><div class="line"></div><div class="line">  classifier.set_effect (vegetation, distance_to_plane,  Classifier::FAVORING);</div><div class="line">  classifier.set_effect (vegetation, dispersion, Classifier::FAVORING);</div><div class="line">  classifier.set_effect (vegetation, elevation, Classifier::NEUTRAL);</div><div class="line"></div><div class="line">  classifier.set_effect (roof, distance_to_plane,  Classifier::NEUTRAL);</div><div class="line">  classifier.set_effect (roof, dispersion, Classifier::NEUTRAL);</div><div class="line">  classifier.set_effect (roof, elevation, Classifier::FAVORING);</div><div class="line"></div></div><!-- fragment --> <h3><a class="anchor" id="Classification_sowf_training"></a>
Training</h3>
<p>Each feature has a specific weight and each pair of feature-label has a specific effect. This means that the number of parameters to set up can quickly explode: if 6 features are used to classify between 4 labels, 30 parameters have to be set up (6 weights + 6x4 feature-label relationships).</p>
<p>Though it is possible to set them up one by one, CGAL also provides a method <a class="el" href="classCGAL_1_1Classification_1_1Sum__of__weighted__features__classifier.html#a11bcf5a1416f0fd2c4855af9c73797cc">train()</a> that requires a small set of ground truth items provided by users. More specifically, users must provide, for each label they want to classify, a set of known inliers among the input data set (for example, selecting one roof, one tree and one section of the ground). The training algorithm works as follows:</p>
<ul>
<li>for each feature, a range of weights is tested: the effect each feature has on each label is estimated. For a given weight, if a feature has the same effect on each label, it is non-relevant for classification. The range of weights such that the feature is relevant is estimated;</li>
<li>for each feature, uniformly picked weight values are tested and their effects are estimated;</li>
<li>each inlier provided by the user is classified using this set of weights and effects;</li>
<li>the mean intersection-over-union (see <a class="el" href="index.html#Classification_evaluation">Evaluation</a>) is used to evaluate the quality of this set of weights and effects;</li>
<li>the same mechanism is repeated until all features' ranges have been tested. Weights are only changed one by one, the other ones are kept to the values that gave the latest best score.</li>
</ul>
<p>This usually converges to a satisfying solution (see Figure <a class="el" href="index.html#fig__Classification_trainer_fig">Figure 84.5</a>). The number of trials is user defined, set to 300 by default. Using at least 10 times the number of features is advised (for example, at least 300 iterations if 30 features are used). If the solution is not satisfying, more inliers can be selected, for example, in a region that the user identifies as misclassified with the current configuration. The training algorithm keeps, as initialization, the best weights found at the previous round and carries on trying new weights by taking new inliers into account.</p>
<p><a class="anchor" id="fig__Classification_trainer_fig"></a></p><div class="image">
<img src="classif_training.png" alt="classif_training.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Classification_trainer_fig">Figure 84.5</a> Example of evolution of the mean intersection-over-union. The purple curve is the score computed at the current iteration, green curve is the best score found so far.  </div> <br /> 
<h3><a class="anchor" id="Classification_sowf_result"></a>
Result</h3>
<p>Figure <a class="el" href="index.html#fig__Classification_sowf_result_fig">Figure 84.6</a> shows an example of output on a defect-laden point set. The accuracy on this example is 0.97 with a mean intersection-over-union of 0.85 (see section <a class="el" href="index.html#Classification_evaluation">Evaluation</a>).</p>
<p><a class="anchor" id="fig__Classification_sowf_result_fig"></a></p><div class="image">
<img src="noise_outliers.png" alt="noise_outliers.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Classification_sowf_result_fig">Figure 84.6</a> Example of classification on a point set with medium noise and outliers (left: input, right: output). <em>Ground</em> is orange, <em>roofs</em> are pink, <em>vegetation</em> is green. Outliers are classified with an additional label <em>outlier</em> in black.  </div> <br /> 
<h1><a class="anchor" id="Classification_classification_functions"></a>
Classification Functions</h1>
<p>Classification is performed by minimizing an energy over the input data set that may include regularization. CGAL provides three different methods for classification, ranging from high speed / low quality to low speed / high quality:</p>
<ul>
<li><code><a class="el" href="group__PkgClassificationMain.html#gaea3ed82bf801bc9fbd00b63da48df73e" title="runs the classification algorithm without any regularization. ">CGAL::Classification::classify()</a></code></li>
<li><code><a class="el" href="group__PkgClassificationMain.html#ga266e487bd1ab9dd4036e3fbd2ec4e8a0" title="runs the classification algorithm with a local smoothing. ">CGAL::Classification::classify_with_local_smoothing()</a></code></li>
<li><code><a class="el" href="group__PkgClassificationMain.html#ga2a4c1b0816b81b628dc9023e104449eb" title="runs the classification algorithm with a global regularization based on a graph cut. ">CGAL::Classification::classify_with_graphcut()</a></code></li>
</ul>
<p>On a point set of 3 millions of points, the first method takes about 4 seconds, the second about 40 seconds and the third about 2 minutes.</p>
<p><a class="anchor" id="fig__Classification_image"></a></p><div class="image">
<img src="classif.png" alt="classif.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Classification_image">Figure 84.7</a> Top-Left: input point set. Top-Right: raw output classification represented by a set of colors (<em>ground</em> is orange, <em>facades</em> are blue, <em>roofs</em> are pink and <em>vegetation</em> is green). Bottom-Left: output classification using local smoothing. Bottom-Right: output classification using graphcut.  </div> <br /> 
<p>Mathematical details are provided hereafter.</p>
<h2><a class="anchor" id="Classification_classify"></a>
Raw Classification</h2>
<ul>
<li><code><a class="el" href="group__PkgClassificationMain.html#gaea3ed82bf801bc9fbd00b63da48df73e" title="runs the classification algorithm without any regularization. ">CGAL::Classification::classify()</a></code>: this is the fastest method that provides acceptable but usually noisy results (see Figure <a class="el" href="index.html#fig__Classification_image">Figure 84.7</a>, top-right).</li>
</ul>
<p>Let \(x=(x_i)_{i=1..N}\) be a potential classification result with \(N\) the number of input items and \(x_i\) the label of the \(i^{th}\) item (for example: <em>vegetation</em>, <em>ground</em>, etc.). The classification is performed by minimizing the following energy:</p>
<p class="formulaDsp">
\[ E(x) = \sum_{i = 1..N} E_{di}(x_i) \]
</p>
<p>This energy is a sum of itemwise energies provided by the classifier and involves no regularization.</p>
<p>The following snippet shows how to classify points based on a label set and a classifier. The result is stored in <code>label_indices</code>, following the same order as the input set and providing for each point the index (in the label set) of its assigned label.</p>
<div class="fragment"><div class="line">  std::vector&lt;int&gt; label_indices (pts.size(), -1);</div><div class="line"></div><div class="line">  CGAL::Real_timer t;</div><div class="line">  t.start();</div><div class="line">  Classification::classify&lt;CGAL::Parallel_if_available_tag&gt; (pts, labels, classifier, label_indices);</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Raw classification performed in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div></div><!-- fragment --> <h2><a class="anchor" id="Classification_smoothing"></a>
Local Regularization</h2>
<ul>
<li><p class="startli"><code><a class="el" href="group__PkgClassificationMain.html#ga266e487bd1ab9dd4036e3fbd2ec4e8a0" title="runs the classification algorithm with a local smoothing. ">CGAL::Classification::classify_with_local_smoothing()</a></code>: this method is a tradeoff between quality and efficiency (see Figure <a class="el" href="index.html#fig__Classification_image">Figure 84.7</a>, bottom-left). The minimized energy is defined as follows:</p>
<p class="formulaDsp">
\[ E(x) = \sum_{i = 1..N} E_{si}(x_i) \]
</p>
</li>
</ul>
<p>The energy \(E_{si}(x_i)\) is defined on a small local neighborhood \(Nb(i)\) of the \(i^{th}\) item (including itself):</p>
<p class="formulaDsp">
\[ E_{si}(x_i) = \frac{\sum_{k \in Nb(i)} E_{di}(x_k)}{\left| Nb(i) \right|} \]
</p>
<p>This allows to eliminate local noisy variations of assigned labels. Increasing the size of the neighborhood increases the noise reduction at the cost of higher computation times.</p>
<p>The following snippet shows how to classify points using local smoothing by providing a model of <code><a class="el" href="classCGAL_1_1Classification_1_1NeighborQuery.html" title="Concept describing a neighbor query used for classification. ">CGAL::Classification::NeighborQuery</a></code>.</p>
<div class="fragment"><div class="line">  t.start();</div><div class="line">  Classification::classify_with_local_smoothing&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (pts, Pmap(), labels, classifier,</div><div class="line">     neighborhood.sphere_neighbor_query(radius_neighbors),</div><div class="line">     label_indices);</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classification with local smoothing performed in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div></div><!-- fragment --> <h2><a class="anchor" id="Classification_graphcut"></a>
Global Regularization (Graph Cut)</h2>
<ul>
<li><p class="startli"><code><a class="el" href="group__PkgClassificationMain.html#ga2a4c1b0816b81b628dc9023e104449eb" title="runs the classification algorithm with a global regularization based on a graph cut. ">CGAL::Classification::classify_with_graphcut()</a></code>: this method offers the best quality but requires longer computation time (see Figure <a class="el" href="index.html#fig__Classification_image">Figure 84.7</a>, bottom-right). The total energy that is minimized is the sum of the partial data term \(E_{di}(x_i)\) and of a pairwise interaction energy defined by the standard Potts model <a class="el" href="citelist.html#CITEREF_cgal:l-mrfmi-09">[5]</a> :</p>
<p class="formulaDsp">
\[ E(x) = \sum_{i = 1..N} E_{di}(x_i) + \gamma \sum_{i \sim j} \mathbf{1}_{x_i \neq x_j} \]
</p>
</li>
</ul>
<p>where \(\gamma&gt;0\) is the parameter of the Potts model that quantifies the strengh of the regularization, \(i \sim j\) represents the pairs of neighboring items and \(\mathbf{1}_{\{.\}}\) the characteristic function.</p>
<p>A <em>graph cut</em> based algorithm (alpha expansion) is used to quickly reach an approximate solution close to the global optimum of this energy.</p>
<p>This method allows to consistently segment the input data set in piecewise constant parts and to correct large wrongly classified clusters. Increasing \(\gamma\) produces more regular result with a constant computation time.</p>
<p>To speed up computations, the input domain can be subdivided into smaller subsets such that several smaller graph cuts are applied instead of a big one. The computation of these smaller graph cuts can be done in parallel. Increasing the number of subsets allows for faster computation times but can also reduce the quality of the results.</p>
<p>The following snippet shows how to classify points using a graph cut regularization providing a model of <code><a class="el" href="classCGAL_1_1Classification_1_1NeighborQuery.html" title="Concept describing a neighbor query used for classification. ">CGAL::Classification::NeighborQuery</a></code>, a strengh parameter \(\gamma\) and a number of subdivisions.</p>
<div class="fragment"><div class="line">  t.start();</div><div class="line">  Classification::classify_with_graphcut&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (pts, Pmap(), labels, classifier,</div><div class="line">     neighborhood.k_neighbor_query(12),</div><div class="line">     0.2f, 4, label_indices);</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classification with graphcut performed in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div></div><!-- fragment --> <h1><a class="anchor" id="Classification_evaluation"></a>
Evaluation</h1>
<p>The class <a class="el" href="classCGAL_1_1Classification_1_1Evaluation.html">Evaluation</a> allows users to evaluate the reliability of the classification with respect to a provided ground truth. The following measurements are available:</p>
<ul>
<li><a class="el" href="classCGAL_1_1Classification_1_1Evaluation.html#a040d137ec34590b2e2364d42264a901e">precision()</a> computes, for one label, the ratio of true positives over the total number of detected positives;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Evaluation.html#a40cd95adcd26d7b16cd6daaf56dfba27">recall()</a> computes, for one label, the ratio of true positives over the total number of provided inliers of this label;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Evaluation.html#a8de98452ad8bafc018b18d75e1e55a47">f1_score()</a> is the harmonic mean of precision and recall;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Evaluation.html#a2d4513d5a5256fda156d5b4fd1ddfbe7">intersection_over_union()</a> computes the ratio of true positives over the union of the detected positives and of the provided inliers;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Evaluation.html#ac2c9a217607e34f38541d10adc77b336">accuracy()</a> computes the ratio of all true positives over the total number of provided inliers;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Evaluation.html#aca8eaa6bf226fc44a3740b376acce804">mean_f1_score()</a>;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Evaluation.html#aae3761d28e2b0585c8715edbff790c14">mean_intersection_over_union()</a>.</li>
</ul>
<p>All these values range from 0 (poor quality) to 1 (perfect quality).</p>
<h1><a class="anchor" id="Classification_examples"></a>
Full Examples</h1>
<h2><a class="anchor" id="Classification_example_general"></a>
Simple Point Set Classification</h2>
<p>The following example:</p>
<ul>
<li>reads an input file (LIDAR point set in PLY format);</li>
<li>computes useful structures from this input;</li>
<li>computes features from the input and the precomputed structures;</li>
<li>defines 3 labels (<em>vegetation</em>, <em>ground</em> and <em>roof</em>);</li>
<li>sets up the classification classifier <a class="el" href="classCGAL_1_1Classification_1_1Sum__of__weighted__features__classifier.html">Sum_of_weighted_features_classifier</a>;</li>
<li>classifies the point set with the 3 different methods (this is for the sake of the example: each method overwrites the previous result, users should only call one of the methods);</li>
<li>saves the result in a colored PLY format.</li>
</ul>
<p><br />
<b>File</b> <a class="el" href="Classification_2example_classification_8cpp-example.html">Classification/example_classification.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#if defined (_MSC_VER) &amp;&amp; !defined (_WIN64)</span></div><div class="line"><span class="preprocessor">#pragma warning(disable:4244) // boost::number_distance::distance()</span></div><div class="line">                              <span class="comment">// converts 64 to 32 bits integers</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Classification.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/bounding_box.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/tags.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_ply_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a> Concurrency_tag;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::Iso_cuboid_3</a> Iso_cuboid_3;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> CGAL::Identity_property_map&lt;Point&gt; Pmap;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Classification = <a class="code" href="namespaceCGAL_1_1Classification.html">CGAL::Classification</a>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Sum_of_weighted_features_classifier Classifier;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Planimetric_grid&lt;Kernel, Point_range, Pmap&gt;             Planimetric_grid;</div><div class="line"><span class="keyword">typedef</span> Classification::Point_set_neighborhood&lt;Kernel, Point_range, Pmap&gt;       Neighborhood;</div><div class="line"><span class="keyword">typedef</span> Classification::Local_eigen_analysis                                    Local_eigen_analysis;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Label_handle                                            Label_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_handle                                          Feature_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Label_set                                               Label_set;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_set                                             Feature_set;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Feature::Distance_to_plane&lt;Point_range, Pmap&gt;           Distance_to_plane;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature::Elevation&lt;Kernel, Point_range, Pmap&gt;           Elevation;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature::Vertical_dispersion&lt;Kernel, Point_range, Pmap&gt; Dispersion;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/b9.ply"</span>);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Reading input"</span> &lt;&lt; std::endl;</div><div class="line">  std::vector&lt;Point&gt; pts;</div><div class="line">  <span class="keywordflow">if</span> (!(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(filename, std::back_inserter(pts),</div><div class="line">                              <span class="comment">// the PLY reader expects a binary file by default</span></div><div class="line">                              CGAL::parameters::use_binary_mode(<span class="keyword">false</span>))))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read "</span> &lt;&lt; filename &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">float</span> grid_resolution = 0.34f;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> number_of_neighbors = 6;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Computing useful structures"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  Iso_cuboid_3 bbox = CGAL::bounding_box (pts.begin(), pts.end());</div><div class="line"></div><div class="line">  Planimetric_grid grid (pts, Pmap(), bbox, grid_resolution);</div><div class="line">  Neighborhood neighborhood (pts, Pmap());</div><div class="line">  Local_eigen_analysis eigen</div><div class="line">    = Local_eigen_analysis::create_from_point_set</div><div class="line">    (pts, Pmap(), neighborhood.k_neighbor_query(number_of_neighbors));</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">float</span> radius_neighbors = 1.7f;</div><div class="line">  <span class="keywordtype">float</span> radius_dtm = 15.0f;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Computing features"</span> &lt;&lt; std::endl;</div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  features.begin_parallel_additions(); <span class="comment">// No effect in sequential mode</span></div><div class="line"></div><div class="line">  Feature_handle distance_to_plane = features.add&lt;Distance_to_plane&gt; (pts, Pmap(), eigen);</div><div class="line">  Feature_handle dispersion = features.add&lt;Dispersion&gt; (pts, Pmap(), grid,</div><div class="line">                                                        radius_neighbors);</div><div class="line">  Feature_handle elevation = features.add&lt;Elevation&gt; (pts, Pmap(), grid,</div><div class="line">                                                      radius_dtm);</div><div class="line"></div><div class="line">  features.end_parallel_additions(); <span class="comment">// No effect in sequential mode</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  Label_set labels;</div><div class="line"></div><div class="line">  <span class="comment">// Init name only</span></div><div class="line">  Label_handle ground = labels.add (<span class="stringliteral">"ground"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Init name and color</span></div><div class="line">  Label_handle vegetation = labels.add (<span class="stringliteral">"vegetation"</span>, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a>(0,255,0));</div><div class="line"></div><div class="line">  <span class="comment">// Init name, Color and standard index (here, ASPRS building index)</span></div><div class="line">  Label_handle roof = labels.add (<span class="stringliteral">"roof"</span>, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a> (255, 0, 0), 6);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Setting weights"</span> &lt;&lt; std::endl;</div><div class="line">  Classifier classifier (labels, features);</div><div class="line">  classifier.set_weight (distance_to_plane, 6.75e-2f);</div><div class="line">  classifier.set_weight (dispersion, 5.45e-1f);</div><div class="line">  classifier.set_weight (elevation, 1.47e1f);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Setting effects"</span> &lt;&lt; std::endl;</div><div class="line">  classifier.set_effect (ground, distance_to_plane, Classifier::NEUTRAL);</div><div class="line">  classifier.set_effect (ground, dispersion, Classifier::NEUTRAL);</div><div class="line">  classifier.set_effect (ground, elevation, Classifier::PENALIZING);</div><div class="line"></div><div class="line">  classifier.set_effect (vegetation, distance_to_plane,  Classifier::FAVORING);</div><div class="line">  classifier.set_effect (vegetation, dispersion, Classifier::FAVORING);</div><div class="line">  classifier.set_effect (vegetation, elevation, Classifier::NEUTRAL);</div><div class="line"></div><div class="line">  classifier.set_effect (roof, distance_to_plane,  Classifier::NEUTRAL);</div><div class="line">  classifier.set_effect (roof, dispersion, Classifier::NEUTRAL);</div><div class="line">  classifier.set_effect (roof, elevation, Classifier::FAVORING);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Run classification</span></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classifying"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::vector&lt;int&gt; label_indices (pts.size(), -1);</div><div class="line"></div><div class="line">  CGAL::Real_timer t;</div><div class="line">  t.start();</div><div class="line">  Classification::classify&lt;CGAL::Parallel_if_available_tag&gt; (pts, labels, classifier, label_indices);</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Raw classification performed in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div><div class="line"></div><div class="line">  t.start();</div><div class="line">  Classification::classify_with_local_smoothing&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (pts, Pmap(), labels, classifier,</div><div class="line">     neighborhood.sphere_neighbor_query(radius_neighbors),</div><div class="line">     label_indices);</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classification with local smoothing performed in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div><div class="line"></div><div class="line">  t.start();</div><div class="line">  Classification::classify_with_graphcut&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (pts, Pmap(), labels, classifier,</div><div class="line">     neighborhood.k_neighbor_query(12),</div><div class="line">     0.2f, 4, label_indices);</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classification with graphcut performed in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save the output in a colored PLY format</span></div><div class="line"></div><div class="line">  std::vector&lt;unsigned char&gt; red, green, blue;</div><div class="line">  red.reserve(pts.size());</div><div class="line">  green.reserve(pts.size());</div><div class="line">  blue.reserve(pts.size());</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; pts.size(); ++ i)</div><div class="line">  {</div><div class="line">    Label_handle label = labels[std::size_t(label_indices[i])];</div><div class="line">    <span class="keywordtype">unsigned</span> r = 0, g = 0, b = 0;</div><div class="line">    <span class="keywordflow">if</span> (label == ground)</div><div class="line">    {</div><div class="line">      r = 245; g = 180; b = 0;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (label == vegetation)</div><div class="line">    {</div><div class="line">      r = 0; g = 255; b = 27;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (label == roof)</div><div class="line">    {</div><div class="line">      r = 255; g = 0; b = 170;</div><div class="line">    }</div><div class="line">    red.push_back(r);</div><div class="line">    green.push_back(g);</div><div class="line">    blue.push_back(b);</div><div class="line">  }</div><div class="line"></div><div class="line">  std::ofstream f (<span class="stringliteral">"classification.ply"</span>);</div><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3IOPly.html#gac1fd90a9d5266e631c68cb31bfe31516">CGAL::IO::write_PLY_with_properties</a></div><div class="line">    (f, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL.html#a266177f3e138c748f9906f7abb76320b">CGAL::make_range</a> (boost::counting_iterator&lt;std::size_t&gt;(0),</div><div class="line">                          boost::counting_iterator&lt;std::size_t&gt;(pts.size())),</div><div class="line">     <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3IOPly.html#ga241c6df9d93e26ec7254ef6366cb7e5b">CGAL::make_ply_point_writer</a> (CGAL::make_property_map(pts)),</div><div class="line">     std::make_pair(CGAL::make_property_map(red), CGAL::PLY_property&lt;unsigned char&gt;(<span class="stringliteral">"red"</span>)),</div><div class="line">     std::make_pair(CGAL::make_property_map(green), CGAL::PLY_property&lt;unsigned char&gt;(<span class="stringliteral">"green"</span>)),</div><div class="line">     std::make_pair(CGAL::make_property_map(blue), CGAL::PLY_property&lt;unsigned char&gt;(<span class="stringliteral">"blue"</span>)));</div><div class="line"></div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"All done"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Classification_example_feeature"></a>
Defining a Custom Feature</h2>
<p>The following example shows how to define a custom feature and how to integrate it in the CGAL classification framework.</p>
<p><br />
<b>File</b> <a class="el" href="Classification_2example_feature_8cpp-example.html">Classification/example_feature.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#if defined (_MSC_VER) &amp;&amp; !defined (_WIN64)</span></div><div class="line"><span class="preprocessor">#pragma warning(disable:4244) // boost::number_distance::distance()</span></div><div class="line">                              <span class="comment">// converts 64 to 32 bits integers</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Classification.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::Iso_cuboid_3</a> Iso_cuboid_3;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> CGAL::Identity_property_map&lt;Point&gt; Pmap;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Classification = <a class="code" href="namespaceCGAL_1_1Classification.html">CGAL::Classification</a>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Sum_of_weighted_features_classifier                      Classifier;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Point_set_neighborhood&lt;Kernel, Point_range, Pmap&gt;       Neighborhood;</div><div class="line"><span class="keyword">typedef</span> Classification::Local_eigen_analysis                                    Local_eigen_analysis;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Label_handle                                            Label_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_handle                                          Feature_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Label_set                                               Label_set;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_set                                             Feature_set;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Feature::Verticality&lt;Kernel&gt;                            Verticality;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// User-defined feature that identifies a specific area of the 3D</span></div><div class="line"><span class="comment">// space. This feature takes value 1 for points that lie inside the</span></div><div class="line"><span class="comment">// area and 0 for the others.</span></div><div class="line"><span class="keyword">class </span>My_feature : <span class="keyword">public</span> <a class="code" href="classCGAL_1_1Classification_1_1Feature__base.html">CGAL::Classification::Feature_base</a></div><div class="line">{</div><div class="line">  <span class="keyword">const</span> Point_range&amp; range;</div><div class="line">  <span class="keywordtype">double</span> xmin, xmax, ymin, ymax;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  My_feature (<span class="keyword">const</span> Point_range&amp; range,</div><div class="line">              <span class="keywordtype">double</span> xmin, <span class="keywordtype">double</span> xmax, <span class="keywordtype">double</span> ymin, <span class="keywordtype">double</span> ymax)</div><div class="line">    : range (range), xmin(xmin), xmax(xmax), ymin(ymin), ymax(ymax)</div><div class="line">  {</div><div class="line">    this-&gt;set_name (<span class="stringliteral">"my_feature"</span>);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">float</span> value (std::size_t pt_index)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (xmin &lt; range[pt_index].x() &amp;&amp; range[pt_index].x() &lt; xmax &amp;&amp;</div><div class="line">        ymin &lt; range[pt_index].y() &amp;&amp; range[pt_index].y() &lt; ymax)</div><div class="line">      <span class="keywordflow">return</span> 1.f;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <span class="keywordflow">return</span> 0.f;</div><div class="line">  }</div><div class="line"></div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::string filename (argc &gt; 1 ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/b9.ply"</span>));</div><div class="line">  std::vector&lt;Point&gt; pts;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Reading input"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">if</span> (!(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(filename, std::back_inserter(pts),</div><div class="line">                              <span class="comment">// the PLY reader expects a binary file by default</span></div><div class="line">                              CGAL::parameters::use_binary_mode(<span class="keyword">false</span>))))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read "</span> &lt;&lt; filename &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  Neighborhood neighborhood (pts, Pmap());</div><div class="line">  Local_eigen_analysis eigen</div><div class="line">    = Local_eigen_analysis::create_from_point_set (pts, Pmap(), neighborhood.k_neighbor_query(6));</div><div class="line"></div><div class="line">  Label_set labels;</div><div class="line">  Label_handle a = labels.add (<span class="stringliteral">"label_A"</span>);</div><div class="line">  Label_handle b = labels.add (<span class="stringliteral">"label_B"</span>);</div><div class="line"></div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Computing features"</span> &lt;&lt; std::endl;</div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  <span class="comment">// Feature that identifies points whose x coordinate is between -20</span></div><div class="line">  <span class="comment">// and 20 and whose y coordinate is between -15 and 15</span></div><div class="line">  Feature_handle my_feature = features.add&lt;My_feature&gt; (pts, -20., 20., -15., 15.);</div><div class="line"></div><div class="line"></div><div class="line">  Feature_handle verticality = features.add&lt;Verticality&gt; (pts, eigen);</div><div class="line"></div><div class="line">  Classifier classifier (labels, features);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Setting weights"</span> &lt;&lt; std::endl;</div><div class="line">  classifier.set_weight(verticality, 0.5);</div><div class="line">  classifier.set_weight(my_feature, 0.25);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Setting up labels"</span> &lt;&lt; std::endl;</div><div class="line">  classifier.set_effect (a, verticality, Classifier::FAVORING);</div><div class="line">  classifier.set_effect (a, my_feature, Classifier::FAVORING);</div><div class="line">  classifier.set_effect (b, verticality, Classifier::PENALIZING);</div><div class="line">  classifier.set_effect (b, my_feature, Classifier::PENALIZING);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classifying"</span> &lt;&lt; std::endl;</div><div class="line">  std::vector&lt;int&gt; label_indices(pts.size(), -1);</div><div class="line">  Classification::classify_with_graphcut&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (pts, Pmap(), labels, classifier,</div><div class="line">     neighborhood.k_neighbor_query(12),</div><div class="line">     0.5, 1, label_indices);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"All done"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Classification_example_training"></a>
Feature Generation and Training</h2>
<p>The following example:</p>
<ul>
<li>reads a point set with a training set (embedded as a PLY feature <em>label</em>);</li>
<li>automatically generates features on 5 scales;</li>
<li>trains the classifier <a class="el" href="classCGAL_1_1Classification_1_1Sum__of__weighted__features__classifier.html">Sum_of_weighted_features_classifier</a> using 800 trials;</li>
<li>runs the algorithm using the graphcut regularization;</li>
<li>prints some evaluation measurements;</li>
<li>saves the configuration of the classifier for further use.</li>
</ul>
<p><br />
<b>File</b> <a class="el" href="Classification_2example_generation_and_training_8cpp-example.html">Classification/example_generation_and_training.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#if defined (_MSC_VER) &amp;&amp; !defined (_WIN64)</span></div><div class="line"><span class="preprocessor">#pragma warning(disable:4244) // boost::number_distance::distance()</span></div><div class="line">                              <span class="comment">// converts 64 to 32 bits integers</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Classification.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3/IO.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> CGAL::Point_set_3&lt;Point&gt; Point_set;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::Iso_cuboid_3</a> Iso_cuboid_3;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Point_set::Point_map Pmap;</div><div class="line"><span class="keyword">typedef</span> Point_set::Property_map&lt;int&gt; Imap;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Classification = <a class="code" href="namespaceCGAL_1_1Classification.html">CGAL::Classification</a>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Label_handle                                            Label_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_handle                                          Feature_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Label_set                                               Label_set;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_set                                             Feature_set;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Sum_of_weighted_features_classifier                     Classifier;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Point_set_feature_generator&lt;Kernel, Point_set, Pmap&gt;    Feature_generator;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::string filename (argc &gt; 1 ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/b9_training.ply"</span>));</div><div class="line">  std::ifstream in (filename.c_str(), std::ios::binary);</div><div class="line">  Point_set pts;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Reading input"</span> &lt;&lt; std::endl;</div><div class="line">  in &gt;&gt; pts;</div><div class="line"></div><div class="line">  Imap label_map;</div><div class="line">  <span class="keywordtype">bool</span> lm_found = <span class="keyword">false</span>;</div><div class="line">  std::tie (label_map, lm_found) = pts.property_map&lt;<span class="keywordtype">int</span>&gt; (<span class="stringliteral">"label"</span>);</div><div class="line">  <span class="keywordflow">if</span> (!lm_found)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: \"label\" property not found in input file."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Generating features"</span> &lt;&lt; std::endl;</div><div class="line">  CGAL::Real_timer t;</div><div class="line">  t.start();</div><div class="line"></div><div class="line"></div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  std::size_t number_of_scales = 5;</div><div class="line">  Feature_generator generator (pts, pts.point_map(), number_of_scales);</div><div class="line"></div><div class="line">  features.begin_parallel_additions();</div><div class="line">  generator.generate_point_based_features (features);</div><div class="line">  features.end_parallel_additions();</div><div class="line"></div><div class="line"></div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; features.size() &lt;&lt; <span class="stringliteral">" feature(s) generated in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  Label_set labels = { <span class="stringliteral">"ground"</span>, <span class="stringliteral">"vegetation"</span>, <span class="stringliteral">"roof"</span> };</div><div class="line"></div><div class="line">  Classifier classifier (labels, features);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Training"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div><div class="line">  t.start();</div><div class="line">  classifier.train&lt;<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a>&gt; (pts.range(label_map), 800);</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  t.reset();</div><div class="line">  t.start();</div><div class="line">  std::vector&lt;int&gt; label_indices(pts.size(), -1);</div><div class="line">  Classification::classify_with_graphcut&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (pts, pts.point_map(), labels, classifier,</div><div class="line">     generator.neighborhood().k_neighbor_query(12),</div><div class="line">     0.2f, 10, label_indices);</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classification with graphcut done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Precision, recall, F1 scores and IoU:"</span> &lt;&lt; std::endl;</div><div class="line">  Classification::Evaluation evaluation (labels, pts.range(label_map), label_indices);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (Label_handle l : labels)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">" * "</span> &lt;&lt; l-&gt;name() &lt;&lt; <span class="stringliteral">": "</span></div><div class="line">              &lt;&lt; evaluation.precision(l) &lt;&lt; <span class="stringliteral">" ; "</span></div><div class="line">              &lt;&lt; evaluation.recall(l) &lt;&lt; <span class="stringliteral">" ; "</span></div><div class="line">              &lt;&lt; evaluation.f1_score(l) &lt;&lt; <span class="stringliteral">" ; "</span></div><div class="line">              &lt;&lt; evaluation.intersection_over_union(l) &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Accuracy = "</span> &lt;&lt; evaluation.accuracy() &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">"Mean F1 score = "</span> &lt;&lt; evaluation.mean_f1_score() &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">"Mean IoU = "</span> &lt;&lt; evaluation.mean_intersection_over_union() &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">  std::ofstream fconfig (<span class="stringliteral">"config.xml"</span>);</div><div class="line">  classifier.save_configuration (fconfig);</div><div class="line">  fconfig.close();</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"All done"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Classification_example_ethz_random_forest"></a>
ETHZ Random Forest</h2>
<p>The following example shows how to use the classifier <a class="el" href="classCGAL_1_1Classification_1_1ETHZ_1_1Random__forest__classifier.html">ETHZ::Random_forest_classifier</a> using an input training set.</p>
<p><br />
<b>File</b> <a class="el" href="Classification_2example_ethz_random_forest_8cpp-example.html">Classification/example_ethz_random_forest.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#if defined (_MSC_VER) &amp;&amp; !defined (_WIN64)</span></div><div class="line"><span class="preprocessor">#pragma warning(disable:4244) // boost::number_distance::distance()</span></div><div class="line">                              <span class="comment">// converts 64 to 32 bits integers</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Classification.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3/IO.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> CGAL::Point_set_3&lt;Point&gt; Point_set;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::Iso_cuboid_3</a> Iso_cuboid_3;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Point_set::Point_map Pmap;</div><div class="line"><span class="keyword">typedef</span> Point_set::Property_map&lt;int&gt; Imap;</div><div class="line"><span class="keyword">typedef</span> Point_set::Property_map&lt;unsigned char&gt; UCmap;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Classification = <a class="code" href="namespaceCGAL_1_1Classification.html">CGAL::Classification</a>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Label_handle                                            Label_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_handle                                          Feature_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Label_set                                               Label_set;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_set                                             Feature_set;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Point_set_feature_generator&lt;Kernel, Point_set, Pmap&gt;    Feature_generator;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::string filename = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/b9_training.ply"</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1)</div><div class="line">    filename = argv[1];</div><div class="line"></div><div class="line">  std::ifstream in (filename.c_str(), std::ios::binary);</div><div class="line">  Point_set pts;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Reading input"</span> &lt;&lt; std::endl;</div><div class="line">  in &gt;&gt; pts;</div><div class="line"></div><div class="line">  Imap label_map;</div><div class="line">  <span class="keywordtype">bool</span> lm_found = <span class="keyword">false</span>;</div><div class="line">  std::tie (label_map, lm_found) = pts.property_map&lt;<span class="keywordtype">int</span>&gt; (<span class="stringliteral">"label"</span>);</div><div class="line">  <span class="keywordflow">if</span> (!lm_found)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: \"label\" property not found in input file."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Generating features"</span> &lt;&lt; std::endl;</div><div class="line">  CGAL::Real_timer t;</div><div class="line">  t.start();</div><div class="line">  Feature_generator generator (pts, pts.point_map(),</div><div class="line">                               5);  <span class="comment">// using 5 scales</span></div><div class="line"></div><div class="line">  features.begin_parallel_additions();</div><div class="line">  generator.generate_point_based_features (features);</div><div class="line">  features.end_parallel_additions();</div><div class="line"></div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Add labels</span></div><div class="line">  Label_set labels;</div><div class="line">  Label_handle ground = labels.add (<span class="stringliteral">"ground"</span>);</div><div class="line">  Label_handle vegetation = labels.add (<span class="stringliteral">"vegetation"</span>);</div><div class="line">  Label_handle roof = labels.add (<span class="stringliteral">"roof"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Check if ground truth is valid for this label set</span></div><div class="line">  <span class="keywordflow">if</span> (!labels.is_valid_ground_truth (pts.range(label_map), <span class="keyword">true</span>))</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line"></div><div class="line">  std::vector&lt;int&gt; label_indices(pts.size(), -1);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Using ETHZ Random Forest Classifier"</span> &lt;&lt; std::endl;</div><div class="line">  Classification::ETHZ::Random_forest_classifier classifier (labels, features);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Training"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div><div class="line">  t.start();</div><div class="line">  classifier.train (pts.range(label_map));</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  t.reset();</div><div class="line">  t.start();</div><div class="line">  Classification::classify_with_graphcut&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (pts, pts.point_map(), labels, classifier,</div><div class="line">     generator.neighborhood().k_neighbor_query(12),</div><div class="line">     0.2f, 1, label_indices);</div><div class="line">  t.stop();</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classification with graphcut done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Precision, recall, F1 scores and IoU:"</span> &lt;&lt; std::endl;</div><div class="line">  Classification::Evaluation evaluation (labels, pts.range(label_map), label_indices);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (Label_handle l : labels)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">" * "</span> &lt;&lt; l-&gt;name() &lt;&lt; <span class="stringliteral">": "</span></div><div class="line">              &lt;&lt; evaluation.precision(l) &lt;&lt; <span class="stringliteral">" ; "</span></div><div class="line">              &lt;&lt; evaluation.recall(l) &lt;&lt; <span class="stringliteral">" ; "</span></div><div class="line">              &lt;&lt; evaluation.f1_score(l) &lt;&lt; <span class="stringliteral">" ; "</span></div><div class="line">              &lt;&lt; evaluation.intersection_over_union(l) &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Accuracy = "</span> &lt;&lt; evaluation.accuracy() &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">"Mean F1 score = "</span> &lt;&lt; evaluation.mean_f1_score() &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">"Mean IoU = "</span> &lt;&lt; evaluation.mean_intersection_over_union() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Color point set according to class</span></div><div class="line">  UCmap red = pts.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"red"</span>, 0).first;</div><div class="line">  UCmap green = pts.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"green"</span>, 0).first;</div><div class="line">  UCmap blue = pts.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"blue"</span>, 0).first;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; label_indices.size(); ++ i)</div><div class="line">  {</div><div class="line">    label_map[i] = label_indices[i]; <span class="comment">// update label map with computed classification</span></div><div class="line"></div><div class="line">    Label_handle label = labels[label_indices[i]];</div><div class="line">    <span class="keyword">const</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a>&amp; color = label-&gt;color();</div><div class="line">    red[i] = color.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html#af428aec48cc6ce23776b5f8cdf2a7883">red</a>();</div><div class="line">    green[i] = color.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html#afc04b32226660e92c55c5855d7ae0c5f">green</a>();</div><div class="line">    blue[i] = color.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html#aee7a7d6b78b2045840c4a292c26500df">blue</a>();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Save configuration for later use</span></div><div class="line">  std::ofstream fconfig (<span class="stringliteral">"ethz_random_forest.bin"</span>, std::ios_base::binary);</div><div class="line">  classifier.save_configuration(fconfig);</div><div class="line"></div><div class="line">  <span class="comment">// Write result</span></div><div class="line">  std::ofstream f (<span class="stringliteral">"classification.ply"</span>);</div><div class="line">  f.precision(18);</div><div class="line">  f &lt;&lt; pts;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"All done"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Classification_example_opencv_random_forest"></a>
OpenCV Random Forest</h2>
<p>The following example shows how to use the classifier <a class="el" href="classCGAL_1_1Classification_1_1OpenCV_1_1Random__forest__classifier.html">OpenCV::Random_forest_classifier</a> using an input training set.</p>
<p><br />
<b>File</b> <a class="el" href="Classification_2example_opencv_random_forest_8cpp-example.html">Classification/example_opencv_random_forest.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#if defined (_MSC_VER) &amp;&amp; !defined (_WIN64)</span></div><div class="line"><span class="preprocessor">#pragma warning(disable:4244) // boost::number_distance::distance()</span></div><div class="line">                              <span class="comment">// converts 64 to 32 bits integers</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Classification.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3/IO.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> CGAL::Point_set_3&lt;Point&gt; Point_set;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::Iso_cuboid_3</a> Iso_cuboid_3;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Point_set::Point_map Pmap;</div><div class="line"><span class="keyword">typedef</span> Point_set::Property_map&lt;int&gt; Imap;</div><div class="line"><span class="keyword">typedef</span> Point_set::Property_map&lt;unsigned char&gt; UCmap;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Classification = <a class="code" href="namespaceCGAL_1_1Classification.html">CGAL::Classification</a>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Label_handle                                            Label_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_handle                                          Feature_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Label_set                                               Label_set;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_set                                             Feature_set;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Point_set_feature_generator&lt;Kernel, Point_set, Pmap&gt;    Feature_generator;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::string filename = (argc &gt; 1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/b9_training.ply"</span>);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Reading input"</span> &lt;&lt; std::endl;</div><div class="line">  std::ifstream in (filename.c_str(), std::ios::binary);</div><div class="line">  Point_set pts;</div><div class="line">  in &gt;&gt; pts;</div><div class="line"></div><div class="line">  Imap label_map;</div><div class="line">  <span class="keywordtype">bool</span> lm_found = <span class="keyword">false</span>;</div><div class="line">  std::tie (label_map, lm_found) = pts.property_map&lt;<span class="keywordtype">int</span>&gt; (<span class="stringliteral">"label"</span>);</div><div class="line">  <span class="keywordflow">if</span> (!lm_found)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: \"label\" property not found in input file."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Generating features"</span> &lt;&lt; std::endl;</div><div class="line">  CGAL::Real_timer t;</div><div class="line">  t.start();</div><div class="line">  Feature_generator generator (pts, pts.point_map(),</div><div class="line">                               5);  <span class="comment">// using 5 scales</span></div><div class="line"></div><div class="line">  features.begin_parallel_additions();</div><div class="line">  generator.generate_point_based_features (features);</div><div class="line">  features.end_parallel_additions();</div><div class="line"></div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Add labels</span></div><div class="line">  Label_set labels;</div><div class="line">  Label_handle ground = labels.add (<span class="stringliteral">"ground"</span>);</div><div class="line">  Label_handle vegetation = labels.add (<span class="stringliteral">"vegetation"</span>);</div><div class="line">  Label_handle roof = labels.add (<span class="stringliteral">"roof"</span>);</div><div class="line"></div><div class="line">  std::vector&lt;int&gt; label_indices(pts.size(), -1);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Using OpenCV Random Forest Classifier"</span> &lt;&lt; std::endl;</div><div class="line">  Classification::OpenCV::Random_forest_classifier classifier (labels, features);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Training"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div><div class="line">  t.start();</div><div class="line">  classifier.train (pts.range(label_map));</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  t.reset();</div><div class="line">  t.start();</div><div class="line">  Classification::classify_with_graphcut&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (pts, pts.point_map(), labels, classifier,</div><div class="line">     generator.neighborhood().k_neighbor_query(12),</div><div class="line">     0.2f, 1, label_indices);</div><div class="line">  t.stop();</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classification with graphcut done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Precision, recall, F1 scores and IoU:"</span> &lt;&lt; std::endl;</div><div class="line">  Classification::Evaluation evaluation (labels, pts.range(label_map), label_indices);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (Label_handle l : labels)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">" * "</span> &lt;&lt; l-&gt;name() &lt;&lt; <span class="stringliteral">": "</span></div><div class="line">              &lt;&lt; evaluation.precision(l) &lt;&lt; <span class="stringliteral">" ; "</span></div><div class="line">              &lt;&lt; evaluation.recall(l) &lt;&lt; <span class="stringliteral">" ; "</span></div><div class="line">              &lt;&lt; evaluation.f1_score(l) &lt;&lt; <span class="stringliteral">" ; "</span></div><div class="line">              &lt;&lt; evaluation.intersection_over_union(l) &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Accuracy = "</span> &lt;&lt; evaluation.accuracy() &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">"Mean F1 score = "</span> &lt;&lt; evaluation.mean_f1_score() &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">"Mean IoU = "</span> &lt;&lt; evaluation.mean_intersection_over_union() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Color point set according to class</span></div><div class="line">  UCmap red = pts.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"red"</span>, 0).first;</div><div class="line">  UCmap green = pts.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"green"</span>, 0).first;</div><div class="line">  UCmap blue = pts.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"blue"</span>, 0).first;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; label_indices.size(); ++ i)</div><div class="line">  {</div><div class="line">    label_map[i] = label_indices[i]; <span class="comment">// update label map with computed classification</span></div><div class="line"></div><div class="line">    Label_handle label = labels[label_indices[i]];</div><div class="line">    <span class="keyword">const</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a>&amp; color = label-&gt;color();</div><div class="line">    red[i] = color.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html#af428aec48cc6ce23776b5f8cdf2a7883">red</a>();</div><div class="line">    green[i] = color.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html#afc04b32226660e92c55c5855d7ae0c5f">green</a>();</div><div class="line">    blue[i] = color.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html#aee7a7d6b78b2045840c4a292c26500df">blue</a>();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Write result</span></div><div class="line">  std::ofstream f (<span class="stringliteral">"classification.ply"</span>);</div><div class="line">  f.precision(18);</div><div class="line">  f &lt;&lt; pts;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"All done"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Classification_example_mesh"></a>
Mesh Classification</h2>
<p>The following example:</p>
<ul>
<li>reads a mesh in OFF format;</li>
<li>automatically generates features on 5 scales;</li>
<li>loads a configuration file for classifier <a class="el" href="classCGAL_1_1Classification_1_1ETHZ_1_1Random__forest__classifier.html">ETHZ::Random_forest_classifier</a>;</li>
<li>runs the algorithm using the graphcut regularization.</li>
</ul>
<p><br />
<b>File</b> <a class="el" href="Classification_2example_mesh_classification_8cpp-example.html">Classification/example_mesh_classification.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#if defined (_MSC_VER) &amp;&amp; !defined (_WIN64)</span></div><div class="line"><span class="preprocessor">#pragma warning(disable:4244) // boost::number_distance::distance()</span></div><div class="line">                              <span class="comment">// converts 64 to 32 bits integers</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Classification.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> CGAL::Surface_mesh&lt;Point&gt; Mesh;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Classification = <a class="code" href="namespaceCGAL_1_1Classification.html">CGAL::Classification</a>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Label_handle                                            Label_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_handle                                          Feature_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Label_set                                               Label_set;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_set                                             Feature_set;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Face_descriptor_to_center_of_mass_map&lt;Mesh&gt;             Face_point_map;</div><div class="line"><span class="keyword">typedef</span> Classification::Face_descriptor_to_face_descriptor_with_bbox_map&lt;Mesh&gt;  Face_with_bbox_map;</div><div class="line"><span class="keyword">typedef</span> Classification::Mesh_feature_generator&lt;Kernel, Mesh, Face_point_map&gt;    Feature_generator;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::string filename = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/b9_mesh.off"</span>);</div><div class="line">  std::string filename_config = <span class="stringliteral">"data/b9_mesh_config.bin"</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1)</div><div class="line">    filename = argv[1];</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 2)</div><div class="line">    filename_config = argv[2];</div><div class="line"></div><div class="line">  Mesh mesh;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLIOFct.html#ga49f5b5e6fbfcbfaaac7604c88e10915c">CGAL::IO::read_polygon_mesh</a>(filename, mesh,</div><div class="line">                                  <span class="comment">// the PLY reader expects a binary file by default</span></div><div class="line">                                  CGAL::parameters::use_binary_mode(<span class="keyword">false</span>)))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Generating features"</span> &lt;&lt; std::endl;</div><div class="line">  CGAL::Real_timer t;</div><div class="line">  t.start();</div><div class="line"></div><div class="line"></div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  Face_point_map face_point_map (&amp;mesh); <span class="comment">// Associates each face to its center of mass</span></div><div class="line"></div><div class="line">  std::size_t number_of_scales = 5;</div><div class="line">  Feature_generator generator (mesh, face_point_map, number_of_scales);</div><div class="line"></div><div class="line">  features.begin_parallel_additions();</div><div class="line">  generator.generate_point_based_features (features); <span class="comment">// Features that consider the mesh as a point set</span></div><div class="line">  generator.generate_face_based_features (features);  <span class="comment">// Features computed directly on mesh faces</span></div><div class="line">  features.end_parallel_additions();</div><div class="line"></div><div class="line"></div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  Label_set labels = { <span class="stringliteral">"ground"</span>, <span class="stringliteral">"vegetation"</span>, <span class="stringliteral">"roof"</span> };</div><div class="line"></div><div class="line">  std::vector&lt;int&gt; label_indices(mesh.number_of_faces(), -1);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Using ETHZ Random Forest Classifier"</span> &lt;&lt; std::endl;</div><div class="line">  Classification::ETHZ::Random_forest_classifier classifier (labels, features);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Loading configuration"</span> &lt;&lt; std::endl;</div><div class="line">  std::ifstream in_config (filename_config, std::ios_base::in | std::ios_base::binary);</div><div class="line">  classifier.load_configuration (in_config);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classifying with graphcut"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div><div class="line">  t.start();</div><div class="line">  Classification::classify_with_graphcut&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (mesh.faces(), Face_with_bbox_map(&amp;mesh), labels, classifier,</div><div class="line">     generator.neighborhood().n_ring_neighbor_query(2),</div><div class="line">     0.2f, 1, label_indices);</div><div class="line">  t.stop();</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classification with graphcut done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Classification_example_cluster"></a>
Cluster Classification</h2>
<p>The following example:</p>
<ul>
<li>reads a point set in PLY format;</li>
<li>estimates the normal vectors of the point set;</li>
<li>automatically generates pointwise features on 5 scales;</li>
<li>detects plane using the algorithm <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Region__growing.html">CGAL::Shape_detection::Region_growing</a></code>;</li>
<li>creates <a class="el" href="classCGAL_1_1Classification_1_1Cluster.html">Cluster</a> objects from these detected planes;</li>
<li>computes cluster features from the pointwise features;</li>
<li>loads a configuration file for classifier <a class="el" href="classCGAL_1_1Classification_1_1ETHZ_1_1Random__forest__classifier.html">ETHZ::Random_forest_classifier</a>;</li>
<li>runs the algorithm using the raw algorithm.</li>
</ul>
<p><br />
<b>File</b> <a class="el" href="Classification_2example_cluster_classification_8cpp-example.html">Classification/example_cluster_classification.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#if defined (_MSC_VER) &amp;&amp; !defined (_WIN64)</span></div><div class="line"><span class="preprocessor">#pragma warning(disable:4244) // boost::number_distance::distance()</span></div><div class="line">                              <span class="comment">// converts 64 to 32 bits integers</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/iterator/function_output_iterator.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Classification.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3/IO.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/jet_estimate_normals.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/Region__growing_8h.html">CGAL/Shape_detection/Region_growing.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::Iso_cuboid_3</a>           Iso_cuboid_3;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> CGAL::Point_set_3&lt;Point&gt; Point_set;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Point_set::Point_map                   Pmap;</div><div class="line"><span class="keyword">typedef</span> Point_set::Vector_map                  Vmap;</div><div class="line"><span class="keyword">typedef</span> Point_set::Property_map&lt;int&gt;           Imap;</div><div class="line"><span class="keyword">typedef</span> Point_set::Property_map&lt;unsigned char&gt; UCmap;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Point__set_1_1Sphere__neighbor__query.html">CGAL::Shape_detection::Point_set::Sphere_neighbor_query&lt;Kernel, Point_set, Pmap&gt;</a>                Neighbor_query;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Point__set_1_1Least__squares__plane__fit__region.html">CGAL::Shape_detection::Point_set::Least_squares_plane_fit_region&lt;Kernel, Point_set, Pmap, Vmap&gt;</a> Region_type;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Region__growing.html">CGAL::Shape_detection::Region_growing&lt;Point_set, Neighbor_query, Region_type&gt;</a>                   Region_growing;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Classification = <a class="code" href="namespaceCGAL_1_1Classification.html">CGAL::Classification</a>;</div><div class="line"><span class="keyword">namespace </span>Feature = <a class="code" href="namespaceCGAL_1_1Classification_1_1Feature.html">CGAL::Classification::Feature</a>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Label_handle   Label_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_handle Feature_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Label_set      Label_set;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_set    Feature_set;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Local_eigen_analysis                                 Local_eigen_analysis;</div><div class="line"><span class="keyword">typedef</span> Classification::Point_set_feature_generator&lt;Kernel, Point_set, Pmap&gt; Feature_generator;</div><div class="line"><span class="keyword">typedef</span> Classification::Cluster&lt;Point_set, Pmap&gt;                             Cluster;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::string filename        = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/b9.ply"</span>);</div><div class="line">  std::string filename_config = <span class="stringliteral">"data/b9_clusters_config.bin"</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1)</div><div class="line">    filename = argv[1];</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 2)</div><div class="line">    filename_config = argv[2];</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Reading input"</span> &lt;&lt; std::endl;</div><div class="line">  Point_set pts;</div><div class="line">  <span class="keywordflow">if</span>(!(CGAL::IO::read_point_set(filename, pts,</div><div class="line">                                <span class="comment">// the PLY reader expects a binary file by default</span></div><div class="line">                                CGAL::parameters::use_binary_mode(<span class="keyword">true</span>))))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read "</span> &lt;&lt; filename &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Estimating normals"</span> &lt;&lt; std::endl;</div><div class="line">  CGAL::Real_timer t;</div><div class="line">  t.start();</div><div class="line">  pts.add_normal_map();</div><div class="line">  CGAL::jet_estimate_normals&lt;CGAL::Parallel_if_available_tag&gt; (pts, 12);</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div><div class="line"></div><div class="line">  Feature_set pointwise_features;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Generating pointwise features"</span> &lt;&lt; std::endl;</div><div class="line">  t.start();</div><div class="line">  Feature_generator generator (pts, pts.point_map(), 5); <span class="comment">// using 5 scales</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef CGAL_LINKED_WITH_TBB</span></div><div class="line">  pointwise_features.begin_parallel_additions();</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">  generator.generate_point_based_features (pointwise_features);</div><div class="line"></div><div class="line">  <span class="comment">// Generator should only be used with variables defined at the scope</span></div><div class="line">  <span class="comment">// of the generator object, thus we instantiate the normal map</span></div><div class="line">  <span class="comment">// outside of the function</span></div><div class="line">  Vmap normal_map = pts.normal_map();</div><div class="line">  generator.generate_normal_based_features (pointwise_features, normal_map);</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef CGAL_LINKED_WITH_TBB</span></div><div class="line">  pointwise_features.end_parallel_additions();</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Detecting planes and creating clusters"</span> &lt;&lt; std::endl;</div><div class="line">  t.start();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> search_sphere_radius  = 1.0;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> max_distance_to_plane = 1.0;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> max_accepted_angle    = 25.0;</div><div class="line">  <span class="keyword">const</span> std::size_t min_region_size  = 10;</div><div class="line"></div><div class="line">  Neighbor_query neighbor_query (</div><div class="line">    pts, CGAL::parameters::sphere_radius(search_sphere_radius)</div><div class="line">                          .point_map(pts.point_map()));</div><div class="line">  Region_type region_type(</div><div class="line">    pts, CGAL::parameters::maximum_distance(max_distance_to_plane)</div><div class="line">                          .maximum_angle(max_accepted_angle)</div><div class="line">                          .minimum_region_size(min_region_size)</div><div class="line">                          .point_map(pts.point_map())</div><div class="line">                          .normal_map(pts.normal_map()));</div><div class="line">  Region_growing region_growing (</div><div class="line">    pts, neighbor_query, region_type);</div><div class="line"></div><div class="line">  std::vector&lt;Cluster&gt; clusters;</div><div class="line">  region_growing.detect</div><div class="line">    (boost::make_function_output_iterator</div><div class="line">     ([&amp;](<span class="keyword">const</span> std::vector&lt;std::size_t&gt;&amp; region) -&gt; <span class="keywordtype">void</span> {</div><div class="line"></div><div class="line">        <span class="comment">// Create a new cluster.</span></div><div class="line">        Classification::Cluster&lt;Point_set, Pmap&gt; cluster (pts, pts.point_map());</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> std::size_t idx : region)</div><div class="line">          cluster.insert(idx);</div><div class="line">        clusters.push_back(cluster);</div><div class="line">      }));</div><div class="line"></div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; clusters.size() &lt;&lt; <span class="stringliteral">" clusters created in "</span></div><div class="line">            &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div><div class="line"></div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Computing cluster features"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">  Local_eigen_analysis eigen = Local_eigen_analysis::create_from_point_clusters (clusters);</div><div class="line"></div><div class="line"></div><div class="line">  t.start();</div><div class="line"></div><div class="line"></div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  <span class="comment">// First, compute means of features.</span></div><div class="line">  features.begin_parallel_additions();</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; pointwise_features.size(); ++ i)</div><div class="line">    features.add&lt;Feature::Cluster_mean_of_feature&gt; (clusters, pointwise_features[i]);</div><div class="line">  features.end_parallel_additions();</div><div class="line"></div><div class="line">  <span class="comment">// Then, compute variances of features (and remaining cluster features).</span></div><div class="line">  features.begin_parallel_additions();</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; pointwise_features.size(); ++ i)</div><div class="line">    features.add&lt;Feature::Cluster_variance_of_feature&gt; (clusters,</div><div class="line">                                                        pointwise_features[i], <span class="comment">// i^th feature</span></div><div class="line">                                                        features[i]);          <span class="comment">// mean of i^th feature</span></div><div class="line"></div><div class="line">  features.add&lt;Feature::Cluster_size&gt; (clusters);</div><div class="line">  features.add&lt;Feature::Cluster_vertical_extent&gt; (clusters);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; 3; ++ i)</div><div class="line">    features.add&lt;Feature::Eigenvalue&gt; (clusters, eigen, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(i));</div><div class="line"></div><div class="line">  features.end_parallel_additions();</div><div class="line"></div><div class="line"></div><div class="line">  t.stop();</div><div class="line"></div><div class="line">  Label_set labels = { <span class="stringliteral">"ground"</span>, <span class="stringliteral">"vegetation"</span>, <span class="stringliteral">"roof"</span> };</div><div class="line"></div><div class="line">  std::vector&lt;int&gt; label_indices(clusters.size(), -1);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Using ETHZ Random Forest Classifier"</span> &lt;&lt; std::endl;</div><div class="line">  Classification::ETHZ::Random_forest_classifier classifier (labels, features);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Loading configuration"</span> &lt;&lt; std::endl;</div><div class="line">  std::ifstream in_config (filename_config, std::ios_base::in | std::ios_base::binary);</div><div class="line">  classifier.load_configuration (in_config);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classifying"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div><div class="line">  t.start();</div><div class="line">  Classification::classify&lt;CGAL::Parallel_if_available_tag&gt; (clusters, labels, classifier, label_indices);</div><div class="line">  t.stop();</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classification done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Classification_history"></a>
History</h1>
<p>This package is based on a research code by <a href="https://www-sop.inria.fr/members/Florent.Lafarge/">Florent Lafarge</a> that was generalized, extended and packaged by <a href="http://geometryfactory.com/who-we-are/">Simon Giraudot</a> in CGAL 4.12. Classification of surface meshes and of clusters were introduced in CGAL 4.13. The Neural Network classifier was introduced in CGAL 4.14. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Jul 5 2022 09:51:36 for CGAL 5.6 - Classification by
    <a href="https://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>
</html>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.6 - Classification
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Classification"></a> </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Authors</dt><dd>Simon Giraudot, Florent Lafarge</dd></dl>
<p>This component implements the algorithm described in <a class="el" href="citelist.html#CITEREF_cgal:lm-clscm-12">[4]</a> (section 2), generalized to handle different types of data, multiple features and multiple labels. It classifies a data set into a user-defined set of labels, such as <em>ground</em>, <em>vegetation</em> and <em>buildings</em>. A flexible API is provided so that users can classify any type of data which they can index and for which they can compute relevant features, compute their own local features on the input data set and define their own labels.</p>
<h1><a class="anchor" id="Classification_Organization"></a>
Package Organization</h1>
<p>Classification of data sets is achieved as follows (see Figure <a class="el" href="index.html#fig__Classification_organization_fig">Figure 84.1</a>):</p>
<ul>
<li>some analysis is performed on the input data set;</li>
<li>features are computed based on this analysis;</li>
<li>a set of labels (for example: <em>ground</em>, <em>building</em>, <em>vegetation</em>) is defined by the user;</li>
<li>a classifier is defined and trained: from the set of values taken by the features at an input item, it measures the likelihood of this item to belong to one label or another;</li>
<li>classification is computed itemwise using the classifier;</li>
<li>additional regularization can be used by smoothing either locally or globally through a <em>graph cut</em> <a class="el" href="citelist.html#CITEREF_Boykov2001FastApproximate">[1]</a> approach.</li>
</ul>
<p><a class="anchor" id="fig__Classification_organization_fig"></a></p><div class="image">
<object type="image/svg+xml" data="organization.svg">organization.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Classification_organization_fig">Figure 84.1</a> Organization of the package.  </div> <br /> 
<p>This package is designed to be easily extended by users: more specifically, features and labels can be defined by users to handle any data they need to classify.</p>
<p>Currently, CGAL provides data structures to handle classification of point sets, surface meshes and clusters.</p>
<h1><a class="anchor" id="Classification_structures"></a>
Common Data Structures</h1>
<h2><a class="anchor" id="Classification_labels"></a>
Label Set</h2>
<p>A label represents how an item should be classified, for example: <em>vegetation</em>, <em>building</em>, <em>road</em>, etc. In CGAL, a label has a name, an index (in a label set), a standard index (for example, the index of the label in the ASPRS standard) and a color. It is simply identified by a <a class="el" href="classCGAL_1_1Classification_1_1Label__handle.html">Label_handle</a>. Note that names, standard indices and colors are not used for identification: two labels in the same set can have the same name, standard index and color but not the same handle.</p>
<p>If labels are initialized with their names only, standard indices and colors can be deduced in some cases (see <a class="el" href="classCGAL_1_1Classification_1_1Label__set.html#afaa0d2e86c20b0c7ef19ce5e3f6b1104">Label_set::add()</a>).</p>
<p>The following code snippet shows how to add labels to the classification object:</p>
<div class="fragment"><div class="line"></div><div class="line">  Label_set labels;</div><div class="line"></div><div class="line">  <span class="comment">// Init name only</span></div><div class="line">  Label_handle ground = labels.add (<span class="stringliteral">"ground"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Init name and color</span></div><div class="line">  Label_handle vegetation = labels.add (<span class="stringliteral">"vegetation"</span>, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a>(0,255,0));</div><div class="line"></div><div class="line">  <span class="comment">// Init name, Color and standard index (here, ASPRS building index)</span></div><div class="line">  Label_handle roof = labels.add (<span class="stringliteral">"roof"</span>, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a> (255, 0, 0), 6);</div><div class="line"></div></div><!-- fragment --> <h2><a class="anchor" id="Classification_features"></a>
Feature Set</h2>
<p>Features are defined as scalar fields that associate each input item with a specific value. Note that in order to limit memory consumption, we use the type <code>float</code> for these scalar values (as well as for every floating point value in this package). A feature has a name and is identified by a <a class="el" href="classCGAL_1_1Classification_1_1Feature__handle.html">Feature_handle</a>.</p>
<p>The computation of features and their addition to the feature set is done in a single step using the <a class="el" href="classCGAL_1_1Classification_1_1Feature__set.html#a2d7dc5beaa908425dcf000ed441aa4bf">Feature_set::add&lt;Feature&gt;()</a> method. If CGAL was linked with <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartyTBB">Intel TBB</a>, features can be computed in parallel (see below).</p>
<p>CGAL provides some predefined features (see <a class="el" href="index.html#Classification_point_sets">Point Set Classification</a> for example). In the following code snippet, a subset of these predefined features are instantiated (in parallel if <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartyTBB">Intel TBB</a> is available). Note that all the predefined features can also be automatically generated in multiple scales (see <a class="el" href="index.html#Classification_point_sets">Point Set Classification</a> for example).</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="keywordtype">float</span> radius_neighbors = 1.7f;</div><div class="line">  <span class="keywordtype">float</span> radius_dtm = 15.0f;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Computing features"</span> &lt;&lt; std::endl;</div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  features.begin_parallel_additions(); <span class="comment">// No effect in sequential mode</span></div><div class="line"></div><div class="line">  Feature_handle distance_to_plane = features.add&lt;Distance_to_plane&gt; (pts, Pmap(), eigen);</div><div class="line">  Feature_handle dispersion = features.add&lt;Dispersion&gt; (pts, Pmap(), grid,</div><div class="line">                                                        radius_neighbors);</div><div class="line">  Feature_handle elevation = features.add&lt;Elevation&gt; (pts, Pmap(), grid,</div><div class="line">                                                      radius_dtm);</div><div class="line"></div><div class="line">  features.end_parallel_additions(); <span class="comment">// No effect in sequential mode</span></div><div class="line"></div></div><!-- fragment --><p> Users may want to define their own features, especially if the input data set comes with additional properties that were not anticipated by CGAL. A user-defined feature must inherit from <a class="el" href="classCGAL_1_1Classification_1_1Feature__base.html">Feature_base</a> and provide a method <a class="el" href="classCGAL_1_1Classification_1_1Feature__base.html#a601e16c0026bd33f28fc8bfd68b30461">value()</a> that associates a scalar value to each input item.</p>
<p>The following example shows how to define a feature that discriminates points that lie inside a 2D box from the others:</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="comment">// User-defined feature that identifies a specific area of the 3D</span></div><div class="line"><span class="comment">// space. This feature takes value 1 for points that lie inside the</span></div><div class="line"><span class="comment">// area and 0 for the others.</span></div><div class="line"><span class="keyword">class </span>My_feature : <span class="keyword">public</span> <a class="code" href="classCGAL_1_1Classification_1_1Feature__base.html">CGAL::Classification::Feature_base</a></div><div class="line">{</div><div class="line">  <span class="keyword">const</span> Point_range&amp; range;</div><div class="line">  <span class="keywordtype">double</span> xmin, xmax, ymin, ymax;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  My_feature (<span class="keyword">const</span> Point_range&amp; range,</div><div class="line">              <span class="keywordtype">double</span> xmin, <span class="keywordtype">double</span> xmax, <span class="keywordtype">double</span> ymin, <span class="keywordtype">double</span> ymax)</div><div class="line">    : range (range), xmin(xmin), xmax(xmax), ymin(ymin), ymax(ymax)</div><div class="line">  {</div><div class="line">    this-&gt;set_name (<span class="stringliteral">"my_feature"</span>);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">float</span> value (std::size_t pt_index)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (xmin &lt; range[pt_index].x() &amp;&amp; range[pt_index].x() &lt; xmax &amp;&amp;</div><div class="line">        ymin &lt; range[pt_index].y() &amp;&amp; range[pt_index].y() &lt; ymax)</div><div class="line">      <span class="keywordflow">return</span> 1.f;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <span class="keywordflow">return</span> 0.f;</div><div class="line">  }</div><div class="line"></div><div class="line">};</div><div class="line"></div></div><!-- fragment --><p> This feature can then be instantiated from the feature set the same way as the others:</p>
<div class="fragment"><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Computing features"</span> &lt;&lt; std::endl;</div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  <span class="comment">// Feature that identifies points whose x coordinate is between -20</span></div><div class="line">  <span class="comment">// and 20 and whose y coordinate is between -15 and 15</span></div><div class="line">  Feature_handle my_feature = features.add&lt;My_feature&gt; (pts, -20., 20., -15., 15.);</div><div class="line"></div></div><!-- fragment --> <h1><a class="anchor" id="Classification_structures_specialized"></a>
Specialized Data Structures</h1>
<p>Classification is based on the computation of local features. These features can take advantage of shared data structures that are precomputed and stored separately. Both these features and the underlying data structures depend on the type of data that needs to be classified. CGAL provides data structures to classify point sets, surface meshes and clusters.</p>
<h2><a class="anchor" id="Classification_point_sets"></a>
Point Set Classification</h2>
<p>CGAL provides the following structures:</p>
<ul>
<li><a class="el" href="classCGAL_1_1Classification_1_1Point__set__neighborhood.html">Point_set_neighborhood</a> stores spatial searching structures and provides adapted queries for points;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Local__eigen__analysis.html">Local_eigen_analysis</a> precomputes covariance matrices on local neighborhoods of points and stores the associated eigenvectors and eigenvalues;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Planimetric__grid.html">Planimetric_grid</a> is a 2D grid used for digital terrain modeling.</li>
</ul>
<p>Most of these data structures depend on a scale parameter. CGAL provides a method to estimate the average spacing based on a number of neighbors (see <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga8b330397a3fb68176c851fd7d214b513">CGAL::compute_average_spacing()</a>), which usually provides satisfying results in the absence of noise. In the presence of noise, <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga28fe6443638647be0874b283085eb2cd">CGAL::estimate_global_range_scale()</a> provides an estimation of the smallest scale such that the point set has the local dimension of a surface (this method is both robust to noise and outliers, see <a class="el" href="index.html#Classification_sowf_result">Result</a>).</p>
<p>The eigen analysis can be used to estimate normals. Note however that this analysis (based on Principal Component Analysis) might not be robust to a high level of noise. CGAL also provides more robust normal estimation functions (see for example <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga078e25209373cab0e1f3524202489771">CGAL::jet_estimate_normals()</a>).</p>
<p>The following code snippet shows how to instantiate such data structures from an input PLY point set (the <a class="el" href="index.html#Classification_example_general">full example</a> is given at the end of the manual).</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/b9.ply"</span>);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Reading input"</span> &lt;&lt; std::endl;</div><div class="line">  std::vector&lt;Point&gt; pts;</div><div class="line">  <span class="keywordflow">if</span> (!(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(filename, std::back_inserter(pts),</div><div class="line">                              <span class="comment">// the PLY reader expects a binary file by default</span></div><div class="line">                              CGAL::parameters::use_binary_mode(<span class="keyword">false</span>))))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read "</span> &lt;&lt; filename &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">float</span> grid_resolution = 0.34f;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> number_of_neighbors = 6;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Computing useful structures"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  Iso_cuboid_3 bbox = CGAL::bounding_box (pts.begin(), pts.end());</div><div class="line"></div><div class="line">  Planimetric_grid grid (pts, Pmap(), bbox, grid_resolution);</div><div class="line">  Neighborhood neighborhood (pts, Pmap());</div><div class="line">  Local_eigen_analysis eigen</div><div class="line">    = Local_eigen_analysis::create_from_point_set</div><div class="line">    (pts, Pmap(), neighborhood.k_neighbor_query(number_of_neighbors));</div><div class="line"></div></div><!-- fragment --><p> CGAL provides some predefined features:</p>
<ul>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Distance__to__plane.html">Distance_to_plane</a> measures how far away a point is from a locally estimated plane;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Eigenvalue.html">Eigenvalue</a> measures one of the three local eigenvalues;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Elevation.html">Elevation</a> computes the local distance to an estimation of the ground;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Elevation.html">Height_above</a> computes the distance between the local highest point and the point;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Elevation.html">Height_below</a> computes the distance between the point and the local lowest point;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Vertical__dispersion.html">Vertical_dispersion</a> computes how noisy the point set is on a local Z-cylinder;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Elevation.html">Vertical_range</a> computes the distance between the local highest and lowest points;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Verticality.html">Verticality</a> compares the local normal vector to the vertical vector.</li>
</ul>
<p>These features are designed for point sets but can easily be used with surface meshes as well (see <a class="el" href="index.html#Classification_meshes">Mesh Classification</a>). For more details about how these different features can help to identify one label or the other, please refer to their associated reference manual pages.</p>
<p>In addition, if the input data set has additional properties, these can also be used as features. For example, CGAL provides the following features:</p>
<ul>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Color__channel.html">Color_channel</a> uses input color information if available;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Echo__scatter.html">Echo_scatter</a> uses the number of returns (echo) provided by most LIDAR scanners if available;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Simple__feature.html">Simple_feature</a> uses any property map applicable to the input range and whose value type is castable to <code>float</code> (useful if an additional property of the input set should be used as is, for example an <code>intensity</code> measurement).</li>
</ul>
<p>Users commonly want to use all predefined features to get the best result possible. CGAL provides a class <a class="el" href="classCGAL_1_1Classification_1_1Point__set__feature__generator.html">Point_set_feature_generator</a> that performs the following operations:</p>
<ul>
<li>it estimates the smallest relevant scale;</li>
<li>it generates all needed analysis structures and provides access to them;</li>
<li>it generates all possible features (among all the CGAL predefined ones) based on which property maps are available (they use colors if available, etc.).</li>
</ul>
<p>Multiple scales that are sequentially larger can be used to increase the quality of the results <a class="el" href="citelist.html#CITEREF_cgal:hws-fsso3-16">[3]</a>.</p>
<p>Note that using this class in order to generate features is not mandatory, as features and data structures can all be handled by hand. It is mainly provided to make the specific case of point sets simpler to handle. Users can still add their own features within their feature set.</p>
<p>Some data structure instantiated by the generator will be used by feature: for this reason, the generator should be instantiated <em>within the same scope</em> as the feature set and should not be deleted before the feature set.</p>
<p>The following snippet shows how to use the point set feature generator:</p>
<div class="fragment"><div class="line"></div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  std::size_t number_of_scales = 5;</div><div class="line">  Feature_generator generator (pts, pts.point_map(), number_of_scales);</div><div class="line"></div><div class="line">  features.begin_parallel_additions();</div><div class="line">  generator.generate_point_based_features (features);</div><div class="line">  features.end_parallel_additions();</div><div class="line"></div></div><!-- fragment --><p> <a class="anchor" id="fig__Classification_point_set_fig"></a></p><div class="image">
<img src="point_set.png" alt="point_set.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Classification_point_set_fig">Figure 84.2</a> Example of point set classification (left: input, right: output). <em>Ground</em> is grey, <em>roofs</em> are orange, <em>vegetation</em> is green.  </div> <br /> 
<h2><a class="anchor" id="Classification_meshes"></a>
Mesh Classification</h2>
<p>Classification of mesh is performed by considering the face of a mesh as an atomic element that should be assign one label or another. Some structures such as neighborhood or Eigen analysis are significantly different from their equivalent for point sets; other data structures from point sets can be directly used by viewing the mesh as a point set through the use of a property map that associates each face with a representative point.</p>
<p>Hereafter, a <em>mesh</em> refers to a model of <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/classFaceListGraph.html">FaceListGraph</a></code>.</p>
<p>CGAL provides the following structures:</p>
<ul>
<li><a class="el" href="classCGAL_1_1Classification_1_1Face__descriptor__to__center__of__mass__map.html">Face_descriptor_to_center_of_mass_map</a> is a property map that takes the face of a mesh as key type and returns the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__3.html">CGAL::Point_3</a></code> located at the center of mass of the face. It is useful to apply point set structures and features to surface meshes;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Face__descriptor__to__face__descriptor__with__bbox__map.html">Face_descriptor_to_face_descriptor_with_bbox_map</a> is a property map that takes the face of a mesh as key type and returns the same face along with its bounding box as a value type. It is useful to call <code><a class="el" href="group__PkgClassificationMain.html#ga2a4c1b0816b81b628dc9023e104449eb" title="runs the classification algorithm with a global regularization based on a graph cut. ">CGAL::Classification::classify_with_graphcut()</a></code> which requires objects that provide a <code>bbox()</code> method (see <a class="el" href="index.html#Classification_classification_functions">Classification Functions</a>);</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Mesh__neighborhood.html">Mesh_neighborhood</a> provides adapted queries for surface meshes;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Local__eigen__analysis.html">Local_eigen_analysis</a> precomputes covariance matrices on local neighborhoods of triangles and stores the associated eigenvectors and eigenvalues (it is the same object as for point sets called with a different named constructor);</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Planimetric__grid.html">Planimetric_grid</a> is the 2D grid used for digital terrain modeling of point sets, it can be used with meshes through <a class="el" href="classCGAL_1_1Classification_1_1Face__descriptor__to__center__of__mass__map.html">Face_descriptor_to_center_of_mass_map</a>.</li>
</ul>
<p>The point set features can be used for mesh classification as well:</p>
<ul>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Eigenvalue.html">Eigenvalue</a> takes the <a class="el" href="classCGAL_1_1Classification_1_1Local__eigen__analysis.html">Local_eigen_analysis</a> object computed on faces as input;</li>
<li>the other ones are computed by considering the mesh as a point set.</li>
</ul>
<p>Similarly to <a class="el" href="classCGAL_1_1Classification_1_1Point__set__feature__generator.html">Point_set_feature_generator</a>, CGAL provides a class <a class="el" href="classCGAL_1_1Classification_1_1Mesh__feature__generator.html">Mesh_feature_generator</a> that estimates the smallest scale automatically and computes all predefined features on several scales. As for point sets, using this class in order to generate features is not mandatory, as features and data structures can all be handled by hand. It is mainly provided to make the specific case of meshes simpler to handle. Users can still add their own features within their feature set.</p>
<p>The following snippet shows how to use the mesh feature generator:</p>
<div class="fragment"><div class="line"></div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  Face_point_map face_point_map (&amp;mesh); <span class="comment">// Associates each face to its center of mass</span></div><div class="line"></div><div class="line">  std::size_t number_of_scales = 5;</div><div class="line">  Feature_generator generator (mesh, face_point_map, number_of_scales);</div><div class="line"></div><div class="line">  features.begin_parallel_additions();</div><div class="line">  generator.generate_point_based_features (features); <span class="comment">// Features that consider the mesh as a point set</span></div><div class="line">  generator.generate_face_based_features (features);  <span class="comment">// Features computed directly on mesh faces</span></div><div class="line">  features.end_parallel_additions();</div><div class="line"></div></div><!-- fragment --><p> The <a class="el" href="index.html#Classification_example_mesh">full example</a> is given at the end of the manual.</p>
<p><a class="anchor" id="fig__Classification_mesh_fig"></a></p><div class="image">
<img src="mesh.png" alt="mesh.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Classification_mesh_fig">Figure 84.3</a> Example of mesh classification (left: input, right: output). <em>Ground</em> is grey, <em>roofs</em> are orange, <em>vegetation</em> is green.  </div> <br /> 
<h2><a class="anchor" id="Classification_clusters"></a>
Cluster Classification</h2>
<p>Classifying clusters of items instead of raw sets of items can have several advantages:</p>
<ul>
<li>if the data set is very large, using clusters can drastically decrease the complexity and thus the need for computation time and memory;</li>
<li>clusters are more complex objects than raw items (isolated points or triangles of a mesh) and thus provide additional information (size of cluster, spatial consistency, etc.);</li>
<li>by construction, the output classification is less noisy (if all points of a facade are in the same cluster, then they are guaranteed to all be classified in the same label).</li>
</ul>
<p>For example, when dealing with urban scenes that typically contain large planar sections, it may be more efficient to first detect planes (with <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Region__growing.html">CGAL::Shape_detection::Region_growing</a></code> or <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Efficient__RANSAC.html">CGAL::Shape_detection::Efficient_RANSAC</a></code> for example) and then to classify each subset of points belonging to a specific plane as clusters.</p>
<p>CGAL provides some tools to classify clusters:</p>
<ul>
<li>the class <code><a class="el" href="classCGAL_1_1Classification_1_1Cluster.html" title="Class that represent a cluster of items to be classified as a single atomic object. ">CGAL::Classification::Cluster</a></code> can be used to represent a cluster of items (points, for example);</li>
<li>the function <code><a class="el" href="group__PkgClassificationCluster.html#ga6c0c1a27071cf5ebfac967d6847cbbf9" title="Given a set of cluster indices, segments the input range into Cluster objects. ">CGAL::Classification::create_clusters_from_indices()</a></code> takes indices over items as input (for example, shape indices taken from shape detection) and generates one cluster per index.</li>
</ul>
<p>The following snippet shows how to create classification clusters from a shape detection algorithm (<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Region__growing.html">Region Growing</a>):</p>
<div class="fragment"><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Detecting planes and creating clusters"</span> &lt;&lt; std::endl;</div><div class="line">  t.start();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> search_sphere_radius  = 1.0;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> max_distance_to_plane = 1.0;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> max_accepted_angle    = 25.0;</div><div class="line">  <span class="keyword">const</span> std::size_t min_region_size  = 10;</div><div class="line"></div><div class="line">  Neighbor_query neighbor_query (</div><div class="line">    pts, CGAL::parameters::sphere_radius(search_sphere_radius)</div><div class="line">                          .point_map(pts.point_map()));</div><div class="line">  Region_type region_type(</div><div class="line">    pts, CGAL::parameters::maximum_distance(max_distance_to_plane)</div><div class="line">                          .maximum_angle(max_accepted_angle)</div><div class="line">                          .minimum_region_size(min_region_size)</div><div class="line">                          .point_map(pts.point_map())</div><div class="line">                          .normal_map(pts.normal_map()));</div><div class="line">  Region_growing region_growing (</div><div class="line">    pts, neighbor_query, region_type);</div><div class="line"></div><div class="line">  std::vector&lt;Cluster&gt; clusters;</div><div class="line">  region_growing.detect</div><div class="line">    (boost::make_function_output_iterator</div><div class="line">     ([&amp;](<span class="keyword">const</span> std::vector&lt;std::size_t&gt;&amp; region) -&gt; <span class="keywordtype">void</span> {</div><div class="line"></div><div class="line">        <span class="comment">// Create a new cluster.</span></div><div class="line">        Classification::Cluster&lt;Point_set, Pmap&gt; cluster (pts, pts.point_map());</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> std::size_t idx : region)</div><div class="line">          cluster.insert(idx);</div><div class="line">        clusters.push_back(cluster);</div><div class="line">      }));</div><div class="line"></div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; clusters.size() &lt;&lt; <span class="stringliteral">" clusters created in "</span></div><div class="line">            &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div><div class="line"></div></div><!-- fragment --><p> The class <a class="el" href="classCGAL_1_1Classification_1_1Local__eigen__analysis.html">Local_eigen_analysis</a> can also take point clusters as input:</p>
<div class="fragment"><div class="line"></div><div class="line">  Local_eigen_analysis eigen = Local_eigen_analysis::create_from_point_clusters (clusters);</div><div class="line"></div></div><!-- fragment --><p> As clusters are based on simple items, users can compute cluster features based on statistics over the itemwise features:</p>
<ul>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Cluster__mean__of__feature.html">Cluster_mean_of_feature</a> computes, for a cluster, the mean value of an itemwise feature over the inliers of this cluster;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Cluster__variance__of__feature.html">Cluster_variance_of_feature</a> computes, for a cluster, the variance of an itemwise feature over the inliers of this cluster.</li>
</ul>
<p>Some additional features are provided specifically for clusters:</p>
<ul>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Cluster__size.html">Cluster_size</a> uses the number of items in a cluster;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Cluster__vertical__extent.html">Cluster_vertical_extent</a> computes the length of the smallest interval on the <code>Z</code> axis that contains all the items of a cluster;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Eigenvalue.html">Eigenvalue</a>, similarly to point sets and meshes, can use the <a class="el" href="classCGAL_1_1Classification_1_1Local__eigen__analysis.html">Local_eigen_analysis</a> object computed on clusters.</li>
</ul>
<p>The following snippet shows, from a pointwise feature set, how to generate the statistical features from a pointwise feature set (along with these latest cluster features):</p>
<div class="fragment"><div class="line"></div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  <span class="comment">// First, compute means of features.</span></div><div class="line">  features.begin_parallel_additions();</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; pointwise_features.size(); ++ i)</div><div class="line">    features.add&lt;Feature::Cluster_mean_of_feature&gt; (clusters, pointwise_features[i]);</div><div class="line">  features.end_parallel_additions();</div><div class="line"></div><div class="line">  <span class="comment">// Then, compute variances of features (and remaining cluster features).</span></div><div class="line">  features.begin_parallel_additions();</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; pointwise_features.size(); ++ i)</div><div class="line">    features.add&lt;Feature::Cluster_variance_of_feature&gt; (clusters,</div><div class="line">                                                        pointwise_features[i], <span class="comment">// i^th feature</span></div><div class="line">                                                        features[i]);          <span class="comment">// mean of i^th feature</span></div><div class="line"></div><div class="line">  features.add&lt;Feature::Cluster_size&gt; (clusters);</div><div class="line">  features.add&lt;Feature::Cluster_vertical_extent&gt; (clusters);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; 3; ++ i)</div><div class="line">    features.add&lt;Feature::Eigenvalue&gt; (clusters, eigen, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(i));</div><div class="line"></div><div class="line">  features.end_parallel_additions();</div><div class="line"></div></div><!-- fragment --><p> The <a class="el" href="index.html#Classification_example_cluster">full example</a> is given at the end of the manual.</p>
<p><a class="anchor" id="fig__Classification_cluster_fig"></a></p><div class="image">
<img src="clusters.png" alt="clusters.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Classification_cluster_fig">Figure 84.4</a> Example of cluster classification mesh (left: input, middle: clusters computed from region growing, right: output). <em>Ground</em> is grey, <em>roofs</em> are orange, <em>vegetation</em> is green, points not assigned to a cluster are <em>black</em>.  </div> <br /> 
<h1><a class="anchor" id="Classification_classifiers"></a>
Classifiers</h1>
<p>Classification relies on a classifier: this classifier is an object that, from the set of values taken by the features at an input item, computes the probability that an input item belongs to one label or another. A model of the concept <code><a class="el" href="classCGAL_1_1Classification_1_1Classifier.html" title="Concept describing a classifier used by classification functions (see CGAL::Classification::classify(...">CGAL::Classification::Classifier</a></code> must take the index of an input item and store the probability associated to each label in a vector. If a classifier returns the value 1 for a pair of label and input item, it means that this item belongs to this label with certainty; values close to 0 mean that this item is not likely to belong to this label.</p>
<p>CGAL provides three models for this concept, <a class="el" href="classCGAL_1_1Classification_1_1ETHZ_1_1Random__forest__classifier.html">ETHZ::Random_forest_classifier</a>, <a class="el" href="classCGAL_1_1Classification_1_1OpenCV_1_1Random__forest__classifier.html">OpenCV::Random_forest_classifier</a>, and <a class="el" href="classCGAL_1_1Classification_1_1Sum__of__weighted__features__classifier.html">Sum_of_weighted_features_classifier</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Currently, <a class="el" href="classCGAL_1_1Classification_1_1ETHZ_1_1Random__forest__classifier.html">ETHZ::Random_forest_classifier</a> is the best classifier available in CGAL and we strongly advise users to use it.</dd></dl>
<p>To perform classification based on four classifiers, please refer to <a class="el" href="index.html#Classification_classification_functions">Classification Functions</a>.</p>
<h2><a class="anchor" id="Classification_ETHZ_random_forest"></a>
ETHZ Random Forest</h2>
<p>CGAL provides <a class="el" href="classCGAL_1_1Classification_1_1ETHZ_1_1Random__forest__classifier.html">ETHZ::Random_forest_classifier</a>, a classifier based on the Random Forest Template Library developed by Stefan Walk at ETH Zurich <a class="el" href="citelist.html#CITEREF_cgal:w-erftl-14">[2]</a> (the library is distributed under the MIT license and is included with the CGAL release, the user does not have to install anything more). This classifier uses a ground truth training set to construct several decision trees that are then used to assign a label to each input item.</p>
<p>This classifier cannot be set up by hand and requires a ground truth training set. The training algorithm is fast but usually requires a high number of inliers. The training algorithm uses more memory at runtime and the configuration files are larger than those produced by <a class="el" href="classCGAL_1_1Classification_1_1Sum__of__weighted__features__classifier.html">Sum_of_weighted_features_classifier</a>, but the output quality is usually significantly better, especially in the cases where many labels are used (more than five).</p>
<p>An <a class="el" href="index.html#Classification_example_ethz_random_forest">example</a> shows how to use this classifier. For more details about the algorithm, please refer to README provided in the <a href="https://ethz.ch/content/dam/ethz/special-interest/baug/igp/photogrammetry-remote-sensing-dam/documents/sourcecode-and-datasets/Random%20Forest/rforest.zip">ETH Zurich's code archive</a>.</p>
<h3><a class="anchor" id="Classification_ETHZ_random_forest_deprecated"></a>
Deprecated IO</h3>
<p>The <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/namespaceCGAL_1_1IO.html">IO</a> functions of this classifier were changed in CGAL 5.2. Configurations generated from previous versions are not valid anymore and should be converted first as shown in the following example:</p>
<p><br />
<b>File</b> <a class="el" href="Classification_2example_deprecated_conversion_8cpp-example.html">Classification/example_deprecated_conversion.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Classification/ETHZ/Random_forest_classifier.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (argc != 3)</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Usage: "</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">" input.gz output.bin"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">  {</div><div class="line">    std::ifstream ifile (argv[1], std::ios_base::binary);</div><div class="line">    std::ofstream ofile (argv[2], std::ios_base::binary);</div><div class="line"></div><div class="line">    <a class="code" href="classCGAL_1_1Classification_1_1ETHZ_1_1Random__forest__classifier.html#a99154673a7b517e7d141e6d3678a65c8">CGAL::Classification::ETHZ::Random_forest_classifier::</a></div><div class="line"><a class="code" href="classCGAL_1_1Classification_1_1ETHZ_1_1Random__forest__classifier.html#a99154673a7b517e7d141e6d3678a65c8">      convert_deprecated_configuration_to_new_format</a>(ifile, ofile);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Classification_OpenCV_random_forest"></a>
OpenCV Random Forest</h2>
<p>The second classifier is <a class="el" href="classCGAL_1_1Classification_1_1OpenCV_1_1Random__forest__classifier.html">OpenCV::Random_forest_classifier</a>. It uses the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartyOpenCV">OpenCV</a> library, more specifically the <a href="https://docs.opencv.org/2.4/modules/ml/doc/random_trees.html">Random Trees</a> package.</p>
<p>Note that this classifier usually produces results with a lower quality than <a class="el" href="classCGAL_1_1Classification_1_1ETHZ_1_1Random__forest__classifier.html">ETHZ::Random_forest_classifier</a>. It is provided for the sake of completeness and for testing purposes, but if you are not sure what to use, we advise using the ETHZ Random Forest instead.</p>
<p>An <a class="el" href="index.html#Classification_example_opencv_random_forest">example</a> shows how to use this classifier. For more details about the algorithm, please refer to <a href="https://docs.opencv.org/2.4/modules/ml/doc/random_trees.html">the official documentation</a> of OpenCV.</p>
<h2><a class="anchor" id="Classification_sowf"></a>
Sum of Weighted Features</h2>
<p>This latest classifier defines the following attributes:</p>
<ul>
<li>a weight applied to each feature;</li>
<li>an effect applied to each pair of feature and label.</li>
</ul>
<p>For each label, the classifier computes an energy as a sum of features normalized with both their weight and the effect they have on this specific label.</p>
<p>The main advantage of this classifier is that it can be set up by hand. Nevertheless, it also embeds a training algorithm.</p>
<h3><a class="anchor" id="Classification_sowf_weights_effects"></a>
Weights and Effects</h3>
<p>Each feature is assigned a weight that measures its strength with respect to the other features.</p>
<p>Each pair of feature and label is assigned an effect that can either be:</p>
<ul>
<li><a class="el" href="classCGAL_1_1Classification_1_1Sum__of__weighted__features__classifier.html#a6aab054f8adf32f1e05b693f5caf9512a9f79d37660f7ace2f1c3a790edb4171a">FAVORING</a>: the label is favored by high values of the feature;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Sum__of__weighted__features__classifier.html#a6aab054f8adf32f1e05b693f5caf9512aafe5766bc7d9202e9e856491e311d954">NEUTRAL</a>: the label is not affected by the feature;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Sum__of__weighted__features__classifier.html#a6aab054f8adf32f1e05b693f5caf9512a2dd2e92685af72202d0875fb898f391e">PENALIZING</a>: the label is favored by low values of the feature.</li>
</ul>
<p>For example, <em>vegetation</em> is expected to have a high distance to plane and have a color close to green (if colors are available); <em>facades</em> have a low distance to plane and a low verticality; etc.</p>
<p>Let \(x=(x_i)_{i=1..N}\) be a potential classification result with \(N\) the number of input items and \(x_i\) the class of the \(i^{th}\) item (for example: <em>vegetation</em>, <em>ground</em>, etc.). Let \(f_j(i)\) be the raw value of the \(j^{th}\) feature at the \(i^{th}\) item and \(w_j\) be the weight of this feature. We define the normalized value \(F_j(x_i) \in [0:1]\) of the \(j^{th}\) feature at the \(i^{th}\) item as follows:</p>
<p class="formulaDsp">
\begin{eqnarray*} F_j(x_i) = &amp; (1 - \min(\max(0,\frac{f_j(i)}{w_j}), 1)) &amp; \mbox{if } f_j \mbox{ favors } x_i \\ &amp; 0.5 &amp; \mbox{if } f_j \mbox{ is neutral for } x_i \\ &amp; \min(\max(0,\frac{f_j(i)}{w_j}), 1) &amp; \mbox{if } f_j \mbox{ penalizes } x_i \end{eqnarray*}
</p>
<p>The itemwise energy measures the coherence of the label \(x_i\) at the \(i^{th}\) item and is defined as:</p>
<p class="formulaDsp">
\[ E_{di}(x_i) = \sum_{j = 1..N_f} F_j(x_i) \]
</p>
<p>The following code snippet shows how to define the weights and effects of features and labels:</p>
<div class="fragment"><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Setting weights"</span> &lt;&lt; std::endl;</div><div class="line">  Classifier classifier (labels, features);</div><div class="line">  classifier.set_weight (distance_to_plane, 6.75e-2f);</div><div class="line">  classifier.set_weight (dispersion, 5.45e-1f);</div><div class="line">  classifier.set_weight (elevation, 1.47e1f);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Setting effects"</span> &lt;&lt; std::endl;</div><div class="line">  classifier.set_effect (ground, distance_to_plane, Classifier::NEUTRAL);</div><div class="line">  classifier.set_effect (ground, dispersion, Classifier::NEUTRAL);</div><div class="line">  classifier.set_effect (ground, elevation, Classifier::PENALIZING);</div><div class="line"></div><div class="line">  classifier.set_effect (vegetation, distance_to_plane,  Classifier::FAVORING);</div><div class="line">  classifier.set_effect (vegetation, dispersion, Classifier::FAVORING);</div><div class="line">  classifier.set_effect (vegetation, elevation, Classifier::NEUTRAL);</div><div class="line"></div><div class="line">  classifier.set_effect (roof, distance_to_plane,  Classifier::NEUTRAL);</div><div class="line">  classifier.set_effect (roof, dispersion, Classifier::NEUTRAL);</div><div class="line">  classifier.set_effect (roof, elevation, Classifier::FAVORING);</div><div class="line"></div></div><!-- fragment --> <h3><a class="anchor" id="Classification_sowf_training"></a>
Training</h3>
<p>Each feature has a specific weight and each pair of feature-label has a specific effect. This means that the number of parameters to set up can quickly explode: if 6 features are used to classify between 4 labels, 30 parameters have to be set up (6 weights + 6x4 feature-label relationships).</p>
<p>Though it is possible to set them up one by one, CGAL also provides a method <a class="el" href="classCGAL_1_1Classification_1_1Sum__of__weighted__features__classifier.html#a11bcf5a1416f0fd2c4855af9c73797cc">train()</a> that requires a small set of ground truth items provided by users. More specifically, users must provide, for each label they want to classify, a set of known inliers among the input data set (for example, selecting one roof, one tree and one section of the ground). The training algorithm works as follows:</p>
<ul>
<li>for each feature, a range of weights is tested: the effect each feature has on each label is estimated. For a given weight, if a feature has the same effect on each label, it is non-relevant for classification. The range of weights such that the feature is relevant is estimated;</li>
<li>for each feature, uniformly picked weight values are tested and their effects are estimated;</li>
<li>each inlier provided by the user is classified using this set of weights and effects;</li>
<li>the mean intersection-over-union (see <a class="el" href="index.html#Classification_evaluation">Evaluation</a>) is used to evaluate the quality of this set of weights and effects;</li>
<li>the same mechanism is repeated until all features' ranges have been tested. Weights are only changed one by one, the other ones are kept to the values that gave the latest best score.</li>
</ul>
<p>This usually converges to a satisfying solution (see Figure <a class="el" href="index.html#fig__Classification_trainer_fig">Figure 84.5</a>). The number of trials is user defined, set to 300 by default. Using at least 10 times the number of features is advised (for example, at least 300 iterations if 30 features are used). If the solution is not satisfying, more inliers can be selected, for example, in a region that the user identifies as misclassified with the current configuration. The training algorithm keeps, as initialization, the best weights found at the previous round and carries on trying new weights by taking new inliers into account.</p>
<p><a class="anchor" id="fig__Classification_trainer_fig"></a></p><div class="image">
<img src="classif_training.png" alt="classif_training.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Classification_trainer_fig">Figure 84.5</a> Example of evolution of the mean intersection-over-union. The purple curve is the score computed at the current iteration, green curve is the best score found so far.  </div> <br /> 
<h3><a class="anchor" id="Classification_sowf_result"></a>
Result</h3>
<p>Figure <a class="el" href="index.html#fig__Classification_sowf_result_fig">Figure 84.6</a> shows an example of output on a defect-laden point set. The accuracy on this example is 0.97 with a mean intersection-over-union of 0.85 (see section <a class="el" href="index.html#Classification_evaluation">Evaluation</a>).</p>
<p><a class="anchor" id="fig__Classification_sowf_result_fig"></a></p><div class="image">
<img src="noise_outliers.png" alt="noise_outliers.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Classification_sowf_result_fig">Figure 84.6</a> Example of classification on a point set with medium noise and outliers (left: input, right: output). <em>Ground</em> is orange, <em>roofs</em> are pink, <em>vegetation</em> is green. Outliers are classified with an additional label <em>outlier</em> in black.  </div> <br /> 
<h1><a class="anchor" id="Classification_classification_functions"></a>
Classification Functions</h1>
<p>Classification is performed by minimizing an energy over the input data set that may include regularization. CGAL provides three different methods for classification, ranging from high speed / low quality to low speed / high quality:</p>
<ul>
<li><code><a class="el" href="group__PkgClassificationMain.html#gaea3ed82bf801bc9fbd00b63da48df73e" title="runs the classification algorithm without any regularization. ">CGAL::Classification::classify()</a></code></li>
<li><code><a class="el" href="group__PkgClassificationMain.html#ga266e487bd1ab9dd4036e3fbd2ec4e8a0" title="runs the classification algorithm with a local smoothing. ">CGAL::Classification::classify_with_local_smoothing()</a></code></li>
<li><code><a class="el" href="group__PkgClassificationMain.html#ga2a4c1b0816b81b628dc9023e104449eb" title="runs the classification algorithm with a global regularization based on a graph cut. ">CGAL::Classification::classify_with_graphcut()</a></code></li>
</ul>
<p>On a point set of 3 millions of points, the first method takes about 4 seconds, the second about 40 seconds and the third about 2 minutes.</p>
<p><a class="anchor" id="fig__Classification_image"></a></p><div class="image">
<img src="classif.png" alt="classif.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Classification_image">Figure 84.7</a> Top-Left: input point set. Top-Right: raw output classification represented by a set of colors (<em>ground</em> is orange, <em>facades</em> are blue, <em>roofs</em> are pink and <em>vegetation</em> is green). Bottom-Left: output classification using local smoothing. Bottom-Right: output classification using graphcut.  </div> <br /> 
<p>Mathematical details are provided hereafter.</p>
<h2><a class="anchor" id="Classification_classify"></a>
Raw Classification</h2>
<ul>
<li><code><a class="el" href="group__PkgClassificationMain.html#gaea3ed82bf801bc9fbd00b63da48df73e" title="runs the classification algorithm without any regularization. ">CGAL::Classification::classify()</a></code>: this is the fastest method that provides acceptable but usually noisy results (see Figure <a class="el" href="index.html#fig__Classification_image">Figure 84.7</a>, top-right).</li>
</ul>
<p>Let \(x=(x_i)_{i=1..N}\) be a potential classification result with \(N\) the number of input items and \(x_i\) the label of the \(i^{th}\) item (for example: <em>vegetation</em>, <em>ground</em>, etc.). The classification is performed by minimizing the following energy:</p>
<p class="formulaDsp">
\[ E(x) = \sum_{i = 1..N} E_{di}(x_i) \]
</p>
<p>This energy is a sum of itemwise energies provided by the classifier and involves no regularization.</p>
<p>The following snippet shows how to classify points based on a label set and a classifier. The result is stored in <code>label_indices</code>, following the same order as the input set and providing for each point the index (in the label set) of its assigned label.</p>
<div class="fragment"><div class="line">  std::vector&lt;int&gt; label_indices (pts.size(), -1);</div><div class="line"></div><div class="line">  CGAL::Real_timer t;</div><div class="line">  t.start();</div><div class="line">  Classification::classify&lt;CGAL::Parallel_if_available_tag&gt; (pts, labels, classifier, label_indices);</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Raw classification performed in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div></div><!-- fragment --> <h2><a class="anchor" id="Classification_smoothing"></a>
Local Regularization</h2>
<ul>
<li><p class="startli"><code><a class="el" href="group__PkgClassificationMain.html#ga266e487bd1ab9dd4036e3fbd2ec4e8a0" title="runs the classification algorithm with a local smoothing. ">CGAL::Classification::classify_with_local_smoothing()</a></code>: this method is a tradeoff between quality and efficiency (see Figure <a class="el" href="index.html#fig__Classification_image">Figure 84.7</a>, bottom-left). The minimized energy is defined as follows:</p>
<p class="formulaDsp">
\[ E(x) = \sum_{i = 1..N} E_{si}(x_i) \]
</p>
</li>
</ul>
<p>The energy \(E_{si}(x_i)\) is defined on a small local neighborhood \(Nb(i)\) of the \(i^{th}\) item (including itself):</p>
<p class="formulaDsp">
\[ E_{si}(x_i) = \frac{\sum_{k \in Nb(i)} E_{di}(x_k)}{\left| Nb(i) \right|} \]
</p>
<p>This allows to eliminate local noisy variations of assigned labels. Increasing the size of the neighborhood increases the noise reduction at the cost of higher computation times.</p>
<p>The following snippet shows how to classify points using local smoothing by providing a model of <code><a class="el" href="classCGAL_1_1Classification_1_1NeighborQuery.html" title="Concept describing a neighbor query used for classification. ">CGAL::Classification::NeighborQuery</a></code>.</p>
<div class="fragment"><div class="line">  t.start();</div><div class="line">  Classification::classify_with_local_smoothing&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (pts, Pmap(), labels, classifier,</div><div class="line">     neighborhood.sphere_neighbor_query(radius_neighbors),</div><div class="line">     label_indices);</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classification with local smoothing performed in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div></div><!-- fragment --> <h2><a class="anchor" id="Classification_graphcut"></a>
Global Regularization (Graph Cut)</h2>
<ul>
<li><p class="startli"><code><a class="el" href="group__PkgClassificationMain.html#ga2a4c1b0816b81b628dc9023e104449eb" title="runs the classification algorithm with a global regularization based on a graph cut. ">CGAL::Classification::classify_with_graphcut()</a></code>: this method offers the best quality but requires longer computation time (see Figure <a class="el" href="index.html#fig__Classification_image">Figure 84.7</a>, bottom-right). The total energy that is minimized is the sum of the partial data term \(E_{di}(x_i)\) and of a pairwise interaction energy defined by the standard Potts model <a class="el" href="citelist.html#CITEREF_cgal:l-mrfmi-09">[5]</a> :</p>
<p class="formulaDsp">
\[ E(x) = \sum_{i = 1..N} E_{di}(x_i) + \gamma \sum_{i \sim j} \mathbf{1}_{x_i \neq x_j} \]
</p>
</li>
</ul>
<p>where \(\gamma&gt;0\) is the parameter of the Potts model that quantifies the strengh of the regularization, \(i \sim j\) represents the pairs of neighboring items and \(\mathbf{1}_{\{.\}}\) the characteristic function.</p>
<p>A <em>graph cut</em> based algorithm (alpha expansion) is used to quickly reach an approximate solution close to the global optimum of this energy.</p>
<p>This method allows to consistently segment the input data set in piecewise constant parts and to correct large wrongly classified clusters. Increasing \(\gamma\) produces more regular result with a constant computation time.</p>
<p>To speed up computations, the input domain can be subdivided into smaller subsets such that several smaller graph cuts are applied instead of a big one. The computation of these smaller graph cuts can be done in parallel. Increasing the number of subsets allows for faster computation times but can also reduce the quality of the results.</p>
<p>The following snippet shows how to classify points using a graph cut regularization providing a model of <code><a class="el" href="classCGAL_1_1Classification_1_1NeighborQuery.html" title="Concept describing a neighbor query used for classification. ">CGAL::Classification::NeighborQuery</a></code>, a strengh parameter \(\gamma\) and a number of subdivisions.</p>
<div class="fragment"><div class="line">  t.start();</div><div class="line">  Classification::classify_with_graphcut&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (pts, Pmap(), labels, classifier,</div><div class="line">     neighborhood.k_neighbor_query(12),</div><div class="line">     0.2f, 4, label_indices);</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classification with graphcut performed in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div></div><!-- fragment --> <h1><a class="anchor" id="Classification_evaluation"></a>
Evaluation</h1>
<p>The class <a class="el" href="classCGAL_1_1Classification_1_1Evaluation.html">Evaluation</a> allows users to evaluate the reliability of the classification with respect to a provided ground truth. The following measurements are available:</p>
<ul>
<li><a class="el" href="classCGAL_1_1Classification_1_1Evaluation.html#a040d137ec34590b2e2364d42264a901e">precision()</a> computes, for one label, the ratio of true positives over the total number of detected positives;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Evaluation.html#a40cd95adcd26d7b16cd6daaf56dfba27">recall()</a> computes, for one label, the ratio of true positives over the total number of provided inliers of this label;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Evaluation.html#a8de98452ad8bafc018b18d75e1e55a47">f1_score()</a> is the harmonic mean of precision and recall;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Evaluation.html#a2d4513d5a5256fda156d5b4fd1ddfbe7">intersection_over_union()</a> computes the ratio of true positives over the union of the detected positives and of the provided inliers;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Evaluation.html#ac2c9a217607e34f38541d10adc77b336">accuracy()</a> computes the ratio of all true positives over the total number of provided inliers;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Evaluation.html#aca8eaa6bf226fc44a3740b376acce804">mean_f1_score()</a>;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Evaluation.html#aae3761d28e2b0585c8715edbff790c14">mean_intersection_over_union()</a>.</li>
</ul>
<p>All these values range from 0 (poor quality) to 1 (perfect quality).</p>
<h1><a class="anchor" id="Classification_examples"></a>
Full Examples</h1>
<h2><a class="anchor" id="Classification_example_general"></a>
Simple Point Set Classification</h2>
<p>The following example:</p>
<ul>
<li>reads an input file (LIDAR point set in PLY format);</li>
<li>computes useful structures from this input;</li>
<li>computes features from the input and the precomputed structures;</li>
<li>defines 3 labels (<em>vegetation</em>, <em>ground</em> and <em>roof</em>);</li>
<li>sets up the classification classifier <a class="el" href="classCGAL_1_1Classification_1_1Sum__of__weighted__features__classifier.html">Sum_of_weighted_features_classifier</a>;</li>
<li>classifies the point set with the 3 different methods (this is for the sake of the example: each method overwrites the previous result, users should only call one of the methods);</li>
<li>saves the result in a colored PLY format.</li>
</ul>
<p><br />
<b>File</b> <a class="el" href="Classification_2example_classification_8cpp-example.html">Classification/example_classification.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#if defined (_MSC_VER) &amp;&amp; !defined (_WIN64)</span></div><div class="line"><span class="preprocessor">#pragma warning(disable:4244) // boost::number_distance::distance()</span></div><div class="line">                              <span class="comment">// converts 64 to 32 bits integers</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Classification.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/bounding_box.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/tags.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_ply_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a> Concurrency_tag;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::Iso_cuboid_3</a> Iso_cuboid_3;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> CGAL::Identity_property_map&lt;Point&gt; Pmap;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Classification = <a class="code" href="namespaceCGAL_1_1Classification.html">CGAL::Classification</a>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Sum_of_weighted_features_classifier Classifier;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Planimetric_grid&lt;Kernel, Point_range, Pmap&gt;             Planimetric_grid;</div><div class="line"><span class="keyword">typedef</span> Classification::Point_set_neighborhood&lt;Kernel, Point_range, Pmap&gt;       Neighborhood;</div><div class="line"><span class="keyword">typedef</span> Classification::Local_eigen_analysis                                    Local_eigen_analysis;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Label_handle                                            Label_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_handle                                          Feature_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Label_set                                               Label_set;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_set                                             Feature_set;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Feature::Distance_to_plane&lt;Point_range, Pmap&gt;           Distance_to_plane;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature::Elevation&lt;Kernel, Point_range, Pmap&gt;           Elevation;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature::Vertical_dispersion&lt;Kernel, Point_range, Pmap&gt; Dispersion;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/b9.ply"</span>);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Reading input"</span> &lt;&lt; std::endl;</div><div class="line">  std::vector&lt;Point&gt; pts;</div><div class="line">  <span class="keywordflow">if</span> (!(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(filename, std::back_inserter(pts),</div><div class="line">                              <span class="comment">// the PLY reader expects a binary file by default</span></div><div class="line">                              CGAL::parameters::use_binary_mode(<span class="keyword">false</span>))))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read "</span> &lt;&lt; filename &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">float</span> grid_resolution = 0.34f;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> number_of_neighbors = 6;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Computing useful structures"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  Iso_cuboid_3 bbox = CGAL::bounding_box (pts.begin(), pts.end());</div><div class="line"></div><div class="line">  Planimetric_grid grid (pts, Pmap(), bbox, grid_resolution);</div><div class="line">  Neighborhood neighborhood (pts, Pmap());</div><div class="line">  Local_eigen_analysis eigen</div><div class="line">    = Local_eigen_analysis::create_from_point_set</div><div class="line">    (pts, Pmap(), neighborhood.k_neighbor_query(number_of_neighbors));</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">float</span> radius_neighbors = 1.7f;</div><div class="line">  <span class="keywordtype">float</span> radius_dtm = 15.0f;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Computing features"</span> &lt;&lt; std::endl;</div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  features.begin_parallel_additions(); <span class="comment">// No effect in sequential mode</span></div><div class="line"></div><div class="line">  Feature_handle distance_to_plane = features.add&lt;Distance_to_plane&gt; (pts, Pmap(), eigen);</div><div class="line">  Feature_handle dispersion = features.add&lt;Dispersion&gt; (pts, Pmap(), grid,</div><div class="line">                                                        radius_neighbors);</div><div class="line">  Feature_handle elevation = features.add&lt;Elevation&gt; (pts, Pmap(), grid,</div><div class="line">                                                      radius_dtm);</div><div class="line"></div><div class="line">  features.end_parallel_additions(); <span class="comment">// No effect in sequential mode</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  Label_set labels;</div><div class="line"></div><div class="line">  <span class="comment">// Init name only</span></div><div class="line">  Label_handle ground = labels.add (<span class="stringliteral">"ground"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Init name and color</span></div><div class="line">  Label_handle vegetation = labels.add (<span class="stringliteral">"vegetation"</span>, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a>(0,255,0));</div><div class="line"></div><div class="line">  <span class="comment">// Init name, Color and standard index (here, ASPRS building index)</span></div><div class="line">  Label_handle roof = labels.add (<span class="stringliteral">"roof"</span>, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a> (255, 0, 0), 6);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Setting weights"</span> &lt;&lt; std::endl;</div><div class="line">  Classifier classifier (labels, features);</div><div class="line">  classifier.set_weight (distance_to_plane, 6.75e-2f);</div><div class="line">  classifier.set_weight (dispersion, 5.45e-1f);</div><div class="line">  classifier.set_weight (elevation, 1.47e1f);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Setting effects"</span> &lt;&lt; std::endl;</div><div class="line">  classifier.set_effect (ground, distance_to_plane, Classifier::NEUTRAL);</div><div class="line">  classifier.set_effect (ground, dispersion, Classifier::NEUTRAL);</div><div class="line">  classifier.set_effect (ground, elevation, Classifier::PENALIZING);</div><div class="line"></div><div class="line">  classifier.set_effect (vegetation, distance_to_plane,  Classifier::FAVORING);</div><div class="line">  classifier.set_effect (vegetation, dispersion, Classifier::FAVORING);</div><div class="line">  classifier.set_effect (vegetation, elevation, Classifier::NEUTRAL);</div><div class="line"></div><div class="line">  classifier.set_effect (roof, distance_to_plane,  Classifier::NEUTRAL);</div><div class="line">  classifier.set_effect (roof, dispersion, Classifier::NEUTRAL);</div><div class="line">  classifier.set_effect (roof, elevation, Classifier::FAVORING);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Run classification</span></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classifying"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::vector&lt;int&gt; label_indices (pts.size(), -1);</div><div class="line"></div><div class="line">  CGAL::Real_timer t;</div><div class="line">  t.start();</div><div class="line">  Classification::classify&lt;CGAL::Parallel_if_available_tag&gt; (pts, labels, classifier, label_indices);</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Raw classification performed in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div><div class="line"></div><div class="line">  t.start();</div><div class="line">  Classification::classify_with_local_smoothing&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (pts, Pmap(), labels, classifier,</div><div class="line">     neighborhood.sphere_neighbor_query(radius_neighbors),</div><div class="line">     label_indices);</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classification with local smoothing performed in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div><div class="line"></div><div class="line">  t.start();</div><div class="line">  Classification::classify_with_graphcut&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (pts, Pmap(), labels, classifier,</div><div class="line">     neighborhood.k_neighbor_query(12),</div><div class="line">     0.2f, 4, label_indices);</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classification with graphcut performed in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save the output in a colored PLY format</span></div><div class="line"></div><div class="line">  std::vector&lt;unsigned char&gt; red, green, blue;</div><div class="line">  red.reserve(pts.size());</div><div class="line">  green.reserve(pts.size());</div><div class="line">  blue.reserve(pts.size());</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; pts.size(); ++ i)</div><div class="line">  {</div><div class="line">    Label_handle label = labels[std::size_t(label_indices[i])];</div><div class="line">    <span class="keywordtype">unsigned</span> r = 0, g = 0, b = 0;</div><div class="line">    <span class="keywordflow">if</span> (label == ground)</div><div class="line">    {</div><div class="line">      r = 245; g = 180; b = 0;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (label == vegetation)</div><div class="line">    {</div><div class="line">      r = 0; g = 255; b = 27;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (label == roof)</div><div class="line">    {</div><div class="line">      r = 255; g = 0; b = 170;</div><div class="line">    }</div><div class="line">    red.push_back(r);</div><div class="line">    green.push_back(g);</div><div class="line">    blue.push_back(b);</div><div class="line">  }</div><div class="line"></div><div class="line">  std::ofstream f (<span class="stringliteral">"classification.ply"</span>);</div><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3IOPly.html#gac1fd90a9d5266e631c68cb31bfe31516">CGAL::IO::write_PLY_with_properties</a></div><div class="line">    (f, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL.html#a266177f3e138c748f9906f7abb76320b">CGAL::make_range</a> (boost::counting_iterator&lt;std::size_t&gt;(0),</div><div class="line">                          boost::counting_iterator&lt;std::size_t&gt;(pts.size())),</div><div class="line">     <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3IOPly.html#ga241c6df9d93e26ec7254ef6366cb7e5b">CGAL::make_ply_point_writer</a> (CGAL::make_property_map(pts)),</div><div class="line">     std::make_pair(CGAL::make_property_map(red), CGAL::PLY_property&lt;unsigned char&gt;(<span class="stringliteral">"red"</span>)),</div><div class="line">     std::make_pair(CGAL::make_property_map(green), CGAL::PLY_property&lt;unsigned char&gt;(<span class="stringliteral">"green"</span>)),</div><div class="line">     std::make_pair(CGAL::make_property_map(blue), CGAL::PLY_property&lt;unsigned char&gt;(<span class="stringliteral">"blue"</span>)));</div><div class="line"></div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"All done"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Classification_example_feeature"></a>
Defining a Custom Feature</h2>
<p>The following example shows how to define a custom feature and how to integrate it in the CGAL classification framework.</p>
<p><br />
<b>File</b> <a class="el" href="Classification_2example_feature_8cpp-example.html">Classification/example_feature.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#if defined (_MSC_VER) &amp;&amp; !defined (_WIN64)</span></div><div class="line"><span class="preprocessor">#pragma warning(disable:4244) // boost::number_distance::distance()</span></div><div class="line">                              <span class="comment">// converts 64 to 32 bits integers</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Classification.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::Iso_cuboid_3</a> Iso_cuboid_3;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> CGAL::Identity_property_map&lt;Point&gt; Pmap;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Classification = <a class="code" href="namespaceCGAL_1_1Classification.html">CGAL::Classification</a>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Sum_of_weighted_features_classifier                      Classifier;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Point_set_neighborhood&lt;Kernel, Point_range, Pmap&gt;       Neighborhood;</div><div class="line"><span class="keyword">typedef</span> Classification::Local_eigen_analysis                                    Local_eigen_analysis;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Label_handle                                            Label_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_handle                                          Feature_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Label_set                                               Label_set;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_set                                             Feature_set;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Feature::Verticality&lt;Kernel&gt;                            Verticality;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// User-defined feature that identifies a specific area of the 3D</span></div><div class="line"><span class="comment">// space. This feature takes value 1 for points that lie inside the</span></div><div class="line"><span class="comment">// area and 0 for the others.</span></div><div class="line"><span class="keyword">class </span>My_feature : <span class="keyword">public</span> <a class="code" href="classCGAL_1_1Classification_1_1Feature__base.html">CGAL::Classification::Feature_base</a></div><div class="line">{</div><div class="line">  <span class="keyword">const</span> Point_range&amp; range;</div><div class="line">  <span class="keywordtype">double</span> xmin, xmax, ymin, ymax;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  My_feature (<span class="keyword">const</span> Point_range&amp; range,</div><div class="line">              <span class="keywordtype">double</span> xmin, <span class="keywordtype">double</span> xmax, <span class="keywordtype">double</span> ymin, <span class="keywordtype">double</span> ymax)</div><div class="line">    : range (range), xmin(xmin), xmax(xmax), ymin(ymin), ymax(ymax)</div><div class="line">  {</div><div class="line">    this-&gt;set_name (<span class="stringliteral">"my_feature"</span>);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">float</span> value (std::size_t pt_index)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (xmin &lt; range[pt_index].x() &amp;&amp; range[pt_index].x() &lt; xmax &amp;&amp;</div><div class="line">        ymin &lt; range[pt_index].y() &amp;&amp; range[pt_index].y() &lt; ymax)</div><div class="line">      <span class="keywordflow">return</span> 1.f;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <span class="keywordflow">return</span> 0.f;</div><div class="line">  }</div><div class="line"></div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::string filename (argc &gt; 1 ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/b9.ply"</span>));</div><div class="line">  std::vector&lt;Point&gt; pts;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Reading input"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">if</span> (!(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(filename, std::back_inserter(pts),</div><div class="line">                              <span class="comment">// the PLY reader expects a binary file by default</span></div><div class="line">                              CGAL::parameters::use_binary_mode(<span class="keyword">false</span>))))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read "</span> &lt;&lt; filename &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  Neighborhood neighborhood (pts, Pmap());</div><div class="line">  Local_eigen_analysis eigen</div><div class="line">    = Local_eigen_analysis::create_from_point_set (pts, Pmap(), neighborhood.k_neighbor_query(6));</div><div class="line"></div><div class="line">  Label_set labels;</div><div class="line">  Label_handle a = labels.add (<span class="stringliteral">"label_A"</span>);</div><div class="line">  Label_handle b = labels.add (<span class="stringliteral">"label_B"</span>);</div><div class="line"></div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Computing features"</span> &lt;&lt; std::endl;</div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  <span class="comment">// Feature that identifies points whose x coordinate is between -20</span></div><div class="line">  <span class="comment">// and 20 and whose y coordinate is between -15 and 15</span></div><div class="line">  Feature_handle my_feature = features.add&lt;My_feature&gt; (pts, -20., 20., -15., 15.);</div><div class="line"></div><div class="line"></div><div class="line">  Feature_handle verticality = features.add&lt;Verticality&gt; (pts, eigen);</div><div class="line"></div><div class="line">  Classifier classifier (labels, features);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Setting weights"</span> &lt;&lt; std::endl;</div><div class="line">  classifier.set_weight(verticality, 0.5);</div><div class="line">  classifier.set_weight(my_feature, 0.25);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Setting up labels"</span> &lt;&lt; std::endl;</div><div class="line">  classifier.set_effect (a, verticality, Classifier::FAVORING);</div><div class="line">  classifier.set_effect (a, my_feature, Classifier::FAVORING);</div><div class="line">  classifier.set_effect (b, verticality, Classifier::PENALIZING);</div><div class="line">  classifier.set_effect (b, my_feature, Classifier::PENALIZING);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classifying"</span> &lt;&lt; std::endl;</div><div class="line">  std::vector&lt;int&gt; label_indices(pts.size(), -1);</div><div class="line">  Classification::classify_with_graphcut&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (pts, Pmap(), labels, classifier,</div><div class="line">     neighborhood.k_neighbor_query(12),</div><div class="line">     0.5, 1, label_indices);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"All done"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Classification_example_training"></a>
Feature Generation and Training</h2>
<p>The following example:</p>
<ul>
<li>reads a point set with a training set (embedded as a PLY feature <em>label</em>);</li>
<li>automatically generates features on 5 scales;</li>
<li>trains the classifier <a class="el" href="classCGAL_1_1Classification_1_1Sum__of__weighted__features__classifier.html">Sum_of_weighted_features_classifier</a> using 800 trials;</li>
<li>runs the algorithm using the graphcut regularization;</li>
<li>prints some evaluation measurements;</li>
<li>saves the configuration of the classifier for further use.</li>
</ul>
<p><br />
<b>File</b> <a class="el" href="Classification_2example_generation_and_training_8cpp-example.html">Classification/example_generation_and_training.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#if defined (_MSC_VER) &amp;&amp; !defined (_WIN64)</span></div><div class="line"><span class="preprocessor">#pragma warning(disable:4244) // boost::number_distance::distance()</span></div><div class="line">                              <span class="comment">// converts 64 to 32 bits integers</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Classification.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3/IO.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> CGAL::Point_set_3&lt;Point&gt; Point_set;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::Iso_cuboid_3</a> Iso_cuboid_3;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Point_set::Point_map Pmap;</div><div class="line"><span class="keyword">typedef</span> Point_set::Property_map&lt;int&gt; Imap;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Classification = <a class="code" href="namespaceCGAL_1_1Classification.html">CGAL::Classification</a>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Label_handle                                            Label_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_handle                                          Feature_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Label_set                                               Label_set;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_set                                             Feature_set;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Sum_of_weighted_features_classifier                     Classifier;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Point_set_feature_generator&lt;Kernel, Point_set, Pmap&gt;    Feature_generator;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::string filename (argc &gt; 1 ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/b9_training.ply"</span>));</div><div class="line">  std::ifstream in (filename.c_str(), std::ios::binary);</div><div class="line">  Point_set pts;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Reading input"</span> &lt;&lt; std::endl;</div><div class="line">  in &gt;&gt; pts;</div><div class="line"></div><div class="line">  Imap label_map;</div><div class="line">  <span class="keywordtype">bool</span> lm_found = <span class="keyword">false</span>;</div><div class="line">  std::tie (label_map, lm_found) = pts.property_map&lt;<span class="keywordtype">int</span>&gt; (<span class="stringliteral">"label"</span>);</div><div class="line">  <span class="keywordflow">if</span> (!lm_found)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: \"label\" property not found in input file."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Generating features"</span> &lt;&lt; std::endl;</div><div class="line">  CGAL::Real_timer t;</div><div class="line">  t.start();</div><div class="line"></div><div class="line"></div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  std::size_t number_of_scales = 5;</div><div class="line">  Feature_generator generator (pts, pts.point_map(), number_of_scales);</div><div class="line"></div><div class="line">  features.begin_parallel_additions();</div><div class="line">  generator.generate_point_based_features (features);</div><div class="line">  features.end_parallel_additions();</div><div class="line"></div><div class="line"></div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; features.size() &lt;&lt; <span class="stringliteral">" feature(s) generated in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  Label_set labels = { <span class="stringliteral">"ground"</span>, <span class="stringliteral">"vegetation"</span>, <span class="stringliteral">"roof"</span> };</div><div class="line"></div><div class="line">  Classifier classifier (labels, features);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Training"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div><div class="line">  t.start();</div><div class="line">  classifier.train&lt;<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a>&gt; (pts.range(label_map), 800);</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  t.reset();</div><div class="line">  t.start();</div><div class="line">  std::vector&lt;int&gt; label_indices(pts.size(), -1);</div><div class="line">  Classification::classify_with_graphcut&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (pts, pts.point_map(), labels, classifier,</div><div class="line">     generator.neighborhood().k_neighbor_query(12),</div><div class="line">     0.2f, 10, label_indices);</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classification with graphcut done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Precision, recall, F1 scores and IoU:"</span> &lt;&lt; std::endl;</div><div class="line">  Classification::Evaluation evaluation (labels, pts.range(label_map), label_indices);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (Label_handle l : labels)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">" * "</span> &lt;&lt; l-&gt;name() &lt;&lt; <span class="stringliteral">": "</span></div><div class="line">              &lt;&lt; evaluation.precision(l) &lt;&lt; <span class="stringliteral">" ; "</span></div><div class="line">              &lt;&lt; evaluation.recall(l) &lt;&lt; <span class="stringliteral">" ; "</span></div><div class="line">              &lt;&lt; evaluation.f1_score(l) &lt;&lt; <span class="stringliteral">" ; "</span></div><div class="line">              &lt;&lt; evaluation.intersection_over_union(l) &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Accuracy = "</span> &lt;&lt; evaluation.accuracy() &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">"Mean F1 score = "</span> &lt;&lt; evaluation.mean_f1_score() &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">"Mean IoU = "</span> &lt;&lt; evaluation.mean_intersection_over_union() &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">  std::ofstream fconfig (<span class="stringliteral">"config.xml"</span>);</div><div class="line">  classifier.save_configuration (fconfig);</div><div class="line">  fconfig.close();</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"All done"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Classification_example_ethz_random_forest"></a>
ETHZ Random Forest</h2>
<p>The following example shows how to use the classifier <a class="el" href="classCGAL_1_1Classification_1_1ETHZ_1_1Random__forest__classifier.html">ETHZ::Random_forest_classifier</a> using an input training set.</p>
<p><br />
<b>File</b> <a class="el" href="Classification_2example_ethz_random_forest_8cpp-example.html">Classification/example_ethz_random_forest.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#if defined (_MSC_VER) &amp;&amp; !defined (_WIN64)</span></div><div class="line"><span class="preprocessor">#pragma warning(disable:4244) // boost::number_distance::distance()</span></div><div class="line">                              <span class="comment">// converts 64 to 32 bits integers</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Classification.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3/IO.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> CGAL::Point_set_3&lt;Point&gt; Point_set;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::Iso_cuboid_3</a> Iso_cuboid_3;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Point_set::Point_map Pmap;</div><div class="line"><span class="keyword">typedef</span> Point_set::Property_map&lt;int&gt; Imap;</div><div class="line"><span class="keyword">typedef</span> Point_set::Property_map&lt;unsigned char&gt; UCmap;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Classification = <a class="code" href="namespaceCGAL_1_1Classification.html">CGAL::Classification</a>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Label_handle                                            Label_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_handle                                          Feature_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Label_set                                               Label_set;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_set                                             Feature_set;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Point_set_feature_generator&lt;Kernel, Point_set, Pmap&gt;    Feature_generator;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::string filename = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/b9_training.ply"</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1)</div><div class="line">    filename = argv[1];</div><div class="line"></div><div class="line">  std::ifstream in (filename.c_str(), std::ios::binary);</div><div class="line">  Point_set pts;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Reading input"</span> &lt;&lt; std::endl;</div><div class="line">  in &gt;&gt; pts;</div><div class="line"></div><div class="line">  Imap label_map;</div><div class="line">  <span class="keywordtype">bool</span> lm_found = <span class="keyword">false</span>;</div><div class="line">  std::tie (label_map, lm_found) = pts.property_map&lt;<span class="keywordtype">int</span>&gt; (<span class="stringliteral">"label"</span>);</div><div class="line">  <span class="keywordflow">if</span> (!lm_found)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: \"label\" property not found in input file."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Generating features"</span> &lt;&lt; std::endl;</div><div class="line">  CGAL::Real_timer t;</div><div class="line">  t.start();</div><div class="line">  Feature_generator generator (pts, pts.point_map(),</div><div class="line">                               5);  <span class="comment">// using 5 scales</span></div><div class="line"></div><div class="line">  features.begin_parallel_additions();</div><div class="line">  generator.generate_point_based_features (features);</div><div class="line">  features.end_parallel_additions();</div><div class="line"></div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Add labels</span></div><div class="line">  Label_set labels;</div><div class="line">  Label_handle ground = labels.add (<span class="stringliteral">"ground"</span>);</div><div class="line">  Label_handle vegetation = labels.add (<span class="stringliteral">"vegetation"</span>);</div><div class="line">  Label_handle roof = labels.add (<span class="stringliteral">"roof"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Check if ground truth is valid for this label set</span></div><div class="line">  <span class="keywordflow">if</span> (!labels.is_valid_ground_truth (pts.range(label_map), <span class="keyword">true</span>))</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line"></div><div class="line">  std::vector&lt;int&gt; label_indices(pts.size(), -1);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Using ETHZ Random Forest Classifier"</span> &lt;&lt; std::endl;</div><div class="line">  Classification::ETHZ::Random_forest_classifier classifier (labels, features);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Training"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div><div class="line">  t.start();</div><div class="line">  classifier.train (pts.range(label_map));</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  t.reset();</div><div class="line">  t.start();</div><div class="line">  Classification::classify_with_graphcut&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (pts, pts.point_map(), labels, classifier,</div><div class="line">     generator.neighborhood().k_neighbor_query(12),</div><div class="line">     0.2f, 1, label_indices);</div><div class="line">  t.stop();</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classification with graphcut done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Precision, recall, F1 scores and IoU:"</span> &lt;&lt; std::endl;</div><div class="line">  Classification::Evaluation evaluation (labels, pts.range(label_map), label_indices);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (Label_handle l : labels)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">" * "</span> &lt;&lt; l-&gt;name() &lt;&lt; <span class="stringliteral">": "</span></div><div class="line">              &lt;&lt; evaluation.precision(l) &lt;&lt; <span class="stringliteral">" ; "</span></div><div class="line">              &lt;&lt; evaluation.recall(l) &lt;&lt; <span class="stringliteral">" ; "</span></div><div class="line">              &lt;&lt; evaluation.f1_score(l) &lt;&lt; <span class="stringliteral">" ; "</span></div><div class="line">              &lt;&lt; evaluation.intersection_over_union(l) &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Accuracy = "</span> &lt;&lt; evaluation.accuracy() &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">"Mean F1 score = "</span> &lt;&lt; evaluation.mean_f1_score() &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">"Mean IoU = "</span> &lt;&lt; evaluation.mean_intersection_over_union() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Color point set according to class</span></div><div class="line">  UCmap red = pts.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"red"</span>, 0).first;</div><div class="line">  UCmap green = pts.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"green"</span>, 0).first;</div><div class="line">  UCmap blue = pts.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"blue"</span>, 0).first;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; label_indices.size(); ++ i)</div><div class="line">  {</div><div class="line">    label_map[i] = label_indices[i]; <span class="comment">// update label map with computed classification</span></div><div class="line"></div><div class="line">    Label_handle label = labels[label_indices[i]];</div><div class="line">    <span class="keyword">const</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a>&amp; color = label-&gt;color();</div><div class="line">    red[i] = color.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html#af428aec48cc6ce23776b5f8cdf2a7883">red</a>();</div><div class="line">    green[i] = color.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html#afc04b32226660e92c55c5855d7ae0c5f">green</a>();</div><div class="line">    blue[i] = color.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html#aee7a7d6b78b2045840c4a292c26500df">blue</a>();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Save configuration for later use</span></div><div class="line">  std::ofstream fconfig (<span class="stringliteral">"ethz_random_forest.bin"</span>, std::ios_base::binary);</div><div class="line">  classifier.save_configuration(fconfig);</div><div class="line"></div><div class="line">  <span class="comment">// Write result</span></div><div class="line">  std::ofstream f (<span class="stringliteral">"classification.ply"</span>);</div><div class="line">  f.precision(18);</div><div class="line">  f &lt;&lt; pts;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"All done"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Classification_example_opencv_random_forest"></a>
OpenCV Random Forest</h2>
<p>The following example shows how to use the classifier <a class="el" href="classCGAL_1_1Classification_1_1OpenCV_1_1Random__forest__classifier.html">OpenCV::Random_forest_classifier</a> using an input training set.</p>
<p><br />
<b>File</b> <a class="el" href="Classification_2example_opencv_random_forest_8cpp-example.html">Classification/example_opencv_random_forest.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#if defined (_MSC_VER) &amp;&amp; !defined (_WIN64)</span></div><div class="line"><span class="preprocessor">#pragma warning(disable:4244) // boost::number_distance::distance()</span></div><div class="line">                              <span class="comment">// converts 64 to 32 bits integers</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Classification.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3/IO.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> CGAL::Point_set_3&lt;Point&gt; Point_set;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::Iso_cuboid_3</a> Iso_cuboid_3;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Point_set::Point_map Pmap;</div><div class="line"><span class="keyword">typedef</span> Point_set::Property_map&lt;int&gt; Imap;</div><div class="line"><span class="keyword">typedef</span> Point_set::Property_map&lt;unsigned char&gt; UCmap;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Classification = <a class="code" href="namespaceCGAL_1_1Classification.html">CGAL::Classification</a>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Label_handle                                            Label_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_handle                                          Feature_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Label_set                                               Label_set;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_set                                             Feature_set;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Point_set_feature_generator&lt;Kernel, Point_set, Pmap&gt;    Feature_generator;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::string filename = (argc &gt; 1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/b9_training.ply"</span>);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Reading input"</span> &lt;&lt; std::endl;</div><div class="line">  std::ifstream in (filename.c_str(), std::ios::binary);</div><div class="line">  Point_set pts;</div><div class="line">  in &gt;&gt; pts;</div><div class="line"></div><div class="line">  Imap label_map;</div><div class="line">  <span class="keywordtype">bool</span> lm_found = <span class="keyword">false</span>;</div><div class="line">  std::tie (label_map, lm_found) = pts.property_map&lt;<span class="keywordtype">int</span>&gt; (<span class="stringliteral">"label"</span>);</div><div class="line">  <span class="keywordflow">if</span> (!lm_found)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: \"label\" property not found in input file."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Generating features"</span> &lt;&lt; std::endl;</div><div class="line">  CGAL::Real_timer t;</div><div class="line">  t.start();</div><div class="line">  Feature_generator generator (pts, pts.point_map(),</div><div class="line">                               5);  <span class="comment">// using 5 scales</span></div><div class="line"></div><div class="line">  features.begin_parallel_additions();</div><div class="line">  generator.generate_point_based_features (features);</div><div class="line">  features.end_parallel_additions();</div><div class="line"></div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Add labels</span></div><div class="line">  Label_set labels;</div><div class="line">  Label_handle ground = labels.add (<span class="stringliteral">"ground"</span>);</div><div class="line">  Label_handle vegetation = labels.add (<span class="stringliteral">"vegetation"</span>);</div><div class="line">  Label_handle roof = labels.add (<span class="stringliteral">"roof"</span>);</div><div class="line"></div><div class="line">  std::vector&lt;int&gt; label_indices(pts.size(), -1);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Using OpenCV Random Forest Classifier"</span> &lt;&lt; std::endl;</div><div class="line">  Classification::OpenCV::Random_forest_classifier classifier (labels, features);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Training"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div><div class="line">  t.start();</div><div class="line">  classifier.train (pts.range(label_map));</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  t.reset();</div><div class="line">  t.start();</div><div class="line">  Classification::classify_with_graphcut&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (pts, pts.point_map(), labels, classifier,</div><div class="line">     generator.neighborhood().k_neighbor_query(12),</div><div class="line">     0.2f, 1, label_indices);</div><div class="line">  t.stop();</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classification with graphcut done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Precision, recall, F1 scores and IoU:"</span> &lt;&lt; std::endl;</div><div class="line">  Classification::Evaluation evaluation (labels, pts.range(label_map), label_indices);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (Label_handle l : labels)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">" * "</span> &lt;&lt; l-&gt;name() &lt;&lt; <span class="stringliteral">": "</span></div><div class="line">              &lt;&lt; evaluation.precision(l) &lt;&lt; <span class="stringliteral">" ; "</span></div><div class="line">              &lt;&lt; evaluation.recall(l) &lt;&lt; <span class="stringliteral">" ; "</span></div><div class="line">              &lt;&lt; evaluation.f1_score(l) &lt;&lt; <span class="stringliteral">" ; "</span></div><div class="line">              &lt;&lt; evaluation.intersection_over_union(l) &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Accuracy = "</span> &lt;&lt; evaluation.accuracy() &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">"Mean F1 score = "</span> &lt;&lt; evaluation.mean_f1_score() &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">"Mean IoU = "</span> &lt;&lt; evaluation.mean_intersection_over_union() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Color point set according to class</span></div><div class="line">  UCmap red = pts.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"red"</span>, 0).first;</div><div class="line">  UCmap green = pts.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"green"</span>, 0).first;</div><div class="line">  UCmap blue = pts.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"blue"</span>, 0).first;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; label_indices.size(); ++ i)</div><div class="line">  {</div><div class="line">    label_map[i] = label_indices[i]; <span class="comment">// update label map with computed classification</span></div><div class="line"></div><div class="line">    Label_handle label = labels[label_indices[i]];</div><div class="line">    <span class="keyword">const</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a>&amp; color = label-&gt;color();</div><div class="line">    red[i] = color.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html#af428aec48cc6ce23776b5f8cdf2a7883">red</a>();</div><div class="line">    green[i] = color.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html#afc04b32226660e92c55c5855d7ae0c5f">green</a>();</div><div class="line">    blue[i] = color.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html#aee7a7d6b78b2045840c4a292c26500df">blue</a>();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Write result</span></div><div class="line">  std::ofstream f (<span class="stringliteral">"classification.ply"</span>);</div><div class="line">  f.precision(18);</div><div class="line">  f &lt;&lt; pts;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"All done"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Classification_example_mesh"></a>
Mesh Classification</h2>
<p>The following example:</p>
<ul>
<li>reads a mesh in OFF format;</li>
<li>automatically generates features on 5 scales;</li>
<li>loads a configuration file for classifier <a class="el" href="classCGAL_1_1Classification_1_1ETHZ_1_1Random__forest__classifier.html">ETHZ::Random_forest_classifier</a>;</li>
<li>runs the algorithm using the graphcut regularization.</li>
</ul>
<p><br />
<b>File</b> <a class="el" href="Classification_2example_mesh_classification_8cpp-example.html">Classification/example_mesh_classification.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#if defined (_MSC_VER) &amp;&amp; !defined (_WIN64)</span></div><div class="line"><span class="preprocessor">#pragma warning(disable:4244) // boost::number_distance::distance()</span></div><div class="line">                              <span class="comment">// converts 64 to 32 bits integers</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Classification.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> CGAL::Surface_mesh&lt;Point&gt; Mesh;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Classification = <a class="code" href="namespaceCGAL_1_1Classification.html">CGAL::Classification</a>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Label_handle                                            Label_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_handle                                          Feature_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Label_set                                               Label_set;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_set                                             Feature_set;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Face_descriptor_to_center_of_mass_map&lt;Mesh&gt;             Face_point_map;</div><div class="line"><span class="keyword">typedef</span> Classification::Face_descriptor_to_face_descriptor_with_bbox_map&lt;Mesh&gt;  Face_with_bbox_map;</div><div class="line"><span class="keyword">typedef</span> Classification::Mesh_feature_generator&lt;Kernel, Mesh, Face_point_map&gt;    Feature_generator;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::string filename = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/b9_mesh.off"</span>);</div><div class="line">  std::string filename_config = <span class="stringliteral">"data/b9_mesh_config.bin"</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1)</div><div class="line">    filename = argv[1];</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 2)</div><div class="line">    filename_config = argv[2];</div><div class="line"></div><div class="line">  Mesh mesh;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLIOFct.html#ga49f5b5e6fbfcbfaaac7604c88e10915c">CGAL::IO::read_polygon_mesh</a>(filename, mesh,</div><div class="line">                                  <span class="comment">// the PLY reader expects a binary file by default</span></div><div class="line">                                  CGAL::parameters::use_binary_mode(<span class="keyword">false</span>)))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Generating features"</span> &lt;&lt; std::endl;</div><div class="line">  CGAL::Real_timer t;</div><div class="line">  t.start();</div><div class="line"></div><div class="line"></div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  Face_point_map face_point_map (&amp;mesh); <span class="comment">// Associates each face to its center of mass</span></div><div class="line"></div><div class="line">  std::size_t number_of_scales = 5;</div><div class="line">  Feature_generator generator (mesh, face_point_map, number_of_scales);</div><div class="line"></div><div class="line">  features.begin_parallel_additions();</div><div class="line">  generator.generate_point_based_features (features); <span class="comment">// Features that consider the mesh as a point set</span></div><div class="line">  generator.generate_face_based_features (features);  <span class="comment">// Features computed directly on mesh faces</span></div><div class="line">  features.end_parallel_additions();</div><div class="line"></div><div class="line"></div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  Label_set labels = { <span class="stringliteral">"ground"</span>, <span class="stringliteral">"vegetation"</span>, <span class="stringliteral">"roof"</span> };</div><div class="line"></div><div class="line">  std::vector&lt;int&gt; label_indices(mesh.number_of_faces(), -1);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Using ETHZ Random Forest Classifier"</span> &lt;&lt; std::endl;</div><div class="line">  Classification::ETHZ::Random_forest_classifier classifier (labels, features);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Loading configuration"</span> &lt;&lt; std::endl;</div><div class="line">  std::ifstream in_config (filename_config, std::ios_base::in | std::ios_base::binary);</div><div class="line">  classifier.load_configuration (in_config);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classifying with graphcut"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div><div class="line">  t.start();</div><div class="line">  Classification::classify_with_graphcut&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (mesh.faces(), Face_with_bbox_map(&amp;mesh), labels, classifier,</div><div class="line">     generator.neighborhood().n_ring_neighbor_query(2),</div><div class="line">     0.2f, 1, label_indices);</div><div class="line">  t.stop();</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classification with graphcut done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Classification_example_cluster"></a>
Cluster Classification</h2>
<p>The following example:</p>
<ul>
<li>reads a point set in PLY format;</li>
<li>estimates the normal vectors of the point set;</li>
<li>automatically generates pointwise features on 5 scales;</li>
<li>detects plane using the algorithm <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Region__growing.html">CGAL::Shape_detection::Region_growing</a></code>;</li>
<li>creates <a class="el" href="classCGAL_1_1Classification_1_1Cluster.html">Cluster</a> objects from these detected planes;</li>
<li>computes cluster features from the pointwise features;</li>
<li>loads a configuration file for classifier <a class="el" href="classCGAL_1_1Classification_1_1ETHZ_1_1Random__forest__classifier.html">ETHZ::Random_forest_classifier</a>;</li>
<li>runs the algorithm using the raw algorithm.</li>
</ul>
<p><br />
<b>File</b> <a class="el" href="Classification_2example_cluster_classification_8cpp-example.html">Classification/example_cluster_classification.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#if defined (_MSC_VER) &amp;&amp; !defined (_WIN64)</span></div><div class="line"><span class="preprocessor">#pragma warning(disable:4244) // boost::number_distance::distance()</span></div><div class="line">                              <span class="comment">// converts 64 to 32 bits integers</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/iterator/function_output_iterator.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Classification.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3/IO.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/jet_estimate_normals.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/Region__growing_8h.html">CGAL/Shape_detection/Region_growing.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::Iso_cuboid_3</a>           Iso_cuboid_3;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> CGAL::Point_set_3&lt;Point&gt; Point_set;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Point_set::Point_map                   Pmap;</div><div class="line"><span class="keyword">typedef</span> Point_set::Vector_map                  Vmap;</div><div class="line"><span class="keyword">typedef</span> Point_set::Property_map&lt;int&gt;           Imap;</div><div class="line"><span class="keyword">typedef</span> Point_set::Property_map&lt;unsigned char&gt; UCmap;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Point__set_1_1Sphere__neighbor__query.html">CGAL::Shape_detection::Point_set::Sphere_neighbor_query&lt;Kernel, Point_set, Pmap&gt;</a>                Neighbor_query;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Point__set_1_1Least__squares__plane__fit__region.html">CGAL::Shape_detection::Point_set::Least_squares_plane_fit_region&lt;Kernel, Point_set, Pmap, Vmap&gt;</a> Region_type;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Region__growing.html">CGAL::Shape_detection::Region_growing&lt;Point_set, Neighbor_query, Region_type&gt;</a>                   Region_growing;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Classification = <a class="code" href="namespaceCGAL_1_1Classification.html">CGAL::Classification</a>;</div><div class="line"><span class="keyword">namespace </span>Feature = <a class="code" href="namespaceCGAL_1_1Classification_1_1Feature.html">CGAL::Classification::Feature</a>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Label_handle   Label_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_handle Feature_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Label_set      Label_set;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_set    Feature_set;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Local_eigen_analysis                                 Local_eigen_analysis;</div><div class="line"><span class="keyword">typedef</span> Classification::Point_set_feature_generator&lt;Kernel, Point_set, Pmap&gt; Feature_generator;</div><div class="line"><span class="keyword">typedef</span> Classification::Cluster&lt;Point_set, Pmap&gt;                             Cluster;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::string filename        = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/b9.ply"</span>);</div><div class="line">  std::string filename_config = <span class="stringliteral">"data/b9_clusters_config.bin"</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1)</div><div class="line">    filename = argv[1];</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 2)</div><div class="line">    filename_config = argv[2];</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Reading input"</span> &lt;&lt; std::endl;</div><div class="line">  Point_set pts;</div><div class="line">  <span class="keywordflow">if</span>(!(CGAL::IO::read_point_set(filename, pts,</div><div class="line">                                <span class="comment">// the PLY reader expects a binary file by default</span></div><div class="line">                                CGAL::parameters::use_binary_mode(<span class="keyword">true</span>))))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read "</span> &lt;&lt; filename &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Estimating normals"</span> &lt;&lt; std::endl;</div><div class="line">  CGAL::Real_timer t;</div><div class="line">  t.start();</div><div class="line">  pts.add_normal_map();</div><div class="line">  CGAL::jet_estimate_normals&lt;CGAL::Parallel_if_available_tag&gt; (pts, 12);</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div><div class="line"></div><div class="line">  Feature_set pointwise_features;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Generating pointwise features"</span> &lt;&lt; std::endl;</div><div class="line">  t.start();</div><div class="line">  Feature_generator generator (pts, pts.point_map(), 5); <span class="comment">// using 5 scales</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef CGAL_LINKED_WITH_TBB</span></div><div class="line">  pointwise_features.begin_parallel_additions();</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">  generator.generate_point_based_features (pointwise_features);</div><div class="line"></div><div class="line">  <span class="comment">// Generator should only be used with variables defined at the scope</span></div><div class="line">  <span class="comment">// of the generator object, thus we instantiate the normal map</span></div><div class="line">  <span class="comment">// outside of the function</span></div><div class="line">  Vmap normal_map = pts.normal_map();</div><div class="line">  generator.generate_normal_based_features (pointwise_features, normal_map);</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef CGAL_LINKED_WITH_TBB</span></div><div class="line">  pointwise_features.end_parallel_additions();</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Detecting planes and creating clusters"</span> &lt;&lt; std::endl;</div><div class="line">  t.start();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> search_sphere_radius  = 1.0;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> max_distance_to_plane = 1.0;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> max_accepted_angle    = 25.0;</div><div class="line">  <span class="keyword">const</span> std::size_t min_region_size  = 10;</div><div class="line"></div><div class="line">  Neighbor_query neighbor_query (</div><div class="line">    pts, CGAL::parameters::sphere_radius(search_sphere_radius)</div><div class="line">                          .point_map(pts.point_map()));</div><div class="line">  Region_type region_type(</div><div class="line">    pts, CGAL::parameters::maximum_distance(max_distance_to_plane)</div><div class="line">                          .maximum_angle(max_accepted_angle)</div><div class="line">                          .minimum_region_size(min_region_size)</div><div class="line">                          .point_map(pts.point_map())</div><div class="line">                          .normal_map(pts.normal_map()));</div><div class="line">  Region_growing region_growing (</div><div class="line">    pts, neighbor_query, region_type);</div><div class="line"></div><div class="line">  std::vector&lt;Cluster&gt; clusters;</div><div class="line">  region_growing.detect</div><div class="line">    (boost::make_function_output_iterator</div><div class="line">     ([&amp;](<span class="keyword">const</span> std::vector&lt;std::size_t&gt;&amp; region) -&gt; <span class="keywordtype">void</span> {</div><div class="line"></div><div class="line">        <span class="comment">// Create a new cluster.</span></div><div class="line">        Classification::Cluster&lt;Point_set, Pmap&gt; cluster (pts, pts.point_map());</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> std::size_t idx : region)</div><div class="line">          cluster.insert(idx);</div><div class="line">        clusters.push_back(cluster);</div><div class="line">      }));</div><div class="line"></div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; clusters.size() &lt;&lt; <span class="stringliteral">" clusters created in "</span></div><div class="line">            &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div><div class="line"></div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Computing cluster features"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">  Local_eigen_analysis eigen = Local_eigen_analysis::create_from_point_clusters (clusters);</div><div class="line"></div><div class="line"></div><div class="line">  t.start();</div><div class="line"></div><div class="line"></div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  <span class="comment">// First, compute means of features.</span></div><div class="line">  features.begin_parallel_additions();</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; pointwise_features.size(); ++ i)</div><div class="line">    features.add&lt;Feature::Cluster_mean_of_feature&gt; (clusters, pointwise_features[i]);</div><div class="line">  features.end_parallel_additions();</div><div class="line"></div><div class="line">  <span class="comment">// Then, compute variances of features (and remaining cluster features).</span></div><div class="line">  features.begin_parallel_additions();</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; pointwise_features.size(); ++ i)</div><div class="line">    features.add&lt;Feature::Cluster_variance_of_feature&gt; (clusters,</div><div class="line">                                                        pointwise_features[i], <span class="comment">// i^th feature</span></div><div class="line">                                                        features[i]);          <span class="comment">// mean of i^th feature</span></div><div class="line"></div><div class="line">  features.add&lt;Feature::Cluster_size&gt; (clusters);</div><div class="line">  features.add&lt;Feature::Cluster_vertical_extent&gt; (clusters);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; 3; ++ i)</div><div class="line">    features.add&lt;Feature::Eigenvalue&gt; (clusters, eigen, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(i));</div><div class="line"></div><div class="line">  features.end_parallel_additions();</div><div class="line"></div><div class="line"></div><div class="line">  t.stop();</div><div class="line"></div><div class="line">  Label_set labels = { <span class="stringliteral">"ground"</span>, <span class="stringliteral">"vegetation"</span>, <span class="stringliteral">"roof"</span> };</div><div class="line"></div><div class="line">  std::vector&lt;int&gt; label_indices(clusters.size(), -1);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Using ETHZ Random Forest Classifier"</span> &lt;&lt; std::endl;</div><div class="line">  Classification::ETHZ::Random_forest_classifier classifier (labels, features);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Loading configuration"</span> &lt;&lt; std::endl;</div><div class="line">  std::ifstream in_config (filename_config, std::ios_base::in | std::ios_base::binary);</div><div class="line">  classifier.load_configuration (in_config);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classifying"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div><div class="line">  t.start();</div><div class="line">  Classification::classify&lt;CGAL::Parallel_if_available_tag&gt; (clusters, labels, classifier, label_indices);</div><div class="line">  t.stop();</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classification done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Classification_history"></a>
History</h1>
<p>This package is based on a research code by <a href="https://www-sop.inria.fr/members/Florent.Lafarge/">Florent Lafarge</a> that was generalized, extended and packaged by <a href="http://geometryfactory.com/who-we-are/">Simon Giraudot</a> in CGAL 4.12. Classification of surface meshes and of clusters were introduced in CGAL 4.13. The Neural Network classifier was introduced in CGAL 4.14. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Jul 5 2022 09:51:36 for CGAL 5.6 - Classification by
    <a href="https://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>
</html><html xmlns="http://www.w3.org/1999/xhtml"><body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.6 - Classification
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Classification"></a> </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Authors</dt><dd>Simon Giraudot, Florent Lafarge</dd></dl>
<p>This component implements the algorithm described in <a class="el" href="citelist.html#CITEREF_cgal:lm-clscm-12">[4]</a> (section 2), generalized to handle different types of data, multiple features and multiple labels. It classifies a data set into a user-defined set of labels, such as <em>ground</em>, <em>vegetation</em> and <em>buildings</em>. A flexible API is provided so that users can classify any type of data which they can index and for which they can compute relevant features, compute their own local features on the input data set and define their own labels.</p>
<h1><a class="anchor" id="Classification_Organization"></a>
Package Organization</h1>
<p>Classification of data sets is achieved as follows (see Figure <a class="el" href="index.html#fig__Classification_organization_fig">Figure 84.1</a>):</p>
<ul>
<li>some analysis is performed on the input data set;</li>
<li>features are computed based on this analysis;</li>
<li>a set of labels (for example: <em>ground</em>, <em>building</em>, <em>vegetation</em>) is defined by the user;</li>
<li>a classifier is defined and trained: from the set of values taken by the features at an input item, it measures the likelihood of this item to belong to one label or another;</li>
<li>classification is computed itemwise using the classifier;</li>
<li>additional regularization can be used by smoothing either locally or globally through a <em>graph cut</em> <a class="el" href="citelist.html#CITEREF_Boykov2001FastApproximate">[1]</a> approach.</li>
</ul>
<p><a class="anchor" id="fig__Classification_organization_fig"></a></p><div class="image">
<object type="image/svg+xml" data="organization.svg">organization.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Classification_organization_fig">Figure 84.1</a> Organization of the package.  </div> <br /> 
<p>This package is designed to be easily extended by users: more specifically, features and labels can be defined by users to handle any data they need to classify.</p>
<p>Currently, CGAL provides data structures to handle classification of point sets, surface meshes and clusters.</p>
<h1><a class="anchor" id="Classification_structures"></a>
Common Data Structures</h1>
<h2><a class="anchor" id="Classification_labels"></a>
Label Set</h2>
<p>A label represents how an item should be classified, for example: <em>vegetation</em>, <em>building</em>, <em>road</em>, etc. In CGAL, a label has a name, an index (in a label set), a standard index (for example, the index of the label in the ASPRS standard) and a color. It is simply identified by a <a class="el" href="classCGAL_1_1Classification_1_1Label__handle.html">Label_handle</a>. Note that names, standard indices and colors are not used for identification: two labels in the same set can have the same name, standard index and color but not the same handle.</p>
<p>If labels are initialized with their names only, standard indices and colors can be deduced in some cases (see <a class="el" href="classCGAL_1_1Classification_1_1Label__set.html#afaa0d2e86c20b0c7ef19ce5e3f6b1104">Label_set::add()</a>).</p>
<p>The following code snippet shows how to add labels to the classification object:</p>
<div class="fragment"><div class="line"></div><div class="line">  Label_set labels;</div><div class="line"></div><div class="line">  <span class="comment">// Init name only</span></div><div class="line">  Label_handle ground = labels.add (<span class="stringliteral">"ground"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Init name and color</span></div><div class="line">  Label_handle vegetation = labels.add (<span class="stringliteral">"vegetation"</span>, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a>(0,255,0));</div><div class="line"></div><div class="line">  <span class="comment">// Init name, Color and standard index (here, ASPRS building index)</span></div><div class="line">  Label_handle roof = labels.add (<span class="stringliteral">"roof"</span>, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a> (255, 0, 0), 6);</div><div class="line"></div></div><!-- fragment --> <h2><a class="anchor" id="Classification_features"></a>
Feature Set</h2>
<p>Features are defined as scalar fields that associate each input item with a specific value. Note that in order to limit memory consumption, we use the type <code>float</code> for these scalar values (as well as for every floating point value in this package). A feature has a name and is identified by a <a class="el" href="classCGAL_1_1Classification_1_1Feature__handle.html">Feature_handle</a>.</p>
<p>The computation of features and their addition to the feature set is done in a single step using the <a class="el" href="classCGAL_1_1Classification_1_1Feature__set.html#a2d7dc5beaa908425dcf000ed441aa4bf">Feature_set::add&lt;Feature&gt;()</a> method. If CGAL was linked with <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartyTBB">Intel TBB</a>, features can be computed in parallel (see below).</p>
<p>CGAL provides some predefined features (see <a class="el" href="index.html#Classification_point_sets">Point Set Classification</a> for example). In the following code snippet, a subset of these predefined features are instantiated (in parallel if <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartyTBB">Intel TBB</a> is available). Note that all the predefined features can also be automatically generated in multiple scales (see <a class="el" href="index.html#Classification_point_sets">Point Set Classification</a> for example).</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="keywordtype">float</span> radius_neighbors = 1.7f;</div><div class="line">  <span class="keywordtype">float</span> radius_dtm = 15.0f;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Computing features"</span> &lt;&lt; std::endl;</div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  features.begin_parallel_additions(); <span class="comment">// No effect in sequential mode</span></div><div class="line"></div><div class="line">  Feature_handle distance_to_plane = features.add&lt;Distance_to_plane&gt; (pts, Pmap(), eigen);</div><div class="line">  Feature_handle dispersion = features.add&lt;Dispersion&gt; (pts, Pmap(), grid,</div><div class="line">                                                        radius_neighbors);</div><div class="line">  Feature_handle elevation = features.add&lt;Elevation&gt; (pts, Pmap(), grid,</div><div class="line">                                                      radius_dtm);</div><div class="line"></div><div class="line">  features.end_parallel_additions(); <span class="comment">// No effect in sequential mode</span></div><div class="line"></div></div><!-- fragment --><p> Users may want to define their own features, especially if the input data set comes with additional properties that were not anticipated by CGAL. A user-defined feature must inherit from <a class="el" href="classCGAL_1_1Classification_1_1Feature__base.html">Feature_base</a> and provide a method <a class="el" href="classCGAL_1_1Classification_1_1Feature__base.html#a601e16c0026bd33f28fc8bfd68b30461">value()</a> that associates a scalar value to each input item.</p>
<p>The following example shows how to define a feature that discriminates points that lie inside a 2D box from the others:</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="comment">// User-defined feature that identifies a specific area of the 3D</span></div><div class="line"><span class="comment">// space. This feature takes value 1 for points that lie inside the</span></div><div class="line"><span class="comment">// area and 0 for the others.</span></div><div class="line"><span class="keyword">class </span>My_feature : <span class="keyword">public</span> <a class="code" href="classCGAL_1_1Classification_1_1Feature__base.html">CGAL::Classification::Feature_base</a></div><div class="line">{</div><div class="line">  <span class="keyword">const</span> Point_range&amp; range;</div><div class="line">  <span class="keywordtype">double</span> xmin, xmax, ymin, ymax;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  My_feature (<span class="keyword">const</span> Point_range&amp; range,</div><div class="line">              <span class="keywordtype">double</span> xmin, <span class="keywordtype">double</span> xmax, <span class="keywordtype">double</span> ymin, <span class="keywordtype">double</span> ymax)</div><div class="line">    : range (range), xmin(xmin), xmax(xmax), ymin(ymin), ymax(ymax)</div><div class="line">  {</div><div class="line">    this-&gt;set_name (<span class="stringliteral">"my_feature"</span>);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">float</span> value (std::size_t pt_index)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (xmin &lt; range[pt_index].x() &amp;&amp; range[pt_index].x() &lt; xmax &amp;&amp;</div><div class="line">        ymin &lt; range[pt_index].y() &amp;&amp; range[pt_index].y() &lt; ymax)</div><div class="line">      <span class="keywordflow">return</span> 1.f;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <span class="keywordflow">return</span> 0.f;</div><div class="line">  }</div><div class="line"></div><div class="line">};</div><div class="line"></div></div><!-- fragment --><p> This feature can then be instantiated from the feature set the same way as the others:</p>
<div class="fragment"><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Computing features"</span> &lt;&lt; std::endl;</div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  <span class="comment">// Feature that identifies points whose x coordinate is between -20</span></div><div class="line">  <span class="comment">// and 20 and whose y coordinate is between -15 and 15</span></div><div class="line">  Feature_handle my_feature = features.add&lt;My_feature&gt; (pts, -20., 20., -15., 15.);</div><div class="line"></div></div><!-- fragment --> <h1><a class="anchor" id="Classification_structures_specialized"></a>
Specialized Data Structures</h1>
<p>Classification is based on the computation of local features. These features can take advantage of shared data structures that are precomputed and stored separately. Both these features and the underlying data structures depend on the type of data that needs to be classified. CGAL provides data structures to classify point sets, surface meshes and clusters.</p>
<h2><a class="anchor" id="Classification_point_sets"></a>
Point Set Classification</h2>
<p>CGAL provides the following structures:</p>
<ul>
<li><a class="el" href="classCGAL_1_1Classification_1_1Point__set__neighborhood.html">Point_set_neighborhood</a> stores spatial searching structures and provides adapted queries for points;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Local__eigen__analysis.html">Local_eigen_analysis</a> precomputes covariance matrices on local neighborhoods of points and stores the associated eigenvectors and eigenvalues;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Planimetric__grid.html">Planimetric_grid</a> is a 2D grid used for digital terrain modeling.</li>
</ul>
<p>Most of these data structures depend on a scale parameter. CGAL provides a method to estimate the average spacing based on a number of neighbors (see <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga8b330397a3fb68176c851fd7d214b513">CGAL::compute_average_spacing()</a>), which usually provides satisfying results in the absence of noise. In the presence of noise, <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga28fe6443638647be0874b283085eb2cd">CGAL::estimate_global_range_scale()</a> provides an estimation of the smallest scale such that the point set has the local dimension of a surface (this method is both robust to noise and outliers, see <a class="el" href="index.html#Classification_sowf_result">Result</a>).</p>
<p>The eigen analysis can be used to estimate normals. Note however that this analysis (based on Principal Component Analysis) might not be robust to a high level of noise. CGAL also provides more robust normal estimation functions (see for example <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga078e25209373cab0e1f3524202489771">CGAL::jet_estimate_normals()</a>).</p>
<p>The following code snippet shows how to instantiate such data structures from an input PLY point set (the <a class="el" href="index.html#Classification_example_general">full example</a> is given at the end of the manual).</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/b9.ply"</span>);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Reading input"</span> &lt;&lt; std::endl;</div><div class="line">  std::vector&lt;Point&gt; pts;</div><div class="line">  <span class="keywordflow">if</span> (!(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(filename, std::back_inserter(pts),</div><div class="line">                              <span class="comment">// the PLY reader expects a binary file by default</span></div><div class="line">                              CGAL::parameters::use_binary_mode(<span class="keyword">false</span>))))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read "</span> &lt;&lt; filename &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">float</span> grid_resolution = 0.34f;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> number_of_neighbors = 6;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Computing useful structures"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  Iso_cuboid_3 bbox = CGAL::bounding_box (pts.begin(), pts.end());</div><div class="line"></div><div class="line">  Planimetric_grid grid (pts, Pmap(), bbox, grid_resolution);</div><div class="line">  Neighborhood neighborhood (pts, Pmap());</div><div class="line">  Local_eigen_analysis eigen</div><div class="line">    = Local_eigen_analysis::create_from_point_set</div><div class="line">    (pts, Pmap(), neighborhood.k_neighbor_query(number_of_neighbors));</div><div class="line"></div></div><!-- fragment --><p> CGAL provides some predefined features:</p>
<ul>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Distance__to__plane.html">Distance_to_plane</a> measures how far away a point is from a locally estimated plane;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Eigenvalue.html">Eigenvalue</a> measures one of the three local eigenvalues;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Elevation.html">Elevation</a> computes the local distance to an estimation of the ground;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Elevation.html">Height_above</a> computes the distance between the local highest point and the point;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Elevation.html">Height_below</a> computes the distance between the point and the local lowest point;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Vertical__dispersion.html">Vertical_dispersion</a> computes how noisy the point set is on a local Z-cylinder;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Elevation.html">Vertical_range</a> computes the distance between the local highest and lowest points;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Verticality.html">Verticality</a> compares the local normal vector to the vertical vector.</li>
</ul>
<p>These features are designed for point sets but can easily be used with surface meshes as well (see <a class="el" href="index.html#Classification_meshes">Mesh Classification</a>). For more details about how these different features can help to identify one label or the other, please refer to their associated reference manual pages.</p>
<p>In addition, if the input data set has additional properties, these can also be used as features. For example, CGAL provides the following features:</p>
<ul>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Color__channel.html">Color_channel</a> uses input color information if available;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Echo__scatter.html">Echo_scatter</a> uses the number of returns (echo) provided by most LIDAR scanners if available;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Simple__feature.html">Simple_feature</a> uses any property map applicable to the input range and whose value type is castable to <code>float</code> (useful if an additional property of the input set should be used as is, for example an <code>intensity</code> measurement).</li>
</ul>
<p>Users commonly want to use all predefined features to get the best result possible. CGAL provides a class <a class="el" href="classCGAL_1_1Classification_1_1Point__set__feature__generator.html">Point_set_feature_generator</a> that performs the following operations:</p>
<ul>
<li>it estimates the smallest relevant scale;</li>
<li>it generates all needed analysis structures and provides access to them;</li>
<li>it generates all possible features (among all the CGAL predefined ones) based on which property maps are available (they use colors if available, etc.).</li>
</ul>
<p>Multiple scales that are sequentially larger can be used to increase the quality of the results <a class="el" href="citelist.html#CITEREF_cgal:hws-fsso3-16">[3]</a>.</p>
<p>Note that using this class in order to generate features is not mandatory, as features and data structures can all be handled by hand. It is mainly provided to make the specific case of point sets simpler to handle. Users can still add their own features within their feature set.</p>
<p>Some data structure instantiated by the generator will be used by feature: for this reason, the generator should be instantiated <em>within the same scope</em> as the feature set and should not be deleted before the feature set.</p>
<p>The following snippet shows how to use the point set feature generator:</p>
<div class="fragment"><div class="line"></div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  std::size_t number_of_scales = 5;</div><div class="line">  Feature_generator generator (pts, pts.point_map(), number_of_scales);</div><div class="line"></div><div class="line">  features.begin_parallel_additions();</div><div class="line">  generator.generate_point_based_features (features);</div><div class="line">  features.end_parallel_additions();</div><div class="line"></div></div><!-- fragment --><p> <a class="anchor" id="fig__Classification_point_set_fig"></a></p><div class="image">
<img src="point_set.png" alt="point_set.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Classification_point_set_fig">Figure 84.2</a> Example of point set classification (left: input, right: output). <em>Ground</em> is grey, <em>roofs</em> are orange, <em>vegetation</em> is green.  </div> <br /> 
<h2><a class="anchor" id="Classification_meshes"></a>
Mesh Classification</h2>
<p>Classification of mesh is performed by considering the face of a mesh as an atomic element that should be assign one label or another. Some structures such as neighborhood or Eigen analysis are significantly different from their equivalent for point sets; other data structures from point sets can be directly used by viewing the mesh as a point set through the use of a property map that associates each face with a representative point.</p>
<p>Hereafter, a <em>mesh</em> refers to a model of <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/classFaceListGraph.html">FaceListGraph</a></code>.</p>
<p>CGAL provides the following structures:</p>
<ul>
<li><a class="el" href="classCGAL_1_1Classification_1_1Face__descriptor__to__center__of__mass__map.html">Face_descriptor_to_center_of_mass_map</a> is a property map that takes the face of a mesh as key type and returns the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__3.html">CGAL::Point_3</a></code> located at the center of mass of the face. It is useful to apply point set structures and features to surface meshes;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Face__descriptor__to__face__descriptor__with__bbox__map.html">Face_descriptor_to_face_descriptor_with_bbox_map</a> is a property map that takes the face of a mesh as key type and returns the same face along with its bounding box as a value type. It is useful to call <code><a class="el" href="group__PkgClassificationMain.html#ga2a4c1b0816b81b628dc9023e104449eb" title="runs the classification algorithm with a global regularization based on a graph cut. ">CGAL::Classification::classify_with_graphcut()</a></code> which requires objects that provide a <code>bbox()</code> method (see <a class="el" href="index.html#Classification_classification_functions">Classification Functions</a>);</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Mesh__neighborhood.html">Mesh_neighborhood</a> provides adapted queries for surface meshes;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Local__eigen__analysis.html">Local_eigen_analysis</a> precomputes covariance matrices on local neighborhoods of triangles and stores the associated eigenvectors and eigenvalues (it is the same object as for point sets called with a different named constructor);</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Planimetric__grid.html">Planimetric_grid</a> is the 2D grid used for digital terrain modeling of point sets, it can be used with meshes through <a class="el" href="classCGAL_1_1Classification_1_1Face__descriptor__to__center__of__mass__map.html">Face_descriptor_to_center_of_mass_map</a>.</li>
</ul>
<p>The point set features can be used for mesh classification as well:</p>
<ul>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Eigenvalue.html">Eigenvalue</a> takes the <a class="el" href="classCGAL_1_1Classification_1_1Local__eigen__analysis.html">Local_eigen_analysis</a> object computed on faces as input;</li>
<li>the other ones are computed by considering the mesh as a point set.</li>
</ul>
<p>Similarly to <a class="el" href="classCGAL_1_1Classification_1_1Point__set__feature__generator.html">Point_set_feature_generator</a>, CGAL provides a class <a class="el" href="classCGAL_1_1Classification_1_1Mesh__feature__generator.html">Mesh_feature_generator</a> that estimates the smallest scale automatically and computes all predefined features on several scales. As for point sets, using this class in order to generate features is not mandatory, as features and data structures can all be handled by hand. It is mainly provided to make the specific case of meshes simpler to handle. Users can still add their own features within their feature set.</p>
<p>The following snippet shows how to use the mesh feature generator:</p>
<div class="fragment"><div class="line"></div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  Face_point_map face_point_map (&amp;mesh); <span class="comment">// Associates each face to its center of mass</span></div><div class="line"></div><div class="line">  std::size_t number_of_scales = 5;</div><div class="line">  Feature_generator generator (mesh, face_point_map, number_of_scales);</div><div class="line"></div><div class="line">  features.begin_parallel_additions();</div><div class="line">  generator.generate_point_based_features (features); <span class="comment">// Features that consider the mesh as a point set</span></div><div class="line">  generator.generate_face_based_features (features);  <span class="comment">// Features computed directly on mesh faces</span></div><div class="line">  features.end_parallel_additions();</div><div class="line"></div></div><!-- fragment --><p> The <a class="el" href="index.html#Classification_example_mesh">full example</a> is given at the end of the manual.</p>
<p><a class="anchor" id="fig__Classification_mesh_fig"></a></p><div class="image">
<img src="mesh.png" alt="mesh.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Classification_mesh_fig">Figure 84.3</a> Example of mesh classification (left: input, right: output). <em>Ground</em> is grey, <em>roofs</em> are orange, <em>vegetation</em> is green.  </div> <br /> 
<h2><a class="anchor" id="Classification_clusters"></a>
Cluster Classification</h2>
<p>Classifying clusters of items instead of raw sets of items can have several advantages:</p>
<ul>
<li>if the data set is very large, using clusters can drastically decrease the complexity and thus the need for computation time and memory;</li>
<li>clusters are more complex objects than raw items (isolated points or triangles of a mesh) and thus provide additional information (size of cluster, spatial consistency, etc.);</li>
<li>by construction, the output classification is less noisy (if all points of a facade are in the same cluster, then they are guaranteed to all be classified in the same label).</li>
</ul>
<p>For example, when dealing with urban scenes that typically contain large planar sections, it may be more efficient to first detect planes (with <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Region__growing.html">CGAL::Shape_detection::Region_growing</a></code> or <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Efficient__RANSAC.html">CGAL::Shape_detection::Efficient_RANSAC</a></code> for example) and then to classify each subset of points belonging to a specific plane as clusters.</p>
<p>CGAL provides some tools to classify clusters:</p>
<ul>
<li>the class <code><a class="el" href="classCGAL_1_1Classification_1_1Cluster.html" title="Class that represent a cluster of items to be classified as a single atomic object. ">CGAL::Classification::Cluster</a></code> can be used to represent a cluster of items (points, for example);</li>
<li>the function <code><a class="el" href="group__PkgClassificationCluster.html#ga6c0c1a27071cf5ebfac967d6847cbbf9" title="Given a set of cluster indices, segments the input range into Cluster objects. ">CGAL::Classification::create_clusters_from_indices()</a></code> takes indices over items as input (for example, shape indices taken from shape detection) and generates one cluster per index.</li>
</ul>
<p>The following snippet shows how to create classification clusters from a shape detection algorithm (<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Region__growing.html">Region Growing</a>):</p>
<div class="fragment"><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Detecting planes and creating clusters"</span> &lt;&lt; std::endl;</div><div class="line">  t.start();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> search_sphere_radius  = 1.0;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> max_distance_to_plane = 1.0;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> max_accepted_angle    = 25.0;</div><div class="line">  <span class="keyword">const</span> std::size_t min_region_size  = 10;</div><div class="line"></div><div class="line">  Neighbor_query neighbor_query (</div><div class="line">    pts, CGAL::parameters::sphere_radius(search_sphere_radius)</div><div class="line">                          .point_map(pts.point_map()));</div><div class="line">  Region_type region_type(</div><div class="line">    pts, CGAL::parameters::maximum_distance(max_distance_to_plane)</div><div class="line">                          .maximum_angle(max_accepted_angle)</div><div class="line">                          .minimum_region_size(min_region_size)</div><div class="line">                          .point_map(pts.point_map())</div><div class="line">                          .normal_map(pts.normal_map()));</div><div class="line">  Region_growing region_growing (</div><div class="line">    pts, neighbor_query, region_type);</div><div class="line"></div><div class="line">  std::vector&lt;Cluster&gt; clusters;</div><div class="line">  region_growing.detect</div><div class="line">    (boost::make_function_output_iterator</div><div class="line">     ([&amp;](<span class="keyword">const</span> std::vector&lt;std::size_t&gt;&amp; region) -&gt; <span class="keywordtype">void</span> {</div><div class="line"></div><div class="line">        <span class="comment">// Create a new cluster.</span></div><div class="line">        Classification::Cluster&lt;Point_set, Pmap&gt; cluster (pts, pts.point_map());</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> std::size_t idx : region)</div><div class="line">          cluster.insert(idx);</div><div class="line">        clusters.push_back(cluster);</div><div class="line">      }));</div><div class="line"></div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; clusters.size() &lt;&lt; <span class="stringliteral">" clusters created in "</span></div><div class="line">            &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div><div class="line"></div></div><!-- fragment --><p> The class <a class="el" href="classCGAL_1_1Classification_1_1Local__eigen__analysis.html">Local_eigen_analysis</a> can also take point clusters as input:</p>
<div class="fragment"><div class="line"></div><div class="line">  Local_eigen_analysis eigen = Local_eigen_analysis::create_from_point_clusters (clusters);</div><div class="line"></div></div><!-- fragment --><p> As clusters are based on simple items, users can compute cluster features based on statistics over the itemwise features:</p>
<ul>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Cluster__mean__of__feature.html">Cluster_mean_of_feature</a> computes, for a cluster, the mean value of an itemwise feature over the inliers of this cluster;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Cluster__variance__of__feature.html">Cluster_variance_of_feature</a> computes, for a cluster, the variance of an itemwise feature over the inliers of this cluster.</li>
</ul>
<p>Some additional features are provided specifically for clusters:</p>
<ul>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Cluster__size.html">Cluster_size</a> uses the number of items in a cluster;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Cluster__vertical__extent.html">Cluster_vertical_extent</a> computes the length of the smallest interval on the <code>Z</code> axis that contains all the items of a cluster;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Feature_1_1Eigenvalue.html">Eigenvalue</a>, similarly to point sets and meshes, can use the <a class="el" href="classCGAL_1_1Classification_1_1Local__eigen__analysis.html">Local_eigen_analysis</a> object computed on clusters.</li>
</ul>
<p>The following snippet shows, from a pointwise feature set, how to generate the statistical features from a pointwise feature set (along with these latest cluster features):</p>
<div class="fragment"><div class="line"></div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  <span class="comment">// First, compute means of features.</span></div><div class="line">  features.begin_parallel_additions();</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; pointwise_features.size(); ++ i)</div><div class="line">    features.add&lt;Feature::Cluster_mean_of_feature&gt; (clusters, pointwise_features[i]);</div><div class="line">  features.end_parallel_additions();</div><div class="line"></div><div class="line">  <span class="comment">// Then, compute variances of features (and remaining cluster features).</span></div><div class="line">  features.begin_parallel_additions();</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; pointwise_features.size(); ++ i)</div><div class="line">    features.add&lt;Feature::Cluster_variance_of_feature&gt; (clusters,</div><div class="line">                                                        pointwise_features[i], <span class="comment">// i^th feature</span></div><div class="line">                                                        features[i]);          <span class="comment">// mean of i^th feature</span></div><div class="line"></div><div class="line">  features.add&lt;Feature::Cluster_size&gt; (clusters);</div><div class="line">  features.add&lt;Feature::Cluster_vertical_extent&gt; (clusters);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; 3; ++ i)</div><div class="line">    features.add&lt;Feature::Eigenvalue&gt; (clusters, eigen, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(i));</div><div class="line"></div><div class="line">  features.end_parallel_additions();</div><div class="line"></div></div><!-- fragment --><p> The <a class="el" href="index.html#Classification_example_cluster">full example</a> is given at the end of the manual.</p>
<p><a class="anchor" id="fig__Classification_cluster_fig"></a></p><div class="image">
<img src="clusters.png" alt="clusters.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Classification_cluster_fig">Figure 84.4</a> Example of cluster classification mesh (left: input, middle: clusters computed from region growing, right: output). <em>Ground</em> is grey, <em>roofs</em> are orange, <em>vegetation</em> is green, points not assigned to a cluster are <em>black</em>.  </div> <br /> 
<h1><a class="anchor" id="Classification_classifiers"></a>
Classifiers</h1>
<p>Classification relies on a classifier: this classifier is an object that, from the set of values taken by the features at an input item, computes the probability that an input item belongs to one label or another. A model of the concept <code><a class="el" href="classCGAL_1_1Classification_1_1Classifier.html" title="Concept describing a classifier used by classification functions (see CGAL::Classification::classify(...">CGAL::Classification::Classifier</a></code> must take the index of an input item and store the probability associated to each label in a vector. If a classifier returns the value 1 for a pair of label and input item, it means that this item belongs to this label with certainty; values close to 0 mean that this item is not likely to belong to this label.</p>
<p>CGAL provides three models for this concept, <a class="el" href="classCGAL_1_1Classification_1_1ETHZ_1_1Random__forest__classifier.html">ETHZ::Random_forest_classifier</a>, <a class="el" href="classCGAL_1_1Classification_1_1OpenCV_1_1Random__forest__classifier.html">OpenCV::Random_forest_classifier</a>, and <a class="el" href="classCGAL_1_1Classification_1_1Sum__of__weighted__features__classifier.html">Sum_of_weighted_features_classifier</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Currently, <a class="el" href="classCGAL_1_1Classification_1_1ETHZ_1_1Random__forest__classifier.html">ETHZ::Random_forest_classifier</a> is the best classifier available in CGAL and we strongly advise users to use it.</dd></dl>
<p>To perform classification based on four classifiers, please refer to <a class="el" href="index.html#Classification_classification_functions">Classification Functions</a>.</p>
<h2><a class="anchor" id="Classification_ETHZ_random_forest"></a>
ETHZ Random Forest</h2>
<p>CGAL provides <a class="el" href="classCGAL_1_1Classification_1_1ETHZ_1_1Random__forest__classifier.html">ETHZ::Random_forest_classifier</a>, a classifier based on the Random Forest Template Library developed by Stefan Walk at ETH Zurich <a class="el" href="citelist.html#CITEREF_cgal:w-erftl-14">[2]</a> (the library is distributed under the MIT license and is included with the CGAL release, the user does not have to install anything more). This classifier uses a ground truth training set to construct several decision trees that are then used to assign a label to each input item.</p>
<p>This classifier cannot be set up by hand and requires a ground truth training set. The training algorithm is fast but usually requires a high number of inliers. The training algorithm uses more memory at runtime and the configuration files are larger than those produced by <a class="el" href="classCGAL_1_1Classification_1_1Sum__of__weighted__features__classifier.html">Sum_of_weighted_features_classifier</a>, but the output quality is usually significantly better, especially in the cases where many labels are used (more than five).</p>
<p>An <a class="el" href="index.html#Classification_example_ethz_random_forest">example</a> shows how to use this classifier. For more details about the algorithm, please refer to README provided in the <a href="https://ethz.ch/content/dam/ethz/special-interest/baug/igp/photogrammetry-remote-sensing-dam/documents/sourcecode-and-datasets/Random%20Forest/rforest.zip">ETH Zurich's code archive</a>.</p>
<h3><a class="anchor" id="Classification_ETHZ_random_forest_deprecated"></a>
Deprecated IO</h3>
<p>The <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/namespaceCGAL_1_1IO.html">IO</a> functions of this classifier were changed in CGAL 5.2. Configurations generated from previous versions are not valid anymore and should be converted first as shown in the following example:</p>
<p><br />
<b>File</b> <a class="el" href="Classification_2example_deprecated_conversion_8cpp-example.html">Classification/example_deprecated_conversion.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Classification/ETHZ/Random_forest_classifier.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (argc != 3)</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Usage: "</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">" input.gz output.bin"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">  {</div><div class="line">    std::ifstream ifile (argv[1], std::ios_base::binary);</div><div class="line">    std::ofstream ofile (argv[2], std::ios_base::binary);</div><div class="line"></div><div class="line">    <a class="code" href="classCGAL_1_1Classification_1_1ETHZ_1_1Random__forest__classifier.html#a99154673a7b517e7d141e6d3678a65c8">CGAL::Classification::ETHZ::Random_forest_classifier::</a></div><div class="line"><a class="code" href="classCGAL_1_1Classification_1_1ETHZ_1_1Random__forest__classifier.html#a99154673a7b517e7d141e6d3678a65c8">      convert_deprecated_configuration_to_new_format</a>(ifile, ofile);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Classification_OpenCV_random_forest"></a>
OpenCV Random Forest</h2>
<p>The second classifier is <a class="el" href="classCGAL_1_1Classification_1_1OpenCV_1_1Random__forest__classifier.html">OpenCV::Random_forest_classifier</a>. It uses the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartyOpenCV">OpenCV</a> library, more specifically the <a href="https://docs.opencv.org/2.4/modules/ml/doc/random_trees.html">Random Trees</a> package.</p>
<p>Note that this classifier usually produces results with a lower quality than <a class="el" href="classCGAL_1_1Classification_1_1ETHZ_1_1Random__forest__classifier.html">ETHZ::Random_forest_classifier</a>. It is provided for the sake of completeness and for testing purposes, but if you are not sure what to use, we advise using the ETHZ Random Forest instead.</p>
<p>An <a class="el" href="index.html#Classification_example_opencv_random_forest">example</a> shows how to use this classifier. For more details about the algorithm, please refer to <a href="https://docs.opencv.org/2.4/modules/ml/doc/random_trees.html">the official documentation</a> of OpenCV.</p>
<h2><a class="anchor" id="Classification_sowf"></a>
Sum of Weighted Features</h2>
<p>This latest classifier defines the following attributes:</p>
<ul>
<li>a weight applied to each feature;</li>
<li>an effect applied to each pair of feature and label.</li>
</ul>
<p>For each label, the classifier computes an energy as a sum of features normalized with both their weight and the effect they have on this specific label.</p>
<p>The main advantage of this classifier is that it can be set up by hand. Nevertheless, it also embeds a training algorithm.</p>
<h3><a class="anchor" id="Classification_sowf_weights_effects"></a>
Weights and Effects</h3>
<p>Each feature is assigned a weight that measures its strength with respect to the other features.</p>
<p>Each pair of feature and label is assigned an effect that can either be:</p>
<ul>
<li><a class="el" href="classCGAL_1_1Classification_1_1Sum__of__weighted__features__classifier.html#a6aab054f8adf32f1e05b693f5caf9512a9f79d37660f7ace2f1c3a790edb4171a">FAVORING</a>: the label is favored by high values of the feature;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Sum__of__weighted__features__classifier.html#a6aab054f8adf32f1e05b693f5caf9512aafe5766bc7d9202e9e856491e311d954">NEUTRAL</a>: the label is not affected by the feature;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Sum__of__weighted__features__classifier.html#a6aab054f8adf32f1e05b693f5caf9512a2dd2e92685af72202d0875fb898f391e">PENALIZING</a>: the label is favored by low values of the feature.</li>
</ul>
<p>For example, <em>vegetation</em> is expected to have a high distance to plane and have a color close to green (if colors are available); <em>facades</em> have a low distance to plane and a low verticality; etc.</p>
<p>Let \(x=(x_i)_{i=1..N}\) be a potential classification result with \(N\) the number of input items and \(x_i\) the class of the \(i^{th}\) item (for example: <em>vegetation</em>, <em>ground</em>, etc.). Let \(f_j(i)\) be the raw value of the \(j^{th}\) feature at the \(i^{th}\) item and \(w_j\) be the weight of this feature. We define the normalized value \(F_j(x_i) \in [0:1]\) of the \(j^{th}\) feature at the \(i^{th}\) item as follows:</p>
<p class="formulaDsp">
\begin{eqnarray*} F_j(x_i) = &amp; (1 - \min(\max(0,\frac{f_j(i)}{w_j}), 1)) &amp; \mbox{if } f_j \mbox{ favors } x_i \\ &amp; 0.5 &amp; \mbox{if } f_j \mbox{ is neutral for } x_i \\ &amp; \min(\max(0,\frac{f_j(i)}{w_j}), 1) &amp; \mbox{if } f_j \mbox{ penalizes } x_i \end{eqnarray*}
</p>
<p>The itemwise energy measures the coherence of the label \(x_i\) at the \(i^{th}\) item and is defined as:</p>
<p class="formulaDsp">
\[ E_{di}(x_i) = \sum_{j = 1..N_f} F_j(x_i) \]
</p>
<p>The following code snippet shows how to define the weights and effects of features and labels:</p>
<div class="fragment"><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Setting weights"</span> &lt;&lt; std::endl;</div><div class="line">  Classifier classifier (labels, features);</div><div class="line">  classifier.set_weight (distance_to_plane, 6.75e-2f);</div><div class="line">  classifier.set_weight (dispersion, 5.45e-1f);</div><div class="line">  classifier.set_weight (elevation, 1.47e1f);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Setting effects"</span> &lt;&lt; std::endl;</div><div class="line">  classifier.set_effect (ground, distance_to_plane, Classifier::NEUTRAL);</div><div class="line">  classifier.set_effect (ground, dispersion, Classifier::NEUTRAL);</div><div class="line">  classifier.set_effect (ground, elevation, Classifier::PENALIZING);</div><div class="line"></div><div class="line">  classifier.set_effect (vegetation, distance_to_plane,  Classifier::FAVORING);</div><div class="line">  classifier.set_effect (vegetation, dispersion, Classifier::FAVORING);</div><div class="line">  classifier.set_effect (vegetation, elevation, Classifier::NEUTRAL);</div><div class="line"></div><div class="line">  classifier.set_effect (roof, distance_to_plane,  Classifier::NEUTRAL);</div><div class="line">  classifier.set_effect (roof, dispersion, Classifier::NEUTRAL);</div><div class="line">  classifier.set_effect (roof, elevation, Classifier::FAVORING);</div><div class="line"></div></div><!-- fragment --> <h3><a class="anchor" id="Classification_sowf_training"></a>
Training</h3>
<p>Each feature has a specific weight and each pair of feature-label has a specific effect. This means that the number of parameters to set up can quickly explode: if 6 features are used to classify between 4 labels, 30 parameters have to be set up (6 weights + 6x4 feature-label relationships).</p>
<p>Though it is possible to set them up one by one, CGAL also provides a method <a class="el" href="classCGAL_1_1Classification_1_1Sum__of__weighted__features__classifier.html#a11bcf5a1416f0fd2c4855af9c73797cc">train()</a> that requires a small set of ground truth items provided by users. More specifically, users must provide, for each label they want to classify, a set of known inliers among the input data set (for example, selecting one roof, one tree and one section of the ground). The training algorithm works as follows:</p>
<ul>
<li>for each feature, a range of weights is tested: the effect each feature has on each label is estimated. For a given weight, if a feature has the same effect on each label, it is non-relevant for classification. The range of weights such that the feature is relevant is estimated;</li>
<li>for each feature, uniformly picked weight values are tested and their effects are estimated;</li>
<li>each inlier provided by the user is classified using this set of weights and effects;</li>
<li>the mean intersection-over-union (see <a class="el" href="index.html#Classification_evaluation">Evaluation</a>) is used to evaluate the quality of this set of weights and effects;</li>
<li>the same mechanism is repeated until all features' ranges have been tested. Weights are only changed one by one, the other ones are kept to the values that gave the latest best score.</li>
</ul>
<p>This usually converges to a satisfying solution (see Figure <a class="el" href="index.html#fig__Classification_trainer_fig">Figure 84.5</a>). The number of trials is user defined, set to 300 by default. Using at least 10 times the number of features is advised (for example, at least 300 iterations if 30 features are used). If the solution is not satisfying, more inliers can be selected, for example, in a region that the user identifies as misclassified with the current configuration. The training algorithm keeps, as initialization, the best weights found at the previous round and carries on trying new weights by taking new inliers into account.</p>
<p><a class="anchor" id="fig__Classification_trainer_fig"></a></p><div class="image">
<img src="classif_training.png" alt="classif_training.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Classification_trainer_fig">Figure 84.5</a> Example of evolution of the mean intersection-over-union. The purple curve is the score computed at the current iteration, green curve is the best score found so far.  </div> <br /> 
<h3><a class="anchor" id="Classification_sowf_result"></a>
Result</h3>
<p>Figure <a class="el" href="index.html#fig__Classification_sowf_result_fig">Figure 84.6</a> shows an example of output on a defect-laden point set. The accuracy on this example is 0.97 with a mean intersection-over-union of 0.85 (see section <a class="el" href="index.html#Classification_evaluation">Evaluation</a>).</p>
<p><a class="anchor" id="fig__Classification_sowf_result_fig"></a></p><div class="image">
<img src="noise_outliers.png" alt="noise_outliers.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Classification_sowf_result_fig">Figure 84.6</a> Example of classification on a point set with medium noise and outliers (left: input, right: output). <em>Ground</em> is orange, <em>roofs</em> are pink, <em>vegetation</em> is green. Outliers are classified with an additional label <em>outlier</em> in black.  </div> <br /> 
<h1><a class="anchor" id="Classification_classification_functions"></a>
Classification Functions</h1>
<p>Classification is performed by minimizing an energy over the input data set that may include regularization. CGAL provides three different methods for classification, ranging from high speed / low quality to low speed / high quality:</p>
<ul>
<li><code><a class="el" href="group__PkgClassificationMain.html#gaea3ed82bf801bc9fbd00b63da48df73e" title="runs the classification algorithm without any regularization. ">CGAL::Classification::classify()</a></code></li>
<li><code><a class="el" href="group__PkgClassificationMain.html#ga266e487bd1ab9dd4036e3fbd2ec4e8a0" title="runs the classification algorithm with a local smoothing. ">CGAL::Classification::classify_with_local_smoothing()</a></code></li>
<li><code><a class="el" href="group__PkgClassificationMain.html#ga2a4c1b0816b81b628dc9023e104449eb" title="runs the classification algorithm with a global regularization based on a graph cut. ">CGAL::Classification::classify_with_graphcut()</a></code></li>
</ul>
<p>On a point set of 3 millions of points, the first method takes about 4 seconds, the second about 40 seconds and the third about 2 minutes.</p>
<p><a class="anchor" id="fig__Classification_image"></a></p><div class="image">
<img src="classif.png" alt="classif.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Classification_image">Figure 84.7</a> Top-Left: input point set. Top-Right: raw output classification represented by a set of colors (<em>ground</em> is orange, <em>facades</em> are blue, <em>roofs</em> are pink and <em>vegetation</em> is green). Bottom-Left: output classification using local smoothing. Bottom-Right: output classification using graphcut.  </div> <br /> 
<p>Mathematical details are provided hereafter.</p>
<h2><a class="anchor" id="Classification_classify"></a>
Raw Classification</h2>
<ul>
<li><code><a class="el" href="group__PkgClassificationMain.html#gaea3ed82bf801bc9fbd00b63da48df73e" title="runs the classification algorithm without any regularization. ">CGAL::Classification::classify()</a></code>: this is the fastest method that provides acceptable but usually noisy results (see Figure <a class="el" href="index.html#fig__Classification_image">Figure 84.7</a>, top-right).</li>
</ul>
<p>Let \(x=(x_i)_{i=1..N}\) be a potential classification result with \(N\) the number of input items and \(x_i\) the label of the \(i^{th}\) item (for example: <em>vegetation</em>, <em>ground</em>, etc.). The classification is performed by minimizing the following energy:</p>
<p class="formulaDsp">
\[ E(x) = \sum_{i = 1..N} E_{di}(x_i) \]
</p>
<p>This energy is a sum of itemwise energies provided by the classifier and involves no regularization.</p>
<p>The following snippet shows how to classify points based on a label set and a classifier. The result is stored in <code>label_indices</code>, following the same order as the input set and providing for each point the index (in the label set) of its assigned label.</p>
<div class="fragment"><div class="line">  std::vector&lt;int&gt; label_indices (pts.size(), -1);</div><div class="line"></div><div class="line">  CGAL::Real_timer t;</div><div class="line">  t.start();</div><div class="line">  Classification::classify&lt;CGAL::Parallel_if_available_tag&gt; (pts, labels, classifier, label_indices);</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Raw classification performed in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div></div><!-- fragment --> <h2><a class="anchor" id="Classification_smoothing"></a>
Local Regularization</h2>
<ul>
<li><p class="startli"><code><a class="el" href="group__PkgClassificationMain.html#ga266e487bd1ab9dd4036e3fbd2ec4e8a0" title="runs the classification algorithm with a local smoothing. ">CGAL::Classification::classify_with_local_smoothing()</a></code>: this method is a tradeoff between quality and efficiency (see Figure <a class="el" href="index.html#fig__Classification_image">Figure 84.7</a>, bottom-left). The minimized energy is defined as follows:</p>
<p class="formulaDsp">
\[ E(x) = \sum_{i = 1..N} E_{si}(x_i) \]
</p>
</li>
</ul>
<p>The energy \(E_{si}(x_i)\) is defined on a small local neighborhood \(Nb(i)\) of the \(i^{th}\) item (including itself):</p>
<p class="formulaDsp">
\[ E_{si}(x_i) = \frac{\sum_{k \in Nb(i)} E_{di}(x_k)}{\left| Nb(i) \right|} \]
</p>
<p>This allows to eliminate local noisy variations of assigned labels. Increasing the size of the neighborhood increases the noise reduction at the cost of higher computation times.</p>
<p>The following snippet shows how to classify points using local smoothing by providing a model of <code><a class="el" href="classCGAL_1_1Classification_1_1NeighborQuery.html" title="Concept describing a neighbor query used for classification. ">CGAL::Classification::NeighborQuery</a></code>.</p>
<div class="fragment"><div class="line">  t.start();</div><div class="line">  Classification::classify_with_local_smoothing&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (pts, Pmap(), labels, classifier,</div><div class="line">     neighborhood.sphere_neighbor_query(radius_neighbors),</div><div class="line">     label_indices);</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classification with local smoothing performed in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div></div><!-- fragment --> <h2><a class="anchor" id="Classification_graphcut"></a>
Global Regularization (Graph Cut)</h2>
<ul>
<li><p class="startli"><code><a class="el" href="group__PkgClassificationMain.html#ga2a4c1b0816b81b628dc9023e104449eb" title="runs the classification algorithm with a global regularization based on a graph cut. ">CGAL::Classification::classify_with_graphcut()</a></code>: this method offers the best quality but requires longer computation time (see Figure <a class="el" href="index.html#fig__Classification_image">Figure 84.7</a>, bottom-right). The total energy that is minimized is the sum of the partial data term \(E_{di}(x_i)\) and of a pairwise interaction energy defined by the standard Potts model <a class="el" href="citelist.html#CITEREF_cgal:l-mrfmi-09">[5]</a> :</p>
<p class="formulaDsp">
\[ E(x) = \sum_{i = 1..N} E_{di}(x_i) + \gamma \sum_{i \sim j} \mathbf{1}_{x_i \neq x_j} \]
</p>
</li>
</ul>
<p>where \(\gamma&gt;0\) is the parameter of the Potts model that quantifies the strengh of the regularization, \(i \sim j\) represents the pairs of neighboring items and \(\mathbf{1}_{\{.\}}\) the characteristic function.</p>
<p>A <em>graph cut</em> based algorithm (alpha expansion) is used to quickly reach an approximate solution close to the global optimum of this energy.</p>
<p>This method allows to consistently segment the input data set in piecewise constant parts and to correct large wrongly classified clusters. Increasing \(\gamma\) produces more regular result with a constant computation time.</p>
<p>To speed up computations, the input domain can be subdivided into smaller subsets such that several smaller graph cuts are applied instead of a big one. The computation of these smaller graph cuts can be done in parallel. Increasing the number of subsets allows for faster computation times but can also reduce the quality of the results.</p>
<p>The following snippet shows how to classify points using a graph cut regularization providing a model of <code><a class="el" href="classCGAL_1_1Classification_1_1NeighborQuery.html" title="Concept describing a neighbor query used for classification. ">CGAL::Classification::NeighborQuery</a></code>, a strengh parameter \(\gamma\) and a number of subdivisions.</p>
<div class="fragment"><div class="line">  t.start();</div><div class="line">  Classification::classify_with_graphcut&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (pts, Pmap(), labels, classifier,</div><div class="line">     neighborhood.k_neighbor_query(12),</div><div class="line">     0.2f, 4, label_indices);</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classification with graphcut performed in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div></div><!-- fragment --> <h1><a class="anchor" id="Classification_evaluation"></a>
Evaluation</h1>
<p>The class <a class="el" href="classCGAL_1_1Classification_1_1Evaluation.html">Evaluation</a> allows users to evaluate the reliability of the classification with respect to a provided ground truth. The following measurements are available:</p>
<ul>
<li><a class="el" href="classCGAL_1_1Classification_1_1Evaluation.html#a040d137ec34590b2e2364d42264a901e">precision()</a> computes, for one label, the ratio of true positives over the total number of detected positives;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Evaluation.html#a40cd95adcd26d7b16cd6daaf56dfba27">recall()</a> computes, for one label, the ratio of true positives over the total number of provided inliers of this label;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Evaluation.html#a8de98452ad8bafc018b18d75e1e55a47">f1_score()</a> is the harmonic mean of precision and recall;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Evaluation.html#a2d4513d5a5256fda156d5b4fd1ddfbe7">intersection_over_union()</a> computes the ratio of true positives over the union of the detected positives and of the provided inliers;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Evaluation.html#ac2c9a217607e34f38541d10adc77b336">accuracy()</a> computes the ratio of all true positives over the total number of provided inliers;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Evaluation.html#aca8eaa6bf226fc44a3740b376acce804">mean_f1_score()</a>;</li>
<li><a class="el" href="classCGAL_1_1Classification_1_1Evaluation.html#aae3761d28e2b0585c8715edbff790c14">mean_intersection_over_union()</a>.</li>
</ul>
<p>All these values range from 0 (poor quality) to 1 (perfect quality).</p>
<h1><a class="anchor" id="Classification_examples"></a>
Full Examples</h1>
<h2><a class="anchor" id="Classification_example_general"></a>
Simple Point Set Classification</h2>
<p>The following example:</p>
<ul>
<li>reads an input file (LIDAR point set in PLY format);</li>
<li>computes useful structures from this input;</li>
<li>computes features from the input and the precomputed structures;</li>
<li>defines 3 labels (<em>vegetation</em>, <em>ground</em> and <em>roof</em>);</li>
<li>sets up the classification classifier <a class="el" href="classCGAL_1_1Classification_1_1Sum__of__weighted__features__classifier.html">Sum_of_weighted_features_classifier</a>;</li>
<li>classifies the point set with the 3 different methods (this is for the sake of the example: each method overwrites the previous result, users should only call one of the methods);</li>
<li>saves the result in a colored PLY format.</li>
</ul>
<p><br />
<b>File</b> <a class="el" href="Classification_2example_classification_8cpp-example.html">Classification/example_classification.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#if defined (_MSC_VER) &amp;&amp; !defined (_WIN64)</span></div><div class="line"><span class="preprocessor">#pragma warning(disable:4244) // boost::number_distance::distance()</span></div><div class="line">                              <span class="comment">// converts 64 to 32 bits integers</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Classification.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/bounding_box.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/tags.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_ply_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a> Concurrency_tag;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::Iso_cuboid_3</a> Iso_cuboid_3;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> CGAL::Identity_property_map&lt;Point&gt; Pmap;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Classification = <a class="code" href="namespaceCGAL_1_1Classification.html">CGAL::Classification</a>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Sum_of_weighted_features_classifier Classifier;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Planimetric_grid&lt;Kernel, Point_range, Pmap&gt;             Planimetric_grid;</div><div class="line"><span class="keyword">typedef</span> Classification::Point_set_neighborhood&lt;Kernel, Point_range, Pmap&gt;       Neighborhood;</div><div class="line"><span class="keyword">typedef</span> Classification::Local_eigen_analysis                                    Local_eigen_analysis;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Label_handle                                            Label_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_handle                                          Feature_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Label_set                                               Label_set;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_set                                             Feature_set;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Feature::Distance_to_plane&lt;Point_range, Pmap&gt;           Distance_to_plane;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature::Elevation&lt;Kernel, Point_range, Pmap&gt;           Elevation;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature::Vertical_dispersion&lt;Kernel, Point_range, Pmap&gt; Dispersion;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/b9.ply"</span>);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Reading input"</span> &lt;&lt; std::endl;</div><div class="line">  std::vector&lt;Point&gt; pts;</div><div class="line">  <span class="keywordflow">if</span> (!(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(filename, std::back_inserter(pts),</div><div class="line">                              <span class="comment">// the PLY reader expects a binary file by default</span></div><div class="line">                              CGAL::parameters::use_binary_mode(<span class="keyword">false</span>))))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read "</span> &lt;&lt; filename &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">float</span> grid_resolution = 0.34f;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> number_of_neighbors = 6;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Computing useful structures"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  Iso_cuboid_3 bbox = CGAL::bounding_box (pts.begin(), pts.end());</div><div class="line"></div><div class="line">  Planimetric_grid grid (pts, Pmap(), bbox, grid_resolution);</div><div class="line">  Neighborhood neighborhood (pts, Pmap());</div><div class="line">  Local_eigen_analysis eigen</div><div class="line">    = Local_eigen_analysis::create_from_point_set</div><div class="line">    (pts, Pmap(), neighborhood.k_neighbor_query(number_of_neighbors));</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">float</span> radius_neighbors = 1.7f;</div><div class="line">  <span class="keywordtype">float</span> radius_dtm = 15.0f;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Computing features"</span> &lt;&lt; std::endl;</div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  features.begin_parallel_additions(); <span class="comment">// No effect in sequential mode</span></div><div class="line"></div><div class="line">  Feature_handle distance_to_plane = features.add&lt;Distance_to_plane&gt; (pts, Pmap(), eigen);</div><div class="line">  Feature_handle dispersion = features.add&lt;Dispersion&gt; (pts, Pmap(), grid,</div><div class="line">                                                        radius_neighbors);</div><div class="line">  Feature_handle elevation = features.add&lt;Elevation&gt; (pts, Pmap(), grid,</div><div class="line">                                                      radius_dtm);</div><div class="line"></div><div class="line">  features.end_parallel_additions(); <span class="comment">// No effect in sequential mode</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  Label_set labels;</div><div class="line"></div><div class="line">  <span class="comment">// Init name only</span></div><div class="line">  Label_handle ground = labels.add (<span class="stringliteral">"ground"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Init name and color</span></div><div class="line">  Label_handle vegetation = labels.add (<span class="stringliteral">"vegetation"</span>, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a>(0,255,0));</div><div class="line"></div><div class="line">  <span class="comment">// Init name, Color and standard index (here, ASPRS building index)</span></div><div class="line">  Label_handle roof = labels.add (<span class="stringliteral">"roof"</span>, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a> (255, 0, 0), 6);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Setting weights"</span> &lt;&lt; std::endl;</div><div class="line">  Classifier classifier (labels, features);</div><div class="line">  classifier.set_weight (distance_to_plane, 6.75e-2f);</div><div class="line">  classifier.set_weight (dispersion, 5.45e-1f);</div><div class="line">  classifier.set_weight (elevation, 1.47e1f);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Setting effects"</span> &lt;&lt; std::endl;</div><div class="line">  classifier.set_effect (ground, distance_to_plane, Classifier::NEUTRAL);</div><div class="line">  classifier.set_effect (ground, dispersion, Classifier::NEUTRAL);</div><div class="line">  classifier.set_effect (ground, elevation, Classifier::PENALIZING);</div><div class="line"></div><div class="line">  classifier.set_effect (vegetation, distance_to_plane,  Classifier::FAVORING);</div><div class="line">  classifier.set_effect (vegetation, dispersion, Classifier::FAVORING);</div><div class="line">  classifier.set_effect (vegetation, elevation, Classifier::NEUTRAL);</div><div class="line"></div><div class="line">  classifier.set_effect (roof, distance_to_plane,  Classifier::NEUTRAL);</div><div class="line">  classifier.set_effect (roof, dispersion, Classifier::NEUTRAL);</div><div class="line">  classifier.set_effect (roof, elevation, Classifier::FAVORING);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Run classification</span></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classifying"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::vector&lt;int&gt; label_indices (pts.size(), -1);</div><div class="line"></div><div class="line">  CGAL::Real_timer t;</div><div class="line">  t.start();</div><div class="line">  Classification::classify&lt;CGAL::Parallel_if_available_tag&gt; (pts, labels, classifier, label_indices);</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Raw classification performed in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div><div class="line"></div><div class="line">  t.start();</div><div class="line">  Classification::classify_with_local_smoothing&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (pts, Pmap(), labels, classifier,</div><div class="line">     neighborhood.sphere_neighbor_query(radius_neighbors),</div><div class="line">     label_indices);</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classification with local smoothing performed in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div><div class="line"></div><div class="line">  t.start();</div><div class="line">  Classification::classify_with_graphcut&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (pts, Pmap(), labels, classifier,</div><div class="line">     neighborhood.k_neighbor_query(12),</div><div class="line">     0.2f, 4, label_indices);</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classification with graphcut performed in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save the output in a colored PLY format</span></div><div class="line"></div><div class="line">  std::vector&lt;unsigned char&gt; red, green, blue;</div><div class="line">  red.reserve(pts.size());</div><div class="line">  green.reserve(pts.size());</div><div class="line">  blue.reserve(pts.size());</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; pts.size(); ++ i)</div><div class="line">  {</div><div class="line">    Label_handle label = labels[std::size_t(label_indices[i])];</div><div class="line">    <span class="keywordtype">unsigned</span> r = 0, g = 0, b = 0;</div><div class="line">    <span class="keywordflow">if</span> (label == ground)</div><div class="line">    {</div><div class="line">      r = 245; g = 180; b = 0;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (label == vegetation)</div><div class="line">    {</div><div class="line">      r = 0; g = 255; b = 27;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (label == roof)</div><div class="line">    {</div><div class="line">      r = 255; g = 0; b = 170;</div><div class="line">    }</div><div class="line">    red.push_back(r);</div><div class="line">    green.push_back(g);</div><div class="line">    blue.push_back(b);</div><div class="line">  }</div><div class="line"></div><div class="line">  std::ofstream f (<span class="stringliteral">"classification.ply"</span>);</div><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3IOPly.html#gac1fd90a9d5266e631c68cb31bfe31516">CGAL::IO::write_PLY_with_properties</a></div><div class="line">    (f, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL.html#a266177f3e138c748f9906f7abb76320b">CGAL::make_range</a> (boost::counting_iterator&lt;std::size_t&gt;(0),</div><div class="line">                          boost::counting_iterator&lt;std::size_t&gt;(pts.size())),</div><div class="line">     <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3IOPly.html#ga241c6df9d93e26ec7254ef6366cb7e5b">CGAL::make_ply_point_writer</a> (CGAL::make_property_map(pts)),</div><div class="line">     std::make_pair(CGAL::make_property_map(red), CGAL::PLY_property&lt;unsigned char&gt;(<span class="stringliteral">"red"</span>)),</div><div class="line">     std::make_pair(CGAL::make_property_map(green), CGAL::PLY_property&lt;unsigned char&gt;(<span class="stringliteral">"green"</span>)),</div><div class="line">     std::make_pair(CGAL::make_property_map(blue), CGAL::PLY_property&lt;unsigned char&gt;(<span class="stringliteral">"blue"</span>)));</div><div class="line"></div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"All done"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Classification_example_feeature"></a>
Defining a Custom Feature</h2>
<p>The following example shows how to define a custom feature and how to integrate it in the CGAL classification framework.</p>
<p><br />
<b>File</b> <a class="el" href="Classification_2example_feature_8cpp-example.html">Classification/example_feature.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#if defined (_MSC_VER) &amp;&amp; !defined (_WIN64)</span></div><div class="line"><span class="preprocessor">#pragma warning(disable:4244) // boost::number_distance::distance()</span></div><div class="line">                              <span class="comment">// converts 64 to 32 bits integers</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Classification.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::Iso_cuboid_3</a> Iso_cuboid_3;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> CGAL::Identity_property_map&lt;Point&gt; Pmap;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Classification = <a class="code" href="namespaceCGAL_1_1Classification.html">CGAL::Classification</a>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Sum_of_weighted_features_classifier                      Classifier;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Point_set_neighborhood&lt;Kernel, Point_range, Pmap&gt;       Neighborhood;</div><div class="line"><span class="keyword">typedef</span> Classification::Local_eigen_analysis                                    Local_eigen_analysis;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Label_handle                                            Label_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_handle                                          Feature_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Label_set                                               Label_set;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_set                                             Feature_set;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Feature::Verticality&lt;Kernel&gt;                            Verticality;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// User-defined feature that identifies a specific area of the 3D</span></div><div class="line"><span class="comment">// space. This feature takes value 1 for points that lie inside the</span></div><div class="line"><span class="comment">// area and 0 for the others.</span></div><div class="line"><span class="keyword">class </span>My_feature : <span class="keyword">public</span> <a class="code" href="classCGAL_1_1Classification_1_1Feature__base.html">CGAL::Classification::Feature_base</a></div><div class="line">{</div><div class="line">  <span class="keyword">const</span> Point_range&amp; range;</div><div class="line">  <span class="keywordtype">double</span> xmin, xmax, ymin, ymax;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  My_feature (<span class="keyword">const</span> Point_range&amp; range,</div><div class="line">              <span class="keywordtype">double</span> xmin, <span class="keywordtype">double</span> xmax, <span class="keywordtype">double</span> ymin, <span class="keywordtype">double</span> ymax)</div><div class="line">    : range (range), xmin(xmin), xmax(xmax), ymin(ymin), ymax(ymax)</div><div class="line">  {</div><div class="line">    this-&gt;set_name (<span class="stringliteral">"my_feature"</span>);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">float</span> value (std::size_t pt_index)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (xmin &lt; range[pt_index].x() &amp;&amp; range[pt_index].x() &lt; xmax &amp;&amp;</div><div class="line">        ymin &lt; range[pt_index].y() &amp;&amp; range[pt_index].y() &lt; ymax)</div><div class="line">      <span class="keywordflow">return</span> 1.f;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <span class="keywordflow">return</span> 0.f;</div><div class="line">  }</div><div class="line"></div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::string filename (argc &gt; 1 ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/b9.ply"</span>));</div><div class="line">  std::vector&lt;Point&gt; pts;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Reading input"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">if</span> (!(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(filename, std::back_inserter(pts),</div><div class="line">                              <span class="comment">// the PLY reader expects a binary file by default</span></div><div class="line">                              CGAL::parameters::use_binary_mode(<span class="keyword">false</span>))))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read "</span> &lt;&lt; filename &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  Neighborhood neighborhood (pts, Pmap());</div><div class="line">  Local_eigen_analysis eigen</div><div class="line">    = Local_eigen_analysis::create_from_point_set (pts, Pmap(), neighborhood.k_neighbor_query(6));</div><div class="line"></div><div class="line">  Label_set labels;</div><div class="line">  Label_handle a = labels.add (<span class="stringliteral">"label_A"</span>);</div><div class="line">  Label_handle b = labels.add (<span class="stringliteral">"label_B"</span>);</div><div class="line"></div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Computing features"</span> &lt;&lt; std::endl;</div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  <span class="comment">// Feature that identifies points whose x coordinate is between -20</span></div><div class="line">  <span class="comment">// and 20 and whose y coordinate is between -15 and 15</span></div><div class="line">  Feature_handle my_feature = features.add&lt;My_feature&gt; (pts, -20., 20., -15., 15.);</div><div class="line"></div><div class="line"></div><div class="line">  Feature_handle verticality = features.add&lt;Verticality&gt; (pts, eigen);</div><div class="line"></div><div class="line">  Classifier classifier (labels, features);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Setting weights"</span> &lt;&lt; std::endl;</div><div class="line">  classifier.set_weight(verticality, 0.5);</div><div class="line">  classifier.set_weight(my_feature, 0.25);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Setting up labels"</span> &lt;&lt; std::endl;</div><div class="line">  classifier.set_effect (a, verticality, Classifier::FAVORING);</div><div class="line">  classifier.set_effect (a, my_feature, Classifier::FAVORING);</div><div class="line">  classifier.set_effect (b, verticality, Classifier::PENALIZING);</div><div class="line">  classifier.set_effect (b, my_feature, Classifier::PENALIZING);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classifying"</span> &lt;&lt; std::endl;</div><div class="line">  std::vector&lt;int&gt; label_indices(pts.size(), -1);</div><div class="line">  Classification::classify_with_graphcut&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (pts, Pmap(), labels, classifier,</div><div class="line">     neighborhood.k_neighbor_query(12),</div><div class="line">     0.5, 1, label_indices);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"All done"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Classification_example_training"></a>
Feature Generation and Training</h2>
<p>The following example:</p>
<ul>
<li>reads a point set with a training set (embedded as a PLY feature <em>label</em>);</li>
<li>automatically generates features on 5 scales;</li>
<li>trains the classifier <a class="el" href="classCGAL_1_1Classification_1_1Sum__of__weighted__features__classifier.html">Sum_of_weighted_features_classifier</a> using 800 trials;</li>
<li>runs the algorithm using the graphcut regularization;</li>
<li>prints some evaluation measurements;</li>
<li>saves the configuration of the classifier for further use.</li>
</ul>
<p><br />
<b>File</b> <a class="el" href="Classification_2example_generation_and_training_8cpp-example.html">Classification/example_generation_and_training.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#if defined (_MSC_VER) &amp;&amp; !defined (_WIN64)</span></div><div class="line"><span class="preprocessor">#pragma warning(disable:4244) // boost::number_distance::distance()</span></div><div class="line">                              <span class="comment">// converts 64 to 32 bits integers</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Classification.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3/IO.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> CGAL::Point_set_3&lt;Point&gt; Point_set;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::Iso_cuboid_3</a> Iso_cuboid_3;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Point_set::Point_map Pmap;</div><div class="line"><span class="keyword">typedef</span> Point_set::Property_map&lt;int&gt; Imap;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Classification = <a class="code" href="namespaceCGAL_1_1Classification.html">CGAL::Classification</a>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Label_handle                                            Label_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_handle                                          Feature_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Label_set                                               Label_set;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_set                                             Feature_set;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Sum_of_weighted_features_classifier                     Classifier;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Point_set_feature_generator&lt;Kernel, Point_set, Pmap&gt;    Feature_generator;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::string filename (argc &gt; 1 ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/b9_training.ply"</span>));</div><div class="line">  std::ifstream in (filename.c_str(), std::ios::binary);</div><div class="line">  Point_set pts;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Reading input"</span> &lt;&lt; std::endl;</div><div class="line">  in &gt;&gt; pts;</div><div class="line"></div><div class="line">  Imap label_map;</div><div class="line">  <span class="keywordtype">bool</span> lm_found = <span class="keyword">false</span>;</div><div class="line">  std::tie (label_map, lm_found) = pts.property_map&lt;<span class="keywordtype">int</span>&gt; (<span class="stringliteral">"label"</span>);</div><div class="line">  <span class="keywordflow">if</span> (!lm_found)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: \"label\" property not found in input file."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Generating features"</span> &lt;&lt; std::endl;</div><div class="line">  CGAL::Real_timer t;</div><div class="line">  t.start();</div><div class="line"></div><div class="line"></div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  std::size_t number_of_scales = 5;</div><div class="line">  Feature_generator generator (pts, pts.point_map(), number_of_scales);</div><div class="line"></div><div class="line">  features.begin_parallel_additions();</div><div class="line">  generator.generate_point_based_features (features);</div><div class="line">  features.end_parallel_additions();</div><div class="line"></div><div class="line"></div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; features.size() &lt;&lt; <span class="stringliteral">" feature(s) generated in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  Label_set labels = { <span class="stringliteral">"ground"</span>, <span class="stringliteral">"vegetation"</span>, <span class="stringliteral">"roof"</span> };</div><div class="line"></div><div class="line">  Classifier classifier (labels, features);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Training"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div><div class="line">  t.start();</div><div class="line">  classifier.train&lt;<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a>&gt; (pts.range(label_map), 800);</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  t.reset();</div><div class="line">  t.start();</div><div class="line">  std::vector&lt;int&gt; label_indices(pts.size(), -1);</div><div class="line">  Classification::classify_with_graphcut&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (pts, pts.point_map(), labels, classifier,</div><div class="line">     generator.neighborhood().k_neighbor_query(12),</div><div class="line">     0.2f, 10, label_indices);</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classification with graphcut done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Precision, recall, F1 scores and IoU:"</span> &lt;&lt; std::endl;</div><div class="line">  Classification::Evaluation evaluation (labels, pts.range(label_map), label_indices);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (Label_handle l : labels)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">" * "</span> &lt;&lt; l-&gt;name() &lt;&lt; <span class="stringliteral">": "</span></div><div class="line">              &lt;&lt; evaluation.precision(l) &lt;&lt; <span class="stringliteral">" ; "</span></div><div class="line">              &lt;&lt; evaluation.recall(l) &lt;&lt; <span class="stringliteral">" ; "</span></div><div class="line">              &lt;&lt; evaluation.f1_score(l) &lt;&lt; <span class="stringliteral">" ; "</span></div><div class="line">              &lt;&lt; evaluation.intersection_over_union(l) &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Accuracy = "</span> &lt;&lt; evaluation.accuracy() &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">"Mean F1 score = "</span> &lt;&lt; evaluation.mean_f1_score() &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">"Mean IoU = "</span> &lt;&lt; evaluation.mean_intersection_over_union() &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">  std::ofstream fconfig (<span class="stringliteral">"config.xml"</span>);</div><div class="line">  classifier.save_configuration (fconfig);</div><div class="line">  fconfig.close();</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"All done"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Classification_example_ethz_random_forest"></a>
ETHZ Random Forest</h2>
<p>The following example shows how to use the classifier <a class="el" href="classCGAL_1_1Classification_1_1ETHZ_1_1Random__forest__classifier.html">ETHZ::Random_forest_classifier</a> using an input training set.</p>
<p><br />
<b>File</b> <a class="el" href="Classification_2example_ethz_random_forest_8cpp-example.html">Classification/example_ethz_random_forest.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#if defined (_MSC_VER) &amp;&amp; !defined (_WIN64)</span></div><div class="line"><span class="preprocessor">#pragma warning(disable:4244) // boost::number_distance::distance()</span></div><div class="line">                              <span class="comment">// converts 64 to 32 bits integers</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Classification.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3/IO.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> CGAL::Point_set_3&lt;Point&gt; Point_set;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::Iso_cuboid_3</a> Iso_cuboid_3;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Point_set::Point_map Pmap;</div><div class="line"><span class="keyword">typedef</span> Point_set::Property_map&lt;int&gt; Imap;</div><div class="line"><span class="keyword">typedef</span> Point_set::Property_map&lt;unsigned char&gt; UCmap;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Classification = <a class="code" href="namespaceCGAL_1_1Classification.html">CGAL::Classification</a>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Label_handle                                            Label_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_handle                                          Feature_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Label_set                                               Label_set;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_set                                             Feature_set;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Point_set_feature_generator&lt;Kernel, Point_set, Pmap&gt;    Feature_generator;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::string filename = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/b9_training.ply"</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1)</div><div class="line">    filename = argv[1];</div><div class="line"></div><div class="line">  std::ifstream in (filename.c_str(), std::ios::binary);</div><div class="line">  Point_set pts;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Reading input"</span> &lt;&lt; std::endl;</div><div class="line">  in &gt;&gt; pts;</div><div class="line"></div><div class="line">  Imap label_map;</div><div class="line">  <span class="keywordtype">bool</span> lm_found = <span class="keyword">false</span>;</div><div class="line">  std::tie (label_map, lm_found) = pts.property_map&lt;<span class="keywordtype">int</span>&gt; (<span class="stringliteral">"label"</span>);</div><div class="line">  <span class="keywordflow">if</span> (!lm_found)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: \"label\" property not found in input file."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Generating features"</span> &lt;&lt; std::endl;</div><div class="line">  CGAL::Real_timer t;</div><div class="line">  t.start();</div><div class="line">  Feature_generator generator (pts, pts.point_map(),</div><div class="line">                               5);  <span class="comment">// using 5 scales</span></div><div class="line"></div><div class="line">  features.begin_parallel_additions();</div><div class="line">  generator.generate_point_based_features (features);</div><div class="line">  features.end_parallel_additions();</div><div class="line"></div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Add labels</span></div><div class="line">  Label_set labels;</div><div class="line">  Label_handle ground = labels.add (<span class="stringliteral">"ground"</span>);</div><div class="line">  Label_handle vegetation = labels.add (<span class="stringliteral">"vegetation"</span>);</div><div class="line">  Label_handle roof = labels.add (<span class="stringliteral">"roof"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Check if ground truth is valid for this label set</span></div><div class="line">  <span class="keywordflow">if</span> (!labels.is_valid_ground_truth (pts.range(label_map), <span class="keyword">true</span>))</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line"></div><div class="line">  std::vector&lt;int&gt; label_indices(pts.size(), -1);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Using ETHZ Random Forest Classifier"</span> &lt;&lt; std::endl;</div><div class="line">  Classification::ETHZ::Random_forest_classifier classifier (labels, features);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Training"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div><div class="line">  t.start();</div><div class="line">  classifier.train (pts.range(label_map));</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  t.reset();</div><div class="line">  t.start();</div><div class="line">  Classification::classify_with_graphcut&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (pts, pts.point_map(), labels, classifier,</div><div class="line">     generator.neighborhood().k_neighbor_query(12),</div><div class="line">     0.2f, 1, label_indices);</div><div class="line">  t.stop();</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classification with graphcut done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Precision, recall, F1 scores and IoU:"</span> &lt;&lt; std::endl;</div><div class="line">  Classification::Evaluation evaluation (labels, pts.range(label_map), label_indices);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (Label_handle l : labels)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">" * "</span> &lt;&lt; l-&gt;name() &lt;&lt; <span class="stringliteral">": "</span></div><div class="line">              &lt;&lt; evaluation.precision(l) &lt;&lt; <span class="stringliteral">" ; "</span></div><div class="line">              &lt;&lt; evaluation.recall(l) &lt;&lt; <span class="stringliteral">" ; "</span></div><div class="line">              &lt;&lt; evaluation.f1_score(l) &lt;&lt; <span class="stringliteral">" ; "</span></div><div class="line">              &lt;&lt; evaluation.intersection_over_union(l) &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Accuracy = "</span> &lt;&lt; evaluation.accuracy() &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">"Mean F1 score = "</span> &lt;&lt; evaluation.mean_f1_score() &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">"Mean IoU = "</span> &lt;&lt; evaluation.mean_intersection_over_union() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Color point set according to class</span></div><div class="line">  UCmap red = pts.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"red"</span>, 0).first;</div><div class="line">  UCmap green = pts.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"green"</span>, 0).first;</div><div class="line">  UCmap blue = pts.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"blue"</span>, 0).first;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; label_indices.size(); ++ i)</div><div class="line">  {</div><div class="line">    label_map[i] = label_indices[i]; <span class="comment">// update label map with computed classification</span></div><div class="line"></div><div class="line">    Label_handle label = labels[label_indices[i]];</div><div class="line">    <span class="keyword">const</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a>&amp; color = label-&gt;color();</div><div class="line">    red[i] = color.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html#af428aec48cc6ce23776b5f8cdf2a7883">red</a>();</div><div class="line">    green[i] = color.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html#afc04b32226660e92c55c5855d7ae0c5f">green</a>();</div><div class="line">    blue[i] = color.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html#aee7a7d6b78b2045840c4a292c26500df">blue</a>();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Save configuration for later use</span></div><div class="line">  std::ofstream fconfig (<span class="stringliteral">"ethz_random_forest.bin"</span>, std::ios_base::binary);</div><div class="line">  classifier.save_configuration(fconfig);</div><div class="line"></div><div class="line">  <span class="comment">// Write result</span></div><div class="line">  std::ofstream f (<span class="stringliteral">"classification.ply"</span>);</div><div class="line">  f.precision(18);</div><div class="line">  f &lt;&lt; pts;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"All done"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Classification_example_opencv_random_forest"></a>
OpenCV Random Forest</h2>
<p>The following example shows how to use the classifier <a class="el" href="classCGAL_1_1Classification_1_1OpenCV_1_1Random__forest__classifier.html">OpenCV::Random_forest_classifier</a> using an input training set.</p>
<p><br />
<b>File</b> <a class="el" href="Classification_2example_opencv_random_forest_8cpp-example.html">Classification/example_opencv_random_forest.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#if defined (_MSC_VER) &amp;&amp; !defined (_WIN64)</span></div><div class="line"><span class="preprocessor">#pragma warning(disable:4244) // boost::number_distance::distance()</span></div><div class="line">                              <span class="comment">// converts 64 to 32 bits integers</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Classification.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3/IO.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> CGAL::Point_set_3&lt;Point&gt; Point_set;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::Iso_cuboid_3</a> Iso_cuboid_3;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Point_set::Point_map Pmap;</div><div class="line"><span class="keyword">typedef</span> Point_set::Property_map&lt;int&gt; Imap;</div><div class="line"><span class="keyword">typedef</span> Point_set::Property_map&lt;unsigned char&gt; UCmap;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Classification = <a class="code" href="namespaceCGAL_1_1Classification.html">CGAL::Classification</a>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Label_handle                                            Label_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_handle                                          Feature_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Label_set                                               Label_set;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_set                                             Feature_set;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Point_set_feature_generator&lt;Kernel, Point_set, Pmap&gt;    Feature_generator;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::string filename = (argc &gt; 1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/b9_training.ply"</span>);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Reading input"</span> &lt;&lt; std::endl;</div><div class="line">  std::ifstream in (filename.c_str(), std::ios::binary);</div><div class="line">  Point_set pts;</div><div class="line">  in &gt;&gt; pts;</div><div class="line"></div><div class="line">  Imap label_map;</div><div class="line">  <span class="keywordtype">bool</span> lm_found = <span class="keyword">false</span>;</div><div class="line">  std::tie (label_map, lm_found) = pts.property_map&lt;<span class="keywordtype">int</span>&gt; (<span class="stringliteral">"label"</span>);</div><div class="line">  <span class="keywordflow">if</span> (!lm_found)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: \"label\" property not found in input file."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Generating features"</span> &lt;&lt; std::endl;</div><div class="line">  CGAL::Real_timer t;</div><div class="line">  t.start();</div><div class="line">  Feature_generator generator (pts, pts.point_map(),</div><div class="line">                               5);  <span class="comment">// using 5 scales</span></div><div class="line"></div><div class="line">  features.begin_parallel_additions();</div><div class="line">  generator.generate_point_based_features (features);</div><div class="line">  features.end_parallel_additions();</div><div class="line"></div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Add labels</span></div><div class="line">  Label_set labels;</div><div class="line">  Label_handle ground = labels.add (<span class="stringliteral">"ground"</span>);</div><div class="line">  Label_handle vegetation = labels.add (<span class="stringliteral">"vegetation"</span>);</div><div class="line">  Label_handle roof = labels.add (<span class="stringliteral">"roof"</span>);</div><div class="line"></div><div class="line">  std::vector&lt;int&gt; label_indices(pts.size(), -1);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Using OpenCV Random Forest Classifier"</span> &lt;&lt; std::endl;</div><div class="line">  Classification::OpenCV::Random_forest_classifier classifier (labels, features);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Training"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div><div class="line">  t.start();</div><div class="line">  classifier.train (pts.range(label_map));</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  t.reset();</div><div class="line">  t.start();</div><div class="line">  Classification::classify_with_graphcut&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (pts, pts.point_map(), labels, classifier,</div><div class="line">     generator.neighborhood().k_neighbor_query(12),</div><div class="line">     0.2f, 1, label_indices);</div><div class="line">  t.stop();</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classification with graphcut done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Precision, recall, F1 scores and IoU:"</span> &lt;&lt; std::endl;</div><div class="line">  Classification::Evaluation evaluation (labels, pts.range(label_map), label_indices);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (Label_handle l : labels)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">" * "</span> &lt;&lt; l-&gt;name() &lt;&lt; <span class="stringliteral">": "</span></div><div class="line">              &lt;&lt; evaluation.precision(l) &lt;&lt; <span class="stringliteral">" ; "</span></div><div class="line">              &lt;&lt; evaluation.recall(l) &lt;&lt; <span class="stringliteral">" ; "</span></div><div class="line">              &lt;&lt; evaluation.f1_score(l) &lt;&lt; <span class="stringliteral">" ; "</span></div><div class="line">              &lt;&lt; evaluation.intersection_over_union(l) &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Accuracy = "</span> &lt;&lt; evaluation.accuracy() &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">"Mean F1 score = "</span> &lt;&lt; evaluation.mean_f1_score() &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">"Mean IoU = "</span> &lt;&lt; evaluation.mean_intersection_over_union() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Color point set according to class</span></div><div class="line">  UCmap red = pts.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"red"</span>, 0).first;</div><div class="line">  UCmap green = pts.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"green"</span>, 0).first;</div><div class="line">  UCmap blue = pts.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"blue"</span>, 0).first;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; label_indices.size(); ++ i)</div><div class="line">  {</div><div class="line">    label_map[i] = label_indices[i]; <span class="comment">// update label map with computed classification</span></div><div class="line"></div><div class="line">    Label_handle label = labels[label_indices[i]];</div><div class="line">    <span class="keyword">const</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a>&amp; color = label-&gt;color();</div><div class="line">    red[i] = color.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html#af428aec48cc6ce23776b5f8cdf2a7883">red</a>();</div><div class="line">    green[i] = color.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html#afc04b32226660e92c55c5855d7ae0c5f">green</a>();</div><div class="line">    blue[i] = color.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html#aee7a7d6b78b2045840c4a292c26500df">blue</a>();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Write result</span></div><div class="line">  std::ofstream f (<span class="stringliteral">"classification.ply"</span>);</div><div class="line">  f.precision(18);</div><div class="line">  f &lt;&lt; pts;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"All done"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Classification_example_mesh"></a>
Mesh Classification</h2>
<p>The following example:</p>
<ul>
<li>reads a mesh in OFF format;</li>
<li>automatically generates features on 5 scales;</li>
<li>loads a configuration file for classifier <a class="el" href="classCGAL_1_1Classification_1_1ETHZ_1_1Random__forest__classifier.html">ETHZ::Random_forest_classifier</a>;</li>
<li>runs the algorithm using the graphcut regularization.</li>
</ul>
<p><br />
<b>File</b> <a class="el" href="Classification_2example_mesh_classification_8cpp-example.html">Classification/example_mesh_classification.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#if defined (_MSC_VER) &amp;&amp; !defined (_WIN64)</span></div><div class="line"><span class="preprocessor">#pragma warning(disable:4244) // boost::number_distance::distance()</span></div><div class="line">                              <span class="comment">// converts 64 to 32 bits integers</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Classification.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> CGAL::Surface_mesh&lt;Point&gt; Mesh;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Classification = <a class="code" href="namespaceCGAL_1_1Classification.html">CGAL::Classification</a>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Label_handle                                            Label_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_handle                                          Feature_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Label_set                                               Label_set;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_set                                             Feature_set;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Face_descriptor_to_center_of_mass_map&lt;Mesh&gt;             Face_point_map;</div><div class="line"><span class="keyword">typedef</span> Classification::Face_descriptor_to_face_descriptor_with_bbox_map&lt;Mesh&gt;  Face_with_bbox_map;</div><div class="line"><span class="keyword">typedef</span> Classification::Mesh_feature_generator&lt;Kernel, Mesh, Face_point_map&gt;    Feature_generator;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::string filename = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/b9_mesh.off"</span>);</div><div class="line">  std::string filename_config = <span class="stringliteral">"data/b9_mesh_config.bin"</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1)</div><div class="line">    filename = argv[1];</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 2)</div><div class="line">    filename_config = argv[2];</div><div class="line"></div><div class="line">  Mesh mesh;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLIOFct.html#ga49f5b5e6fbfcbfaaac7604c88e10915c">CGAL::IO::read_polygon_mesh</a>(filename, mesh,</div><div class="line">                                  <span class="comment">// the PLY reader expects a binary file by default</span></div><div class="line">                                  CGAL::parameters::use_binary_mode(<span class="keyword">false</span>)))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Generating features"</span> &lt;&lt; std::endl;</div><div class="line">  CGAL::Real_timer t;</div><div class="line">  t.start();</div><div class="line"></div><div class="line"></div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  Face_point_map face_point_map (&amp;mesh); <span class="comment">// Associates each face to its center of mass</span></div><div class="line"></div><div class="line">  std::size_t number_of_scales = 5;</div><div class="line">  Feature_generator generator (mesh, face_point_map, number_of_scales);</div><div class="line"></div><div class="line">  features.begin_parallel_additions();</div><div class="line">  generator.generate_point_based_features (features); <span class="comment">// Features that consider the mesh as a point set</span></div><div class="line">  generator.generate_face_based_features (features);  <span class="comment">// Features computed directly on mesh faces</span></div><div class="line">  features.end_parallel_additions();</div><div class="line"></div><div class="line"></div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  Label_set labels = { <span class="stringliteral">"ground"</span>, <span class="stringliteral">"vegetation"</span>, <span class="stringliteral">"roof"</span> };</div><div class="line"></div><div class="line">  std::vector&lt;int&gt; label_indices(mesh.number_of_faces(), -1);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Using ETHZ Random Forest Classifier"</span> &lt;&lt; std::endl;</div><div class="line">  Classification::ETHZ::Random_forest_classifier classifier (labels, features);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Loading configuration"</span> &lt;&lt; std::endl;</div><div class="line">  std::ifstream in_config (filename_config, std::ios_base::in | std::ios_base::binary);</div><div class="line">  classifier.load_configuration (in_config);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classifying with graphcut"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div><div class="line">  t.start();</div><div class="line">  Classification::classify_with_graphcut&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (mesh.faces(), Face_with_bbox_map(&amp;mesh), labels, classifier,</div><div class="line">     generator.neighborhood().n_ring_neighbor_query(2),</div><div class="line">     0.2f, 1, label_indices);</div><div class="line">  t.stop();</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classification with graphcut done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Classification_example_cluster"></a>
Cluster Classification</h2>
<p>The following example:</p>
<ul>
<li>reads a point set in PLY format;</li>
<li>estimates the normal vectors of the point set;</li>
<li>automatically generates pointwise features on 5 scales;</li>
<li>detects plane using the algorithm <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Region__growing.html">CGAL::Shape_detection::Region_growing</a></code>;</li>
<li>creates <a class="el" href="classCGAL_1_1Classification_1_1Cluster.html">Cluster</a> objects from these detected planes;</li>
<li>computes cluster features from the pointwise features;</li>
<li>loads a configuration file for classifier <a class="el" href="classCGAL_1_1Classification_1_1ETHZ_1_1Random__forest__classifier.html">ETHZ::Random_forest_classifier</a>;</li>
<li>runs the algorithm using the raw algorithm.</li>
</ul>
<p><br />
<b>File</b> <a class="el" href="Classification_2example_cluster_classification_8cpp-example.html">Classification/example_cluster_classification.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#if defined (_MSC_VER) &amp;&amp; !defined (_WIN64)</span></div><div class="line"><span class="preprocessor">#pragma warning(disable:4244) // boost::number_distance::distance()</span></div><div class="line">                              <span class="comment">// converts 64 to 32 bits integers</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/iterator/function_output_iterator.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Classification.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3/IO.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/jet_estimate_normals.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/Region__growing_8h.html">CGAL/Shape_detection/Region_growing.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::Iso_cuboid_3</a>           Iso_cuboid_3;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> CGAL::Point_set_3&lt;Point&gt; Point_set;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Point_set::Point_map                   Pmap;</div><div class="line"><span class="keyword">typedef</span> Point_set::Vector_map                  Vmap;</div><div class="line"><span class="keyword">typedef</span> Point_set::Property_map&lt;int&gt;           Imap;</div><div class="line"><span class="keyword">typedef</span> Point_set::Property_map&lt;unsigned char&gt; UCmap;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Point__set_1_1Sphere__neighbor__query.html">CGAL::Shape_detection::Point_set::Sphere_neighbor_query&lt;Kernel, Point_set, Pmap&gt;</a>                Neighbor_query;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Point__set_1_1Least__squares__plane__fit__region.html">CGAL::Shape_detection::Point_set::Least_squares_plane_fit_region&lt;Kernel, Point_set, Pmap, Vmap&gt;</a> Region_type;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Region__growing.html">CGAL::Shape_detection::Region_growing&lt;Point_set, Neighbor_query, Region_type&gt;</a>                   Region_growing;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Classification = <a class="code" href="namespaceCGAL_1_1Classification.html">CGAL::Classification</a>;</div><div class="line"><span class="keyword">namespace </span>Feature = <a class="code" href="namespaceCGAL_1_1Classification_1_1Feature.html">CGAL::Classification::Feature</a>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Label_handle   Label_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_handle Feature_handle;</div><div class="line"><span class="keyword">typedef</span> Classification::Label_set      Label_set;</div><div class="line"><span class="keyword">typedef</span> Classification::Feature_set    Feature_set;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Classification::Local_eigen_analysis                                 Local_eigen_analysis;</div><div class="line"><span class="keyword">typedef</span> Classification::Point_set_feature_generator&lt;Kernel, Point_set, Pmap&gt; Feature_generator;</div><div class="line"><span class="keyword">typedef</span> Classification::Cluster&lt;Point_set, Pmap&gt;                             Cluster;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::string filename        = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/b9.ply"</span>);</div><div class="line">  std::string filename_config = <span class="stringliteral">"data/b9_clusters_config.bin"</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1)</div><div class="line">    filename = argv[1];</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 2)</div><div class="line">    filename_config = argv[2];</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Reading input"</span> &lt;&lt; std::endl;</div><div class="line">  Point_set pts;</div><div class="line">  <span class="keywordflow">if</span>(!(CGAL::IO::read_point_set(filename, pts,</div><div class="line">                                <span class="comment">// the PLY reader expects a binary file by default</span></div><div class="line">                                CGAL::parameters::use_binary_mode(<span class="keyword">true</span>))))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read "</span> &lt;&lt; filename &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Estimating normals"</span> &lt;&lt; std::endl;</div><div class="line">  CGAL::Real_timer t;</div><div class="line">  t.start();</div><div class="line">  pts.add_normal_map();</div><div class="line">  CGAL::jet_estimate_normals&lt;CGAL::Parallel_if_available_tag&gt; (pts, 12);</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div><div class="line"></div><div class="line">  Feature_set pointwise_features;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Generating pointwise features"</span> &lt;&lt; std::endl;</div><div class="line">  t.start();</div><div class="line">  Feature_generator generator (pts, pts.point_map(), 5); <span class="comment">// using 5 scales</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef CGAL_LINKED_WITH_TBB</span></div><div class="line">  pointwise_features.begin_parallel_additions();</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">  generator.generate_point_based_features (pointwise_features);</div><div class="line"></div><div class="line">  <span class="comment">// Generator should only be used with variables defined at the scope</span></div><div class="line">  <span class="comment">// of the generator object, thus we instantiate the normal map</span></div><div class="line">  <span class="comment">// outside of the function</span></div><div class="line">  Vmap normal_map = pts.normal_map();</div><div class="line">  generator.generate_normal_based_features (pointwise_features, normal_map);</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef CGAL_LINKED_WITH_TBB</span></div><div class="line">  pointwise_features.end_parallel_additions();</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Detecting planes and creating clusters"</span> &lt;&lt; std::endl;</div><div class="line">  t.start();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> search_sphere_radius  = 1.0;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> max_distance_to_plane = 1.0;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> max_accepted_angle    = 25.0;</div><div class="line">  <span class="keyword">const</span> std::size_t min_region_size  = 10;</div><div class="line"></div><div class="line">  Neighbor_query neighbor_query (</div><div class="line">    pts, CGAL::parameters::sphere_radius(search_sphere_radius)</div><div class="line">                          .point_map(pts.point_map()));</div><div class="line">  Region_type region_type(</div><div class="line">    pts, CGAL::parameters::maximum_distance(max_distance_to_plane)</div><div class="line">                          .maximum_angle(max_accepted_angle)</div><div class="line">                          .minimum_region_size(min_region_size)</div><div class="line">                          .point_map(pts.point_map())</div><div class="line">                          .normal_map(pts.normal_map()));</div><div class="line">  Region_growing region_growing (</div><div class="line">    pts, neighbor_query, region_type);</div><div class="line"></div><div class="line">  std::vector&lt;Cluster&gt; clusters;</div><div class="line">  region_growing.detect</div><div class="line">    (boost::make_function_output_iterator</div><div class="line">     ([&amp;](<span class="keyword">const</span> std::vector&lt;std::size_t&gt;&amp; region) -&gt; <span class="keywordtype">void</span> {</div><div class="line"></div><div class="line">        <span class="comment">// Create a new cluster.</span></div><div class="line">        Classification::Cluster&lt;Point_set, Pmap&gt; cluster (pts, pts.point_map());</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> std::size_t idx : region)</div><div class="line">          cluster.insert(idx);</div><div class="line">        clusters.push_back(cluster);</div><div class="line">      }));</div><div class="line"></div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; clusters.size() &lt;&lt; <span class="stringliteral">" clusters created in "</span></div><div class="line">            &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div><div class="line"></div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Computing cluster features"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">  Local_eigen_analysis eigen = Local_eigen_analysis::create_from_point_clusters (clusters);</div><div class="line"></div><div class="line"></div><div class="line">  t.start();</div><div class="line"></div><div class="line"></div><div class="line">  Feature_set features;</div><div class="line"></div><div class="line">  <span class="comment">// First, compute means of features.</span></div><div class="line">  features.begin_parallel_additions();</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; pointwise_features.size(); ++ i)</div><div class="line">    features.add&lt;Feature::Cluster_mean_of_feature&gt; (clusters, pointwise_features[i]);</div><div class="line">  features.end_parallel_additions();</div><div class="line"></div><div class="line">  <span class="comment">// Then, compute variances of features (and remaining cluster features).</span></div><div class="line">  features.begin_parallel_additions();</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; pointwise_features.size(); ++ i)</div><div class="line">    features.add&lt;Feature::Cluster_variance_of_feature&gt; (clusters,</div><div class="line">                                                        pointwise_features[i], <span class="comment">// i^th feature</span></div><div class="line">                                                        features[i]);          <span class="comment">// mean of i^th feature</span></div><div class="line"></div><div class="line">  features.add&lt;Feature::Cluster_size&gt; (clusters);</div><div class="line">  features.add&lt;Feature::Cluster_vertical_extent&gt; (clusters);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; 3; ++ i)</div><div class="line">    features.add&lt;Feature::Eigenvalue&gt; (clusters, eigen, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(i));</div><div class="line"></div><div class="line">  features.end_parallel_additions();</div><div class="line"></div><div class="line"></div><div class="line">  t.stop();</div><div class="line"></div><div class="line">  Label_set labels = { <span class="stringliteral">"ground"</span>, <span class="stringliteral">"vegetation"</span>, <span class="stringliteral">"roof"</span> };</div><div class="line"></div><div class="line">  std::vector&lt;int&gt; label_indices(clusters.size(), -1);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Using ETHZ Random Forest Classifier"</span> &lt;&lt; std::endl;</div><div class="line">  Classification::ETHZ::Random_forest_classifier classifier (labels, features);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Loading configuration"</span> &lt;&lt; std::endl;</div><div class="line">  std::ifstream in_config (filename_config, std::ios_base::in | std::ios_base::binary);</div><div class="line">  classifier.load_configuration (in_config);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classifying"</span> &lt;&lt; std::endl;</div><div class="line">  t.reset();</div><div class="line">  t.start();</div><div class="line">  Classification::classify&lt;CGAL::Parallel_if_available_tag&gt; (clusters, labels, classifier, label_indices);</div><div class="line">  t.stop();</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Classification done in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" second(s)"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Classification_history"></a>
History</h1>
<p>This package is based on a research code by <a href="https://www-sop.inria.fr/members/Florent.Lafarge/">Florent Lafarge</a> that was generalized, extended and packaged by <a href="http://geometryfactory.com/who-we-are/">Simon Giraudot</a> in CGAL 4.12. Classification of surface meshes and of clusters were introduced in CGAL 4.13. The Neural Network classifier was introduced in CGAL 4.14. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Jul 5 2022 09:51:36 for CGAL 5.6 - Classification by
    <a href="https://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>
</html>

</html>
