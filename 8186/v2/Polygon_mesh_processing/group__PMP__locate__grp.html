<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Polygon_mesh_processing/group__PMP__locate__grp.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=11">
<meta name="generator" content="Doxygen 1.9.6">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CGAL 6.1 - Polygon Mesh Processing: Location Functions</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/doxygen.css" rel="stylesheet" type="text/css">
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      },
      equationNumbers: { autoNumber: "AMS" }
  }
}
);
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<script src="modules.js" type="text/javascript"></script>
<link href="cgal_stylesheet.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
      <span class="left">
         <span id="MSearchSelect" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"> 
        </span>
        <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
      </span>
      <span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.svg" alt=""></a>
      </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CGAL 6.1 - Polygon Mesh Processing
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search/",'.html');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__PMP__locate__grp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> |
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Location Functions<div class="ingroups"><a class="el" href="group__PkgPolygonMeshProcessingRef.html">Polygon Mesh Processing Reference</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader"> </h2>
<p>Functions to locate points on a mesh, and manipulate such locations. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga8ec69004f1d28b296aa9e89926bb3981"><td class="memTemplParams" colspan="2"><a id="ga8ec69004f1d28b296aa9e89926bb3981" name="ga8ec69004f1d28b296aa9e89926bb3981"></a>
template&lt;typename TriangleMesh &gt; </td></tr>
<tr class="memitem:ga8ec69004f1d28b296aa9e89926bb3981"><td class="memTemplItemLeft" align="right" valign="top">using </td><td class="memTemplItemRight" valign="bottom"><b>CGAL::Polygon_mesh_processing::descriptor_variant</b> = std::variant&lt; typename boost::graph_traits&lt; TriangleMesh &gt;::vertex_descriptor, typename boost::graph_traits&lt; TriangleMesh &gt;::halfedge_descriptor, typename boost::graph_traits&lt; TriangleMesh &gt;::face_descriptor &gt;</td></tr>
<tr class="memdesc:ga8ec69004f1d28b296aa9e89926bb3981"><td class="mdescLeft"> </td><td class="mdescRight">A variant used in the function <code><a class="el" href="group__PMP__locate__grp.html#ga1be5d5de27953a11b593797d5224fefd" title="Given a location, returns a descriptor to the simplex of smallest dimension on which the point corres...">get_descriptor_from_location()</a></code>. <br></td></tr>
<tr class="separator:ga8ec69004f1d28b296aa9e89926bb3981"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga6581d3f34a14d533fdab2e6beef2873f"><td class="memTemplParams" colspan="2">template&lt;typename FT &gt; </td></tr>
<tr class="memitem:ga6581d3f34a14d533fdab2e6beef2873f"><td class="memTemplItemLeft" align="right" valign="top">using </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PMP__locate__grp.html#ga6581d3f34a14d533fdab2e6beef2873f">CGAL::Polygon_mesh_processing::Barycentric_coordinates</a> = std::array&lt; FT, 3 &gt;</td></tr>
<tr class="memdesc:ga6581d3f34a14d533fdab2e6beef2873f"><td class="mdescLeft"> </td><td class="mdescRight">A triplet of coordinates describing the barycentric coordinates of a point with respect to the vertices of a triangular face.  <br></td></tr>
<tr class="separator:ga6581d3f34a14d533fdab2e6beef2873f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga35604eae6b378b8254a3f41f1a274b9e"><td class="memTemplParams" colspan="2">template&lt;typename TriangleMesh , typename FT &gt; </td></tr>
<tr class="memitem:ga35604eae6b378b8254a3f41f1a274b9e"><td class="memTemplItemLeft" align="right" valign="top">using </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">CGAL::Polygon_mesh_processing::Face_location</a> = std::pair&lt; typename boost::graph_traits&lt; TriangleMesh &gt;::face_descriptor, <a class="el" href="group__PMP__locate__grp.html#ga6581d3f34a14d533fdab2e6beef2873f">Barycentric_coordinates</a>&lt; FT &gt; &gt;</td></tr>
<tr class="memdesc:ga35604eae6b378b8254a3f41f1a274b9e"><td class="mdescLeft"> </td><td class="mdescRight">If <code>tm</code> is the input triangulated surface mesh and given the pair (<code>f</code>, <code>bc</code>) such that <code>bc</code> is the triplet of barycentric coordinates <code>(w0, w1, w2)</code>, the correspondence between the coordinates in <code>bc</code> and the vertices of the face <code>f</code> is the following:  <br></td></tr>
<tr class="separator:ga35604eae6b378b8254a3f41f1a274b9e"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga72808d7750dab4989b4613dfa1dd46fc"><td class="memTemplParams" colspan="2">template&lt;typename GeomTraits , typename Point &gt; </td></tr>
<tr class="memitem:ga72808d7750dab4989b4613dfa1dd46fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__PMP__locate__grp.html#ga6581d3f34a14d533fdab2e6beef2873f">Barycentric_coordinates</a>&lt; typename GeomTraits::FT &gt; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PMP__locate__grp.html#ga72808d7750dab4989b4613dfa1dd46fc">CGAL::Polygon_mesh_processing::barycentric_coordinates</a> (const Point &amp;p, const Point &amp;q, const Point &amp;r, const Point &amp;query, const GeomTraits &amp;gt)</td></tr>
<tr class="memdesc:ga72808d7750dab4989b4613dfa1dd46fc"><td class="mdescLeft"> </td><td class="mdescRight">Given a set of three points and a query point, computes the barycentric coordinates of the query point with respect to the first three points.  <br></td></tr>
<tr class="separator:ga72808d7750dab4989b4613dfa1dd46fc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga1be5d5de27953a11b593797d5224fefd"><td class="memTemplParams" colspan="2">template&lt;typename FT , typename TriangleMesh &gt; </td></tr>
<tr class="memitem:ga1be5d5de27953a11b593797d5224fefd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__PMP__locate__grp.html#ga8ec69004f1d28b296aa9e89926bb3981">descriptor_variant</a>&lt; TriangleMesh &gt; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PMP__locate__grp.html#ga1be5d5de27953a11b593797d5224fefd">CGAL::Polygon_mesh_processing::get_descriptor_from_location</a> (const <a class="el" href="group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">Face_location</a>&lt; TriangleMesh, FT &gt; &amp;loc, const TriangleMesh &amp;tm)</td></tr>
<tr class="memdesc:ga1be5d5de27953a11b593797d5224fefd"><td class="mdescLeft"> </td><td class="mdescRight">Given a location, returns a descriptor to the simplex of smallest dimension on which the point corresponding to the location lies.  <br></td></tr>
<tr class="separator:ga1be5d5de27953a11b593797d5224fefd"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga7632ebc56378e6ded961eab21540cecb"><td class="memTemplParams" colspan="2">template&lt;typename FT , typename TriangleMesh , typename NamedParameters  = parameters::Default_named_parameters&gt; </td></tr>
<tr class="memitem:ga7632ebc56378e6ded961eab21540cecb"><td class="memTemplItemLeft" align="right" valign="top">Point </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PMP__locate__grp.html#ga7632ebc56378e6ded961eab21540cecb">CGAL::Polygon_mesh_processing::construct_point</a> (const <a class="el" href="group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">Face_location</a>&lt; TriangleMesh, FT &gt; &amp;loc, const TriangleMesh &amp;tm, const NamedParameters &amp;np=<a class="elRef" href="../STL_Extension/group__PkgSTLExtensionRef.html#gaac7f54fe7abb7321d8d755683eaafaf2">parameters::default_values</a>())</td></tr>
<tr class="memdesc:ga7632ebc56378e6ded961eab21540cecb"><td class="mdescLeft"> </td><td class="mdescRight">Given a location in a face, returns the geometric position described by these coordinates, as a point.  <br></td></tr>
<tr class="separator:ga7632ebc56378e6ded961eab21540cecb"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Random Location Generation</h2></td></tr>
<tr class="memitem:ga23816d7cea5cba77e56363c5ebd17b6e"><td class="memTemplParams" colspan="2">template&lt;typename FT , typename TriangleMesh &gt; </td></tr>
<tr class="memitem:ga23816d7cea5cba77e56363c5ebd17b6e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">Face_location</a>&lt; TriangleMesh, FT &gt; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PMP__locate__grp.html#ga23816d7cea5cba77e56363c5ebd17b6e">CGAL::Polygon_mesh_processing::random_location_on_halfedge</a> (typename boost::graph_traits&lt; TriangleMesh &gt;::halfedge_descriptor hd, const TriangleMesh &amp;tm, <a class="elRef" href="../Generator/classCGAL_1_1Random.html">CGAL::Random</a> &amp;rnd=<a class="elRef" href="../Generator/group__PkgGeneratorsRef.html#gaaf28146567a47f590c4ee036527f1706">get_default_random</a>())</td></tr>
<tr class="memdesc:ga23816d7cea5cba77e56363c5ebd17b6e"><td class="mdescLeft"> </td><td class="mdescRight">returns a random point over the halfedge <code>hd</code>, as a location.  <br></td></tr>
<tr class="separator:ga23816d7cea5cba77e56363c5ebd17b6e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gac78863fa23c382d08f9944a4f70b7a75"><td class="memTemplParams" colspan="2">template&lt;typename FT , typename TriangleMesh &gt; </td></tr>
<tr class="memitem:gac78863fa23c382d08f9944a4f70b7a75"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">Face_location</a>&lt; TriangleMesh, FT &gt; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PMP__locate__grp.html#gac78863fa23c382d08f9944a4f70b7a75">CGAL::Polygon_mesh_processing::random_location_on_face</a> (typename boost::graph_traits&lt; TriangleMesh &gt;::face_descriptor fd, const TriangleMesh &amp;tm, <a class="elRef" href="../Generator/classCGAL_1_1Random.html">CGAL::Random</a> &amp;rnd=<a class="elRef" href="../Generator/group__PkgGeneratorsRef.html#gaaf28146567a47f590c4ee036527f1706">get_default_random</a>())</td></tr>
<tr class="memdesc:gac78863fa23c382d08f9944a4f70b7a75"><td class="mdescLeft"> </td><td class="mdescRight">returns a random point over the face <code>fd</code>, as a location.  <br></td></tr>
<tr class="separator:gac78863fa23c382d08f9944a4f70b7a75"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga6d90010ec9ad9c07c3659d12d7453d74"><td class="memTemplParams" colspan="2">template&lt;typename FT , typename TriangleMesh &gt; </td></tr>
<tr class="memitem:ga6d90010ec9ad9c07c3659d12d7453d74"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">Face_location</a>&lt; TriangleMesh, FT &gt; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PMP__locate__grp.html#ga6d90010ec9ad9c07c3659d12d7453d74">CGAL::Polygon_mesh_processing::random_location_on_mesh</a> (const TriangleMesh &amp;tm, <a class="elRef" href="../Generator/classCGAL_1_1Random.html">CGAL::Random</a> &amp;rnd=<a class="elRef" href="../Generator/group__PkgGeneratorsRef.html#gaaf28146567a47f590c4ee036527f1706">get_default_random</a>())</td></tr>
<tr class="memdesc:ga6d90010ec9ad9c07c3659d12d7453d74"><td class="mdescLeft"> </td><td class="mdescRight">returns a random point over the mesh <code>tm</code>.  <br></td></tr>
<tr class="separator:ga6d90010ec9ad9c07c3659d12d7453d74"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Location Predicates</h2></td></tr>
<tr class="memitem:ga90eb394aab0e2f1a78d5f69c87cdcb53"><td class="memTemplParams" colspan="2">template&lt;typename FT , typename TriangleMesh &gt; </td></tr>
<tr class="memitem:ga90eb394aab0e2f1a78d5f69c87cdcb53"><td class="memTemplItemLeft" align="right" valign="top">bool </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PMP__locate__grp.html#ga90eb394aab0e2f1a78d5f69c87cdcb53">CGAL::Polygon_mesh_processing::is_on_vertex</a> (const <a class="el" href="group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">Face_location</a>&lt; TriangleMesh, FT &gt; &amp;loc, const typename boost::graph_traits&lt; TriangleMesh &gt;::vertex_descriptor vd, const TriangleMesh &amp;tm)</td></tr>
<tr class="memdesc:ga90eb394aab0e2f1a78d5f69c87cdcb53"><td class="mdescLeft"> </td><td class="mdescRight">Given a location, returns whether the location is on the vertex <code>vd</code> or not.  <br></td></tr>
<tr class="separator:ga90eb394aab0e2f1a78d5f69c87cdcb53"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gad94f826508b2a7d47bffe1c9e9164fa2"><td class="memTemplParams" colspan="2">template&lt;typename FT , typename TriangleMesh &gt; </td></tr>
<tr class="memitem:gad94f826508b2a7d47bffe1c9e9164fa2"><td class="memTemplItemLeft" align="right" valign="top">bool </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PMP__locate__grp.html#gad94f826508b2a7d47bffe1c9e9164fa2">CGAL::Polygon_mesh_processing::is_on_halfedge</a> (const <a class="el" href="group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">Face_location</a>&lt; TriangleMesh, FT &gt; &amp;loc, const typename boost::graph_traits&lt; TriangleMesh &gt;::halfedge_descriptor hd, const TriangleMesh &amp;tm)</td></tr>
<tr class="memdesc:gad94f826508b2a7d47bffe1c9e9164fa2"><td class="mdescLeft"> </td><td class="mdescRight">Given a location, returns whether this location is on the halfedge <code>hd</code> or not.  <br></td></tr>
<tr class="separator:gad94f826508b2a7d47bffe1c9e9164fa2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga475c1e0acddee2198db30289fa331b1b"><td class="memTemplParams" colspan="2">template&lt;typename FT , typename TriangleMesh &gt; </td></tr>
<tr class="memitem:ga475c1e0acddee2198db30289fa331b1b"><td class="memTemplItemLeft" align="right" valign="top">bool </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PMP__locate__grp.html#ga475c1e0acddee2198db30289fa331b1b">CGAL::Polygon_mesh_processing::is_in_face</a> (const <a class="el" href="group__PMP__locate__grp.html#ga6581d3f34a14d533fdab2e6beef2873f">Barycentric_coordinates</a>&lt; FT &gt; &amp;bar, const TriangleMesh &amp;tm)</td></tr>
<tr class="memdesc:ga475c1e0acddee2198db30289fa331b1b"><td class="mdescLeft"> </td><td class="mdescRight">Given a set of barycentric coordinates, returns whether those barycentric coordinates correspond to a point within the face (boundary included), that is, if all the barycentric coordinates are positive.  <br></td></tr>
<tr class="separator:ga475c1e0acddee2198db30289fa331b1b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaf90da1db1204afbf66dbebd17d2e3e27"><td class="memTemplParams" colspan="2">template&lt;typename FT , typename TriangleMesh &gt; </td></tr>
<tr class="memitem:gaf90da1db1204afbf66dbebd17d2e3e27"><td class="memTemplItemLeft" align="right" valign="top">bool </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PMP__locate__grp.html#gaf90da1db1204afbf66dbebd17d2e3e27">CGAL::Polygon_mesh_processing::is_in_face</a> (const <a class="el" href="group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">Face_location</a>&lt; TriangleMesh, FT &gt; &amp;loc, const TriangleMesh &amp;tm)</td></tr>
<tr class="memdesc:gaf90da1db1204afbf66dbebd17d2e3e27"><td class="mdescLeft"> </td><td class="mdescRight">Given a location, returns whether the location is in the face (boundary included) or not.  <br></td></tr>
<tr class="separator:gaf90da1db1204afbf66dbebd17d2e3e27"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga455a6b4f1edfd88358a1150c870691e9"><td class="memTemplParams" colspan="2">template&lt;typename FT , typename TriangleMesh &gt; </td></tr>
<tr class="memitem:ga455a6b4f1edfd88358a1150c870691e9"><td class="memTemplItemLeft" align="right" valign="top">bool </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PMP__locate__grp.html#ga455a6b4f1edfd88358a1150c870691e9">CGAL::Polygon_mesh_processing::is_on_face_border</a> (const <a class="el" href="group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">Face_location</a>&lt; TriangleMesh, FT &gt; &amp;loc, const TriangleMesh &amp;tm)</td></tr>
<tr class="memdesc:ga455a6b4f1edfd88358a1150c870691e9"><td class="mdescLeft"> </td><td class="mdescRight">Given a location, returns whether the location is on the boundary of the face or not.  <br></td></tr>
<tr class="separator:ga455a6b4f1edfd88358a1150c870691e9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga905f903215a1123afef50b74d5424bda"><td class="memTemplParams" colspan="2">template&lt;typename FT , typename TriangleMesh &gt; </td></tr>
<tr class="memitem:ga905f903215a1123afef50b74d5424bda"><td class="memTemplItemLeft" align="right" valign="top">bool </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PMP__locate__grp.html#ga905f903215a1123afef50b74d5424bda">CGAL::Polygon_mesh_processing::is_on_mesh_border</a> (const <a class="el" href="group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">Face_location</a>&lt; TriangleMesh, FT &gt; &amp;loc, const TriangleMesh &amp;tm)</td></tr>
<tr class="memdesc:ga905f903215a1123afef50b74d5424bda"><td class="mdescLeft"> </td><td class="mdescRight">Given a location, returns whether the location is on the border of the mesh or not.  <br></td></tr>
<tr class="separator:ga905f903215a1123afef50b74d5424bda"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Point Location</h2></td></tr>
<tr class="memitem:ga777f3083d65c79021429c9884a828682"><td class="memTemplParams" colspan="2">template&lt;typename FT , typename TriangleMesh &gt; </td></tr>
<tr class="memitem:ga777f3083d65c79021429c9884a828682"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">Face_location</a>&lt; TriangleMesh, FT &gt; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PMP__locate__grp.html#ga777f3083d65c79021429c9884a828682">CGAL::Polygon_mesh_processing::locate_vertex</a> (typename boost::graph_traits&lt; TriangleMesh &gt;::vertex_descriptor vd, const TriangleMesh &amp;tm)</td></tr>
<tr class="memdesc:ga777f3083d65c79021429c9884a828682"><td class="mdescLeft"> </td><td class="mdescRight">returns the location of the given vertex <code>vd</code> as a location, that is an ordered pair specifying a face incident to <code>vd</code> and the barycentric coordinates of the vertex <code>vd</code> in that face.  <br></td></tr>
<tr class="separator:ga777f3083d65c79021429c9884a828682"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga59628d063d4bc22dd52142a365c2f274"><td class="memTemplParams" colspan="2">template&lt;typename FT , typename TriangleMesh &gt; </td></tr>
<tr class="memitem:ga59628d063d4bc22dd52142a365c2f274"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">Face_location</a>&lt; TriangleMesh, FT &gt; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PMP__locate__grp.html#ga59628d063d4bc22dd52142a365c2f274">CGAL::Polygon_mesh_processing::locate_vertex</a> (const typename boost::graph_traits&lt; TriangleMesh &gt;::vertex_descriptor vd, const typename boost::graph_traits&lt; TriangleMesh &gt;::face_descriptor fd, const TriangleMesh &amp;tm)</td></tr>
<tr class="memdesc:ga59628d063d4bc22dd52142a365c2f274"><td class="mdescLeft"> </td><td class="mdescRight">returns the location of a given vertex as a location in <code>fd</code>, that is an ordered pair composed of <code>fd</code> and of the barycentric coordinates of the vertex in <code>fd</code>.  <br></td></tr>
<tr class="separator:ga59628d063d4bc22dd52142a365c2f274"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaea15285dfafaa66a11deede8fdba473e"><td class="memTemplParams" colspan="2">template&lt;typename FT , typename TriangleMesh &gt; </td></tr>
<tr class="memitem:gaea15285dfafaa66a11deede8fdba473e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">Face_location</a>&lt; TriangleMesh, FT &gt; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PMP__locate__grp.html#gaea15285dfafaa66a11deede8fdba473e">CGAL::Polygon_mesh_processing::locate_on_halfedge</a> (const typename boost::graph_traits&lt; TriangleMesh &gt;::halfedge_descriptor hd, const FT t, const TriangleMesh &amp;tm)</td></tr>
<tr class="memdesc:gaea15285dfafaa66a11deede8fdba473e"><td class="mdescLeft"> </td><td class="mdescRight">Given a point described by a halfedge <code>hd</code> and a scalar <code>t</code> as <code>p = (1 - t) * source(hd, tm) + t * target(hd, tm)</code>, returns this location along the given edge as a location, that is an ordered pair specifying a face containing the location and the barycentric coordinates of that location in that face.  <br></td></tr>
<tr class="separator:gaea15285dfafaa66a11deede8fdba473e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaa8b9a0579a35e7beff2ab54aa911cff1"><td class="memTemplParams" colspan="2">template&lt;typename TriangleMesh , typename NamedParameters  = parameters::Default_named_parameters&gt; </td></tr>
<tr class="memitem:gaa8b9a0579a35e7beff2ab54aa911cff1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">Face_location</a>&lt; TriangleMesh, FT &gt; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PMP__locate__grp.html#gaa8b9a0579a35e7beff2ab54aa911cff1">CGAL::Polygon_mesh_processing::locate_in_face</a> (const Point &amp;query, const typename boost::graph_traits&lt; TriangleMesh &gt;::face_descriptor fd, const TriangleMesh &amp;tm, const NamedParameters &amp;np=<a class="elRef" href="../STL_Extension/group__PkgSTLExtensionRef.html#gaac7f54fe7abb7321d8d755683eaafaf2">parameters::default_values</a>())</td></tr>
<tr class="memdesc:gaa8b9a0579a35e7beff2ab54aa911cff1"><td class="mdescLeft"> </td><td class="mdescRight">Given a point <code>query</code> and a face <code>fd</code> of a triangulated surface mesh, returns this location as a location, that is an ordered pair composed of <code>fd</code> and of the barycentric coordinates of <code>query</code> with respect to the vertices of <code>fd</code>.  <br></td></tr>
<tr class="separator:gaa8b9a0579a35e7beff2ab54aa911cff1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gae0f1a2098f3f8c86c3bca86926517f21"><td class="memTemplParams" colspan="2">template&lt;typename FT , typename TriangleMesh &gt; </td></tr>
<tr class="memitem:gae0f1a2098f3f8c86c3bca86926517f21"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">Face_location</a>&lt; TriangleMesh, FT &gt; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PMP__locate__grp.html#gae0f1a2098f3f8c86c3bca86926517f21">CGAL::Polygon_mesh_processing::locate_in_adjacent_face</a> (const <a class="el" href="group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">Face_location</a>&lt; TriangleMesh, FT &gt; &amp;loc, const typename boost::graph_traits&lt; TriangleMesh &gt;::face_descriptor fd, const TriangleMesh &amp;tm)</td></tr>
<tr class="memdesc:gae0f1a2098f3f8c86c3bca86926517f21"><td class="mdescLeft"> </td><td class="mdescRight">Given a location and a second face adjacent to the first, returns the location of the point in the second face.  <br></td></tr>
<tr class="separator:gae0f1a2098f3f8c86c3bca86926517f21"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Nearest Face Location Queries</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>The following functions can be used to find the closest point on a triangle mesh, given either a point or a ray.</p>
<p>This closest point is computed using a <code><a class="elRef" href="../AABB_tree/classCGAL_1_1AABB__tree.html">CGAL::AABB_tree</a></code>. Users intending to call location functions on more than a single point (or ray) should first compute an AABB tree to store it (otherwise, it will be recomputed every time). Note that since the AABB tree class is a 3D structure, it might be required to wrap your point property map to convert your point type to the 3D point type (i.e., your traits' <code>Point_3</code>) if you are working with a 2D triangle structure. </p>
</td></tr>
<tr class="memitem:gafa64630e9a7b1cbc28875d63ac8a3eaa"><td class="memTemplParams" colspan="2">template&lt;typename TriangleMesh , typename Point3VPM , typename NamedParameters  = parameters::Default_named_parameters&gt; </td></tr>
<tr class="memitem:gafa64630e9a7b1cbc28875d63ac8a3eaa"><td class="memTemplItemLeft" align="right" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PMP__locate__grp.html#gafa64630e9a7b1cbc28875d63ac8a3eaa">CGAL::Polygon_mesh_processing::build_AABB_tree</a> (const TriangleMesh &amp;tm, <a class="elRef" href="../AABB_tree/classCGAL_1_1AABB__tree.html">AABB_tree</a>&lt; <a class="elRef" href="../AABB_tree/classCGAL_1_1AABB__traits__3.html">AABB_traits_3</a>&lt; Geom_traits, <a class="elRef" href="../AABB_tree/classCGAL_1_1AABB__face__graph__triangle__primitive.html">CGAL::AABB_face_graph_triangle_primitive</a>&lt; TriangleMesh, Point3VPM &gt; &gt; &gt; &amp;outTree, const NamedParameters &amp;np=<a class="elRef" href="../STL_Extension/group__PkgSTLExtensionRef.html#gaac7f54fe7abb7321d8d755683eaafaf2">parameters::default_values</a>())</td></tr>
<tr class="memdesc:gafa64630e9a7b1cbc28875d63ac8a3eaa"><td class="mdescLeft"> </td><td class="mdescRight">creates an AABB tree suitable for use with <code><a class="el" href="group__PMP__locate__grp.html#ga609d1fd3a16ecc381a1b131386fc708c" title="returns the face location nearest to the given point, as a location.">locate_with_AABB_tree()</a></code>.  <br></td></tr>
<tr class="separator:gafa64630e9a7b1cbc28875d63ac8a3eaa"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga609d1fd3a16ecc381a1b131386fc708c"><td class="memTemplParams" colspan="2">template&lt;typename TriangleMesh , typename Point3VPM , typename NamedParameters  = parameters::Default_named_parameters&gt; </td></tr>
<tr class="memitem:ga609d1fd3a16ecc381a1b131386fc708c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">Face_location</a>&lt; TriangleMesh, FT &gt; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PMP__locate__grp.html#ga609d1fd3a16ecc381a1b131386fc708c">CGAL::Polygon_mesh_processing::locate_with_AABB_tree</a> (const Point &amp;p, const <a class="elRef" href="../AABB_tree/classCGAL_1_1AABB__tree.html">AABB_tree</a>&lt; <a class="elRef" href="../AABB_tree/classCGAL_1_1AABB__traits__3.html">AABB_traits_3</a>&lt; Geom_traits, <a class="elRef" href="../AABB_tree/classCGAL_1_1AABB__face__graph__triangle__primitive.html">AABB_face_graph_triangle_primitive</a>&lt; TriangleMesh, Point3VPM &gt; &gt; &gt; &amp;tree, const TriangleMesh &amp;tm, const NamedParameters &amp;np=<a class="elRef" href="../STL_Extension/group__PkgSTLExtensionRef.html#gaac7f54fe7abb7321d8d755683eaafaf2">parameters::default_values</a>())</td></tr>
<tr class="memdesc:ga609d1fd3a16ecc381a1b131386fc708c"><td class="mdescLeft"> </td><td class="mdescRight">returns the face location nearest to the given point, as a location.  <br></td></tr>
<tr class="separator:ga609d1fd3a16ecc381a1b131386fc708c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga817d3417a9711b3efbfde45e46e0aa00"><td class="memTemplParams" colspan="2">template&lt;typename TriangleMesh , typename NamedParameters  = parameters::Default_named_parameters&gt; </td></tr>
<tr class="memitem:ga817d3417a9711b3efbfde45e46e0aa00"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">Face_location</a>&lt; TriangleMesh, FT &gt; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PMP__locate__grp.html#ga817d3417a9711b3efbfde45e46e0aa00">CGAL::Polygon_mesh_processing::locate</a> (const Point &amp;p, const TriangleMesh &amp;tm, const NamedParameters &amp;np=<a class="elRef" href="../STL_Extension/group__PkgSTLExtensionRef.html#gaac7f54fe7abb7321d8d755683eaafaf2">parameters::default_values</a>())</td></tr>
<tr class="memdesc:ga817d3417a9711b3efbfde45e46e0aa00"><td class="mdescLeft"> </td><td class="mdescRight">returns the nearest face location to the given point.  <br></td></tr>
<tr class="separator:ga817d3417a9711b3efbfde45e46e0aa00"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga32bd9c2a74c9e475340a7e761539b3e1"><td class="memTemplParams" colspan="2">template&lt;typename TriangleMesh , typename Point3VPM , typename NamedParameters  = parameters::Default_named_parameters&gt; </td></tr>
<tr class="memitem:ga32bd9c2a74c9e475340a7e761539b3e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">Face_location</a>&lt; TriangleMesh, FT &gt; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PMP__locate__grp.html#ga32bd9c2a74c9e475340a7e761539b3e1">CGAL::Polygon_mesh_processing::locate_with_AABB_tree</a> (const Ray &amp;ray, const <a class="elRef" href="../AABB_tree/classCGAL_1_1AABB__tree.html">AABB_tree</a>&lt; <a class="elRef" href="../AABB_tree/classCGAL_1_1AABB__traits__3.html">AABB_traits_3</a>&lt; Geom_traits, <a class="elRef" href="../AABB_tree/classCGAL_1_1AABB__face__graph__triangle__primitive.html">AABB_face_graph_triangle_primitive</a>&lt; TriangleMesh, Point3VPM &gt; &gt; &gt; &amp;tree, const TriangleMesh &amp;tm, const NamedParameters &amp;np=<a class="elRef" href="../STL_Extension/group__PkgSTLExtensionRef.html#gaac7f54fe7abb7321d8d755683eaafaf2">parameters::default_values</a>())</td></tr>
<tr class="memdesc:ga32bd9c2a74c9e475340a7e761539b3e1"><td class="mdescLeft"> </td><td class="mdescRight">returns the face location along <code>ray</code> nearest to its source point.  <br></td></tr>
<tr class="separator:ga32bd9c2a74c9e475340a7e761539b3e1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga34d601277f6003a751716e29eb830038"><td class="memTemplParams" colspan="2">template&lt;typename TriangleMesh , typename NamedParameters  = parameters::Default_named_parameters&gt; </td></tr>
<tr class="memitem:ga34d601277f6003a751716e29eb830038"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">Face_location</a>&lt; TriangleMesh, FT &gt; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PMP__locate__grp.html#ga34d601277f6003a751716e29eb830038">CGAL::Polygon_mesh_processing::locate</a> (const Ray &amp;ray, const TriangleMesh &amp;tm, const NamedParameters &amp;np=<a class="elRef" href="../STL_Extension/group__PkgSTLExtensionRef.html#gaac7f54fe7abb7321d8d755683eaafaf2">parameters::default_values</a>())</td></tr>
<tr class="memdesc:ga34d601277f6003a751716e29eb830038"><td class="mdescLeft"> </td><td class="mdescRight">returns the face location along <code>ray</code> nearest to its source point.  <br></td></tr>
<tr class="separator:ga34d601277f6003a751716e29eb830038"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga6581d3f34a14d533fdab2e6beef2873f" name="ga6581d3f34a14d533fdab2e6beef2873f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6581d3f34a14d533fdab2e6beef2873f">◆ </a></span>Barycentric_coordinates</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__PMP__locate__grp.html#ga6581d3f34a14d533fdab2e6beef2873f">CGAL::Polygon_mesh_processing::Barycentric_coordinates</a> = typedef std::array&lt;FT, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/locate.h&gt;</code></p>

<p>A triplet of coordinates describing the barycentric coordinates of a point with respect to the vertices of a triangular face. </p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e" title="If tm is the input triangulated surface mesh and given the pair (f, bc) such that bc is the triplet o...">Face_location</a></code> </dd></dl>

</div>
</div>
<a id="ga35604eae6b378b8254a3f41f1a274b9e" name="ga35604eae6b378b8254a3f41f1a274b9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35604eae6b378b8254a3f41f1a274b9e">◆ </a></span>Face_location</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TriangleMesh , typename FT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">CGAL::Polygon_mesh_processing::Face_location</a> = typedef std::pair&lt;typename boost::graph_traits&lt;TriangleMesh&gt;::face_descriptor, <a class="el" href="group__PMP__locate__grp.html#ga6581d3f34a14d533fdab2e6beef2873f">Barycentric_coordinates</a>&lt;FT&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/locate.h&gt;</code></p>

<p>If <code>tm</code> is the input triangulated surface mesh and given the pair (<code>f</code>, <code>bc</code>) such that <code>bc</code> is the triplet of barycentric coordinates <code>(w0, w1, w2)</code>, the correspondence between the coordinates in <code>bc</code> and the vertices of the face <code>f</code> is the following: </p>
<ul>
<li><code>w0</code> corresponds to <code>source(halfedge(f, tm), tm)</code></li>
<li><code>w1</code> corresponds to <code>target(halfedge(f, tm), tm)</code></li>
<li><code>w2</code> corresponds to <code>target(next(halfedge(f, tm), tm), tm)</code> </li>
</ul>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga72808d7750dab4989b4613dfa1dd46fc" name="ga72808d7750dab4989b4613dfa1dd46fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72808d7750dab4989b4613dfa1dd46fc">◆ </a></span>barycentric_coordinates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeomTraits , typename Point &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PMP__locate__grp.html#ga6581d3f34a14d533fdab2e6beef2873f">Barycentric_coordinates</a>&lt; typename GeomTraits::FT &gt; CGAL::Polygon_mesh_processing::barycentric_coordinates </td>
          <td>(</td>
          <td class="paramtype">const Point &amp; </td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point &amp; </td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point &amp; </td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point &amp; </td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GeomTraits &amp; </td>
          <td class="paramname"><em>gt</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/locate.h&gt;</code></p>

<p>Given a set of three points and a query point, computes the barycentric coordinates of the query point with respect to the first three points. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GeomTraits</td><td>the type of a geometric traits. Must be a model of <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> and be compatible with the template parameter <code>Point</code>. </td></tr>
    <tr><td class="paramname">Point</td><td>the type of a geometric 2D or 3D point</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p,q,r</td><td>three points with respect to whom the barycentric coordinates of <code>query</code> will be computed </td></tr>
    <tr><td class="paramname">query</td><td>the query point whose barycentric coordinates will be computed </td></tr>
    <tr><td class="paramname">gt</td><td>an instance of the geometric traits</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>p</code>, <code>q</code>, and <code>r</code> are not collinear. </dd>
<dd>
<code>query</code> lies on the plane defined by <code>p</code>, <code>q</code>, and <code>r</code>. </dd></dl>

</div>
</div>
<a id="gafa64630e9a7b1cbc28875d63ac8a3eaa" name="gafa64630e9a7b1cbc28875d63ac8a3eaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa64630e9a7b1cbc28875d63ac8a3eaa">◆ </a></span>build_AABB_tree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TriangleMesh , typename Point3VPM , typename NamedParameters  = parameters::Default_named_parameters&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CGAL::Polygon_mesh_processing::build_AABB_tree </td>
          <td>(</td>
          <td class="paramtype">const TriangleMesh &amp; </td>
          <td class="paramname"><em>tm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../AABB_tree/classCGAL_1_1AABB__tree.html">AABB_tree</a>&lt; <a class="elRef" href="../AABB_tree/classCGAL_1_1AABB__traits__3.html">AABB_traits_3</a>&lt; Geom_traits, <a class="elRef" href="../AABB_tree/classCGAL_1_1AABB__face__graph__triangle__primitive.html">CGAL::AABB_face_graph_triangle_primitive</a>&lt; TriangleMesh, Point3VPM &gt; &gt; &gt; &amp; </td>
          <td class="paramname"><em>outTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters &amp; </td>
          <td class="paramname"><em>np</em> = <code><a class="elRef" href="../STL_Extension/group__PkgSTLExtensionRef.html#gaac7f54fe7abb7321d8d755683eaafaf2">parameters::default_values</a>()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/locate.h&gt;</code></p>

<p>creates an AABB tree suitable for use with <code><a class="el" href="group__PMP__locate__grp.html#ga609d1fd3a16ecc381a1b131386fc708c" title="returns the face location nearest to the given point, as a location.">locate_with_AABB_tree()</a></code>. </p>
<p>This function should first be called by users who intend to locate multiple points: in this case, it is better to first build an AABB tree, and use the function <code><a class="el" href="group__PMP__locate__grp.html#ga609d1fd3a16ecc381a1b131386fc708c" title="returns the face location nearest to the given point, as a location.">locate_with_AABB_tree()</a></code> that takes as parameter an AABB tree, instead of calling <code><a class="el" href="group__PMP__locate__grp.html#ga817d3417a9711b3efbfde45e46e0aa00" title="returns the nearest face location to the given point.">locate()</a></code> multiple times, which will build a new AABB tree on every call.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriangleMesh</td><td>must be a model of <code><a class="elRef" href="../BGL/classFaceListGraph.html">FaceListGraph</a></code> </td></tr>
    <tr><td class="paramname">Point3VPM</td><td>must be a class model of <code><a class="elRef" href="../Manual/classReadablePropertyMap.html">ReadablePropertyMap</a></code> with <code>boost::graph_traits&lt;TriangleMesh&gt;::vertex_descriptor</code> as key type and the CGAL 3D point type (your traits' <code>Point_3</code>) as value type. </td></tr>
    <tr><td class="paramname">NamedParameters</td><td>a sequence of <a class="elRef" href="../BGL/group__bgl__namedparameters.html">Named Parameters</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tm</td><td>a triangulated surface mesh </td></tr>
    <tr><td class="paramname">outTree</td><td>output parameter that stores the computed <code><a class="elRef" href="../AABB_tree/classCGAL_1_1AABB__tree.html">AABB_tree</a></code> </td></tr>
    <tr><td class="paramname">np</td><td>an optional sequence of <a class="elRef" href="../BGL/group__bgl__namedparameters.html">Named Parameters</a> among the ones listed below</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Optional Named Parameters</dt>
<dd><table class="params">
<tr>
<td> <button class="collapsible"> <b>vertex_point_map</b> </button> <div class="content"><ul>
<li>
a property map associating points to the vertices of <code>tm</code> </li>
<li>
<b>Type: </b>a class model of <code><a class="elRef" href="../Manual/classReadablePropertyMap.html">ReadablePropertyMap</a></code> with <code>boost::graph_traits&lt;TriangleMesh&gt;::vertex_descriptor</code> as key type and <code>Point_3</code> as value type </li>
<li>
<b>Default: </b><code>boost::get(CGAL::vertex_point, tm)</code> </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>geom_traits</b> </button> <div class="content"><ul>
<li>
an instance of a geometric traits class </li>
<li>
<b>Type: </b>a class model of <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> </li>
<li>
<b>Default: </b>a CGAL <a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a> deduced from the point type, using <code><a class="elRef" href="../Kernel_23/structCGAL_1_1Kernel__traits.html">CGAL::Kernel_traits</a></code> </li>
<li>
<b>Extra: </b>The geometric traits class must be compatible with the vertex point type. </li>
<li>
<b>Extra: </b>Must be identical to the traits used in the template parameter of the <code>AABB_traits</code>. </li>
</ul>
 </div>  </td><td></td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a id="ga7632ebc56378e6ded961eab21540cecb" name="ga7632ebc56378e6ded961eab21540cecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7632ebc56378e6ded961eab21540cecb">◆ </a></span>construct_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FT , typename TriangleMesh , typename NamedParameters  = parameters::Default_named_parameters&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Point CGAL::Polygon_mesh_processing::construct_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">Face_location</a>&lt; TriangleMesh, FT &gt; &amp; </td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TriangleMesh &amp; </td>
          <td class="paramname"><em>tm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters &amp; </td>
          <td class="paramname"><em>np</em> = <code><a class="elRef" href="../STL_Extension/group__PkgSTLExtensionRef.html#gaac7f54fe7abb7321d8d755683eaafaf2">parameters::default_values</a>()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/locate.h&gt;</code></p>

<p>Given a location in a face, returns the geometric position described by these coordinates, as a point. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FT</td><td>must be a model of <code><a class="elRef" href="../Algebraic_foundations/classFieldNumberType.html">FieldNumberType</a></code> </td></tr>
    <tr><td class="paramname">TriangleMesh</td><td>must be a model of <code><a class="elRef" href="../BGL/classFaceGraph.html">FaceGraph</a></code> </td></tr>
    <tr><td class="paramname">NamedParameters</td><td>a sequence of <a class="elRef" href="../BGL/group__bgl__namedparameters.html">Named Parameters</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loc</td><td>the location from which a point is constructed </td></tr>
    <tr><td class="paramname">tm</td><td>a triangulated surface mesh </td></tr>
    <tr><td class="paramname">np</td><td>an optional sequence of <a class="elRef" href="../BGL/group__bgl__namedparameters.html">Named Parameters</a> among the ones listed below</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Optional Named Parameters</dt>
<dd><table class="params">
<tr>
<td> <button class="collapsible"> <b>vertex_point_map</b> </button> <div class="content"><ul>
<li>
a property map associating points to the vertices of <code>tm</code> </li>
<li>
<b>Type: </b>a class model of <code><a class="elRef" href="../Manual/classReadablePropertyMap.html">ReadablePropertyMap</a></code> with <code>boost::graph_traits&lt;TriangleMesh&gt;::vertex_descriptor</code> as key type and <code>Point_3</code> as value type </li>
<li>
<b>Default: </b><code>boost::get(CGAL::vertex_point, tm)</code> </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>geom_traits</b> </button> <div class="content"><ul>
<li>
an instance of a geometric traits class </li>
<li>
<b>Type: </b>a class model of <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> </li>
<li>
<b>Default: </b>a CGAL <a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a> deduced from the point type, using <code><a class="elRef" href="../Kernel_23/structCGAL_1_1Kernel__traits.html">CGAL::Kernel_traits</a></code> </li>
<li>
<b>Extra: </b>The geometric traits class must be compatible with the vertex point type. </li>
<li>
<b>Extra: </b>If such traits class is provided, its type <code>FT</code> must be identical to the template parameter <code>FT</code> of this function. </li>
</ul>
 </div>  </td><td></td></tr>
</table>
</dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>loc.first</code> is a face descriptor corresponding to a face of <code>tm</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a point whose type is the same as the value type of the vertex point property map provided by the user or via named parameters, or the internal point map of the mesh <code>tm</code>. </dd></dl>

</div>
</div>
<a id="ga1be5d5de27953a11b593797d5224fefd" name="ga1be5d5de27953a11b593797d5224fefd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1be5d5de27953a11b593797d5224fefd">◆ </a></span>get_descriptor_from_location()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FT , typename TriangleMesh &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PMP__locate__grp.html#ga8ec69004f1d28b296aa9e89926bb3981">descriptor_variant</a>&lt; TriangleMesh &gt; CGAL::Polygon_mesh_processing::get_descriptor_from_location </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">Face_location</a>&lt; TriangleMesh, FT &gt; &amp; </td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TriangleMesh &amp; </td>
          <td class="paramname"><em>tm</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/locate.h&gt;</code></p>

<p>Given a location, returns a descriptor to the simplex of smallest dimension on which the point corresponding to the location lies. </p>
<p>In other words:</p><ul>
<li>if the point lies on a vertex, this function returns a <code>boost::graph_traits&lt;TriangleMesh&gt;::vertex_descriptor</code> <code>v</code>;</li>
<li>if the point lies on a halfedge, this function returns a <code>boost::graph_traits&lt;TriangleMesh&gt;::halfedge_descriptor</code> <code>hd</code> (note that in that case, <code>loc.first == face(hd, tm)</code> holds).</li>
<li>otherwise, this function returns a <code>boost::graph_traits&lt;TriangleMesh&gt;::face_descriptor</code> <code>fd</code> (equal to <code>loc.first</code>).</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FT</td><td>must be a model of <code><a class="elRef" href="../Algebraic_foundations/classFieldNumberType.html">FieldNumberType</a></code> </td></tr>
    <tr><td class="paramname">TriangleMesh</td><td>must be a model of <code><a class="elRef" href="../BGL/classFaceGraph.html">FaceGraph</a></code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loc</td><td>a location with <code>loc.first</code> a face of <code>tm</code> </td></tr>
    <tr><td class="paramname">tm</td><td>a triangulated surface mesh</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>loc.first</code> is a face descriptor corresponding to a face of <code>tm</code>. </dd>
<dd>
<code>loc</code> describes the barycentric coordinates of a point that lives within the face (boundary included), meaning the barycentric coordinates are all positive. </dd></dl>

</div>
</div>
<a id="ga475c1e0acddee2198db30289fa331b1b" name="ga475c1e0acddee2198db30289fa331b1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga475c1e0acddee2198db30289fa331b1b">◆ </a></span>is_in_face() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FT , typename TriangleMesh &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool CGAL::Polygon_mesh_processing::is_in_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__PMP__locate__grp.html#ga6581d3f34a14d533fdab2e6beef2873f">Barycentric_coordinates</a>&lt; FT &gt; &amp; </td>
          <td class="paramname"><em>bar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TriangleMesh &amp; </td>
          <td class="paramname"><em>tm</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/locate.h&gt;</code></p>

<p>Given a set of barycentric coordinates, returns whether those barycentric coordinates correspond to a point within the face (boundary included), that is, if all the barycentric coordinates are positive. </p>
<p>If <code>tm</code> is the input triangulated surface mesh and given the pair (<code>f</code>, <code>bc</code>) such that <code>bc</code> is the triplet of barycentric coordinates <code>(w0, w1, w2)</code>, the correspondence between the coordinates in <code>bc</code> and the vertices of the face <code>f</code> is the following:</p><ul>
<li><code>w0</code> corresponds to <code>source(halfedge(f, tm), tm)</code></li>
<li><code>w1</code> corresponds to <code>target(halfedge(f, tm), tm)</code></li>
<li><code>w2</code> corresponds to <code>target(next(halfedge(f, tm), tm), tm)</code></li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FT</td><td>must be a model of <code><a class="elRef" href="../Algebraic_foundations/classFieldNumberType.html">FieldNumberType</a></code> </td></tr>
    <tr><td class="paramname">TriangleMesh</td><td>must be a model of <code><a class="elRef" href="../BGL/classFaceGraph.html">FaceGraph</a></code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bar</td><td>an array of barycentric coordinates </td></tr>
    <tr><td class="paramname">tm</td><td>a triangulated surface mesh </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf90da1db1204afbf66dbebd17d2e3e27" name="gaf90da1db1204afbf66dbebd17d2e3e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf90da1db1204afbf66dbebd17d2e3e27">◆ </a></span>is_in_face() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FT , typename TriangleMesh &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool CGAL::Polygon_mesh_processing::is_in_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">Face_location</a>&lt; TriangleMesh, FT &gt; &amp; </td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TriangleMesh &amp; </td>
          <td class="paramname"><em>tm</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/locate.h&gt;</code></p>

<p>Given a location, returns whether the location is in the face (boundary included) or not. </p>
<p>If <code>tm</code> is the input triangulated surface mesh and given the pair (<code>f</code>, <code>bc</code>) such that <code>bc</code> is the triplet of barycentric coordinates <code>(w0, w1, w2)</code>, the correspondence between the coordinates in <code>bc</code> and the vertices of the face <code>f</code> is the following:</p><ul>
<li><code>w0</code> corresponds to <code>source(halfedge(f, tm), tm)</code></li>
<li><code>w1</code> corresponds to <code>target(halfedge(f, tm), tm)</code></li>
<li><code>w2</code> corresponds to <code>target(next(halfedge(f, tm), tm), tm)</code></li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FT</td><td>must be a model of <code><a class="elRef" href="../Algebraic_foundations/classFieldNumberType.html">FieldNumberType</a></code> </td></tr>
    <tr><td class="paramname">TriangleMesh</td><td>must be a model of <code><a class="elRef" href="../BGL/classFaceGraph.html">FaceGraph</a></code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loc</td><td>a location with <code>loc.first</code> a face of <code>tm</code> </td></tr>
    <tr><td class="paramname">tm</td><td>a triangulated surface mesh</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>loc.first</code> is a face descriptor corresponding to a face of <code>tm</code>. </dd></dl>

</div>
</div>
<a id="ga455a6b4f1edfd88358a1150c870691e9" name="ga455a6b4f1edfd88358a1150c870691e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga455a6b4f1edfd88358a1150c870691e9">◆ </a></span>is_on_face_border()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FT , typename TriangleMesh &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool CGAL::Polygon_mesh_processing::is_on_face_border </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">Face_location</a>&lt; TriangleMesh, FT &gt; &amp; </td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TriangleMesh &amp; </td>
          <td class="paramname"><em>tm</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/locate.h&gt;</code></p>

<p>Given a location, returns whether the location is on the boundary of the face or not. </p>
<p>If <code>tm</code> is the input triangulated surface mesh and given the pair (<code>f</code>, <code>bc</code>) such that <code>bc</code> is the triplet of barycentric coordinates <code>(w0, w1, w2)</code>, the correspondence between the coordinates in <code>bc</code> and the vertices of the face <code>f</code> is the following:</p><ul>
<li><code>w0</code> corresponds to <code>source(halfedge(f, tm), tm)</code></li>
<li><code>w1</code> corresponds to <code>target(halfedge(f, tm), tm)</code></li>
<li><code>w2</code> corresponds to <code>target(next(halfedge(f, tm), tm), tm)</code></li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FT</td><td>must be a model of <code><a class="elRef" href="../Algebraic_foundations/classFieldNumberType.html">FieldNumberType</a></code> </td></tr>
    <tr><td class="paramname">TriangleMesh</td><td>must be a model of <code><a class="elRef" href="../BGL/classFaceGraph.html">FaceGraph</a></code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loc</td><td>a location with <code>loc.first</code> a face of <code>tm</code> </td></tr>
    <tr><td class="paramname">tm</td><td>a triangulated surface mesh</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>loc.first</code> is a face descriptor corresponding to a face of <code>tm</code>. </dd></dl>

</div>
</div>
<a id="gad94f826508b2a7d47bffe1c9e9164fa2" name="gad94f826508b2a7d47bffe1c9e9164fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad94f826508b2a7d47bffe1c9e9164fa2">◆ </a></span>is_on_halfedge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FT , typename TriangleMesh &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool CGAL::Polygon_mesh_processing::is_on_halfedge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">Face_location</a>&lt; TriangleMesh, FT &gt; &amp; </td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename boost::graph_traits&lt; TriangleMesh &gt;::halfedge_descriptor </td>
          <td class="paramname"><em>hd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TriangleMesh &amp; </td>
          <td class="paramname"><em>tm</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/locate.h&gt;</code></p>

<p>Given a location, returns whether this location is on the halfedge <code>hd</code> or not. </p>
<p>If <code>tm</code> is the input triangulated surface mesh and given the pair (<code>f</code>, <code>bc</code>) such that <code>bc</code> is the triplet of barycentric coordinates <code>(w0, w1, w2)</code>, the correspondence between the coordinates in <code>bc</code> and the vertices of the face <code>f</code> is the following:</p><ul>
<li><code>w0</code> corresponds to <code>source(halfedge(f, tm), tm)</code></li>
<li><code>w1</code> corresponds to <code>target(halfedge(f, tm), tm)</code></li>
<li><code>w2</code> corresponds to <code>target(next(halfedge(f, tm), tm), tm)</code></li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FT</td><td>must be a model of <code><a class="elRef" href="../Algebraic_foundations/classFieldNumberType.html">FieldNumberType</a></code> </td></tr>
    <tr><td class="paramname">TriangleMesh</td><td>must be a model of <code><a class="elRef" href="../BGL/classFaceGraph.html">FaceGraph</a></code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loc</td><td>a location with <code>loc.first</code> a face of <code>tm</code> </td></tr>
    <tr><td class="paramname">hd</td><td>a halfedge of <code>tm</code> </td></tr>
    <tr><td class="paramname">tm</td><td>a triangulated surface mesh</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>loc.first</code> is a face descriptor corresponding to a face of <code>tm</code>. </dd></dl>

</div>
</div>
<a id="ga905f903215a1123afef50b74d5424bda" name="ga905f903215a1123afef50b74d5424bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga905f903215a1123afef50b74d5424bda">◆ </a></span>is_on_mesh_border()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FT , typename TriangleMesh &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool CGAL::Polygon_mesh_processing::is_on_mesh_border </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">Face_location</a>&lt; TriangleMesh, FT &gt; &amp; </td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TriangleMesh &amp; </td>
          <td class="paramname"><em>tm</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/locate.h&gt;</code></p>

<p>Given a location, returns whether the location is on the border of the mesh or not. </p>
<p>If <code>tm</code> is the input triangulated surface mesh and given the pair (<code>f</code>, <code>bc</code>) such that <code>bc</code> is the triplet of barycentric coordinates <code>(w0, w1, w2)</code>, the correspondence between the coordinates in <code>bc</code> and the vertices of the face <code>f</code> is the following:</p><ul>
<li><code>w0</code> corresponds to <code>source(halfedge(f, tm), tm)</code></li>
<li><code>w1</code> corresponds to <code>target(halfedge(f, tm), tm)</code></li>
<li><code>w2</code> corresponds to <code>target(next(halfedge(f, tm), tm), tm)</code></li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FT</td><td>must be a model of <code><a class="elRef" href="../Algebraic_foundations/classFieldNumberType.html">FieldNumberType</a></code> </td></tr>
    <tr><td class="paramname">TriangleMesh</td><td>must be a model of <code><a class="elRef" href="../BGL/classFaceGraph.html">FaceGraph</a></code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loc</td><td>a location with <code>loc.first</code> a face of <code>tm</code> </td></tr>
    <tr><td class="paramname">tm</td><td>a triangulated surface mesh</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>loc.first</code> is a face descriptor corresponding to a face of <code>tm</code>. </dd></dl>

</div>
</div>
<a id="ga90eb394aab0e2f1a78d5f69c87cdcb53" name="ga90eb394aab0e2f1a78d5f69c87cdcb53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90eb394aab0e2f1a78d5f69c87cdcb53">◆ </a></span>is_on_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FT , typename TriangleMesh &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool CGAL::Polygon_mesh_processing::is_on_vertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">Face_location</a>&lt; TriangleMesh, FT &gt; &amp; </td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename boost::graph_traits&lt; TriangleMesh &gt;::vertex_descriptor </td>
          <td class="paramname"><em>vd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TriangleMesh &amp; </td>
          <td class="paramname"><em>tm</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/locate.h&gt;</code></p>

<p>Given a location, returns whether the location is on the vertex <code>vd</code> or not. </p>
<p>If <code>tm</code> is the input triangulated surface mesh and given the pair (<code>f</code>, <code>bc</code>) such that <code>bc</code> is the triplet of barycentric coordinates <code>(w0, w1, w2)</code>, the correspondence between the coordinates in <code>bc</code> and the vertices of the face <code>f</code> is the following:</p><ul>
<li><code>w0</code> corresponds to <code>source(halfedge(f, tm), tm)</code></li>
<li><code>w1</code> corresponds to <code>target(halfedge(f, tm), tm)</code></li>
<li><code>w2</code> corresponds to <code>target(next(halfedge(f, tm), tm), tm)</code></li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FT</td><td>must be a model of <code><a class="elRef" href="../Algebraic_foundations/classFieldNumberType.html">FieldNumberType</a></code> </td></tr>
    <tr><td class="paramname">TriangleMesh</td><td>must be a model of <code><a class="elRef" href="../BGL/classFaceGraph.html">FaceGraph</a></code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loc</td><td>a location with <code>loc.first</code> a face of <code>tm</code> </td></tr>
    <tr><td class="paramname">vd</td><td>a vertex of <code>tm</code> </td></tr>
    <tr><td class="paramname">tm</td><td>a triangulated surface mesh</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>loc.first</code> is a face descriptor corresponding to a face of <code>tm</code>. </dd></dl>

</div>
</div>
<a id="ga817d3417a9711b3efbfde45e46e0aa00" name="ga817d3417a9711b3efbfde45e46e0aa00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga817d3417a9711b3efbfde45e46e0aa00">◆ </a></span>locate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TriangleMesh , typename NamedParameters  = parameters::Default_named_parameters&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">Face_location</a>&lt; TriangleMesh, FT &gt; CGAL::Polygon_mesh_processing::locate </td>
          <td>(</td>
          <td class="paramtype">const Point &amp; </td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TriangleMesh &amp; </td>
          <td class="paramname"><em>tm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters &amp; </td>
          <td class="paramname"><em>np</em> = <code><a class="elRef" href="../STL_Extension/group__PkgSTLExtensionRef.html#gaac7f54fe7abb7321d8d755683eaafaf2">parameters::default_values</a>()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/locate.h&gt;</code></p>

<p>returns the nearest face location to the given point. </p>
<p>Note that this function will build an AABB tree on each call. If you need to call this function more than once, first use <code><a class="el" href="group__PMP__locate__grp.html#gafa64630e9a7b1cbc28875d63ac8a3eaa" title="creates an AABB tree suitable for use with locate_with_AABB_tree().">build_AABB_tree()</a></code> to create a an AABB tree that you can store and use the function <code><a class="el" href="group__PMP__locate__grp.html#ga609d1fd3a16ecc381a1b131386fc708c" title="returns the face location nearest to the given point, as a location.">locate_with_AABB_tree()</a></code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriangleMesh</td><td>must be a model of <code><a class="elRef" href="../BGL/classFaceListGraph.html">FaceListGraph</a></code>. </td></tr>
    <tr><td class="paramname">NamedParameters</td><td>a sequence of <a class="elRef" href="../BGL/group__bgl__namedparameters.html">Named Parameters</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the point to locate on the input triangulated surface mesh </td></tr>
    <tr><td class="paramname">tm</td><td>a triangulated surface mesh </td></tr>
    <tr><td class="paramname">np</td><td>an optional sequence of <a class="elRef" href="../BGL/group__bgl__namedparameters.html">Named Parameters</a> among the ones listed below</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Optional Named Parameters</dt>
<dd><table class="params">
<tr>
<td> <button class="collapsible"> <b>vertex_point_map</b> </button> <div class="content"><ul>
<li>
a property map associating points to the vertices of <code>tm</code> </li>
<li>
<b>Type: </b>a class model of <code><a class="elRef" href="../Manual/classReadablePropertyMap.html">ReadablePropertyMap</a></code> with <code>boost::graph_traits&lt;TriangleMesh&gt;::vertex_descriptor</code> as key type and <code>Point_3</code> as value type </li>
<li>
<b>Default: </b><code>boost::get(CGAL::vertex_point, tm)</code> </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>geom_traits</b> </button> <div class="content"><ul>
<li>
an instance of a geometric traits class </li>
<li>
<b>Type: </b>a class model of <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> </li>
<li>
<b>Default: </b>a CGAL <a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a> deduced from the point type, using <code><a class="elRef" href="../Kernel_23/structCGAL_1_1Kernel__traits.html">CGAL::Kernel_traits</a></code> </li>
<li>
<b>Extra: </b>The geometric traits class must be compatible with the vertex point type. </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>snapping_tolerance</b> </button> <div class="content"><ul>
<li>
a tolerance value used to snap barycentric coordinates </li>
<li>
<b>Type: </b>double </li>
<li>
<b>Default: </b><code>0</code> </li>
<li>
<b>Extra: </b>Depending on the geometric traits used, the computation of the barycentric coordinates might be an inexact construction, thus leading to sometimes surprising values (e.g. a triplet <code>[0.5, 0.5, -1-e17]</code> for a point at the middle of an edge). The coordinates will be snapped towards <code>0</code> and <code>1</code> if the difference is smaller than the tolerance value, while still ensuring that the total sum of the coordinates is <code>1</code>. </li>
</ul>
 </div>  </td><td></td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a id="ga34d601277f6003a751716e29eb830038" name="ga34d601277f6003a751716e29eb830038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34d601277f6003a751716e29eb830038">◆ </a></span>locate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TriangleMesh , typename NamedParameters  = parameters::Default_named_parameters&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">Face_location</a>&lt; TriangleMesh, FT &gt; CGAL::Polygon_mesh_processing::locate </td>
          <td>(</td>
          <td class="paramtype">const Ray &amp; </td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TriangleMesh &amp; </td>
          <td class="paramname"><em>tm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters &amp; </td>
          <td class="paramname"><em>np</em> = <code><a class="elRef" href="../STL_Extension/group__PkgSTLExtensionRef.html#gaac7f54fe7abb7321d8d755683eaafaf2">parameters::default_values</a>()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/locate.h&gt;</code></p>

<p>returns the face location along <code>ray</code> nearest to its source point. </p>
<p>If the ray does not intersect the mesh, a default constructed location is returned.</p>
<p>Note that this function will build an AABB tree on each call. If you need to call this function more than once, use <code><a class="el" href="group__PMP__locate__grp.html#gafa64630e9a7b1cbc28875d63ac8a3eaa" title="creates an AABB tree suitable for use with locate_with_AABB_tree().">build_AABB_tree()</a></code> to cache a copy of the <code><a class="elRef" href="../AABB_tree/classCGAL_1_1AABB__tree.html">AABB_tree</a></code>, and use the overloads of this function that accept a reference to an AABB tree as input.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriangleMesh</td><td>must be a model of <code><a class="elRef" href="../BGL/classFaceListGraph.html">FaceListGraph</a></code>. </td></tr>
    <tr><td class="paramname">NamedParameters</td><td>a sequence of <a class="elRef" href="../BGL/group__bgl__namedparameters.html">Named Parameters</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ray</td><td>a ray to intersect with the input triangulated surface mesh </td></tr>
    <tr><td class="paramname">tm</td><td>the input triangulated surface mesh </td></tr>
    <tr><td class="paramname">np</td><td>an optional sequence of <a class="elRef" href="../BGL/group__bgl__namedparameters.html">Named Parameters</a> among the ones listed below</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Optional Named Parameters</dt>
<dd><table class="params">
<tr>
<td> <button class="collapsible"> <b>vertex_point_map</b> </button> <div class="content"><ul>
<li>
a property map associating points to the vertices of <code>tm</code> </li>
<li>
<b>Type: </b>a class model of <code><a class="elRef" href="../Manual/classReadablePropertyMap.html">ReadablePropertyMap</a></code> with <code>boost::graph_traits&lt;TriangleMesh&gt;::vertex_descriptor</code> as key type and <code>Point_3</code> as value type </li>
<li>
<b>Default: </b><code>boost::get(CGAL::vertex_point, tm)</code> </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>geom_traits</b> </button> <div class="content"><ul>
<li>
an instance of a geometric traits class </li>
<li>
<b>Type: </b>a class model of <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> </li>
<li>
<b>Default: </b>a CGAL <a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a> deduced from the point type, using <code><a class="elRef" href="../Kernel_23/structCGAL_1_1Kernel__traits.html">CGAL::Kernel_traits</a></code> </li>
<li>
<b>Extra: </b>The geometric traits class must be compatible with the vertex point type. </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>snapping_tolerance</b> </button> <div class="content"><ul>
<li>
a tolerance value used to snap barycentric coordinates </li>
<li>
<b>Type: </b>double </li>
<li>
<b>Default: </b><code>0</code> </li>
<li>
<b>Extra: </b>Depending on the geometric traits used, the computation of the barycentric coordinates might be an inexact construction, thus leading to sometimes surprising values (e.g. a triplet <code>[0.5, 0.5, -1-e17]</code> for a point at the middle of an edge). The coordinates will be snapped towards <code>0</code> and <code>1</code> if the difference is smaller than the tolerance value, while still ensuring that the total sum of the coordinates is <code>1</code>. </li>
</ul>
 </div>  </td><td></td></tr>
</table>
</dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>ray</code> is an object with the same ambient dimension as the point type (the value type of the vertex point map). </dd></dl>

</div>
</div>
<a id="gae0f1a2098f3f8c86c3bca86926517f21" name="gae0f1a2098f3f8c86c3bca86926517f21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0f1a2098f3f8c86c3bca86926517f21">◆ </a></span>locate_in_adjacent_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FT , typename TriangleMesh &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">Face_location</a>&lt; TriangleMesh, FT &gt; CGAL::Polygon_mesh_processing::locate_in_adjacent_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">Face_location</a>&lt; TriangleMesh, FT &gt; &amp; </td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename boost::graph_traits&lt; TriangleMesh &gt;::face_descriptor </td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TriangleMesh &amp; </td>
          <td class="paramname"><em>tm</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/locate.h&gt;</code></p>

<p>Given a location and a second face adjacent to the first, returns the location of the point in the second face. </p>
<p>If <code>tm</code> is the input triangulated surface mesh and given the pair (<code>f</code>, <code>bc</code>) such that <code>bc</code> is the triplet of barycentric coordinates <code>(w0, w1, w2)</code>, the correspondence between the coordinates in <code>bc</code> and the vertices of the face <code>f</code> is the following:</p><ul>
<li><code>w0</code> corresponds to <code>source(halfedge(f, tm), tm)</code></li>
<li><code>w1</code> corresponds to <code>target(halfedge(f, tm), tm)</code></li>
<li><code>w2</code> corresponds to <code>target(next(halfedge(f, tm), tm), tm)</code></li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FT</td><td>must be a model of <code><a class="elRef" href="../Algebraic_foundations/classFieldNumberType.html">FieldNumberType</a></code> </td></tr>
    <tr><td class="paramname">TriangleMesh</td><td>must be a model of <code><a class="elRef" href="../BGL/classFaceGraph.html">FaceGraph</a></code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loc</td><td>the first location, with <code>loc.first</code> being a face of <code>tm</code> </td></tr>
    <tr><td class="paramname">fd</td><td>the second face, adjacent to <code>loc.first</code> </td></tr>
    <tr><td class="paramname">tm</td><td>the triangle mesh to which <code>fd</code> belongs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>loc</code> corresponds to a point that lies on a face incident to both <code>loc.first</code> and <code>fd</code>. </dd></dl>

</div>
</div>
<a id="gaa8b9a0579a35e7beff2ab54aa911cff1" name="gaa8b9a0579a35e7beff2ab54aa911cff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8b9a0579a35e7beff2ab54aa911cff1">◆ </a></span>locate_in_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TriangleMesh , typename NamedParameters  = parameters::Default_named_parameters&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">Face_location</a>&lt; TriangleMesh, FT &gt; CGAL::Polygon_mesh_processing::locate_in_face </td>
          <td>(</td>
          <td class="paramtype">const Point &amp; </td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename boost::graph_traits&lt; TriangleMesh &gt;::face_descriptor </td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TriangleMesh &amp; </td>
          <td class="paramname"><em>tm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters &amp; </td>
          <td class="paramname"><em>np</em> = <code><a class="elRef" href="../STL_Extension/group__PkgSTLExtensionRef.html#gaac7f54fe7abb7321d8d755683eaafaf2">parameters::default_values</a>()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/locate.h&gt;</code></p>

<p>Given a point <code>query</code> and a face <code>fd</code> of a triangulated surface mesh, returns this location as a location, that is an ordered pair composed of <code>fd</code> and of the barycentric coordinates of <code>query</code> with respect to the vertices of <code>fd</code>. </p>
<p>If <code>tm</code> is the input triangulated surface mesh and given the pair (<code>f</code>, <code>bc</code>) such that <code>bc</code> is the triplet of barycentric coordinates <code>(w0, w1, w2)</code>, the correspondence between the coordinates in <code>bc</code> and the vertices of the face <code>f</code> is the following:</p><ul>
<li><code>w0</code> corresponds to <code>source(halfedge(f, tm), tm)</code></li>
<li><code>w1</code> corresponds to <code>target(halfedge(f, tm), tm)</code></li>
<li><code>w2</code> corresponds to <code>target(next(halfedge(f, tm), tm), tm)</code></li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriangleMesh</td><td>must be a model of <code><a class="elRef" href="../BGL/classFaceGraph.html">FaceGraph</a></code> </td></tr>
    <tr><td class="paramname">NamedParameters</td><td>a sequence of <a class="elRef" href="../BGL/group__bgl__namedparameters.html">Named Parameters</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>a point, whose type is equal to the value type of the vertex point property map (either user-provided via named parameters or the internal point map of the mesh <code>tm</code>) </td></tr>
    <tr><td class="paramname">fd</td><td>a face of <code>tm</code> </td></tr>
    <tr><td class="paramname">tm</td><td>a triangulated surface mesh </td></tr>
    <tr><td class="paramname">np</td><td>an optional sequence of <a class="elRef" href="../BGL/group__bgl__namedparameters.html">Named Parameters</a> among the ones listed below</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Optional Named Parameters</dt>
<dd><table class="params">
<tr>
<td> <button class="collapsible"> <b>vertex_point_map</b> </button> <div class="content"><ul>
<li>
a property map associating points to the vertices of <code>tm</code> </li>
<li>
<b>Type: </b>a class model of <code><a class="elRef" href="../Manual/classReadablePropertyMap.html">ReadablePropertyMap</a></code> with <code>boost::graph_traits&lt;TriangleMesh&gt;::vertex_descriptor</code> as key type and <code>Point_3</code> as value type </li>
<li>
<b>Default: </b><code>boost::get(CGAL::vertex_point, tm)</code> </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>geom_traits</b> </button> <div class="content"><ul>
<li>
an instance of a geometric traits class </li>
<li>
<b>Type: </b>a class model of <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> </li>
<li>
<b>Default: </b>a CGAL <a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a> deduced from the point type, using <code><a class="elRef" href="../Kernel_23/structCGAL_1_1Kernel__traits.html">CGAL::Kernel_traits</a></code> </li>
<li>
<b>Extra: </b>The geometric traits class must be compatible with the vertex point type. </li>
<li>
<b>Extra: </b>If such traits class is provided, its type <code>FT</code> must be identical to the template parameter <code>FT</code> of this function. </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>snapping_tolerance</b> </button> <div class="content"><ul>
<li>
a tolerance value used to snap barycentric coordinates </li>
<li>
<b>Type: </b>double </li>
<li>
<b>Default: </b><code>0</code> </li>
<li>
<b>Extra: </b>Depending on the geometric traits used, the computation of the barycentric coordinates might be an inexact construction, thus leading to sometimes surprising values (e.g. a triplet <code>[0.5, 0.5, -1-e17]</code> for a point at the middle of an edge). The coordinates will be snapped towards <code>0</code> and <code>1</code> if the difference is smaller than the tolerance value, while still ensuring that the total sum of the coordinates is <code>1</code>. </li>
</ul>
 </div>  </td><td></td></tr>
</table>
</dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>fd</code> is not the null face</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a face location. The type <code>FT</code> is deduced from the geometric traits, either provided by the user via named parameters (with <code>geom_traits</code>) or using <code><a class="elRef" href="../Kernel_23/structCGAL_1_1Kernel__traits.html">CGAL::Kernel_traits</a></code> and the point type of the vertex point property map in use. </dd></dl>

</div>
</div>
<a id="gaea15285dfafaa66a11deede8fdba473e" name="gaea15285dfafaa66a11deede8fdba473e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea15285dfafaa66a11deede8fdba473e">◆ </a></span>locate_on_halfedge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FT , typename TriangleMesh &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">Face_location</a>&lt; TriangleMesh, FT &gt; CGAL::Polygon_mesh_processing::locate_on_halfedge </td>
          <td>(</td>
          <td class="paramtype">const typename boost::graph_traits&lt; TriangleMesh &gt;::halfedge_descriptor </td>
          <td class="paramname"><em>hd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FT </td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TriangleMesh &amp; </td>
          <td class="paramname"><em>tm</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/locate.h&gt;</code></p>

<p>Given a point described by a halfedge <code>hd</code> and a scalar <code>t</code> as <code>p = (1 - t) * source(hd, tm) + t * target(hd, tm)</code>, returns this location along the given edge as a location, that is an ordered pair specifying a face containing the location and the barycentric coordinates of that location in that face. </p>
<p>If <code>tm</code> is the input triangulated surface mesh and given the pair (<code>f</code>, <code>bc</code>) such that <code>bc</code> is the triplet of barycentric coordinates <code>(w0, w1, w2)</code>, the correspondence between the coordinates in <code>bc</code> and the vertices of the face <code>f</code> is the following:</p><ul>
<li><code>w0</code> corresponds to <code>source(halfedge(f, tm), tm)</code></li>
<li><code>w1</code> corresponds to <code>target(halfedge(f, tm), tm)</code></li>
<li><code>w2</code> corresponds to <code>target(next(halfedge(f, tm), tm), tm)</code></li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FT</td><td>must be a model of <code><a class="elRef" href="../Algebraic_foundations/classFieldNumberType.html">FieldNumberType</a></code> </td></tr>
    <tr><td class="paramname">TriangleMesh</td><td>must be a model of <code><a class="elRef" href="../BGL/classFaceGraph.html">FaceGraph</a></code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hd</td><td>a halfedge of <code>tm</code> </td></tr>
    <tr><td class="paramname">t</td><td>the parametric distance of the desired point along <code>hd</code> </td></tr>
    <tr><td class="paramname">tm</td><td>a triangulated surface mesh </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga59628d063d4bc22dd52142a365c2f274" name="ga59628d063d4bc22dd52142a365c2f274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59628d063d4bc22dd52142a365c2f274">◆ </a></span>locate_vertex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FT , typename TriangleMesh &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">Face_location</a>&lt; TriangleMesh, FT &gt; CGAL::Polygon_mesh_processing::locate_vertex </td>
          <td>(</td>
          <td class="paramtype">const typename boost::graph_traits&lt; TriangleMesh &gt;::vertex_descriptor </td>
          <td class="paramname"><em>vd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename boost::graph_traits&lt; TriangleMesh &gt;::face_descriptor </td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TriangleMesh &amp; </td>
          <td class="paramname"><em>tm</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/locate.h&gt;</code></p>

<p>returns the location of a given vertex as a location in <code>fd</code>, that is an ordered pair composed of <code>fd</code> and of the barycentric coordinates of the vertex in <code>fd</code>. </p>
<p>If <code>tm</code> is the input triangulated surface mesh and given the pair (<code>f</code>, <code>bc</code>) such that <code>bc</code> is the triplet of barycentric coordinates <code>(w0, w1, w2)</code>, the correspondence between the coordinates in <code>bc</code> and the vertices of the face <code>f</code> is the following:</p><ul>
<li><code>w0</code> corresponds to <code>source(halfedge(f, tm), tm)</code></li>
<li><code>w1</code> corresponds to <code>target(halfedge(f, tm), tm)</code></li>
<li><code>w2</code> corresponds to <code>target(next(halfedge(f, tm), tm), tm)</code></li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FT</td><td>must be a model of <code><a class="elRef" href="../Algebraic_foundations/classFieldNumberType.html">FieldNumberType</a></code> </td></tr>
    <tr><td class="paramname">TriangleMesh</td><td>must be a model of <code><a class="elRef" href="../BGL/classFaceGraph.html">FaceGraph</a></code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vd</td><td>a vertex of <code>tm</code> and a vertex of the face <code>fd</code> </td></tr>
    <tr><td class="paramname">fd</td><td>a face of <code>tm</code> </td></tr>
    <tr><td class="paramname">tm</td><td>a triangulated surface mesh</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>fd</code> is not the null face </dd></dl>

</div>
</div>
<a id="ga777f3083d65c79021429c9884a828682" name="ga777f3083d65c79021429c9884a828682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga777f3083d65c79021429c9884a828682">◆ </a></span>locate_vertex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FT , typename TriangleMesh &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">Face_location</a>&lt; TriangleMesh, FT &gt; CGAL::Polygon_mesh_processing::locate_vertex </td>
          <td>(</td>
          <td class="paramtype">typename boost::graph_traits&lt; TriangleMesh &gt;::vertex_descriptor </td>
          <td class="paramname"><em>vd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TriangleMesh &amp; </td>
          <td class="paramname"><em>tm</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/locate.h&gt;</code></p>

<p>returns the location of the given vertex <code>vd</code> as a location, that is an ordered pair specifying a face incident to <code>vd</code> and the barycentric coordinates of the vertex <code>vd</code> in that face. </p>
<p>If <code>tm</code> is the input triangulated surface mesh and given the pair (<code>f</code>, <code>bc</code>) such that <code>bc</code> is the triplet of barycentric coordinates <code>(w0, w1, w2)</code>, the correspondence between the coordinates in <code>bc</code> and the vertices of the face <code>f</code> is the following:</p><ul>
<li><code>w0</code> corresponds to <code>source(halfedge(f, tm), tm)</code></li>
<li><code>w1</code> corresponds to <code>target(halfedge(f, tm), tm)</code></li>
<li><code>w2</code> corresponds to <code>target(next(halfedge(f, tm), tm), tm)</code></li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FT</td><td>must be a model of <code><a class="elRef" href="../Algebraic_foundations/classFieldNumberType.html">FieldNumberType</a></code> </td></tr>
    <tr><td class="paramname">TriangleMesh</td><td>must be a model of <code><a class="elRef" href="../BGL/classFaceGraph.html">FaceGraph</a></code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vd</td><td>a vertex of <code>tm</code> </td></tr>
    <tr><td class="paramname">tm</td><td>a triangulated surface mesh</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>vd</code> is not an isolated vertex </dd></dl>

</div>
</div>
<a id="ga609d1fd3a16ecc381a1b131386fc708c" name="ga609d1fd3a16ecc381a1b131386fc708c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga609d1fd3a16ecc381a1b131386fc708c">◆ </a></span>locate_with_AABB_tree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TriangleMesh , typename Point3VPM , typename NamedParameters  = parameters::Default_named_parameters&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">Face_location</a>&lt; TriangleMesh, FT &gt; CGAL::Polygon_mesh_processing::locate_with_AABB_tree </td>
          <td>(</td>
          <td class="paramtype">const Point &amp; </td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../AABB_tree/classCGAL_1_1AABB__tree.html">AABB_tree</a>&lt; <a class="elRef" href="../AABB_tree/classCGAL_1_1AABB__traits__3.html">AABB_traits_3</a>&lt; Geom_traits, <a class="elRef" href="../AABB_tree/classCGAL_1_1AABB__face__graph__triangle__primitive.html">AABB_face_graph_triangle_primitive</a>&lt; TriangleMesh, Point3VPM &gt; &gt; &gt; &amp; </td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TriangleMesh &amp; </td>
          <td class="paramname"><em>tm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters &amp; </td>
          <td class="paramname"><em>np</em> = <code><a class="elRef" href="../STL_Extension/group__PkgSTLExtensionRef.html#gaac7f54fe7abb7321d8d755683eaafaf2">parameters::default_values</a>()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/locate.h&gt;</code></p>

<p>returns the face location nearest to the given point, as a location. </p>
<p>Note that it is possible for the triangle mesh to have ambiant dimension <code>2</code> (e.g. the mesh is a 2D triangulation, or a <a class="elRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh</a>&lt;CGAL::Point_2&lt;Kernel&gt; &gt;), as long as an appropriate vertex point property map is passed in the AABB tree, which will convert from 2D to 3D.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriangleMesh</td><td>must be a model of <code><a class="elRef" href="../BGL/classFaceListGraph.html">FaceListGraph</a></code> </td></tr>
    <tr><td class="paramname">Point3VPM</td><td>must be a class model of <code><a class="elRef" href="../Manual/classReadablePropertyMap.html">ReadablePropertyMap</a></code> with <code>boost::graph_traits&lt;TriangleMesh&gt;::vertex_descriptor</code> as key type and the CGAL 3D point type (your traits' <code>Point_3</code>) as value type. </td></tr>
    <tr><td class="paramname">NamedParameters</td><td>a sequence of <a class="elRef" href="../BGL/group__bgl__namedparameters.html">Named Parameters</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the point to locate on the input triangulated surface mesh </td></tr>
    <tr><td class="paramname">tree</td><td>an AABB tree containing the triangular faces of the input surface mesh to perform the point location with </td></tr>
    <tr><td class="paramname">tm</td><td>a triangulated surface mesh </td></tr>
    <tr><td class="paramname">np</td><td>an optional sequence of <a class="elRef" href="../BGL/group__bgl__namedparameters.html">Named Parameters</a> among the ones listed below</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Optional Named Parameters</dt>
<dd><table class="params">
<tr>
<td> <button class="collapsible"> <b>vertex_point_map</b> </button> <div class="content"><ul>
<li>
a property map associating points to the vertices of <code>tm</code> </li>
<li>
<b>Type: </b>a class model of <code><a class="elRef" href="../Manual/classReadablePropertyMap.html">ReadablePropertyMap</a></code> with <code>boost::graph_traits&lt;TriangleMesh&gt;::vertex_descriptor</code> as key type and <code>Point_3</code> as value type </li>
<li>
<b>Default: </b><code>boost::get(CGAL::vertex_point, tm)</code> </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>geom_traits</b> </button> <div class="content"><ul>
<li>
an instance of a geometric traits class </li>
<li>
<b>Type: </b>a class model of <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> </li>
<li>
<b>Default: </b>a CGAL <a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a> deduced from the point type, using <code><a class="elRef" href="../Kernel_23/structCGAL_1_1Kernel__traits.html">CGAL::Kernel_traits</a></code> </li>
<li>
<b>Extra: </b>The geometric traits class must be compatible with the vertex point type. </li>
<li>
<b>Extra: </b>Must be identical to the traits used in the template parameter of the <code>AABB_traits</code>. </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>snapping_tolerance</b> </button> <div class="content"><ul>
<li>
a tolerance value used to snap barycentric coordinates </li>
<li>
<b>Type: </b>double </li>
<li>
<b>Default: </b><code>0</code> </li>
<li>
<b>Extra: </b>Depending on the geometric traits used, the computation of the barycentric coordinates might be an inexact construction, thus leading to sometimes surprising values (e.g. a triplet <code>[0.5, 0.5, -1-e17]</code> for a point at the middle of an edge). The coordinates will be snapped towards <code>0</code> and <code>1</code> if the difference is smaller than the tolerance value, while still ensuring that the total sum of the coordinates is <code>1</code>. </li>
</ul>
 </div>  </td><td></td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a face location. The type <code>FT</code> is deduced from the geometric traits, either provided by the user via named parameters (with <code>geom_traits</code>) or using <code><a class="elRef" href="../Kernel_23/structCGAL_1_1Kernel__traits.html">CGAL::Kernel_traits</a></code> and the point type of the vertex point property map in use. </dd></dl>

</div>
</div>
<a id="ga32bd9c2a74c9e475340a7e761539b3e1" name="ga32bd9c2a74c9e475340a7e761539b3e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32bd9c2a74c9e475340a7e761539b3e1">◆ </a></span>locate_with_AABB_tree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TriangleMesh , typename Point3VPM , typename NamedParameters  = parameters::Default_named_parameters&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">Face_location</a>&lt; TriangleMesh, FT &gt; CGAL::Polygon_mesh_processing::locate_with_AABB_tree </td>
          <td>(</td>
          <td class="paramtype">const Ray &amp; </td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="../AABB_tree/classCGAL_1_1AABB__tree.html">AABB_tree</a>&lt; <a class="elRef" href="../AABB_tree/classCGAL_1_1AABB__traits__3.html">AABB_traits_3</a>&lt; Geom_traits, <a class="elRef" href="../AABB_tree/classCGAL_1_1AABB__face__graph__triangle__primitive.html">AABB_face_graph_triangle_primitive</a>&lt; TriangleMesh, Point3VPM &gt; &gt; &gt; &amp; </td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TriangleMesh &amp; </td>
          <td class="paramname"><em>tm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters &amp; </td>
          <td class="paramname"><em>np</em> = <code><a class="elRef" href="../STL_Extension/group__PkgSTLExtensionRef.html#gaac7f54fe7abb7321d8d755683eaafaf2">parameters::default_values</a>()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/locate.h&gt;</code></p>

<p>returns the face location along <code>ray</code> nearest to its source point. </p>
<p>If the ray does not intersect the mesh, a default constructed location is returned.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriangleMesh</td><td>must be a model of <code><a class="elRef" href="../BGL/classFaceListGraph.html">FaceListGraph</a></code>. </td></tr>
    <tr><td class="paramname">Point3VPM</td><td>must be a class model of <code><a class="elRef" href="../Manual/classReadablePropertyMap.html">ReadablePropertyMap</a></code> with <code>boost::graph_traits&lt;TriangleMesh&gt;::vertex_descriptor</code> as key type and the CGAL 3D point type (your traits' <code>Point_3</code>) as value type. </td></tr>
    <tr><td class="paramname">NamedParameters</td><td>a sequence of <a class="elRef" href="../BGL/group__bgl__namedparameters.html">Named Parameters</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ray</td><td>a ray to intersect with the input triangulated surface mesh </td></tr>
    <tr><td class="paramname">tree</td><td>an AABB tree containing the triangular faces of the input surface mesh to perform the point location with </td></tr>
    <tr><td class="paramname">tm</td><td>a triangulated surface mesh </td></tr>
    <tr><td class="paramname">np</td><td>an optional sequence of <a class="elRef" href="../BGL/group__bgl__namedparameters.html">Named Parameters</a> among the ones listed below</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Optional Named Parameters</dt>
<dd><table class="params">
<tr>
<td> <button class="collapsible"> <b>vertex_point_map</b> </button> <div class="content"><ul>
<li>
a property map associating points to the vertices of <code>tm</code> </li>
<li>
<b>Type: </b>a class model of <code><a class="elRef" href="../Manual/classReadablePropertyMap.html">ReadablePropertyMap</a></code> with <code>boost::graph_traits&lt;TriangleMesh&gt;::vertex_descriptor</code> as key type and <code>Point_3</code> as value type </li>
<li>
<b>Default: </b><code>boost::get(CGAL::vertex_point, tm)</code> </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>geom_traits</b> </button> <div class="content"><ul>
<li>
an instance of a geometric traits class </li>
<li>
<b>Type: </b>a class model of <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> </li>
<li>
<b>Default: </b>a CGAL <a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a> deduced from the point type, using <code><a class="elRef" href="../Kernel_23/structCGAL_1_1Kernel__traits.html">CGAL::Kernel_traits</a></code> </li>
<li>
<b>Extra: </b>The geometric traits class must be compatible with the vertex point type. </li>
<li>
<b>Extra: </b>Must be identical to the traits used in the template parameter of the <code>AABB_traits</code>. </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>snapping_tolerance</b> </button> <div class="content"><ul>
<li>
a tolerance value used to snap barycentric coordinates </li>
<li>
<b>Type: </b>double </li>
<li>
<b>Default: </b><code>0</code> </li>
<li>
<b>Extra: </b>Depending on the geometric traits used, the computation of the barycentric coordinates might be an inexact construction, thus leading to sometimes surprising values (e.g. a triplet <code>[0.5, 0.5, -1-e17]</code> for a point at the middle of an edge). The coordinates will be snapped towards <code>0</code> and <code>1</code> if the difference is smaller than the tolerance value, while still ensuring that the total sum of the coordinates is <code>1</code>. </li>
</ul>
 </div>  </td><td></td></tr>
</table>
</dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>ray</code> is an object with the same ambient dimension as the point type (the value type of the vertex point map). </dd></dl>

</div>
</div>
<a id="gac78863fa23c382d08f9944a4f70b7a75" name="gac78863fa23c382d08f9944a4f70b7a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac78863fa23c382d08f9944a4f70b7a75">◆ </a></span>random_location_on_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FT , typename TriangleMesh &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">Face_location</a>&lt; TriangleMesh, FT &gt; CGAL::Polygon_mesh_processing::random_location_on_face </td>
          <td>(</td>
          <td class="paramtype">typename boost::graph_traits&lt; TriangleMesh &gt;::face_descriptor </td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TriangleMesh &amp; </td>
          <td class="paramname"><em>tm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../Generator/classCGAL_1_1Random.html">CGAL::Random</a> &amp; </td>
          <td class="paramname"><em>rnd</em> = <code><a class="elRef" href="../Generator/group__PkgGeneratorsRef.html#gaaf28146567a47f590c4ee036527f1706">get_default_random</a>()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/locate.h&gt;</code></p>

<p>returns a random point over the face <code>fd</code>, as a location. </p>
<p>The random point is on the face, meaning that all its barycentric coordinates are positive. It is constructed by uniformly picking a value <code>u</code> between <code>0</code> and <code>1</code>, a value <code>v</code> between <code>1-u</code>, and setting the barycentric coordinates to <code>u</code>, <code>v</code>, and <code>1-u-v</code> for respectively the source and target of <code>halfedge(fd, tm)</code>, and the third point.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FT</td><td>must be a model of <code><a class="elRef" href="../Algebraic_foundations/classFieldNumberType.html">FieldNumberType</a></code> </td></tr>
    <tr><td class="paramname">TriangleMesh</td><td>must be a model of <code><a class="elRef" href="../BGL/classFaceGraph.html">FaceGraph</a></code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>a face of <code>tm</code> </td></tr>
    <tr><td class="paramname">tm</td><td>a triangulated surface mesh </td></tr>
    <tr><td class="paramname">rnd</td><td>optional random number generator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga23816d7cea5cba77e56363c5ebd17b6e" name="ga23816d7cea5cba77e56363c5ebd17b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23816d7cea5cba77e56363c5ebd17b6e">◆ </a></span>random_location_on_halfedge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FT , typename TriangleMesh &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">Face_location</a>&lt; TriangleMesh, FT &gt; CGAL::Polygon_mesh_processing::random_location_on_halfedge </td>
          <td>(</td>
          <td class="paramtype">typename boost::graph_traits&lt; TriangleMesh &gt;::halfedge_descriptor </td>
          <td class="paramname"><em>hd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TriangleMesh &amp; </td>
          <td class="paramname"><em>tm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../Generator/classCGAL_1_1Random.html">CGAL::Random</a> &amp; </td>
          <td class="paramname"><em>rnd</em> = <code><a class="elRef" href="../Generator/group__PkgGeneratorsRef.html#gaaf28146567a47f590c4ee036527f1706">get_default_random</a>()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/locate.h&gt;</code></p>

<p>returns a random point over the halfedge <code>hd</code>, as a location. </p>
<p>The random point is chosen on the halfedge, meaning that all its barycentric coordinates are positive. It is constructed by uniformly generating a value <code>t</code> between <code>0</code> and <code>1</code> and setting the barycentric coordinates to <code>t</code>, <code>1-t</code>, and <code>0</code> for respetively the source and target of <code>hd</code>, and the third vertex.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FT</td><td>must be a model of <code><a class="elRef" href="../Algebraic_foundations/classFieldNumberType.html">FieldNumberType</a></code> </td></tr>
    <tr><td class="paramname">TriangleMesh</td><td>must be a model of <code><a class="elRef" href="../BGL/classFaceGraph.html">FaceGraph</a></code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hd</td><td>a halfedge of <code>tm</code> </td></tr>
    <tr><td class="paramname">tm</td><td>a triangulated surface mesh </td></tr>
    <tr><td class="paramname">rnd</td><td>optional random number generator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6d90010ec9ad9c07c3659d12d7453d74" name="ga6d90010ec9ad9c07c3659d12d7453d74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d90010ec9ad9c07c3659d12d7453d74">◆ </a></span>random_location_on_mesh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FT , typename TriangleMesh &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">Face_location</a>&lt; TriangleMesh, FT &gt; CGAL::Polygon_mesh_processing::random_location_on_mesh </td>
          <td>(</td>
          <td class="paramtype">const TriangleMesh &amp; </td>
          <td class="paramname"><em>tm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../Generator/classCGAL_1_1Random.html">CGAL::Random</a> &amp; </td>
          <td class="paramname"><em>rnd</em> = <code><a class="elRef" href="../Generator/group__PkgGeneratorsRef.html#gaaf28146567a47f590c4ee036527f1706">get_default_random</a>()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Polygon_mesh_processing/locate.h&gt;</code></p>

<p>returns a random point over the mesh <code>tm</code>. </p>
<p>The returned location is obtained by choosing a random face of the mesh and a random point on that face. The barycentric coordinates of the point in the face are thus all positive. Note that all faces have the same probability to be chosen.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FT</td><td>must be a model of <code><a class="elRef" href="../Algebraic_foundations/classFieldNumberType.html">FieldNumberType</a></code> </td></tr>
    <tr><td class="paramname">TriangleMesh</td><td>must be a model of <code><a class="elRef" href="../BGL/classFaceGraph.html">FaceGraph</a></code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tm</td><td>a triangulated surface mesh </td></tr>
    <tr><td class="paramname">rnd</td><td>optional random number generator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__PMP__locate__grp.html#gac78863fa23c382d08f9944a4f70b7a75" title="returns a random point over the face fd, as a location.">random_location_on_face()</a></code> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"></a> 1.9.6 </li>
  </ul>
</div>
</div>
</body>

</html>
