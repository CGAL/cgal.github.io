<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Interpolation/group__PkgInterpolationSibsonGradientFitting.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=11">
<meta name="generator" content="Doxygen 1.9.6">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CGAL 6.2 - 2D and Surface Function Interpolation: Sibson Gradient Fitting Functions</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/doxygen.css" rel="stylesheet" type="text/css">
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      },
      equationNumbers: { autoNumber: "AMS" }
  }
}
);
MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
  var PARSE = MathJax.InputJax.TeX.Parse,
      TEXT = PARSE.prototype.InternalText;
  PARSE.Augment({
    InternalText: function (text,def) {
      text = text.replace(/\\/g,"");
      return TEXT.call(this,text,def);
    }
  });
});
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
      <span class="left">
         <span id="MSearchSelect" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"> 
        </span>
        <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
      </span>
      <span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.svg" alt=""></a>
      </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CGAL 6.2 - 2D and Surface Function Interpolation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search/",'.html');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__PkgInterpolationSibsonGradientFitting.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Sibson Gradient Fitting Functions<div class="ingroups"><a class="el" href="group__PkgInterpolation2Ref.html">Reference Manual</a> » <a class="el" href="group__PkgInterpolation2Interpolation.html">Interpolation Functions</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader"> </h2>
<p>The first function implements Sibson's gradient estimation method based on natural neighbor coordinates <a class="el" href="citelist.html#CITEREF_s-bdnni-81">[9]</a>. </p>
<p>Further functions are provided to fit the gradient for all data points that lie inside the convex hull of the data points. One function exists for each type of neighbor coordinates (natural and regular).</p>
<p><b>Output Format</b><br>
</p>
<p>The output format of the functions <code><a class="el" href="group__PkgInterpolationSibsonGradientFitting.html#ga2063ef2d118d601f4d0789ffcf2c191f" title="Estimates the function gradients at all vertices of the Delaunay triangulation dt that lie inside the...">CGAL::sibson_gradient_fitting_nn_2()</a></code> and <code><a class="el" href="group__PkgInterpolationSibsonGradientFitting.html#gadd232ce2ff777c055c039aa9bcff7e90" title="Estimates the function gradients at all vertices of rt that lie inside the convex hull using the coor...">CGAL::sibson_gradient_fitting_rn_2()</a></code> can be customized using the functor parameter of type <code>OutputFunctor</code>: this functor must have argument type <code>std::pair&lt;Tr::Vertex_handle, Traits::Vector_d&gt;</code> (where <code>Tr</code> and <code>Traits</code> are the types of the triangulation and traits passed in arguments) but its result type is set as desired by the user.</p>
<p>See also <a class="el" href="group__PkgInterpolationNaturalNeighborCoordinates2.html">natural neighbor coordinates functions</a>, which use the same mechanism to allow flexible output.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classCGAL_1_1Interpolation__gradient__fitting__traits__2.html" title="Interpolation_gradient_fitting_traits_2 is a model for the concepts InterpolationTraits and GradientF...">CGAL::Interpolation_gradient_fitting_traits_2</a>&lt;K&gt;</code> </dd>
<dd>
<code><a class="el" href="group__PkgInterpolationNaturalNeighborCoordinates2.html" title="The functions natural_neighbor_coordinates_2() compute natural neighbor coordinates,...">CGAL::natural_neighbor_coordinates_2()</a></code> </dd>
<dd>
<code><a class="el" href="group__PkgInterpolationRegularNeighborCoordinates2.html" title="The functions regular_neighbor_coordinates_2() compute natural neighbor coordinates,...">CGAL::regular_neighbor_coordinates_2()</a></code> </dd>
<dd>
<code><a class="el" href="group__PkgInterpolationSurfaceNeighborCoordinates3.html" title="The functions surface_neighbor_coordinates_3() compute natural neighbor coordinates for surface point...">3D Surface Neighbor Coordinates Functions</a></code> </dd>
<dd>
<code><a class="el" href="group__PkgInterpolation2Interpolation.html">Interpolation Functions</a></code> </dd></dl>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9c4601224b6352ed583f247fe3fee826"><td class="memTemplParams" colspan="2">template&lt;class CoordinateInputIterator , class ValueFunctor , class Traits , class Point &gt; </td></tr>
<tr class="memitem:ga9c4601224b6352ed583f247fe3fee826"><td class="memTemplItemLeft" align="right" valign="top">Traits::Vector_d </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgInterpolationSibsonGradientFitting.html#ga9c4601224b6352ed583f247fe3fee826">CGAL::sibson_gradient_fitting</a> (CoordinateInputIterator first, CoordinateInputIterator beyond, const typename std::iterator_traits&lt; CoordinateInputIterator &gt;::value_type::second_type &amp;norm, const Point &amp;p, ValueFunctor value_function, const typename ValueFunctor::result_type::first_type fn, const Traits &amp;traits)</td></tr>
<tr class="memdesc:ga9c4601224b6352ed583f247fe3fee826"><td class="mdescLeft"> </td><td class="mdescRight">Estimates the gradient of a function at a query point.  <br></td></tr>
<tr class="separator:ga9c4601224b6352ed583f247fe3fee826"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga2063ef2d118d601f4d0789ffcf2c191f"><td class="memTemplParams" colspan="2">template&lt;class Dt , class GradientOutputIterator , class OutputFunctor , class ValueFunctor , class Traits &gt; </td></tr>
<tr class="memitem:ga2063ef2d118d601f4d0789ffcf2c191f"><td class="memTemplItemLeft" align="right" valign="top">GradientOutputIterator </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgInterpolationSibsonGradientFitting.html#ga2063ef2d118d601f4d0789ffcf2c191f">CGAL::sibson_gradient_fitting_nn_2</a> (const Dt &amp;dt, GradientOutputIterator out, OutputFunctor fct, ValueFunctor value_function, const Traits &amp;traits)</td></tr>
<tr class="memdesc:ga2063ef2d118d601f4d0789ffcf2c191f"><td class="mdescLeft"> </td><td class="mdescRight">Estimates the function gradients at all vertices of the Delaunay triangulation <code>dt</code> that lie inside the convex hull, using the coordinates computed by the function <a class="el" href="group__PkgInterpolationNaturalNeighborCoordinates2.html">CGAL::natural_neighbor_coordinates_2()</a>.  <br></td></tr>
<tr class="separator:ga2063ef2d118d601f4d0789ffcf2c191f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gadd232ce2ff777c055c039aa9bcff7e90"><td class="memTemplParams" colspan="2">template&lt;class Rt , class GradientOutputIterator , class OutputFunctor , class ValueFunctor , class Traits &gt; </td></tr>
<tr class="memitem:gadd232ce2ff777c055c039aa9bcff7e90"><td class="memTemplItemLeft" align="right" valign="top">GradientOutputIterator </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgInterpolationSibsonGradientFitting.html#gadd232ce2ff777c055c039aa9bcff7e90">CGAL::sibson_gradient_fitting_rn_2</a> (const Rt &amp;rt, GradientOutputIterator out, OutputFunctor fct, ValueFunctor value_function, const Traits &amp;traits)</td></tr>
<tr class="memdesc:gadd232ce2ff777c055c039aa9bcff7e90"><td class="mdescLeft"> </td><td class="mdescRight">Estimates the function gradients at all vertices of <code>rt</code> that lie inside the convex hull using the coordinates computed by the functions <a class="el" href="group__PkgInterpolationRegularNeighborCoordinates2.html">CGAL::regular_neighbor_coordinates_2()</a>.  <br></td></tr>
<tr class="separator:gadd232ce2ff777c055c039aa9bcff7e90"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga9c4601224b6352ed583f247fe3fee826" name="ga9c4601224b6352ed583f247fe3fee826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c4601224b6352ed583f247fe3fee826">◆ </a></span>sibson_gradient_fitting()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CoordinateInputIterator , class ValueFunctor , class Traits , class Point &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Traits::Vector_d CGAL::sibson_gradient_fitting </td>
          <td>(</td>
          <td class="paramtype">CoordinateInputIterator </td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoordinateInputIterator </td>
          <td class="paramname"><em>beyond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename std::iterator_traits&lt; CoordinateInputIterator &gt;::value_type::second_type &amp; </td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point &amp; </td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueFunctor </td>
          <td class="paramname"><em>value_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename ValueFunctor::result_type::first_type </td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Traits &amp; </td>
          <td class="paramname"><em>traits</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/sibson_gradient_fitting.h&gt;</code></p>

<p>Estimates the gradient of a function at a query point. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CoordinateInputIterator</td><td>must be a model of <code><a class="elRef" href="../Manual/classForwardIterator.html">ForwardIterator</a></code> and must have as value type a pair associating an entity to a (non-normalized) barycentric coordinate. More precisely, <code>std::iterator_traits&lt;CoordinateInputIterator&gt;::value_type::first_type</code> can be of the following types: <ul>
<li>
a type equivalent to <code>Traits::Point_d</code> or <code>Traits::Weighted_point_d</code>  </li>
<li>
an iterator type providing a <code>point()</code> function returning a type equivalent to <code>Traits::Point_d</code> or <code>Traits::Weighted_point_d</code>;  </li>
</ul>
and <code>std::iterator_traits&lt;CoordinateInputIterator&gt;::value_type::second_type</code> must be equivalent to <code>Traits::FT</code>. </td></tr>
    <tr><td class="paramname">ValueFunctor</td><td>must be a functor where <code>ValueFunctor::argument_type</code> must be equivalent to <code>std::iterator_traits&lt;CoordinateInputIterator&gt;::value_type::first_type</code> and <code>ValueFunctor::result_type</code> is a pair of the function value type and a Boolean. The function value type must provide a multiplication and addition operation with the type <code>Traits::FT</code> as well as a constructor with argument <code>0</code>. </td></tr>
    <tr><td class="paramname">Traits</td><td>must be a model of the concept <code><a class="el" href="classGradientFittingTraits.html" title="Sibson Gradient Fitting Functions are parameterized by a traits class that defines the primitives use...">GradientFittingTraits</a></code>. </td></tr>
    <tr><td class="paramname">Point</td><td>must be equivalent to <code>Traits::Point_d</code> or <code>Traits::Weighted_point_d</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>An example of compatible types for <code>CoordinateInputIterator</code> and <code>ValueFunctor</code> is a forward iterator with value type <code>std::pair&lt;Vertex_handle, Traits::FT&gt;</code> and a functor with argument type <code>Vertex_handle</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first,beyond</td><td>is the iterator range of the neighbor coordinates for the query point <code>p</code>. </td></tr>
    <tr><td class="paramname">norm</td><td>is the normalization factor. </td></tr>
    <tr><td class="paramname">p</td><td>is the query point </td></tr>
    <tr><td class="paramname">value_function</td><td>is a functor that allows to access values of the interpolated function. </td></tr>
    <tr><td class="paramname">fn</td><td>is the value of the function at <code>p</code>. </td></tr>
    <tr><td class="paramname">traits</td><td>is an instance of the gradient fitting traits class.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the gradient at the point <code>p</code>. </dd></dl>

</div>
</div>
<a id="ga2063ef2d118d601f4d0789ffcf2c191f" name="ga2063ef2d118d601f4d0789ffcf2c191f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2063ef2d118d601f4d0789ffcf2c191f">◆ </a></span>sibson_gradient_fitting_nn_2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Dt , class GradientOutputIterator , class OutputFunctor , class ValueFunctor , class Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GradientOutputIterator CGAL::sibson_gradient_fitting_nn_2 </td>
          <td>(</td>
          <td class="paramtype">const Dt &amp; </td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GradientOutputIterator </td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputFunctor </td>
          <td class="paramname"><em>fct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueFunctor </td>
          <td class="paramname"><em>value_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Traits &amp; </td>
          <td class="paramname"><em>traits</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/sibson_gradient_fitting.h&gt;</code></p>

<p>Estimates the function gradients at all vertices of the Delaunay triangulation <code>dt</code> that lie inside the convex hull, using the coordinates computed by the function <a class="el" href="group__PkgInterpolationNaturalNeighborCoordinates2.html">CGAL::natural_neighbor_coordinates_2()</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Dt</td><td>must be of type <code><a class="elRef" href="../Triangulation_2/classCGAL_1_1Delaunay__triangulation__2.html">Delaunay_triangulation_2</a>&lt;Dt_Traits, Tds&gt;</code>. <code>Dt_Traits</code> must be a model of the concepts <code><a class="elRef" href="../Triangulation_2/classDelaunayTriangulationTraits__2.html">DelaunayTriangulationTraits_2</a></code> and <code><a class="elRef" href="../Polygon/classPolygonTraits__2.html">PolygonTraits_2</a></code>. </td></tr>
    <tr><td class="paramname">GradientOutputIterator</td><td>must be a model of <code><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a></code> with value type <code>OutputFunctor::result_type</code>. </td></tr>
    <tr><td class="paramname">OutputFunctor</td><td>must be a functor with argument type <code>std::pair&lt;Dt::Vertex_handle, Traits::Vector_d&gt;</code>. Note that the result type of the functor is not specified and is chosen by users to fit their needs. </td></tr>
    <tr><td class="paramname">ValueFunctor</td><td>must be a functor where:<ul>
<li><code>ValueFunctor::argument_type</code> must be either <code>Dt::Vertex_handle</code> or <code>Dt::Point</code>.</li>
<li><code>ValueFunctor::result_type</code> is a pair of the function value type and a Boolean. The function value type must provide a multiplication and addition operation with the type <code>Traits::FT</code> as well as a constructor with argument <code>0</code>. </li>
</ul>
</td></tr>
    <tr><td class="paramname">Traits</td><td>must be a model of <code><a class="el" href="classGradientFittingTraits.html" title="Sibson Gradient Fitting Functions are parameterized by a traits class that defines the primitives use...">GradientFittingTraits</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dt</td><td>is the Delaunay triangulation. </td></tr>
    <tr><td class="paramname">out</td><td>is an object of type <code>GradientOutputIterator</code>. </td></tr>
    <tr><td class="paramname">fct</td><td>is an object of type <code>OutputFunctor</code>. </td></tr>
    <tr><td class="paramname">value_function</td><td>is a functor of type <code>ValueFunctor</code> that gives access to the values of the function at points of the triangulation. </td></tr>
    <tr><td class="paramname">traits</td><td>is an instance of the gradient fitting traits class.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An output iterator with value type <code>OutputFunctor::result_type</code>. The sequence is written starting at <code>out</code>. The function returns an iterator that is placed past-the-end of the resulting sequence. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Interpolation_2sibson_interpolation_vertex_with_info_2_8cpp-example.html#a6">Interpolation/sibson_interpolation_vertex_with_info_2.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="gadd232ce2ff777c055c039aa9bcff7e90" name="gadd232ce2ff777c055c039aa9bcff7e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd232ce2ff777c055c039aa9bcff7e90">◆ </a></span>sibson_gradient_fitting_rn_2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Rt , class GradientOutputIterator , class OutputFunctor , class ValueFunctor , class Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GradientOutputIterator CGAL::sibson_gradient_fitting_rn_2 </td>
          <td>(</td>
          <td class="paramtype">const Rt &amp; </td>
          <td class="paramname"><em>rt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GradientOutputIterator </td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputFunctor </td>
          <td class="paramname"><em>fct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueFunctor </td>
          <td class="paramname"><em>value_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Traits &amp; </td>
          <td class="paramname"><em>traits</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/sibson_gradient_fitting.h&gt;</code></p>

<p>Estimates the function gradients at all vertices of <code>rt</code> that lie inside the convex hull using the coordinates computed by the functions <a class="el" href="group__PkgInterpolationRegularNeighborCoordinates2.html">CGAL::regular_neighbor_coordinates_2()</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rt</td><td>must be of type <code><a class="elRef" href="../Triangulation_2/classCGAL_1_1Regular__triangulation__2.html">Regular_triangulation_2</a>&lt;Rt_Traits, Tds&gt;</code>. <code>Rt_Traits</code> must be a model of the concepts <code><a class="elRef" href="../Triangulation_2/classRegularTriangulationTraits__2.html">RegularTriangulationTraits_2</a></code> and <code><a class="elRef" href="../Polygon/classPolygonTraits__2.html">PolygonTraits_2</a></code>. </td></tr>
    <tr><td class="paramname">GradientOutputIterator</td><td>must be a model of <code><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a></code> with value type <code>OutputFunctor::result_type</code>. </td></tr>
    <tr><td class="paramname">OutputFunctor</td><td>must be a functor with argument type <code>std::pair&lt;Rt::Vertex_handle, Traits::Vector_d&gt;</code>. Note that the result type of the functor is not specified and is chosen by users to fit their needs. </td></tr>
    <tr><td class="paramname">ValueFunctor</td><td>must be a functor where:<ul>
<li><code>ValueFunctor::argument_type</code> must be either <code>Rt::Vertex_handle</code> or <code>Rt::Weighted_point</code>.</li>
<li><code>ValueFunctor::result_type</code> is a pair of the function value type and a Boolean. The function value type must provide a multiplication and addition operation with the type <code>Traits::FT</code> as well as a constructor with argument <code>0</code>. </li>
</ul>
</td></tr>
    <tr><td class="paramname">Traits</td><td>must be a model of <code><a class="el" href="classGradientFittingTraits.html" title="Sibson Gradient Fitting Functions are parameterized by a traits class that defines the primitives use...">GradientFittingTraits</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rt</td><td>is the regular triangulation. </td></tr>
    <tr><td class="paramname">out</td><td>is an object of type <code>GradientOutputIterator</code>. </td></tr>
    <tr><td class="paramname">fct</td><td>is an object of type <code>OutputFunctor</code>. </td></tr>
    <tr><td class="paramname">value_function</td><td>is a functor of type <code>ValueFunctor</code> that gives access to the values of the function at points of the triangulation. </td></tr>
    <tr><td class="paramname">traits</td><td>is an instance of the gradient fitting traits class.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An output iterator with value type <code>OutputFunctor::result_type</code>. The sequence is written starting at <code>out</code>. The function returns an iterator that is placed past-the-end of the resulting sequence. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"></a> 1.9.6 </li>
  </ul>
</div>
</div>
</body>

</html>
