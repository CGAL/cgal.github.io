<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Arrangement_on_surface_2/group__PkgArrangementOnSurface2Funcs.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=11">
<meta name="generator" content="Doxygen 1.9.6">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CGAL 6.0 - 2D Arrangements: Free Functions</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/doxygen.css" rel="stylesheet" type="text/css">
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      },
      equationNumbers: { autoNumber: "AMS" }
  }
}
);
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
      <span class="left">
         <span id="MSearchSelect" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"> 
        </span>
        <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
      </span>
      <span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.svg" alt=""></a>
      </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CGAL 6.0 - 2D Arrangements
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search/",'.html');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__PkgArrangementOnSurface2Funcs.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> |
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Free Functions<div class="ingroups"><a class="el" href="group__PkgArrangementOnSurface2Ref.html">2D Arrangement Reference</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader"> </h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__PkgArrangementOnSurface2Insert"><td class="memItemLeft" align="right" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="group__PkgArrangementOnSurface2Insert.html">CGAL::insert()</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga339cdba93f54001be303595689002396"><td class="memTemplParams" colspan="2">template&lt;class GeomTraitsA , class GeomTraitsB , class GeomTraitsRes , class TopTraitsA , class TopTraitsB , class TopTraitsRes , class <a class="el" href="classOverlayTraits.html">OverlayTraits</a> &gt; </td></tr>
<tr class="memitem:ga339cdba93f54001be303595689002396"><td class="memTemplItemLeft" align="right" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#ga339cdba93f54001be303595689002396">CGAL::overlay</a> (const <a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; GeomTraitsA, TopTraitsA &gt; &amp;arr1, const <a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; GeomTraitsB, TopTraitsB &gt; &amp;arr2, <a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; GeomTraitsRes, TopTraitsRes &gt; &amp;arr_res, <a class="el" href="classOverlayTraits.html">OverlayTraits</a> &amp;ovl_tr)</td></tr>
<tr class="memdesc:ga339cdba93f54001be303595689002396"><td class="mdescLeft"> </td><td class="mdescRight">Computes the overlay of two arrangements <code>arr1</code> and <code>arr2</code>, and sets the output arrangement <code>res</code> to represent the overlaid arrangement.  <br></td></tr>
<tr class="separator:ga339cdba93f54001be303595689002396"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaddb9e44b14b27e4cf0c7bb26b27d8518"><td class="memTemplParams" colspan="2">template&lt;typename Traits , typename Dcel1 , typename Dcel2 , typename ResDcel , typename <a class="el" href="classOverlayTraits.html">OverlayTraits</a> &gt; </td></tr>
<tr class="memitem:gaddb9e44b14b27e4cf0c7bb26b27d8518"><td class="memTemplItemLeft" align="right" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#gaddb9e44b14b27e4cf0c7bb26b27d8518">CGAL::overlay</a> (const <a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a>&lt; Traits, Dcel1 &gt; &amp;arr1, const <a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a>&lt; Traits, Dcel2 &gt; &amp;arr2, <a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a>&lt; Traits, ResDcel &gt; &amp;res, <a class="el" href="classOverlayTraits.html">OverlayTraits</a> &amp;ovl_tr)</td></tr>
<tr class="memdesc:gaddb9e44b14b27e4cf0c7bb26b27d8518"><td class="mdescLeft"> </td><td class="mdescRight">Computes the overlay of two arrangements with history <code>arr1</code> and <code>arr2</code>, and sets the output arrangement with history <code>res</code> to represent the overlaid arrangement.  <br></td></tr>
<tr class="separator:gaddb9e44b14b27e4cf0c7bb26b27d8518"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga6250573eaa94af687154326513c2cd2c"><td class="memTemplParams" colspan="2">template&lt;typename Traits , typename TopologyTraits , typename <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> &gt; </td></tr>
<tr class="memitem:ga6250573eaa94af687154326513c2cd2c"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#ga6250573eaa94af687154326513c2cd2c">CGAL::decompose</a> (const <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html">Arrangement_on_surface_2</a>&lt; GeometryTraits, TopologyTraits &gt; &amp;arr, <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> oi)</td></tr>
<tr class="memdesc:ga6250573eaa94af687154326513c2cd2c"><td class="mdescLeft"> </td><td class="mdescRight">produces the symbolic vertical decomposition of a given arrangement.  <br></td></tr>
<tr class="separator:ga6250573eaa94af687154326513c2cd2c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga9dd10a3efed93328acef4e4bcb175df9"><td class="memTemplParams" colspan="2">template&lt;typename Traits , typename Dcel , typename PointLocation &gt; </td></tr>
<tr class="memitem:ga9dd10a3efed93328acef4e4bcb175df9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; Traits, Dcel &gt;::Halfedge_handle </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#ga9dd10a3efed93328acef4e4bcb175df9">CGAL::insert_non_intersecting_curve</a> (<a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; Traits, Dcel &gt; &amp;arr, const typename Traits::X_monotone_curve_2 &amp;xc, const PointLocation &amp;pl=walk_pl)</td></tr>
<tr class="memdesc:ga9dd10a3efed93328acef4e4bcb175df9"><td class="mdescLeft"> </td><td class="mdescRight">Inserts a given \( x\)-monotone curve into a given arrangement, where the interior of the given curve is disjoint from all existing arrangement vertices and edges.  <br></td></tr>
<tr class="separator:ga9dd10a3efed93328acef4e4bcb175df9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gad4aa37a4e938747028690579fb703d67"><td class="memTemplParams" colspan="2">template&lt;typename Traits , typename Dcel , <a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> &gt; </td></tr>
<tr class="memitem:gad4aa37a4e938747028690579fb703d67"><td class="memTemplItemLeft" align="right" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#gad4aa37a4e938747028690579fb703d67">CGAL::insert_non_intersecting_curves</a> (<a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; Traits, Dcel &gt; &amp;arr, <a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> first, <a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> last)</td></tr>
<tr class="memdesc:gad4aa37a4e938747028690579fb703d67"><td class="mdescLeft"> </td><td class="mdescRight">Inserts a set of \( x\)-monotone curves in a given range into a given arrangement.  <br></td></tr>
<tr class="separator:gad4aa37a4e938747028690579fb703d67"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gabfaca749e7d8c9547c143032a0e9df08"><td class="memTemplParams" colspan="2">template&lt;typename Traits , typename Dcel , typename PointLocation &gt; </td></tr>
<tr class="memitem:gabfaca749e7d8c9547c143032a0e9df08"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; Traits, Dcel &gt;::Vertex_handle </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#gabfaca749e7d8c9547c143032a0e9df08">CGAL::insert_point</a> (<a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; Traits, Dcel &gt; &amp;arr, const typename Traits::Point_2 &amp;p, const PointLocation &amp;pl=walk_pl)</td></tr>
<tr class="memdesc:gabfaca749e7d8c9547c143032a0e9df08"><td class="mdescLeft"> </td><td class="mdescRight">Inserts a given point into a given arrangement.  <br></td></tr>
<tr class="separator:gabfaca749e7d8c9547c143032a0e9df08"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gabcb9bc6c5859edf3fbc1390e60e32a17"><td class="memTemplParams" colspan="2">template&lt;typename Traits , typename Dcel &gt; </td></tr>
<tr class="memitem:gabcb9bc6c5859edf3fbc1390e60e32a17"><td class="memTemplItemLeft" align="right" valign="top">bool </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#gabcb9bc6c5859edf3fbc1390e60e32a17">CGAL::is_valid</a> (const <a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; Traits, Dcel &gt; &amp;arr)</td></tr>
<tr class="memdesc:gabcb9bc6c5859edf3fbc1390e60e32a17"><td class="mdescLeft"> </td><td class="mdescRight">Checks the validity of a given arrangement.  <br></td></tr>
<tr class="separator:gabcb9bc6c5859edf3fbc1390e60e32a17"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gad41fab113e4ec35768bbcdfc6f3c54c4"><td class="memTemplParams" colspan="2">template&lt;typename Traits , typename Dcel &gt; </td></tr>
<tr class="memitem:gad41fab113e4ec35768bbcdfc6f3c54c4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; Traits, Dcel &gt;::Face_handle </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#gad41fab113e4ec35768bbcdfc6f3c54c4">CGAL::remove_edge</a> (<a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; Traits, Dcel &gt; &amp;arr, typename <a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; Traits, Dcel &gt;::Halfedge_handle e)</td></tr>
<tr class="memdesc:gad41fab113e4ec35768bbcdfc6f3c54c4"><td class="mdescLeft"> </td><td class="mdescRight">Removes an edge given by one of the twin halfedges that forms it, from a given arrangement.  <br></td></tr>
<tr class="separator:gad41fab113e4ec35768bbcdfc6f3c54c4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gacbb4f22a59c77fb06a9d544cbbb04778"><td class="memTemplParams" colspan="2">template&lt;typename Traits , typename Dcel &gt; </td></tr>
<tr class="memitem:gacbb4f22a59c77fb06a9d544cbbb04778"><td class="memTemplItemLeft" align="right" valign="top">bool </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#gacbb4f22a59c77fb06a9d544cbbb04778">CGAL::remove_vertex</a> (<a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; Traits, Dcel &gt; &amp;arr, typename <a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; Traits, Dcel &gt;::Vertex_handle v)</td></tr>
<tr class="memdesc:gacbb4f22a59c77fb06a9d544cbbb04778"><td class="mdescLeft"> </td><td class="mdescRight">Attempts to removed a given vertex from a given arrangement.  <br></td></tr>
<tr class="separator:gacbb4f22a59c77fb06a9d544cbbb04778"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga7598937d11570bdedd5f3b6491065940"><td class="memTemplParams" colspan="2">template&lt;typename GeometryTraits , typename TopologyTraits , typename Curve , typename PointLocation &gt; </td></tr>
<tr class="memitem:ga7598937d11570bdedd5f3b6491065940"><td class="memTemplItemLeft" align="right" valign="top">bool </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#ga7598937d11570bdedd5f3b6491065940">CGAL::do_intersect</a> (<a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html">Arrangement_on_surface_2</a>&lt; GeometryTraits, TopologyTraits &gt; &amp;arr, const Curve &amp;c, const PointLocation &amp;pl)</td></tr>
<tr class="memdesc:ga7598937d11570bdedd5f3b6491065940"><td class="mdescLeft"> </td><td class="mdescRight">Checks if a given curve or \(x\)-monotone curve intersects an existing arrangement's edges or vertices.  <br></td></tr>
<tr class="separator:ga7598937d11570bdedd5f3b6491065940"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gad2c812247ce5c1dd592c0e0be74a1fc8"><td class="memTemplParams" colspan="2">template&lt;typename GeometryTraits , typename TopologyTraits , typename PointLocation &gt; </td></tr>
<tr class="memitem:gad2c812247ce5c1dd592c0e0be74a1fc8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html">Arrangement_on_surface_2</a>&lt; GeometryTraits, TopologyTraits &gt;::Halfedge_handle </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#gad2c812247ce5c1dd592c0e0be74a1fc8">CGAL::insert_non_intersecting_curve</a> (<a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html">Arrangement_on_surface_2</a>&lt; GeometryTraits, TopologyTraits &gt; &amp;arr, const typename Traits::X_monotone_curve_2 &amp;xc, const PointLocation &amp;pl=walk_pl)</td></tr>
<tr class="memdesc:gad2c812247ce5c1dd592c0e0be74a1fc8"><td class="mdescLeft"> </td><td class="mdescRight">Inserts a given \( x\)-monotone curve into a given arrangement, where the given curve and the existing arrangement edges (more precisely, the curves geometric mappings of the edges) must be pairwise disjoint in their interiors, and the interior of the input curve must not contain existing arrangement vertices (more precisely, the points geometric mappings of the vertices).  <br></td></tr>
<tr class="separator:gad2c812247ce5c1dd592c0e0be74a1fc8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gab168a4f4aa766c5bd670d82f4793f16d"><td class="memTemplParams" colspan="2">template&lt;typename GeometryTraits , typename TopologyTraits , typename <a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> &gt; </td></tr>
<tr class="memitem:gab168a4f4aa766c5bd670d82f4793f16d"><td class="memTemplItemLeft" align="right" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#gab168a4f4aa766c5bd670d82f4793f16d">CGAL::insert_non_intersecting_curves</a> (<a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html">Arrangement_on_surface_2</a>&lt; GeometryTraits, TopologyTraits &gt; &amp;arr, <a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> first, <a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> last)</td></tr>
<tr class="memdesc:gab168a4f4aa766c5bd670d82f4793f16d"><td class="mdescLeft"> </td><td class="mdescRight">Inserts a set of \( x\)-monotone curves in a given range into a given arrangement.  <br></td></tr>
<tr class="separator:gab168a4f4aa766c5bd670d82f4793f16d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga20598ef738aed142f32617212dc861d9"><td class="memTemplParams" colspan="2">template&lt;typename GeometryTraits , typename TopologyTraits , typename PointLocation &gt; </td></tr>
<tr class="memitem:ga20598ef738aed142f32617212dc861d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html">Arrangement_on_surface_2</a>&lt; GeometryTraits, TopologyTraits &gt;::Vertex_handle </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#ga20598ef738aed142f32617212dc861d9">CGAL::insert_point</a> (<a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html">Arrangement_on_surface_2</a>&lt; GeometryTraits, TopologyTraits &gt; &amp;arr, const typename Traits::Point_2 &amp;p, const PointLocation &amp;pl=walk_pl)</td></tr>
<tr class="memdesc:ga20598ef738aed142f32617212dc861d9"><td class="mdescLeft"> </td><td class="mdescRight">Inserts a given point into a given arrangement.  <br></td></tr>
<tr class="separator:ga20598ef738aed142f32617212dc861d9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gafd685214e9dcdfe2186b4d9b7f76f37e"><td class="memTemplParams" colspan="2">template&lt;typename GeometryTraits , typename TopologyTraits &gt; </td></tr>
<tr class="memitem:gafd685214e9dcdfe2186b4d9b7f76f37e"><td class="memTemplItemLeft" align="right" valign="top">bool </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#gafd685214e9dcdfe2186b4d9b7f76f37e">CGAL::is_valid</a> (const <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html">Arrangement_on_surface_2</a>&lt; GeometryTraits, TopologyTraits &gt; &amp;arr)</td></tr>
<tr class="memdesc:gafd685214e9dcdfe2186b4d9b7f76f37e"><td class="mdescLeft"> </td><td class="mdescRight">Checks the validity of a given arrangement.  <br></td></tr>
<tr class="separator:gafd685214e9dcdfe2186b4d9b7f76f37e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaaa3cb37bae2483e238ede133951e3088"><td class="memTemplParams" colspan="2">template&lt;typename GeometryTraits , typename TopologyTraits &gt; </td></tr>
<tr class="memitem:gaaa3cb37bae2483e238ede133951e3088"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html">Arrangement_on_surface_2</a>&lt; GeometryTraits, TopologyTraits &gt;::Face_handle </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#gaaa3cb37bae2483e238ede133951e3088">CGAL::remove_edge</a> (<a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html">Arrangement_on_surface_2</a>&lt; GeometryTraits, TopologyTraits &gt; &amp;arr, typename <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html">Arrangement_on_surface_2</a>&lt; GeometryTraits, TopologyTraits &gt;::Halfedge_handle e)</td></tr>
<tr class="memdesc:gaaa3cb37bae2483e238ede133951e3088"><td class="mdescLeft"> </td><td class="mdescRight">Removes an edge given by one of the twin halfedges that forms it, from a given arrangement.  <br></td></tr>
<tr class="separator:gaaa3cb37bae2483e238ede133951e3088"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga5eca39557780532185639e02ce4ecf83"><td class="memTemplParams" colspan="2">template&lt;typename GeometryTraits , typename TopologyTraits &gt; </td></tr>
<tr class="memitem:ga5eca39557780532185639e02ce4ecf83"><td class="memTemplItemLeft" align="right" valign="top">bool </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#ga5eca39557780532185639e02ce4ecf83">CGAL::remove_vertex</a> (<a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html">Arrangement_on_surface_2</a>&lt; GeometryTraits, TopologyTraits &gt; &amp;arr, typename <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html">Arrangement_on_surface_2</a>&lt; GeometryTraits, TopologyTraits &gt;::Vertex_handle v)</td></tr>
<tr class="memdesc:ga5eca39557780532185639e02ce4ecf83"><td class="mdescLeft"> </td><td class="mdescRight">Attempts to removed a given vertex from a given arrangement.  <br></td></tr>
<tr class="separator:ga5eca39557780532185639e02ce4ecf83"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga52ccca744c113ea53ae30cdf6c70b295"><td class="memTemplParams" colspan="2">template&lt;typename GeometryTraits , typename TopologyTraits , typename <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> , typename PointLocation &gt; </td></tr>
<tr class="memitem:ga52ccca744c113ea53ae30cdf6c70b295"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#ga52ccca744c113ea53ae30cdf6c70b295">CGAL::zone</a> (<a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html">Arrangement_on_surface_2</a>&lt; GeometryTraits, TopologyTraits &gt; &amp;arr, const typename GeometryTraits::X_monotone_curve_2 &amp;c, <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> oi, const PointLocation &amp;pl)</td></tr>
<tr class="memdesc:ga52ccca744c113ea53ae30cdf6c70b295"><td class="mdescLeft"> </td><td class="mdescRight">computes the zone of the given \(x\)-monotone curve in a given arrangement.  <br></td></tr>
<tr class="separator:ga52ccca744c113ea53ae30cdf6c70b295"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaa323bd67be0dc7cc326eb4f26653e326"><td class="memTemplParams" colspan="2">template&lt;typename GeometryTraits , typename TopologyTraits &gt; </td></tr>
<tr class="memitem:gaa323bd67be0dc7cc326eb4f26653e326"><td class="memTemplItemLeft" align="right" valign="top">Size </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#gaa323bd67be0dc7cc326eb4f26653e326">CGAL::remove_curve</a> (<a class="el" href="classCGAL_1_1Arrangement__on__surface__with__history__2.html">Arrangement_on_surface_with_history_2</a>&lt; GeometryTraits, TopologyTraits &gt; &amp;arr, typename <a class="el" href="classCGAL_1_1Arrangement__on__surface__with__history__2.html">Arrangement_on_surface_with_history_2</a>&lt; GeometryTraits, TopologyTraits &gt;::Curve_handle ch)</td></tr>
<tr class="memdesc:gaa323bd67be0dc7cc326eb4f26653e326"><td class="mdescLeft"> </td><td class="mdescRight">Removes a given curve from a given arrangement.  <br></td></tr>
<tr class="separator:gaa323bd67be0dc7cc326eb4f26653e326"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga9a27533ff4ade0c60978812e517b89d9"><td class="memTemplParams" colspan="2">template&lt;typename Traits , typename Dcel &gt; </td></tr>
<tr class="memitem:ga9a27533ff4ade0c60978812e517b89d9"><td class="memTemplItemLeft" align="right" valign="top">Size </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#ga9a27533ff4ade0c60978812e517b89d9">CGAL::remove_curve</a> (<a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a>&lt; Traits, Dcel &gt; &amp;arr, typename <a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a>&lt; Traits, Dcel &gt;::Curve_handle ch)</td></tr>
<tr class="memdesc:ga9a27533ff4ade0c60978812e517b89d9"><td class="mdescLeft"> </td><td class="mdescRight">Removes a given curvespecified by its handle <code>ch</code>, from a given arrangement <code>arr</code>, deleting all the edges it induces.  <br></td></tr>
<tr class="separator:ga9a27533ff4ade0c60978812e517b89d9"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga6250573eaa94af687154326513c2cd2c" name="ga6250573eaa94af687154326513c2cd2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6250573eaa94af687154326513c2cd2c">◆ </a></span>decompose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TopologyTraits , typename <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> CGAL::decompose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html">Arrangement_on_surface_2</a>&lt; GeometryTraits, TopologyTraits &gt; &amp; </td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> </td>
          <td class="paramname"><em>oi</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Arr_vertical_decomposition_2.h&gt;</code></p>

<p>produces the symbolic vertical decomposition of a given arrangement. </p>
<p>More precisely, this function performs a batched vertical ray-shooting query from every arrangement vertex, and pairs each vertex with a pair of polymorphic objects, one corresponds to the arrangement feature that lies below it, and the other corresponds to the feature that lies above it.</p>
<p>The finite arrangement vertices and the features they "see", if exist, that are, the query results, are inserted in ascending \(xy\)-lexicographic order (of the query vertex) into an output container given through an output iterator. If the vertex is the top end-vertex of a vertical edge, we say that there is no feature below it; similarly, if it is the bottom end-vertex of a vertical edge, we say that there is no feature above it. Each feature, if exists, is represented by a discriminated union container that holds an object of one of the following types:</p>
<ul>
<li>
<code><a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a22adafaff54a2c42e6c369f198870be5" title="a handle to a halfedge.">Arrangement_on_surface_2::Halfedge_const_handle</a></code>, if the vertex is located above (or below) an edge. The given halfedge is always directed from right to left. In case there is no concrete edge below (or above) the vertex, and the arrangement is unbounded, then the object returned is a <em>fictitious</em> halfedge. </li>
<li>
<code><a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a513a10758cc81189887d5f0a492f0245" title="a handle to an arrangement face.">Arrangement_on_surface_2::Face_const_handle</a></code>, in case there is no edge below (or above) the vertex, and the arrangement is bounded. </li>
<li>
<code><a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a47fac787fb37cd812814fbb9b6ab9acc" title="Constant.">Arrangement_on_surface_2::Vertex_const_handle</a></code>, in case the vertex is located vertically above (or below) another arrangement vertex. </li>
</ul>
<p>The output of this function can be readily used for inserting vertical walls and physically decomposing the arrangement into pseudo-trapezoids.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>The arrangement. </td></tr>
    <tr><td class="paramname">oi</td><td>The output iterator that points at the output container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The past-the-end iterator of the output container.</dd></dl>
<p><b>Requirements</b><br>
</p>
<dl class="section pre"><dt>Precondition</dt><dd>Dereferencing <code>oi</code> must yield an object of type <code>std::pair&lt;<a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a47fac787fb37cd812814fbb9b6ab9acc" title="Constant.">Arrangement_on_surface_2::Vertex_const_handle</a>, std::pair&lt;std::optional&lt;Type,std::optional&lt;Type&gt;&gt;&gt;</code>, where <code>Type</code> is <code>std::variant&lt;<a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a47fac787fb37cd812814fbb9b6ab9acc" title="Constant.">Arrangement_on_surface_2::Vertex_const_handle</a>, <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a22adafaff54a2c42e6c369f198870be5" title="a handle to a halfedge.">Arrangement_on_surface_2::Halfedge_const_handle</a>, <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a513a10758cc81189887d5f0a492f0245" title="a handle to an arrangement face.">Arrangement_on_surface_2::Face_const_handle</a>&gt;</code>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Arrangement_on_surface_2_2bounded_vertical_decomposition_8cpp-example.html#a0">Arrangement_on_surface_2/bounded_vertical_decomposition.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga7598937d11570bdedd5f3b6491065940" name="ga7598937d11570bdedd5f3b6491065940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7598937d11570bdedd5f3b6491065940">◆ </a></span>do_intersect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeometryTraits , typename TopologyTraits , typename Curve , typename PointLocation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool CGAL::do_intersect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html">Arrangement_on_surface_2</a>&lt; GeometryTraits, TopologyTraits &gt; &amp; </td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Curve &amp; </td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointLocation &amp; </td>
          <td class="paramname"><em>pl</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Arrangement_on_surface_2.h&gt;</code></p>

<p>Checks if a given curve or \(x\)-monotone curve intersects an existing arrangement's edges or vertices. </p>
<p>If the give curve is not an \(x\)-monotone curve then the function subdivides the given curve into \( x\)-monotone subcurves and isolated vertices . Each subcurve is in turn checked for intersection. The function uses the zone algorithm to check if the curve intersects the arrangement. First, the curve's left endpoint is located. Then, its zone is computed starting from its left endpoint location. The zone computation terminates when an intersection with an arrangement's edge/vertex is found or when the right endpoint is reached.</p>
<p>A given point-location object is used for locating the left endpoint of the given curve in the existing arrangement. By default, the function uses the "walk along line" point-location strategy - namely an instance of the class <code><a class="el" href="classCGAL_1_1Arr__walk__along__line__point__location.html">Arr_walk_along_line_point_location</a>&lt;<a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html">Arrangement_on_surface_2</a>&lt;GeometryTraits, TopologyTraits&gt; &gt;</code>.</p>
<p>Checks if the given curve or \( x\)-monotone curve <code>c</code> intersects edges or vertices of the existing arrangement <code>arr</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If provided, <code>pl</code> must be attached to the given arrangement <code>arr</code>.</dd></dl>
<p><b>Requirements</b><br>
</p>
<ul>
<li>
If <code>c</code> is \( x\)-monotone then the instantiated <code>GeometryTraits</code> class must model the <code><a class="el" href="classArrangementXMonotoneTraits__2.html" title="The concept ArrangementXMonotoneTraits_2 refines the basic arrangement-traits concept....">ArrangementXMonotoneTraits_2</a></code> concept. If <code>c</code> is a curve then the instantiated <code>GeometryTraits</code> class must model the <code><a class="el" href="classArrangementTraits__2.html" title="The concept ArrangementTraits_2 allows the construction of arrangement of general planar curves....">ArrangementTraits_2</a></code> concept. That is, it should define the <code>Curve_2</code> type, and support its subdivision into \( x\)-monotone subcurves (and perhaps isolated points). </li>
<li>
The point-location object <code>pl</code>, must model the <code><a class="el" href="classArrangementPointLocation__2.html" title="A model of the ArrangementPointLocation_2 concept can answer point-location queries on an arrangement...">ArrangementPointLocation_2</a></code> concept. </li>
</ul>

</div>
</div>
<a id="ga9dd10a3efed93328acef4e4bcb175df9" name="ga9dd10a3efed93328acef4e4bcb175df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9dd10a3efed93328acef4e4bcb175df9">◆ </a></span>insert_non_intersecting_curve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Dcel , typename PointLocation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; Traits, Dcel &gt;::Halfedge_handle CGAL::insert_non_intersecting_curve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; Traits, Dcel &gt; &amp; </td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Traits::X_monotone_curve_2 &amp; </td>
          <td class="paramname"><em>xc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointLocation &amp; </td>
          <td class="paramname"><em>pl</em> = <code>walk_pl</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Arrangement_2.h&gt;</code></p>

<p>Inserts a given \( x\)-monotone curve into a given arrangement, where the interior of the given curve is disjoint from all existing arrangement vertices and edges. </p>
<p>Under this assumption, it is possible to locate the endpoints of the given curve in the arrangement, and use one of the specialized insertion member-functions of the arrangement according to the results. The insertion operations creates a single new edge, that is, two twin halfedges, and the function returns a handle for the one directed lexicographically in increasing order (from left to right).</p>
<p>A given point-location object is used for answering the two point-location queries on the given curve endpoints. By default, the function uses the "walk
along line" point-location strategy - namely, an instance of the class <code><a class="el" href="classCGAL_1_1Arr__walk__along__line__point__location.html">Arr_walk_along_line_point_location</a>&lt;<a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt;Traits,Dcel&gt; &gt;</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If provided, <code>pl</code> must be attached to the given arrangement <code>arr</code>.</dd></dl>
<p><b>Requirements</b><br>
</p>
<ul>
<li>
The instantiated <code>Traits</code> class must model the restricted <code><a class="el" href="classArrangementBasicTraits__2.html" title="The concept ArrangementBasicTraits_2 defines the minimal set of geometric predicates needed for the c...">ArrangementBasicTraits_2</a></code> concept, as no intersections are computed. </li>
<li>
The point-location object <code>pl</code> must model the <code><a class="el" href="classArrangementPointLocation__2.html" title="A model of the ArrangementPointLocation_2 concept can answer point-location queries on an arrangement...">ArrangementPointLocation_2</a></code> concept. </li>
</ul>

</div>
</div>
<a id="gad2c812247ce5c1dd592c0e0be74a1fc8" name="gad2c812247ce5c1dd592c0e0be74a1fc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2c812247ce5c1dd592c0e0be74a1fc8">◆ </a></span>insert_non_intersecting_curve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeometryTraits , typename TopologyTraits , typename PointLocation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html">Arrangement_on_surface_2</a>&lt; GeometryTraits, TopologyTraits &gt;::Halfedge_handle CGAL::insert_non_intersecting_curve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html">Arrangement_on_surface_2</a>&lt; GeometryTraits, TopologyTraits &gt; &amp; </td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Traits::X_monotone_curve_2 &amp; </td>
          <td class="paramname"><em>xc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointLocation &amp; </td>
          <td class="paramname"><em>pl</em> = <code>walk_pl</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Arrangement_on_surface_2.h&gt;</code></p>

<p>Inserts a given \( x\)-monotone curve into a given arrangement, where the given curve and the existing arrangement edges (more precisely, the curves geometric mappings of the edges) must be pairwise disjoint in their interiors, and the interior of the input curve must not contain existing arrangement vertices (more precisely, the points geometric mappings of the vertices). </p>
<p>Under this condition, it is possible to locate the endpoints of the given curve in the arrangement, and use one of the specialized insertion member-functions of the arrangement according to the results. The insertion operations creates a single new edge, that is, two twin halfedges. The function returns a handle to the one directed lexicographically in increasing order (from left to right).</p>
<p>A given point-location object is used for answering the two point-location queries on the given curve endpoints. By default, the function uses the "walk
along line" point-location strategy - namely, an instance of the class <code><a class="el" href="classCGAL_1_1Arr__walk__along__line__point__location.html">Arr_walk_along_line_point_location</a>&lt;<a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html">Arrangement_on_surface_2</a>&lt;GeometryTraits, TopologyTraits&gt; &gt;</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If provided, <code>pl</code> must be attached to the given arrangement <code>arr</code>.</dd></dl>
<p><b>Requirements</b><br>
</p>
<ul>
<li>
The instantiated <code>Traits</code> class must model the restricted <code><a class="el" href="classArrangementBasicTraits__2.html" title="The concept ArrangementBasicTraits_2 defines the minimal set of geometric predicates needed for the c...">ArrangementBasicTraits_2</a></code> concept, as no intersections are computed. </li>
<li>
The point-location object <code>pl</code> must model the <code><a class="el" href="classArrangementPointLocation__2.html" title="A model of the ArrangementPointLocation_2 concept can answer point-location queries on an arrangement...">ArrangementPointLocation_2</a></code> concept. </li>
</ul>

</div>
</div>
<a id="gad4aa37a4e938747028690579fb703d67" name="gad4aa37a4e938747028690579fb703d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4aa37a4e938747028690579fb703d67">◆ </a></span>insert_non_intersecting_curves() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Dcel , <a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CGAL::insert_non_intersecting_curves </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; Traits, Dcel &gt; &amp; </td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> </td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> </td>
          <td class="paramname"><em>last</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Arrangement_2.h&gt;</code></p>

<p>Inserts a set of \( x\)-monotone curves in a given range into a given arrangement. </p>
<p>The insertion is performed in an aggregated manner, using the sweep-line algorithm. The input curves should be pairwise disjoint in their interior and pairwise interior-disjoint from all existing arrangement vertices and edges.</p>
<p><b>Requirements</b><br>
</p>
<ul>
<li>
The instantiated <code>Traits</code> class must model the <code><a class="el" href="classArrangementBasicTraits__2.html" title="The concept ArrangementBasicTraits_2 defines the minimal set of geometric predicates needed for the c...">ArrangementBasicTraits_2</a></code> concept, as no intersections are computed. </li>
<li>
<code>InputIterator::value_type</code> must be <code>Traits::X_monotone_curve_2</code> </li>
</ul>

</div>
</div>
<a id="gab168a4f4aa766c5bd670d82f4793f16d" name="gab168a4f4aa766c5bd670d82f4793f16d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab168a4f4aa766c5bd670d82f4793f16d">◆ </a></span>insert_non_intersecting_curves() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeometryTraits , typename TopologyTraits , typename <a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CGAL::insert_non_intersecting_curves </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html">Arrangement_on_surface_2</a>&lt; GeometryTraits, TopologyTraits &gt; &amp; </td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> </td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> </td>
          <td class="paramname"><em>last</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Arrangement_on_surface_2.h&gt;</code></p>

<p>Inserts a set of \( x\)-monotone curves in a given range into a given arrangement. </p>
<p>The insertion is performed in an aggregated manner using the sweep-line algorithm. The input curves and the existing arrangement edges (more precisely, the curves geometric mappings of the edges) must be pairwise disjoint in their interiors, and the interiors of the input curves must not contain existing arrangement vertices (more precisely, the points geometric mappings of the vertices). The insertion operations creates exactly one new edge, that is, two twin halfedges, for every input curve.</p>
<p><b>Requirements</b><br>
</p>
<ul>
<li>
The instantiated <code>Traits</code> class must model the <code><a class="el" href="classArrangementBasicTraits__2.html" title="The concept ArrangementBasicTraits_2 defines the minimal set of geometric predicates needed for the c...">ArrangementBasicTraits_2</a></code> concept, as no intersections are computed. </li>
<li>
<code>InputIterator::value_type</code> must be <code>Traits::X_monotone_curve_2</code> </li>
</ul>

</div>
</div>
<a id="gabfaca749e7d8c9547c143032a0e9df08" name="gabfaca749e7d8c9547c143032a0e9df08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabfaca749e7d8c9547c143032a0e9df08">◆ </a></span>insert_point() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Dcel , typename PointLocation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; Traits, Dcel &gt;::Vertex_handle CGAL::insert_point </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; Traits, Dcel &gt; &amp; </td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Traits::Point_2 &amp; </td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointLocation &amp; </td>
          <td class="paramname"><em>pl</em> = <code>walk_pl</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Arrangement_2.h&gt;</code></p>

<p>Inserts a given point into a given arrangement. </p>
<p>It uses a given point-location object to locate the given point in the given arrangement. If the point coincides with an existing vertex, there is nothing left to do; if it lies on an edge, the edge is split at the point. Otherwise, the point is contained inside a face, and is inserted as an isolated vertex inside this face. By default, the function uses the "walk along line" point-location strategy - namely, an instance of the class <code><a class="el" href="classCGAL_1_1Arr__walk__along__line__point__location.html">Arr_walk_along_line_point_location</a>&lt;<a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt;Traits,Dcel&gt; &gt;</code>. In either case, the function returns a handle for the vertex associated with the point.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If provided, <code>pl</code> must be attached to the given arrangement <code>arr</code>.</dd></dl>
<p><b>Requirements</b><br>
</p>
<ul>
<li>
The instantiated <code>Traits</code> class must model the <code><a class="el" href="classArrangementXMonotoneTraits__2.html" title="The concept ArrangementXMonotoneTraits_2 refines the basic arrangement-traits concept....">ArrangementXMonotoneTraits_2</a></code> concept. Not all expressions listed by this concept are required. In fact the traits class must model the <code><a class="el" href="classArrangementBasicTraits__2.html" title="The concept ArrangementBasicTraits_2 defines the minimal set of geometric predicates needed for the c...">ArrangementBasicTraits_2</a></code> concept, and support the splitting functionality. </li>
<li>
The point-location object <code>pl</code>, must model the <code><a class="el" href="classArrangementPointLocation__2.html" title="A model of the ArrangementPointLocation_2 concept can answer point-location queries on an arrangement...">ArrangementPointLocation_2</a></code> concept. </li>
</ul>

</div>
</div>
<a id="ga20598ef738aed142f32617212dc861d9" name="ga20598ef738aed142f32617212dc861d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20598ef738aed142f32617212dc861d9">◆ </a></span>insert_point() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeometryTraits , typename TopologyTraits , typename PointLocation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html">Arrangement_on_surface_2</a>&lt; GeometryTraits, TopologyTraits &gt;::Vertex_handle CGAL::insert_point </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html">Arrangement_on_surface_2</a>&lt; GeometryTraits, TopologyTraits &gt; &amp; </td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Traits::Point_2 &amp; </td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointLocation &amp; </td>
          <td class="paramname"><em>pl</em> = <code>walk_pl</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Arrangement_on_surface_2.h&gt;</code></p>

<p>Inserts a given point into a given arrangement. </p>
<p>It uses a given point-location object to locate the given point in the given arrangement. If the point coincides with an existing vertex, there is nothing left to do; if it lies on an edge, the edge is split at the point. Otherwise, the point is contained inside a face, and is inserted as an isolated vertex inside this face. By default, the function uses the "walk along line" point-location strategy - namely, an instance of the class <code><a class="el" href="classCGAL_1_1Arr__walk__along__line__point__location.html">Arr_walk_along_line_point_location</a>&lt;<a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html">Arrangement_on_surface_2</a>&lt;GeometryTraits, TopologyTraits&gt; &gt;</code>. In either case, the function returns a handle for the vertex associated with the point.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If provided, <code>pl</code> must be attached to the given arrangement <code>arr</code>.</dd></dl>
<p><b>Requirements</b><br>
</p>
<ul>
<li>
The instantiated <code>Traits</code> class must model the <code><a class="el" href="classArrangementXMonotoneTraits__2.html" title="The concept ArrangementXMonotoneTraits_2 refines the basic arrangement-traits concept....">ArrangementXMonotoneTraits_2</a></code> concept. Not all expressions listed by this concept are required. In fact the traits class must model the <code><a class="el" href="classArrangementBasicTraits__2.html" title="The concept ArrangementBasicTraits_2 defines the minimal set of geometric predicates needed for the c...">ArrangementBasicTraits_2</a></code> concept, and support the splitting functionality. </li>
<li>
The point-location object <code>pl</code>, must model the <code><a class="el" href="classArrangementPointLocation__2.html" title="A model of the ArrangementPointLocation_2 concept can answer point-location queries on an arrangement...">ArrangementPointLocation_2</a></code> concept. </li>
</ul>

</div>
</div>
<a id="gabcb9bc6c5859edf3fbc1390e60e32a17" name="gabcb9bc6c5859edf3fbc1390e60e32a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcb9bc6c5859edf3fbc1390e60e32a17">◆ </a></span>is_valid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Dcel &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool CGAL::is_valid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; Traits, Dcel &gt; &amp; </td>
          <td class="paramname"><em>arr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Arrangement_2.h&gt;</code></p>

<p>Checks the validity of a given arrangement. </p>
<p>Invokes the member function <code>arr.is_valid()</code> to verify the topological correctness of the arrangement. Then it performs additional validity tests. It checks that all \( x\)-monotone curves associated with arrangement edges are pairwise disjoint in their interior. Then it makes sure that all holes and all isolated vertices are located within the proper arrangement faces. Note that the test carried out by this function may take a considerable amount of time; it is recommended to be used only for debugging purposes.</p>
<p><b>Requirements</b><br>
</p>
<p>The instantiated traits class must model the concept <code>ArranagmentXMonotoneTraits_2</code>. </p>

</div>
</div>
<a id="gafd685214e9dcdfe2186b4d9b7f76f37e" name="gafd685214e9dcdfe2186b4d9b7f76f37e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd685214e9dcdfe2186b4d9b7f76f37e">◆ </a></span>is_valid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeometryTraits , typename TopologyTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool CGAL::is_valid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html">Arrangement_on_surface_2</a>&lt; GeometryTraits, TopologyTraits &gt; &amp; </td>
          <td class="paramname"><em>arr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Arrangement_on_surface_2.h&gt;</code></p>

<p>Checks the validity of a given arrangement. </p>
<p>Invokes the member function <code>arr.is_valid()</code> to verify the topological correctness of the arrangement. Then it performs additional validity tests. It checks that all \( x\)-monotone curves associated with arrangement edges are pairwise disjoint in their interior. Then it makes sure that all holes and all isolated vertices are located within the proper arrangement faces. Note that the test carried out by this function may take a considerable amount of time; it is recommended to be used only for debugging purposes.</p>
<p><b>Requirements</b><br>
</p>
<p>The instantiated traits class must model the concept <code>ArranagmentXMonotoneTraits_2</code>. </p>

</div>
</div>
<a id="ga339cdba93f54001be303595689002396" name="ga339cdba93f54001be303595689002396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga339cdba93f54001be303595689002396">◆ </a></span>overlay() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GeomTraitsA , class GeomTraitsB , class GeomTraitsRes , class TopTraitsA , class TopTraitsB , class TopTraitsRes , class <a class="el" href="classOverlayTraits.html">OverlayTraits</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CGAL::overlay </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; GeomTraitsA, TopTraitsA &gt; &amp; </td>
          <td class="paramname"><em>arr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; GeomTraitsB, TopTraitsB &gt; &amp; </td>
          <td class="paramname"><em>arr2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; GeomTraitsRes, TopTraitsRes &gt; &amp; </td>
          <td class="paramname"><em>arr_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOverlayTraits.html">OverlayTraits</a> &amp; </td>
          <td class="paramname"><em>ovl_tr</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Arr_overlay_2.h&gt;</code></p>

<p>Computes the overlay of two arrangements <code>arr1</code> and <code>arr2</code>, and sets the output arrangement <code>res</code> to represent the overlaid arrangement. </p>
<p>Computes the overlay of two input arrangement objects, and returns the overlaid arrangement. All three arrangements can be instantiated with different geometric traits classes and different DCEL classes (encapsulated in the various topology-traits classes). The geometry traits of the resulting arrangement is used to construct the resulting arrangement. This means that all the types (e.g., <code>Traits::Point_2</code>, <code>Traits::Curve_2</code>, and <code>Traits::Point_2</code>) of both input arrangements have to be convertible to the types in the resulting arrangement. A given overlay-traits object is used to properly construct the overlaid DCEL that represents the resulting arrangement.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>res</code> does not refer to either <code>arr1</code> or <code>arr2</code> (that is, "self overlay" is not supported).</dd>
<dd>
The overlay-traits object <code>ovl_tr</code> must model the <code><a class="el" href="classOverlayTraits.html" title="A model for the OverlayTraits should be able to operate on records (namely, vertices,...">OverlayTraits</a></code> concept, which is able to construct records of the <code>ResDcel</code> class on the basis of the <code>Dcel1</code> and <code>Dcel2</code> records that induce them.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classOverlayTraits.html" title="A model for the OverlayTraits should be able to operate on records (namely, vertices,...">OverlayTraits</a></code> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Arrangement_on_surface_2_2face_extension_overlay_8cpp-example.html#a3">Arrangement_on_surface_2/face_extension_overlay.cpp</a>, <a class="el" href="Arrangement_on_surface_2_2overlay_8cpp-example.html#a0">Arrangement_on_surface_2/overlay.cpp</a>, <a class="el" href="Arrangement_on_surface_2_2overlay_color_8cpp-example.html#a2">Arrangement_on_surface_2/overlay_color.cpp</a>, and <a class="el" href="Arrangement_on_surface_2_2overlay_unbounded_8cpp-example.html#a3">Arrangement_on_surface_2/overlay_unbounded.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="gaddb9e44b14b27e4cf0c7bb26b27d8518" name="gaddb9e44b14b27e4cf0c7bb26b27d8518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaddb9e44b14b27e4cf0c7bb26b27d8518">◆ </a></span>overlay() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Dcel1 , typename Dcel2 , typename ResDcel , typename <a class="el" href="classOverlayTraits.html">OverlayTraits</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CGAL::overlay </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a>&lt; Traits, Dcel1 &gt; &amp; </td>
          <td class="paramname"><em>arr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a>&lt; Traits, Dcel2 &gt; &amp; </td>
          <td class="paramname"><em>arr2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a>&lt; Traits, ResDcel &gt; &amp; </td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOverlayTraits.html">OverlayTraits</a> &amp; </td>
          <td class="paramname"><em>ovl_tr</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Arr_overlay_2.h&gt;</code></p>

<p>Computes the overlay of two arrangements with history <code>arr1</code> and <code>arr2</code>, and sets the output arrangement with history <code>res</code> to represent the overlaid arrangement. </p>
<p>The function also constructs a consolidated set of curves that induce <code>res</code>.</p>
<p>Computes the overlay of two input arrangement objects, and returns the overlaid arrangement. All three arrangements can be instantiated with different geometric traits classes and different DCEL classes (encapsulated in the various topology-traits classes). The geometry traits of the resulting arrangement is used to construct the resulting arrangement. This means that all the types (e.g., <code>Traits::Point_2</code>, <code>Traits::Curve_2</code>, and <code>Traits::Point_2</code>) of both input arrangements have to be convertible to the types in the resulting arrangement. A given overlay-traits object is used to properly construct the overlaid DCEL that represents the resulting arrangement.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>res</code> does not refer to either <code>arr1</code> or <code>arr2</code> (that is, "self overlay" is not supported).</dd>
<dd>
The overlay-traits object <code>ovl_tr</code> must model the <code><a class="el" href="classOverlayTraits.html" title="A model for the OverlayTraits should be able to operate on records (namely, vertices,...">OverlayTraits</a></code> concept, which is able to construct records of the <code>ResDcel</code> class on the basis of the <code>Dcel1</code> and <code>Dcel2</code> records that induce them.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classOverlayTraits.html" title="A model for the OverlayTraits should be able to operate on records (namely, vertices,...">OverlayTraits</a></code> </dd></dl>

</div>
</div>
<a id="gaa323bd67be0dc7cc326eb4f26653e326" name="gaa323bd67be0dc7cc326eb4f26653e326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa323bd67be0dc7cc326eb4f26653e326">◆ </a></span>remove_curve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeometryTraits , typename TopologyTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Size CGAL::remove_curve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Arrangement__on__surface__with__history__2.html">Arrangement_on_surface_with_history_2</a>&lt; GeometryTraits, TopologyTraits &gt; &amp; </td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classCGAL_1_1Arrangement__on__surface__with__history__2.html">Arrangement_on_surface_with_history_2</a>&lt; GeometryTraits, TopologyTraits &gt;::Curve_handle </td>
          <td class="paramname"><em>ch</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Arrangement_on_surface_with_history_2.h&gt;</code></p>

<p>Removes a given curve from a given arrangement. </p>
<p>The curve is specified by its handle <code>ch</code>, from the arrangement <code>arr</code>, by deleting all the edges it induces. The function returns the number of deleted edges. </p>

</div>
</div>
<a id="ga9a27533ff4ade0c60978812e517b89d9" name="ga9a27533ff4ade0c60978812e517b89d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a27533ff4ade0c60978812e517b89d9">◆ </a></span>remove_curve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Dcel &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Size CGAL::remove_curve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a>&lt; Traits, Dcel &gt; &amp; </td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a>&lt; Traits, Dcel &gt;::Curve_handle </td>
          <td class="paramname"><em>ch</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Arrangement_with_history_2.h&gt;</code></p>

<p>Removes a given curvespecified by its handle <code>ch</code>, from a given arrangement <code>arr</code>, deleting all the edges it induces. </p>
<p>The function returns the number of deleted edges. </p>

</div>
</div>
<a id="gad41fab113e4ec35768bbcdfc6f3c54c4" name="gad41fab113e4ec35768bbcdfc6f3c54c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad41fab113e4ec35768bbcdfc6f3c54c4">◆ </a></span>remove_edge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Dcel &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; Traits, Dcel &gt;::Face_handle CGAL::remove_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; Traits, Dcel &gt; &amp; </td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; Traits, Dcel &gt;::Halfedge_handle </td>
          <td class="paramname"><em>e</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Arrangement_2.h&gt;</code></p>

<p>Removes an edge given by one of the twin halfedges that forms it, from a given arrangement. </p>
<p>Once the edge is removed, if the vertices associated with its endpoints become isolated, they are removed as well. The call <code>remove_edge(arr, e)</code> is equivalent to the call <code>arr.remove_edge (e, true, true)</code>. However, this free function requires that <code>Traits</code> be a model of the refined concept <code><a class="el" href="classArrangementXMonotoneTraits__2.html" title="The concept ArrangementXMonotoneTraits_2 refines the basic arrangement-traits concept....">ArrangementXMonotoneTraits_2</a></code>, which requires merge operations on \( x\)-monotone curves. If one of the end-vertices of the given edge becomes redundant after the edge is removed (see <code><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#gacbb4f22a59c77fb06a9d544cbbb04778" title="Attempts to removed a given vertex from a given arrangement.">remove_vertex()</a></code> for the definition of a redundant vertex), it is removed, and its incident edges are merged. If the edge-removal operation causes two faces to merge, the merged face is returned. Otherwise, the face to which the edge was incident before the removal is returned.</p>
<p><b>Requirements</b><br>
</p>
<ul>
<li>
The instantiated traits class must model the concept <code><a class="el" href="classArrangementXMonotoneTraits__2.html" title="The concept ArrangementXMonotoneTraits_2 refines the basic arrangement-traits concept....">ArrangementXMonotoneTraits_2</a></code>. </li>
</ul>

</div>
</div>
<a id="gaaa3cb37bae2483e238ede133951e3088" name="gaaa3cb37bae2483e238ede133951e3088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa3cb37bae2483e238ede133951e3088">◆ </a></span>remove_edge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeometryTraits , typename TopologyTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html">Arrangement_on_surface_2</a>&lt; GeometryTraits, TopologyTraits &gt;::Face_handle CGAL::remove_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html">Arrangement_on_surface_2</a>&lt; GeometryTraits, TopologyTraits &gt; &amp; </td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html">Arrangement_on_surface_2</a>&lt; GeometryTraits, TopologyTraits &gt;::Halfedge_handle </td>
          <td class="paramname"><em>e</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Arrangement_on_surface_2.h&gt;</code></p>

<p>Removes an edge given by one of the twin halfedges that forms it, from a given arrangement. </p>
<p>Once the edge is removed, if the vertices associated with its endpoints become isolated, they are removed as well. The call <code>remove_edge(arr, e)</code> is equivalent to the call <code>arr.remove_edge (e, true, true)</code>. However, this free function requires that <code>Traits</code> be a model of the refined concept <code><a class="el" href="classArrangementXMonotoneTraits__2.html" title="The concept ArrangementXMonotoneTraits_2 refines the basic arrangement-traits concept....">ArrangementXMonotoneTraits_2</a></code>, which requires merge operations on \( x\)-monotone curves. If one of the end-vertices of the given edge becomes redundant after the edge is removed (see <code><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#gacbb4f22a59c77fb06a9d544cbbb04778" title="Attempts to removed a given vertex from a given arrangement.">remove_vertex()</a></code> for the definition of a redundant vertex), it is removed, and its incident edges are merged. If the edge-removal operation causes two faces to merge, the merged face is returned. Otherwise, the face to which the edge was incident before the removal is returned.</p>
<p><b>Requirements</b><br>
</p>
<ul>
<li>
The instantiated traits class must model the concept <code><a class="el" href="classArrangementXMonotoneTraits__2.html" title="The concept ArrangementXMonotoneTraits_2 refines the basic arrangement-traits concept....">ArrangementXMonotoneTraits_2</a></code>. </li>
</ul>

</div>
</div>
<a id="gacbb4f22a59c77fb06a9d544cbbb04778" name="gacbb4f22a59c77fb06a9d544cbbb04778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbb4f22a59c77fb06a9d544cbbb04778">◆ </a></span>remove_vertex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Dcel &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool CGAL::remove_vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; Traits, Dcel &gt; &amp; </td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt; Traits, Dcel &gt;::Vertex_handle </td>
          <td class="paramname"><em>v</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Arrangement_2.h&gt;</code></p>

<p>Attempts to removed a given vertex from a given arrangement. </p>
<p>The vertex can be removed if it is either an isolated vertex, (and has no incident edge,) or if it is a <em>redundant</em> vertex. That is, it has exactly two incident edges, whose associated curves can be merged to form a single \(
x\)-monotone curve. The function returns a boolean value that indicates whether it succeeded removing the vertex from the arrangement.</p>
<p><b>Requirements</b><br>
</p>
<ul>
<li>
The instantiated <code>Traits</code> class must model the <code><a class="el" href="classArrangementXMonotoneTraits__2.html" title="The concept ArrangementXMonotoneTraits_2 refines the basic arrangement-traits concept....">ArrangementXMonotoneTraits_2</a></code> concept. Not all expressions listed by this concept are required. In fact the traits class must model the <code><a class="el" href="classArrangementBasicTraits__2.html" title="The concept ArrangementBasicTraits_2 defines the minimal set of geometric predicates needed for the c...">ArrangementBasicTraits_2</a></code> concept and support the merging functionality. </li>
</ul>

</div>
</div>
<a id="ga5eca39557780532185639e02ce4ecf83" name="ga5eca39557780532185639e02ce4ecf83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5eca39557780532185639e02ce4ecf83">◆ </a></span>remove_vertex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeometryTraits , typename TopologyTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool CGAL::remove_vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html">Arrangement_on_surface_2</a>&lt; GeometryTraits, TopologyTraits &gt; &amp; </td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html">Arrangement_on_surface_2</a>&lt; GeometryTraits, TopologyTraits &gt;::Vertex_handle </td>
          <td class="paramname"><em>v</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Arrangement_on_surface_2.h&gt;</code></p>

<p>Attempts to removed a given vertex from a given arrangement. </p>
<p>The vertex can be removed if it is either an isolated vertex, (and has no incident edge,) or if it is a <em>redundant</em> vertex. That is, it has exactly two incident edges, whose associated curves can be merged to form a single \(
x\)-monotone curve. The function returns a boolean value that indicates whether it succeeded removing the vertex from the arrangement.</p>
<p><b>Requirements</b><br>
</p>
<ul>
<li>
The instantiated <code>Traits</code> class must model the <code><a class="el" href="classArrangementXMonotoneTraits__2.html" title="The concept ArrangementXMonotoneTraits_2 refines the basic arrangement-traits concept....">ArrangementXMonotoneTraits_2</a></code> concept. Not all expressions listed by this concept are required. In fact the traits class must model the <code><a class="el" href="classArrangementBasicTraits__2.html" title="The concept ArrangementBasicTraits_2 defines the minimal set of geometric predicates needed for the c...">ArrangementBasicTraits_2</a></code> concept and support the merging functionality. </li>
</ul>

</div>
</div>
<a id="ga52ccca744c113ea53ae30cdf6c70b295" name="ga52ccca744c113ea53ae30cdf6c70b295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52ccca744c113ea53ae30cdf6c70b295">◆ </a></span>zone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeometryTraits , typename TopologyTraits , typename <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> , typename PointLocation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> CGAL::zone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html">Arrangement_on_surface_2</a>&lt; GeometryTraits, TopologyTraits &gt; &amp; </td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename GeometryTraits::X_monotone_curve_2 &amp; </td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> </td>
          <td class="paramname"><em>oi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointLocation &amp; </td>
          <td class="paramname"><em>pl</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Arrangement_on_surface_2.h&gt;</code></p>

<p>computes the zone of the given \(x\)-monotone curve in a given arrangement. </p>
<p>More precisely, this function finds the arrangement vertices, edges ,and faces that the given \(x\)-monotone curve intersects, and inserts them in the order they are discovered when traversing the \(x\)-monotone curve from left to right into an output contaiuner given through an output iterator. An object in the resulting zone is represented by a discriminated union container that holds a vertex handle, halfedge handle, or a face handle.</p>
<p>A given point-location object is used for answering point-location queries during the insertion process. By default, the function uses the "walk along
line" point-location strategy, namely, an instance of the class <code><a class="el" href="classCGAL_1_1Arr__walk__along__line__point__location.html">Arr_walk_along_line_point_location</a>&lt;<a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html">Arrangement_on_surface_2</a>&lt;GeometryTraits, TopologyTraits&gt;&gt;</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>The given arrangement. </td></tr>
    <tr><td class="paramname">c</td><td>The \(x\)-monotone curve. </td></tr>
    <tr><td class="paramname">oi</td><td>The output iterator that points at the output container. </td></tr>
    <tr><td class="paramname">pl</td><td>The point-location object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The past-the-end iterator of the output container.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>If provided, <code>pl</code> must be attached to the given arrangement <code>arr</code>. </dd>
<dd>
The instantiated <code>GeometryTraits</code> class must model the <code><a class="el" href="classArrangementXMonotoneTraits__2.html" title="The concept ArrangementXMonotoneTraits_2 refines the basic arrangement-traits concept....">ArrangementXMonotoneTraits_2</a></code> concept. </dd>
<dd>
The point-location object <code>pl</code>, must model the <code><a class="el" href="classArrangementPointLocation__2.html" title="A model of the ArrangementPointLocation_2 concept can answer point-location queries on an arrangement...">ArrangementPointLocation_2</a></code> concept. </dd>
<dd>
Dereferencing <code>oi</code> must yield a polymorphic object of type <code>std::variant&lt;<a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a43113edb82930474c25b57b9a8e2143f" title="Mutable.">Arrangement_on_surface_2::Vertex_handle</a>, <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#aaae449ff521205c5ba837143c431d3d3" title="a handle to a halfedge.">Arrangement_on_surface_2::Halfedge_handle</a>, <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a5c97d46fc76cf9ab96ceced3b795b3c9" title="a handle to an arrangement face.">Arrangement_on_surface_2::Face_handle</a>&gt;</code>.</dd></dl>
<p><b>Requirements</b><br>
 </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"></a> 1.9.6 </li>
  </ul>
</div>
</div>
</body>

</html>
