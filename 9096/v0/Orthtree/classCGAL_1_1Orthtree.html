<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Orthtree/classCGAL_1_1Orthtree.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=11">
<meta name="generator" content="Doxygen 1.9.6">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CGAL 6.2 - Quadtrees, Octrees, and Orthtrees: CGAL::Orthtree&lt; GeomTraits &gt; Class Template Reference</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/doxygen.css" rel="stylesheet" type="text/css">
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      },
      equationNumbers: { autoNumber: "AMS" }
  }
}
);
MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
  var PARSE = MathJax.InputJax.TeX.Parse,
      TEXT = PARSE.prototype.InternalText;
  PARSE.Augment({
    InternalText: function (text,def) {
      text = text.replace(/\\/g,"");
      return TEXT.call(this,text,def);
    }
  });
});
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
      <span class="left">
         <span id="MSearchSelect" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"> 
        </span>
        <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
      </span>
      <span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.svg" alt=""></a>
      </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CGAL 6.2 - Quadtrees, Octrees, and Orthtrees
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search/",'.html');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classCGAL_1_1Orthtree.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="classCGAL_1_1Orthtree-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">CGAL::Orthtree&lt; GeomTraits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__PkgOrthtreeRef.html">Reference Manual</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;CGAL/Orthtree.h&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename GeomTraits&gt;<br>
class CGAL::Orthtree&lt; GeomTraits &gt;</div><p>A data structure using an axis-aligned hyperrectangle decomposition of dD space for efficient access and computation. </p>
<p>It builds a hierarchy of nodes which subdivides the space. Each node represents an axis-aligned hyperrectangle region of space. The contents of nodes depend on the traits class, non-leaf nodes also contain \(2^{dim}\) other nodes which further subdivide the region.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__PkgOrthtreeRef.html#gae24e1ab33fb7912f5554ff339ee26424" title="Alias that specializes the Orthtree class to a 2D quadtree storing 2D points.">CGAL::Quadtree</a></code> </dd>
<dd>
<code><a class="el" href="group__PkgOrthtreeRef.html#ga937c2cf9aa6adc991f40c30071f0adad" title="Alias that specializes the Orthtree class to a 3D octree storing 3D points.">CGAL::Octree</a></code></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GeomTraits</td><td>must be a model of <code><a class="el" href="classOrthtreeTraits.html" title="The concept OrthtreeTraits defines the requirements for the template parameter of the CGAL::Orthtree ...">OrthtreeTraits</a></code> or <code><a class="el" href="classOrthtreeTraitsWithData.html" title="The concept OrthtreeTraitsWithData defines the requirements for the template parameter of the CGAL::O...">OrthtreeTraitsWithData</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Orthtree_2octree_build_from_point_set_8cpp-example.html#_a3">Orthtree/octree_build_from_point_set.cpp</a>, <a class="el" href="Orthtree_2octree_build_from_point_vector_8cpp-example.html#_a2">Orthtree/octree_build_from_point_vector.cpp</a>, <a class="el" href="Orthtree_2octree_build_with_custom_split_8cpp-example.html#_a3">Orthtree/octree_build_with_custom_split.cpp</a>, <a class="el" href="Orthtree_2octree_find_nearest_neighbor_8cpp-example.html#_a3">Orthtree/octree_find_nearest_neighbor.cpp</a>, <a class="el" href="Orthtree_2octree_grade_8cpp-example.html#_a2">Orthtree/octree_grade.cpp</a>, <a class="el" href="Orthtree_2octree_surface_mesh_8cpp-example.html#_a3">Orthtree/octree_surface_mesh.cpp</a>, <a class="el" href="Orthtree_2octree_traversal_custom_8cpp-example.html#_a3">Orthtree/octree_traversal_custom.cpp</a>, <a class="el" href="Orthtree_2octree_traversal_manual_8cpp-example.html#_a3">Orthtree/octree_traversal_manual.cpp</a>, <a class="el" href="Orthtree_2octree_traversal_preorder_8cpp-example.html#_a3">Orthtree/octree_traversal_preorder.cpp</a>, <a class="el" href="Orthtree_2orthtree_build_8cpp-example.html#_a2">Orthtree/orthtree_build.cpp</a>, and <a class="el" href="Orthtree_2quadtree_build_from_point_vector_8cpp-example.html#_a2">Orthtree/quadtree_build_from_point_vector.cpp</a>.</dd>
</dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Traits Types</h2></td></tr>
<tr class="memitem:a8bdee414dfdfd7da5a08ea7b7bf7ceca"><td class="memItemLeft" align="right" valign="top"><a id="a8bdee414dfdfd7da5a08ea7b7bf7ceca" name="a8bdee414dfdfd7da5a08ea7b7bf7ceca"></a>
using </td><td class="memItemRight" valign="bottom"><b>Kernel</b> = typename Traits::Kernel</td></tr>
<tr class="memdesc:a8bdee414dfdfd7da5a08ea7b7bf7ceca"><td class="mdescLeft"> </td><td class="mdescRight"><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a> type. <br></td></tr>
<tr class="separator:a8bdee414dfdfd7da5a08ea7b7bf7ceca"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a06eb0a886fe4aa54ef396efa64976cc1"><td class="memItemLeft" align="right" valign="top"><a id="a06eb0a886fe4aa54ef396efa64976cc1" name="a06eb0a886fe4aa54ef396efa64976cc1"></a>
using </td><td class="memItemRight" valign="bottom"><b>Geom_traits</b> = <a class="el" href="classCGAL_1_1Orthtree.html#a8bdee414dfdfd7da5a08ea7b7bf7ceca">Kernel</a></td></tr>
<tr class="separator:a06eb0a886fe4aa54ef396efa64976cc1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a30f0f420b76eb8580b805bb091853841"><td class="memItemLeft" align="right" valign="top"><a id="a30f0f420b76eb8580b805bb091853841" name="a30f0f420b76eb8580b805bb091853841"></a>
using </td><td class="memItemRight" valign="bottom"><b>FT</b> = typename Traits::FT</td></tr>
<tr class="memdesc:a30f0f420b76eb8580b805bb091853841"><td class="mdescLeft"> </td><td class="mdescRight">Number type. <br></td></tr>
<tr class="separator:a30f0f420b76eb8580b805bb091853841"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4ac2d10c702ee9ddc4284fb06b214e57"><td class="memItemLeft" align="right" valign="top"><a id="a4ac2d10c702ee9ddc4284fb06b214e57" name="a4ac2d10c702ee9ddc4284fb06b214e57"></a>
using </td><td class="memItemRight" valign="bottom"><b>Point</b> = typename Traits::Point_d</td></tr>
<tr class="memdesc:a4ac2d10c702ee9ddc4284fb06b214e57"><td class="mdescLeft"> </td><td class="mdescRight">Point type. <br></td></tr>
<tr class="separator:a4ac2d10c702ee9ddc4284fb06b214e57"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac87e5e05fe5ef3ccad8d9290f4ec0ff4"><td class="memItemLeft" align="right" valign="top"><a id="ac87e5e05fe5ef3ccad8d9290f4ec0ff4" name="ac87e5e05fe5ef3ccad8d9290f4ec0ff4"></a>
using </td><td class="memItemRight" valign="bottom"><b>Bbox</b> = typename Traits::Bbox_d</td></tr>
<tr class="memdesc:ac87e5e05fe5ef3ccad8d9290f4ec0ff4"><td class="mdescLeft"> </td><td class="mdescRight">Bounding box type. <br></td></tr>
<tr class="separator:ac87e5e05fe5ef3ccad8d9290f4ec0ff4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af4dc25d22b8a1740ac781a81be9ba76e"><td class="memItemLeft" align="right" valign="top"><a id="af4dc25d22b8a1740ac781a81be9ba76e" name="af4dc25d22b8a1740ac781a81be9ba76e"></a>
using </td><td class="memItemRight" valign="bottom"><b>Sphere</b> = typename Traits::Sphere_d</td></tr>
<tr class="memdesc:af4dc25d22b8a1740ac781a81be9ba76e"><td class="mdescLeft"> </td><td class="mdescRight">Sphere type. <br></td></tr>
<tr class="separator:af4dc25d22b8a1740ac781a81be9ba76e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a99c2e9168773b25d932d2570c12f6118"><td class="memItemLeft" align="right" valign="top"><a id="a99c2e9168773b25d932d2570c12f6118" name="a99c2e9168773b25d932d2570c12f6118"></a>
using </td><td class="memItemRight" valign="bottom"><b>Adjacency</b> = typename Traits::Adjacency</td></tr>
<tr class="memdesc:a99c2e9168773b25d932d2570c12f6118"><td class="mdescLeft"> </td><td class="mdescRight">Adjacency type. <br></td></tr>
<tr class="separator:a99c2e9168773b25d932d2570c12f6118"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa68903c2bac01150edfd9f781bc35b8c"><td class="memItemLeft" align="right" valign="top"><a id="aa68903c2bac01150edfd9f781bc35b8c" name="aa68903c2bac01150edfd9f781bc35b8c"></a>
using </td><td class="memItemRight" valign="bottom"><b>Node_index</b> = typename Traits::Node_index</td></tr>
<tr class="memdesc:aa68903c2bac01150edfd9f781bc35b8c"><td class="mdescLeft"> </td><td class="mdescRight"><a class="elRef" href="../STL_Extension/classIndex.html">Index</a> of a given node in the tree; the root always has index 0. <br></td></tr>
<tr class="separator:aa68903c2bac01150edfd9f781bc35b8c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa547e4a0b876084eb67616d002450fe0"><td class="memItemLeft" align="right" valign="top"><a id="aa547e4a0b876084eb67616d002450fe0" name="aa547e4a0b876084eb67616d002450fe0"></a>
using </td><td class="memItemRight" valign="bottom"><b>Node_data</b> = std::conditional_t&lt; <a class="el" href="classCGAL_1_1Orthtree.html#a9a7eb5739c197b8360937690759f0c44">has_data</a>, typename GeomTraits::Node_data, void * &gt;</td></tr>
<tr class="separator:aa547e4a0b876084eb67616d002450fe0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9a7eb5739c197b8360937690759f0c44"><td class="memItemLeft" align="right" valign="top"><a id="a9a7eb5739c197b8360937690759f0c44" name="a9a7eb5739c197b8360937690759f0c44"></a>
static constexpr bool </td><td class="memItemRight" valign="bottom"><b>has_data</b> = bool_value</td></tr>
<tr class="memdesc:a9a7eb5739c197b8360937690759f0c44"><td class="mdescLeft"> </td><td class="mdescRight"><code>true</code> if <code>GeomTraits</code> is a model of <code><a class="el" href="classOrthtreeTraitsWithData.html" title="The concept OrthtreeTraitsWithData defines the requirements for the template parameter of the CGAL::O...">OrthtreeTraitsWithData</a></code> and <code>false</code> otherwise. <br></td></tr>
<tr class="separator:a9a7eb5739c197b8360937690759f0c44"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa9950180d4635885babc5caf33854062"><td class="memItemLeft" align="right" valign="top"><a id="aa9950180d4635885babc5caf33854062" name="aa9950180d4635885babc5caf33854062"></a>
static constexpr bool </td><td class="memItemRight" valign="bottom"><b>supports_neighbor_search</b> = bool_value</td></tr>
<tr class="memdesc:aa9950180d4635885babc5caf33854062"><td class="mdescLeft"> </td><td class="mdescRight"><code>true</code> if <code>GeomTraits</code> is a model of <code><a class="el" href="classCollectionPartitioningOrthtreeTraits.html" title="Refinement of the OrthtreeTraitsWithData concept, adding requirements for the traits class of a CGAL:...">CollectionPartitioningOrthtreeTraits</a></code> and <code>false</code> otherwise. <br></td></tr>
<tr class="separator:aa9950180d4635885babc5caf33854062"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a96402476020b5d7e434465ccf69f9904"><td class="memItemLeft" align="right" valign="top"><a id="a96402476020b5d7e434465ccf69f9904" name="a96402476020b5d7e434465ccf69f9904"></a>
static constexpr int </td><td class="memItemRight" valign="bottom"><b>dimension</b> = Traits::dimension</td></tr>
<tr class="memdesc:a96402476020b5d7e434465ccf69f9904"><td class="mdescLeft"> </td><td class="mdescRight">Dimension of the tree. <br></td></tr>
<tr class="separator:a96402476020b5d7e434465ccf69f9904"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Public Types</h2></td></tr>
<tr class="memitem:af5b48b697d9de75fdd133590b31b0aa5"><td class="memItemLeft" align="right" valign="top"><a id="af5b48b697d9de75fdd133590b31b0aa5" name="af5b48b697d9de75fdd133590b31b0aa5"></a>
using </td><td class="memItemRight" valign="bottom"><b>Self</b> = <a class="el" href="classCGAL_1_1Orthtree.html">Orthtree</a>&lt; Traits &gt;</td></tr>
<tr class="memdesc:af5b48b697d9de75fdd133590b31b0aa5"><td class="mdescLeft"> </td><td class="mdescRight">Self alias for convenience. <br></td></tr>
<tr class="separator:af5b48b697d9de75fdd133590b31b0aa5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4d495b3fdb62a8ec35d179ce179c80b3"><td class="memItemLeft" align="right" valign="top">using </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Orthtree.html#a4d495b3fdb62a8ec35d179ce179c80b3">Local_coordinates</a> = std::bitset&lt; <a class="el" href="classCGAL_1_1Orthtree.html#a96402476020b5d7e434465ccf69f9904">dimension</a> &gt;</td></tr>
<tr class="memdesc:a4d495b3fdb62a8ec35d179ce179c80b3"><td class="mdescLeft"> </td><td class="mdescRight">Set of bits representing this node's relationship to its parent.  <br></td></tr>
<tr class="separator:a4d495b3fdb62a8ec35d179ce179c80b3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af129281538a90126489849d2594ebb8d"><td class="memItemLeft" align="right" valign="top">using </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Orthtree.html#af129281538a90126489849d2594ebb8d">Global_coordinates</a> = std::array&lt; std::uint32_t, <a class="el" href="classCGAL_1_1Orthtree.html#a96402476020b5d7e434465ccf69f9904">dimension</a> &gt;</td></tr>
<tr class="memdesc:af129281538a90126489849d2594ebb8d"><td class="mdescLeft"> </td><td class="mdescRight">Coordinates representing this node's relationship with the rest of the tree.  <br></td></tr>
<tr class="separator:af129281538a90126489849d2594ebb8d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a17cefc00b4625f5bd9c82e9ad710fc57"><td class="memItemLeft" align="right" valign="top"><a id="a17cefc00b4625f5bd9c82e9ad710fc57" name="a17cefc00b4625f5bd9c82e9ad710fc57"></a>
using </td><td class="memItemRight" valign="bottom"><b>Split_predicate</b> = std::function&lt; bool(<a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a>, const <a class="el" href="classCGAL_1_1Orthtree.html#af5b48b697d9de75fdd133590b31b0aa5">Self</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a17cefc00b4625f5bd9c82e9ad710fc57"><td class="mdescLeft"> </td><td class="mdescRight">A predicate that determines whether a node must be split when refining a tree. <br></td></tr>
<tr class="separator:a17cefc00b4625f5bd9c82e9ad710fc57"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac64ad58ab63542e47220d1ecef4a2818"><td class="memItemLeft" align="right" valign="top"><a id="ac64ad58ab63542e47220d1ecef4a2818" name="ac64ad58ab63542e47220d1ecef4a2818"></a>
using </td><td class="memItemRight" valign="bottom"><b>Node_index_range</b> = <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a></td></tr>
<tr class="memdesc:ac64ad58ab63542e47220d1ecef4a2818"><td class="mdescLeft"> </td><td class="mdescRight">A model of <code><a class="elRef" href="../Manual/classForwardRange.html">ForwardRange</a></code> whose value type is <code>Node_index</code>. <br></td></tr>
<tr class="separator:ac64ad58ab63542e47220d1ecef4a2818"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a38528c13ec0ee505bef5533cd99b3b3a"><td class="memTemplParams" colspan="2"><a id="a38528c13ec0ee505bef5533cd99b3b3a" name="a38528c13ec0ee505bef5533cd99b3b3a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a38528c13ec0ee505bef5533cd99b3b3a"><td class="memTemplItemLeft" align="right" valign="top">using </td><td class="memTemplItemRight" valign="bottom"><b>Property_map</b> = <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a></td></tr>
<tr class="memdesc:a38528c13ec0ee505bef5533cd99b3b3a"><td class="mdescLeft"> </td><td class="mdescRight">A model of <code><a class="elRef" href="../Manual/classLvaluePropertyMap.html">LvaluePropertyMap</a></code> with <code>Node_index</code> as key type and <code>T</code> as value type. <br></td></tr>
<tr class="separator:a38528c13ec0ee505bef5533cd99b3b3a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad1a116e9dec0f9ee204744510952925a"><td class="memItemLeft" align="right" valign="top"><a id="ad1a116e9dec0f9ee204744510952925a" name="ad1a116e9dec0f9ee204744510952925a"></a>
static constexpr int </td><td class="memItemRight" valign="bottom"><b>degree</b> = (2 &lt;&lt; (<a class="el" href="classCGAL_1_1Orthtree.html#a96402476020b5d7e434465ccf69f9904">dimension</a> - 1))</td></tr>
<tr class="memdesc:ad1a116e9dec0f9ee204744510952925a"><td class="mdescLeft"> </td><td class="mdescRight">Degree of the tree (number of children of non-leaf nodes). <br></td></tr>
<tr class="separator:ad1a116e9dec0f9ee204744510952925a"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Constructor</h2></td></tr>
<tr class="memitem:aeec5c5e64b90b82003558b3dec2de212"><td class="memItemLeft" align="right" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Orthtree.html#aeec5c5e64b90b82003558b3dec2de212">Orthtree</a> (Traits <a class="el" href="classCGAL_1_1Orthtree.html#a08f31128cd8cd87146a5829b79d130b3">traits</a>)</td></tr>
<tr class="memdesc:aeec5c5e64b90b82003558b3dec2de212"><td class="mdescLeft"> </td><td class="mdescRight">constructs an orthtree for a traits instance.  <br></td></tr>
<tr class="separator:aeec5c5e64b90b82003558b3dec2de212"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1876e99f0262b5a73c1d7cd49841595d"><td class="memTemplParams" colspan="2"><a id="a1876e99f0262b5a73c1d7cd49841595d" name="a1876e99f0262b5a73c1d7cd49841595d"></a>
template&lt;class ... Args, class  = std::enable_if_t&lt;sizeof...(Args)&gt;= 2&gt; </td></tr>
<tr class="memitem:a1876e99f0262b5a73c1d7cd49841595d"><td class="memTemplItemLeft" align="right" valign="top"> </td><td class="memTemplItemRight" valign="bottom"><b>Orthtree</b> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a1876e99f0262b5a73c1d7cd49841595d"><td class="mdescLeft"> </td><td class="mdescRight">constructs an orthtree from a set of arguments provided to the traits constructor <br></td></tr>
<tr class="separator:a1876e99f0262b5a73c1d7cd49841595d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7abedde5717ef6de879852c024ff7c87"><td class="memItemLeft" align="right" valign="top"><a id="a7abedde5717ef6de879852c024ff7c87" name="a7abedde5717ef6de879852c024ff7c87"></a>
 </td><td class="memItemRight" valign="bottom"><b>Orthtree</b> (const <a class="el" href="classCGAL_1_1Orthtree.html">Orthtree</a> &amp;other)</td></tr>
<tr class="memdesc:a7abedde5717ef6de879852c024ff7c87"><td class="mdescLeft"> </td><td class="mdescRight">copy constructor <br></td></tr>
<tr class="separator:a7abedde5717ef6de879852c024ff7c87"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af08d75a0935cf8af33cbc942259c6fd6"><td class="memItemLeft" align="right" valign="top"><a id="af08d75a0935cf8af33cbc942259c6fd6" name="af08d75a0935cf8af33cbc942259c6fd6"></a>
 </td><td class="memItemRight" valign="bottom"><b>Orthtree</b> (<a class="el" href="classCGAL_1_1Orthtree.html">Orthtree</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:af08d75a0935cf8af33cbc942259c6fd6"><td class="mdescLeft"> </td><td class="mdescRight">move constructor <br></td></tr>
<tr class="separator:af08d75a0935cf8af33cbc942259c6fd6"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Tree Building</h2></td></tr>
<tr class="memitem:aacc01689e01cf63ddbf033c73fa96b55"><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Orthtree.html#aacc01689e01cf63ddbf033c73fa96b55">refine</a> (const <a class="el" href="classCGAL_1_1Orthtree.html#a17cefc00b4625f5bd9c82e9ad710fc57">Split_predicate</a> &amp;split_predicate)</td></tr>
<tr class="memdesc:aacc01689e01cf63ddbf033c73fa96b55"><td class="mdescLeft"> </td><td class="mdescRight">recursively subdivides the orthtree until it meets the given criteria.  <br></td></tr>
<tr class="separator:aacc01689e01cf63ddbf033c73fa96b55"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ada5b919261c84840cb19bfef21b6b3f6"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classCGAL_1_1Orthtree.html">Orthtree</a>  = Self&gt; </td></tr>
<tr class="memitem:ada5b919261c84840cb19bfef21b6b3f6"><td class="memTemplItemLeft" align="right" valign="top">auto </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Orthtree.html#ada5b919261c84840cb19bfef21b6b3f6">refine</a> (size_t max_depth=10, size_t bucket_size=20) -&gt; std::enable_if_t&lt; <a class="el" href="classCGAL_1_1Orthtree.html#a9a7eb5739c197b8360937690759f0c44">Orthtree::has_data</a>, void &gt;</td></tr>
<tr class="memdesc:ada5b919261c84840cb19bfef21b6b3f6"><td class="mdescLeft"> </td><td class="mdescRight">convenience overload that refines an orthtree using a maximum depth and maximum number of contained elements in a node as split predicate.  <br></td></tr>
<tr class="separator:ada5b919261c84840cb19bfef21b6b3f6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a163f19e9594282378fe8059d6b48fc88"><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Orthtree.html#a163f19e9594282378fe8059d6b48fc88">grade</a> ()</td></tr>
<tr class="memdesc:a163f19e9594282378fe8059d6b48fc88"><td class="mdescLeft"> </td><td class="mdescRight">refines the orthtree such that the difference of depth between two immediate neighbor leaves is never more than 1.  <br></td></tr>
<tr class="separator:a163f19e9594282378fe8059d6b48fc88"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Accessors</h2></td></tr>
<tr class="memitem:a08f31128cd8cd87146a5829b79d130b3"><td class="memItemLeft" align="right" valign="top"><a id="a08f31128cd8cd87146a5829b79d130b3" name="a08f31128cd8cd87146a5829b79d130b3"></a>
const Traits &amp; </td><td class="memItemRight" valign="bottom"><b>traits</b> () const</td></tr>
<tr class="memdesc:a08f31128cd8cd87146a5829b79d130b3"><td class="mdescLeft"> </td><td class="mdescRight">provides direct read-only access to the tree traits. <br></td></tr>
<tr class="separator:a08f31128cd8cd87146a5829b79d130b3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a312ed2e3b85ca8421502363a70bd0901"><td class="memItemLeft" align="right" valign="top"><a id="a312ed2e3b85ca8421502363a70bd0901" name="a312ed2e3b85ca8421502363a70bd0901"></a>
const <a class="el" href="classCGAL_1_1Orthtree.html#a8bdee414dfdfd7da5a08ea7b7bf7ceca">Kernel</a> &amp; </td><td class="memItemRight" valign="bottom"><b>geom_traits</b> () const</td></tr>
<tr class="separator:a312ed2e3b85ca8421502363a70bd0901"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:acb22ce8df61c3ad539cf24390472f80e"><td class="memItemLeft" align="right" valign="top"><a id="acb22ce8df61c3ad539cf24390472f80e" name="acb22ce8df61c3ad539cf24390472f80e"></a>
<a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> </td><td class="memItemRight" valign="bottom"><b>root</b> () const</td></tr>
<tr class="memdesc:acb22ce8df61c3ad539cf24390472f80e"><td class="mdescLeft"> </td><td class="mdescRight">provides access to the root node, and by extension the rest of the tree. <br></td></tr>
<tr class="separator:acb22ce8df61c3ad539cf24390472f80e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a534e65d99fe77796e84df929249b3f33"><td class="memItemLeft" align="right" valign="top"><a id="a534e65d99fe77796e84df929249b3f33" name="a534e65d99fe77796e84df929249b3f33"></a>
std::size_t </td><td class="memItemRight" valign="bottom"><b>depth</b> () const</td></tr>
<tr class="memdesc:a534e65d99fe77796e84df929249b3f33"><td class="mdescLeft"> </td><td class="mdescRight">returns the deepest level reached by a leaf node in this tree (root being level 0). <br></td></tr>
<tr class="separator:a534e65d99fe77796e84df929249b3f33"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a92abb1c566bb8e967a9d24bae321dac9"><td class="memTemplParams" colspan="2">template&lt;typename Traversal &gt; </td></tr>
<tr class="memitem:a92abb1c566bb8e967a9d24bae321dac9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Orthtree.html#ac64ad58ab63542e47220d1ecef4a2818">Node_index_range</a> </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Orthtree.html#a92abb1c566bb8e967a9d24bae321dac9">traverse</a> (Traversal traversal) const</td></tr>
<tr class="memdesc:a92abb1c566bb8e967a9d24bae321dac9"><td class="mdescLeft"> </td><td class="mdescRight">constructs a node index range using a tree-traversal function.  <br></td></tr>
<tr class="separator:a92abb1c566bb8e967a9d24bae321dac9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af3eaf7030f7d87317bd490b44aac17a3"><td class="memTemplParams" colspan="2">template&lt;typename Traversal , typename ... Args&gt; </td></tr>
<tr class="memitem:af3eaf7030f7d87317bd490b44aac17a3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Orthtree.html#ac64ad58ab63542e47220d1ecef4a2818">Node_index_range</a> </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Orthtree.html#af3eaf7030f7d87317bd490b44aac17a3">traverse</a> (Args &amp;&amp;...args) const</td></tr>
<tr class="memdesc:af3eaf7030f7d87317bd490b44aac17a3"><td class="mdescLeft"> </td><td class="mdescRight">convenience method for using a traversal without constructing it yourself  <br></td></tr>
<tr class="separator:af3eaf7030f7d87317bd490b44aac17a3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a65d55b9b37ef19965ca3c6cfbcf9cbcc"><td class="memItemLeft" align="right" valign="top"><a id="a65d55b9b37ef19965ca3c6cfbcf9cbcc" name="a65d55b9b37ef19965ca3c6cfbcf9cbcc"></a>
<a class="el" href="classCGAL_1_1Orthtree.html#a30f0f420b76eb8580b805bb091853841">FT</a> </td><td class="memItemRight" valign="bottom"><b>compute_cartesian_coordinate</b> (std::uint32_t gc, std::size_t <a class="el" href="classCGAL_1_1Orthtree.html#a534e65d99fe77796e84df929249b3f33">depth</a>, int ci) const</td></tr>
<tr class="separator:a65d55b9b37ef19965ca3c6cfbcf9cbcc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab0f9bff7f067845ad4cdb18aab3c55ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Orthtree.html#ac87e5e05fe5ef3ccad8d9290f4ec0ff4">Bbox</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Orthtree.html#ab0f9bff7f067845ad4cdb18aab3c55ea">bbox</a> (<a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> n) const</td></tr>
<tr class="memdesc:ab0f9bff7f067845ad4cdb18aab3c55ea"><td class="mdescLeft"> </td><td class="mdescRight">constructs the bounding box of a node.  <br></td></tr>
<tr class="separator:ab0f9bff7f067845ad4cdb18aab3c55ea"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Custom Properties</h2></td></tr>
<tr class="memitem:a1eed57ab7422c76fd3421b89e6916c96"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1eed57ab7422c76fd3421b89e6916c96"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classCGAL_1_1Orthtree.html#a38528c13ec0ee505bef5533cd99b3b3a">Property_map</a>&lt; T &gt;, bool &gt; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Orthtree.html#a1eed57ab7422c76fd3421b89e6916c96">add_property</a> (const std::string &amp;name, const T default_value=T())</td></tr>
<tr class="memdesc:a1eed57ab7422c76fd3421b89e6916c96"><td class="mdescLeft"> </td><td class="mdescRight">gets a property for nodes, adding it if it does not already exist.  <br></td></tr>
<tr class="separator:a1eed57ab7422c76fd3421b89e6916c96"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae45690e71f4fbac4daae927808ed6f26"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae45690e71f4fbac4daae927808ed6f26"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classCGAL_1_1Orthtree.html#a38528c13ec0ee505bef5533cd99b3b3a">Property_map</a>&lt; T &gt; &gt; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Orthtree.html#ae45690e71f4fbac4daae927808ed6f26">property</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:ae45690e71f4fbac4daae927808ed6f26"><td class="mdescLeft"> </td><td class="mdescRight">gets a property of the nodes if it exists.  <br></td></tr>
<tr class="separator:ae45690e71f4fbac4daae927808ed6f26"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1e17168f52e398517e7332f9a39273ec"><td class="memItemLeft" align="right" valign="top"><a id="a1e17168f52e398517e7332f9a39273ec" name="a1e17168f52e398517e7332f9a39273ec"></a>
std::vector&lt; std::string &gt; </td><td class="memItemRight" valign="bottom"><b>properties</b> () const</td></tr>
<tr class="memdesc:a1e17168f52e398517e7332f9a39273ec"><td class="mdescLeft"> </td><td class="mdescRight">returns a vector of all property names. <br></td></tr>
<tr class="separator:a1e17168f52e398517e7332f9a39273ec"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab22254f287d37c8dfe3db38fa6ba32af"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab22254f287d37c8dfe3db38fa6ba32af"><td class="memTemplItemLeft" align="right" valign="top">bool </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Orthtree.html#ab22254f287d37c8dfe3db38fa6ba32af">remove_property</a> (<a class="el" href="classCGAL_1_1Orthtree.html#a38528c13ec0ee505bef5533cd99b3b3a">Property_map</a>&lt; T &gt; <a class="el" href="classCGAL_1_1Orthtree.html#ae45690e71f4fbac4daae927808ed6f26">property</a>)</td></tr>
<tr class="memdesc:ab22254f287d37c8dfe3db38fa6ba32af"><td class="mdescLeft"> </td><td class="mdescRight">removes the node property from the tree.  <br></td></tr>
<tr class="separator:ab22254f287d37c8dfe3db38fa6ba32af"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Queries</h2></td></tr>
<tr class="memitem:aaf2c3ef04be6579f4b3ba91c2ef1e3fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Orthtree.html#aaf2c3ef04be6579f4b3ba91c2ef1e3fb">locate</a> (const <a class="el" href="classCGAL_1_1Orthtree.html#a4ac2d10c702ee9ddc4284fb06b214e57">Point</a> &amp;point) const</td></tr>
<tr class="memdesc:aaf2c3ef04be6579f4b3ba91c2ef1e3fb"><td class="mdescLeft"> </td><td class="mdescRight">finds the leaf node which contains a particular point in space.  <br></td></tr>
<tr class="separator:aaf2c3ef04be6579f4b3ba91c2ef1e3fb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ace56c8246b26679dc6645ed8205ed68d"><td class="memTemplParams" colspan="2">template&lt;typename <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> , typename <a class="el" href="classCGAL_1_1Orthtree.html">Orthtree</a>  = Self&gt; </td></tr>
<tr class="memitem:ace56c8246b26679dc6645ed8205ed68d"><td class="memTemplItemLeft" align="right" valign="top">auto </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Orthtree.html#ace56c8246b26679dc6645ed8205ed68d">nearest_k_neighbors</a> (const <a class="el" href="classCGAL_1_1Orthtree.html#a4ac2d10c702ee9ddc4284fb06b214e57">Point</a> &amp;query, std::size_t k, <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> output) const -&gt; std::enable_if_t&lt; <a class="el" href="classCGAL_1_1Orthtree.html#aa9950180d4635885babc5caf33854062">Orthtree::supports_neighbor_search</a>, <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> &gt;</td></tr>
<tr class="memdesc:ace56c8246b26679dc6645ed8205ed68d"><td class="mdescLeft"> </td><td class="mdescRight">finds the <code>k</code> nearest neighbors of the point <code>query</code>.  <br></td></tr>
<tr class="separator:ace56c8246b26679dc6645ed8205ed68d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a51679a2495891c0677e65de057e478d1"><td class="memTemplParams" colspan="2">template&lt;typename <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> , typename <a class="el" href="classCGAL_1_1Orthtree.html">Orthtree</a>  = Self&gt; </td></tr>
<tr class="memitem:a51679a2495891c0677e65de057e478d1"><td class="memTemplItemLeft" align="right" valign="top">auto </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Orthtree.html#a51679a2495891c0677e65de057e478d1">neighbors_within_radius</a> (const <a class="el" href="classCGAL_1_1Orthtree.html#af4dc25d22b8a1740ac781a81be9ba76e">Sphere</a> &amp;query, <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> output) const -&gt; std::enable_if_t&lt; <a class="el" href="classCGAL_1_1Orthtree.html#aa9950180d4635885babc5caf33854062">Orthtree::supports_neighbor_search</a>, <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> &gt;</td></tr>
<tr class="memdesc:a51679a2495891c0677e65de057e478d1"><td class="mdescLeft"> </td><td class="mdescRight">finds the elements in the sphere <code>query</code>.  <br></td></tr>
<tr class="separator:a51679a2495891c0677e65de057e478d1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac7789da53af2d0fc78cb1de158bc0160"><td class="memTemplParams" colspan="2">template&lt;typename <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> , typename <a class="el" href="classCGAL_1_1Orthtree.html">Orthtree</a>  = Self&gt; </td></tr>
<tr class="memitem:ac7789da53af2d0fc78cb1de158bc0160"><td class="memTemplItemLeft" align="right" valign="top">auto </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Orthtree.html#ac7789da53af2d0fc78cb1de158bc0160">nearest_k_neighbors_within_radius</a> (const <a class="el" href="classCGAL_1_1Orthtree.html#af4dc25d22b8a1740ac781a81be9ba76e">Sphere</a> &amp;query, std::size_t k, <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> output) const -&gt; std::enable_if_t&lt; <a class="el" href="classCGAL_1_1Orthtree.html#aa9950180d4635885babc5caf33854062">Orthtree::supports_neighbor_search</a>, <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> &gt;</td></tr>
<tr class="memdesc:ac7789da53af2d0fc78cb1de158bc0160"><td class="mdescLeft"> </td><td class="mdescRight">finds at most <code>k</code> elements within a specific radius that are nearest to the center of the sphere <code>query</code>: if <code>query</code> does not contain at least <code>k</code> elements, only contained elements will be returned.  <br></td></tr>
<tr class="separator:ac7789da53af2d0fc78cb1de158bc0160"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a595f6d7c735f4c60c2c65e5ed2ef293c"><td class="memTemplParams" colspan="2">template&lt;typename Query , typename <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> &gt; </td></tr>
<tr class="memitem:a595f6d7c735f4c60c2c65e5ed2ef293c"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Orthtree.html#a595f6d7c735f4c60c2c65e5ed2ef293c">intersected_nodes</a> (const Query &amp;query, <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> output) const</td></tr>
<tr class="memdesc:a595f6d7c735f4c60c2c65e5ed2ef293c"><td class="mdescLeft"> </td><td class="mdescRight">finds the leaf nodes that intersect with any primitive.  <br></td></tr>
<tr class="separator:a595f6d7c735f4c60c2c65e5ed2ef293c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a18a2ac4bb94e3dbc17e556e833d2fe68"><td class="memTemplParams" colspan="2">template&lt;typename Query , typename <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> , typename IntersectionFunctor &gt; </td></tr>
<tr class="memitem:a18a2ac4bb94e3dbc17e556e833d2fe68"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Orthtree.html#a18a2ac4bb94e3dbc17e556e833d2fe68">intersected_nodes</a> (const Query &amp;query, <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> output, IntersectionFunctor &amp;func) const</td></tr>
<tr class="memdesc:a18a2ac4bb94e3dbc17e556e833d2fe68"><td class="mdescLeft"> </td><td class="mdescRight">finds the leaf nodes that intersect with any primitive.  <br></td></tr>
<tr class="separator:a18a2ac4bb94e3dbc17e556e833d2fe68"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Operators</h2></td></tr>
<tr class="memitem:add758c075edb135d4caf214d9bf1f339"><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Orthtree.html#add758c075edb135d4caf214d9bf1f339">operator==</a> (const <a class="el" href="classCGAL_1_1Orthtree.html#af5b48b697d9de75fdd133590b31b0aa5">Self</a> &amp;rhs) const</td></tr>
<tr class="memdesc:add758c075edb135d4caf214d9bf1f339"><td class="mdescLeft"> </td><td class="mdescRight">compares the topology of the orthtree with that of <code>rhs</code>.  <br></td></tr>
<tr class="separator:add758c075edb135d4caf214d9bf1f339"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8fe93cebf6492978c288c75b3c9003c0"><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Orthtree.html#a8fe93cebf6492978c288c75b3c9003c0">operator!=</a> (const <a class="el" href="classCGAL_1_1Orthtree.html#af5b48b697d9de75fdd133590b31b0aa5">Self</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a8fe93cebf6492978c288c75b3c9003c0"><td class="mdescLeft"> </td><td class="mdescRight">compares the topology of the orthtree with that of <code>rhs</code>.  <br></td></tr>
<tr class="separator:a8fe93cebf6492978c288c75b3c9003c0"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Node Access</h2></td></tr>
<tr class="memitem:ab811676ae7087731372c2ed0b801ebf8"><td class="memItemLeft" align="right" valign="top"><a id="ab811676ae7087731372c2ed0b801ebf8" name="ab811676ae7087731372c2ed0b801ebf8"></a>
bool </td><td class="memItemRight" valign="bottom"><b>is_leaf</b> (<a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> n) const</td></tr>
<tr class="memdesc:ab811676ae7087731372c2ed0b801ebf8"><td class="mdescLeft"> </td><td class="mdescRight">determines whether the node specified by index <code>n</code> is a leaf node. <br></td></tr>
<tr class="separator:ab811676ae7087731372c2ed0b801ebf8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7c7ec0670e949163125e32d96f94e33f"><td class="memItemLeft" align="right" valign="top"><a id="a7c7ec0670e949163125e32d96f94e33f" name="a7c7ec0670e949163125e32d96f94e33f"></a>
bool </td><td class="memItemRight" valign="bottom"><b>is_root</b> (<a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> n) const</td></tr>
<tr class="memdesc:a7c7ec0670e949163125e32d96f94e33f"><td class="mdescLeft"> </td><td class="mdescRight">determines whether the node specified by index <code>n</code> is the root node. <br></td></tr>
<tr class="separator:a7c7ec0670e949163125e32d96f94e33f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a25752f941cfeb52ba393b44cbe599803"><td class="memItemLeft" align="right" valign="top">std::size_t </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Orthtree.html#a25752f941cfeb52ba393b44cbe599803">depth</a> (<a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> n) const</td></tr>
<tr class="memdesc:a25752f941cfeb52ba393b44cbe599803"><td class="mdescLeft"> </td><td class="mdescRight">determines the depth of the node specified.  <br></td></tr>
<tr class="separator:a25752f941cfeb52ba393b44cbe599803"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a999b2b3c258e04af375c24b374249b48"><td class="memItemLeft" align="right" valign="top"><a id="a999b2b3c258e04af375c24b374249b48" name="a999b2b3c258e04af375c24b374249b48"></a>
std::conditional_t&lt; <a class="el" href="classCGAL_1_1Orthtree.html#a9a7eb5739c197b8360937690759f0c44">has_data</a>, Node_data &amp;, void * &gt; &amp; </td><td class="memItemRight" valign="bottom"><b>data</b> (<a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> n)</td></tr>
<tr class="memdesc:a999b2b3c258e04af375c24b374249b48"><td class="mdescLeft"> </td><td class="mdescRight">retrieves a reference to the <code>Node_data</code> associated with the node specified by <code>n</code> if <code>GeomTraits</code> is a model of <code>OrthtreeTraitswithData</code>, and <code>nullptr</code> otherwise. <br></td></tr>
<tr class="separator:a999b2b3c258e04af375c24b374249b48"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0e89107a952303d1a1902b8e9822e610"><td class="memItemLeft" align="right" valign="top"><a id="a0e89107a952303d1a1902b8e9822e610" name="a0e89107a952303d1a1902b8e9822e610"></a>
std::conditional_t&lt; <a class="el" href="classCGAL_1_1Orthtree.html#a9a7eb5739c197b8360937690759f0c44">has_data</a>, const Node_data &amp;, void * &gt; </td><td class="memItemRight" valign="bottom"><b>data</b> (<a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> n) const</td></tr>
<tr class="memdesc:a0e89107a952303d1a1902b8e9822e610"><td class="mdescLeft"> </td><td class="mdescRight">retrieves a const reference to the <code>Node_data</code> associated with the node specified by <code>n</code> if <code>GeomTraits</code> is a model of <code>OrthtreeTraitswithData</code>, and <code>nullptr</code> otherwise. <br></td></tr>
<tr class="separator:a0e89107a952303d1a1902b8e9822e610"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3e4a2e01980082bc81557db90b1f62b1"><td class="memItemLeft" align="right" valign="top"><a id="a3e4a2e01980082bc81557db90b1f62b1" name="a3e4a2e01980082bc81557db90b1f62b1"></a>
<a class="el" href="classCGAL_1_1Orthtree.html#af129281538a90126489849d2594ebb8d">Global_coordinates</a> </td><td class="memItemRight" valign="bottom"><b>global_coordinates</b> (<a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> n) const</td></tr>
<tr class="memdesc:a3e4a2e01980082bc81557db90b1f62b1"><td class="mdescLeft"> </td><td class="mdescRight">retrieves the global coordinates of the node. <br></td></tr>
<tr class="separator:a3e4a2e01980082bc81557db90b1f62b1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4e1c2ffce4d3914ded18a721db37b61d"><td class="memItemLeft" align="right" valign="top"><a id="a4e1c2ffce4d3914ded18a721db37b61d" name="a4e1c2ffce4d3914ded18a721db37b61d"></a>
<a class="el" href="classCGAL_1_1Orthtree.html#a4d495b3fdb62a8ec35d179ce179c80b3">Local_coordinates</a> </td><td class="memItemRight" valign="bottom"><b>local_coordinates</b> (<a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> n) const</td></tr>
<tr class="memdesc:a4e1c2ffce4d3914ded18a721db37b61d"><td class="mdescLeft"> </td><td class="mdescRight">retrieves the local coordinates of the node. <br></td></tr>
<tr class="separator:a4e1c2ffce4d3914ded18a721db37b61d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a99c0b6f1e97ff888d076787915353e83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Orthtree.html#a99c0b6f1e97ff888d076787915353e83">parent</a> (<a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> n) const</td></tr>
<tr class="memdesc:a99c0b6f1e97ff888d076787915353e83"><td class="mdescLeft"> </td><td class="mdescRight">returns this n's parent.  <br></td></tr>
<tr class="separator:a99c0b6f1e97ff888d076787915353e83"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad1d35de554997f6d08976054edec8cf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Orthtree.html#ad1d35de554997f6d08976054edec8cf6">child</a> (<a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> n, std::size_t i) const</td></tr>
<tr class="memdesc:ad1d35de554997f6d08976054edec8cf6"><td class="mdescLeft"> </td><td class="mdescRight">returns a node's <code>i</code>th child.  <br></td></tr>
<tr class="separator:ad1d35de554997f6d08976054edec8cf6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a57a97876f19d46b3649b37fddddb8ab4"><td class="memTemplParams" colspan="2">template&lt;typename... Indices&gt; </td></tr>
<tr class="memitem:a57a97876f19d46b3649b37fddddb8ab4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Orthtree.html#a57a97876f19d46b3649b37fddddb8ab4">descendant</a> (<a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> <a class="el" href="classCGAL_1_1Orthtree.html#a7c9da8da9a5dc7d78c169acb153be4be">node</a>, Indices... indices) const</td></tr>
<tr class="memdesc:a57a97876f19d46b3649b37fddddb8ab4"><td class="mdescLeft"> </td><td class="mdescRight">retrieves an arbitrary descendant of the node specified by <code>node</code>.  <br></td></tr>
<tr class="separator:a57a97876f19d46b3649b37fddddb8ab4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7c9da8da9a5dc7d78c169acb153be4be"><td class="memTemplParams" colspan="2">template&lt;typename... Indices&gt; </td></tr>
<tr class="memitem:a7c9da8da9a5dc7d78c169acb153be4be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Orthtree.html#a7c9da8da9a5dc7d78c169acb153be4be">node</a> (Indices... indices) const</td></tr>
<tr class="memdesc:a7c9da8da9a5dc7d78c169acb153be4be"><td class="mdescLeft"> </td><td class="mdescRight">convenience function for retrieving arbitrary nodes.  <br></td></tr>
<tr class="separator:a7c9da8da9a5dc7d78c169acb153be4be"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2d6ef6d88bef37f49493164b047480b9"><td class="memItemLeft" align="right" valign="top">const std::optional&lt; <a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Orthtree.html#a2d6ef6d88bef37f49493164b047480b9">next_sibling</a> (<a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> n) const</td></tr>
<tr class="memdesc:a2d6ef6d88bef37f49493164b047480b9"><td class="mdescLeft"> </td><td class="mdescRight">finds the next sibling in the parent of the node specified by the index <code>n</code>.  <br></td></tr>
<tr class="separator:a2d6ef6d88bef37f49493164b047480b9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa679a68fd0288cd04202b75622037813"><td class="memItemLeft" align="right" valign="top">const std::optional&lt; <a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Orthtree.html#aa679a68fd0288cd04202b75622037813">next_sibling_up</a> (<a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> n) const</td></tr>
<tr class="memdesc:aa679a68fd0288cd04202b75622037813"><td class="mdescLeft"> </td><td class="mdescRight">finds the next sibling of the parent of the node specified by <code>n</code> if it exists.  <br></td></tr>
<tr class="separator:aa679a68fd0288cd04202b75622037813"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac45a90aeb90f0716e0e48f16d44a7555"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Orthtree.html#ac45a90aeb90f0716e0e48f16d44a7555">deepest_first_child</a> (<a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> n) const</td></tr>
<tr class="memdesc:ac45a90aeb90f0716e0e48f16d44a7555"><td class="mdescLeft"> </td><td class="mdescRight">finds the leaf node reached when descending the tree and always choosing child 0.  <br></td></tr>
<tr class="separator:ac45a90aeb90f0716e0e48f16d44a7555"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7ca35569da094a083a415cb5f0fc0ff6"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Orthtree.html#a7ca35569da094a083a415cb5f0fc0ff6">first_child_at_depth</a> (<a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> n, std::size_t d) const</td></tr>
<tr class="memdesc:a7ca35569da094a083a415cb5f0fc0ff6"><td class="mdescLeft"> </td><td class="mdescRight">finds node reached when descending the tree to a depth <code>d</code> and always choosing child 0.  <br></td></tr>
<tr class="separator:a7ca35569da094a083a415cb5f0fc0ff6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac8c8cf31c4ea90a655d1c88d857036cf"><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Orthtree.html#ac8c8cf31c4ea90a655d1c88d857036cf">split</a> (<a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> n)</td></tr>
<tr class="memdesc:ac8c8cf31c4ea90a655d1c88d857036cf"><td class="mdescLeft"> </td><td class="mdescRight">splits a node into subnodes.  <br></td></tr>
<tr class="separator:ac8c8cf31c4ea90a655d1c88d857036cf"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac000a527e1dd660d1e29df0491006a05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Orthtree.html#a4ac2d10c702ee9ddc4284fb06b214e57">Point</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Orthtree.html#ac000a527e1dd660d1e29df0491006a05">barycenter</a> (<a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> n) const</td></tr>
<tr class="memdesc:ac000a527e1dd660d1e29df0491006a05"><td class="mdescLeft"> </td><td class="mdescRight">returns the center point of a node.  <br></td></tr>
<tr class="separator:ac000a527e1dd660d1e29df0491006a05"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a39aa961c73bd0166276d755bd4743b75"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Orthtree.html#a39aa961c73bd0166276d755bd4743b75">adjacent_node</a> (<a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> n, const <a class="el" href="classCGAL_1_1Orthtree.html#a4d495b3fdb62a8ec35d179ce179c80b3">Local_coordinates</a> &amp;direction) const</td></tr>
<tr class="memdesc:a39aa961c73bd0166276d755bd4743b75"><td class="mdescLeft"> </td><td class="mdescRight">finds the directly adjacent node in a specific direction  <br></td></tr>
<tr class="separator:a39aa961c73bd0166276d755bd4743b75"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8e3777412132429918d4f9b2070cd9ba"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Orthtree.html#a8e3777412132429918d4f9b2070cd9ba">adjacent_node</a> (<a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> n, <a class="el" href="classCGAL_1_1Orthtree.html#a99c2e9168773b25d932d2570c12f6118">Adjacency</a> adjacency) const</td></tr>
<tr class="memdesc:a8e3777412132429918d4f9b2070cd9ba"><td class="mdescLeft"> </td><td class="mdescRight">equivalent to <code><a class="el" href="classCGAL_1_1Orthtree.html#a39aa961c73bd0166276d755bd4743b75" title="finds the directly adjacent node in a specific direction">adjacent_node()</a></code>, with an adjacency direction rather than a bitset.  <br></td></tr>
<tr class="separator:a8e3777412132429918d4f9b2070cd9ba"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2be1272f2efa404da4243dfa3ef99440"><td class="memItemLeft" align="right" valign="top">static bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Orthtree.html#a2be1272f2efa404da4243dfa3ef99440">is_topology_equal</a> (<a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> lhsNode, const <a class="el" href="classCGAL_1_1Orthtree.html#af5b48b697d9de75fdd133590b31b0aa5">Self</a> &amp;lhsTree, <a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> rhsNode, const <a class="el" href="classCGAL_1_1Orthtree.html#af5b48b697d9de75fdd133590b31b0aa5">Self</a> &amp;rhsTree)</td></tr>
<tr class="memdesc:a2be1272f2efa404da4243dfa3ef99440"><td class="mdescLeft"> </td><td class="mdescRight">determines whether a pair of subtrees have the same topology.  <br></td></tr>
<tr class="separator:a2be1272f2efa404da4243dfa3ef99440"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afcc2b401378db6162911e013eecb924a"><td class="memItemLeft" align="right" valign="top">static bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Orthtree.html#afcc2b401378db6162911e013eecb924a">is_topology_equal</a> (const <a class="el" href="classCGAL_1_1Orthtree.html#af5b48b697d9de75fdd133590b31b0aa5">Self</a> &amp;lhs, const <a class="el" href="classCGAL_1_1Orthtree.html#af5b48b697d9de75fdd133590b31b0aa5">Self</a> &amp;rhs)</td></tr>
<tr class="memdesc:afcc2b401378db6162911e013eecb924a"><td class="mdescLeft"> </td><td class="mdescRight">helper function for calling <code><a class="el" href="classCGAL_1_1Orthtree.html#a2be1272f2efa404da4243dfa3ef99440" title="determines whether a pair of subtrees have the same topology.">is_topology_equal()</a></code> on the root nodes of two trees.  <br></td></tr>
<tr class="separator:afcc2b401378db6162911e013eecb924a"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="af129281538a90126489849d2594ebb8d" name="af129281538a90126489849d2594ebb8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af129281538a90126489849d2594ebb8d">◆ </a></span>Global_coordinates</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeomTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classCGAL_1_1Orthtree.html">CGAL::Orthtree</a>&lt; GeomTraits &gt;::Global_coordinates =  std::array&lt;std::uint32_t, <a class="el" href="classCGAL_1_1Orthtree.html#a96402476020b5d7e434465ccf69f9904">dimension</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Coordinates representing this node's relationship with the rest of the tree. </p>
<p>Each value <code>(x, y, z, ...)</code> of global coordinates is calculated by doubling the parent's global coordinates and adding the local coordinates. </p>

</div>
</div>
<a id="a4d495b3fdb62a8ec35d179ce179c80b3" name="a4d495b3fdb62a8ec35d179ce179c80b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d495b3fdb62a8ec35d179ce179c80b3">◆ </a></span>Local_coordinates</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeomTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classCGAL_1_1Orthtree.html">CGAL::Orthtree</a>&lt; GeomTraits &gt;::Local_coordinates =  std::bitset&lt;<a class="el" href="classCGAL_1_1Orthtree.html#a96402476020b5d7e434465ccf69f9904">dimension</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set of bits representing this node's relationship to its parent. </p>
<p>Equivalent to an array of Booleans, where index[0] is whether <code>x</code> is greater, index[1] is whether <code>y</code> is greater, index[2] is whether <code>z</code> is greater, and so on for higher dimensions if needed. Used to represent a node's relationship to the center of its parent. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aeec5c5e64b90b82003558b3dec2de212" name="aeec5c5e64b90b82003558b3dec2de212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeec5c5e64b90b82003558b3dec2de212">◆ </a></span>Orthtree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeomTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Orthtree.html">CGAL::Orthtree</a>&lt; GeomTraits &gt;::Orthtree </td>
          <td>(</td>
          <td class="paramtype">Traits </td>
          <td class="paramname"><em>traits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructs an orthtree for a traits instance. </p>
<p>The constructed orthtree has a root node with no children, containing the contents determined by <code>Construct_root_node_contents</code> from the traits class. That root node has a bounding box determined by <code>Construct_root_node_bbox</code> from the traits class, which typically encloses its contents.</p>
<p>This single-node orthtree is valid and compatible with all orthtree functionality, but any performance benefits are unlikely to be realized until <code><a class="el" href="classCGAL_1_1Orthtree.html#aacc01689e01cf63ddbf033c73fa96b55" title="recursively subdivides the orthtree until it meets the given criteria.">refine()</a></code> is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">traits</td><td>the traits object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1eed57ab7422c76fd3421b89e6916c96" name="a1eed57ab7422c76fd3421b89e6916c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eed57ab7422c76fd3421b89e6916c96">◆ </a></span>add_property()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeomTraits &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classCGAL_1_1Orthtree.html#a38528c13ec0ee505bef5533cd99b3b3a">Property_map</a>&lt; T &gt;, bool &gt; <a class="el" href="classCGAL_1_1Orthtree.html">CGAL::Orthtree</a>&lt; GeomTraits &gt;::add_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp; </td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T </td>
          <td class="paramname"><em>default_value</em> = <code>T()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets a property for nodes, adding it if it does not already exist. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the property to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the new property </td></tr>
    <tr><td class="paramname">default_value</td><td>the default value assigned to nodes for this property</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair of the property map and a Boolean which is <code>true</code> if the property needed to be created </dd></dl>

</div>
</div>
<a id="a8e3777412132429918d4f9b2070cd9ba" name="a8e3777412132429918d4f9b2070cd9ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e3777412132429918d4f9b2070cd9ba">◆ </a></span>adjacent_node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeomTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> &gt; <a class="el" href="classCGAL_1_1Orthtree.html">CGAL::Orthtree</a>&lt; GeomTraits &gt;::adjacent_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> </td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Orthtree.html#a99c2e9168773b25d932d2570c12f6118">Adjacency</a> </td>
          <td class="paramname"><em>adjacency</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>equivalent to <code><a class="el" href="classCGAL_1_1Orthtree.html#a39aa961c73bd0166276d755bd4743b75" title="finds the directly adjacent node in a specific direction">adjacent_node()</a></code>, with an adjacency direction rather than a bitset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>index of the node to find a neighbor of </td></tr>
    <tr><td class="paramname">adjacency</td><td>which way to find the adjacent node relative to this one </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39aa961c73bd0166276d755bd4743b75" name="a39aa961c73bd0166276d755bd4743b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39aa961c73bd0166276d755bd4743b75">◆ </a></span>adjacent_node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeomTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> &gt; <a class="el" href="classCGAL_1_1Orthtree.html">CGAL::Orthtree</a>&lt; GeomTraits &gt;::adjacent_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> </td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Orthtree.html#a4d495b3fdb62a8ec35d179ce179c80b3">Local_coordinates</a> &amp; </td>
          <td class="paramname"><em>direction</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds the directly adjacent node in a specific direction </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>direction.to_ulong &lt; 2 * dimension</code></dd></dl>
<p>Adjacent nodes are found according to several properties:</p><ul>
<li>adjacent nodes may be larger than the seek node, but never smaller</li>
<li>a node has at most <code>2 * dimension</code> different adjacent nodes (in 3D: left, right, up, down, front, back)</li>
<li>adjacent nodes are not required to be leaf nodes</li>
</ul>
<p>Here's a diagram demonstrating the concept for a quadtree:</p>
<div class="fragment"><div class="line">+---------------+---------------+</div>
<div class="line">|               |               |</div>
<div class="line">|               |               |</div>
<div class="line">|               |               |</div>
<div class="line">|       A       |               |</div>
<div class="line">|               |               |</div>
<div class="line">|               |               |</div>
<div class="line">|               |               |</div>
<div class="line">+-------+-------+---+---+-------+</div>
<div class="line">|       |       |   |   |       |</div>
<div class="line">|   A   |  (S)  +---A---+       |</div>
<div class="line">|       |       |   |   |       |</div>
<div class="line">+---+---+-------+---+---+-------+</div>
<div class="line">|   |   |       |       |       |</div>
<div class="line">+---+---+   A   |       |       |</div>
<div class="line">|   |   |       |       |       |</div>
<div class="line">+---+---+-------+-------+-------+</div>
</div><!-- fragment --><ul>
<li>(S) : Seek node</li>
<li>A : Adjacent node</li>
</ul>
<p>Note how the top adjacent node is larger than the seek node. The right adjacent node is the same size, even though it contains further subdivisions.</p>
<p>This implementation returns the adjacent node if it's found. If there is no adjacent node in that direction, it returns a null node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>index of the node to find a neighbor of </td></tr>
    <tr><td class="paramname">direction</td><td>which way to find the adjacent node relative to this one. Each successive bit selects the direction for the corresponding dimension: for an octree in 3D, 010 means: negative direction in X, position direction in Y, negative direction in Z.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the adjacent node if it exists, nothing otherwise. </dd></dl>

</div>
</div>
<a id="ac000a527e1dd660d1e29df0491006a05" name="ac000a527e1dd660d1e29df0491006a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac000a527e1dd660d1e29df0491006a05">◆ </a></span>barycenter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeomTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Orthtree.html#a4ac2d10c702ee9ddc4284fb06b214e57">Point</a> <a class="el" href="classCGAL_1_1Orthtree.html">CGAL::Orthtree</a>&lt; GeomTraits &gt;::barycenter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> </td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the center point of a node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>index of the node to find the center point for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the center point of node n </dd></dl>

</div>
</div>
<a id="ab0f9bff7f067845ad4cdb18aab3c55ea" name="ab0f9bff7f067845ad4cdb18aab3c55ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f9bff7f067845ad4cdb18aab3c55ea">◆ </a></span>bbox()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeomTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Orthtree.html#ac87e5e05fe5ef3ccad8d9290f4ec0ff4">Bbox</a> <a class="el" href="classCGAL_1_1Orthtree.html">CGAL::Orthtree</a>&lt; GeomTraits &gt;::bbox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> </td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructs the bounding box of a node. </p>
<dl class="section note"><dt>Note</dt><dd>The object constructed is not the bounding box of the node's contents, but the bounding box of the node itself.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>node to generate a bounding box for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the bounding box of the node n </dd></dl>

</div>
</div>
<a id="ad1d35de554997f6d08976054edec8cf6" name="ad1d35de554997f6d08976054edec8cf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d35de554997f6d08976054edec8cf6">◆ </a></span>child()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeomTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> <a class="el" href="classCGAL_1_1Orthtree.html">CGAL::Orthtree</a>&lt; GeomTraits &gt;::child </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> </td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t </td>
          <td class="paramname"><em>i</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a node's <code>i</code>th child. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>!is_leaf()</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>index of the node to retrieve the child of </td></tr>
    <tr><td class="paramname">i</td><td>in [0, 2^D) specifying the child to retrieve</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the <code>i</code>th child of node n </dd></dl>

</div>
</div>
<a id="ac45a90aeb90f0716e0e48f16d44a7555" name="ac45a90aeb90f0716e0e48f16d44a7555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac45a90aeb90f0716e0e48f16d44a7555">◆ </a></span>deepest_first_child()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeomTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> <a class="el" href="classCGAL_1_1Orthtree.html">CGAL::Orthtree</a>&lt; GeomTraits &gt;::deepest_first_child </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> </td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds the leaf node reached when descending the tree and always choosing child 0. </p>
<p>This is the starting point of a depth-first traversal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the node to find the deepest first child of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the deepest first child of node n. </dd></dl>

</div>
</div>
<a id="a25752f941cfeb52ba393b44cbe599803" name="a25752f941cfeb52ba393b44cbe599803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25752f941cfeb52ba393b44cbe599803">◆ </a></span>depth()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeomTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classCGAL_1_1Orthtree.html">CGAL::Orthtree</a>&lt; GeomTraits &gt;::depth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> </td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>determines the depth of the node specified. </p>
<p>The root node has depth 0, its children have depth 1, and so on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>index of the node to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the depth of the node n within its tree. </dd></dl>

</div>
</div>
<a id="a57a97876f19d46b3649b37fddddb8ab4" name="a57a97876f19d46b3649b37fddddb8ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a97876f19d46b3649b37fddddb8ab4">◆ </a></span>descendant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeomTraits &gt; </div>
<div class="memtemplate">
template&lt;typename... Indices&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> <a class="el" href="classCGAL_1_1Orthtree.html">CGAL::Orthtree</a>&lt; GeomTraits &gt;::descendant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> </td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Indices... </td>
          <td class="paramname"><em>indices</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>retrieves an arbitrary descendant of the node specified by <code>node</code>. </p>
<p>Convenience function to avoid the need to call <code>orthtree.child(orthtree.child(node, 0), 1)</code>.</p>
<p>Each index in <code>indices</code> specifies which child to enter as descending the tree from <code>node</code> down. Indices are evaluated in the order they appear as parameters, so <code>descendant(root, 0, 1)</code> returns the second child of the first child of the root.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to descend </td></tr>
    <tr><td class="paramname">indices</td><td>the integer indices specifying the descent to perform</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the specified descendant node </dd></dl>

</div>
</div>
<a id="a7ca35569da094a083a415cb5f0fc0ff6" name="a7ca35569da094a083a415cb5f0fc0ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ca35569da094a083a415cb5f0fc0ff6">◆ </a></span>first_child_at_depth()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeomTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> &gt; <a class="el" href="classCGAL_1_1Orthtree.html">CGAL::Orthtree</a>&lt; GeomTraits &gt;::first_child_at_depth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> </td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t </td>
          <td class="paramname"><em>d</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds node reached when descending the tree to a depth <code>d</code> and always choosing child 0. </p>
<p>Similar to <code><a class="el" href="classCGAL_1_1Orthtree.html#ac45a90aeb90f0716e0e48f16d44a7555" title="finds the leaf node reached when descending the tree and always choosing child 0.">deepest_first_child()</a></code>, but does go to a fixed depth.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the node to find the <code>d</code>th first child of. </td></tr>
    <tr><td class="paramname">d</td><td>the depth to descend to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the <code>d</code>th first child, nothing if the tree is not deep enough. </dd></dl>

</div>
</div>
<a id="a163f19e9594282378fe8059d6b48fc88" name="a163f19e9594282378fe8059d6b48fc88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a163f19e9594282378fe8059d6b48fc88">◆ </a></span>grade()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeomTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCGAL_1_1Orthtree.html">CGAL::Orthtree</a>&lt; GeomTraits &gt;::grade </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>refines the orthtree such that the difference of depth between two immediate neighbor leaves is never more than 1. </p>
<p>This is done only by adding nodes, nodes are never removed. </p>

</div>
</div>
<a id="a595f6d7c735f4c60c2c65e5ed2ef293c" name="a595f6d7c735f4c60c2c65e5ed2ef293c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a595f6d7c735f4c60c2c65e5ed2ef293c">◆ </a></span>intersected_nodes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeomTraits &gt; </div>
<div class="memtemplate">
template&lt;typename Query , typename <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> <a class="el" href="classCGAL_1_1Orthtree.html">CGAL::Orthtree</a>&lt; GeomTraits &gt;::intersected_nodes </td>
          <td>(</td>
          <td class="paramtype">const Query &amp; </td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> </td>
          <td class="paramname"><em>output</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds the leaf nodes that intersect with any primitive. </p>
<dl class="section note"><dt>Note</dt><dd>this function requires the function <code>bool CGAL::do_intersect(QueryType, Traits::Bbox_d)</code> to be defined.</dd></dl>
<p>This function finds all the intersecting leaf nodes and writes their indices to the output iterator.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Query</td><td>the primitive class (e.g., sphere, ray) </td></tr>
    <tr><td class="paramname"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a></td><td>a model of <code><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a></code> that accepts <code>Node_index</code> types</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>the intersecting primitive. </td></tr>
    <tr><td class="paramname">output</td><td>output iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output iterator after writing </dd></dl>

</div>
</div>
<a id="a18a2ac4bb94e3dbc17e556e833d2fe68" name="a18a2ac4bb94e3dbc17e556e833d2fe68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18a2ac4bb94e3dbc17e556e833d2fe68">◆ </a></span>intersected_nodes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeomTraits &gt; </div>
<div class="memtemplate">
template&lt;typename Query , typename <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> , typename IntersectionFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> <a class="el" href="classCGAL_1_1Orthtree.html">CGAL::Orthtree</a>&lt; GeomTraits &gt;::intersected_nodes </td>
          <td>(</td>
          <td class="paramtype">const Query &amp; </td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> </td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntersectionFunctor &amp; </td>
          <td class="paramname"><em>func</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds the leaf nodes that intersect with any primitive. </p>
<p>This function finds all the intersecting leaf nodes and writes their indices to the output iterator.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Query</td><td>the primitive class (e.g., sphere, ray) </td></tr>
    <tr><td class="paramname"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a></td><td>a model of <code><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a></code> that accepts <code>Node_index</code> types </td></tr>
    <tr><td class="paramname">IntersectionFunctor</td><td>a functor that is invoked on each node while traversing the tree to determine intersection must be of type <code>bool(const Query&amp;, const Traits::Bbox_d&amp;)</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>the intersecting primitive. </td></tr>
    <tr><td class="paramname">output</td><td>output iterator. </td></tr>
    <tr><td class="paramname">func</td><td>the intersection functor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output iterator after writing </dd></dl>

</div>
</div>
<a id="afcc2b401378db6162911e013eecb924a" name="afcc2b401378db6162911e013eecb924a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcc2b401378db6162911e013eecb924a">◆ </a></span>is_topology_equal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeomTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classCGAL_1_1Orthtree.html">CGAL::Orthtree</a>&lt; GeomTraits &gt;::is_topology_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Orthtree.html#af5b48b697d9de75fdd133590b31b0aa5">Self</a> &amp; </td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Orthtree.html#af5b48b697d9de75fdd133590b31b0aa5">Self</a> &amp; </td>
          <td class="paramname"><em>rhs</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>helper function for calling <code><a class="el" href="classCGAL_1_1Orthtree.html#a2be1272f2efa404da4243dfa3ef99440" title="determines whether a pair of subtrees have the same topology.">is_topology_equal()</a></code> on the root nodes of two trees. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>an <a class="el" href="classCGAL_1_1Orthtree.html" title="A data structure using an axis-aligned hyperrectangle decomposition of dD space for efficient access ...">Orthtree</a> </td></tr>
    <tr><td class="paramname">rhs</td><td>another <a class="el" href="classCGAL_1_1Orthtree.html" title="A data structure using an axis-aligned hyperrectangle decomposition of dD space for efficient access ...">Orthtree</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>lhs</code> and <code>rhs</code> have the same topology, and <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="a2be1272f2efa404da4243dfa3ef99440" name="a2be1272f2efa404da4243dfa3ef99440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2be1272f2efa404da4243dfa3ef99440">◆ </a></span>is_topology_equal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeomTraits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classCGAL_1_1Orthtree.html">CGAL::Orthtree</a>&lt; GeomTraits &gt;::is_topology_equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> </td>
          <td class="paramname"><em>lhsNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Orthtree.html#af5b48b697d9de75fdd133590b31b0aa5">Self</a> &amp; </td>
          <td class="paramname"><em>lhsTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> </td>
          <td class="paramname"><em>rhsNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Orthtree.html#af5b48b697d9de75fdd133590b31b0aa5">Self</a> &amp; </td>
          <td class="paramname"><em>rhsTree</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>determines whether a pair of subtrees have the same topology. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhsNode</td><td>index of a node in lhsTree </td></tr>
    <tr><td class="paramname">lhsTree</td><td>an <a class="el" href="classCGAL_1_1Orthtree.html" title="A data structure using an axis-aligned hyperrectangle decomposition of dD space for efficient access ...">Orthtree</a> </td></tr>
    <tr><td class="paramname">rhsNode</td><td>index of a node in rhsTree </td></tr>
    <tr><td class="paramname">rhsTree</td><td>another <a class="el" href="classCGAL_1_1Orthtree.html" title="A data structure using an axis-aligned hyperrectangle decomposition of dD space for efficient access ...">Orthtree</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if lhsNode and rhsNode have the same topology, false otherwise </dd></dl>

</div>
</div>
<a id="aaf2c3ef04be6579f4b3ba91c2ef1e3fb" name="aaf2c3ef04be6579f4b3ba91c2ef1e3fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2c3ef04be6579f4b3ba91c2ef1e3fb">◆ </a></span>locate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeomTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> <a class="el" href="classCGAL_1_1Orthtree.html">CGAL::Orthtree</a>&lt; GeomTraits &gt;::locate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Orthtree.html#a4ac2d10c702ee9ddc4284fb06b214e57">Point</a> &amp; </td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds the leaf node which contains a particular point in space. </p>
<p>Traverses the orthtree and finds the leaf cell that has a domain enclosing the point passed. The point passed must be within the region enclosed by the orthtree (bbox of the root node). The point is contained in the lower cell of each direction if its coordinate is lower than the center.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>query point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the node which contains the point. </dd></dl>

</div>
</div>
<a id="ace56c8246b26679dc6645ed8205ed68d" name="ace56c8246b26679dc6645ed8205ed68d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace56c8246b26679dc6645ed8205ed68d">◆ </a></span>nearest_k_neighbors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeomTraits &gt; </div>
<div class="memtemplate">
template&lt;typename <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> , typename <a class="el" href="classCGAL_1_1Orthtree.html">Orthtree</a>  = Self&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classCGAL_1_1Orthtree.html">CGAL::Orthtree</a>&lt; GeomTraits &gt;::nearest_k_neighbors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Orthtree.html#a4ac2d10c702ee9ddc4284fb06b214e57">Point</a> &amp; </td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t </td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> </td>
          <td class="paramname"><em>output</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const -&gt; std::enable_if_t&lt;<a class="el" href="classCGAL_1_1Orthtree.html#aa9950180d4635885babc5caf33854062">Orthtree::supports_neighbor_search</a>, <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a>&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds the <code>k</code> nearest neighbors of the point <code>query</code>. </p>
<p>Nearest neighbors are outputted in order of increasing distance to <code>query</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a></td><td>a model of <code><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a></code> that accepts <code>GeomTraits::Node_data_element</code> objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>query point </td></tr>
    <tr><td class="paramname">k</td><td>number of neighbors to find </td></tr>
    <tr><td class="paramname">output</td><td>output iterator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Nearest neighbor searches requires <code>GeomTraits</code> to be a model of <code><a class="el" href="classCollectionPartitioningOrthtreeTraits.html" title="Refinement of the OrthtreeTraitsWithData concept, adding requirements for the traits class of a CGAL:...">CollectionPartitioningOrthtreeTraits</a></code>. </dd></dl>

</div>
</div>
<a id="ac7789da53af2d0fc78cb1de158bc0160" name="ac7789da53af2d0fc78cb1de158bc0160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7789da53af2d0fc78cb1de158bc0160">◆ </a></span>nearest_k_neighbors_within_radius()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeomTraits &gt; </div>
<div class="memtemplate">
template&lt;typename <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> , typename <a class="el" href="classCGAL_1_1Orthtree.html">Orthtree</a>  = Self&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classCGAL_1_1Orthtree.html">CGAL::Orthtree</a>&lt; GeomTraits &gt;::nearest_k_neighbors_within_radius </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Orthtree.html#af4dc25d22b8a1740ac781a81be9ba76e">Sphere</a> &amp; </td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t </td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> </td>
          <td class="paramname"><em>output</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const -&gt; std::enable_if_t&lt;<a class="el" href="classCGAL_1_1Orthtree.html#aa9950180d4635885babc5caf33854062">Orthtree::supports_neighbor_search</a>, <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a>&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds at most <code>k</code> elements within a specific radius that are nearest to the center of the sphere <code>query</code>: if <code>query</code> does not contain at least <code>k</code> elements, only contained elements will be returned. </p>
<p>This function is useful when the user already knows how sparse the elements are, or if they do not care about elements that are too far away. Setting a small radius may have performance benefits.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a></td><td>must be a model of <code><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a></code> that accepts <code>GeomTraits::Node_data_element</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>the region to search within </td></tr>
    <tr><td class="paramname">k</td><td>the number of elements to find </td></tr>
    <tr><td class="paramname">output</td><td>the output iterator to add the found elements to (in order of increasing distance)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Nearest neighbor searches requires <code>GeomTraits</code> to be a model of <code><a class="el" href="classCollectionPartitioningOrthtreeTraits.html" title="Refinement of the OrthtreeTraitsWithData concept, adding requirements for the traits class of a CGAL:...">CollectionPartitioningOrthtreeTraits</a></code>. </dd></dl>

</div>
</div>
<a id="a51679a2495891c0677e65de057e478d1" name="a51679a2495891c0677e65de057e478d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51679a2495891c0677e65de057e478d1">◆ </a></span>neighbors_within_radius()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeomTraits &gt; </div>
<div class="memtemplate">
template&lt;typename <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> , typename <a class="el" href="classCGAL_1_1Orthtree.html">Orthtree</a>  = Self&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classCGAL_1_1Orthtree.html">CGAL::Orthtree</a>&lt; GeomTraits &gt;::neighbors_within_radius </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Orthtree.html#af4dc25d22b8a1740ac781a81be9ba76e">Sphere</a> &amp; </td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> </td>
          <td class="paramname"><em>output</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const -&gt; std::enable_if_t&lt;<a class="el" href="classCGAL_1_1Orthtree.html#aa9950180d4635885babc5caf33854062">Orthtree::supports_neighbor_search</a>, <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a>&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds the elements in the sphere <code>query</code>. </p>
<p>Elements are outputted in order of increasing distance to the center of the sphere.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a></td><td>a model of <code><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a></code> that accepts <code>GeomTraits::Node_data_element</code> objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>query sphere </td></tr>
    <tr><td class="paramname">output</td><td>output iterator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Nearest neighbor searches requires <code>GeomTraits</code> to be a model of <code><a class="el" href="classCollectionPartitioningOrthtreeTraits.html" title="Refinement of the OrthtreeTraitsWithData concept, adding requirements for the traits class of a CGAL:...">CollectionPartitioningOrthtreeTraits</a></code>. </dd></dl>

</div>
</div>
<a id="a2d6ef6d88bef37f49493164b047480b9" name="a2d6ef6d88bef37f49493164b047480b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d6ef6d88bef37f49493164b047480b9">◆ </a></span>next_sibling()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeomTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::optional&lt; <a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> &gt; <a class="el" href="classCGAL_1_1Orthtree.html">CGAL::Orthtree</a>&lt; GeomTraits &gt;::next_sibling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> </td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds the next sibling in the parent of the node specified by the index <code>n</code>. </p>
<p>Traverses the tree in increasing order of local index (e.g., 000, 001, 010, etc.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index of the node to find the sibling of</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the next sibling of n if n is not the last node in its parent, otherwise <code>std::nullopt</code>. </dd></dl>

</div>
</div>
<a id="aa679a68fd0288cd04202b75622037813" name="aa679a68fd0288cd04202b75622037813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa679a68fd0288cd04202b75622037813">◆ </a></span>next_sibling_up()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeomTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::optional&lt; <a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> &gt; <a class="el" href="classCGAL_1_1Orthtree.html">CGAL::Orthtree</a>&lt; GeomTraits &gt;::next_sibling_up </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> </td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds the next sibling of the parent of the node specified by <code>n</code> if it exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index node to find the sibling up of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the next sibling of the parent of n if n is not the root and its parent has a sibling, otherwise nothing. </dd></dl>

</div>
</div>
<a id="a7c9da8da9a5dc7d78c169acb153be4be" name="a7c9da8da9a5dc7d78c169acb153be4be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c9da8da9a5dc7d78c169acb153be4be">◆ </a></span>node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeomTraits &gt; </div>
<div class="memtemplate">
template&lt;typename... Indices&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> <a class="el" href="classCGAL_1_1Orthtree.html">CGAL::Orthtree</a>&lt; GeomTraits &gt;::node </td>
          <td>(</td>
          <td class="paramtype">Indices... </td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convenience function for retrieving arbitrary nodes. </p>
<p>Equivalent to <code>tree.descendant(tree.root(), indices...)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>the integer indices specifying the descent to perform, starting from the root</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the specified node </dd></dl>

</div>
</div>
<a id="a8fe93cebf6492978c288c75b3c9003c0" name="a8fe93cebf6492978c288c75b3c9003c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fe93cebf6492978c288c75b3c9003c0">◆ </a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeomTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Orthtree.html">CGAL::Orthtree</a>&lt; GeomTraits &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Orthtree.html#af5b48b697d9de75fdd133590b31b0aa5">Self</a> &amp; </td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compares the topology of the orthtree with that of <code>rhs</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the other orthtree</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if the trees have the same topology, and <code>true</code> otherwise </dd></dl>

</div>
</div>
<a id="add758c075edb135d4caf214d9bf1f339" name="add758c075edb135d4caf214d9bf1f339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add758c075edb135d4caf214d9bf1f339">◆ </a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeomTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Orthtree.html">CGAL::Orthtree</a>&lt; GeomTraits &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Orthtree.html#af5b48b697d9de75fdd133590b31b0aa5">Self</a> &amp; </td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compares the topology of the orthtree with that of <code>rhs</code>. </p>
<p>Trees may be considered equivalent even if they have different contents. Equivalent trees must have the same root bounding box and the same node structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the other orthtree</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the trees have the same topology, and <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="a99c0b6f1e97ff888d076787915353e83" name="a99c0b6f1e97ff888d076787915353e83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99c0b6f1e97ff888d076787915353e83">◆ </a></span>parent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeomTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> <a class="el" href="classCGAL_1_1Orthtree.html">CGAL::Orthtree</a>&lt; GeomTraits &gt;::parent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> </td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns this n's parent. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>!is_root()</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>index of the node to retrieve the parent of</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the parent of node n </dd></dl>

</div>
</div>
<a id="ae45690e71f4fbac4daae927808ed6f26" name="ae45690e71f4fbac4daae927808ed6f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae45690e71f4fbac4daae927808ed6f26">◆ </a></span>property()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeomTraits &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classCGAL_1_1Orthtree.html#a38528c13ec0ee505bef5533cd99b3b3a">Property_map</a>&lt; T &gt; &gt; <a class="el" href="classCGAL_1_1Orthtree.html">CGAL::Orthtree</a>&lt; GeomTraits &gt;::property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp; </td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets a property of the nodes if it exists. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the property to retrieve</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the property</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an optional containing the property map if it exists </dd></dl>

</div>
</div>
<a id="aacc01689e01cf63ddbf033c73fa96b55" name="aacc01689e01cf63ddbf033c73fa96b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc01689e01cf63ddbf033c73fa96b55">◆ </a></span>refine() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeomTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCGAL_1_1Orthtree.html">CGAL::Orthtree</a>&lt; GeomTraits &gt;::refine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Orthtree.html#a17cefc00b4625f5bd9c82e9ad710fc57">Split_predicate</a> &amp; </td>
          <td class="paramname"><em>split_predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>recursively subdivides the orthtree until it meets the given criteria. </p>
<p>The split predicate should return <code>true</code> if a leaf node should be split and <code>false</code> otherwise.</p>
<p>This function may be called several times with different predicates: in that case, nodes already split are left unaltered, while nodes that were not split and for which <code>split_predicate</code> returns <code>true</code> are split.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">split_predicate</td><td>determines whether or not a leaf node needs to be subdivided. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada5b919261c84840cb19bfef21b6b3f6" name="ada5b919261c84840cb19bfef21b6b3f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada5b919261c84840cb19bfef21b6b3f6">◆ </a></span>refine() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeomTraits &gt; </div>
<div class="memtemplate">
template&lt;typename <a class="el" href="classCGAL_1_1Orthtree.html">Orthtree</a>  = Self&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classCGAL_1_1Orthtree.html">CGAL::Orthtree</a>&lt; GeomTraits &gt;::refine </td>
          <td>(</td>
          <td class="paramtype">size_t </td>
          <td class="paramname"><em>max_depth</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t </td>
          <td class="paramname"><em>bucket_size</em> = <code>20</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::enable_if_t&lt;<a class="el" href="classCGAL_1_1Orthtree.html#a9a7eb5739c197b8360937690759f0c44">Orthtree::has_data</a>, void&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convenience overload that refines an orthtree using a maximum depth and maximum number of contained elements in a node as split predicate. </p>
<p>This is equivalent to calling <code>refine(Orthtrees::Maximum_depth_and_maximum_contained_elements(max_depth,
bucket_size))</code>.</p>
<p>The refinement is stopped as soon as one of the conditions is violated: if a node contains more elements than <code>bucket_size</code> but is already at <code>max_depth</code>, it is not split. Similarly, a node that is at a depth smaller than <code>max_depth</code> but already contains fewer elements than <code>bucket_size</code>, it is not split.</p>
<dl class="section warning"><dt>Warning</dt><dd>This convenience method is only appropriate for trees with traits classes where <code>Node_data</code> is a model of <code><a class="elRef" href="../Circulator/classRange.html">Range</a></code>. <code><a class="elRef" href="../Manual/classRandomAccessRange.html">RandomAccessRange</a></code> is suggested for performance.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_depth</td><td>deepest a tree is allowed to be (nodes at this depth will not be split). </td></tr>
    <tr><td class="paramname">bucket_size</td><td>maximum number of items a node is allowed to contain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab22254f287d37c8dfe3db38fa6ba32af" name="ab22254f287d37c8dfe3db38fa6ba32af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab22254f287d37c8dfe3db38fa6ba32af">◆ </a></span>remove_property()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeomTraits &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Orthtree.html">CGAL::Orthtree</a>&lt; GeomTraits &gt;::remove_property </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Orthtree.html#a38528c13ec0ee505bef5533cd99b3b3a">Property_map</a>&lt; T &gt; </td>
          <td class="paramname"><em>property</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>removes the node property from the tree. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the property to remove</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">property</td><td>the property to be removed from the tree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if property was a valid property of the tree. </dd></dl>

</div>
</div>
<a id="ac8c8cf31c4ea90a655d1c88d857036cf" name="ac8c8cf31c4ea90a655d1c88d857036cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8c8cf31c4ea90a655d1c88d857036cf">◆ </a></span>split()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeomTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCGAL_1_1Orthtree.html">CGAL::Orthtree</a>&lt; GeomTraits &gt;::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Orthtree.html#aa68903c2bac01150edfd9f781bc35b8c">Node_index</a> </td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>splits a node into subnodes. </p>
<p>Only leaf nodes should be split. When a node is split it is no longer a leaf node. The full set of <code>degree</code> children are constructed automatically, and their values are set. Contents of this node are <em>not</em> propagated automatically, this is responsibility of the <code>distribute_node_contents_object</code> in the traits class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>index of the node to split </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3eaf7030f7d87317bd490b44aac17a3" name="af3eaf7030f7d87317bd490b44aac17a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3eaf7030f7d87317bd490b44aac17a3">◆ </a></span>traverse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeomTraits &gt; </div>
<div class="memtemplate">
template&lt;typename Traversal , typename ... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Orthtree.html#ac64ad58ab63542e47220d1ecef4a2818">Node_index_range</a> <a class="el" href="classCGAL_1_1Orthtree.html">CGAL::Orthtree</a>&lt; GeomTraits &gt;::traverse </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;... </td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convenience method for using a traversal without constructing it yourself </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Traversal</td><td>a model of <code><a class="el" href="classOrthtreeTraversal.html" title="Requirements for defining a traversal strategy of an orthtree.">OrthtreeTraversal</a></code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Arguments to pass to the traversal's constructor, excluding the first (always an orthtree reference)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <code><a class="elRef" href="../Manual/classForwardRange.html">ForwardRange</a></code> over the node indices of the tree </dd></dl>

</div>
</div>
<a id="a92abb1c566bb8e967a9d24bae321dac9" name="a92abb1c566bb8e967a9d24bae321dac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92abb1c566bb8e967a9d24bae321dac9">◆ </a></span>traverse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GeomTraits &gt; </div>
<div class="memtemplate">
template&lt;typename Traversal &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Orthtree.html#ac64ad58ab63542e47220d1ecef4a2818">Node_index_range</a> <a class="el" href="classCGAL_1_1Orthtree.html">CGAL::Orthtree</a>&lt; GeomTraits &gt;::traverse </td>
          <td>(</td>
          <td class="paramtype">Traversal </td>
          <td class="paramname"><em>traversal</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructs a node index range using a tree-traversal function. </p>
<p>This method allows iteration over the nodes of the tree with a user-selected order (preorder, postorder, leaves-only, etc.).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Traversal</td><td>a model of <code><a class="el" href="classOrthtreeTraversal.html" title="Requirements for defining a traversal strategy of an orthtree.">OrthtreeTraversal</a></code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">traversal</td><td>class defining the traversal strategy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <code><a class="elRef" href="../Manual/classForwardRange.html">ForwardRange</a></code> over the node indices of the tree </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>CGAL</b></li><li class="navelem"><a class="el" href="classCGAL_1_1Orthtree.html">Orthtree</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"></a> 1.9.6 </li>
  </ul>
</div>
</div>
</body>



</html>
