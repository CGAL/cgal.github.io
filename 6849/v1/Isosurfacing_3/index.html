<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Isosurfacing_3/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 5.6 - 3D Isosurfacing: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//&amp;lt;![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      }
  }
}
);
//]]&amp;gt;
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.6 - 3D Isosurfacing
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Isosurfacing3"></a>  </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Author</dt><dd>Julian Stahl and Daniel Zint</dd></dl>
<p><a class="anchor" id="fig__isosurfacing_bunny_offset"></a></p><center> <div class="image">
<img src="bunny_offset.gif" style="max-width:50%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__isosurfacing_bunny_offset">Figure 60.1</a> Different isovalues of a bunny.  </div> <br /> 
<h1><a class="anchor" id="secmyintroduction"></a>
Introduction</h1>
<p>This package provides methods to compute a surface mesh representing an isosurface of a 3-dimensional scalar field. An isosurface is defined as the surface on which the value of this field is equal to a given constant, i.e. the isovalue. Depending on the isosurfacing method and the input data structure, the result is either a triangular, quadrilateral, or higher order polygonal indexed face set.</p>
<h1><a class="anchor" id="secmyalgorithms"></a>
Algorithms</h1>
<p>There are multiple algorithms to extract isosurfaces. This package contains Marching Cubes, topologically correct Marching Cubes, Dual Contouring, and Octree Marching. (References?)</p>
<h2><a class="anchor" id="subsecmc"></a>
Marching Cubes (MC)</h2>
<p>MC processes all cells of the input domain individually. Each cell corner gets a sign (+/-) to indicate if it is above or below the isovalue. A new vertex is created on every cell edge where the sign changes, i.e. the isosurface is intersected. The vertex position is computed via linear interpolation of the scalar values of the incident corners. Depending on the configuration of signs at the corners the resulting vertices are connected to form triangles within the cell.</p>
<p>MC can process any input data structure that consists of hexahedral cells. In case of a conforming grid, MC produces a triangle mesh that is manifold in most scenarios. If the mesh is manifold and the isosurface does not intersect the domain boundaries, the mesh is also watertight. Compared to other approaches the algorithm often generates more and many thin triangles with acute angles. MC does not preserve sharp edges.</p>
<p><a class="anchor" id="fig__isosurfacing_mc_cases"></a></p><center> <div class="image">
<img src="mc_cases.png" style="max-width:70%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__isosurfacing_mc_cases">Figure 60.2</a> Some example cases of Marching Cubes.  </div> <br /> 
<h2><a class="anchor" id="subsectmc"></a>
Topologically correct Marching Cubes (TMC)</h2>
<p>This algorithm is an extension to MC and provides additional guarantees. It generates a mesh that is homeomorphic to the trilinear interpolant of the input function inside each cube. Furthermore, the mesh is guaranteed to be manifold and watertight, as long as the isosurface does not intersect the domain boundaries.</p>
<p>TODO examples</p>
<h2><a class="anchor" id="subsecdc"></a>
Dual Contouring (DC)</h2>
<p>DC creates one vertex in every cell that is intersected by the isosurface. Next, a face is created for each edge that intersects the isosurface, by connecting the vertices of the incident cells. For a uniform hexahedral grid, this results in a quadrilateral mesh.</p>
<p>The classical DC method requires the gradient of the scalar field. It is passed to the method as an additional parameter in the form of a functor. The default argument for this parameter assumes the gradient to be zero. Thus, for using the classical DC, the gradient has to be defined by the user.</p>
<p>Different versions of DC compute the vertex positions differently. Therefore, the vertex positioning is configurable with an optional parameter. Some of them do not require the gradient and therefore even work with the zero gradient.</p>
<p>Dual Contouring works on any domain but does not guarantee a manifold or watertight mesh. It creates less faces than Marching Cubes. The main advantage of DC over MC is the ability to represent sharp edges.</p>
<p><a class="anchor" id="fig__isosurfacing_iwp_dc"></a></p><center> <div class="image">
<img src="iwp_dc.png" style="max-width:40%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__isosurfacing_iwp_dc">Figure 60.3</a> Isosurface of the IWP function generated by Dual Contouring.  </div> <br /> 
<h2><a class="anchor" id="subseccomparison"></a>
Comparison</h2>
<table class="doxtable">
<tr>
<th>Algorithm </th><th>Domains </th><th>Faces </th><th>Manifold </th><th>Watertight* </th><th>Topologically correct  </th></tr>
<tr>
<td>MC </td><td>Hexahedral </td><td>Triangles </td><td>no </td><td>no </td><td>no </td></tr>
<tr>
<td>TMC </td><td>Hexahedral </td><td>Triangles </td><td>yes </td><td>yes </td><td>yes </td></tr>
<tr>
<td>DC </td><td>All </td><td>Polygons </td><td>no </td><td>no </td><td>no </td></tr>
</table>
<p>(* assuming the isosurface does not leave the given bounding box)</p>
<p><a class="anchor" id="fig__isosurfacing_compare_mc_dc"></a></p><center> <div class="image">
<img src="cube_mc_dc.png" style="max-width:70%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__isosurfacing_compare_mc_dc">Figure 60.4</a> Comparison between a cube generated by Dual Contouring (left) and Marching Cubes (right).  </div> <br /> 
<h1><a class="anchor" id="secmyinterface"></a>
Interface</h1>
<p>Each algorithm is represented by a single functions. The function signature is the same for all algorithms:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Concurrency_tag = Sequential_tag, <span class="keyword">class</span> Domain_, <span class="keyword">class</span> Po<span class="keywordtype">int</span>Range, <span class="keyword">class</span> PolygonRange&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="group__PkgIsosurfacing3Ref.html#gaefb927d1bed0dba94be85b1032465f60">make_triangle_mesh_using_marching_cubes</a>(<span class="keyword">const</span> Domain_&amp; domain, <span class="keyword">const</span> <span class="keyword">typename</span> Domain_::FT iso_value,</div><div class="line">                                             PointRange&amp; points, PolygonRange&amp; polygons);</div></div><!-- fragment --><p>The input is provided in the form of a <code>domain</code> (see <a class="el" href="index.html#secmydomains">Domains</a>).</p>
<p>The <code>iso_value</code> parameter describes the grid value the isosurface should represent.</p>
<p>The output is in the form of an indexed face set that is written to the two collections <code>points</code> and <code>polygons</code>. The vertex positions are stored as <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__3.html">Point_3</a></code> in <code>points</code>. Each face in <code>polygons</code> is a list of indices pointing into the <code>points</code> collection. Depending on the algorithm, the indexed face set may either store a polygon soup or a topological mesh.</p>
<p>Algorithms can run sequentially on one CPU core or in parallel. The Concurrency_tag is used to specify how the algorithm is executed and is either <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Sequential__tag.html">Sequential_tag</a> or <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__tag.html">Parallel_tag</a>. To enable parallelism, <a class="el" href="namespaceCGAL.html">CGAL</a> needs to be linked with the Intel TBB library. If the parallel version is not availible the sequential version will always be used as a fallback.</p>
<h1><a class="anchor" id="secmydomains"></a>
Domains</h1>
<p>A domain is an object that provides functions to access the input data, its geometry, topology, and optionally its gradient. There are some predefined domain classes that wrap the input data and provide a generalized interface for the algorithm. Users can also define new domains by implementing the <code>Isosurfacing_domain</code> concept.</p>
<h2><a class="anchor" id="mysubsecimplicitdomain"></a>
Implicit domain</h2>
<p>The <code>Implicit_domain</code> represents the input function in an implicit form without storing any values. It takes a functor or lambda that computes the value of the function from the position of a vertex as parameter. Additionally, the bounding box and spacing between grid points have to be specified.</p>
<h2><a class="anchor" id="mysubseccartesiandomain"></a>
Cartesian grid domain</h2>
<p>The <code>Cartesian_grid_domain</code> only takes a <code><a class="el" href="classCGAL_1_1Cartesian__grid__3.html">Cartesian_grid_3</a></code> as parameter. It represents a uniform grid of values that are either computed by the user or read from an <code>Image_3</code>. The constructor of <code><a class="el" href="classCGAL_1_1Cartesian__grid__3.html">Cartesian_grid_3</a></code> needs the number of grid points in each dimension and the bounding box. The values are read and written with <code>value(x, y, z)</code> where x, y, and z are the coordinates of a grid point. Alternatively, all required data can be copied from an <code>Image_3</code>.</p>
<h2><a class="anchor" id="mysubsecoctreedomain"></a>
Octree domain</h2>
<p>The <code>Octree_domain</code> wraps an octree to be used by isosurfacing algorithms. The octree has to be already refined. ...</p>
<h1><a class="anchor" id="secmybenchmarks"></a>
Performance</h1>
<p><a class="anchor" id="fig__isosurfacing_perf_iwp_mc"></a></p><center> <div class="image">
<object type="image/svg+xml" data="perf_threads_iwp_mc.svg" style="max-width:70%;"></object>
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__isosurfacing_perf_iwp_mc">Figure 60.5</a> <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Scaling.html">Scaling</a> of Marching Cubes with more threads.  </div> <br /> 
<h1><a class="anchor" id="secmyexamples"></a>
Examples</h1>
<h2><a class="anchor" id="myExampleImplicit_domain"></a>
Implicit sphere</h2>
<p>The following example shows the usage of the Marching Cubes algorithm to extract an isosurface. The domain is an <code>Implicit_domain</code> that describes a sphere by the distance to its origin as an implicit function.</p>
<p><br />
<b>File</b> <a class="el" href="Isosurfacing_3_2marching_cubes_implicit_sphere_8cpp-example.html">Isosurfacing_3/marching_cubes_implicit_sphere.cpp</a> </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Implicit_domain.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Marching_cubes_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/OFF.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;std::vector&lt;std::size_t&gt;&gt; Polygon_range;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// distance to the origin</span></div><div class="line">    <span class="keyword">auto</span> sphere_function = [](<span class="keyword">const</span> Point&amp; point) {</div><div class="line">        <span class="keywordflow">return</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">std::sqrt</a>(point.x() * point.x() + point.y() * point.y() + point.z() * point.z());</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// create a domain with bounding box [-1, 1]^3 and grid spacing 0.02</span></div><div class="line">    <a class="code" href="classCGAL_1_1Isosurfacing_1_1Implicit__domain.html">CGAL::Isosurfacing::Implicit_domain&lt;Kernel, decltype(sphere_function)&gt;</a> domain(</div><div class="line">        {-1, -1, -1, 1, 1, 1}, Vector(0.02f, 0.02f, 0.02f), sphere_function);  <span class="comment">// TODO: this is ugly</span></div><div class="line"></div><div class="line">    <span class="comment">// prepare collections for the result</span></div><div class="line">    Point_range points;</div><div class="line">    Polygon_range polygons;</div><div class="line"></div><div class="line">    <span class="comment">// execute marching cubes with an isovalue of 0.8</span></div><div class="line">    <a class="code" href="group__PkgIsosurfacing3Ref.html#gaefb927d1bed0dba94be85b1032465f60">CGAL::Isosurfacing::make_triangle_mesh_using_marching_cubes</a>(domain, 0.8f, points, polygons);</div><div class="line"></div><div class="line">    <span class="comment">// save the result in the OFF format</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result.off"</span>, points, polygons);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="myExampleAll_cube"></a>
Cartesian_grid_3 cube comparison</h2>
<p>The following example compares all provided algorithms to extract an isosurface. The domain is an <code>Cartesian_grid_domain</code> that describes a cube by storing the manhattan distance to its origin in a <code><a class="el" href="classCGAL_1_1Cartesian__grid__3.html">Cartesian_grid_3</a></code>.</p>
<p><br />
<b>File</b> <a class="el" href="Isosurfacing_3_2all_cartesian_cube_8cpp-example.html">Isosurfacing_3/all_cartesian_cube.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian_grid_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian_grid_domain.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Dual_contouring_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Marching_cubes_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/TC_marching_cubes_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/OFF.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Cartesian__grid__3.html">CGAL::Cartesian_grid_3&lt;Kernel&gt;</a> Grid;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;std::vector&lt;std::size_t&gt;&gt; Polygon_range;</div><div class="line"></div><div class="line">FT <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gaf3d75d272a29458960987a8f248ec636">sign</a>(FT value) {</div><div class="line">    <span class="keywordflow">return</span> (value &gt; 0) - (value &lt; 0);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// create a cartesian grid with 100^3 grid points and the bounding box [-1, 1]^3</span></div><div class="line">    Grid grid(7, 7, 7, {-1, -1, -1, 1, 1, 1});</div><div class="line"></div><div class="line">    <span class="comment">// calculate the value at all grid points</span></div><div class="line">    <span class="keywordflow">for</span> (std::size_t x = 0; x &lt; grid.xdim(); x++) {</div><div class="line">        <span class="keywordflow">for</span> (std::size_t y = 0; y &lt; grid.ydim(); y++) {</div><div class="line">            <span class="keywordflow">for</span> (std::size_t z = 0; z &lt; grid.zdim(); z++) {</div><div class="line"></div><div class="line">                <span class="keyword">const</span> FT pos_x = x * grid.get_spacing()[0] + grid.get_bbox().xmin();</div><div class="line">                <span class="keyword">const</span> FT pos_y = y * grid.get_spacing()[1] + grid.get_bbox().ymin();</div><div class="line">                <span class="keyword">const</span> FT pos_z = z * grid.get_spacing()[2] + grid.get_bbox().zmin();</div><div class="line"></div><div class="line">                <span class="comment">// manhattan distance to the origin</span></div><div class="line">                grid.value(x, y, z) = std::max({<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(pos_x), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(pos_y), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(pos_z)});</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> cube_gradient = [](<span class="keyword">const</span> Point&amp; p) {</div><div class="line">        <span class="comment">// the normal depends on the side of the cube</span></div><div class="line">        <span class="keyword">const</span> FT max_value = std::max({<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.x()), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.y()), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.z())});</div><div class="line"></div><div class="line">        Vector g(0, 0, 0);</div><div class="line">        <span class="keywordflow">if</span> (max_value == <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.x())) {</div><div class="line">            g += Vector(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gaf3d75d272a29458960987a8f248ec636">sign</a>(p.x()), 0, 0);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> (max_value == <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.y())) {</div><div class="line">            g += Vector(0, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gaf3d75d272a29458960987a8f248ec636">sign</a>(p.y()), 0);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> (max_value == <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.z())) {</div><div class="line">            g += Vector(0, 0, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gaf3d75d272a29458960987a8f248ec636">sign</a>(p.z()));</div><div class="line">        }</div><div class="line">        <span class="keyword">const</span> FT length_sq = g.squared_length();</div><div class="line">        <span class="keywordflow">if</span> (length_sq &gt; 0.00001) {</div><div class="line">            g /= CGAL::approximate_sqrt(length_sq);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> g;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// create a domain from the grid</span></div><div class="line">    <a class="code" href="classCGAL_1_1Isosurfacing_1_1Cartesian__grid__domain.html">CGAL::Isosurfacing::Cartesian_grid_domain&lt;Kernel, decltype(cube_gradient)&gt;</a> domain(grid, cube_gradient);</div><div class="line"></div><div class="line">    <span class="comment">// prepare collections for the results</span></div><div class="line">    Point_range points_mc, points_tmc, points_dc;</div><div class="line">    Polygon_range polygons_mc, polygons_tmc, polygons_dc;</div><div class="line"></div><div class="line">    <span class="comment">// execute marching cubes, topologically correct marching cubes and dual contouring with an isovalue of 0.8</span></div><div class="line">    <a class="code" href="group__PkgIsosurfacing3Ref.html#gaefb927d1bed0dba94be85b1032465f60">CGAL::Isosurfacing::make_triangle_mesh_using_marching_cubes</a>(domain, 0.88, points_mc, polygons_mc);</div><div class="line">    <a class="code" href="namespaceCGAL_1_1Isosurfacing.html#a0f2a5861ee0f085224ecccc2316f24b8">CGAL::Isosurfacing::make_triangle_mesh_using_tmc</a>(domain, 0.88, points_tmc, polygons_tmc);</div><div class="line">    <a class="code" href="namespaceCGAL_1_1Isosurfacing.html#af612ed0d7baf7e2f300ba98e52f96050">CGAL::Isosurfacing::make_quad_mesh_using_dual_contouring</a>(domain, 0.88, points_dc, polygons_dc);</div><div class="line"></div><div class="line">    <span class="comment">// save the results in the OFF format</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result_mc.off"</span>, points_mc, polygons_mc);</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result_tmc.off"</span>, points_tmc, polygons_tmc);</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result_dc.off"</span>, points_dc, polygons_dc);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="myExampleImage"></a>
Image_3</h2>
<p>The following example shows how to load data from an <code>Image_3</code>.</p>
<p><br />
<b>File</b> <a class="el" href="Isosurfacing_3_2marching_cubes_inrimage_8cpp-example.html">Isosurfacing_3/marching_cubes_inrimage.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian_grid_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian_grid_domain.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Marching_cubes_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/OFF.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Cartesian__grid__3.html">CGAL::Cartesian_grid_3&lt;Kernel&gt;</a> Grid;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;std::vector&lt;std::size_t&gt;&gt; Polygon_range;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string fname = <span class="stringliteral">"../../../data/skull_2.9.inr"</span>;</div><div class="line"></div><div class="line">    <span class="comment">// load the image</span></div><div class="line">    CGAL::Image_3 image;</div><div class="line">    <span class="keywordflow">if</span> (!image.read(fname)) {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">"Error: Cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// convert it to a cartesian grid</span></div><div class="line">    <span class="keyword">const</span> Grid grid(image);</div><div class="line"></div><div class="line">    <span class="comment">// create a domain from the grid</span></div><div class="line">    <a class="code" href="classCGAL_1_1Isosurfacing_1_1Cartesian__grid__domain.html">CGAL::Isosurfacing::Cartesian_grid_domain&lt;Kernel&gt;</a> domain(grid);</div><div class="line"></div><div class="line">    <span class="comment">// prepare collections for the result</span></div><div class="line">    Point_range points;</div><div class="line">    Polygon_range polygons;</div><div class="line"></div><div class="line">    <span class="comment">// execute marching cubes with an isovalue of 2.9</span></div><div class="line">    <a class="code" href="group__PkgIsosurfacing3Ref.html#gaefb927d1bed0dba94be85b1032465f60">CGAL::Isosurfacing::make_triangle_mesh_using_marching_cubes</a>(domain, 2.9, points, polygons);</div><div class="line"></div><div class="line">    <span class="comment">// save the result in the OFF format</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result.off"</span>, points, polygons);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="myExampleMeshOffset"></a>
Offset mesh</h2>
<p>The following example shows how to compute an offset mesh. The original mesh is passed to an <code>AABB_tree</code> to allow fast distance queries. With the use of <code>Side_of_triangle_mesh</code> the sign of the distance function is flipped inside the mesh.</p>
<p><br />
<b>File</b> <a class="el" href="Isosurfacing_3_2marching_cubes_mesh_offset_8cpp-example.html">Isosurfacing_3/marching_cubes_mesh_offset.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/AABB_face_graph_triangle_primitive.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/AABB_traits.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/AABB_tree.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian_grid_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian_grid_domain.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Marching_cubes_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Side_of_triangle_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/OFF.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Cartesian__grid__3.html">CGAL::Cartesian_grid_3&lt;Kernel&gt;</a> Grid;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> CGAL::Surface_mesh&lt;Point&gt; Mesh;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> CGAL::AABB_face_graph_triangle_primitive&lt;Mesh&gt; Primitive;</div><div class="line"><span class="keyword">typedef</span> CGAL::AABB_traits&lt;Kernel, Primitive&gt; Traits;</div><div class="line"><span class="keyword">typedef</span> CGAL::AABB_tree&lt;Traits&gt; Tree;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;std::vector&lt;std::size_t&gt;&gt; Polygon_range;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// computes the distance of a point p from the mesh with the use of a AABB_tree</span></div><div class="line"><span class="keyword">inline</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> distance_to_mesh(<span class="keyword">const</span> Tree&amp; tree, <span class="keyword">const</span> Point&amp; p) {</div><div class="line">    <span class="keyword">const</span> Point&amp; x = tree.closest_point(p);</div><div class="line">    <span class="keywordflow">return</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">std::sqrt</a>((p - x).squared_length());</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="keyword">const</span> std::string input_name = <span class="stringliteral">"../../../data/bunny.off"</span>;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> n_voxels = 20;</div><div class="line">    <span class="keyword">const</span> FT offset_value = -0.03;</div><div class="line"></div><div class="line">    <span class="comment">// load the original mesh</span></div><div class="line">    Mesh mesh_input;</div><div class="line">    <span class="keywordflow">if</span> (!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga7396bef8d41fe287d52d19ddbb83a3e4">CGAL::IO::read_OFF</a>(input_name, mesh_input)) {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">"Could not read mesh"</span> &lt;&lt; std::endl;</div><div class="line">        exit(-1);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// compute the new bounding box</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html">CGAL::Bbox_3</a> aabb_grid = CGAL::Polygon_mesh_processing::bbox(mesh_input);</div><div class="line">    Vector aabb_increase_vec = Vector(offset_value + 0.01, offset_value + 0.01, offset_value + 0.01);</div><div class="line">    aabb_grid += (Point(aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a3f5e323700e1509624a02d151237cc4c">xmax</a>(), aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a9d06f61bd89faa841e011ff53edf745f">ymax</a>(), aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a98def8b9515f31ded759d781969ddaf6">zmax</a>()) + aabb_increase_vec).bbox();</div><div class="line">    aabb_grid += (Point(aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#aab574470a2591f187553ca1166e682e1">xmin</a>(), aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a2088e16a1f0a20e011e5b94c2e9c222a">ymin</a>(), aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a6c55430abc7fda54571cf1075c7f2f8b">zmin</a>()) - aabb_increase_vec).bbox();</div><div class="line"></div><div class="line">    <span class="comment">// construct AABB tree</span></div><div class="line">    Tree tree(mesh_input.faces_begin(), mesh_input.faces_end(), mesh_input);</div><div class="line"></div><div class="line">    CGAL::Side_of_triangle_mesh&lt;Mesh, CGAL::GetGeomTraits&lt;Mesh&gt;::type&gt; sotm(mesh_input);</div><div class="line"></div><div class="line">    <span class="comment">// create the grid</span></div><div class="line">    Grid grid(n_voxels, n_voxels, n_voxels, aabb_grid);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (std::size_t z = 0; z &lt; grid.zdim(); z++) {</div><div class="line">        <span class="keywordflow">for</span> (std::size_t y = 0; y &lt; grid.ydim(); y++) {</div><div class="line">            <span class="keywordflow">for</span> (std::size_t x = 0; x &lt; grid.xdim(); x++) {</div><div class="line"></div><div class="line">                <span class="keyword">const</span> FT pos_x = x * grid.get_spacing()[0] + grid.get_bbox().xmin();</div><div class="line">                <span class="keyword">const</span> FT pos_y = y * grid.get_spacing()[1] + grid.get_bbox().ymin();</div><div class="line">                <span class="keyword">const</span> FT pos_z = z * grid.get_spacing()[2] + grid.get_bbox().zmin();</div><div class="line">                <span class="keyword">const</span> Point p(pos_x, pos_y, pos_z);</div><div class="line"></div><div class="line">                <span class="comment">// compute the distance</span></div><div class="line">                grid.value(x, y, z) = distance_to_mesh(tree, p);</div><div class="line"></div><div class="line">                <span class="comment">// flip the sign, so the distance is negative inside the mesh</span></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">bool</span> is_inside = (sotm(p) == <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ggaf6030e89dadcc1f45369b0cdc5d9e111ad8333d35d4801c08b3a5ae9e94d7cabe">CGAL::ON_BOUNDED_SIDE</a>);</div><div class="line">                <span class="keywordflow">if</span> (is_inside) {</div><div class="line">                    grid.value(x, y, z) *= -1;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// create a domain from the grid</span></div><div class="line">    <a class="code" href="classCGAL_1_1Isosurfacing_1_1Cartesian__grid__domain.html">CGAL::Isosurfacing::Cartesian_grid_domain&lt;Kernel&gt;</a> domain(grid);</div><div class="line"></div><div class="line">    <span class="comment">// prepare collections for the result</span></div><div class="line">    Point_range points;</div><div class="line">    Polygon_range polygons;</div><div class="line"></div><div class="line">    <span class="comment">// execute marching cubes with an isovalue equal to the offset</span></div><div class="line">    <a class="code" href="group__PkgIsosurfacing3Ref.html#gaefb927d1bed0dba94be85b1032465f60">CGAL::Isosurfacing::make_triangle_mesh_using_marching_cubes</a>(domain, offset_value, points, polygons);</div><div class="line"></div><div class="line">    <span class="comment">// save the result in the OFF format</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result.off"</span>, points, polygons);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="myExampleOctree"></a>
Octree Dual Contouring</h2>
<p>The following example shows how to extract an isosurface from an octree using Dual Contouring. The domain is an <code>Octree_domain</code> that describes a sphere by the distance to its origin stored in an octree. The octree is highly refined in one octant and only coarse in the others.</p>
<p><br />
<b>File</b> <a class="el" href="Isosurfacing_3_2dual_contouring_octree_8cpp-example.html">Isosurfacing_3/dual_contouring_octree.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Dual_contouring_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Octree_domain.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Octree_wrapper.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/OFF.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;math.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector_3;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point_3;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point_3&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;std::vector&lt;std::size_t&gt;&gt; Polygon_range;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Isosurfacing_1_1Octree__wrapper.html">CGAL::Isosurfacing::Octree_wrapper&lt;Kernel&gt;</a> Octree_wrapper_;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Isosurfacing_1_1Octree__domain.html">CGAL::Isosurfacing::Octree_domain&lt;Kernel&gt;</a> Octree_domain_;</div><div class="line"></div><div class="line"><a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> sphere_function(<span class="keyword">const</span> Point_3&amp; point) {</div><div class="line">    <span class="keywordflow">return</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">std::sqrt</a>(point.x() * point.x() + point.y() * point.y() + point.z() * point.z());</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Refine_one_eighth {</div><div class="line">    std::size_t min_depth_;</div><div class="line">    std::size_t max_depth_;</div><div class="line"></div><div class="line">    std::size_t octree_dim_;</div><div class="line"></div><div class="line">    Octree_wrapper_::Uniform_coords uniform_coordinates(<span class="keyword">const</span> Octree_wrapper_::Octree::Node&amp; node)<span class="keyword"> const </span>{</div><div class="line">        <span class="keyword">auto</span> coords = node.global_coordinates();</div><div class="line">        <span class="keyword">const</span> std::size_t depth_factor = std::size_t(1) &lt;&lt; (max_depth_ - node.depth());</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; Octree_wrapper_::Octree::Node::Dimension::value; ++i) {</div><div class="line">            coords[i] *= (uint32_t)depth_factor;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> coords;</div><div class="line">    }</div><div class="line"></div><div class="line">    Refine_one_eighth(std::size_t min_depth, std::size_t max_depth) : min_depth_(min_depth), max_depth_(max_depth) {</div><div class="line">        octree_dim_ = std::size_t(1) &lt;&lt; max_depth_;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> Octree_wrapper_::Octree::Node&amp; n)<span class="keyword"> const </span>{</div><div class="line">        <span class="comment">// n.depth()</span></div><div class="line">        <span class="keywordflow">if</span> (n.depth() &lt; min_depth_) {</div><div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> (n.depth() == max_depth_) {</div><div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> leaf_coords = uniform_coordinates(n);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (leaf_coords[0] &gt;= octree_dim_ / 2) {</div><div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> (leaf_coords[1] &gt;= octree_dim_ / 2) {</div><div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> (leaf_coords[2] &gt;= octree_dim_ / 2) {</div><div class="line">            <span class="comment">// return false;</span></div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    Octree_wrapper_ octree_wrap({-1, -1, -1, 1, 1, 1});</div><div class="line"></div><div class="line">    Refine_one_eighth split_predicate(4, 6);</div><div class="line">    octree_wrap.refine(split_predicate);</div><div class="line"></div><div class="line">    Octree_domain_ octree_domain(octree_wrap);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> lam = [&amp;](<span class="keyword">const</span> Octree_domain_::Vertex_handle&amp; v) {</div><div class="line">        Point_3 p = octree_domain.position(v);</div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> val = sphere_function(p);</div><div class="line">        Vector_3 gradient = p - <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga9d272a8e3a8080b851741b6d3a44afdc">CGAL::ORIGIN</a>;</div><div class="line">        gradient = gradient / <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">std::sqrt</a>(gradient.squared_length());</div><div class="line">        octree_wrap.value(v) = val;</div><div class="line">        octree_wrap.gradient(v) = gradient;</div><div class="line">    };</div><div class="line">    octree_domain.iterate_vertices(lam, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Sequential__tag.html">CGAL::Sequential_tag</a>());</div><div class="line"></div><div class="line">    Point_range points;</div><div class="line">    Polygon_range polygons;</div><div class="line"></div><div class="line">    <a class="code" href="namespaceCGAL_1_1Isosurfacing.html#af612ed0d7baf7e2f300ba98e52f96050">CGAL::Isosurfacing::make_quad_mesh_using_dual_contouring</a>(octree_domain, 0.8, points, polygons);</div><div class="line"></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result.off"</span>, points, polygons);</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Sep 15 2022 14:12:25 for CGAL 5.6 - 3D Isosurfacing by
    <a href="https://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>
</html><html xmlns="http://www.w3.org/1999/xhtml"><body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.6 - 3D Isosurfacing
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Isosurfacing3"></a>  </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Author</dt><dd>Julian Stahl and Daniel Zint</dd></dl>
<p><a class="anchor" id="fig__isosurfacing_bunny_offset"></a></p><center> <div class="image">
<img src="bunny_offset.gif" style="max-width:50%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__isosurfacing_bunny_offset">Figure 60.1</a> Different isovalues of a bunny.  </div> <br /> 
<h1><a class="anchor" id="secmyintroduction"></a>
Introduction</h1>
<p>This package provides methods to compute a surface mesh representing an isosurface of a 3-dimensional scalar field. An isosurface is defined as the surface on which the value of this field is equal to a given constant, i.e. the isovalue. Depending on the isosurfacing method and the input data structure, the result is either a triangular, quadrilateral, or higher order polygonal indexed face set.</p>
<h1><a class="anchor" id="secmyalgorithms"></a>
Algorithms</h1>
<p>There are multiple algorithms to extract isosurfaces. This package contains Marching Cubes, topologically correct Marching Cubes, Dual Contouring, and Octree Marching. (References?)</p>
<h2><a class="anchor" id="subsecmc"></a>
Marching Cubes (MC)</h2>
<p>MC processes all cells of the input domain individually. Each cell corner gets a sign (+/-) to indicate if it is above or below the isovalue. A new vertex is created on every cell edge where the sign changes, i.e. the isosurface is intersected. The vertex position is computed via linear interpolation of the scalar values of the incident corners. Depending on the configuration of signs at the corners the resulting vertices are connected to form triangles within the cell.</p>
<p>MC can process any input data structure that consists of hexahedral cells. In case of a conforming grid, MC produces a triangle mesh that is manifold in most scenarios. If the mesh is manifold and the isosurface does not intersect the domain boundaries, the mesh is also watertight. Compared to other approaches the algorithm often generates more and many thin triangles with acute angles. MC does not preserve sharp edges.</p>
<p><a class="anchor" id="fig__isosurfacing_mc_cases"></a></p><center> <div class="image">
<img src="mc_cases.png" style="max-width:70%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__isosurfacing_mc_cases">Figure 60.2</a> Some example cases of Marching Cubes.  </div> <br /> 
<h2><a class="anchor" id="subsectmc"></a>
Topologically correct Marching Cubes (TMC)</h2>
<p>This algorithm is an extension to MC and provides additional guarantees. It generates a mesh that is homeomorphic to the trilinear interpolant of the input function inside each cube. Furthermore, the mesh is guaranteed to be manifold and watertight, as long as the isosurface does not intersect the domain boundaries.</p>
<p>TODO examples</p>
<h2><a class="anchor" id="subsecdc"></a>
Dual Contouring (DC)</h2>
<p>DC creates one vertex in every cell that is intersected by the isosurface. Next, a face is created for each edge that intersects the isosurface, by connecting the vertices of the incident cells. For a uniform hexahedral grid, this results in a quadrilateral mesh.</p>
<p>The classical DC method requires the gradient of the scalar field. It is passed to the method as an additional parameter in the form of a functor. The default argument for this parameter assumes the gradient to be zero. Thus, for using the classical DC, the gradient has to be defined by the user.</p>
<p>Different versions of DC compute the vertex positions differently. Therefore, the vertex positioning is configurable with an optional parameter. Some of them do not require the gradient and therefore even work with the zero gradient.</p>
<p>Dual Contouring works on any domain but does not guarantee a manifold or watertight mesh. It creates less faces than Marching Cubes. The main advantage of DC over MC is the ability to represent sharp edges.</p>
<p><a class="anchor" id="fig__isosurfacing_iwp_dc"></a></p><center> <div class="image">
<img src="iwp_dc.png" style="max-width:40%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__isosurfacing_iwp_dc">Figure 60.3</a> Isosurface of the IWP function generated by Dual Contouring.  </div> <br /> 
<h2><a class="anchor" id="subseccomparison"></a>
Comparison</h2>
<table class="doxtable">
<tr>
<th>Algorithm </th><th>Domains </th><th>Faces </th><th>Manifold </th><th>Watertight* </th><th>Topologically correct  </th></tr>
<tr>
<td>MC </td><td>Hexahedral </td><td>Triangles </td><td>no </td><td>no </td><td>no </td></tr>
<tr>
<td>TMC </td><td>Hexahedral </td><td>Triangles </td><td>yes </td><td>yes </td><td>yes </td></tr>
<tr>
<td>DC </td><td>All </td><td>Polygons </td><td>no </td><td>no </td><td>no </td></tr>
</table>
<p>(* assuming the isosurface does not leave the given bounding box)</p>
<p><a class="anchor" id="fig__isosurfacing_compare_mc_dc"></a></p><center> <div class="image">
<img src="cube_mc_dc.png" style="max-width:70%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__isosurfacing_compare_mc_dc">Figure 60.4</a> Comparison between a cube generated by Dual Contouring (left) and Marching Cubes (right).  </div> <br /> 
<h1><a class="anchor" id="secmyinterface"></a>
Interface</h1>
<p>Each algorithm is represented by a single functions. The function signature is the same for all algorithms:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Concurrency_tag = Sequential_tag, <span class="keyword">class</span> Domain_, <span class="keyword">class</span> Po<span class="keywordtype">int</span>Range, <span class="keyword">class</span> PolygonRange&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="group__PkgIsosurfacing3Ref.html#gaefb927d1bed0dba94be85b1032465f60">make_triangle_mesh_using_marching_cubes</a>(<span class="keyword">const</span> Domain_&amp; domain, <span class="keyword">const</span> <span class="keyword">typename</span> Domain_::FT iso_value,</div><div class="line">                                             PointRange&amp; points, PolygonRange&amp; polygons);</div></div><!-- fragment --><p>The input is provided in the form of a <code>domain</code> (see <a class="el" href="index.html#secmydomains">Domains</a>).</p>
<p>The <code>iso_value</code> parameter describes the grid value the isosurface should represent.</p>
<p>The output is in the form of an indexed face set that is written to the two collections <code>points</code> and <code>polygons</code>. The vertex positions are stored as <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__3.html">Point_3</a></code> in <code>points</code>. Each face in <code>polygons</code> is a list of indices pointing into the <code>points</code> collection. Depending on the algorithm, the indexed face set may either store a polygon soup or a topological mesh.</p>
<p>Algorithms can run sequentially on one CPU core or in parallel. The Concurrency_tag is used to specify how the algorithm is executed and is either <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Sequential__tag.html">Sequential_tag</a> or <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__tag.html">Parallel_tag</a>. To enable parallelism, <a class="el" href="namespaceCGAL.html">CGAL</a> needs to be linked with the Intel TBB library. If the parallel version is not availible the sequential version will always be used as a fallback.</p>
<h1><a class="anchor" id="secmydomains"></a>
Domains</h1>
<p>A domain is an object that provides functions to access the input data, its geometry, topology, and optionally its gradient. There are some predefined domain classes that wrap the input data and provide a generalized interface for the algorithm. Users can also define new domains by implementing the <code>Isosurfacing_domain</code> concept.</p>
<h2><a class="anchor" id="mysubsecimplicitdomain"></a>
Implicit domain</h2>
<p>The <code>Implicit_domain</code> represents the input function in an implicit form without storing any values. It takes a functor or lambda that computes the value of the function from the position of a vertex as parameter. Additionally, the bounding box and spacing between grid points have to be specified.</p>
<h2><a class="anchor" id="mysubseccartesiandomain"></a>
Cartesian grid domain</h2>
<p>The <code>Cartesian_grid_domain</code> only takes a <code><a class="el" href="classCGAL_1_1Cartesian__grid__3.html">Cartesian_grid_3</a></code> as parameter. It represents a uniform grid of values that are either computed by the user or read from an <code>Image_3</code>. The constructor of <code><a class="el" href="classCGAL_1_1Cartesian__grid__3.html">Cartesian_grid_3</a></code> needs the number of grid points in each dimension and the bounding box. The values are read and written with <code>value(x, y, z)</code> where x, y, and z are the coordinates of a grid point. Alternatively, all required data can be copied from an <code>Image_3</code>.</p>
<h2><a class="anchor" id="mysubsecoctreedomain"></a>
Octree domain</h2>
<p>The <code>Octree_domain</code> wraps an octree to be used by isosurfacing algorithms. The octree has to be already refined. ...</p>
<h1><a class="anchor" id="secmybenchmarks"></a>
Performance</h1>
<p><a class="anchor" id="fig__isosurfacing_perf_iwp_mc"></a></p><center> <div class="image">
<object type="image/svg+xml" data="perf_threads_iwp_mc.svg" style="max-width:70%;"></object>
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__isosurfacing_perf_iwp_mc">Figure 60.5</a> <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Scaling.html">Scaling</a> of Marching Cubes with more threads.  </div> <br /> 
<h1><a class="anchor" id="secmyexamples"></a>
Examples</h1>
<h2><a class="anchor" id="myExampleImplicit_domain"></a>
Implicit sphere</h2>
<p>The following example shows the usage of the Marching Cubes algorithm to extract an isosurface. The domain is an <code>Implicit_domain</code> that describes a sphere by the distance to its origin as an implicit function.</p>
<p><br />
<b>File</b> <a class="el" href="Isosurfacing_3_2marching_cubes_implicit_sphere_8cpp-example.html">Isosurfacing_3/marching_cubes_implicit_sphere.cpp</a> </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Implicit_domain.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Marching_cubes_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/OFF.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;std::vector&lt;std::size_t&gt;&gt; Polygon_range;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// distance to the origin</span></div><div class="line">    <span class="keyword">auto</span> sphere_function = [](<span class="keyword">const</span> Point&amp; point) {</div><div class="line">        <span class="keywordflow">return</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">std::sqrt</a>(point.x() * point.x() + point.y() * point.y() + point.z() * point.z());</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// create a domain with bounding box [-1, 1]^3 and grid spacing 0.02</span></div><div class="line">    <a class="code" href="classCGAL_1_1Isosurfacing_1_1Implicit__domain.html">CGAL::Isosurfacing::Implicit_domain&lt;Kernel, decltype(sphere_function)&gt;</a> domain(</div><div class="line">        {-1, -1, -1, 1, 1, 1}, Vector(0.02f, 0.02f, 0.02f), sphere_function);  <span class="comment">// TODO: this is ugly</span></div><div class="line"></div><div class="line">    <span class="comment">// prepare collections for the result</span></div><div class="line">    Point_range points;</div><div class="line">    Polygon_range polygons;</div><div class="line"></div><div class="line">    <span class="comment">// execute marching cubes with an isovalue of 0.8</span></div><div class="line">    <a class="code" href="group__PkgIsosurfacing3Ref.html#gaefb927d1bed0dba94be85b1032465f60">CGAL::Isosurfacing::make_triangle_mesh_using_marching_cubes</a>(domain, 0.8f, points, polygons);</div><div class="line"></div><div class="line">    <span class="comment">// save the result in the OFF format</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result.off"</span>, points, polygons);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="myExampleAll_cube"></a>
Cartesian_grid_3 cube comparison</h2>
<p>The following example compares all provided algorithms to extract an isosurface. The domain is an <code>Cartesian_grid_domain</code> that describes a cube by storing the manhattan distance to its origin in a <code><a class="el" href="classCGAL_1_1Cartesian__grid__3.html">Cartesian_grid_3</a></code>.</p>
<p><br />
<b>File</b> <a class="el" href="Isosurfacing_3_2all_cartesian_cube_8cpp-example.html">Isosurfacing_3/all_cartesian_cube.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian_grid_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian_grid_domain.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Dual_contouring_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Marching_cubes_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/TC_marching_cubes_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/OFF.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Cartesian__grid__3.html">CGAL::Cartesian_grid_3&lt;Kernel&gt;</a> Grid;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;std::vector&lt;std::size_t&gt;&gt; Polygon_range;</div><div class="line"></div><div class="line">FT <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gaf3d75d272a29458960987a8f248ec636">sign</a>(FT value) {</div><div class="line">    <span class="keywordflow">return</span> (value &gt; 0) - (value &lt; 0);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// create a cartesian grid with 100^3 grid points and the bounding box [-1, 1]^3</span></div><div class="line">    Grid grid(7, 7, 7, {-1, -1, -1, 1, 1, 1});</div><div class="line"></div><div class="line">    <span class="comment">// calculate the value at all grid points</span></div><div class="line">    <span class="keywordflow">for</span> (std::size_t x = 0; x &lt; grid.xdim(); x++) {</div><div class="line">        <span class="keywordflow">for</span> (std::size_t y = 0; y &lt; grid.ydim(); y++) {</div><div class="line">            <span class="keywordflow">for</span> (std::size_t z = 0; z &lt; grid.zdim(); z++) {</div><div class="line"></div><div class="line">                <span class="keyword">const</span> FT pos_x = x * grid.get_spacing()[0] + grid.get_bbox().xmin();</div><div class="line">                <span class="keyword">const</span> FT pos_y = y * grid.get_spacing()[1] + grid.get_bbox().ymin();</div><div class="line">                <span class="keyword">const</span> FT pos_z = z * grid.get_spacing()[2] + grid.get_bbox().zmin();</div><div class="line"></div><div class="line">                <span class="comment">// manhattan distance to the origin</span></div><div class="line">                grid.value(x, y, z) = std::max({<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(pos_x), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(pos_y), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(pos_z)});</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> cube_gradient = [](<span class="keyword">const</span> Point&amp; p) {</div><div class="line">        <span class="comment">// the normal depends on the side of the cube</span></div><div class="line">        <span class="keyword">const</span> FT max_value = std::max({<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.x()), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.y()), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.z())});</div><div class="line"></div><div class="line">        Vector g(0, 0, 0);</div><div class="line">        <span class="keywordflow">if</span> (max_value == <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.x())) {</div><div class="line">            g += Vector(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gaf3d75d272a29458960987a8f248ec636">sign</a>(p.x()), 0, 0);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> (max_value == <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.y())) {</div><div class="line">            g += Vector(0, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gaf3d75d272a29458960987a8f248ec636">sign</a>(p.y()), 0);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> (max_value == <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.z())) {</div><div class="line">            g += Vector(0, 0, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gaf3d75d272a29458960987a8f248ec636">sign</a>(p.z()));</div><div class="line">        }</div><div class="line">        <span class="keyword">const</span> FT length_sq = g.squared_length();</div><div class="line">        <span class="keywordflow">if</span> (length_sq &gt; 0.00001) {</div><div class="line">            g /= CGAL::approximate_sqrt(length_sq);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> g;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// create a domain from the grid</span></div><div class="line">    <a class="code" href="classCGAL_1_1Isosurfacing_1_1Cartesian__grid__domain.html">CGAL::Isosurfacing::Cartesian_grid_domain&lt;Kernel, decltype(cube_gradient)&gt;</a> domain(grid, cube_gradient);</div><div class="line"></div><div class="line">    <span class="comment">// prepare collections for the results</span></div><div class="line">    Point_range points_mc, points_tmc, points_dc;</div><div class="line">    Polygon_range polygons_mc, polygons_tmc, polygons_dc;</div><div class="line"></div><div class="line">    <span class="comment">// execute marching cubes, topologically correct marching cubes and dual contouring with an isovalue of 0.8</span></div><div class="line">    <a class="code" href="group__PkgIsosurfacing3Ref.html#gaefb927d1bed0dba94be85b1032465f60">CGAL::Isosurfacing::make_triangle_mesh_using_marching_cubes</a>(domain, 0.88, points_mc, polygons_mc);</div><div class="line">    <a class="code" href="namespaceCGAL_1_1Isosurfacing.html#a0f2a5861ee0f085224ecccc2316f24b8">CGAL::Isosurfacing::make_triangle_mesh_using_tmc</a>(domain, 0.88, points_tmc, polygons_tmc);</div><div class="line">    <a class="code" href="namespaceCGAL_1_1Isosurfacing.html#af612ed0d7baf7e2f300ba98e52f96050">CGAL::Isosurfacing::make_quad_mesh_using_dual_contouring</a>(domain, 0.88, points_dc, polygons_dc);</div><div class="line"></div><div class="line">    <span class="comment">// save the results in the OFF format</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result_mc.off"</span>, points_mc, polygons_mc);</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result_tmc.off"</span>, points_tmc, polygons_tmc);</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result_dc.off"</span>, points_dc, polygons_dc);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="myExampleImage"></a>
Image_3</h2>
<p>The following example shows how to load data from an <code>Image_3</code>.</p>
<p><br />
<b>File</b> <a class="el" href="Isosurfacing_3_2marching_cubes_inrimage_8cpp-example.html">Isosurfacing_3/marching_cubes_inrimage.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian_grid_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian_grid_domain.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Marching_cubes_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/OFF.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Cartesian__grid__3.html">CGAL::Cartesian_grid_3&lt;Kernel&gt;</a> Grid;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;std::vector&lt;std::size_t&gt;&gt; Polygon_range;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string fname = <span class="stringliteral">"../../../data/skull_2.9.inr"</span>;</div><div class="line"></div><div class="line">    <span class="comment">// load the image</span></div><div class="line">    CGAL::Image_3 image;</div><div class="line">    <span class="keywordflow">if</span> (!image.read(fname)) {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">"Error: Cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// convert it to a cartesian grid</span></div><div class="line">    <span class="keyword">const</span> Grid grid(image);</div><div class="line"></div><div class="line">    <span class="comment">// create a domain from the grid</span></div><div class="line">    <a class="code" href="classCGAL_1_1Isosurfacing_1_1Cartesian__grid__domain.html">CGAL::Isosurfacing::Cartesian_grid_domain&lt;Kernel&gt;</a> domain(grid);</div><div class="line"></div><div class="line">    <span class="comment">// prepare collections for the result</span></div><div class="line">    Point_range points;</div><div class="line">    Polygon_range polygons;</div><div class="line"></div><div class="line">    <span class="comment">// execute marching cubes with an isovalue of 2.9</span></div><div class="line">    <a class="code" href="group__PkgIsosurfacing3Ref.html#gaefb927d1bed0dba94be85b1032465f60">CGAL::Isosurfacing::make_triangle_mesh_using_marching_cubes</a>(domain, 2.9, points, polygons);</div><div class="line"></div><div class="line">    <span class="comment">// save the result in the OFF format</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result.off"</span>, points, polygons);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="myExampleMeshOffset"></a>
Offset mesh</h2>
<p>The following example shows how to compute an offset mesh. The original mesh is passed to an <code>AABB_tree</code> to allow fast distance queries. With the use of <code>Side_of_triangle_mesh</code> the sign of the distance function is flipped inside the mesh.</p>
<p><br />
<b>File</b> <a class="el" href="Isosurfacing_3_2marching_cubes_mesh_offset_8cpp-example.html">Isosurfacing_3/marching_cubes_mesh_offset.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/AABB_face_graph_triangle_primitive.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/AABB_traits.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/AABB_tree.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian_grid_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian_grid_domain.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Marching_cubes_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Side_of_triangle_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/OFF.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Cartesian__grid__3.html">CGAL::Cartesian_grid_3&lt;Kernel&gt;</a> Grid;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> CGAL::Surface_mesh&lt;Point&gt; Mesh;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> CGAL::AABB_face_graph_triangle_primitive&lt;Mesh&gt; Primitive;</div><div class="line"><span class="keyword">typedef</span> CGAL::AABB_traits&lt;Kernel, Primitive&gt; Traits;</div><div class="line"><span class="keyword">typedef</span> CGAL::AABB_tree&lt;Traits&gt; Tree;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;std::vector&lt;std::size_t&gt;&gt; Polygon_range;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// computes the distance of a point p from the mesh with the use of a AABB_tree</span></div><div class="line"><span class="keyword">inline</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> distance_to_mesh(<span class="keyword">const</span> Tree&amp; tree, <span class="keyword">const</span> Point&amp; p) {</div><div class="line">    <span class="keyword">const</span> Point&amp; x = tree.closest_point(p);</div><div class="line">    <span class="keywordflow">return</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">std::sqrt</a>((p - x).squared_length());</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="keyword">const</span> std::string input_name = <span class="stringliteral">"../../../data/bunny.off"</span>;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> n_voxels = 20;</div><div class="line">    <span class="keyword">const</span> FT offset_value = -0.03;</div><div class="line"></div><div class="line">    <span class="comment">// load the original mesh</span></div><div class="line">    Mesh mesh_input;</div><div class="line">    <span class="keywordflow">if</span> (!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga7396bef8d41fe287d52d19ddbb83a3e4">CGAL::IO::read_OFF</a>(input_name, mesh_input)) {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">"Could not read mesh"</span> &lt;&lt; std::endl;</div><div class="line">        exit(-1);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// compute the new bounding box</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html">CGAL::Bbox_3</a> aabb_grid = CGAL::Polygon_mesh_processing::bbox(mesh_input);</div><div class="line">    Vector aabb_increase_vec = Vector(offset_value + 0.01, offset_value + 0.01, offset_value + 0.01);</div><div class="line">    aabb_grid += (Point(aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a3f5e323700e1509624a02d151237cc4c">xmax</a>(), aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a9d06f61bd89faa841e011ff53edf745f">ymax</a>(), aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a98def8b9515f31ded759d781969ddaf6">zmax</a>()) + aabb_increase_vec).bbox();</div><div class="line">    aabb_grid += (Point(aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#aab574470a2591f187553ca1166e682e1">xmin</a>(), aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a2088e16a1f0a20e011e5b94c2e9c222a">ymin</a>(), aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a6c55430abc7fda54571cf1075c7f2f8b">zmin</a>()) - aabb_increase_vec).bbox();</div><div class="line"></div><div class="line">    <span class="comment">// construct AABB tree</span></div><div class="line">    Tree tree(mesh_input.faces_begin(), mesh_input.faces_end(), mesh_input);</div><div class="line"></div><div class="line">    CGAL::Side_of_triangle_mesh&lt;Mesh, CGAL::GetGeomTraits&lt;Mesh&gt;::type&gt; sotm(mesh_input);</div><div class="line"></div><div class="line">    <span class="comment">// create the grid</span></div><div class="line">    Grid grid(n_voxels, n_voxels, n_voxels, aabb_grid);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (std::size_t z = 0; z &lt; grid.zdim(); z++) {</div><div class="line">        <span class="keywordflow">for</span> (std::size_t y = 0; y &lt; grid.ydim(); y++) {</div><div class="line">            <span class="keywordflow">for</span> (std::size_t x = 0; x &lt; grid.xdim(); x++) {</div><div class="line"></div><div class="line">                <span class="keyword">const</span> FT pos_x = x * grid.get_spacing()[0] + grid.get_bbox().xmin();</div><div class="line">                <span class="keyword">const</span> FT pos_y = y * grid.get_spacing()[1] + grid.get_bbox().ymin();</div><div class="line">                <span class="keyword">const</span> FT pos_z = z * grid.get_spacing()[2] + grid.get_bbox().zmin();</div><div class="line">                <span class="keyword">const</span> Point p(pos_x, pos_y, pos_z);</div><div class="line"></div><div class="line">                <span class="comment">// compute the distance</span></div><div class="line">                grid.value(x, y, z) = distance_to_mesh(tree, p);</div><div class="line"></div><div class="line">                <span class="comment">// flip the sign, so the distance is negative inside the mesh</span></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">bool</span> is_inside = (sotm(p) == <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ggaf6030e89dadcc1f45369b0cdc5d9e111ad8333d35d4801c08b3a5ae9e94d7cabe">CGAL::ON_BOUNDED_SIDE</a>);</div><div class="line">                <span class="keywordflow">if</span> (is_inside) {</div><div class="line">                    grid.value(x, y, z) *= -1;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// create a domain from the grid</span></div><div class="line">    <a class="code" href="classCGAL_1_1Isosurfacing_1_1Cartesian__grid__domain.html">CGAL::Isosurfacing::Cartesian_grid_domain&lt;Kernel&gt;</a> domain(grid);</div><div class="line"></div><div class="line">    <span class="comment">// prepare collections for the result</span></div><div class="line">    Point_range points;</div><div class="line">    Polygon_range polygons;</div><div class="line"></div><div class="line">    <span class="comment">// execute marching cubes with an isovalue equal to the offset</span></div><div class="line">    <a class="code" href="group__PkgIsosurfacing3Ref.html#gaefb927d1bed0dba94be85b1032465f60">CGAL::Isosurfacing::make_triangle_mesh_using_marching_cubes</a>(domain, offset_value, points, polygons);</div><div class="line"></div><div class="line">    <span class="comment">// save the result in the OFF format</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result.off"</span>, points, polygons);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="myExampleOctree"></a>
Octree Dual Contouring</h2>
<p>The following example shows how to extract an isosurface from an octree using Dual Contouring. The domain is an <code>Octree_domain</code> that describes a sphere by the distance to its origin stored in an octree. The octree is highly refined in one octant and only coarse in the others.</p>
<p><br />
<b>File</b> <a class="el" href="Isosurfacing_3_2dual_contouring_octree_8cpp-example.html">Isosurfacing_3/dual_contouring_octree.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Dual_contouring_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Octree_domain.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Octree_wrapper.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/OFF.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;math.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector_3;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point_3;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point_3&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;std::vector&lt;std::size_t&gt;&gt; Polygon_range;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Isosurfacing_1_1Octree__wrapper.html">CGAL::Isosurfacing::Octree_wrapper&lt;Kernel&gt;</a> Octree_wrapper_;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Isosurfacing_1_1Octree__domain.html">CGAL::Isosurfacing::Octree_domain&lt;Kernel&gt;</a> Octree_domain_;</div><div class="line"></div><div class="line"><a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> sphere_function(<span class="keyword">const</span> Point_3&amp; point) {</div><div class="line">    <span class="keywordflow">return</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">std::sqrt</a>(point.x() * point.x() + point.y() * point.y() + point.z() * point.z());</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Refine_one_eighth {</div><div class="line">    std::size_t min_depth_;</div><div class="line">    std::size_t max_depth_;</div><div class="line"></div><div class="line">    std::size_t octree_dim_;</div><div class="line"></div><div class="line">    Octree_wrapper_::Uniform_coords uniform_coordinates(<span class="keyword">const</span> Octree_wrapper_::Octree::Node&amp; node)<span class="keyword"> const </span>{</div><div class="line">        <span class="keyword">auto</span> coords = node.global_coordinates();</div><div class="line">        <span class="keyword">const</span> std::size_t depth_factor = std::size_t(1) &lt;&lt; (max_depth_ - node.depth());</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; Octree_wrapper_::Octree::Node::Dimension::value; ++i) {</div><div class="line">            coords[i] *= (uint32_t)depth_factor;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> coords;</div><div class="line">    }</div><div class="line"></div><div class="line">    Refine_one_eighth(std::size_t min_depth, std::size_t max_depth) : min_depth_(min_depth), max_depth_(max_depth) {</div><div class="line">        octree_dim_ = std::size_t(1) &lt;&lt; max_depth_;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> Octree_wrapper_::Octree::Node&amp; n)<span class="keyword"> const </span>{</div><div class="line">        <span class="comment">// n.depth()</span></div><div class="line">        <span class="keywordflow">if</span> (n.depth() &lt; min_depth_) {</div><div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> (n.depth() == max_depth_) {</div><div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> leaf_coords = uniform_coordinates(n);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (leaf_coords[0] &gt;= octree_dim_ / 2) {</div><div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> (leaf_coords[1] &gt;= octree_dim_ / 2) {</div><div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> (leaf_coords[2] &gt;= octree_dim_ / 2) {</div><div class="line">            <span class="comment">// return false;</span></div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    Octree_wrapper_ octree_wrap({-1, -1, -1, 1, 1, 1});</div><div class="line"></div><div class="line">    Refine_one_eighth split_predicate(4, 6);</div><div class="line">    octree_wrap.refine(split_predicate);</div><div class="line"></div><div class="line">    Octree_domain_ octree_domain(octree_wrap);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> lam = [&amp;](<span class="keyword">const</span> Octree_domain_::Vertex_handle&amp; v) {</div><div class="line">        Point_3 p = octree_domain.position(v);</div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> val = sphere_function(p);</div><div class="line">        Vector_3 gradient = p - <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga9d272a8e3a8080b851741b6d3a44afdc">CGAL::ORIGIN</a>;</div><div class="line">        gradient = gradient / <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">std::sqrt</a>(gradient.squared_length());</div><div class="line">        octree_wrap.value(v) = val;</div><div class="line">        octree_wrap.gradient(v) = gradient;</div><div class="line">    };</div><div class="line">    octree_domain.iterate_vertices(lam, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Sequential__tag.html">CGAL::Sequential_tag</a>());</div><div class="line"></div><div class="line">    Point_range points;</div><div class="line">    Polygon_range polygons;</div><div class="line"></div><div class="line">    <a class="code" href="namespaceCGAL_1_1Isosurfacing.html#af612ed0d7baf7e2f300ba98e52f96050">CGAL::Isosurfacing::make_quad_mesh_using_dual_contouring</a>(octree_domain, 0.8, points, polygons);</div><div class="line"></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result.off"</span>, points, polygons);</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Sep 15 2022 14:12:25 for CGAL 5.6 - 3D Isosurfacing by
    <a href="https://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>
</html>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.6 - 3D Isosurfacing
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Isosurfacing3"></a>  </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Author</dt><dd>Julian Stahl and Daniel Zint</dd></dl>
<p><a class="anchor" id="fig__isosurfacing_bunny_offset"></a></p><center> <div class="image">
<img src="bunny_offset.gif" style="max-width:50%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__isosurfacing_bunny_offset">Figure 60.1</a> Different isovalues of a bunny.  </div> <br /> 
<h1><a class="anchor" id="secmyintroduction"></a>
Introduction</h1>
<p>This package provides methods to compute a surface mesh representing an isosurface of a 3-dimensional scalar field. An isosurface is defined as the surface on which the value of this field is equal to a given constant, i.e. the isovalue. Depending on the isosurfacing method and the input data structure, the result is either a triangular, quadrilateral, or higher order polygonal indexed face set.</p>
<h1><a class="anchor" id="secmyalgorithms"></a>
Algorithms</h1>
<p>There are multiple algorithms to extract isosurfaces. This package contains Marching Cubes, topologically correct Marching Cubes, Dual Contouring, and Octree Marching. (References?)</p>
<h2><a class="anchor" id="subsecmc"></a>
Marching Cubes (MC)</h2>
<p>MC processes all cells of the input domain individually. Each cell corner gets a sign (+/-) to indicate if it is above or below the isovalue. A new vertex is created on every cell edge where the sign changes, i.e. the isosurface is intersected. The vertex position is computed via linear interpolation of the scalar values of the incident corners. Depending on the configuration of signs at the corners the resulting vertices are connected to form triangles within the cell.</p>
<p>MC can process any input data structure that consists of hexahedral cells. In case of a conforming grid, MC produces a triangle mesh that is manifold in most scenarios. If the mesh is manifold and the isosurface does not intersect the domain boundaries, the mesh is also watertight. Compared to other approaches the algorithm often generates more and many thin triangles with acute angles. MC does not preserve sharp edges.</p>
<p><a class="anchor" id="fig__isosurfacing_mc_cases"></a></p><center> <div class="image">
<img src="mc_cases.png" style="max-width:70%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__isosurfacing_mc_cases">Figure 60.2</a> Some example cases of Marching Cubes.  </div> <br /> 
<h2><a class="anchor" id="subsectmc"></a>
Topologically correct Marching Cubes (TMC)</h2>
<p>This algorithm is an extension to MC and provides additional guarantees. It generates a mesh that is homeomorphic to the trilinear interpolant of the input function inside each cube. Furthermore, the mesh is guaranteed to be manifold and watertight, as long as the isosurface does not intersect the domain boundaries.</p>
<p>TODO examples</p>
<h2><a class="anchor" id="subsecdc"></a>
Dual Contouring (DC)</h2>
<p>DC creates one vertex in every cell that is intersected by the isosurface. Next, a face is created for each edge that intersects the isosurface, by connecting the vertices of the incident cells. For a uniform hexahedral grid, this results in a quadrilateral mesh.</p>
<p>The classical DC method requires the gradient of the scalar field. It is passed to the method as an additional parameter in the form of a functor. The default argument for this parameter assumes the gradient to be zero. Thus, for using the classical DC, the gradient has to be defined by the user.</p>
<p>Different versions of DC compute the vertex positions differently. Therefore, the vertex positioning is configurable with an optional parameter. Some of them do not require the gradient and therefore even work with the zero gradient.</p>
<p>Dual Contouring works on any domain but does not guarantee a manifold or watertight mesh. It creates less faces than Marching Cubes. The main advantage of DC over MC is the ability to represent sharp edges.</p>
<p><a class="anchor" id="fig__isosurfacing_iwp_dc"></a></p><center> <div class="image">
<img src="iwp_dc.png" style="max-width:40%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__isosurfacing_iwp_dc">Figure 60.3</a> Isosurface of the IWP function generated by Dual Contouring.  </div> <br /> 
<h2><a class="anchor" id="subseccomparison"></a>
Comparison</h2>
<table class="doxtable">
<tr>
<th>Algorithm </th><th>Domains </th><th>Faces </th><th>Manifold </th><th>Watertight* </th><th>Topologically correct  </th></tr>
<tr>
<td>MC </td><td>Hexahedral </td><td>Triangles </td><td>no </td><td>no </td><td>no </td></tr>
<tr>
<td>TMC </td><td>Hexahedral </td><td>Triangles </td><td>yes </td><td>yes </td><td>yes </td></tr>
<tr>
<td>DC </td><td>All </td><td>Polygons </td><td>no </td><td>no </td><td>no </td></tr>
</table>
<p>(* assuming the isosurface does not leave the given bounding box)</p>
<p><a class="anchor" id="fig__isosurfacing_compare_mc_dc"></a></p><center> <div class="image">
<img src="cube_mc_dc.png" style="max-width:70%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__isosurfacing_compare_mc_dc">Figure 60.4</a> Comparison between a cube generated by Dual Contouring (left) and Marching Cubes (right).  </div> <br /> 
<h1><a class="anchor" id="secmyinterface"></a>
Interface</h1>
<p>Each algorithm is represented by a single functions. The function signature is the same for all algorithms:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Concurrency_tag = Sequential_tag, <span class="keyword">class</span> Domain_, <span class="keyword">class</span> Po<span class="keywordtype">int</span>Range, <span class="keyword">class</span> PolygonRange&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="group__PkgIsosurfacing3Ref.html#gaefb927d1bed0dba94be85b1032465f60">make_triangle_mesh_using_marching_cubes</a>(<span class="keyword">const</span> Domain_&amp; domain, <span class="keyword">const</span> <span class="keyword">typename</span> Domain_::FT iso_value,</div><div class="line">                                             PointRange&amp; points, PolygonRange&amp; polygons);</div></div><!-- fragment --><p>The input is provided in the form of a <code>domain</code> (see <a class="el" href="index.html#secmydomains">Domains</a>).</p>
<p>The <code>iso_value</code> parameter describes the grid value the isosurface should represent.</p>
<p>The output is in the form of an indexed face set that is written to the two collections <code>points</code> and <code>polygons</code>. The vertex positions are stored as <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__3.html">Point_3</a></code> in <code>points</code>. Each face in <code>polygons</code> is a list of indices pointing into the <code>points</code> collection. Depending on the algorithm, the indexed face set may either store a polygon soup or a topological mesh.</p>
<p>Algorithms can run sequentially on one CPU core or in parallel. The Concurrency_tag is used to specify how the algorithm is executed and is either <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Sequential__tag.html">Sequential_tag</a> or <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__tag.html">Parallel_tag</a>. To enable parallelism, <a class="el" href="namespaceCGAL.html">CGAL</a> needs to be linked with the Intel TBB library. If the parallel version is not availible the sequential version will always be used as a fallback.</p>
<h1><a class="anchor" id="secmydomains"></a>
Domains</h1>
<p>A domain is an object that provides functions to access the input data, its geometry, topology, and optionally its gradient. There are some predefined domain classes that wrap the input data and provide a generalized interface for the algorithm. Users can also define new domains by implementing the <code>Isosurfacing_domain</code> concept.</p>
<h2><a class="anchor" id="mysubsecimplicitdomain"></a>
Implicit domain</h2>
<p>The <code>Implicit_domain</code> represents the input function in an implicit form without storing any values. It takes a functor or lambda that computes the value of the function from the position of a vertex as parameter. Additionally, the bounding box and spacing between grid points have to be specified.</p>
<h2><a class="anchor" id="mysubseccartesiandomain"></a>
Cartesian grid domain</h2>
<p>The <code>Cartesian_grid_domain</code> only takes a <code><a class="el" href="classCGAL_1_1Cartesian__grid__3.html">Cartesian_grid_3</a></code> as parameter. It represents a uniform grid of values that are either computed by the user or read from an <code>Image_3</code>. The constructor of <code><a class="el" href="classCGAL_1_1Cartesian__grid__3.html">Cartesian_grid_3</a></code> needs the number of grid points in each dimension and the bounding box. The values are read and written with <code>value(x, y, z)</code> where x, y, and z are the coordinates of a grid point. Alternatively, all required data can be copied from an <code>Image_3</code>.</p>
<h2><a class="anchor" id="mysubsecoctreedomain"></a>
Octree domain</h2>
<p>The <code>Octree_domain</code> wraps an octree to be used by isosurfacing algorithms. The octree has to be already refined. ...</p>
<h1><a class="anchor" id="secmybenchmarks"></a>
Performance</h1>
<p><a class="anchor" id="fig__isosurfacing_perf_iwp_mc"></a></p><center> <div class="image">
<object type="image/svg+xml" data="perf_threads_iwp_mc.svg" style="max-width:70%;"></object>
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__isosurfacing_perf_iwp_mc">Figure 60.5</a> <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Scaling.html">Scaling</a> of Marching Cubes with more threads.  </div> <br /> 
<h1><a class="anchor" id="secmyexamples"></a>
Examples</h1>
<h2><a class="anchor" id="myExampleImplicit_domain"></a>
Implicit sphere</h2>
<p>The following example shows the usage of the Marching Cubes algorithm to extract an isosurface. The domain is an <code>Implicit_domain</code> that describes a sphere by the distance to its origin as an implicit function.</p>
<p><br />
<b>File</b> <a class="el" href="Isosurfacing_3_2marching_cubes_implicit_sphere_8cpp-example.html">Isosurfacing_3/marching_cubes_implicit_sphere.cpp</a> </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Implicit_domain.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Marching_cubes_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/OFF.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;std::vector&lt;std::size_t&gt;&gt; Polygon_range;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// distance to the origin</span></div><div class="line">    <span class="keyword">auto</span> sphere_function = [](<span class="keyword">const</span> Point&amp; point) {</div><div class="line">        <span class="keywordflow">return</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">std::sqrt</a>(point.x() * point.x() + point.y() * point.y() + point.z() * point.z());</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// create a domain with bounding box [-1, 1]^3 and grid spacing 0.02</span></div><div class="line">    <a class="code" href="classCGAL_1_1Isosurfacing_1_1Implicit__domain.html">CGAL::Isosurfacing::Implicit_domain&lt;Kernel, decltype(sphere_function)&gt;</a> domain(</div><div class="line">        {-1, -1, -1, 1, 1, 1}, Vector(0.02f, 0.02f, 0.02f), sphere_function);  <span class="comment">// TODO: this is ugly</span></div><div class="line"></div><div class="line">    <span class="comment">// prepare collections for the result</span></div><div class="line">    Point_range points;</div><div class="line">    Polygon_range polygons;</div><div class="line"></div><div class="line">    <span class="comment">// execute marching cubes with an isovalue of 0.8</span></div><div class="line">    <a class="code" href="group__PkgIsosurfacing3Ref.html#gaefb927d1bed0dba94be85b1032465f60">CGAL::Isosurfacing::make_triangle_mesh_using_marching_cubes</a>(domain, 0.8f, points, polygons);</div><div class="line"></div><div class="line">    <span class="comment">// save the result in the OFF format</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result.off"</span>, points, polygons);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="myExampleAll_cube"></a>
Cartesian_grid_3 cube comparison</h2>
<p>The following example compares all provided algorithms to extract an isosurface. The domain is an <code>Cartesian_grid_domain</code> that describes a cube by storing the manhattan distance to its origin in a <code><a class="el" href="classCGAL_1_1Cartesian__grid__3.html">Cartesian_grid_3</a></code>.</p>
<p><br />
<b>File</b> <a class="el" href="Isosurfacing_3_2all_cartesian_cube_8cpp-example.html">Isosurfacing_3/all_cartesian_cube.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian_grid_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian_grid_domain.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Dual_contouring_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Marching_cubes_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/TC_marching_cubes_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/OFF.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Cartesian__grid__3.html">CGAL::Cartesian_grid_3&lt;Kernel&gt;</a> Grid;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;std::vector&lt;std::size_t&gt;&gt; Polygon_range;</div><div class="line"></div><div class="line">FT <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gaf3d75d272a29458960987a8f248ec636">sign</a>(FT value) {</div><div class="line">    <span class="keywordflow">return</span> (value &gt; 0) - (value &lt; 0);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// create a cartesian grid with 100^3 grid points and the bounding box [-1, 1]^3</span></div><div class="line">    Grid grid(7, 7, 7, {-1, -1, -1, 1, 1, 1});</div><div class="line"></div><div class="line">    <span class="comment">// calculate the value at all grid points</span></div><div class="line">    <span class="keywordflow">for</span> (std::size_t x = 0; x &lt; grid.xdim(); x++) {</div><div class="line">        <span class="keywordflow">for</span> (std::size_t y = 0; y &lt; grid.ydim(); y++) {</div><div class="line">            <span class="keywordflow">for</span> (std::size_t z = 0; z &lt; grid.zdim(); z++) {</div><div class="line"></div><div class="line">                <span class="keyword">const</span> FT pos_x = x * grid.get_spacing()[0] + grid.get_bbox().xmin();</div><div class="line">                <span class="keyword">const</span> FT pos_y = y * grid.get_spacing()[1] + grid.get_bbox().ymin();</div><div class="line">                <span class="keyword">const</span> FT pos_z = z * grid.get_spacing()[2] + grid.get_bbox().zmin();</div><div class="line"></div><div class="line">                <span class="comment">// manhattan distance to the origin</span></div><div class="line">                grid.value(x, y, z) = std::max({<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(pos_x), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(pos_y), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(pos_z)});</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> cube_gradient = [](<span class="keyword">const</span> Point&amp; p) {</div><div class="line">        <span class="comment">// the normal depends on the side of the cube</span></div><div class="line">        <span class="keyword">const</span> FT max_value = std::max({<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.x()), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.y()), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.z())});</div><div class="line"></div><div class="line">        Vector g(0, 0, 0);</div><div class="line">        <span class="keywordflow">if</span> (max_value == <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.x())) {</div><div class="line">            g += Vector(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gaf3d75d272a29458960987a8f248ec636">sign</a>(p.x()), 0, 0);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> (max_value == <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.y())) {</div><div class="line">            g += Vector(0, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gaf3d75d272a29458960987a8f248ec636">sign</a>(p.y()), 0);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> (max_value == <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.z())) {</div><div class="line">            g += Vector(0, 0, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gaf3d75d272a29458960987a8f248ec636">sign</a>(p.z()));</div><div class="line">        }</div><div class="line">        <span class="keyword">const</span> FT length_sq = g.squared_length();</div><div class="line">        <span class="keywordflow">if</span> (length_sq &gt; 0.00001) {</div><div class="line">            g /= CGAL::approximate_sqrt(length_sq);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> g;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// create a domain from the grid</span></div><div class="line">    <a class="code" href="classCGAL_1_1Isosurfacing_1_1Cartesian__grid__domain.html">CGAL::Isosurfacing::Cartesian_grid_domain&lt;Kernel, decltype(cube_gradient)&gt;</a> domain(grid, cube_gradient);</div><div class="line"></div><div class="line">    <span class="comment">// prepare collections for the results</span></div><div class="line">    Point_range points_mc, points_tmc, points_dc;</div><div class="line">    Polygon_range polygons_mc, polygons_tmc, polygons_dc;</div><div class="line"></div><div class="line">    <span class="comment">// execute marching cubes, topologically correct marching cubes and dual contouring with an isovalue of 0.8</span></div><div class="line">    <a class="code" href="group__PkgIsosurfacing3Ref.html#gaefb927d1bed0dba94be85b1032465f60">CGAL::Isosurfacing::make_triangle_mesh_using_marching_cubes</a>(domain, 0.88, points_mc, polygons_mc);</div><div class="line">    <a class="code" href="namespaceCGAL_1_1Isosurfacing.html#a0f2a5861ee0f085224ecccc2316f24b8">CGAL::Isosurfacing::make_triangle_mesh_using_tmc</a>(domain, 0.88, points_tmc, polygons_tmc);</div><div class="line">    <a class="code" href="namespaceCGAL_1_1Isosurfacing.html#af612ed0d7baf7e2f300ba98e52f96050">CGAL::Isosurfacing::make_quad_mesh_using_dual_contouring</a>(domain, 0.88, points_dc, polygons_dc);</div><div class="line"></div><div class="line">    <span class="comment">// save the results in the OFF format</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result_mc.off"</span>, points_mc, polygons_mc);</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result_tmc.off"</span>, points_tmc, polygons_tmc);</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result_dc.off"</span>, points_dc, polygons_dc);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="myExampleImage"></a>
Image_3</h2>
<p>The following example shows how to load data from an <code>Image_3</code>.</p>
<p><br />
<b>File</b> <a class="el" href="Isosurfacing_3_2marching_cubes_inrimage_8cpp-example.html">Isosurfacing_3/marching_cubes_inrimage.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian_grid_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian_grid_domain.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Marching_cubes_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/OFF.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Cartesian__grid__3.html">CGAL::Cartesian_grid_3&lt;Kernel&gt;</a> Grid;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;std::vector&lt;std::size_t&gt;&gt; Polygon_range;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string fname = <span class="stringliteral">"../../../data/skull_2.9.inr"</span>;</div><div class="line"></div><div class="line">    <span class="comment">// load the image</span></div><div class="line">    CGAL::Image_3 image;</div><div class="line">    <span class="keywordflow">if</span> (!image.read(fname)) {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">"Error: Cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// convert it to a cartesian grid</span></div><div class="line">    <span class="keyword">const</span> Grid grid(image);</div><div class="line"></div><div class="line">    <span class="comment">// create a domain from the grid</span></div><div class="line">    <a class="code" href="classCGAL_1_1Isosurfacing_1_1Cartesian__grid__domain.html">CGAL::Isosurfacing::Cartesian_grid_domain&lt;Kernel&gt;</a> domain(grid);</div><div class="line"></div><div class="line">    <span class="comment">// prepare collections for the result</span></div><div class="line">    Point_range points;</div><div class="line">    Polygon_range polygons;</div><div class="line"></div><div class="line">    <span class="comment">// execute marching cubes with an isovalue of 2.9</span></div><div class="line">    <a class="code" href="group__PkgIsosurfacing3Ref.html#gaefb927d1bed0dba94be85b1032465f60">CGAL::Isosurfacing::make_triangle_mesh_using_marching_cubes</a>(domain, 2.9, points, polygons);</div><div class="line"></div><div class="line">    <span class="comment">// save the result in the OFF format</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result.off"</span>, points, polygons);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="myExampleMeshOffset"></a>
Offset mesh</h2>
<p>The following example shows how to compute an offset mesh. The original mesh is passed to an <code>AABB_tree</code> to allow fast distance queries. With the use of <code>Side_of_triangle_mesh</code> the sign of the distance function is flipped inside the mesh.</p>
<p><br />
<b>File</b> <a class="el" href="Isosurfacing_3_2marching_cubes_mesh_offset_8cpp-example.html">Isosurfacing_3/marching_cubes_mesh_offset.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/AABB_face_graph_triangle_primitive.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/AABB_traits.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/AABB_tree.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian_grid_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian_grid_domain.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Marching_cubes_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Side_of_triangle_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/OFF.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Cartesian__grid__3.html">CGAL::Cartesian_grid_3&lt;Kernel&gt;</a> Grid;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> CGAL::Surface_mesh&lt;Point&gt; Mesh;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> CGAL::AABB_face_graph_triangle_primitive&lt;Mesh&gt; Primitive;</div><div class="line"><span class="keyword">typedef</span> CGAL::AABB_traits&lt;Kernel, Primitive&gt; Traits;</div><div class="line"><span class="keyword">typedef</span> CGAL::AABB_tree&lt;Traits&gt; Tree;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;std::vector&lt;std::size_t&gt;&gt; Polygon_range;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// computes the distance of a point p from the mesh with the use of a AABB_tree</span></div><div class="line"><span class="keyword">inline</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> distance_to_mesh(<span class="keyword">const</span> Tree&amp; tree, <span class="keyword">const</span> Point&amp; p) {</div><div class="line">    <span class="keyword">const</span> Point&amp; x = tree.closest_point(p);</div><div class="line">    <span class="keywordflow">return</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">std::sqrt</a>((p - x).squared_length());</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="keyword">const</span> std::string input_name = <span class="stringliteral">"../../../data/bunny.off"</span>;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> n_voxels = 20;</div><div class="line">    <span class="keyword">const</span> FT offset_value = -0.03;</div><div class="line"></div><div class="line">    <span class="comment">// load the original mesh</span></div><div class="line">    Mesh mesh_input;</div><div class="line">    <span class="keywordflow">if</span> (!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga7396bef8d41fe287d52d19ddbb83a3e4">CGAL::IO::read_OFF</a>(input_name, mesh_input)) {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">"Could not read mesh"</span> &lt;&lt; std::endl;</div><div class="line">        exit(-1);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// compute the new bounding box</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html">CGAL::Bbox_3</a> aabb_grid = CGAL::Polygon_mesh_processing::bbox(mesh_input);</div><div class="line">    Vector aabb_increase_vec = Vector(offset_value + 0.01, offset_value + 0.01, offset_value + 0.01);</div><div class="line">    aabb_grid += (Point(aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a3f5e323700e1509624a02d151237cc4c">xmax</a>(), aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a9d06f61bd89faa841e011ff53edf745f">ymax</a>(), aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a98def8b9515f31ded759d781969ddaf6">zmax</a>()) + aabb_increase_vec).bbox();</div><div class="line">    aabb_grid += (Point(aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#aab574470a2591f187553ca1166e682e1">xmin</a>(), aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a2088e16a1f0a20e011e5b94c2e9c222a">ymin</a>(), aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a6c55430abc7fda54571cf1075c7f2f8b">zmin</a>()) - aabb_increase_vec).bbox();</div><div class="line"></div><div class="line">    <span class="comment">// construct AABB tree</span></div><div class="line">    Tree tree(mesh_input.faces_begin(), mesh_input.faces_end(), mesh_input);</div><div class="line"></div><div class="line">    CGAL::Side_of_triangle_mesh&lt;Mesh, CGAL::GetGeomTraits&lt;Mesh&gt;::type&gt; sotm(mesh_input);</div><div class="line"></div><div class="line">    <span class="comment">// create the grid</span></div><div class="line">    Grid grid(n_voxels, n_voxels, n_voxels, aabb_grid);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (std::size_t z = 0; z &lt; grid.zdim(); z++) {</div><div class="line">        <span class="keywordflow">for</span> (std::size_t y = 0; y &lt; grid.ydim(); y++) {</div><div class="line">            <span class="keywordflow">for</span> (std::size_t x = 0; x &lt; grid.xdim(); x++) {</div><div class="line"></div><div class="line">                <span class="keyword">const</span> FT pos_x = x * grid.get_spacing()[0] + grid.get_bbox().xmin();</div><div class="line">                <span class="keyword">const</span> FT pos_y = y * grid.get_spacing()[1] + grid.get_bbox().ymin();</div><div class="line">                <span class="keyword">const</span> FT pos_z = z * grid.get_spacing()[2] + grid.get_bbox().zmin();</div><div class="line">                <span class="keyword">const</span> Point p(pos_x, pos_y, pos_z);</div><div class="line"></div><div class="line">                <span class="comment">// compute the distance</span></div><div class="line">                grid.value(x, y, z) = distance_to_mesh(tree, p);</div><div class="line"></div><div class="line">                <span class="comment">// flip the sign, so the distance is negative inside the mesh</span></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">bool</span> is_inside = (sotm(p) == <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ggaf6030e89dadcc1f45369b0cdc5d9e111ad8333d35d4801c08b3a5ae9e94d7cabe">CGAL::ON_BOUNDED_SIDE</a>);</div><div class="line">                <span class="keywordflow">if</span> (is_inside) {</div><div class="line">                    grid.value(x, y, z) *= -1;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// create a domain from the grid</span></div><div class="line">    <a class="code" href="classCGAL_1_1Isosurfacing_1_1Cartesian__grid__domain.html">CGAL::Isosurfacing::Cartesian_grid_domain&lt;Kernel&gt;</a> domain(grid);</div><div class="line"></div><div class="line">    <span class="comment">// prepare collections for the result</span></div><div class="line">    Point_range points;</div><div class="line">    Polygon_range polygons;</div><div class="line"></div><div class="line">    <span class="comment">// execute marching cubes with an isovalue equal to the offset</span></div><div class="line">    <a class="code" href="group__PkgIsosurfacing3Ref.html#gaefb927d1bed0dba94be85b1032465f60">CGAL::Isosurfacing::make_triangle_mesh_using_marching_cubes</a>(domain, offset_value, points, polygons);</div><div class="line"></div><div class="line">    <span class="comment">// save the result in the OFF format</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result.off"</span>, points, polygons);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="myExampleOctree"></a>
Octree Dual Contouring</h2>
<p>The following example shows how to extract an isosurface from an octree using Dual Contouring. The domain is an <code>Octree_domain</code> that describes a sphere by the distance to its origin stored in an octree. The octree is highly refined in one octant and only coarse in the others.</p>
<p><br />
<b>File</b> <a class="el" href="Isosurfacing_3_2dual_contouring_octree_8cpp-example.html">Isosurfacing_3/dual_contouring_octree.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Dual_contouring_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Octree_domain.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Octree_wrapper.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/OFF.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;math.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector_3;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point_3;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point_3&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;std::vector&lt;std::size_t&gt;&gt; Polygon_range;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Isosurfacing_1_1Octree__wrapper.html">CGAL::Isosurfacing::Octree_wrapper&lt;Kernel&gt;</a> Octree_wrapper_;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Isosurfacing_1_1Octree__domain.html">CGAL::Isosurfacing::Octree_domain&lt;Kernel&gt;</a> Octree_domain_;</div><div class="line"></div><div class="line"><a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> sphere_function(<span class="keyword">const</span> Point_3&amp; point) {</div><div class="line">    <span class="keywordflow">return</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">std::sqrt</a>(point.x() * point.x() + point.y() * point.y() + point.z() * point.z());</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Refine_one_eighth {</div><div class="line">    std::size_t min_depth_;</div><div class="line">    std::size_t max_depth_;</div><div class="line"></div><div class="line">    std::size_t octree_dim_;</div><div class="line"></div><div class="line">    Octree_wrapper_::Uniform_coords uniform_coordinates(<span class="keyword">const</span> Octree_wrapper_::Octree::Node&amp; node)<span class="keyword"> const </span>{</div><div class="line">        <span class="keyword">auto</span> coords = node.global_coordinates();</div><div class="line">        <span class="keyword">const</span> std::size_t depth_factor = std::size_t(1) &lt;&lt; (max_depth_ - node.depth());</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; Octree_wrapper_::Octree::Node::Dimension::value; ++i) {</div><div class="line">            coords[i] *= (uint32_t)depth_factor;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> coords;</div><div class="line">    }</div><div class="line"></div><div class="line">    Refine_one_eighth(std::size_t min_depth, std::size_t max_depth) : min_depth_(min_depth), max_depth_(max_depth) {</div><div class="line">        octree_dim_ = std::size_t(1) &lt;&lt; max_depth_;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> Octree_wrapper_::Octree::Node&amp; n)<span class="keyword"> const </span>{</div><div class="line">        <span class="comment">// n.depth()</span></div><div class="line">        <span class="keywordflow">if</span> (n.depth() &lt; min_depth_) {</div><div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> (n.depth() == max_depth_) {</div><div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> leaf_coords = uniform_coordinates(n);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (leaf_coords[0] &gt;= octree_dim_ / 2) {</div><div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> (leaf_coords[1] &gt;= octree_dim_ / 2) {</div><div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> (leaf_coords[2] &gt;= octree_dim_ / 2) {</div><div class="line">            <span class="comment">// return false;</span></div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    Octree_wrapper_ octree_wrap({-1, -1, -1, 1, 1, 1});</div><div class="line"></div><div class="line">    Refine_one_eighth split_predicate(4, 6);</div><div class="line">    octree_wrap.refine(split_predicate);</div><div class="line"></div><div class="line">    Octree_domain_ octree_domain(octree_wrap);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> lam = [&amp;](<span class="keyword">const</span> Octree_domain_::Vertex_handle&amp; v) {</div><div class="line">        Point_3 p = octree_domain.position(v);</div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> val = sphere_function(p);</div><div class="line">        Vector_3 gradient = p - <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga9d272a8e3a8080b851741b6d3a44afdc">CGAL::ORIGIN</a>;</div><div class="line">        gradient = gradient / <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">std::sqrt</a>(gradient.squared_length());</div><div class="line">        octree_wrap.value(v) = val;</div><div class="line">        octree_wrap.gradient(v) = gradient;</div><div class="line">    };</div><div class="line">    octree_domain.iterate_vertices(lam, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Sequential__tag.html">CGAL::Sequential_tag</a>());</div><div class="line"></div><div class="line">    Point_range points;</div><div class="line">    Polygon_range polygons;</div><div class="line"></div><div class="line">    <a class="code" href="namespaceCGAL_1_1Isosurfacing.html#af612ed0d7baf7e2f300ba98e52f96050">CGAL::Isosurfacing::make_quad_mesh_using_dual_contouring</a>(octree_domain, 0.8, points, polygons);</div><div class="line"></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result.off"</span>, points, polygons);</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Sep 15 2022 14:12:25 for CGAL 5.6 - 3D Isosurfacing by
    <a href="https://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>
</html><html xmlns="http://www.w3.org/1999/xhtml"><body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.6 - 3D Isosurfacing
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Isosurfacing3"></a>  </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Author</dt><dd>Julian Stahl and Daniel Zint</dd></dl>
<p><a class="anchor" id="fig__isosurfacing_bunny_offset"></a></p><center> <div class="image">
<img src="bunny_offset.gif" style="max-width:50%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__isosurfacing_bunny_offset">Figure 60.1</a> Different isovalues of a bunny.  </div> <br /> 
<h1><a class="anchor" id="secmyintroduction"></a>
Introduction</h1>
<p>This package provides methods to compute a surface mesh representing an isosurface of a 3-dimensional scalar field. An isosurface is defined as the surface on which the value of this field is equal to a given constant, i.e. the isovalue. Depending on the isosurfacing method and the input data structure, the result is either a triangular, quadrilateral, or higher order polygonal indexed face set.</p>
<h1><a class="anchor" id="secmyalgorithms"></a>
Algorithms</h1>
<p>There are multiple algorithms to extract isosurfaces. This package contains Marching Cubes, topologically correct Marching Cubes, Dual Contouring, and Octree Marching. (References?)</p>
<h2><a class="anchor" id="subsecmc"></a>
Marching Cubes (MC)</h2>
<p>MC processes all cells of the input domain individually. Each cell corner gets a sign (+/-) to indicate if it is above or below the isovalue. A new vertex is created on every cell edge where the sign changes, i.e. the isosurface is intersected. The vertex position is computed via linear interpolation of the scalar values of the incident corners. Depending on the configuration of signs at the corners the resulting vertices are connected to form triangles within the cell.</p>
<p>MC can process any input data structure that consists of hexahedral cells. In case of a conforming grid, MC produces a triangle mesh that is manifold in most scenarios. If the mesh is manifold and the isosurface does not intersect the domain boundaries, the mesh is also watertight. Compared to other approaches the algorithm often generates more and many thin triangles with acute angles. MC does not preserve sharp edges.</p>
<p><a class="anchor" id="fig__isosurfacing_mc_cases"></a></p><center> <div class="image">
<img src="mc_cases.png" style="max-width:70%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__isosurfacing_mc_cases">Figure 60.2</a> Some example cases of Marching Cubes.  </div> <br /> 
<h2><a class="anchor" id="subsectmc"></a>
Topologically correct Marching Cubes (TMC)</h2>
<p>This algorithm is an extension to MC and provides additional guarantees. It generates a mesh that is homeomorphic to the trilinear interpolant of the input function inside each cube. Furthermore, the mesh is guaranteed to be manifold and watertight, as long as the isosurface does not intersect the domain boundaries.</p>
<p>TODO examples</p>
<h2><a class="anchor" id="subsecdc"></a>
Dual Contouring (DC)</h2>
<p>DC creates one vertex in every cell that is intersected by the isosurface. Next, a face is created for each edge that intersects the isosurface, by connecting the vertices of the incident cells. For a uniform hexahedral grid, this results in a quadrilateral mesh.</p>
<p>The classical DC method requires the gradient of the scalar field. It is passed to the method as an additional parameter in the form of a functor. The default argument for this parameter assumes the gradient to be zero. Thus, for using the classical DC, the gradient has to be defined by the user.</p>
<p>Different versions of DC compute the vertex positions differently. Therefore, the vertex positioning is configurable with an optional parameter. Some of them do not require the gradient and therefore even work with the zero gradient.</p>
<p>Dual Contouring works on any domain but does not guarantee a manifold or watertight mesh. It creates less faces than Marching Cubes. The main advantage of DC over MC is the ability to represent sharp edges.</p>
<p><a class="anchor" id="fig__isosurfacing_iwp_dc"></a></p><center> <div class="image">
<img src="iwp_dc.png" style="max-width:40%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__isosurfacing_iwp_dc">Figure 60.3</a> Isosurface of the IWP function generated by Dual Contouring.  </div> <br /> 
<h2><a class="anchor" id="subseccomparison"></a>
Comparison</h2>
<table class="doxtable">
<tr>
<th>Algorithm </th><th>Domains </th><th>Faces </th><th>Manifold </th><th>Watertight* </th><th>Topologically correct  </th></tr>
<tr>
<td>MC </td><td>Hexahedral </td><td>Triangles </td><td>no </td><td>no </td><td>no </td></tr>
<tr>
<td>TMC </td><td>Hexahedral </td><td>Triangles </td><td>yes </td><td>yes </td><td>yes </td></tr>
<tr>
<td>DC </td><td>All </td><td>Polygons </td><td>no </td><td>no </td><td>no </td></tr>
</table>
<p>(* assuming the isosurface does not leave the given bounding box)</p>
<p><a class="anchor" id="fig__isosurfacing_compare_mc_dc"></a></p><center> <div class="image">
<img src="cube_mc_dc.png" style="max-width:70%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__isosurfacing_compare_mc_dc">Figure 60.4</a> Comparison between a cube generated by Dual Contouring (left) and Marching Cubes (right).  </div> <br /> 
<h1><a class="anchor" id="secmyinterface"></a>
Interface</h1>
<p>Each algorithm is represented by a single functions. The function signature is the same for all algorithms:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Concurrency_tag = Sequential_tag, <span class="keyword">class</span> Domain_, <span class="keyword">class</span> Po<span class="keywordtype">int</span>Range, <span class="keyword">class</span> PolygonRange&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="group__PkgIsosurfacing3Ref.html#gaefb927d1bed0dba94be85b1032465f60">make_triangle_mesh_using_marching_cubes</a>(<span class="keyword">const</span> Domain_&amp; domain, <span class="keyword">const</span> <span class="keyword">typename</span> Domain_::FT iso_value,</div><div class="line">                                             PointRange&amp; points, PolygonRange&amp; polygons);</div></div><!-- fragment --><p>The input is provided in the form of a <code>domain</code> (see <a class="el" href="index.html#secmydomains">Domains</a>).</p>
<p>The <code>iso_value</code> parameter describes the grid value the isosurface should represent.</p>
<p>The output is in the form of an indexed face set that is written to the two collections <code>points</code> and <code>polygons</code>. The vertex positions are stored as <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__3.html">Point_3</a></code> in <code>points</code>. Each face in <code>polygons</code> is a list of indices pointing into the <code>points</code> collection. Depending on the algorithm, the indexed face set may either store a polygon soup or a topological mesh.</p>
<p>Algorithms can run sequentially on one CPU core or in parallel. The Concurrency_tag is used to specify how the algorithm is executed and is either <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Sequential__tag.html">Sequential_tag</a> or <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__tag.html">Parallel_tag</a>. To enable parallelism, <a class="el" href="namespaceCGAL.html">CGAL</a> needs to be linked with the Intel TBB library. If the parallel version is not availible the sequential version will always be used as a fallback.</p>
<h1><a class="anchor" id="secmydomains"></a>
Domains</h1>
<p>A domain is an object that provides functions to access the input data, its geometry, topology, and optionally its gradient. There are some predefined domain classes that wrap the input data and provide a generalized interface for the algorithm. Users can also define new domains by implementing the <code>Isosurfacing_domain</code> concept.</p>
<h2><a class="anchor" id="mysubsecimplicitdomain"></a>
Implicit domain</h2>
<p>The <code>Implicit_domain</code> represents the input function in an implicit form without storing any values. It takes a functor or lambda that computes the value of the function from the position of a vertex as parameter. Additionally, the bounding box and spacing between grid points have to be specified.</p>
<h2><a class="anchor" id="mysubseccartesiandomain"></a>
Cartesian grid domain</h2>
<p>The <code>Cartesian_grid_domain</code> only takes a <code><a class="el" href="classCGAL_1_1Cartesian__grid__3.html">Cartesian_grid_3</a></code> as parameter. It represents a uniform grid of values that are either computed by the user or read from an <code>Image_3</code>. The constructor of <code><a class="el" href="classCGAL_1_1Cartesian__grid__3.html">Cartesian_grid_3</a></code> needs the number of grid points in each dimension and the bounding box. The values are read and written with <code>value(x, y, z)</code> where x, y, and z are the coordinates of a grid point. Alternatively, all required data can be copied from an <code>Image_3</code>.</p>
<h2><a class="anchor" id="mysubsecoctreedomain"></a>
Octree domain</h2>
<p>The <code>Octree_domain</code> wraps an octree to be used by isosurfacing algorithms. The octree has to be already refined. ...</p>
<h1><a class="anchor" id="secmybenchmarks"></a>
Performance</h1>
<p><a class="anchor" id="fig__isosurfacing_perf_iwp_mc"></a></p><center> <div class="image">
<object type="image/svg+xml" data="perf_threads_iwp_mc.svg" style="max-width:70%;"></object>
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__isosurfacing_perf_iwp_mc">Figure 60.5</a> <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Scaling.html">Scaling</a> of Marching Cubes with more threads.  </div> <br /> 
<h1><a class="anchor" id="secmyexamples"></a>
Examples</h1>
<h2><a class="anchor" id="myExampleImplicit_domain"></a>
Implicit sphere</h2>
<p>The following example shows the usage of the Marching Cubes algorithm to extract an isosurface. The domain is an <code>Implicit_domain</code> that describes a sphere by the distance to its origin as an implicit function.</p>
<p><br />
<b>File</b> <a class="el" href="Isosurfacing_3_2marching_cubes_implicit_sphere_8cpp-example.html">Isosurfacing_3/marching_cubes_implicit_sphere.cpp</a> </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Implicit_domain.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Marching_cubes_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/OFF.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;std::vector&lt;std::size_t&gt;&gt; Polygon_range;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// distance to the origin</span></div><div class="line">    <span class="keyword">auto</span> sphere_function = [](<span class="keyword">const</span> Point&amp; point) {</div><div class="line">        <span class="keywordflow">return</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">std::sqrt</a>(point.x() * point.x() + point.y() * point.y() + point.z() * point.z());</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// create a domain with bounding box [-1, 1]^3 and grid spacing 0.02</span></div><div class="line">    <a class="code" href="classCGAL_1_1Isosurfacing_1_1Implicit__domain.html">CGAL::Isosurfacing::Implicit_domain&lt;Kernel, decltype(sphere_function)&gt;</a> domain(</div><div class="line">        {-1, -1, -1, 1, 1, 1}, Vector(0.02f, 0.02f, 0.02f), sphere_function);  <span class="comment">// TODO: this is ugly</span></div><div class="line"></div><div class="line">    <span class="comment">// prepare collections for the result</span></div><div class="line">    Point_range points;</div><div class="line">    Polygon_range polygons;</div><div class="line"></div><div class="line">    <span class="comment">// execute marching cubes with an isovalue of 0.8</span></div><div class="line">    <a class="code" href="group__PkgIsosurfacing3Ref.html#gaefb927d1bed0dba94be85b1032465f60">CGAL::Isosurfacing::make_triangle_mesh_using_marching_cubes</a>(domain, 0.8f, points, polygons);</div><div class="line"></div><div class="line">    <span class="comment">// save the result in the OFF format</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result.off"</span>, points, polygons);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="myExampleAll_cube"></a>
Cartesian_grid_3 cube comparison</h2>
<p>The following example compares all provided algorithms to extract an isosurface. The domain is an <code>Cartesian_grid_domain</code> that describes a cube by storing the manhattan distance to its origin in a <code><a class="el" href="classCGAL_1_1Cartesian__grid__3.html">Cartesian_grid_3</a></code>.</p>
<p><br />
<b>File</b> <a class="el" href="Isosurfacing_3_2all_cartesian_cube_8cpp-example.html">Isosurfacing_3/all_cartesian_cube.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian_grid_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian_grid_domain.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Dual_contouring_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Marching_cubes_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/TC_marching_cubes_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/OFF.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Cartesian__grid__3.html">CGAL::Cartesian_grid_3&lt;Kernel&gt;</a> Grid;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;std::vector&lt;std::size_t&gt;&gt; Polygon_range;</div><div class="line"></div><div class="line">FT <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gaf3d75d272a29458960987a8f248ec636">sign</a>(FT value) {</div><div class="line">    <span class="keywordflow">return</span> (value &gt; 0) - (value &lt; 0);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// create a cartesian grid with 100^3 grid points and the bounding box [-1, 1]^3</span></div><div class="line">    Grid grid(7, 7, 7, {-1, -1, -1, 1, 1, 1});</div><div class="line"></div><div class="line">    <span class="comment">// calculate the value at all grid points</span></div><div class="line">    <span class="keywordflow">for</span> (std::size_t x = 0; x &lt; grid.xdim(); x++) {</div><div class="line">        <span class="keywordflow">for</span> (std::size_t y = 0; y &lt; grid.ydim(); y++) {</div><div class="line">            <span class="keywordflow">for</span> (std::size_t z = 0; z &lt; grid.zdim(); z++) {</div><div class="line"></div><div class="line">                <span class="keyword">const</span> FT pos_x = x * grid.get_spacing()[0] + grid.get_bbox().xmin();</div><div class="line">                <span class="keyword">const</span> FT pos_y = y * grid.get_spacing()[1] + grid.get_bbox().ymin();</div><div class="line">                <span class="keyword">const</span> FT pos_z = z * grid.get_spacing()[2] + grid.get_bbox().zmin();</div><div class="line"></div><div class="line">                <span class="comment">// manhattan distance to the origin</span></div><div class="line">                grid.value(x, y, z) = std::max({<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(pos_x), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(pos_y), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(pos_z)});</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> cube_gradient = [](<span class="keyword">const</span> Point&amp; p) {</div><div class="line">        <span class="comment">// the normal depends on the side of the cube</span></div><div class="line">        <span class="keyword">const</span> FT max_value = std::max({<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.x()), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.y()), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.z())});</div><div class="line"></div><div class="line">        Vector g(0, 0, 0);</div><div class="line">        <span class="keywordflow">if</span> (max_value == <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.x())) {</div><div class="line">            g += Vector(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gaf3d75d272a29458960987a8f248ec636">sign</a>(p.x()), 0, 0);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> (max_value == <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.y())) {</div><div class="line">            g += Vector(0, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gaf3d75d272a29458960987a8f248ec636">sign</a>(p.y()), 0);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> (max_value == <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.z())) {</div><div class="line">            g += Vector(0, 0, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gaf3d75d272a29458960987a8f248ec636">sign</a>(p.z()));</div><div class="line">        }</div><div class="line">        <span class="keyword">const</span> FT length_sq = g.squared_length();</div><div class="line">        <span class="keywordflow">if</span> (length_sq &gt; 0.00001) {</div><div class="line">            g /= CGAL::approximate_sqrt(length_sq);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> g;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// create a domain from the grid</span></div><div class="line">    <a class="code" href="classCGAL_1_1Isosurfacing_1_1Cartesian__grid__domain.html">CGAL::Isosurfacing::Cartesian_grid_domain&lt;Kernel, decltype(cube_gradient)&gt;</a> domain(grid, cube_gradient);</div><div class="line"></div><div class="line">    <span class="comment">// prepare collections for the results</span></div><div class="line">    Point_range points_mc, points_tmc, points_dc;</div><div class="line">    Polygon_range polygons_mc, polygons_tmc, polygons_dc;</div><div class="line"></div><div class="line">    <span class="comment">// execute marching cubes, topologically correct marching cubes and dual contouring with an isovalue of 0.8</span></div><div class="line">    <a class="code" href="group__PkgIsosurfacing3Ref.html#gaefb927d1bed0dba94be85b1032465f60">CGAL::Isosurfacing::make_triangle_mesh_using_marching_cubes</a>(domain, 0.88, points_mc, polygons_mc);</div><div class="line">    <a class="code" href="namespaceCGAL_1_1Isosurfacing.html#a0f2a5861ee0f085224ecccc2316f24b8">CGAL::Isosurfacing::make_triangle_mesh_using_tmc</a>(domain, 0.88, points_tmc, polygons_tmc);</div><div class="line">    <a class="code" href="namespaceCGAL_1_1Isosurfacing.html#af612ed0d7baf7e2f300ba98e52f96050">CGAL::Isosurfacing::make_quad_mesh_using_dual_contouring</a>(domain, 0.88, points_dc, polygons_dc);</div><div class="line"></div><div class="line">    <span class="comment">// save the results in the OFF format</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result_mc.off"</span>, points_mc, polygons_mc);</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result_tmc.off"</span>, points_tmc, polygons_tmc);</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result_dc.off"</span>, points_dc, polygons_dc);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="myExampleImage"></a>
Image_3</h2>
<p>The following example shows how to load data from an <code>Image_3</code>.</p>
<p><br />
<b>File</b> <a class="el" href="Isosurfacing_3_2marching_cubes_inrimage_8cpp-example.html">Isosurfacing_3/marching_cubes_inrimage.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian_grid_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian_grid_domain.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Marching_cubes_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/OFF.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Cartesian__grid__3.html">CGAL::Cartesian_grid_3&lt;Kernel&gt;</a> Grid;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;std::vector&lt;std::size_t&gt;&gt; Polygon_range;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string fname = <span class="stringliteral">"../../../data/skull_2.9.inr"</span>;</div><div class="line"></div><div class="line">    <span class="comment">// load the image</span></div><div class="line">    CGAL::Image_3 image;</div><div class="line">    <span class="keywordflow">if</span> (!image.read(fname)) {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">"Error: Cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// convert it to a cartesian grid</span></div><div class="line">    <span class="keyword">const</span> Grid grid(image);</div><div class="line"></div><div class="line">    <span class="comment">// create a domain from the grid</span></div><div class="line">    <a class="code" href="classCGAL_1_1Isosurfacing_1_1Cartesian__grid__domain.html">CGAL::Isosurfacing::Cartesian_grid_domain&lt;Kernel&gt;</a> domain(grid);</div><div class="line"></div><div class="line">    <span class="comment">// prepare collections for the result</span></div><div class="line">    Point_range points;</div><div class="line">    Polygon_range polygons;</div><div class="line"></div><div class="line">    <span class="comment">// execute marching cubes with an isovalue of 2.9</span></div><div class="line">    <a class="code" href="group__PkgIsosurfacing3Ref.html#gaefb927d1bed0dba94be85b1032465f60">CGAL::Isosurfacing::make_triangle_mesh_using_marching_cubes</a>(domain, 2.9, points, polygons);</div><div class="line"></div><div class="line">    <span class="comment">// save the result in the OFF format</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result.off"</span>, points, polygons);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="myExampleMeshOffset"></a>
Offset mesh</h2>
<p>The following example shows how to compute an offset mesh. The original mesh is passed to an <code>AABB_tree</code> to allow fast distance queries. With the use of <code>Side_of_triangle_mesh</code> the sign of the distance function is flipped inside the mesh.</p>
<p><br />
<b>File</b> <a class="el" href="Isosurfacing_3_2marching_cubes_mesh_offset_8cpp-example.html">Isosurfacing_3/marching_cubes_mesh_offset.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/AABB_face_graph_triangle_primitive.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/AABB_traits.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/AABB_tree.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian_grid_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian_grid_domain.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Marching_cubes_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Side_of_triangle_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/OFF.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Cartesian__grid__3.html">CGAL::Cartesian_grid_3&lt;Kernel&gt;</a> Grid;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> CGAL::Surface_mesh&lt;Point&gt; Mesh;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> CGAL::AABB_face_graph_triangle_primitive&lt;Mesh&gt; Primitive;</div><div class="line"><span class="keyword">typedef</span> CGAL::AABB_traits&lt;Kernel, Primitive&gt; Traits;</div><div class="line"><span class="keyword">typedef</span> CGAL::AABB_tree&lt;Traits&gt; Tree;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;std::vector&lt;std::size_t&gt;&gt; Polygon_range;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// computes the distance of a point p from the mesh with the use of a AABB_tree</span></div><div class="line"><span class="keyword">inline</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> distance_to_mesh(<span class="keyword">const</span> Tree&amp; tree, <span class="keyword">const</span> Point&amp; p) {</div><div class="line">    <span class="keyword">const</span> Point&amp; x = tree.closest_point(p);</div><div class="line">    <span class="keywordflow">return</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">std::sqrt</a>((p - x).squared_length());</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="keyword">const</span> std::string input_name = <span class="stringliteral">"../../../data/bunny.off"</span>;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> n_voxels = 20;</div><div class="line">    <span class="keyword">const</span> FT offset_value = -0.03;</div><div class="line"></div><div class="line">    <span class="comment">// load the original mesh</span></div><div class="line">    Mesh mesh_input;</div><div class="line">    <span class="keywordflow">if</span> (!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga7396bef8d41fe287d52d19ddbb83a3e4">CGAL::IO::read_OFF</a>(input_name, mesh_input)) {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">"Could not read mesh"</span> &lt;&lt; std::endl;</div><div class="line">        exit(-1);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// compute the new bounding box</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html">CGAL::Bbox_3</a> aabb_grid = CGAL::Polygon_mesh_processing::bbox(mesh_input);</div><div class="line">    Vector aabb_increase_vec = Vector(offset_value + 0.01, offset_value + 0.01, offset_value + 0.01);</div><div class="line">    aabb_grid += (Point(aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a3f5e323700e1509624a02d151237cc4c">xmax</a>(), aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a9d06f61bd89faa841e011ff53edf745f">ymax</a>(), aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a98def8b9515f31ded759d781969ddaf6">zmax</a>()) + aabb_increase_vec).bbox();</div><div class="line">    aabb_grid += (Point(aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#aab574470a2591f187553ca1166e682e1">xmin</a>(), aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a2088e16a1f0a20e011e5b94c2e9c222a">ymin</a>(), aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a6c55430abc7fda54571cf1075c7f2f8b">zmin</a>()) - aabb_increase_vec).bbox();</div><div class="line"></div><div class="line">    <span class="comment">// construct AABB tree</span></div><div class="line">    Tree tree(mesh_input.faces_begin(), mesh_input.faces_end(), mesh_input);</div><div class="line"></div><div class="line">    CGAL::Side_of_triangle_mesh&lt;Mesh, CGAL::GetGeomTraits&lt;Mesh&gt;::type&gt; sotm(mesh_input);</div><div class="line"></div><div class="line">    <span class="comment">// create the grid</span></div><div class="line">    Grid grid(n_voxels, n_voxels, n_voxels, aabb_grid);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (std::size_t z = 0; z &lt; grid.zdim(); z++) {</div><div class="line">        <span class="keywordflow">for</span> (std::size_t y = 0; y &lt; grid.ydim(); y++) {</div><div class="line">            <span class="keywordflow">for</span> (std::size_t x = 0; x &lt; grid.xdim(); x++) {</div><div class="line"></div><div class="line">                <span class="keyword">const</span> FT pos_x = x * grid.get_spacing()[0] + grid.get_bbox().xmin();</div><div class="line">                <span class="keyword">const</span> FT pos_y = y * grid.get_spacing()[1] + grid.get_bbox().ymin();</div><div class="line">                <span class="keyword">const</span> FT pos_z = z * grid.get_spacing()[2] + grid.get_bbox().zmin();</div><div class="line">                <span class="keyword">const</span> Point p(pos_x, pos_y, pos_z);</div><div class="line"></div><div class="line">                <span class="comment">// compute the distance</span></div><div class="line">                grid.value(x, y, z) = distance_to_mesh(tree, p);</div><div class="line"></div><div class="line">                <span class="comment">// flip the sign, so the distance is negative inside the mesh</span></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">bool</span> is_inside = (sotm(p) == <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ggaf6030e89dadcc1f45369b0cdc5d9e111ad8333d35d4801c08b3a5ae9e94d7cabe">CGAL::ON_BOUNDED_SIDE</a>);</div><div class="line">                <span class="keywordflow">if</span> (is_inside) {</div><div class="line">                    grid.value(x, y, z) *= -1;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// create a domain from the grid</span></div><div class="line">    <a class="code" href="classCGAL_1_1Isosurfacing_1_1Cartesian__grid__domain.html">CGAL::Isosurfacing::Cartesian_grid_domain&lt;Kernel&gt;</a> domain(grid);</div><div class="line"></div><div class="line">    <span class="comment">// prepare collections for the result</span></div><div class="line">    Point_range points;</div><div class="line">    Polygon_range polygons;</div><div class="line"></div><div class="line">    <span class="comment">// execute marching cubes with an isovalue equal to the offset</span></div><div class="line">    <a class="code" href="group__PkgIsosurfacing3Ref.html#gaefb927d1bed0dba94be85b1032465f60">CGAL::Isosurfacing::make_triangle_mesh_using_marching_cubes</a>(domain, offset_value, points, polygons);</div><div class="line"></div><div class="line">    <span class="comment">// save the result in the OFF format</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result.off"</span>, points, polygons);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="myExampleOctree"></a>
Octree Dual Contouring</h2>
<p>The following example shows how to extract an isosurface from an octree using Dual Contouring. The domain is an <code>Octree_domain</code> that describes a sphere by the distance to its origin stored in an octree. The octree is highly refined in one octant and only coarse in the others.</p>
<p><br />
<b>File</b> <a class="el" href="Isosurfacing_3_2dual_contouring_octree_8cpp-example.html">Isosurfacing_3/dual_contouring_octree.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Dual_contouring_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Octree_domain.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Octree_wrapper.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/OFF.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;math.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector_3;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point_3;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point_3&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;std::vector&lt;std::size_t&gt;&gt; Polygon_range;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Isosurfacing_1_1Octree__wrapper.html">CGAL::Isosurfacing::Octree_wrapper&lt;Kernel&gt;</a> Octree_wrapper_;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Isosurfacing_1_1Octree__domain.html">CGAL::Isosurfacing::Octree_domain&lt;Kernel&gt;</a> Octree_domain_;</div><div class="line"></div><div class="line"><a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> sphere_function(<span class="keyword">const</span> Point_3&amp; point) {</div><div class="line">    <span class="keywordflow">return</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">std::sqrt</a>(point.x() * point.x() + point.y() * point.y() + point.z() * point.z());</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Refine_one_eighth {</div><div class="line">    std::size_t min_depth_;</div><div class="line">    std::size_t max_depth_;</div><div class="line"></div><div class="line">    std::size_t octree_dim_;</div><div class="line"></div><div class="line">    Octree_wrapper_::Uniform_coords uniform_coordinates(<span class="keyword">const</span> Octree_wrapper_::Octree::Node&amp; node)<span class="keyword"> const </span>{</div><div class="line">        <span class="keyword">auto</span> coords = node.global_coordinates();</div><div class="line">        <span class="keyword">const</span> std::size_t depth_factor = std::size_t(1) &lt;&lt; (max_depth_ - node.depth());</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; Octree_wrapper_::Octree::Node::Dimension::value; ++i) {</div><div class="line">            coords[i] *= (uint32_t)depth_factor;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> coords;</div><div class="line">    }</div><div class="line"></div><div class="line">    Refine_one_eighth(std::size_t min_depth, std::size_t max_depth) : min_depth_(min_depth), max_depth_(max_depth) {</div><div class="line">        octree_dim_ = std::size_t(1) &lt;&lt; max_depth_;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> Octree_wrapper_::Octree::Node&amp; n)<span class="keyword"> const </span>{</div><div class="line">        <span class="comment">// n.depth()</span></div><div class="line">        <span class="keywordflow">if</span> (n.depth() &lt; min_depth_) {</div><div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> (n.depth() == max_depth_) {</div><div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> leaf_coords = uniform_coordinates(n);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (leaf_coords[0] &gt;= octree_dim_ / 2) {</div><div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> (leaf_coords[1] &gt;= octree_dim_ / 2) {</div><div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> (leaf_coords[2] &gt;= octree_dim_ / 2) {</div><div class="line">            <span class="comment">// return false;</span></div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    Octree_wrapper_ octree_wrap({-1, -1, -1, 1, 1, 1});</div><div class="line"></div><div class="line">    Refine_one_eighth split_predicate(4, 6);</div><div class="line">    octree_wrap.refine(split_predicate);</div><div class="line"></div><div class="line">    Octree_domain_ octree_domain(octree_wrap);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> lam = [&amp;](<span class="keyword">const</span> Octree_domain_::Vertex_handle&amp; v) {</div><div class="line">        Point_3 p = octree_domain.position(v);</div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> val = sphere_function(p);</div><div class="line">        Vector_3 gradient = p - <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga9d272a8e3a8080b851741b6d3a44afdc">CGAL::ORIGIN</a>;</div><div class="line">        gradient = gradient / <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">std::sqrt</a>(gradient.squared_length());</div><div class="line">        octree_wrap.value(v) = val;</div><div class="line">        octree_wrap.gradient(v) = gradient;</div><div class="line">    };</div><div class="line">    octree_domain.iterate_vertices(lam, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Sequential__tag.html">CGAL::Sequential_tag</a>());</div><div class="line"></div><div class="line">    Point_range points;</div><div class="line">    Polygon_range polygons;</div><div class="line"></div><div class="line">    <a class="code" href="namespaceCGAL_1_1Isosurfacing.html#af612ed0d7baf7e2f300ba98e52f96050">CGAL::Isosurfacing::make_quad_mesh_using_dual_contouring</a>(octree_domain, 0.8, points, polygons);</div><div class="line"></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result.off"</span>, points, polygons);</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Sep 15 2022 14:12:25 for CGAL 5.6 - 3D Isosurfacing by
    <a href="https://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>
</html>

</html>
