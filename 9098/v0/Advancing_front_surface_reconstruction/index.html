<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Advancing_front_surface_reconstruction/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=11">
<meta name="generator" content="Doxygen 1.9.6">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CGAL 6.2 - Advancing Front Surface Reconstruction: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/doxygen.css" rel="stylesheet" type="text/css">
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      },
      equationNumbers: { autoNumber: "AMS" }
  }
}
);
MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
  var PARSE = MathJax.InputJax.TeX.Parse,
      TEXT = PARSE.prototype.InternalText;
  PARSE.Augment({
    InternalText: function (text,def) {
      text = text.replace(/\\/g,"");
      return TEXT.call(this,text,def);
    }
  });
});
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
      <span class="left">
         <span id="MSearchSelect" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()">Â 
        </span>
        <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
      </span>
      <span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.svg" alt=""></a>
      </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CGAL 6.2 - Advancing Front Surface Reconstruction
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search/",'.html');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">User Manual </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Advancing_Front_Surface_Reconstruction"></a><a class="anchor" id="I1ChapterAdvancingFrontSurfaceReconstruction"></a></p> <div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Author</dt><dd>Tran Kai Frank Da and David Cohen-Steiner</dd></dl>
<p>Surface reconstruction from an unstructured point cloud amounts to generate a plausible surface that approximates well the input points. This problem is ill-posed as many surfaces can be generated. A wide range of approaches have been proposed to tackle this problem. Among them are variational methods <a class="el" href="citelist.html#CITEREF_s-lsm-96">[13]</a><a class="el" href="citelist.html#CITEREF_zomk-insru-00">[14]</a>, tensor voting <a class="el" href="citelist.html#CITEREF_cgal:ml-cfsg-00">[11]</a>, implicit surface <a class="el" href="citelist.html#CITEREF_hddhjmss-pssr-94">[9]</a><a class="el" href="citelist.html#CITEREF_bc-ssrnn-00">[6]</a>, and Delaunay triangulations.</p>
<p>For Delaunay based algorithms the output surface is commonly generated as the union of some triangles selected in the 3D Delaunay triangulation of the input points. Such algorithms are either volume-based by generating as output the boundary of selected tetrahedra <a class="el" href="citelist.html#CITEREF_abe-cbscc-97">[3]</a><a class="el" href="citelist.html#CITEREF_ack-pcubm-01">[4]</a>, or surface-based by selecting a set of triangles.</p>
<p>In most surface based Delaunay algorithms the triangles are selected independently, that is in parallel <a class="el" href="citelist.html#CITEREF_agj-lcsr-00">[1]</a><a class="el" href="citelist.html#CITEREF_ab-srvf-98">[2]</a>.</p>
<p>This chapter presents a surface-based Delaunay surface reconstruction algorithm that sequentially selects the triangles, that is it uses previously selected triangles to select a new triangle for advancing the front. At each advancing step the most plausible triangle is selected, and such that the triangles selected generates an orientable manifold triangulated surface.</p>
<p>Two other examples of this greedy approach are the ball pivoting algorithm and Boyer-Petitjean's algorithm <a class="el" href="citelist.html#CITEREF_bmrst-bpasr-99">[5]</a><a class="el" href="citelist.html#CITEREF_pb-rnrps-01">[12]</a>. In both algorithms a triangulated surface is incrementally grown starting from a seed triangle. Ball pivoting is fast, but the quality of the reconstruction depends on user defined parameters corresponding to the sampling density. The Boyer-Petitjean approach can handle non-uniform sampling, but fails when near co-circular points are encountered, and it does not provide any guarantee on the topology of the surface.</p>
<p>We describe next the algorithm and provide examples.</p>
<dl class="section note"><dt>Note</dt><dd>A <a class="elRef" href="../Manual/tuto_reconstruction.html">detailed tutorial on surface reconstruction</a> is provided with a guide to choose the most appropriate method along with pre- and postprocessing.</dd></dl>
<h1><a class="anchor" id="AFSR_Definitions"></a>
Definitions and the Algorithm</h1>
<p>A detailed description of the algorithm and the underlying theory are provided in <a class="el" href="citelist.html#CITEREF_cgal:csd-gdbsra-04">[8]</a>.</p>
<p>The first step of the algorithm is the construction of a 3D Delaunay triangulation of the point set. The radius of a triangle \( t \) is the radius of the smallest sphere passing through the vertices of \( t\) and enclosing no sample point. In other words, the radius \( r_t\) is the distance from any vertex of \( t\) to the Voronoi edge dual to \( t\). This triangle with three boundary edges is the initial triangulated surface, and its boundary is the advancing front. The Delaunay triangle with the smallest radius is the starting point for the greedy algorithm.</p>
<p>The algorithm maintains a priority queue of candidate triangles, that is of valid triangles incident to the boundary edges of the current surface. The priority is the plausibility. While the priority queue is not empty, the algorithm pops from the queue the most plausible candidate triangle and adds it to the surface. New candidate triangles are pushed to the priority queue when new boundary edges appear on the advancing front. As the algorithm creates a two-manifold surface some candidate triangles can not be selected due to topological constraints which are explained next.</p>
<h2><a class="anchor" id="AFSR_Topology"></a>
Topological Constraints</h2>
<p>Any triangle \(t\) considered as the next potential candidate shares an edge \(e\) with the front of the current reconstruction. Let \(b\) be the vertex of \(t\) opposite to \(e\). There are four configurations where \(t\) is added to the surface.</p>
<ul>
<li>extension, if \(b\) is not yet on the surface.</li>
<li>hole filling, if \(b\) is on the front and both neighbors of \(b\) on the front are on edge \(e\).</li>
<li>ear filling, if \(b\) is on the front and one neighbor of \(b\) on the front is on edge \(e\).</li>
<li>glueing, if \(b\) is on the front and no neighbor of \(b\) on the front is on edge \(e\).</li>
</ul>
<p><a class="anchor" id="fig__figAFSRvalid"></a> </p><div class="image">
<img src="valid.png" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__figAFSRvalid">Figure 70.1</a> Valid candidates. </p> </div> <p> <br>
</p>
<p>While the first three operations never induce a non-manifold edge or vertex, we only can perform gluing, if triangle \(t\) has a <em>twin</em> facet, that is a triangle with an edge on the front and incident to \(b\), and the third vertex on edge \(e\).</p>
<p>A triangle is said <em>valid</em> when the above operations can be applied.</p>
<h2><a class="anchor" id="AFSR_Selection"></a>
Plausibility of a Candidate Triangle</h2>
<p>Valid triangles for an edge on the front are compared through their radius. While the radius is a good criterion in the case of 2D smooth curve reconstruction <a class="el" href="citelist.html#CITEREF_b-cccda-94">[7]</a>, we need another criterion for 3D surface reconstruction, namely the dihedral angle between triangles on the surface, that is the angle between the normals of the triangles. There are three bounds namely \( \alpha_\mathrm{sliver} \), \( \beta \), and \( \delta \).</p>
<p>The <em>candidate</em> triangle of an edge \( e \) is the triangle with the smallest radius:</p><ul>
<li>that is valid for \( e \), and</li>
<li>that has \( \beta_t &lt; \alpha_\mathrm{sliver} \), and</li>
<li>that has its internal angles with \( e \) smaller than \( \delta \).</li>
</ul>
<p>There may be no such triangle. In the implementation of the algorithm \( \alpha_\mathrm{sliver} \) and \( \delta\) are equal to \( 5\pi/6 \).</p>
<p>We denote by \( \beta_t\) the angle between the normal of a triangle \( t\) incident on a boundary edge \( e \) and the normal of the triangle on the surface incident to \( e \).</p>
<p>We define the <em>plausibility</em> grade \( p(t) \) as \( 1/r_t \), if \( \beta_t &lt; \beta \), and \( -\beta_t \) else. The parameter \(
\beta \) can be specified by the user and is set by default to \( \pi/6\).</p>
<p>Let's have a look at the figure below. <a class="anchor" id="fig__figAFSRplausible"></a> </p><div class="image">
<img src="wedges.png" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__figAFSRplausible">Figure 70.2</a> Plausibility. Triangle <code>t'</code> and incident triangles sharing edge <code>e</code> seen from the side. </p> </div> <p> <br>
</p>
<p>\( \alpha_\mathrm{sliver}\) corresponds to the red wedge. The algorithm will never select triangle <code>t1</code> even if it is the only candidate triangle.</p>
<p>\(\beta\) corresponds to the green wedge. If there is a candidate triangle in this zone, the one with the smallest radius is the most plausible.</p>
<p>If there is no candidate triangle in the green wedge, the triangle with the smallest angle between its normal and the normal of <code>t'</code> is chosen. In the figure above this would be triangle <code>t4</code>.</p>
<h2><a class="anchor" id="AFSR_Boundaries"></a>
Dealing with Multiple Components, Boundaries and Sharp Edges</h2>
<p>By construction the output of the algorithm is a connected orientable manifold with or without boundary. To cope with multiple components we merely look for a new seed facet among facets disjoint from the surface. In case of noisy data or outliers, the user must filter out small surface components.</p>
<p>It is impossible to handle all kinds of boundaries and non uniform sampling at the same time, as a void can either be an undersampled area of the surface, or a hole.</p>
<p>As we do not want the algorithm to rely on a uniformity condition on the sampling it will fill holes cut off from "flat" regions of the surface. However, in many cases a boundary component cannot be closed by adding a spanning disk such that the resulting disk is well sampled. Typically, closing a boundary component due to a transversal clipping of the operation, would yield large dihedral angles at boundary edges. Moreover, if the boundary is sufficiently well sampled, the radii of the two triangles incident on a boundary edge would be very different. These heuristic facts can be used for boundary detection.</p>
<p>More specifically, we discard any candidate triangle \( t \), for an edge \( e \) such that \( p(t) &lt; 0\), and \( r_t &gt; \mathrm{radius\_ratio\_bound} \times r_{t'}\) where \( t'\) is the triangle on the surface incident on \( e \). The parameter \(\mathrm{radius\_ratio\_bound}\) is specified by the user and is set by default to 5.</p>
<p>For the example given in <a class="el" href="index.html#fig__figAFSRplausible">Figure 70.2</a>, we said that if there was no triangle <code>t3</code> in the green wedge, triangle <code>t4</code> would be chosen as it has the smallest angle between its normal and the normal of triangle <code>t'</code>. However, in case its radius was \(\mathrm{radius\_ratio\_bound}\) times larger than the radius of triangle <code>t'</code>, triangle <code>t2</code> would be chosen, assuming that its radius is not \(\mathrm{radius\_ratio\_bound}\) times larger.</p>
<p>Note that this heuristic implies that where the sampling is too sparse with respect to curvature, it must be sufficiently uniform for our algorithm to work.</p>
<h1><a class="anchor" id="AFSR_Examples"></a>
Examples</h1>
<p>The first of the following three examples presents a free function for doing surface reconstruction. For a sequence of points the function produces a sequence of triplets of indices describing the triangles of the surface. The second example presents a class that enables to traverse the surface represented in a 2D triangulation data structure where the faces are connected with the facets of underlying 3D Delaunay triangulation. The third example shows how to get outliers and the boundaries of the surface. The last example shows how to combine this algorithm with two CGAL algorithms in order to reconstruct surfaces with sharp features.</p>
<h2><a class="anchor" id="AFSR_Example_function"></a>
Examples for Global Function</h2>
<p>The global function <code><a class="el" href="group__PkgAdvancingFrontSurfaceReconstructionRef.html#gaa2b1f41291920247fd5c6ef7c09f70a4" title="For a sequence of points computes a sequence of index triples describing the faces of the reconstruct...">advancing_front_surface_reconstruction()</a></code> takes an iterator range of points as input and writes for each face of the reconstructed surface a triplet of point indices into an output iterator. The following example writes the output triangulated surface to <code>std::cout</code> in accordance to the OFF format.</p>
<p>The function has an overload with an additional argument that allows to choose how to prioritize facets. It can be written in a way to avoid the generation of triangles with a perimeter larger than a given bound.</p>
<p><br>
<b>File</b> <a class="el" href="Advancing_front_surface_reconstruction_2reconstruction_fct_8cpp-example.html">Advancing_front_surface_reconstruction/reconstruction_fct.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Advancing_front_surface_reconstruction.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/tuple.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/lexical_cast.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_structRef" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> K;</div>
<div class="line"><span class="keyword">typedef</span> K::Point_3  Point_3;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> std::array&lt;std::size_t,3&gt; Facet;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacestd.html">std</a> {</div>
<div class="line">  std::ostream&amp;</div>
<div class="line">  <a class="code hl_functionRef" href="../TDS_3/group__PkgIOTDS3.html#ga13941cbdb65047e071485853a7f619d9">operator&lt;&lt;</a>(std::ostream&amp; os, <span class="keyword">const</span> Facet&amp; f)</div>
<div class="line">  {</div>
<div class="line">    os &lt;&lt; <span class="stringliteral">"3 "</span> &lt;&lt; f[0] &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; f[1] &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; f[2];</div>
<div class="line">    <span class="keywordflow">return</span> os;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Perimeter {</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">double</span> bound;</div>
<div class="line"> </div>
<div class="line">  Perimeter(<span class="keywordtype">double</span> bound)</div>
<div class="line">    : bound(bound)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> AdvancingFront, <span class="keyword">typename</span> Cell_handle&gt;</div>
<div class="line">  <span class="keywordtype">double</span> operator() (<span class="keyword">const</span> AdvancingFront&amp; adv, Cell_handle&amp; c,</div>
<div class="line">                     <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; index)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="comment">// bound == 0 is better than bound &lt; infinity</span></div>
<div class="line">    <span class="comment">// as it avoids the distance computations</span></div>
<div class="line">    <span class="keywordflow">if</span>(bound == 0){</div>
<div class="line">      <span class="keywordflow">return</span> adv.smallest_radius_delaunay_sphere (c, index);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// If perimeter &gt; bound, return infinity so that facet is not used</span></div>
<div class="line">    <span class="keywordtype">double</span> d  = 0;</div>
<div class="line">    d = <a class="code hl_functionRef" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">sqrt</a>(<a class="code hl_functionRef" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">squared_distance</a>(c-&gt;vertex((index+1)%4)-&gt;point(),</div>
<div class="line">                              c-&gt;vertex((index+2)%4)-&gt;point()));</div>
<div class="line">    <span class="keywordflow">if</span>(d&gt;bound) <span class="keywordflow">return</span> adv.infinity();</div>
<div class="line">    d += <a class="code hl_functionRef" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">sqrt</a>(<a class="code hl_functionRef" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">squared_distance</a>(c-&gt;vertex((index+2)%4)-&gt;point(),</div>
<div class="line">                               c-&gt;vertex((index+3)%4)-&gt;point()));</div>
<div class="line">    <span class="keywordflow">if</span>(d&gt;bound) <span class="keywordflow">return</span> adv.infinity();</div>
<div class="line">    d += <a class="code hl_functionRef" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">sqrt</a>(<a class="code hl_functionRef" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">squared_distance</a>(c-&gt;vertex((index+1)%4)-&gt;point(),</div>
<div class="line">                               c-&gt;vertex((index+3)%4)-&gt;point()));</div>
<div class="line">    <span class="keywordflow">if</span>(d&gt;bound) <span class="keywordflow">return</span> adv.infinity();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Otherwise, return usual priority value: smallest radius of</span></div>
<div class="line">    <span class="comment">// delaunay sphere</span></div>
<div class="line">    <span class="keywordflow">return</span> adv.smallest_radius_delaunay_sphere (c, index);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  std::ifstream in((argc&gt;1)?argv[1]:<a class="code hl_functionRef" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/half.xyz"</span>));</div>
<div class="line">  <span class="keywordtype">double</span> per = (argc&gt;2)?boost::lexical_cast&lt;double&gt;(argv[2]):0;</div>
<div class="line">  <span class="keywordtype">double</span> radius_ratio_bound = (argc&gt;3)?boost::lexical_cast&lt;double&gt;(argv[3]):5.0;</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;Point_3&gt; points;</div>
<div class="line">  std::vector&lt;Facet&gt; facets;</div>
<div class="line"> </div>
<div class="line">  std::copy(std::istream_iterator&lt;Point_3&gt;(in),</div>
<div class="line">            std::istream_iterator&lt;Point_3&gt;(),</div>
<div class="line">            std::back_inserter(points));</div>
<div class="line"> </div>
<div class="line">  Perimeter perimeter(per);</div>
<div class="line">  <a class="code hl_function" href="group__PkgAdvancingFrontSurfaceReconstructionRef.html#gaa2b1f41291920247fd5c6ef7c09f70a4">CGAL::advancing_front_surface_reconstruction</a>(points.begin(),</div>
<div class="line">                                               points.end(),</div>
<div class="line">                                               std::back_inserter(facets),</div>
<div class="line">                                               perimeter,</div>
<div class="line">                                               radius_ratio_bound);</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"OFF\n"</span> &lt;&lt; points.size() &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; facets.size() &lt;&lt; <span class="stringliteral">" 0\n"</span>;</div>
<div class="line">  std::copy(points.begin(),</div>
<div class="line">            points.end(),</div>
<div class="line">            std::ostream_iterator&lt;Point_3&gt;(std::cout, <span class="stringliteral">"\n"</span>));</div>
<div class="line">  std::copy(facets.begin(),</div>
<div class="line">            facets.end(),</div>
<div class="line">            std::ostream_iterator&lt;Facet&gt;(std::cout, <span class="stringliteral">"\n"</span>));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__PkgAdvancingFrontSurfaceReconstructionRef_html_gaa2b1f41291920247fd5c6ef7c09f70a4"><div class="ttname"><a href="group__PkgAdvancingFrontSurfaceReconstructionRef.html#gaa2b1f41291920247fd5c6ef7c09f70a4">CGAL::advancing_front_surface_reconstruction</a></div><div class="ttdeci">IndicesOutputIterator advancing_front_surface_reconstruction(PointInputIterator b, PointInputIterator e, IndicesOutputIterator out, double radius_ratio_bound=5, double beta=0.52)</div><div class="ttdoc">For a sequence of points computes a sequence of index triples describing the faces of the reconstruct...</div><div class="ttdef"><b>Definition:</b> Advancing_front_surface_reconstruction.h:2531</div></div>
<div class="ttc" id="agroup__PkgAlgebraicFoundationsRef_html_gab922269072ee9ee99ba8c541418b2e11"><div class="ttname"><a href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">CGAL::sqrt</a></div><div class="ttdeci">NT sqrt(const NT &amp;x)</div></div>
<div class="ttc" id="agroup__PkgIOTDS3_html_ga13941cbdb65047e071485853a7f619d9"><div class="ttname"><a href="../TDS_3/group__PkgIOTDS3.html#ga13941cbdb65047e071485853a7f619d9">operator&lt;&lt;</a></div><div class="ttdeci">ostream &amp; operator&lt;&lt;(ostream &amp;os, const TriangulationDataStructure_3 &amp;tds)</div></div>
<div class="ttc" id="agroup__squared__distance__grp_html_ga1ff73525660a052564d33fbdd61a4f71"><div class="ttname"><a href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">CGAL::squared_distance</a></div><div class="ttdeci">Kernel::FT squared_distance(Type1&lt; Kernel &gt; obj1, Type2&lt; Kernel &gt; obj2)</div></div>
<div class="ttc" id="anamespaceCGAL_html_acdae9a147ad2a3998cc21f88bc292dac"><div class="ttname"><a href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a></div><div class="ttdeci">std::string data_file_path(const std::string &amp;filename)</div></div>
<div class="ttc" id="anamespacestd_html"><div class="ttname"><a href="namespacestd.html">std</a></div><div class="ttdoc">STL namespace.</div></div>
<div class="ttc" id="astructCGAL_1_1Simple__cartesian_html"><div class="ttname"><a href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian</a></div></div>
</div><!-- fragment --><p>While the first example just writes index triples, the second example uses as output iterator a wrapper around a reference to a <code><a class="elRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">Surface_mesh</a></code> and calls the function <code>add_face()</code>.</p>
<p><br>
<b>File</b> <a class="el" href="Advancing_front_surface_reconstruction_2reconstruction_surface_mesh_8cpp-example.html">Advancing_front_surface_reconstruction/reconstruction_surface_mesh.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Advancing_front_surface_reconstruction.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/disable_warnings.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> std::array&lt;std::size_t,3&gt; Facet;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> <a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>  Point_3;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point_3&gt;</a> Mesh;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Construct{</div>
<div class="line">  Mesh&amp; mesh;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt; <span class="keyword">typename</span> Po<span class="keywordtype">int</span>Iterator&gt;</div>
<div class="line">  Construct(Mesh&amp; mesh,PointIterator b, PointIterator e)</div>
<div class="line">    : mesh(mesh)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">for</span>(; b!=e; ++b){</div>
<div class="line">      boost::graph_traits&lt;Mesh&gt;::vertex_descriptor v;</div>
<div class="line">      v = add_vertex(mesh);</div>
<div class="line">      mesh.point(v) = *b;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  Construct&amp; operator=(<span class="keyword">const</span> Facet f)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::vertex_descriptor vertex_descriptor;</div>
<div class="line">    <span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::vertices_size_type size_type;</div>
<div class="line">    mesh.add_face(vertex_descriptor(<span class="keyword">static_cast&lt;</span>size_type<span class="keyword">&gt;</span>(f[0])),</div>
<div class="line">                  vertex_descriptor(<span class="keyword">static_cast&lt;</span>size_type<span class="keyword">&gt;</span>(f[1])),</div>
<div class="line">                  vertex_descriptor(<span class="keyword">static_cast&lt;</span>size_type<span class="keyword">&gt;</span>(f[2])));</div>
<div class="line">    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  Construct&amp;</div>
<div class="line">  <a class="code hl_functionRef" href="../Kernel_23/group__Kernel__operator__prod.html#ga8427cff04588dc338b8acf3e1b116dce">operator*</a>() { <span class="keywordflow">return</span> *<span class="keyword">this</span>; }</div>
<div class="line"> </div>
<div class="line">  Construct&amp;</div>
<div class="line">  operator++() { <span class="keywordflow">return</span> *<span class="keyword">this</span>; }</div>
<div class="line"> </div>
<div class="line">  Construct</div>
<div class="line">  operator++(<span class="keywordtype">int</span>) { <span class="keywordflow">return</span> *<span class="keyword">this</span>; }</div>
<div class="line"> </div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  std::ifstream in((argc&gt;1)?argv[1]:<a class="code hl_functionRef" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/half.xyz"</span>));</div>
<div class="line">  std::vector&lt;Point_3&gt; points;</div>
<div class="line">  Mesh m;</div>
<div class="line"> </div>
<div class="line">  std::copy(std::istream_iterator&lt;Point_3&gt;(in),</div>
<div class="line">            std::istream_iterator&lt;Point_3&gt;(),</div>
<div class="line">            std::back_inserter(points));</div>
<div class="line"> </div>
<div class="line">  Construct construct(m,points.begin(),points.end());</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="group__PkgAdvancingFrontSurfaceReconstructionRef.html#gaa2b1f41291920247fd5c6ef7c09f70a4">CGAL::advancing_front_surface_reconstruction</a>(points.begin(),</div>
<div class="line">                                               points.end(),</div>
<div class="line">                                               construct);</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; m  &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassCGAL_1_1Exact__predicates__inexact__constructions__kernel_html"><div class="ttname"><a href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a></div></div>
<div class="ttc" id="aclassCGAL_1_1Surface__mesh_html"><div class="ttname"><a href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh</a></div></div>
<div class="ttc" id="aclassKernel_1_1Point__3_html"><div class="ttname"><a href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a></div></div>
<div class="ttc" id="agroup__Kernel__operator__prod_html_ga8427cff04588dc338b8acf3e1b116dce"><div class="ttname"><a href="../Kernel_23/group__Kernel__operator__prod.html#ga8427cff04588dc338b8acf3e1b116dce">operator*</a></div><div class="ttdeci">Vector_2&lt; Kernel &gt; operator*(const Vector_2&lt; Kernel &gt; &amp;v, const Kernel::RT &amp;s)</div></div>
<div class="ttc" id="anamespaceKernel_html"><div class="ttname"><a href="../Kernel_23/namespaceKernel.html">Kernel</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="AFSR_Example_class"></a>
Example for the Reconstruction Class</h2>
<p>The class <code><a class="el" href="classCGAL_1_1Advancing__front__surface__reconstruction.html" title="The class Advancing_front_surface_reconstruction enables advanced users to provide the unstructured p...">Advancing_front_surface_reconstruction</a></code> provides access to a 2D triangulation data structure describing the output surface. The latter can be explored by hopping from a face to its neighboring faces, and by hopping from faces of the 2D triangulation data structure to corresponding facets of the underlying 3D Delaunay triangulation.</p>
<p>The type of the 2D triangulation data structure describing the reconstructed surface is the nested type <a class="el" href="classCGAL_1_1Advancing__front__surface__reconstruction.html#a5e53d504a33aeadb5d07754ef9abf1fe"><code>Advancing_front_surface_reconstruction::Triangulation_data_structure_2</code></a>.</p>
<p>The type <code>Advancing_front_surface_reconstruction::Triangulation_data_structure_2::Vertex</code> is model of the concept <code><a class="elRef" href="../TDS_2/classTriangulationDataStructure__2_1_1Vertex.html">TriangulationDataStructure_2::Vertex</a></code> and has additionally the method <code>vertex_3()</code> that returns an <code><a class="el" href="classCGAL_1_1Advancing__front__surface__reconstruction.html#a9df10e1e009e536e2271b17d8ad117e9" title="The vertex handle type of the 3D triangulation.">Advancing_front_surface_reconstruction::Vertex_handle</a></code> to the associated 3D vertex.</p>
<p>The type <code>Advancing_front_surface_reconstruction::Triangulation_data_structure_2::Face</code> is model of the concept <code><a class="elRef" href="../TDS_2/classTriangulationDataStructure__2_1_1Face.html">TriangulationDataStructure_2::Face</a></code> and has additionally the method <code>facet()</code> that returns the associated <code><a class="el" href="classCGAL_1_1Advancing__front__surface__reconstruction.html#aa5e3c1e9ad309a243a3fe34d8dbfb783" title="The facet type of the 3D triangulation.">Advancing_front_surface_reconstruction::Facet</a></code>, and a method <code>is_on_surface()</code> for testing if a face is part of the reconstructed surface.</p>
<p>In case the surface has boundaries, the 2D surface has one vertex which is associated to the infinite vertex of the 3D triangulation.</p>
<p>The underlying 3D Delaunay triangulation can be accessed as well, using the API of the class <code><a class="elRef" href="../Triangulation_3/classCGAL_1_1Delaunay__triangulation__3.html">Delaunay_triangulation_3</a></code>.</p>
<p>The following example writes the surface to <code>std::cout</code> in accordance to the STL (Stereo Lithography) format.</p>
<p><br>
<b>File</b> <a class="el" href="Advancing_front_surface_reconstruction_2reconstruction_class_8cpp-example.html">Advancing_front_surface_reconstruction/reconstruction_class.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Advancing_front_surface_reconstruction.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classCGAL_1_1Advancing__front__surface__reconstruction.html">CGAL::Advancing_front_surface_reconstruction&lt;&gt;</a> Reconstruction;</div>
<div class="line"><span class="keyword">typedef</span> Reconstruction::Triangulation_3 Triangulation_3;</div>
<div class="line"><span class="keyword">typedef</span> Reconstruction::Triangulation_data_structure_2 TDS_2;</div>
<div class="line"><span class="keyword">typedef</span> K::Point_3 Point_3;</div>
<div class="line"><span class="keyword">typedef</span> K::Vector_3 Vector_3;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  std::ifstream in((argc&gt;1)?argv[1]:<a class="code hl_functionRef" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/half.xyz"</span>));</div>
<div class="line">  std::istream_iterator&lt;Point_3&gt; begin(in);</div>
<div class="line">  std::istream_iterator&lt;Point_3&gt; end;</div>
<div class="line"> </div>
<div class="line">  Triangulation_3 dt(begin,end);</div>
<div class="line"> </div>
<div class="line">  Reconstruction reconstruction(dt);</div>
<div class="line"> </div>
<div class="line">  reconstruction.run();</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> TDS_2&amp; tds = reconstruction.triangulation_data_structure_2();</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"solid produced with CGAL::Advancing_front_surface_reconstruction\n"</span>;</div>
<div class="line">  <span class="keywordflow">for</span>(TDS_2::Face_iterator fit = tds.faces_begin();</div>
<div class="line">      fit != tds.faces_end();</div>
<div class="line">      ++fit){</div>
<div class="line">    <span class="keywordflow">if</span>(reconstruction.has_on_surface(fit)){</div>
<div class="line">      <a class="code hl_typedefRef" href="../Triangulation_3/classCGAL_1_1Triangulation__3.html#aa100228164b0cf78d5c2b1009c2df258">Triangulation_3::Facet</a> f = fit-&gt;facet();</div>
<div class="line">      <a class="code hl_typedefRef" href="../Triangulation_3/classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Triangulation_3::Cell_handle</a> ch = f.first;</div>
<div class="line">      <span class="keywordtype">int</span> ci = f.second;</div>
<div class="line">      Point_3 points[3];</div>
<div class="line">      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0, j = 0; i &lt; 4; i++){</div>
<div class="line">        <span class="keywordflow">if</span>(ci != i){</div>
<div class="line">          points[j] = ch-&gt;vertex(i)-&gt;point();</div>
<div class="line">          j++;</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">"  facet normal "</span></div>
<div class="line">                &lt;&lt; <a class="code hl_functionRef" href="../Kernel_23/group__unit__normal__grp.html#ga2dd531ada431e654de186b792ad28c95">CGAL::unit_normal</a>(points[0],points[1], points[2]) &lt;&lt; <span class="stringliteral">"\n"</span></div>
<div class="line">                &lt;&lt; <span class="stringliteral">"  outer loop\n"</span></div>
<div class="line">                &lt;&lt; <span class="stringliteral">"    vertex "</span> &lt;&lt; points[0]  &lt;&lt; <span class="stringliteral">"\n"</span></div>
<div class="line">                &lt;&lt; <span class="stringliteral">"    vertex "</span> &lt;&lt; points[1]  &lt;&lt; <span class="stringliteral">"\n"</span></div>
<div class="line">                &lt;&lt; <span class="stringliteral">"    vertex "</span> &lt;&lt; points[2]  &lt;&lt; <span class="stringliteral">"\n"</span></div>
<div class="line">                &lt;&lt; <span class="stringliteral">"  endloop\n"</span></div>
<div class="line">                &lt;&lt; <span class="stringliteral">"  endfacet\n"</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">"endsolid"</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassCGAL_1_1Advancing__front__surface__reconstruction_html"><div class="ttname"><a href="classCGAL_1_1Advancing__front__surface__reconstruction.html">CGAL::Advancing_front_surface_reconstruction</a></div><div class="ttdoc">The class Advancing_front_surface_reconstruction enables advanced users to provide the unstructured p...</div><div class="ttdef"><b>Definition:</b> Advancing_front_surface_reconstruction.h:205</div></div>
<div class="ttc" id="aclassCGAL_1_1Triangulation__3_html_aa100228164b0cf78d5c2b1009c2df258"><div class="ttname"><a href="../Triangulation_3/classCGAL_1_1Triangulation__3.html#aa100228164b0cf78d5c2b1009c2df258">CGAL::Triangulation_3::Facet</a></div><div class="ttdeci">Triangulation_data_structure::Facet Facet</div></div>
<div class="ttc" id="aclassCGAL_1_1Triangulation__3_html_ac076eb6ecdeeeb2b5bf678a21b3d23ee"><div class="ttname"><a href="../Triangulation_3/classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">CGAL::Triangulation_3::Cell_handle</a></div><div class="ttdeci">Triangulation_data_structure::Cell_handle Cell_handle</div></div>
<div class="ttc" id="agroup__unit__normal__grp_html_ga2dd531ada431e654de186b792ad28c95"><div class="ttname"><a href="../Kernel_23/group__unit__normal__grp.html#ga2dd531ada431e654de186b792ad28c95">CGAL::unit_normal</a></div><div class="ttdeci">CGAL::Vector_3&lt; Kernel &gt; unit_normal(const CGAL::Point_3&lt; Kernel &gt; &amp;p, const CGAL::Point_3&lt; Kernel &gt; &amp;q, const CGAL::Point_3&lt; Kernel &gt; &amp;r)</div></div>
</div><!-- fragment --><h2><a class="anchor" id="AFSR_Example_boundaries"></a>
Example for Outliers and Boundaries</h2>
<p>Input points which are not on a surface are outliers. The member function <a class="el" href="classCGAL_1_1Advancing__front__surface__reconstruction.html#af6c1b6feaf4f93dc29e3d67b86efde86"><code>outliers()</code></a> returns an iterator range of those points.</p>
<p>Boundary edges can be traversed with the member function <a class="el" href="classCGAL_1_1Advancing__front__surface__reconstruction.html#aa38773e1696b49b55c06b2bc037d7a88"><code>boundaries()</code></a> It returns an iterator range type <a class="el" href="classCGAL_1_1Advancing__front__surface__reconstruction.html#a048f25a32eebd5d396c1e79fec5db49d"><code>Boundary_range</code></a> whose iterators have the value type <a class="el" href="classCGAL_1_1Advancing__front__surface__reconstruction.html#aa2bcfba42b1a2ad04fd0e1914a01b162"><code>Vertex_on_boundary_range</code></a>. This is again an iterator range whose iterators have the value type <a class="el" href="classCGAL_1_1Advancing__front__surface__reconstruction.html#a9df10e1e009e536e2271b17d8ad117e9"><code>Vertex_handle</code></a>.</p>
<p><br>
<b>File</b> <a class="el" href="Advancing_front_surface_reconstruction_2boundaries_8cpp-example.html">Advancing_front_surface_reconstruction/boundaries.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Advancing_front_surface_reconstruction.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Perimeter {</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">double</span> bound;</div>
<div class="line"> </div>
<div class="line">  Perimeter(<span class="keywordtype">double</span> bound)</div>
<div class="line">    : bound(bound)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> AdvancingFront, <span class="keyword">typename</span> Cell_handle&gt;</div>
<div class="line">  <span class="keywordtype">double</span> operator() (<span class="keyword">const</span> AdvancingFront&amp; adv, Cell_handle&amp; c,</div>
<div class="line">                     <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; index)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="comment">// bound == 0 is better than bound &lt; infinity</span></div>
<div class="line">    <span class="comment">// as it avoids the distance computations</span></div>
<div class="line">    <span class="keywordflow">if</span>(bound == 0){</div>
<div class="line">      <span class="keywordflow">return</span> adv.smallest_radius_delaunay_sphere (c, index);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// If perimeter &gt; bound, return infinity so that facet is not used</span></div>
<div class="line">    <span class="keywordtype">double</span> d  = 0;</div>
<div class="line">    d = <a class="code hl_functionRef" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">sqrt</a>(<a class="code hl_functionRef" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">squared_distance</a>(c-&gt;vertex((index+1)%4)-&gt;point(),</div>
<div class="line">                              c-&gt;vertex((index+2)%4)-&gt;point()));</div>
<div class="line">    <span class="keywordflow">if</span>(d&gt;bound) <span class="keywordflow">return</span> adv.infinity();</div>
<div class="line">    d += <a class="code hl_functionRef" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">sqrt</a>(<a class="code hl_functionRef" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">squared_distance</a>(c-&gt;vertex((index+2)%4)-&gt;point(),</div>
<div class="line">                               c-&gt;vertex((index+3)%4)-&gt;point()));</div>
<div class="line">    <span class="keywordflow">if</span>(d&gt;bound) <span class="keywordflow">return</span> adv.infinity();</div>
<div class="line">    d += <a class="code hl_functionRef" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">sqrt</a>(<a class="code hl_functionRef" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">squared_distance</a>(c-&gt;vertex((index+1)%4)-&gt;point(),</div>
<div class="line">                               c-&gt;vertex((index+3)%4)-&gt;point()));</div>
<div class="line">    <span class="keywordflow">if</span>(d&gt;bound) <span class="keywordflow">return</span> adv.infinity();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Otherwise, return usual priority value: smallest radius of</span></div>
<div class="line">    <span class="comment">// delaunay sphere</span></div>
<div class="line">    <span class="keywordflow">return</span> adv.smallest_radius_delaunay_sphere (c, index);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classCGAL_1_1Advancing__front__surface__reconstruction.html">CGAL::Advancing_front_surface_reconstruction&lt;CGAL::Default, Perimeter&gt;</a> Reconstruction;</div>
<div class="line"><span class="keyword">typedef</span> Reconstruction::Triangulation_3 Triangulation_3;</div>
<div class="line"><span class="keyword">typedef</span> Reconstruction::Outlier_range Outlier_range;</div>
<div class="line"><span class="keyword">typedef</span> Reconstruction::Boundary_range Boundary_range;</div>
<div class="line"><span class="keyword">typedef</span> Reconstruction::Vertex_on_boundary_range Vertex_on_boundary_range;</div>
<div class="line"><span class="keyword">typedef</span> Reconstruction::Vertex_handle Vertex_handle;</div>
<div class="line"><span class="keyword">typedef</span> K::Point_3 Point_3;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  std::ifstream in((argc&gt;1)?argv[1]:<a class="code hl_functionRef" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/half.xyz"</span>));</div>
<div class="line">  std::istream_iterator&lt;Point_3&gt; begin(in);</div>
<div class="line">  std::istream_iterator&lt;Point_3&gt; end;</div>
<div class="line"> </div>
<div class="line">  Perimeter perimeter(0.5);</div>
<div class="line">  Triangulation_3 dt(begin, end);</div>
<div class="line">  Reconstruction reconstruction(dt, perimeter);</div>
<div class="line"> </div>
<div class="line">  reconstruction.run();</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; reconstruction.number_of_outliers() &lt;&lt; <span class="stringliteral">" outliers:\n"</span> &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keyword">const</span> Point_3&amp; p : reconstruction.outliers()){</div>
<div class="line">    std::cout &lt;&lt; p &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Boundaries:"</span> &lt;&lt; std::endl ;</div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keyword">const</span> Vertex_on_boundary_range&amp; vobr : reconstruction.boundaries()){</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">"boundary\n"</span>;</div>
<div class="line">    <span class="comment">// As we use range-base loop we do not use the type Boundary_range</span></div>
<div class="line">    <span class="keywordflow">for</span>(Vertex_handle v : vobr){</div>
<div class="line">      std::cout &lt;&lt; v-&gt;point() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="AFSR_Example_sharp_features"></a>
Example for Sharp Features</h2>
<p>The priority queue used by the advancing front surface reconstruction algorithm can be modified to achieve robustness to sharp edges and provide piecewise-planar or hybrid reconstruction as described in <a class="el" href="citelist.html#CITEREF_cgal:la-srpss-13">[10]</a>. Two other algorithms available in CGAL must be applied first as a preprocessing to the point set:</p>
<ul>
<li><a class="elRef" href="../Shape_detection/index.html#Chapter_Shape_Detection">Shape detection</a>: detect planar sections of the input.</li>
<li><a class="elRef" href="../Point_set_processing_3/index.html#Point_set_processing_3Structuring">Point set structuring</a>: resample the planar sections and edges and corners detected among them.</li>
</ul>
<p><a class="anchor" id="fig__figAFSRstruct"></a> </p><div class="image">
<img src="structured_example.png" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__figAFSRstruct">Figure 70.3</a> Comparison of advancing front output.</p>
<ul>
<li>Top: input point set and raw advancing front reconstruction</li>
<li>Bottom: structured point set and advancing front reconstruction with structure-dependent priority functor</li>
</ul>
 </div> <p> <br>
</p>
<p>The quality of the reconstruction can be significantly improved thanks to point set structuring when dealing with shapes with sharp features, as shown on the previous figure. The following example shows how to define a priority functor that favors structurally coherent facets and makes the advancing front algorithm robust to sharp features.</p>
<p><br>
<b>File</b> <a class="el" href="Advancing_front_surface_reconstruction_2reconstruction_structured_8cpp-example.html">Advancing_front_surface_reconstruction/reconstruction_structured.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;array&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" href="../Shape_detection/Efficient__RANSAC_8h.html">CGAL/Shape_detection/Efficient_RANSAC.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/structure_point_set.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Delaunay_triangulation_3.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Triangulation_vertex_base_with_info_3.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Advancing_front_surface_reconstruction.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/disable_warnings.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;boost/lexical_cast.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>  <a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>  Point;</div>
<div class="line"><span class="keyword">typedef</span> std::pair&lt;Kernel::Point_3, Kernel::Vector_3&gt;         Point_with_normal;</div>
<div class="line"><span class="keyword">typedef</span> std::vector&lt;Point_with_normal&gt;                       Pwn_vector;</div>
<div class="line"><span class="keyword">typedef</span> CGAL::First_of_pair_property_map&lt;Point_with_normal&gt;  Point_map;</div>
<div class="line"><span class="keyword">typedef</span> CGAL::Second_of_pair_property_map&lt;Point_with_normal&gt; Normal_map;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Efficient RANSAC types</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_structRef" href="../Shape_detection/structCGAL_1_1Shape__detection_1_1Efficient__RANSAC__traits.html">CGAL::Shape_detection::Efficient_RANSAC_traits</a></div>
<div class="line">  &lt;<a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>, Pwn_vector, Point_map, Normal_map&gt;              Traits;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Efficient__RANSAC.html">CGAL::Shape_detection::Efficient_RANSAC&lt;Traits&gt;</a>    Efficient_ransac;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Plane.html">CGAL::Shape_detection::Plane&lt;Traits&gt;</a>               Plane;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Point set structuring type</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Point_set_processing_3/classCGAL_1_1Point__set__with__structure.html">CGAL::Point_set_with_structure&lt;Kernel&gt;</a>               Structure;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Advancing front types</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classCGAL_1_1Advancing__front__surface__reconstruction__vertex__base__3.html">CGAL::Advancing_front_surface_reconstruction_vertex_base_3&lt;Kernel&gt;</a> LVb;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classCGAL_1_1Advancing__front__surface__reconstruction__cell__base__3.html">CGAL::Advancing_front_surface_reconstruction_cell_base_3&lt;Kernel&gt;</a> LCb;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../TDS_3/classCGAL_1_1Triangulation__data__structure__3.html">CGAL::Triangulation_data_structure_3&lt;LVb,LCb&gt;</a> Tds;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Triangulation_3/classCGAL_1_1Delaunay__triangulation__3.html">CGAL::Delaunay_triangulation_3&lt;Kernel,Tds&gt;</a> Triangulation_3;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_typedefRef" href="../Triangulation_3/classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Triangulation_3::Vertex_handle</a> Vertex_handle;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> std::array&lt;std::size_t,3&gt; Facet;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Functor to init the advancing front algorithm with indexed points</span></div>
<div class="line"><span class="keyword">struct </span>On_the_fly_pair{</div>
<div class="line">  <span class="keyword">const</span> Pwn_vector&amp; points;</div>
<div class="line">  <span class="keyword">typedef</span> std::pair&lt;Point, std::size_t&gt; result_type;</div>
<div class="line"> </div>
<div class="line">  On_the_fly_pair(<span class="keyword">const</span> Pwn_vector&amp; points) : points(points) {}</div>
<div class="line"> </div>
<div class="line">  result_type</div>
<div class="line">  operator()(std::size_t i)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keywordflow">return</span> result_type(points[i].first,i);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Specialized priority functor that favor structure coherence</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Structure&gt;</div>
<div class="line"><span class="keyword">struct </span>Priority_with_structure_coherence {</div>
<div class="line"> </div>
<div class="line">  Structure&amp; structure;</div>
<div class="line">  <span class="keywordtype">double</span> bound;</div>
<div class="line"> </div>
<div class="line">  Priority_with_structure_coherence(Structure&amp; structure,</div>
<div class="line">                                    <span class="keywordtype">double</span> bound)</div>
<div class="line">    : structure (structure), bound (bound)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> AdvancingFront, <span class="keyword">typename</span> Cell_handle&gt;</div>
<div class="line">  <span class="keywordtype">double</span> operator() (AdvancingFront&amp; adv, Cell_handle&amp; c,</div>
<div class="line">                     <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; index)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="comment">// If perimeter &gt; bound, return infinity so that facet is not used</span></div>
<div class="line">    <span class="keywordflow">if</span> (bound != 0)</div>
<div class="line">      {</div>
<div class="line">        <span class="keywordtype">double</span> d  = 0;</div>
<div class="line">        d = <a class="code hl_functionRef" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">sqrt</a>(<a class="code hl_functionRef" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">squared_distance</a>(c-&gt;vertex((index+1)%4)-&gt;point(),</div>
<div class="line">                                  c-&gt;vertex((index+2)%4)-&gt;point()));</div>
<div class="line">        <span class="keywordflow">if</span>(d&gt;bound) <span class="keywordflow">return</span> adv.infinity();</div>
<div class="line">        d += <a class="code hl_functionRef" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">sqrt</a>(<a class="code hl_functionRef" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">squared_distance</a>(c-&gt;vertex((index+2)%4)-&gt;point(),</div>
<div class="line">                                   c-&gt;vertex((index+3)%4)-&gt;point()));</div>
<div class="line">        <span class="keywordflow">if</span>(d&gt;bound) <span class="keywordflow">return</span> adv.infinity();</div>
<div class="line">        d += <a class="code hl_functionRef" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">sqrt</a>(<a class="code hl_functionRef" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">squared_distance</a>(c-&gt;vertex((index+1)%4)-&gt;point(),</div>
<div class="line">                                   c-&gt;vertex((index+3)%4)-&gt;point()));</div>
<div class="line">        <span class="keywordflow">if</span>(d&gt;bound) <span class="keywordflow">return</span> adv.infinity();</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">    Facet f = {{ c-&gt;vertex ((index + 1) % 4)-&gt;info (),</div>
<div class="line">                 c-&gt;vertex ((index + 2) % 4)-&gt;info (),</div>
<div class="line">                 c-&gt;vertex ((index + 3) % 4)-&gt;info () }};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// facet_coherence takes values between -1 and 3, 3 being the most</span></div>
<div class="line">    <span class="comment">// coherent and -1 being incoherent. Smaller weight means higher</span></div>
<div class="line">    <span class="comment">// priority.</span></div>
<div class="line">    <span class="keywordtype">double</span> weight = 100. * (5 - structure.facet_coherence (f));</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> weight * adv.smallest_radius_delaunay_sphere (c, index);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Advancing front type</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classCGAL_1_1Advancing__front__surface__reconstruction.html">CGAL::Advancing_front_surface_reconstruction</a></div>
<div class="line">         &lt;Triangulation_3,</div>
<div class="line">          Priority_with_structure_coherence&lt;Structure&gt; &gt;</div>
<div class="line">        Reconstruction;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Points with normals.</span></div>
<div class="line">  Pwn_vector points;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> std::string fname = (argc&gt;1) ? argv[1] : <a class="code hl_functionRef" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/cube.pwn"</span>);</div>
<div class="line">  <span class="comment">// Loading point set from a file.</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (!<a class="code hl_functionRef" href="../Point_set_processing_3/group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname, std::back_inserter(points),</div>
<div class="line">                             CGAL::parameters::point_map(Point_map()).</div>
<div class="line">                                               normal_map(Normal_map())))</div>
<div class="line">  {</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file"</span> &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Shape detection... "</span>;</div>
<div class="line"> </div>
<div class="line">  Efficient_ransac ransac;</div>
<div class="line">  ransac.set_input(points);</div>
<div class="line">  ransac.add_shape_factory&lt;Plane&gt;(); <span class="comment">// Only planes are useful for structuring</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Default RANSAC parameters</span></div>
<div class="line">  Efficient_ransac::Parameters op;</div>
<div class="line">  op.probability = 0.05;</div>
<div class="line">  op.min_points = 100;</div>
<div class="line">  op.epsilon = (argc&gt;2 ? boost::lexical_cast&lt;double&gt;(argv[2]) : 0.002);</div>
<div class="line">  op.cluster_epsilon = (argc&gt;3 ? boost::lexical_cast&lt;double&gt;(argv[3]) : 0.02);</div>
<div class="line">  op.normal_threshold = 0.7;</div>
<div class="line"> </div>
<div class="line">  ransac.detect(op); <span class="comment">// Plane detection</span></div>
<div class="line"> </div>
<div class="line">  Efficient_ransac::Plane_range planes = ransac.planes();</div>
<div class="line"> </div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"done\nPoint set structuring... "</span>;</div>
<div class="line"> </div>
<div class="line">  Pwn_vector structured_pts;</div>
<div class="line">  Structure pss (points,</div>
<div class="line">                 planes,</div>
<div class="line">                 op.cluster_epsilon,  <span class="comment">// Same parameter as RANSAC</span></div>
<div class="line">                 CGAL::parameters::point_map (Point_map()).</div>
<div class="line">                 normal_map (Normal_map()).</div>
<div class="line">                 plane_map (<a class="code hl_classRef" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Plane__map.html">CGAL::Shape_detection::Plane_map&lt;Traits&gt;</a>()).</div>
<div class="line">                 plane_index_map(<a class="code hl_classRef" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Point__to__shape__index__map.html">CGAL::Shape_detection::Point_to_shape_index_map&lt;Traits&gt;</a>(points, planes)));</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; pss.size(); ++ i)</div>
<div class="line">    structured_pts.push_back (pss[i]);</div>
<div class="line"> </div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"done\nAdvancing front... "</span>;</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;std::size_t&gt; point_indices(boost::counting_iterator&lt;std::size_t&gt;(0),</div>
<div class="line">                                         boost::counting_iterator&lt;std::size_t&gt;(structured_pts.size()));</div>
<div class="line"> </div>
<div class="line">  Triangulation_3 dt (boost::make_transform_iterator(point_indices.begin(), On_the_fly_pair(structured_pts)),</div>
<div class="line">                      boost::make_transform_iterator(point_indices.end(), On_the_fly_pair(structured_pts)));</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  Priority_with_structure_coherence&lt;Structure&gt; priority (pss,</div>
<div class="line">                                                         1000. * op.cluster_epsilon); <span class="comment">// Avoid too large facets</span></div>
<div class="line">  Reconstruction R(dt, priority);</div>
<div class="line">  R.run ();</div>
<div class="line"> </div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"done\nWriting result... "</span>;</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;Facet&gt; output;</div>
<div class="line">  <span class="keyword">const</span> Reconstruction::TDS_2&amp; tds = R.triangulation_data_structure_2();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span>(Reconstruction::TDS_2::Face_iterator fit = tds.faces_begin(); fit != tds.faces_end(); ++fit)</div>
<div class="line">    <span class="keywordflow">if</span>(fit-&gt;is_on_surface())</div>
<div class="line">      output.push_back (<a class="code hl_functionRef" href="../STL_Extension/group__PkgSTLExtensionRef.html#ga08aa4fa93a53622eae19f823e8e141df">CGAL::make_array</a>(fit-&gt;vertex(0)-&gt;vertex_3()-&gt;id(),</div>
<div class="line">                                         fit-&gt;vertex(1)-&gt;vertex_3()-&gt;id(),</div>
<div class="line">                                         fit-&gt;vertex(2)-&gt;vertex_3()-&gt;id()));</div>
<div class="line"> </div>
<div class="line">  std::ofstream f (<span class="stringliteral">"out.off"</span>);</div>
<div class="line">  f &lt;&lt; <span class="stringliteral">"OFF\n"</span> &lt;&lt; structured_pts.size () &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; output.size() &lt;&lt; <span class="stringliteral">" 0\n"</span>; <span class="comment">// Header</span></div>
<div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; structured_pts.size (); ++ i)</div>
<div class="line">    f &lt;&lt; structured_pts[i].first &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; output.size (); ++ i)</div>
<div class="line">    f &lt;&lt; <span class="stringliteral">"3 "</span></div>
<div class="line">      &lt;&lt; output[i][0] &lt;&lt; <span class="stringliteral">" "</span></div>
<div class="line">      &lt;&lt; output[i][1] &lt;&lt; <span class="stringliteral">" "</span></div>
<div class="line">      &lt;&lt; output[i][2] &lt;&lt; std::endl;</div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"all done\n"</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  f.close();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aEfficient__RANSAC_8h_html"><div class="ttname"><a href="../Shape_detection/Efficient__RANSAC_8h.html">Efficient_RANSAC.h</a></div></div>
<div class="ttc" id="aclassCGAL_1_1Advancing__front__surface__reconstruction__cell__base__3_html"><div class="ttname"><a href="classCGAL_1_1Advancing__front__surface__reconstruction__cell__base__3.html">CGAL::Advancing_front_surface_reconstruction_cell_base_3</a></div><div class="ttdoc">The class Advancing_front_surface_reconstruction_cell_base_3 is the default cell type for the class A...</div><div class="ttdef"><b>Definition:</b> Advancing_front_surface_reconstruction_cell_base_3.h:33</div></div>
<div class="ttc" id="aclassCGAL_1_1Advancing__front__surface__reconstruction__vertex__base__3_html"><div class="ttname"><a href="classCGAL_1_1Advancing__front__surface__reconstruction__vertex__base__3.html">CGAL::Advancing_front_surface_reconstruction_vertex_base_3</a></div><div class="ttdoc">The class Advancing_front_surface_reconstruction_vertex_base_3 is the default vertex type for the cla...</div><div class="ttdef"><b>Definition:</b> Advancing_front_surface_reconstruction_vertex_base_3.h:43</div></div>
<div class="ttc" id="aclassCGAL_1_1Delaunay__triangulation__3_html"><div class="ttname"><a href="../Triangulation_3/classCGAL_1_1Delaunay__triangulation__3.html">CGAL::Delaunay_triangulation_3</a></div></div>
<div class="ttc" id="aclassCGAL_1_1Point__set__with__structure_html"><div class="ttname"><a href="../Point_set_processing_3/classCGAL_1_1Point__set__with__structure.html">CGAL::Point_set_with_structure</a></div></div>
<div class="ttc" id="aclassCGAL_1_1Shape__detection_1_1Efficient__RANSAC_html"><div class="ttname"><a href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Efficient__RANSAC.html">CGAL::Shape_detection::Efficient_RANSAC</a></div></div>
<div class="ttc" id="aclassCGAL_1_1Shape__detection_1_1Plane__map_html"><div class="ttname"><a href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Plane__map.html">CGAL::Shape_detection::Plane_map</a></div></div>
<div class="ttc" id="aclassCGAL_1_1Shape__detection_1_1Plane_html"><div class="ttname"><a href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Plane.html">CGAL::Shape_detection::Plane</a></div></div>
<div class="ttc" id="aclassCGAL_1_1Shape__detection_1_1Point__to__shape__index__map_html"><div class="ttname"><a href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Point__to__shape__index__map.html">CGAL::Shape_detection::Point_to_shape_index_map</a></div></div>
<div class="ttc" id="aclassCGAL_1_1Triangulation__3_html_a1ba56e37b3a5acb1ba49a56d9d101a19"><div class="ttname"><a href="../Triangulation_3/classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">CGAL::Triangulation_3::Vertex_handle</a></div><div class="ttdeci">Triangulation_data_structure::Vertex_handle Vertex_handle</div></div>
<div class="ttc" id="aclassCGAL_1_1Triangulation__data__structure__3_html"><div class="ttname"><a href="../TDS_3/classCGAL_1_1Triangulation__data__structure__3.html">CGAL::Triangulation_data_structure_3</a></div></div>
<div class="ttc" id="agroup__PkgPointSetProcessing3IO_html_ga8fac388459c5cf96bf11ce3b4e0459c1"><div class="ttname"><a href="../Point_set_processing_3/group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a></div><div class="ttdeci">bool read_points(const std::string &amp;fname, PointOutputIterator output, const NamedParameters &amp;np=parameters::default_values())</div></div>
<div class="ttc" id="agroup__PkgSTLExtensionRef_html_ga08aa4fa93a53622eae19f823e8e141df"><div class="ttname"><a href="../STL_Extension/group__PkgSTLExtensionRef.html#ga08aa4fa93a53622eae19f823e8e141df">CGAL::make_array</a></div><div class="ttdeci">std::array&lt; T, N &gt; make_array(const T &amp;...)</div></div>
<div class="ttc" id="astructCGAL_1_1Shape__detection_1_1Efficient__RANSAC__traits_html"><div class="ttname"><a href="../Shape_detection/structCGAL_1_1Shape__detection_1_1Efficient__RANSAC__traits.html">CGAL::Shape_detection::Efficient_RANSAC_traits</a></div></div>
</div><!-- fragment --> </div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"></a> 1.9.6 </li>
  </ul>
</div>
</div>
</body>


</html>
