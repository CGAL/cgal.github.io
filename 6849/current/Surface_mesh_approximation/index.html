<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Surface_mesh_approximation/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=11">
<meta name="generator" content="Doxygen 1.9.6">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CGAL 6.0 - Triangulated Surface Mesh Approximation: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/doxygen.css" rel="stylesheet" type="text/css">
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      },
      equationNumbers: { autoNumber: "AMS" }
  }
}
);
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
      <span class="left">
         <span id="MSearchSelect" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()">Â 
        </span>
        <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
      </span>
      <span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.svg" alt=""></a>
      </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CGAL 6.0 - Triangulated Surface Mesh Approximation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search/",'.html');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">User Manual </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Triangulated_Surface_Mesh_Approximation"></a> </p> <div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Authors</dt><dd>Pierre Alliez, David Cohen-Steiner, Lingjie Zhu</dd></dl>
<h1><a class="anchor" id="sma_introduction"></a>
Introduction</h1>
<p>This package implements the <em>Variational Shape Approximation</em> <a class="el" href="citelist.html#CITEREF_cgal:cad-vsa-04">[1]</a> (VSA) method to approximate an input surface mesh by a simpler surface triangle mesh. The input of the algorithm must be:</p><ul>
<li>Triangulated</li>
<li>Combinatorially 2-manifold</li>
</ul>
<p>The output is a triangle soup and can be built into a polygon surface mesh.</p>
<p>Given an input surface triangle mesh, VSA leverages a discrete clustering algorithm to approximate it by a set of local simple shapes referred to as proxies. Each cluster is represented as a connected set of triangles of the input mesh, and the output mesh is constructed by generating a surface triangle mesh which approximates the clusters. The approximation error is one-sided, defined between the clusters and their associated proxies. Two error metrics ( \( \mathcal{L}^2 \), \( \mathcal{L}^{2,1} \)) for planar proxies are provided via the classes <code><a class="el" href="classCGAL_1_1Surface__mesh__approximation_1_1L2__metric__plane__proxy.html" title="Approximation L2 metric of plane proxy.">CGAL::Surface_mesh_approximation::L2_metric_plane_proxy</a></code> and <code><a class="el" href="classCGAL_1_1Surface__mesh__approximation_1_1L21__metric__plane__proxy.html" title="Approximation L21 metric of vector proxy.">CGAL::Surface_mesh_approximation::L21_metric_plane_proxy</a></code>, and the algorithm design is generic to other user-defined metrics. The current proxies are planes or vectors, however the algorithm design is generic for future extensions to non-planar proxies <a class="el" href="citelist.html#CITEREF_cgal:ywly-vmsqs-12">[4]</a><a class="el" href="citelist.html#CITEREF_cgal:wk-srhvs-05">[3]</a>. The default \( \mathcal{L}^{2,1} \) metric is recommended in terms of computation and visual perception <a class="el" href="citelist.html#CITEREF_cgal:cad-vsa-04">[1]</a>. A brief background about <em>Proxy</em> and <em>ErrorMetric</em> is provided in Section <a class="el" href="index.html#sma_background">Background</a>.</p>
<p><a class="anchor" id="fig__Approximation_teaser"></a> </p><div class="image">
<img src="teaser.jpg" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__Approximation_teaser">Figure 80.1</a> Variational shape approximation on two models with the \( \mathcal{L}^{2,1} \) error metric and planar proxies. From left to right: partition of the input surface triangle mesh, anchor vertices and edges, and output triangle mesh. The partition is optimized via discrete clustering of the input triangles, so as to minimize the approximation error from the clusters to the planar proxies (not shown). </p> </div> <p> <br>
</p>
<p>This package offers both the approximation and mesh construction functionalities, through the free function <code><a class="el" href="group__PkgTSMARef.html#ga4bd463b1bad91654f253895861d37dbd" title="approximates the input mesh with plane proxies.">CGAL::Surface_mesh_approximation::approximate_triangle_mesh()</a></code> which runs a fully automated version of the algorithm: <br>
<b>File</b> <a class="el" href="Surface_mesh_approximation_2vsa_simple_approximation_example_8cpp-example.html">Surface_mesh_approximation/vsa_simple_approximation_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_approximation/approximate_triangle_mesh.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/IO/polygon_mesh_io.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> <a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Kernel::Point_3&gt;</a> Mesh;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>VSA = CGAL::Surface_mesh_approximation;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : <a class="code hl_functionRef" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/bear.off"</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// reads input surface triangle mesh</span></div>
<div class="line">  Mesh mesh;</div>
<div class="line">  <span class="keywordflow">if</span>(!<a class="code hl_functionRef" href="../Polygon_mesh_processing/group__PMP__IO__grp.html#gac5b3295bd1b6375628a46d1fbaf7e881">CGAL::Polygon_mesh_processing::IO::read_polygon_mesh</a>(filename, mesh) ||</div>
<div class="line">     !<a class="code hl_functionRef" href="../BGL/group__PkgBGLHelperFct.html#ga11883d231eec1b58f37efe4acedd9588">CGAL::is_triangle_mesh</a>(mesh))</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input file."</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The output will be an indexed triangle mesh</span></div>
<div class="line">  std::vector&lt;Kernel::Point_3&gt; anchors;</div>
<div class="line">  std::vector&lt;std::array&lt;std::size_t, 3&gt; &gt; triangles;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// free function interface with named parameters</span></div>
<div class="line">  VSA::approximate_triangle_mesh(mesh,</div>
<div class="line">                                 CGAL::parameters::verbose_level(VSA::MAIN_STEPS).</div>
<div class="line">                                                   max_number_of_proxies(200).</div>
<div class="line">                                                   anchors(std::back_inserter(anchors)). <span class="comment">// anchor points</span></div>
<div class="line">                                                   triangles(std::back_inserter(triangles))); <span class="comment">// indexed triangles</span></div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"#anchor points: "</span> &lt;&lt; anchors.size() &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"#triangles: "</span> &lt;&lt; triangles.size() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="ttc" id="aclassCGAL_1_1Exact__predicates__inexact__constructions__kernel_html"><div class="ttname"><a href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a></div></div>
<div class="ttc" id="aclassCGAL_1_1Surface__mesh_html"><div class="ttname"><a href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh</a></div></div>
<div class="ttc" id="agroup__PMP__IO__grp_html_gac5b3295bd1b6375628a46d1fbaf7e881"><div class="ttname"><a href="../Polygon_mesh_processing/group__PMP__IO__grp.html#gac5b3295bd1b6375628a46d1fbaf7e881">CGAL::Polygon_mesh_processing::IO::read_polygon_mesh</a></div><div class="ttdeci">bool read_polygon_mesh(const std::string &amp;fname, PolygonMesh &amp;g, const NamedParameters &amp;np=parameters::default_values())</div></div>
<div class="ttc" id="agroup__PkgBGLHelperFct_html_ga11883d231eec1b58f37efe4acedd9588"><div class="ttname"><a href="../BGL/group__PkgBGLHelperFct.html#ga11883d231eec1b58f37efe4acedd9588">CGAL::is_triangle_mesh</a></div><div class="ttdeci">bool is_triangle_mesh(const FaceGraph &amp;g)</div></div>
<div class="ttc" id="anamespaceCGAL_html_acdae9a147ad2a3998cc21f88bc292dac"><div class="ttname"><a href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a></div><div class="ttdeci">std::string data_file_path(const std::string &amp;filename)</div></div>
<div class="ttc" id="anamespaceKernel_html"><div class="ttname"><a href="../Kernel_23/namespaceKernel.html">Kernel</a></div></div>
</div><!-- fragment --><p>A class interface is also provided for advanced users, in which a series of pliant operators offer interactive capabilities during clustering and customization in terms of error and proxies.</p>
<h1><a class="anchor" id="sma_overview"></a>
Overview</h1>
<p>The package contains 3 main components: approximation algorithm, pliant operators and meshing as shown in <a class="el" href="index.html#fig__workflow">Figure 80.2</a>.</p>
<p><a class="anchor" id="fig__workflow"></a> </p><div class="image">
<object type="image/svg+xml" data="workflow.svg" style="pointer-events: none;"></object>
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__workflow">Figure 80.2</a> From left to right are 3 components of the approximation package: approximation algorithm (left), optional pliant operations (middle) and meshing (right). </p> </div> <p> <br>
</p>
<h2><a class="anchor" id="sma_approximation"></a>
Approximation</h2>
<p>The left part of <a class="el" href="index.html#fig__workflow">Figure 80.2</a> depicts the workflow of the approximation algorithm.</p>
<h3><a class="anchor" id="sma_clustering"></a>
Clustering Iteration</h3>
<p><a class="el" href="index.html#fig__iterations">Figure 80.3</a> depicts several Lloyd <a class="el" href="citelist.html#CITEREF_cgal:l-lsqp-82">[2]</a> clustering iterations on the plane-sphere model with planar proxies and the \( \mathcal{L}^{2,1} \) metric. We plot the fitting error against each iteration. After 8 iterations, the error barely changes. Based on this observation, we consider that the clustering converges if the error change between the current and previous iteration is lower than a user-specified threshold (indicated by two green dash lines).</p>
<p><a class="anchor" id="fig__iterations"></a> </p><div class="image">
<img src="iterations.jpg" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__iterations">Figure 80.3</a> Discrete Lloyd iterations on the plane-sphere model with planar proxies and the \( \mathcal{L}^{2,1} \) metric: (left) random seeding of 6 proxies; (center) after one iteration; (right) after 8 iterations, the regions settle. The red lines depict the proxy normals drawn at the seed faces. </p> </div> <p> <br>
</p>
<h3><a class="anchor" id="sma_seeding"></a>
Seeding</h3>
<p>Each proxy is always associated to a <em>seed</em> triangle face in the input surface mesh. While the proxies may be viewed as centers (or best representative) in a geometric error sense, the seed of each proxy is used as the starting point in the clustering process. Seeding is the processing of deciding how to select a seed face where a new proxy/partition can be initialized from.</p>
<p>To start the clustering iterations, we need an initial set of proxies. The default (hierarchical) approach generates one proxy per connected component, seeded at arbitrarily chosen faces. It then adds more proxies in batches, in order to drive the error down. After each batch of proxies added, it performs several inner clustering iterations, which is referred to as <em>relaxation</em> in the seeding step.</p>
<p>Assuming a clustering partition of \(n\) regions with errors \( \{E_k\}_{k=1\cdots n} \), and we wish to add \(m\) proxies. We provide 3 different seeding methods:</p><ul>
<li><b>Random</b>. \(m\) seed faces are picked randomly on the surface, excluding the current seed faces.</li>
<li><b>Incremental</b>. Each new proxy is initialized from a face of the region with the largest approximation error. The face itself is chosen as the one realizing the largest error in its region.</li>
<li><b>Hierarchical</b>. \(m\) seed faces are dispatched within the current partition, where each region is refined with a number of proxies chosen in accordance to its fitting error:<ul>
<li>calculate total error \( E_{total} \), then average error \( E_{avg} = E_{total} / m \) (assuming that each new proxy shares the same amount of error)</li>
<li>sort errors \( \{E_{min},\cdots,E_{max}\} \)</li>
<li>from \( E_{min} \) to \( E_{max} \), we diffuse the error <em>hierarchically</em> one after another. More specifically, the number of proxies \(N_k\) added to the \(k\)th region is proportional to its error: <p class="formulaDsp">
\[ N_k = \lfloor E_k / E_{avg} + 0.5 \rfloor, \]
</p>
 and the remaining error is added to the next proxy error in order to keep the total error unchanged: <p class="formulaDsp">
\[ E'_{k+1} = (E_k - N_k * E_{avg}) + E_{k+1}. \]
</p>
</li>
</ul>
</li>
</ul>
<p><a class="el" href="index.html#fig__seeding_method">Figure 80.4</a> depicts different seeding methods. Random initialization randomly selects a set of input triangle faces as proxy seeds. While it is very fast, the subsequent clustering process can be entrapped in a bad local minimum, especially on shapes with regions surrounded by sharp creases (left closeup). Incremental initialization adds the proxies one by one at the most distorted region. It can thus be slow due to the large number of interleaved relaxation iterations. Hierarchical initialization (selected by default) repeatedly doubles the number of proxies in a hierarchical refinement sequence, so as to generate clustering regions with evenly distributed fitting errors. Time consumption is typically in-between the former two. Statistics and comparisons are available in Section <a class="el" href="index.html#sma_perf">Performances</a>.</p>
<p><a class="anchor" id="fig__seeding_method"></a> </p><div class="image">
<img src="seeding_method.jpg" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__seeding_method">Figure 80.4</a> Different seeding methods on the sphere-cube model. From left to right: initial partition ( \( \mathcal{L}^{2,1} \) metrics and 20 proxies), add 5 proxy seeds (red faces) with random, incremental and hierarchical methods respectively. </p> </div> <p> <br>
</p>
<h3><a class="anchor" id="sma_stop"></a>
Stop Criteria</h3>
<p>To determine when to stop adding more proxies, we can specify either the maximum number of proxies required to approximate the geometry or the minimum error drop percentage with respect to the very first partition. More specifically, we can decide:</p><ul>
<li><b>Maximum number of proxies</b>. Adding proxies until the specified number is met.</li>
<li><b>Minimum error drop</b>. Starting from the very first partition (with one proxy per connected component) with fitting error \( \hat E \), the algorithm adds proxies until the approximation error drops below the specified percentage \( target\_drop * \hat E \). As depicted by <a class="el" href="index.html#fig__nb_proxies">Figure 80.5</a>, specifying a minimum error drop of 10% (yellow dash lines) as stopping criterion, yields 12 proxies on the plane-sphere model. When both criteria are provided, the first criterion met stops the seeding. Different seeding examples are depicted by <a class="el" href="index.html#fig__meshing">Figure 80.10</a>. To balance between performance and speed, we recommend using hierarchical seeding and specifying both stopping criteria.</li>
</ul>
<p><a class="anchor" id="fig__nb_proxies"></a> </p><div class="image">
<img src="nb_proxies.jpg" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__nb_proxies">Figure 80.5</a> Using different number of proxies to approximate the plane-sphere model. From left to right: 8, 14, 20 proxies. We plot right the error against the number of proxies. </p> </div> <p> <br>
</p>
<h2><a class="anchor" id="sma_operations"></a>
Pliant Operators</h2>
<p>For interactive use, the approach can yield better approximations of the geometry via adding/removing proxies and tunneling out of local minima via additional operations:</p><ul>
<li><b>Merging</b>. Merging two adjacent regions.</li>
<li><b>Splitting</b>. Splitting one specified region into smaller ones to reduce the error. By default bisection is performed but N-section is also possible. We first select the request number of face seeds from the specified region, then perform the refitting process confined to the region.</li>
<li><b>Adding</b>. Adding one or more proxies to further reduce the approximation error. As for the seeding process, addition can be performed incrementally or hierarchically, as shown in <a class="el" href="index.html#fig__seeding_method">Figure 80.4</a>.</li>
<li><b>Teleporting</b>. A teleportation operator is a combination of merging and adding proxies: merging the pair of adjacent regions and adding a proxy seed to the worst region. More specifically, the pair of regions whose merging realizes the smallest error after merging and local re-fitting, is selected for merging. In practice, the teleport operation can temporarily either decrease or increase the total approximation error. We provide an optional heuristic to evaluate if the teleportation is worth it by verifying whether the error increase induced by a (simulated) deletion is smaller than half of the error of the worst region. If this test fails, no teleportation is judged necessary.</li>
</ul>
<p><a class="anchor" id="fig__operations"></a> </p><div class="image">
<img src="operations.jpg" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__operations">Figure 80.6</a> Operations on the sphere-cube union model. Upper row: merging (9 proxies) and the reverse bisection splitting (10 partitions) on the confined region. Lower row: one teleportation operation of merging and adding a face seed, the sphere is approximated with one more proxy. </p> </div> <p> <br>
</p>
<p>As depicted in <a class="el" href="index.html#fig__operations">Figure 80.6</a>, teleportation provides a means to relocate a local minimum region entrapped in the planar part (left) to the most needed regions on the sphere (right). In <a class="el" href="index.html#sma_example3">Class Interface</a>, the class interface is used to control the approximation process through the aforementioned operations.</p>
<h2><a class="anchor" id="sma_meshing"></a>
Meshing</h2>
<p>This package implements the meshing algorithm described in <a class="el" href="citelist.html#CITEREF_cgal:cad-vsa-04">[1]</a> by generating a triangle mesh approximation of the clustering partition. The meshing algorithm has two major steps:</p><ul>
<li><b>Finding anchors</b>. <em>Anchors</em> are just a subset of the vertices of the input mesh on the region boundaries.</li>
<li><b>Discrete constrained 2D Delaunay triangulation</b>. Connecting the anchors to generate the final approximated triangle mesh.</li>
</ul>
<h3><a class="anchor" id="sma_anchors_basic"></a>
Basic Anchors</h3>
<p>A vertex is selected as a basic anchor if it is:</p><ul>
<li>not a mesh boundary vertex and adjacent to at least three regions,</li>
<li>or a mesh boundary vertex adjacent to at least two regions.</li>
</ul>
<h3><a class="anchor" id="sma_anchors_subdivision"></a>
Subdivision Anchors</h3>
<p>Walking along the boundary of a proxy region (counterclockwise), a <em>chord</em> is a sequence of halfedges connecting two anchors. One cluster boundary cycle may consist of several chords. A connected region with holes may yield several boundary cycles (<a class="el" href="index.html#fig__operations">Figure 80.6</a>, planar part before teleportation).</p>
<p>In order to approximate complex boundaries well, more anchors are generated by recursive chord subdivision (<a class="el" href="index.html#fig__chord">Figure 80.7</a>). An anchor \( \mathbf{c} \) is added at the furthest vertex of a chord \( (\mathbf{a}, \mathbf{b}) \), split it into \( (\mathbf{a}, \mathbf{c}) \) and \( (\mathbf{c}, \mathbf{b}) \), if the distance \( d = \Vert \mathbf{c} , (\mathbf{a}, \mathbf{b}) \Vert \) is beyond certain threshold. To make \( d \) independent to the scale of the input: </p><p class="formulaDsp">
\[ d = d / input\_mesh\_average\_edge\_length. \]
</p>
<p> Optionally, \( d \) can be measured as the ratio of the chord length: </p><p class="formulaDsp">
\[ d = d / \Vert(\mathbf{a}, \mathbf{b})\Vert. \]
</p>
<p> Also, we can add a dihedral angle weight \( sin(\mathbf{N}_i,\mathbf{N}_j) \) to the distance measurement, where \( \mathbf{N}_i,\mathbf{N}_j \) are the normals of the proxies separated by the chord \( (\mathbf{a}, \mathbf{b}) \). If the angle between proxy \( P_i \) and \( P_j \) is rather small, then a coarse approximation will do as it does not add geometric information on the shape. Trivial chords (made of a single edge) are not subdivided. In case of circular chords, additional anchors may be added to maintain the topology, as detailed in Section <a class="el" href="index.html#sma_anchors_additional">Additional Anchors</a>.</p>
<p><a class="anchor" id="fig__chord"></a> </p><div class="image">
<img src="chord.jpg" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__chord">Figure 80.7</a> Varying the chord error. From left to right: clustering partition, and meshing with decreasing absolute chord error 5, 3 and 1 without dihedral angle weight. The boundaries of the partition (red lines) are approximated with increasing accuracy. </p> </div> <p> <br>
</p>
<h3><a class="anchor" id="sma_anchors_additional"></a>
Additional Anchors</h3>
<p>For a boundary cycle without any anchor such as the hole depicted <a class="el" href="index.html#fig__operations">Figure 80.6</a>, we first add a starting anchor to the boundary. We then subdivide this circular chord to ensure that every boundary cycle has at least 2 anchors (i.e., every chord is connecting 2 different anchors, <a class="el" href="index.html#fig__anchors">Figure 80.8</a>). Finally, we add additional anchors to ensure that at least three anchor vertices are generated on every boundary cycle.</p>
<p><a class="anchor" id="fig__anchors"></a> </p><div class="image">
<img src="anchors.jpg" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__anchors">Figure 80.8</a> Adding anchors. From left to right: starting from a partition (grey) with a hole (white) and two encircled regions (green and blue), we add a starting anchor (orange disk) to the boundary cycle (red dash line) without any anchor (2nd), subdivide the circular chord (3rd, the number indicates the level of recursion) and add anchors to the boundary cycle with less than 2 anchors (4th, red dash lines). </p> </div> <p> <br>
</p>
<h3><a class="anchor" id="sma_triangulation"></a>
Discrete Triangulation</h3>
<p>With the anchors defined, their chord connection graph forms a general polygon mesh. Because of non-flat, concave polygon or polygons with holes, we need to triangulate this initial polygon mesh. The triangulation is generated by computing a discrete variant of a constrained 2D Delaunay triangulation, where distances are measured on the input triangle mesh.</p>
<p>The first image of <a class="el" href="index.html#fig__triangulation">Figure 80.9</a> depicts how the Delaunay triangulation of set of points (colored disks) is deduced from its dual Voronoi diagram (colored regions separated by blue lines) by connecting the points indicated by the vertices (red circles) where 3 Voronoi cells meet. In an analogous manner, we construct discrete Voronoi cells from which the triangulation is extracted.</p>
<p>In a first step, we start a flooding of the interior of the region, coloring the vertices according to their closest anchor vertex. We then only flood the boundary of a region so that every vertex on it is colored depending on the closest anchor vertex. This enforces the constrained edges by forcing the boundary to be in it.</p>
<p><a class="anchor" id="fig__triangulation"></a> </p><div class="image">
<img src="triangulation.jpg" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__triangulation">Figure 80.9</a> Discrete constrained triangulation on a sphere model. The triangulation process first floods the inner vertices (red arrows, 2nd) to simulate the Voronoi diagram. It then constructs constrained edges between anchor vertices, by flooding along the boundary edges (red arrows, 3rd). Finally, triangles (red hollow triangle, 4th) are formed by connecting the source anchors (black arrows, 4th) of the faces where 3 Voronoi cells meet (red solid triangle, 4th). </p> </div> <p> <br>
</p>
<p>After each clustering region is triangulated, the final anchor positions are recomputed by averaging the projections of an anchor on its incident proxies.</p>
<p>In <a class="el" href="index.html#fig__meshing">Figure 80.10</a>, the bear model is approximated through \( \mathcal{L}^{2,1} \) metric and the final number of proxies is determined by monitoring the error drop. The anchor points (black) are attached to the corresponding vertex on the mesh (white). The red lines connecting the anchor points approximate the boundary of each region.</p>
<p><a class="anchor" id="fig__meshing"></a> </p><div class="image">
<img src="meshing.jpg" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__meshing">Figure 80.10</a> Meshing the bear model with decreasing target error drop. From left to right, the target error drop are 6%, 4% and 2% to the initial error respectively, the output mesh densifies. Notice the boundary subdivision in the black rectangle area. </p> </div> <p> <br>
</p>
<p>As there is no guarantee that the output mesh is 2-manifold and oriented, the main input is an indexed triangle set. We can use <a class="elRef" href="../Polygon_mesh_processing/index.html#PMPPolygonSoups">Polygon Soups</a> to build the triangle soup into a valid polygon mesh.</p>
<h2><a class="anchor" id="sma_api"></a>
API</h2>
<p>This package can be used with any class model of the concept <code><a class="elRef" href="../BGL/classFaceListGraph.html">FaceListGraph</a></code> described in <a class="elRef" href="../Manual/packages.html#PkgBGL">CGAL and the Boost Graph Library</a>.</p>
<p>Free function with <a class="elRef" href="../BGL/group__bgl__namedparameters.html">Named Parameters</a> options.</p><ul>
<li><code><a class="el" href="group__PkgTSMARef.html#ga4bd463b1bad91654f253895861d37dbd" title="approximates the input mesh with plane proxies.">CGAL::Surface_mesh_approximation::approximate_triangle_mesh()</a></code>: given a triangle mesh, approximate the geometry with default \( \mathcal{L}^{2,1} \) metric.</li>
</ul>
<p>Class interface:</p><ul>
<li><code><a class="el" href="classCGAL_1_1Variational__shape__approximation.html" title="Main class for Variational Shape Approximation algorithm.">CGAL::Variational_shape_approximation</a></code>: allowing more customization of the proxy, metric and approximation process. As shown in <a class="el" href="index.html#fig__workflow">Figure 80.2</a>, typical calling order of the approximation and meshing process is:<ul>
<li><a class="el" href="classCGAL_1_1Variational__shape__approximation.html#a8b5b69c3f841a27f7a5c9ebde1ecc8bb">initialize seeds </a></li>
<li><a class="el" href="classCGAL_1_1Variational__shape__approximation.html#a9fa9ea011fc167ebc5aa301452af60cf">run clustering iterations </a></li>
<li><a class="el" href="classCGAL_1_1Variational__shape__approximation.html#a94c248ead7a448407ee5ef0a0865a969">extract mesh </a></li>
<li><a class="el" href="classCGAL_1_1Variational__shape__approximation.html#a057ed7685d6b18427956ab101a76c486">take outputs </a></li>
</ul>
</li>
</ul>
<p>One thing to note is that some parameters depend heavily on the input, like the number of proxies. Although we can approximate a geometry with any number of proxies regardless of the quality, it is not recommended to use all the defaults without any consideration of the input.</p>
<h1><a class="anchor" id="sma_examples"></a>
Examples</h1>
<h2><a class="anchor" id="sma_example1"></a>
Free Function Approximation</h2>
<p>The following example calls the free function <code><a class="el" href="group__PkgTSMARef.html#ga4bd463b1bad91654f253895861d37dbd" title="approximates the input mesh with plane proxies.">CGAL::Surface_mesh_approximation::approximate_triangle_mesh()</a></code> on the input triangle mesh with default <code><a class="el" href="classCGAL_1_1Surface__mesh__approximation_1_1L21__metric__plane__proxy.html" title="Approximation L21 metric of vector proxy.">CGAL::Surface_mesh_approximation::L21_metric_plane_proxy</a></code>.</p>
<p><br>
<b>File</b> <a class="el" href="Surface_mesh_approximation_2vsa_approximation_example_8cpp-example.html">Surface_mesh_approximation/vsa_approximation_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_approximation/approximate_triangle_mesh.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/orient_polygon_soup.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/polygon_soup_to_polygon_mesh.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/orientation.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/IO/polygon_mesh_io.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> <a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Kernel::Point_3&gt;</a> Mesh;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>VSA = CGAL::Surface_mesh_approximation;</div>
<div class="line"><span class="keyword">namespace </span>PMP = <a class="code hl_namespaceRef" href="../Polygon_mesh_processing/classCGAL_1_1Polygon__mesh__processing_1_1Adaptive__sizing__field.html">CGAL::Polygon_mesh_processing</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : <a class="code hl_functionRef" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/bear.off"</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// read input surface triangle mesh</span></div>
<div class="line">  Mesh mesh;</div>
<div class="line">  <span class="keywordflow">if</span>(!<a class="code hl_functionRef" href="../Polygon_mesh_processing/group__PMP__IO__grp.html#gac5b3295bd1b6375628a46d1fbaf7e881">CGAL::Polygon_mesh_processing::IO::read_polygon_mesh</a>(filename, mesh) ||</div>
<div class="line">     !<a class="code hl_functionRef" href="../BGL/group__PkgBGLHelperFct.html#ga11883d231eec1b58f37efe4acedd9588">CGAL::is_triangle_mesh</a>(mesh))</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input file."</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// output indexed triangles</span></div>
<div class="line">  std::vector&lt;Kernel::Point_3&gt; anchors;</div>
<div class="line">  std::vector&lt;std::array&lt;std::size_t, 3&gt; &gt; triangles; <span class="comment">// triplets of indices</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// free function interface with named parameters</span></div>
<div class="line">  <span class="keywordtype">bool</span> is_manifold = VSA::approximate_triangle_mesh(mesh,</div>
<div class="line">    CGAL::parameters::seeding_method(VSA::HIERARCHICAL). <span class="comment">// hierarchical seeding</span></div>
<div class="line">                      max_number_of_proxies(200). <span class="comment">// seeding with maximum number of proxies</span></div>
<div class="line">                      number_of_iterations(30). <span class="comment">// number of clustering iterations after seeding</span></div>
<div class="line">                      anchors(std::back_inserter(anchors)). <span class="comment">// anchor vertices</span></div>
<div class="line">                      triangles(std::back_inserter(triangles))); <span class="comment">// indexed triangles</span></div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"#anchor vertices: "</span> &lt;&lt; anchors.size() &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"#triangles: "</span> &lt;&lt; triangles.size() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (is_manifold) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">"oriented, 2-manifold output."</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// convert from soup to surface mesh</span></div>
<div class="line">    PMP::orient_polygon_soup(anchors, triangles);</div>
<div class="line">    Mesh output;</div>
<div class="line">    PMP::polygon_soup_to_polygon_mesh(anchors, triangles, output);</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_functionRef" href="../BGL/group__PkgBGLHelperFct.html#gae04c8044cf1eee6a84baa5b79ab99fef">CGAL::is_closed</a>(output) &amp;&amp; (!PMP::is_outward_oriented(output)))</div>
<div class="line">      PMP::reverse_face_orientations(output);</div>
<div class="line"> </div>
<div class="line">    std::ofstream out(<span class="stringliteral">"dump.off"</span>);</div>
<div class="line">    out &lt;&lt; output;</div>
<div class="line">    out.close();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="ttc" id="aclassCGAL_1_1Polygon__mesh__processing_1_1Adaptive__sizing__field_html"><div class="ttname"><a href="../Polygon_mesh_processing/classCGAL_1_1Polygon__mesh__processing_1_1Adaptive__sizing__field.html">CGAL::Polygon_mesh_processing</a></div></div>
<div class="ttc" id="agroup__PkgBGLHelperFct_html_gae04c8044cf1eee6a84baa5b79ab99fef"><div class="ttname"><a href="../BGL/group__PkgBGLHelperFct.html#gae04c8044cf1eee6a84baa5b79ab99fef">CGAL::is_closed</a></div><div class="ttdeci">bool is_closed(const FaceGraph &amp;g)</div></div>
</div><!-- fragment --><p>The function parameters are provided through <a class="elRef" href="../BGL/group__bgl__namedparameters.html">Named Parameters</a>. Setting the non-default parameter values requires calling the functions with the required parameters, connected by a dot and in an arbitrary order. The following example shows a different configuration of parameters and retrieves the indexed face proxy map and the proxies:</p>
<p><br>
<b>File</b> <a class="el" href="Surface_mesh_approximation_2vsa_approximation_2_example_8cpp-example.html">Surface_mesh_approximation/vsa_approximation_2_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_approximation/approximate_triangle_mesh.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/IO/polygon_mesh_io.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>   <a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Kernel::Point_3&gt;</a>                   Mesh;</div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::face_descriptor            face_descriptor;</div>
<div class="line"><span class="keyword">typedef</span> Mesh::Property_map&lt;face_descriptor, std::size_t&gt;      Face_proxy_pmap;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>VSA = CGAL::Surface_mesh_approximation;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : <a class="code hl_functionRef" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/bear.off"</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// read input surface triangle mesh</span></div>
<div class="line">  Mesh mesh;</div>
<div class="line">  <span class="keywordflow">if</span>(!<a class="code hl_functionRef" href="../Polygon_mesh_processing/group__PMP__IO__grp.html#gac5b3295bd1b6375628a46d1fbaf7e881">CGAL::Polygon_mesh_processing::IO::read_polygon_mesh</a>(filename, mesh) ||</div>
<div class="line">     !<a class="code hl_functionRef" href="../BGL/group__PkgBGLHelperFct.html#ga11883d231eec1b58f37efe4acedd9588">CGAL::is_triangle_mesh</a>(mesh))</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input file."</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// output indexed triangle mesh</span></div>
<div class="line">  std::vector&lt;Kernel::Point_3&gt; anchors;</div>
<div class="line">  std::vector&lt;std::array&lt;std::size_t, 3&gt; &gt; triangles; <span class="comment">// triplets of indices</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// output face proxy index property map</span></div>
<div class="line">  Face_proxy_pmap fpxmap =</div>
<div class="line">    mesh.add_property_map&lt;face_descriptor, std::size_t&gt;(<span class="stringliteral">"f:proxy_id"</span>, 0).first;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// output planar proxies</span></div>
<div class="line">  std::vector&lt;Kernel::Vector_3&gt; proxies;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// free function interface with named parameters</span></div>
<div class="line">  VSA::approximate_triangle_mesh(mesh,</div>
<div class="line">    CGAL::parameters::min_error_drop(0.05). <span class="comment">// seeding with minimum error drop</span></div>
<div class="line">                      number_of_iterations(40). <span class="comment">// set number of clustering iterations after seeding</span></div>
<div class="line">                      subdivision_ratio(0.3). <span class="comment">// set chord subdivision ratio threshold when meshing</span></div>
<div class="line">                      face_proxy_map(fpxmap). <span class="comment">// get face partition map</span></div>
<div class="line">                      proxies(std::back_inserter(proxies)). <span class="comment">// output proxies</span></div>
<div class="line">                      anchors(std::back_inserter(anchors)). <span class="comment">// output anchor points</span></div>
<div class="line">                      triangles(std::back_inserter(triangles))); <span class="comment">// output indexed triangles</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The face proxy index map and the output proxies provide a means to access the partition and the proxy parameters as illustrated by <a class="el" href="index.html#fig__iterations">Figure 80.3</a>.</p>
<h2><a class="anchor" id="sma_example2"></a>
Free Function Segmentation</h2>
<p>The free function can be used for retrieving the segmentation via proxy ids output into the proxy output iterator:</p>
<p><br>
<b>File</b> <a class="el" href="Surface_mesh_approximation_2vsa_segmentation_example_8cpp-example.html">Surface_mesh_approximation/vsa_segmentation_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh_approximation/approximate_triangle_mesh.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/IO/polygon_mesh_io.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> <a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Kernel::Point_3&gt;</a> Mesh;</div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::face_descriptor face_descriptor;</div>
<div class="line"><span class="keyword">typedef</span> Mesh::Property_map&lt;face_descriptor, std::size_t&gt; Face_proxy_pmap;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>VSA = CGAL::Surface_mesh_approximation;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : <a class="code hl_functionRef" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/bear.off"</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// reads input surface triangle mesh</span></div>
<div class="line">  Mesh mesh;</div>
<div class="line">  <span class="keywordflow">if</span>(!<a class="code hl_functionRef" href="../Polygon_mesh_processing/group__PMP__IO__grp.html#gac5b3295bd1b6375628a46d1fbaf7e881">CGAL::Polygon_mesh_processing::IO::read_polygon_mesh</a>(filename, mesh) ||</div>
<div class="line">     !<a class="code hl_functionRef" href="../BGL/group__PkgBGLHelperFct.html#ga11883d231eec1b58f37efe4acedd9588">CGAL::is_triangle_mesh</a>(mesh))</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input file."</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// face proxy index property map</span></div>
<div class="line">  Face_proxy_pmap fpxmap = mesh.add_property_map&lt;face_descriptor, std::size_t&gt;(<span class="stringliteral">"f:proxy_id"</span>, 0).first;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// free function interface with named parameters</span></div>
<div class="line">  VSA::approximate_triangle_mesh(mesh,</div>
<div class="line">                                 CGAL::parameters::max_number_of_proxies(200). <span class="comment">// first stop criterion</span></div>
<div class="line">                                                   min_error_drop(0.05). <span class="comment">// second stop criterion</span></div>
<div class="line">                                                   number_of_iterations(30). <span class="comment">// number of relaxation iterations after seeding</span></div>
<div class="line">                                                   face_proxy_map(fpxmap)); <span class="comment">// output face-proxy map</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// iterates over faces and outputs segment id to console</span></div>
<div class="line">  <span class="keywordflow">for</span>(face_descriptor f : faces(mesh))</div>
<div class="line">    std::cout &lt;&lt; fpxmap[f] &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="sma_example3"></a>
Class Interface</h2>
<p>The class interface <code><a class="el" href="classCGAL_1_1Variational__shape__approximation.html" title="Main class for Variational Shape Approximation algorithm.">CGAL::Variational_shape_approximation</a></code> offers a flexible means to control of the algorithm. The following example uses the <code><a class="el" href="classCGAL_1_1Surface__mesh__approximation_1_1L2__metric__plane__proxy.html" title="Approximation L2 metric of plane proxy.">CGAL::Surface_mesh_approximation::L2_metric_plane_proxy</a></code> to approximate the shape.</p>
<p><br>
<b>File</b> <a class="el" href="Surface_mesh_approximation_2vsa_class_interface_example_8cpp-example.html">Surface_mesh_approximation/vsa_class_interface_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Variational_shape_approximation.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/IO/polygon_mesh_io.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>VSA = CGAL::Surface_mesh_approximation;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> <a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Kernel::Point_3&gt;</a> Mesh;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> boost::property_map&lt;Mesh, boost::vertex_point_t&gt;::type Vertex_point_map;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classCGAL_1_1Variational__shape__approximation.html">CGAL::Variational_shape_approximation&lt;Mesh, Vertex_point_map&gt;</a> Mesh_approximation;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// L21 error metric</span></div>
<div class="line"><span class="keyword">typedef</span> Mesh_approximation::Error_metric L21_metric;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : <a class="code hl_functionRef" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/bear.off"</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// reads input surface triangle mesh</span></div>
<div class="line">  Mesh mesh;</div>
<div class="line">  <span class="keywordflow">if</span>(!<a class="code hl_functionRef" href="../Polygon_mesh_processing/group__PMP__IO__grp.html#gac5b3295bd1b6375628a46d1fbaf7e881">CGAL::Polygon_mesh_processing::IO::read_polygon_mesh</a>(filename, mesh) ||</div>
<div class="line">     !<a class="code hl_functionRef" href="../BGL/group__PkgBGLHelperFct.html#ga11883d231eec1b58f37efe4acedd9588">CGAL::is_triangle_mesh</a>(mesh))</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input file."</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  Vertex_point_map vpmap = get(boost::vertex_point, <span class="keyword">const_cast&lt;</span>Mesh &amp;<span class="keyword">&gt;</span>(mesh));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// error metric and fitting function</span></div>
<div class="line">  L21_metric error_metric(mesh, vpmap);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// creates VSA algorithm instance</span></div>
<div class="line">  Mesh_approximation approx(mesh, vpmap, error_metric);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// seeds 100 random proxies</span></div>
<div class="line">  approx.initialize_seeds(CGAL::parameters::seeding_method(VSA::RANDOM)</div>
<div class="line">      .max_number_of_proxies(100));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// runs 30 iterations</span></div>
<div class="line">  approx.run(30);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// adds 3 proxies to the one with the maximum fitting error,</span></div>
<div class="line">  <span class="comment">// running 5 iterations between each addition</span></div>
<div class="line">  approx.add_to_furthest_proxies(3, 5);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// runs 10 iterations</span></div>
<div class="line">  approx.run(10);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// teleports 2 proxies to tunnel out of local minima,</span></div>
<div class="line">  <span class="comment">// running 5 iterations between each teleport</span></div>
<div class="line">  approx.teleport_proxies(2, 5);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// runs 10 iterations</span></div>
<div class="line">  approx.run(10);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// extract approximated mesh with default parameters</span></div>
<div class="line">  approx.extract_mesh(<a class="code hl_functionRef" href="../STL_Extension/group__PkgSTLExtensionRef.html#gaac7f54fe7abb7321d8d755683eaafaf2">CGAL::parameters::default_values</a>());</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// get approximated triangle soup</span></div>
<div class="line">  std::vector&lt;Kernel::Point_3&gt; anchors;</div>
<div class="line">  std::vector&lt;std::array&lt;std::size_t, 3&gt; &gt; triangles;</div>
<div class="line">  approx.output(CGAL::parameters::anchors(std::back_inserter(anchors)).</div>
<div class="line">    triangles(std::back_inserter(triangles)));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="ttc" id="aclassCGAL_1_1Variational__shape__approximation_html"><div class="ttname"><a href="classCGAL_1_1Variational__shape__approximation.html">CGAL::Variational_shape_approximation</a></div><div class="ttdoc">Main class for Variational Shape Approximation algorithm.</div><div class="ttdef"><b>Definition:</b> Variational_shape_approximation.h:88</div></div>
<div class="ttc" id="agroup__PkgSTLExtensionRef_html_gaac7f54fe7abb7321d8d755683eaafaf2"><div class="ttname"><a href="../STL_Extension/group__PkgSTLExtensionRef.html#gaac7f54fe7abb7321d8d755683eaafaf2">CGAL::parameters::default_values</a></div><div class="ttdeci">Default_named_parameters default_values()</div></div>
</div><!-- fragment --><h2><a class="anchor" id="sma_example4"></a>
Customized Proxy and Error Metric</h2>
<p><a class="anchor" id="fig__vsa_metric_comparison"></a> </p><div class="image">
<img src="vsa_metric_comparison_200_30.jpg" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__vsa_metric_comparison">Figure 80.11</a> Comparison of different error metrics on the bear model, with 200 proxies and hierarchical seeding. From left to right: \( \mathcal{L}^{2,1} \) metric, \( \mathcal{L}^2 \) metric and custom compact metric. </p> </div> <p> <br>
</p>
<p>The following example defines a point-wise proxy to yield an isotropic approximation. The output mesh is depicted in <a class="el" href="index.html#fig__vsa_metric_comparison">Figure 80.11</a>.</p>
<p><br>
<b>File</b> <a class="el" href="Surface_mesh_approximation_2vsa_isotropic_metric_example_8cpp-example.html">Surface_mesh_approximation/vsa_isotropic_metric_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Variational_shape_approximation.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/IO/polygon_mesh_io.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> <a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div>
<div class="line"><span class="keyword">typedef</span> Kernel::FT FT;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector_3;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point_3;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point_3&gt;</a> Mesh;</div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::face_descriptor face_descriptor;</div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::halfedge_descriptor halfedge_descriptor;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> boost::property_map&lt;Mesh, boost::vertex_point_t&gt;::type Vertex_point_map;</div>
<div class="line"><span class="keyword">typedef</span> Mesh::Property_map&lt;face_descriptor, FT&gt; Face_area_map;</div>
<div class="line"><span class="keyword">typedef</span> Mesh::Property_map&lt;face_descriptor, Point_3&gt; Face_center_map;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>VSA = CGAL::Surface_mesh_approximation;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// user-defined "compact" error metric using type Point_3 as proxy</span></div>
<div class="line"><span class="keyword">struct </span>Compact_metric_point_proxy</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// use point as proxy</span></div>
<div class="line">  <span class="keyword">typedef</span> Point_3 Proxy;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// we keep a precomputed property map to speed up computations</span></div>
<div class="line">  Compact_metric_point_proxy(<span class="keyword">const</span> Face_center_map &amp;center_pmap_, <span class="keyword">const</span> Face_area_map &amp;area_pmap_)</div>
<div class="line">    : center_pmap(center_pmap_), area_pmap(area_pmap_)</div>
<div class="line">  { }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// compute and return error from a face to a proxy,</span></div>
<div class="line">  <span class="comment">// defined as the Euclidean distance between</span></div>
<div class="line">  <span class="comment">// the face center of mass and proxy point.</span></div>
<div class="line">  FT compute_error(<span class="keyword">const</span> face_descriptor &amp;f, <span class="keyword">const</span> Mesh &amp;, <span class="keyword">const</span> Proxy &amp;px)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_functionRef" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">CGAL::sqrt</a>(<a class="code hl_functionRef" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">CGAL::squared_distance</a>(center_pmap[f], px));</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// template functor to compute a best-fit</span></div>
<div class="line">  <span class="comment">// proxy from a range of faces</span></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> FaceRange&gt;</div>
<div class="line">  Proxy fit_proxy(<span class="keyword">const</span> FaceRange &amp;faces, <span class="keyword">const</span> Mesh &amp;)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="comment">// fitting center</span></div>
<div class="line">    Vector_3 center = <a class="code hl_variableRef" href="../Kernel_23/group__kernel__enums.html#ga4a98ec6bd9dfd8fe8c46fea553b5d238">CGAL::NULL_VECTOR</a>;</div>
<div class="line">    FT sum_areas = FT(0.0);</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">const</span> face_descriptor&amp; f : faces) {</div>
<div class="line">      center = center + (center_pmap[f] - <a class="code hl_variableRef" href="../Kernel_23/group__kernel__enums.html#ga9d272a8e3a8080b851741b6d3a44afdc">CGAL::ORIGIN</a>) * area_pmap[f];</div>
<div class="line">      sum_areas += area_pmap[f];</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// deal with case where sum = 0</span></div>
<div class="line">    <span class="keywordflow">if</span> (center == <a class="code hl_variableRef" href="../Kernel_23/group__kernel__enums.html#ga4a98ec6bd9dfd8fe8c46fea553b5d238">CGAL::NULL_VECTOR</a> || sum_areas &lt;= FT(0.0))</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">"Error: degenerate geometry."</span> &lt;&lt; std::endl;</div>
<div class="line">      std::exit(EXIT_FAILURE);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    center = center / sum_areas;</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_variableRef" href="../Kernel_23/group__kernel__enums.html#ga9d272a8e3a8080b851741b6d3a44afdc">CGAL::ORIGIN</a> + center;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> Face_center_map center_pmap;</div>
<div class="line">  <span class="keyword">const</span> Face_area_map area_pmap;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classCGAL_1_1Variational__shape__approximation.html">CGAL::Variational_shape_approximation</a>&lt;</div>
<div class="line">  Mesh, Vertex_point_map, Compact_metric_point_proxy&gt; Approximation;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : <a class="code hl_functionRef" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/bear.off"</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// reads input surface triangle mesh</span></div>
<div class="line">  Mesh mesh;</div>
<div class="line">  <span class="keywordflow">if</span>(!<a class="code hl_functionRef" href="../Polygon_mesh_processing/group__PMP__IO__grp.html#gac5b3295bd1b6375628a46d1fbaf7e881">CGAL::Polygon_mesh_processing::IO::read_polygon_mesh</a>(filename, mesh) ||</div>
<div class="line">     !<a class="code hl_functionRef" href="../BGL/group__PkgBGLHelperFct.html#ga11883d231eec1b58f37efe4acedd9588">CGAL::is_triangle_mesh</a>(mesh))</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input file."</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// constructs precomputed face normal and area map</span></div>
<div class="line">  Vertex_point_map vpmap = get(boost::vertex_point, <span class="keyword">const_cast&lt;</span>Mesh &amp;<span class="keyword">&gt;</span>(mesh));</div>
<div class="line">  Face_area_map area_pmap = mesh.add_property_map&lt;face_descriptor, FT&gt;(<span class="stringliteral">"f:area"</span>, FT(0.0)).first;</div>
<div class="line">  Face_center_map center_pmap = mesh.add_property_map&lt;face_descriptor, Point_3&gt;(<span class="stringliteral">"f:center"</span>, <a class="code hl_variableRef" href="../Kernel_23/group__kernel__enums.html#ga9d272a8e3a8080b851741b6d3a44afdc">CGAL::ORIGIN</a>).first;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span>(face_descriptor f : faces(mesh))</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">const</span> halfedge_descriptor he = halfedge(f, mesh);</div>
<div class="line">    <span class="keyword">const</span> Point_3 &amp;p0 = vpmap[source(he, mesh)];</div>
<div class="line">    <span class="keyword">const</span> Point_3 &amp;p1 = vpmap[target(he, mesh)];</div>
<div class="line">    <span class="keyword">const</span> Point_3 &amp;p2 = vpmap[target(next(he, mesh), mesh)];</div>
<div class="line">    put(area_pmap, f, <a class="code hl_functionRef" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">CGAL::sqrt</a>(<a class="code hl_functionRef" href="../Kernel_23/group__squared__area__grp.html#ga4a78403d9db87ffea0efec851fea117c">CGAL::squared_area</a>(p0, p1, p2)));</div>
<div class="line">    put(center_pmap, f, <a class="code hl_functionRef" href="../Kernel_23/group__centroid__grp.html#ga3ba0496a839f97ee6cd506baff51dfe4">CGAL::centroid</a>(p0, p1, p2));</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// error metric and fitting function</span></div>
<div class="line">  Compact_metric_point_proxy error_metric(center_pmap, area_pmap);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// creates compact metric approximation algorithm instance</span></div>
<div class="line">  Approximation approx(mesh, vpmap, error_metric);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// approximates via 200 proxies and 30 iterations</span></div>
<div class="line">  approx.initialize_seeds(CGAL::parameters::seeding_method(VSA::HIERARCHICAL)</div>
<div class="line">                                           .max_number_of_proxies(200));</div>
<div class="line">  approx.run(30);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="ttc" id="aclassKernel_1_1Point__3_html"><div class="ttname"><a href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a></div></div>
<div class="ttc" id="aclassKernel_1_1Vector__3_html"><div class="ttname"><a href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a></div></div>
<div class="ttc" id="agroup__PkgAlgebraicFoundationsRef_html_gab922269072ee9ee99ba8c541418b2e11"><div class="ttname"><a href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">CGAL::sqrt</a></div><div class="ttdeci">NT sqrt(const NT &amp;x)</div></div>
<div class="ttc" id="agroup__centroid__grp_html_ga3ba0496a839f97ee6cd506baff51dfe4"><div class="ttname"><a href="../Kernel_23/group__centroid__grp.html#ga3ba0496a839f97ee6cd506baff51dfe4">CGAL::centroid</a></div><div class="ttdeci">CGAL::Point_2&lt; Kernel &gt; centroid(const CGAL::Point_2&lt; Kernel &gt; &amp;p, const CGAL::Point_2&lt; Kernel &gt; &amp;q, const CGAL::Point_2&lt; Kernel &gt; &amp;r)</div></div>
<div class="ttc" id="agroup__kernel__enums_html_ga4a98ec6bd9dfd8fe8c46fea553b5d238"><div class="ttname"><a href="../Kernel_23/group__kernel__enums.html#ga4a98ec6bd9dfd8fe8c46fea553b5d238">CGAL::NULL_VECTOR</a></div><div class="ttdeci">const CGAL::Null_vector NULL_VECTOR</div></div>
<div class="ttc" id="agroup__kernel__enums_html_ga9d272a8e3a8080b851741b6d3a44afdc"><div class="ttname"><a href="../Kernel_23/group__kernel__enums.html#ga9d272a8e3a8080b851741b6d3a44afdc">CGAL::ORIGIN</a></div><div class="ttdeci">const CGAL::Origin ORIGIN</div></div>
<div class="ttc" id="agroup__squared__area__grp_html_ga4a78403d9db87ffea0efec851fea117c"><div class="ttname"><a href="../Kernel_23/group__squared__area__grp.html#ga4a78403d9db87ffea0efec851fea117c">CGAL::squared_area</a></div><div class="ttdeci">Kernel::FT squared_area(const CGAL::Point_3&lt; Kernel &gt; &amp;p, const CGAL::Point_3&lt; Kernel &gt; &amp;q, const CGAL::Point_3&lt; Kernel &gt; &amp;r)</div></div>
<div class="ttc" id="agroup__squared__distance__grp_html_ga1ff73525660a052564d33fbdd61a4f71"><div class="ttname"><a href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">CGAL::squared_distance</a></div><div class="ttdeci">Kernel::FT squared_distance(Type1&lt; Kernel &gt; obj1, Type2&lt; Kernel &gt; obj2)</div></div>
</div><!-- fragment --><h1><a class="anchor" id="sma_perf"></a>
Performances</h1>
<p>We provide some performance comparisons with the free function API <code><a class="el" href="group__PkgTSMARef.html#ga4bd463b1bad91654f253895861d37dbd" title="approximates the input mesh with plane proxies.">CGAL::Surface_mesh_approximation::approximate_triangle_mesh</a></code>. Timings are recorded on a PC running Windows10 X64 with an Intel Xeon E5-1620 clocked at 3.70 GHz with 32GB of RAM. The program has been optimized with the O2 option with Visual Studio 2015. By default the kernel used is <code><a class="elRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">Exact_predicates_inexact_constructions_kernel</a></code> (<code>EPICK</code>).</p>
<p>Runtime in seconds with target number of proxies of different seeding method:</p>
<center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">Model   </th><th class="markdownTableHeadRight">#Triangles   </th><th class="markdownTableHeadRight">#Proxies   </th><th class="markdownTableHeadRight">Random   </th><th class="markdownTableHeadRight">Incremental   </th><th class="markdownTableHeadRight">Hierarchical    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">plane-sphere   </td><td class="markdownTableBodyRight">6,826   </td><td class="markdownTableBodyRight">20   </td><td class="markdownTableBodyRight">0   </td><td class="markdownTableBodyRight">0.87   </td><td class="markdownTableBodyRight">0.17    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">bear   </td><td class="markdownTableBodyRight">20,188   </td><td class="markdownTableBodyRight">200   </td><td class="markdownTableBodyRight">0   </td><td class="markdownTableBodyRight">36.749   </td><td class="markdownTableBodyRight">1.194    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">masque   </td><td class="markdownTableBodyRight">62,467   </td><td class="markdownTableBodyRight">200   </td><td class="markdownTableBodyRight">0.002   </td><td class="markdownTableBodyRight">133.901   </td><td class="markdownTableBodyRight">4.308   </td></tr>
</table>
</center><p>Runtime in seconds with target error drop of different seeding method. The benchmark is running on the bear model with 20,188 faces. Each column records the time and the resulting number of proxies:</p>
<center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">Target Error Drop   </th><th class="markdownTableHeadRight">Random   </th><th class="markdownTableHeadRight">Incremental   </th><th class="markdownTableHeadRight">Hierarchical    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">0.06   </td><td class="markdownTableBodyRight">1.03/64   </td><td class="markdownTableBodyRight">9.053/53   </td><td class="markdownTableBodyRight">1.017/64    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">0.04   </td><td class="markdownTableBodyRight">1.207/128   </td><td class="markdownTableBodyRight">15.422/88   </td><td class="markdownTableBodyRight">1.2/128    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">0.02   </td><td class="markdownTableBodyRight">1.415/256   </td><td class="markdownTableBodyRight">35.171/192   </td><td class="markdownTableBodyRight">1.428/256   </td></tr>
</table>
</center><p>Runtime of the 3 phases of the algorithm in seconds: seeding, clustering iteration and meshing. The seeding method is hierarchical with target number of proxies.</p>
<center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">Model   </th><th class="markdownTableHeadRight">#Triangles   </th><th class="markdownTableHeadRight">#Proxies   </th><th class="markdownTableHeadRight">#Iterations   </th><th class="markdownTableHeadRight">Seeding   </th><th class="markdownTableHeadRight">Clustering   </th><th class="markdownTableHeadRight">Meshing   </th><th class="markdownTableHeadRight">Total    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">plane-sphere   </td><td class="markdownTableBodyRight">6,826   </td><td class="markdownTableBodyRight">20   </td><td class="markdownTableBodyRight">20   </td><td class="markdownTableBodyRight">0.17   </td><td class="markdownTableBodyRight">0.228   </td><td class="markdownTableBodyRight">0.044   </td><td class="markdownTableBodyRight">0.442    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">bear   </td><td class="markdownTableBodyRight">20,188   </td><td class="markdownTableBodyRight">200   </td><td class="markdownTableBodyRight">20   </td><td class="markdownTableBodyRight">1.194   </td><td class="markdownTableBodyRight">0.784   </td><td class="markdownTableBodyRight">0.128   </td><td class="markdownTableBodyRight">2.006    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">masque   </td><td class="markdownTableBodyRight">62,467   </td><td class="markdownTableBodyRight">200   </td><td class="markdownTableBodyRight">20   </td><td class="markdownTableBodyRight">4.308   </td><td class="markdownTableBodyRight">2.974   </td><td class="markdownTableBodyRight">0.349   </td><td class="markdownTableBodyRight">7.631   </td></tr>
</table>
</center><h1><a class="anchor" id="sma_background"></a>
Background</h1>
<p>The VSA method has two key geometric concepts:</p>
<ul>
<li><b>Proxy</b> \( P \). The parameterized best-fit surrogate of a piece of surface geometry.</li>
<li><b>Error metric</b> \( E \). To measure how well a proxy approximates the corresponding geometry.</li>
</ul>
<p>Given an error metric \( E \), a desired number of \( k \) proxies, and an input surface \( S \), we denote by <em>optimal shape proxies</em> a set \( P \) of proxies \( P_i \) associated to the regions \( R_i\) of a partition \( \mathcal{R} \) of \( S \) that minimizes the total fitting error <a class="el" href="citelist.html#CITEREF_cgal:cad-vsa-04">[1]</a> :</p>
<p class="formulaDsp">
\[ E(\mathcal{R}, P) = \sum_{i = 1..k} E(\mathcal{R}_i, P_i). \]
</p>
<p>By casting the approximation problem into an optimal discrete clustering one, the algorithm leverages the effective Lloyd algorithm <a class="el" href="citelist.html#CITEREF_cgal:cad-vsa-04">[1]</a> to drive the total error down iteratively. More specifically, during each iteration two different steps are conducted, for the \( m \)th iteration:</p><ul>
<li><b>Partition process</b>. Firstly, all triangle faces are partitioned into \( k \) connected regions \( \{ R^{m}_1, \cdots, R^{m}_k \} \) by assigning each face to its nearest proxy \( P^{m-1}_i \).</li>
<li><b>Fitting process</b>. Then, the algorithm fits a proxy and update the parameters \( P^{m}_i \) from the corresponding region \( R^{m}_i \).</li>
</ul>
<p>For a sequence of iterations with the fitting error \( \{ E^1, \cdots, E^m \} \), the iteration is repeated until one of the stopping criteria is met:</p><ul>
<li>The maximum number of iterations is reached: \( m &gt;= max\_iterations \).</li>
<li>No significant error change between two iterations: \( (E^{m-1} - E^{m}) / E^{m-1} &lt; converge\_threshold \).</li>
</ul>
<p>Intuitively, each region \( \mathcal{R}_i \) of a partition \( \mathcal{R} \) can be summarily represented to first order as an "average" point \( X_i \) and an "average" normal \( N_i \). We denote such local representative pair \( P_i = (X_i, N_i) \), a <em>planar proxy</em> of the associated region.</p>
<p>Defining an appropriate error metric is the key ingredient for the algorithm. The \( \mathcal{L}^2 \) metric is defined as: </p><p class="formulaDsp">
\[ \mathcal{L}^2(\mathcal{R}_i, P_i) = \iint_{x \in \mathcal{R}_i}\Vert x - \Pi_i(x)\Vert^2 dx. \]
</p>
<p> where \( \Pi_i(\cdot) \) denotes the orthogonal projection of the argument onto the proxy plane passing through \( X_i \) and normal to \( N_i \). The \( \mathcal{L}^2 \) metric tries to match the input shape through approximation of the geometric position.</p>
<p>In the original paper <a class="el" href="citelist.html#CITEREF_cgal:cad-vsa-04">[1]</a> the author proposed the \( \mathcal{L}^{2,1} \) metrics, arguing that the normals are important to the visual interpretation of the shape. The \( \mathcal{L}^{2,1} \) is defined as: </p><p class="formulaDsp">
\[ \mathcal{L}^{2,1}(\mathcal{R}_i, P_i) = \iint_{x \in \mathcal{R}_i}\Vert \mathbf{n}(x) - \mathbf{n}_i\Vert^2 dx. \]
</p>
<p>The \( \mathcal{L}^{2,1} \) is numerically superior to \( \mathcal{L}^2 \) in several ways:</p><ul>
<li>The anisotropy of the surface is better captured.</li>
<li>Finding the best normal proxy is as simple as averaging the normals.</li>
</ul>
<h1><a class="anchor" id="sma_history"></a>
Design and Implementation History</h1>
<p>This package is the result of the work of Lingjie Zhu during the 2017 season of the Google Summer of Code, mentored by Pierre Alliez. The code is based on an initial research code written by Pierre Alliez at Inria in 2003, for a paper published at the ACM SIGGRAPH conference in 2004, co-authored by David Cohen-Steiner, Pierre Alliez and Mathieu Desbrun <a class="el" href="citelist.html#CITEREF_cgal:cad-vsa-04">[1]</a>. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"></a> 1.9.6 </li>
  </ul>
</div>
</div>
</body>


</html>
