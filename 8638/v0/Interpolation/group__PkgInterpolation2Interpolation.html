<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Interpolation/group__PkgInterpolation2Interpolation.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=11">
<meta name="generator" content="Doxygen 1.9.6">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CGAL 6.2 - 2D and Surface Function Interpolation: Interpolation Functions</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/doxygen.css" rel="stylesheet" type="text/css">
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      },
      equationNumbers: { autoNumber: "AMS" }
  }
}
);
MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
  var PARSE = MathJax.InputJax.TeX.Parse,
      TEXT = PARSE.prototype.InternalText;
  PARSE.Augment({
    InternalText: function (text,def) {
      text = text.replace(/\\/g,"");
      return TEXT.call(this,text,def);
    }
  });
});
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
      <span class="left">
         <span id="MSearchSelect" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"> 
        </span>
        <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
      </span>
      <span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.svg" alt=""></a>
      </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CGAL 6.2 - 2D and Surface Function Interpolation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search/",'.html');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__PkgInterpolation2Interpolation.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> |
<a href="#nested-classes">Classes</a> |
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Interpolation Functions<div class="ingroups"><a class="el" href="group__PkgInterpolation2Ref.html">Reference Manual</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader"> </h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__PkgInterpolationSibsonGradientFitting"><td class="memItemLeft" align="right" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="group__PkgInterpolationSibsonGradientFitting.html">Sibson Gradient Fitting Functions</a></td></tr>
<tr class="memdesc:group__PkgInterpolationSibsonGradientFitting"><td class="mdescLeft"> </td><td class="mdescRight">The first function implements Sibson's gradient estimation method based on natural neighbor coordinates <a class="el" href="citelist.html#CITEREF_s-bdnni-81">[9]</a>. <br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Interpolation__gradient__fitting__traits__2.html">CGAL::Interpolation_gradient_fitting_traits_2&lt; K &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight"><code><a class="el" href="classCGAL_1_1Interpolation__gradient__fitting__traits__2.html" title="Interpolation_gradient_fitting_traits_2 is a model for the concepts InterpolationTraits and GradientF...">Interpolation_gradient_fitting_traits_2</a></code> is a model for the concepts <code><a class="el" href="classInterpolationTraits.html" title="Most interpolation functions are parameterized by a traits class that defines the primitives used in ...">InterpolationTraits</a></code> and <code><a class="el" href="classGradientFittingTraits.html" title="Sibson Gradient Fitting Functions are parameterized by a traits class that defines the primitives use...">GradientFittingTraits</a></code>.  <a href="classCGAL_1_1Interpolation__gradient__fitting__traits__2.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Interpolation__traits__2.html">CGAL::Interpolation_traits_2&lt; K &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight"><code><a class="el" href="classCGAL_1_1Interpolation__traits__2.html" title="Interpolation_traits_2 is a model for the concept InterpolationTraits and can be used to instantiate ...">Interpolation_traits_2</a></code> is a model for the concept <code><a class="el" href="classInterpolationTraits.html" title="Most interpolation functions are parameterized by a traits class that defines the primitives used in ...">InterpolationTraits</a></code> and can be used to instantiate the geometric traits class of interpolation methods applied on a bivariate function over a two-dimensional domain.  <a href="classCGAL_1_1Interpolation__traits__2.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2f8a2f88b5b91b9f3db2d5e40bfa1df7"><td class="memTemplParams" colspan="2">template&lt;class CoordinateInputIterator , class ValueFunctor &gt; </td></tr>
<tr class="memitem:ga2f8a2f88b5b91b9f3db2d5e40bfa1df7"><td class="memTemplItemLeft" align="right" valign="top">ValueFunctor::result_type::first_type </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgInterpolation2Interpolation.html#ga2f8a2f88b5b91b9f3db2d5e40bfa1df7">CGAL::linear_interpolation</a> (CoordinateInputIterator first, CoordinateInputIterator beyond, const typename std::iterator_traits&lt; CoordinateInputIterator &gt;::value_type::second_type &amp;norm, ValueFunctor value_function)</td></tr>
<tr class="memdesc:ga2f8a2f88b5b91b9f3db2d5e40bfa1df7"><td class="mdescLeft"> </td><td class="mdescRight">The function <code><a class="el" href="group__PkgInterpolation2Interpolation.html#ga2f8a2f88b5b91b9f3db2d5e40bfa1df7" title="The function linear_interpolation() computes the weighted sum of the function values which must be pr...">linear_interpolation()</a></code> computes the weighted sum of the function values which must be provided via a functor.  <br></td></tr>
<tr class="separator:ga2f8a2f88b5b91b9f3db2d5e40bfa1df7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga50aa68e988b099a99533f26872c639f5"><td class="memTemplParams" colspan="2">template&lt;class CoordinateInputIterator , class ValueFunctor , class GradFunctor , class Traits , class Point &gt; </td></tr>
<tr class="memitem:ga50aa68e988b099a99533f26872c639f5"><td class="memTemplItemLeft" align="right" valign="top">ValueFunctor::result_type </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgInterpolation2Interpolation.html#ga50aa68e988b099a99533f26872c639f5">CGAL::quadratic_interpolation</a> (CoordinateInputIterator first, CoordinateInputIterator beyond, const typename std::iterator_traits&lt; CoordinateInputIterator &gt;::value_type::second_type &amp;norm, const Point &amp;p, ValueFunctor value_function, GradFunctor gradient_function, const Traits &amp;traits)</td></tr>
<tr class="memdesc:ga50aa68e988b099a99533f26872c639f5"><td class="mdescLeft"> </td><td class="mdescRight">The function <code><a class="el" href="group__PkgInterpolation2Interpolation.html#ga50aa68e988b099a99533f26872c639f5" title="The function quadratic_interpolation() generates the interpolated function value as the weighted sum ...">quadratic_interpolation()</a></code> generates the interpolated function value as the weighted sum of the values plus a linear term in the gradient for each entity of the entity/coordinate pairs in the range <code>[first, beyond)</code>.  <br></td></tr>
<tr class="separator:ga50aa68e988b099a99533f26872c639f5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga79d301865904d46b1fd247594a07db55"><td class="memTemplParams" colspan="2">template&lt;class CoordinateInputIterator , class ValueFunctor , class GradFunctor , class Traits , class Point &gt; </td></tr>
<tr class="memitem:ga79d301865904d46b1fd247594a07db55"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename ValueFunctor::result_type, bool &gt; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgInterpolation2Interpolation.html#ga79d301865904d46b1fd247594a07db55">CGAL::sibson_c1_interpolation</a> (CoordinateInputIterator first, CoordinateInputIterator beyond, const typename std::iterator_traits&lt; CoordinateInputIterator &gt;::value_type::second_type &amp;norm, const Point &amp;p, ValueFunctor value_function, GradFunctor gradient_function, const Traits &amp;traits)</td></tr>
<tr class="memdesc:ga79d301865904d46b1fd247594a07db55"><td class="mdescLeft"> </td><td class="mdescRight">The function <code><a class="el" href="group__PkgInterpolation2Interpolation.html#ga79d301865904d46b1fd247594a07db55" title="The function sibson_c1_interpolation() generates the interpolated function value at the point p,...">sibson_c1_interpolation()</a></code> generates the interpolated function value at the point <code>p</code>, using functors for the function values and the gradients, by applying Sibson's \( Z^1\) interpolant.  <br></td></tr>
<tr class="separator:ga79d301865904d46b1fd247594a07db55"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga1f84e03a02a6602d45c26f600a6d225b"><td class="memTemplParams" colspan="2">template&lt;class CoordinateInputIterator , class ValueFunctor , class GradFunctor , class Traits , class Point &gt; </td></tr>
<tr class="memitem:ga1f84e03a02a6602d45c26f600a6d225b"><td class="memTemplItemLeft" align="right" valign="top">ValueFunctor::result_type </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgInterpolation2Interpolation.html#ga1f84e03a02a6602d45c26f600a6d225b">CGAL::sibson_c1_interpolation_square</a> (CoordinateInputIterator first, CoordinateInputIterator beyond, const typename std::iterator_traits&lt; CoordinateInputIterator &gt;::value_type::second_type &amp;norm, const Point &amp;p, ValueFunctor value_function, GradFunctor gradient_function, const Traits &amp;traits)</td></tr>
<tr class="memdesc:ga1f84e03a02a6602d45c26f600a6d225b"><td class="mdescLeft"> </td><td class="mdescRight">Same as <code><a class="el" href="group__PkgInterpolation2Interpolation.html#ga79d301865904d46b1fd247594a07db55" title="The function sibson_c1_interpolation() generates the interpolated function value at the point p,...">sibson_c1_interpolation()</a></code>, except that no square root operation is required for the number type <code>Traits::FT</code>.  <br></td></tr>
<tr class="separator:ga1f84e03a02a6602d45c26f600a6d225b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga40856de51734ae1b1882cb46e8195c93"><td class="memTemplParams" colspan="2">template&lt;class CoordinateInputIterator , class ValueFunctor , class GradFunctor , class Traits , class Point &gt; </td></tr>
<tr class="memitem:ga40856de51734ae1b1882cb46e8195c93"><td class="memTemplItemLeft" align="right" valign="top">ValueFunctor::result_type </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgInterpolation2Interpolation.html#ga40856de51734ae1b1882cb46e8195c93">CGAL::farin_c1_interpolation</a> (CoordinateInputIterator first, CoordinateInputIterator beyond, const typename std::iterator_traits&lt; CoordinateInputIterator &gt;::value_type::second_type &amp;norm, const Point &amp;p, ValueFunctor value_function, GradFunctor gradient_function, const Traits &amp;traits)</td></tr>
<tr class="memdesc:ga40856de51734ae1b1882cb46e8195c93"><td class="mdescLeft"> </td><td class="mdescRight">Generates the interpolated function value computed by Farin's interpolant.  <br></td></tr>
<tr class="separator:ga40856de51734ae1b1882cb46e8195c93"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga40856de51734ae1b1882cb46e8195c93" name="ga40856de51734ae1b1882cb46e8195c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40856de51734ae1b1882cb46e8195c93">◆ </a></span>farin_c1_interpolation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CoordinateInputIterator , class ValueFunctor , class GradFunctor , class Traits , class Point &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ValueFunctor::result_type CGAL::farin_c1_interpolation </td>
          <td>(</td>
          <td class="paramtype">CoordinateInputIterator </td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoordinateInputIterator </td>
          <td class="paramname"><em>beyond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename std::iterator_traits&lt; CoordinateInputIterator &gt;::value_type::second_type &amp; </td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point &amp; </td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueFunctor </td>
          <td class="paramname"><em>value_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GradFunctor </td>
          <td class="paramname"><em>gradient_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Traits &amp; </td>
          <td class="paramname"><em>traits</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/interpolation_functions.h&gt;</code></p>

<p>Generates the interpolated function value computed by Farin's interpolant. </p>
<p><b>Requirements</b><br>
</p>
<p>Same requirements as the function <code><a class="el" href="group__PkgInterpolation2Interpolation.html#ga79d301865904d46b1fd247594a07db55" title="The function sibson_c1_interpolation() generates the interpolated function value at the point p,...">sibson_c1_interpolation()</a></code>, but the input iterator must provide random access (be a model of <code><a class="elRef" href="../Manual/classRandomAccessIterator.html">RandomAccessIterator</a></code>) and <code>Traits::FT</code> does not need to provide the square root operation.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The range <code>[first, beyond)</code> contains either one or more than three elements. The function <code><a class="el" href="group__PkgInterpolation2Interpolation.html#ga40856de51734ae1b1882cb46e8195c93" title="Generates the interpolated function value computed by Farin's interpolant.">farin_c1_interpolation()</a></code> interpolates the function values and the gradients that are provided by functors using the method described in <a class="el" href="citelist.html#CITEREF_f-sodt-90">[4]</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__PkgInterpolation2Interpolation.html#ga79d301865904d46b1fd247594a07db55" title="The function sibson_c1_interpolation() generates the interpolated function value at the point p,...">CGAL::sibson_c1_interpolation()</a></code> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Interpolation_2interpolation_2_8cpp-example.html#a6">Interpolation/interpolation_2.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga2f8a2f88b5b91b9f3db2d5e40bfa1df7" name="ga2f8a2f88b5b91b9f3db2d5e40bfa1df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f8a2f88b5b91b9f3db2d5e40bfa1df7">◆ </a></span>linear_interpolation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CoordinateInputIterator , class ValueFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ValueFunctor::result_type::first_type CGAL::linear_interpolation </td>
          <td>(</td>
          <td class="paramtype">CoordinateInputIterator </td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoordinateInputIterator </td>
          <td class="paramname"><em>beyond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename std::iterator_traits&lt; CoordinateInputIterator &gt;::value_type::second_type &amp; </td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueFunctor </td>
          <td class="paramname"><em>value_function</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/interpolation_functions.h&gt;</code></p>

<p>The function <code><a class="el" href="group__PkgInterpolation2Interpolation.html#ga2f8a2f88b5b91b9f3db2d5e40bfa1df7" title="The function linear_interpolation() computes the weighted sum of the function values which must be pr...">linear_interpolation()</a></code> computes the weighted sum of the function values which must be provided via a functor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CoordinateInputIterator</td><td>must be a model of <code><a class="elRef" href="../Manual/classForwardIterator.html">ForwardIterator</a></code> and must have as value type a pair associating an entity, e.g. the <code>Vertex_handle</code> or <code>Point</code> types of a triangulation, to a (non-normalized) barycentric coordinate. </td></tr>
    <tr><td class="paramname">ValueFunctor</td><td>must be a functor where <code>ValueFunctor::argument_type</code> must be equivalent to <code>std::iterator_traits&lt;CoordinateInputIterator&gt;::value_type::first_type</code> and <code>ValueFunctor::result_type</code> is a pair of the function value type and a Boolean. The function value type <code>VT</code> must provide an addition operator, and a multiplication operator with the type <code>Traits::FT</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>A model of the functor <code>ValueFunctor</code> is provided by the struct <code><a class="el" href="structCGAL_1_1Data__access.html" title="The struct Data_access implements a functor that allows to retrieve data from an associative containe...">CGAL::Data_access</a></code> instantiated with an associative container (e.g. <code>std::map</code>) and having:</p><ul>
<li><code>std::iterator_traits&lt;CoordinateInputIterator&gt;::value_type::first_type</code> (the entity type) as <code>key_type</code></li>
<li><code>std::iterator_traits&lt;CoordinateInputIterator&gt;::value_type::second_type</code> (the coordinate type) as <code>mapped_type</code>.</li>
</ul>
<p>The two template parameters must satisfy the following conditions:</p><ul>
<li><code>std::iterator_traits&lt;CoordinateInputIterator&gt;::value_type::first_type</code> (the entity type) is equivalent to a <code>ValueFunctor::argument_type</code>.</li>
<li><code>std::iterator_traits&lt;CoordinateInputIterator&gt;::value_type::second_type</code> (the coordinate type) is a field number type that is equivalent to <code>ValueFunctor::result_type::first_type</code>.</li>
</ul>
<p>For example, if <code>CoordinateInputIterator</code> is an iterator with value type <code>std::pair&lt;Vertex_handle, double&gt;</code>, then the <code>ValueFunctor</code> must have argument type <code>Vertex_handle</code> (or convertible to) and return type <code>std::pair&lt;double, bool&gt;</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first,beyond</td><td>is the iterator range for the coordinates. </td></tr>
    <tr><td class="paramname">norm</td><td>is the normalization factor. </td></tr>
    <tr><td class="paramname">value_function</td><td>is a functor of type <code>ValueFunctor</code> that allows to access a pair of a function value and a Boolean at a given entity. The Boolean indicates whether the function value could be retrieved correctly. This function generates the interpolated function value as the weighted sum of the values corresponding to each entry of the entity/coordinate pairs in the range <code>[first, beyond)</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>norm</code> \( \neq0\). </dd>
<dd>
<code>first != beyond</code>. </dd>
<dd>
<code>value_function(p.first).second == true</code> for all pairs <code>p</code> in the range <code>[first, beyond)</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__PkgInterpolation2Interpolation.html#ga50aa68e988b099a99533f26872c639f5" title="The function quadratic_interpolation() generates the interpolated function value as the weighted sum ...">CGAL::quadratic_interpolation()</a></code> </dd>
<dd>
<code><a class="el" href="group__PkgInterpolationNaturalNeighborCoordinates2.html" title="The functions natural_neighbor_coordinates_2() compute natural neighbor coordinates,...">CGAL::natural_neighbor_coordinates_2()</a></code> </dd>
<dd>
<code><a class="el" href="group__PkgInterpolationRegularNeighborCoordinates2.html" title="The functions regular_neighbor_coordinates_2() compute natural neighbor coordinates,...">CGAL::regular_neighbor_coordinates_2()</a></code> </dd>
<dd>
<code><a class="el" href="group__PkgInterpolationSurfaceNeighborCoordinates3.html" title="The functions surface_neighbor_coordinates_3() compute natural neighbor coordinates for surface point...">3D Surface Neighbor Coordinates Functions</a></code> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Interpolation_2interpolation_2_8cpp-example.html#a4">Interpolation/interpolation_2.cpp</a>, <a class="el" href="Interpolation_2linear_interpolation_2_8cpp-example.html#a5">Interpolation/linear_interpolation_2.cpp</a>, and <a class="el" href="Interpolation_2linear_interpolation_of_vector_3_8cpp-example.html#a5">Interpolation/linear_interpolation_of_vector_3.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga50aa68e988b099a99533f26872c639f5" name="ga50aa68e988b099a99533f26872c639f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50aa68e988b099a99533f26872c639f5">◆ </a></span>quadratic_interpolation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CoordinateInputIterator , class ValueFunctor , class GradFunctor , class Traits , class Point &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ValueFunctor::result_type CGAL::quadratic_interpolation </td>
          <td>(</td>
          <td class="paramtype">CoordinateInputIterator </td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoordinateInputIterator </td>
          <td class="paramname"><em>beyond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename std::iterator_traits&lt; CoordinateInputIterator &gt;::value_type::second_type &amp; </td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point &amp; </td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueFunctor </td>
          <td class="paramname"><em>value_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GradFunctor </td>
          <td class="paramname"><em>gradient_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Traits &amp; </td>
          <td class="paramname"><em>traits</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/interpolation_functions.h&gt;</code></p>

<p>The function <code><a class="el" href="group__PkgInterpolation2Interpolation.html#ga50aa68e988b099a99533f26872c639f5" title="The function quadratic_interpolation() generates the interpolated function value as the weighted sum ...">quadratic_interpolation()</a></code> generates the interpolated function value as the weighted sum of the values plus a linear term in the gradient for each entity of the entity/coordinate pairs in the range <code>[first, beyond)</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>If the interpolation was successful, the pair contains the interpolated function value as first and <code>true</code> as second value. Otherwise, the second value will be <code>false</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Traits</td><td>must be a model of <code><a class="el" href="classInterpolationTraits.html" title="Most interpolation functions are parameterized by a traits class that defines the primitives used in ...">InterpolationTraits</a></code>. Note that, contrary to some other interpolation methods, the number type <code>FT</code> provided by <code>Traits</code> does not need to provide the square root operation. </td></tr>
    <tr><td class="paramname">CoordinateInputIterator</td><td>must be a model of <code><a class="elRef" href="../Manual/classForwardIterator.html">ForwardIterator</a></code> and must have as value type a pair associating an entity to a (non-normalized) barycentric coordinate. More precisely, <code>std::iterator_traits&lt;CoordinateInputIterator&gt;::value_type::first_type</code> can be of the following types: <ul>
<li>
a type equivalent to <code>Traits::Point_d</code> or <code>Traits::Weighted_point_d</code>  </li>
<li>
an iterator type providing a <code>point()</code> function returning a type equivalent to <code>Traits::Point_d</code> or <code>Traits::Weighted_point_d</code>;  </li>
</ul>
and <code>std::iterator_traits&lt;CoordinateInputIterator&gt;::value_type::second_type</code> must be equivalent to <code>Traits::FT</code>. </td></tr>
    <tr><td class="paramname">ValueFunctor</td><td>must be a functor where <code>ValueFunctor::argument_type</code> must be equivalent to <code>std::iterator_traits&lt;CoordinateInputIterator&gt;::value_type::first_type</code> and <code>ValueFunctor::result_type</code> is a pair of the function value type and a Boolean. The function value type must provide a multiplication and addition operation with the type <code>Traits::FT</code> as well as a constructor with argument <code>0</code>. </td></tr>
    <tr><td class="paramname">GradFunctor</td><td>must be a functor where <code>GradFunctor::argument_type</code> must be equivalent to <code>std::iterator_traits&lt;CoordinateInputIterator&gt;::value_type::first_type</code> and <code>Functor::result_type</code> is a pair of the function's gradient type and a Boolean. The function gradient type must provide a multiplication operation with <code>Traits::Vector_d</code>. </td></tr>
    <tr><td class="paramname">Point</td><td>must be equivalent to <code>Traits::Point_d</code> or <code>Traits::Weighted_point_d</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>A model of the functor types <code>ValueFunctor</code> (resp. <code>GradFunctor</code>) is provided by the struct <code><a class="el" href="structCGAL_1_1Data__access.html" title="The struct Data_access implements a functor that allows to retrieve data from an associative containe...">CGAL::Data_access</a></code>. It must be instantiated accordingly with an associative container (e.g. <code>std::map</code>) having <code>std::iterator_traits&lt;CoordinateInputIterator&gt;::value_type::first_type</code> as <code>key_type</code> and the function value type (resp. the function gradient type) as <code>mapped_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first,beyond</td><td>is the iterator range of the barycentric coordinates for the query point <code>p</code>. </td></tr>
    <tr><td class="paramname">norm</td><td>is the normalization factor. </td></tr>
    <tr><td class="paramname">p</td><td>is the point at which the interpolated function value is computed. </td></tr>
    <tr><td class="paramname">value_function</td><td>is a functor that allows to access values of the interpolated function. </td></tr>
    <tr><td class="paramname">gradient_function</td><td>is a functor that allows to access the function gradients. If the functor <code>gradient_function</code> cannot supply the gradient of a point, the function returns a pair where the Boolean is set to <code>false</code>. </td></tr>
    <tr><td class="paramname">traits</td><td>is an instance of the traits class.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>norm</code> \( \neq0\). </dd>
<dd>
<code>first != beyond</code>. </dd>
<dd>
<code>value_function(p.first).second == true</code> for pairs <code>p</code> in the range <code>[first, beyond)</code></dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__PkgInterpolation2Interpolation.html#ga2f8a2f88b5b91b9f3db2d5e40bfa1df7" title="The function linear_interpolation() computes the weighted sum of the function values which must be pr...">CGAL::linear_interpolation()</a></code> </dd>
<dd>
<code><a class="el" href="classCGAL_1_1Interpolation__traits__2.html" title="Interpolation_traits_2 is a model for the concept InterpolationTraits and can be used to instantiate ...">CGAL::Interpolation_traits_2</a>&lt;K&gt;</code> </dd>
<dd>
<code><a class="el" href="group__PkgInterpolationNaturalNeighborCoordinates2.html" title="The functions natural_neighbor_coordinates_2() compute natural neighbor coordinates,...">CGAL::natural_neighbor_coordinates_2()</a></code> </dd>
<dd>
<code><a class="el" href="group__PkgInterpolationRegularNeighborCoordinates2.html" title="The functions regular_neighbor_coordinates_2() compute natural neighbor coordinates,...">CGAL::regular_neighbor_coordinates_2()</a></code> </dd>
<dd>
<code><a class="el" href="group__PkgInterpolationSurfaceNeighborCoordinates3.html" title="The functions surface_neighbor_coordinates_3() compute natural neighbor coordinates for surface point...">3D Surface Neighbor Coordinates Functions</a></code> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Interpolation_2interpolation_2_8cpp-example.html#a7">Interpolation/interpolation_2.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga79d301865904d46b1fd247594a07db55" name="ga79d301865904d46b1fd247594a07db55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79d301865904d46b1fd247594a07db55">◆ </a></span>sibson_c1_interpolation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CoordinateInputIterator , class ValueFunctor , class GradFunctor , class Traits , class Point &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename ValueFunctor::result_type, bool &gt; CGAL::sibson_c1_interpolation </td>
          <td>(</td>
          <td class="paramtype">CoordinateInputIterator </td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoordinateInputIterator </td>
          <td class="paramname"><em>beyond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename std::iterator_traits&lt; CoordinateInputIterator &gt;::value_type::second_type &amp; </td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point &amp; </td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueFunctor </td>
          <td class="paramname"><em>value_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GradFunctor </td>
          <td class="paramname"><em>gradient_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Traits &amp; </td>
          <td class="paramname"><em>traits</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/interpolation_functions.h&gt;</code></p>

<p>The function <code><a class="el" href="group__PkgInterpolation2Interpolation.html#ga79d301865904d46b1fd247594a07db55" title="The function sibson_c1_interpolation() generates the interpolated function value at the point p,...">sibson_c1_interpolation()</a></code> generates the interpolated function value at the point <code>p</code>, using functors for the function values and the gradients, by applying Sibson's \( Z^1\) interpolant. </p>
<dl class="section return"><dt>Returns</dt><dd>If the interpolation was successful, the pair contains the interpolated function value as first and <code>true</code> as second value. Otherwise, <code>false</code> is returned as second value.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Traits</td><td>must be a model of <code><a class="el" href="classInterpolationTraits.html" title="Most interpolation functions are parameterized by a traits class that defines the primitives used in ...">InterpolationTraits</a></code>. The number type <code>FT</code> provided by <code>Traits</code> must support the square root operation <code><a class="elRef" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">sqrt()</a></code>. </td></tr>
    <tr><td class="paramname">CoordinateInputIterator</td><td>must be a model of <code><a class="elRef" href="../Manual/classForwardIterator.html">ForwardIterator</a></code> and must have as value type a pair associating an entity to a (non-normalized) barycentric coordinate. More precisely, <code>std::iterator_traits&lt;CoordinateInputIterator&gt;::value_type::first_type</code> can be of the following types: <ul>
<li>
a type equivalent to <code>Traits::Point_d</code> or <code>Traits::Weighted_point_d</code>  </li>
<li>
an iterator type providing a <code>point()</code> function returning a type equivalent to <code>Traits::Point_d</code> or <code>Traits::Weighted_point_d</code>;  </li>
</ul>
and <code>std::iterator_traits&lt;CoordinateInputIterator&gt;::value_type::second_type</code> must be equivalent to <code>Traits::FT</code>. </td></tr>
    <tr><td class="paramname">ValueFunctor</td><td>must be a functor where <code>ValueFunctor::argument_type</code> must be equivalent to <code>std::iterator_traits&lt;CoordinateInputIterator&gt;::value_type::first_type</code> and <code>ValueFunctor::result_type</code> is a pair of the function value type and a Boolean. The function value type must provide a multiplication and addition operation with the type <code>Traits::FT</code> as well as a constructor with argument <code>0</code>. </td></tr>
    <tr><td class="paramname">GradFunctor</td><td>must be a functor where <code>GradFunctor::argument_type</code> must be equivalent to <code>std::iterator_traits&lt;CoordinatetCoordinateInputIteratorIterator&gt;::value_type::first_type</code> and <code>Functor::result_type</code> is a pair of the function's gradient type and a Boolean. The function gradient type must provide a multiplication operation with <code>Traits::Vector_d</code>. </td></tr>
    <tr><td class="paramname">Point</td><td>must be equivalent to <code>Traits::Point_d</code> or <code>Traits::Weighted_point_d</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>A model of the functor types <code>ValueFunctor</code> (resp. <code>GradFunctor</code>) is provided by the struct <code><a class="el" href="structCGAL_1_1Data__access.html" title="The struct Data_access implements a functor that allows to retrieve data from an associative containe...">CGAL::Data_access</a></code>. It must be instantiated accordingly with an associative container (e.g. <code>std::map</code>) having <code>std::iterator_traits&lt;CoordinateInputIterator&gt;::value_type::first_type</code> as <code>key_type</code> and the function value type (resp. the function gradient type) as <code>mapped_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first,beyond</td><td>is the iterator range of the barycentric coordinates for the query point <code>p</code>. </td></tr>
    <tr><td class="paramname">norm</td><td>is the normalization factor. </td></tr>
    <tr><td class="paramname">p</td><td>is the point at which the interpolated function value is computed. </td></tr>
    <tr><td class="paramname">value_function</td><td>is a functor that allows to access values of the interpolated function. </td></tr>
    <tr><td class="paramname">gradient_function</td><td>is a functor that allows to access the function gradients. If the functor <code>gradient_function</code> cannot supply the gradient of a point, the function returns a pair where the Boolean is set to <code>false</code>. </td></tr>
    <tr><td class="paramname">traits</td><td>is an instance of the traits class.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>norm</code> \( \neq0\). </dd>
<dd>
<code>first != beyond</code>. </dd>
<dd>
<code>value_function(q).second == true</code> for all points <code>q</code> of the point/coordinate pairs in the range <code>[first, beyond)</code></dd></dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classCGAL_1_1Interpolation__traits__2.html" title="Interpolation_traits_2 is a model for the concept InterpolationTraits and can be used to instantiate ...">CGAL::Interpolation_traits_2</a>&lt;K&gt;</code> </dd>
<dd>
<code><a class="el" href="group__PkgInterpolation2Interpolation.html#ga1f84e03a02a6602d45c26f600a6d225b" title="Same as sibson_c1_interpolation(), except that no square root operation is required for the number ty...">CGAL::sibson_c1_interpolation_square()</a></code> </dd>
<dd>
<code><a class="el" href="group__PkgInterpolationNaturalNeighborCoordinates2.html" title="The functions natural_neighbor_coordinates_2() compute natural neighbor coordinates,...">CGAL::natural_neighbor_coordinates_2()</a></code> </dd>
<dd>
<code><a class="el" href="group__PkgInterpolationRegularNeighborCoordinates2.html" title="The functions regular_neighbor_coordinates_2() compute natural neighbor coordinates,...">CGAL::regular_neighbor_coordinates_2()</a></code> </dd>
<dd>
<a class="el" href="group__PkgInterpolationSurfaceNeighborCoordinates3.html" title="The functions surface_neighbor_coordinates_3() compute natural neighbor coordinates for surface point...">3D Surface Neighbor Coordinates Functions</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Interpolation_2interpolation_2_8cpp-example.html#a9">Interpolation/interpolation_2.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga1f84e03a02a6602d45c26f600a6d225b" name="ga1f84e03a02a6602d45c26f600a6d225b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f84e03a02a6602d45c26f600a6d225b">◆ </a></span>sibson_c1_interpolation_square()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CoordinateInputIterator , class ValueFunctor , class GradFunctor , class Traits , class Point &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ValueFunctor::result_type CGAL::sibson_c1_interpolation_square </td>
          <td>(</td>
          <td class="paramtype">CoordinateInputIterator </td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoordinateInputIterator </td>
          <td class="paramname"><em>beyond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename std::iterator_traits&lt; CoordinateInputIterator &gt;::value_type::second_type &amp; </td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point &amp; </td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueFunctor </td>
          <td class="paramname"><em>value_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GradFunctor </td>
          <td class="paramname"><em>gradient_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Traits &amp; </td>
          <td class="paramname"><em>traits</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/interpolation_functions.h&gt;</code></p>

<p>Same as <code><a class="el" href="group__PkgInterpolation2Interpolation.html#ga79d301865904d46b1fd247594a07db55" title="The function sibson_c1_interpolation() generates the interpolated function value at the point p,...">sibson_c1_interpolation()</a></code>, except that no square root operation is required for the number type <code>Traits::FT</code>. </p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="group__PkgInterpolation2Interpolation.html#ga79d301865904d46b1fd247594a07db55" title="The function sibson_c1_interpolation() generates the interpolated function value at the point p,...">CGAL::sibson_c1_interpolation()</a></code> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Interpolation_2interpolation_2_8cpp-example.html#a8">Interpolation/interpolation_2.cpp</a>, <a class="el" href="Interpolation_2sibson_interpolation_2_8cpp-example.html#a4">Interpolation/sibson_interpolation_2.cpp</a>, and <a class="el" href="Interpolation_2sibson_interpolation_vertex_with_info_2_8cpp-example.html#a9">Interpolation/sibson_interpolation_vertex_with_info_2.cpp</a>.</dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"></a> 1.9.6 </li>
  </ul>
</div>
</div>
</body>

</html>
