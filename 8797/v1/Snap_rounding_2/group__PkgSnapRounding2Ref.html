<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Snap_rounding_2/group__PkgSnapRounding2Ref.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=11">
<meta name="generator" content="Doxygen 1.9.6">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CGAL 6.2 - 2D Snap Rounding: Reference Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/doxygen.css" rel="stylesheet" type="text/css">
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      },
      equationNumbers: { autoNumber: "AMS" }
  }
}
);
MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
  var PARSE = MathJax.InputJax.TeX.Parse,
      TEXT = PARSE.prototype.InternalText;
  PARSE.Augment({
    InternalText: function (text,def) {
      text = text.replace(/\\/g,"");
      return TEXT.call(this,text,def);
    }
  });
});
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
      <span class="left">
         <span id="MSearchSelect" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"> 
        </span>
        <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
      </span>
      <span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.svg" alt=""></a>
      </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CGAL 6.2 - 2D Snap Rounding
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search/",'.html');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__PkgSnapRounding2Ref.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> |
<a href="#nested-classes">Classes</a> |
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Reference Manual</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader"> </h2>
<div class="PkgImage">  <div class="image">
<img src="snap-detail.png" alt="">
</div>
 </div> <div class="PkgSummary"> <div class="PkgAuthors">Eli Packer</div> <div class="PkgDescription">Snap Rounding is a well known method for converting arbitrary-precision arrangements of segments into a fixed-precision representation. In the study of robust geometric computing, it can be classified as a finite precision approximation technique. Iterated Snap Rounding is a modification of Snap Rounding in which each vertex is at least half-the-width-of-a-pixel away from any non-incident edge. This package supports both methods.</div> <div class="PkgManuals"></div> </div> <div class="PkgShortInfo"> <b>Introduced in:</b> CGAL 3.1<br>
 <b>Depends on:</b> <a class="elRef" href="../Manual/packages.html#PkgArrangementOnSurface2">2D Arrangements</a> <br>
 <b>BibTeX:</b> <a href="../Manual/how_to_cite_cgal.html#cgal:p-sr2-26a">cgal:p-sr2-26a</a><br>
 <b>License:</b> <a class="elRef" href="../Manual/license.html#licensesGPL">GPL</a> <br>
 <b>Windows Demo:</b> <a href="https://www.cgal.org/demo/6.2/snap_rounding_2.zip">2D Snap Rounding</a><br>
 </div> <table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__PkgSnapRounding2Concepts"><td class="memItemLeft" align="right" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="group__PkgSnapRounding2Concepts.html">Concepts</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Snap__rounding__traits__2.html">CGAL::Snap_rounding_traits_2&lt; Kernel &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">The class <code><a class="el" href="classCGAL_1_1Snap__rounding__traits__2.html" title="The class Snap_rounding_traits_2&lt;Kernel&gt; is a model of the SnapRoundingTraits_2 concept,...">Snap_rounding_traits_2</a>&lt;<a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a>&gt;</code> is a model of the <code><a class="el" href="classSnapRoundingTraits__2.html" title="The concept SnapRoundingTraits_2 lists the set of requirements that must be fulfilled by an instance ...">SnapRoundingTraits_2</a></code> concept, and is the only traits class supplied with the package.  <a href="classCGAL_1_1Snap__rounding__traits__2.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structCGAL_1_1Float__snap__rounding__traits__2.html">CGAL::Float_snap_rounding_traits_2&lt; Input_Kernel, Exact_Kernel &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">The class <code><a class="el" href="structCGAL_1_1Float__snap__rounding__traits__2.html" title="The class Float_snap_rounding_traits_2&lt;Kernel&gt; is a model of the FloatSnapRoundingTraits_2 concept,...">Float_snap_rounding_traits_2</a>&lt;<a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a>&gt;</code> is a model of the <code><a class="el" href="classFloatSnapRoundingTraits__2.html" title="The concept FloatSnapRoundingTraits_2 lists the set of requirements that must be fulfilled by an inst...">FloatSnapRoundingTraits_2</a></code> concept, and is the only traits class supplied with the package.  <a href="structCGAL_1_1Float__snap__rounding__traits__2.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gabf9cbdb9bfcfd83513d30908e9679bbe"><td class="memTemplParams" colspan="2">template&lt;class Traits , class <a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> , class OutputContainer &gt; </td></tr>
<tr class="memitem:gabf9cbdb9bfcfd83513d30908e9679bbe"><td class="memTemplItemLeft" align="right" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgSnapRounding2Ref.html#gabf9cbdb9bfcfd83513d30908e9679bbe">CGAL::snap_rounding_2</a> (<a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> begin, <a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> end, OutputContainer &amp;output_container, typename Traits::FT pixel_size, bool do_isr=true, bool int_output=true, unsigned int number_of_kd_trees=1)</td></tr>
<tr class="separator:gabf9cbdb9bfcfd83513d30908e9679bbe"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga7c7195a922e72c75416e896196b90361"><td class="memTemplParams" colspan="2">template&lt;class <a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> , class OutputContainer , class NamedParameters  = parameters::Default_named_parameters&gt; </td></tr>
<tr class="memitem:ga7c7195a922e72c75416e896196b90361"><td class="memTemplItemLeft" align="right" valign="top">OutputContainer </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgSnapRounding2Ref.html#ga7c7195a922e72c75416e896196b90361">CGAL::double_snap_rounding_2</a> (<a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> begin, <a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> end, OutputContainer out, const NamedParameters &amp;np=<a class="elRef" href="../STL_Extension/group__PkgSTLExtensionRef.html#gaac7f54fe7abb7321d8d755683eaafaf2">parameters::default_values</a>())</td></tr>
<tr class="memdesc:ga7c7195a922e72c75416e896196b90361"><td class="mdescLeft"> </td><td class="mdescRight">Subdivides and rounded a set of segments so that they are pairwise disjoint in their interiors.  <br></td></tr>
<tr class="separator:ga7c7195a922e72c75416e896196b90361"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaaecaa9d94fc89865a58918e380b21210"><td class="memTemplParams" colspan="2">template&lt;class <a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> , class <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> , class NamedParameters  = parameters::Default_named_parameters&gt; </td></tr>
<tr class="memitem:gaaecaa9d94fc89865a58918e380b21210"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgSnapRounding2Ref.html#gaaecaa9d94fc89865a58918e380b21210">CGAL::compute_snapped_subcurves_2</a> (<a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> begin, <a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> end, <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> out, const NamedParameters &amp;np=<a class="elRef" href="../STL_Extension/group__PkgSTLExtensionRef.html#gaac7f54fe7abb7321d8d755683eaafaf2">parameters::default_values</a>())</td></tr>
<tr class="memdesc:gaaecaa9d94fc89865a58918e380b21210"><td class="mdescLeft"> </td><td class="mdescRight">Given a range of segments, compute rounded subsegments that are pairwise disjoint in their interior, as induced by the input curves.  <br></td></tr>
<tr class="separator:gaaecaa9d94fc89865a58918e380b21210"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga1481b05dbdd1b38b61c946370e1cb9b9"><td class="memTemplParams" colspan="2">template&lt;class <a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> , class <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> , class NamedParameters  = parameters::Default_named_parameters&gt; </td></tr>
<tr class="memitem:ga1481b05dbdd1b38b61c946370e1cb9b9"><td class="memTemplItemLeft" align="right" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgSnapRounding2Ref.html#ga1481b05dbdd1b38b61c946370e1cb9b9">CGAL::compute_snapped_polygons_2</a> (<a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> begin, <a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> end, <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> out, const NamedParameters &amp;np=<a class="elRef" href="../STL_Extension/group__PkgSTLExtensionRef.html#gaac7f54fe7abb7321d8d755683eaafaf2">parameters::default_values</a>())</td></tr>
<tr class="memdesc:ga1481b05dbdd1b38b61c946370e1cb9b9"><td class="mdescLeft"> </td><td class="mdescRight">Given a range of <code>Polygon_2</code>, compute rounded polygons such that their segments are either equal either disjoint in their interior, as induced by the input polygons.  <br></td></tr>
<tr class="separator:ga1481b05dbdd1b38b61c946370e1cb9b9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga99769f505f6f10bb1481f3c53e03eac0"><td class="memTemplParams" colspan="2">template&lt;class Polygon_2 , class NamedParameters  = parameters::Default_named_parameters&gt; </td></tr>
<tr class="memitem:ga99769f505f6f10bb1481f3c53e03eac0"><td class="memTemplItemLeft" align="right" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgSnapRounding2Ref.html#ga99769f505f6f10bb1481f3c53e03eac0">CGAL::compute_snapped_polygon_2</a> (const Polygon_2 &amp;P, Polygon_2 &amp;out, const NamedParameters &amp;np=<a class="elRef" href="../STL_Extension/group__PkgSTLExtensionRef.html#gaac7f54fe7abb7321d8d755683eaafaf2">parameters::default_values</a>())</td></tr>
<tr class="memdesc:ga99769f505f6f10bb1481f3c53e03eac0"><td class="mdescLeft"> </td><td class="mdescRight">Given a Polygon_2, compute rounded segments that are pairwise disjoint in their interior, as induced by the input polygon.  <br></td></tr>
<tr class="separator:ga99769f505f6f10bb1481f3c53e03eac0"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga99769f505f6f10bb1481f3c53e03eac0" name="ga99769f505f6f10bb1481f3c53e03eac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99769f505f6f10bb1481f3c53e03eac0">◆ </a></span>compute_snapped_polygon_2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Polygon_2 , class NamedParameters  = parameters::Default_named_parameters&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CGAL::compute_snapped_polygon_2 </td>
          <td>(</td>
          <td class="paramtype">const Polygon_2 &amp; </td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Polygon_2 &amp; </td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters &amp; </td>
          <td class="paramname"><em>np</em> = <code><a class="elRef" href="../STL_Extension/group__PkgSTLExtensionRef.html#gaac7f54fe7abb7321d8d755683eaafaf2">parameters::default_values</a>()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Float_snap_rounding_2.h&gt;</code></p>

<p>Given a Polygon_2, compute rounded segments that are pairwise disjoint in their interior, as induced by the input polygon. </p>
<p>The output is guarantee to be a Polygon but may present pinched section.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Polygon_2</td><td>model of <code>CGAL::Polygon_2</code> </td></tr>
    <tr><td class="paramname">NamedParameters</td><td>a sequence of <a class="elRef" href="../BGL/group__bgl__namedparameters.html">Named Parameters</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>the input polygon </td></tr>
    <tr><td class="paramname">out</td><td>the output polygon </td></tr>
    <tr><td class="paramname">np</td><td>an optional sequence of <a class="elRef" href="../BGL/group__bgl__namedparameters.html">Named Parameters</a> among the ones listed below</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Optional Named Parameters</dt>
<dd><table class="params">
<tr>
<td> <button class="collapsible"> <b>concurrency_tag</b> </button> <div class="content"><ul>
<li>
That template parameter enables to choose whether the algorithm is to be run in parallel, if <a class="elRef" href="../STL_Extension/structCGAL_1_1Parallel__tag.html">CGAL::Parallel_tag</a> is specified and <a class="elRef" href="../Manual/namespaceCGAL.html">CGAL</a> has been linked with the Intel TBB library, or sequentially, otherwise. </li>
<li>
<b>Type: </b>CGAL::Concurrency_tag </li>
<li>
<b>Default: </b><a class="elRef" href="../STL_Extension/structCGAL_1_1Sequential__tag.html">CGAL::Sequential_tag</a> </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>geom_traits</b> </button> <div class="content"><ul>
<li>
a multiplier of the error value for boundary edges to preserve the boundaries </li>
<li>
<b>Type: </b>double </li>
<li>
<b>Default: </b>100 </li>
</ul>
 </div>  </td><td></td></tr>
</table>
</dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The convex property is not necessarly preserved </dd></dl>

</div>
</div>
<a id="ga1481b05dbdd1b38b61c946370e1cb9b9" name="ga1481b05dbdd1b38b61c946370e1cb9b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1481b05dbdd1b38b61c946370e1cb9b9">◆ </a></span>compute_snapped_polygons_2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> , class <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> , class NamedParameters  = parameters::Default_named_parameters&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CGAL::compute_snapped_polygons_2 </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> </td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> </td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> </td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters &amp; </td>
          <td class="paramname"><em>np</em> = <code><a class="elRef" href="../STL_Extension/group__PkgSTLExtensionRef.html#gaac7f54fe7abb7321d8d755683eaafaf2">parameters::default_values</a>()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Float_snap_rounding_2.h&gt;</code></p>

<p>Given a range of <code>Polygon_2</code>, compute rounded polygons such that their segments are either equal either disjoint in their interior, as induced by the input polygons. </p>
<p>The polygons are intended to be non-intersecting, unless the named parameter <code>compute_intersections</code> is set to <code>true</code>. Any polygon is guaranteed to remain a Polygon in the output but may present pinched section or/and common vertices or segments with other polygons.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a></td><td>iterator of a CGAL::Polygon_2 range </td></tr>
    <tr><td class="paramname">OutputContainer</td><td>inserter of a CGAL::Polygon_2 range </td></tr>
    <tr><td class="paramname">NamedParameters</td><td>a sequence of <a class="elRef" href="../BGL/group__bgl__namedparameters.html">Named Parameters</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin,end</td><td>the input polygon range </td></tr>
    <tr><td class="paramname">out</td><td>the output inserter </td></tr>
    <tr><td class="paramname">np</td><td>an optional sequence of <a class="elRef" href="../BGL/group__bgl__namedparameters.html">Named Parameters</a> among the ones listed below</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Optional Named Parameters</dt>
<dd><table class="params">
<tr>
<td> <button class="collapsible"> <b>concurrency_tag</b> </button> <div class="content"><ul>
<li>
That template parameter enables to choose whether the algorithm is to be run in parallel, if <a class="elRef" href="../STL_Extension/structCGAL_1_1Parallel__tag.html">CGAL::Parallel_tag</a> is specified and <a class="elRef" href="../Manual/namespaceCGAL.html">CGAL</a> has been linked with the Intel TBB library, or sequentially, otherwise. </li>
<li>
<b>Type: </b>CGAL::Concurrency_tag </li>
<li>
<b>Default: </b><a class="elRef" href="../STL_Extension/structCGAL_1_1Sequential__tag.html">CGAL::Sequential_tag</a> </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>compute_intersections</b> </button> <div class="content"><ul>
<li>
Enable intersection computation between the polygons before performing snapping. </li>
<li>
<b>Type: </b>boolean </li>
<li>
<b>Default: </b>false </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>geom_traits</b> </button> <div class="content"><ul>
<li>
an instance of a geometric traits class </li>
<li>
<b>Type: </b>The traits class must respect the concept of <code><a class="el" href="classFloatSnapRoundingTraits__2.html" title="The concept FloatSnapRoundingTraits_2 lists the set of requirements that must be fulfilled by an inst...">FloatSnapRoundingTraits_2</a></code> </li>
<li>
<b>Default: </b>an instance of <code><a class="el" href="structCGAL_1_1Float__snap__rounding__traits__2.html" title="The class Float_snap_rounding_traits_2&lt;Kernel&gt; is a model of the FloatSnapRoundingTraits_2 concept,...">Float_snap_rounding_traits_2</a></code> </li>
</ul>
 </div>  </td><td></td></tr>
</table>
</dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If an input polygon is convex, it might no longer be convex in the output of this function </dd></dl>

</div>
</div>
<a id="gaaecaa9d94fc89865a58918e380b21210" name="gaaecaa9d94fc89865a58918e380b21210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaecaa9d94fc89865a58918e380b21210">◆ </a></span>compute_snapped_subcurves_2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> , class <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> , class NamedParameters  = parameters::Default_named_parameters&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> CGAL::compute_snapped_subcurves_2 </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> </td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> </td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> </td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters &amp; </td>
          <td class="paramname"><em>np</em> = <code><a class="elRef" href="../STL_Extension/group__PkgSTLExtensionRef.html#gaac7f54fe7abb7321d8d755683eaafaf2">parameters::default_values</a>()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Float_snap_rounding_2.h&gt;</code></p>

<p>Given a range of segments, compute rounded subsegments that are pairwise disjoint in their interior, as induced by the input curves. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Concurrency_tag</td><td>That template parameter enables to choose whether the algorithm is to be run in parallel, if <a class="elRef" href="../STL_Extension/structCGAL_1_1Parallel__tag.html">CGAL::Parallel_tag</a> is specified and <a class="elRef" href="../Manual/namespaceCGAL.html">CGAL</a> has been linked with the Intel TBB library, or sequentially, if <a class="elRef" href="../STL_Extension/structCGAL_1_1Sequential__tag.html">CGAL::Sequential_tag</a> - the default value - is specified. </td></tr>
    <tr><td class="paramname"><a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a></td><td>iterator of a segment range </td></tr>
    <tr><td class="paramname">OutputContainer</td><td>inserter of a segment range </td></tr>
    <tr><td class="paramname">NamedParameters</td><td>a sequence of <a class="elRef" href="../BGL/group__bgl__namedparameters.html">Named Parameters</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin,end</td><td>the input segment range </td></tr>
    <tr><td class="paramname">out</td><td>the output inserter </td></tr>
    <tr><td class="paramname">np</td><td>an optional sequence of <a class="elRef" href="../BGL/group__bgl__namedparameters.html">Named Parameters</a> among the ones listed below</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Optional Named Parameters</dt>
<dd><table class="params">
<tr>
<td> <button class="collapsible"> <b>concurrency_tag</b> </button> <div class="content"><ul>
<li>
That template parameter enables to choose whether the algorithm is to be run in parallel, if <a class="elRef" href="../STL_Extension/structCGAL_1_1Parallel__tag.html">CGAL::Parallel_tag</a> is specified and <a class="elRef" href="../Manual/namespaceCGAL.html">CGAL</a> has been linked with the Intel TBB library, or sequentially, otherwise. </li>
<li>
<b>Type: </b>CGAL::Concurrency_tag </li>
<li>
<b>Default: </b><a class="elRef" href="../STL_Extension/structCGAL_1_1Sequential__tag.html">CGAL::Sequential_tag</a> </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>geom_traits</b> </button> <div class="content"><ul>
<li>
an instance of a geometric traits class </li>
<li>
<b>Type: </b>The traits class must respect the concept of <code><a class="el" href="classFloatSnapRoundingTraits__2.html" title="The concept FloatSnapRoundingTraits_2 lists the set of requirements that must be fulfilled by an inst...">FloatSnapRoundingTraits_2</a></code> </li>
<li>
<b>Default: </b>an instance of <code><a class="el" href="structCGAL_1_1Float__snap__rounding__traits__2.html" title="The class Float_snap_rounding_traits_2&lt;Kernel&gt; is a model of the FloatSnapRoundingTraits_2 concept,...">Float_snap_rounding_traits_2</a></code> </li>
</ul>
 </div>  </td><td></td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a id="ga7c7195a922e72c75416e896196b90361" name="ga7c7195a922e72c75416e896196b90361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c7195a922e72c75416e896196b90361">◆ </a></span>double_snap_rounding_2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> , class OutputContainer , class NamedParameters  = parameters::Default_named_parameters&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputContainer CGAL::double_snap_rounding_2 </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> </td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> </td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputContainer </td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NamedParameters &amp; </td>
          <td class="paramname"><em>np</em> = <code><a class="elRef" href="../STL_Extension/group__PkgSTLExtensionRef.html#gaac7f54fe7abb7321d8d755683eaafaf2">parameters::default_values</a>()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Float_snap_rounding_2.h&gt;</code></p>

<p>Subdivides and rounded a set of segments so that they are pairwise disjoint in their interiors. </p>
<p>The output is a range of polyline with each polyline corresponding to an input segment.</p>
<p>TODO Currently compute_subcurves have no visitor to obtain a polyline per input segment, thus currently the output contain one polyline per ubsegment of the arrangement</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a></td><td>iterator over a range of <code><a class="elRef" href="../Kernel_23/classCGAL_1_1Segment__2.html">Segment_2</a></code> </td></tr>
    <tr><td class="paramname">OutputContainer</td><td>inserter over a range of <code>Polyline</code>. <code>Polyline</code> must be a type that provides a <code>push_back(Point_2)</code> function. </td></tr>
    <tr><td class="paramname">NamedParameters</td><td>a sequence of <a class="elRef" href="../BGL/group__bgl__namedparameters.html">Named Parameters</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin,end</td><td>the input segment range </td></tr>
    <tr><td class="paramname">out</td><td>the output inserter </td></tr>
    <tr><td class="paramname">np</td><td>an optional sequence of <a class="elRef" href="../BGL/group__bgl__namedparameters.html">Named Parameters</a> among the ones listed below</td></tr>
  </table>
  </dd>
</dl>
<dl class="params">
<dt>Optional Named Parameters</dt>
<dd><table class="params">
<tr>
<td> <button class="collapsible"> <b>concurrency_tag</b> </button> <div class="content"><ul>
<li>
That template parameter enables to choose whether the algorithm is to be run in parallel, if <a class="elRef" href="../STL_Extension/structCGAL_1_1Parallel__tag.html">CGAL::Parallel_tag</a> is specified and <a class="elRef" href="../Manual/namespaceCGAL.html">CGAL</a> has been linked with the Intel TBB library, or sequentially, otherwise. </li>
<li>
<b>Type: </b>CGAL::Concurrency_tag </li>
<li>
<b>Default: </b><a class="elRef" href="../STL_Extension/structCGAL_1_1Sequential__tag.html">CGAL::Sequential_tag</a> </li>
</ul>
 </div>  </td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td> <button class="collapsible"> <b>geom_traits</b> </button> <div class="content"><ul>
<li>
an instance of a geometric traits class </li>
<li>
<b>Type: </b>The traits class must respect the concept of <code><a class="el" href="classFloatSnapRoundingTraits__2.html" title="The concept FloatSnapRoundingTraits_2 lists the set of requirements that must be fulfilled by an inst...">FloatSnapRoundingTraits_2</a></code> </li>
<li>
<b>Default: </b>an instance of <code><a class="el" href="structCGAL_1_1Float__snap__rounding__traits__2.html" title="The class Float_snap_rounding_traits_2&lt;Kernel&gt; is a model of the FloatSnapRoundingTraits_2 concept,...">Float_snap_rounding_traits_2</a></code> </li>
</ul>
 </div>  </td><td></td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a id="gabf9cbdb9bfcfd83513d30908e9679bbe" name="gabf9cbdb9bfcfd83513d30908e9679bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf9cbdb9bfcfd83513d30908e9679bbe">◆ </a></span>snap_rounding_2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits , class <a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> , class OutputContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CGAL::snap_rounding_2 </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> </td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> </td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputContainer &amp; </td>
          <td class="paramname"><em>output_container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Traits::FT </td>
          <td class="paramname"><em>pixel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>do_isr</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>int_output</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int </td>
          <td class="paramname"><em>number_of_kd_trees</em> = <code>1</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Snap_rounding_2.h&gt;</code></p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Traits</td><td>must be a model of <code><a class="el" href="classSnapRoundingTraits__2.html" title="The concept SnapRoundingTraits_2 lists the set of requirements that must be fulfilled by an instance ...">SnapRoundingTraits_2</a></code>. </td></tr>
    <tr><td class="paramname"><a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a></td><td>must be an iterator with value type <code>Traits::Segment_2</code>. </td></tr>
    <tr><td class="paramname">OutputContainer</td><td>must be a container with a method <code>push_back(const OutputContainer::value_type&amp; c)</code>, where <code>OutputContainer::value_type</code> must be a container with a method <code>push_back(const Traits::Point_2&amp; p)</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin,end</td><td>The first two parameters denote the iterator range of the input segments.</td></tr>
    <tr><td class="paramname">output_container</td><td>is a reference to a container of the output polylines. Since a polyline is composed of a sequence of points, a polyline is a container itself.</td></tr>
    <tr><td class="paramname">do_isr</td><td>The fifth parameter determines whether to apply ISR or SR.</td></tr>
    <tr><td class="paramname">pixel_size</td><td>The fourth parameter denotes the pixel size <code>w</code>. The plane will be tiled with square pixels of width <code>w</code> such that the origin is the center of a pixel. <code>pixel_size</code> must have a positive value.</td></tr>
    <tr><td class="paramname">int_output</td><td>The sixth parameter denotes the output representation. If the value of the sixth parameter is <code>true</code> then the centers of pixels constitute the integer grid, and hence the vertices of the output polylines will be integers. For example, the coordinates of the center of the pixel to the right of the pixel containing the origin will be <code>(1,0)</code> regardless of the pixel width. If the value of the sixth parameter is <code>false</code>, then the centers of hot pixels (and hence the vertices of the output polylines) will bear their original coordinates, which may not necessarily be integers. In the latter case, the coordinates of the center of the pixel to the right of the pixel containing the origin, for example, will be <code>(w,0)</code>.</td></tr>
    <tr><td class="paramname">number_of_kd_trees</td><td>The seventh parameter is briefly described later on this page; for a detailed description see <a class="el" href="citelist.html#CITEREF_cgal:hp-isr-02">[3]</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Snap Rounding (SR, for short) is a well known method for converting arbitrary-precision arrangements of segments into a fixed-precision representation <a class="el" href="citelist.html#CITEREF_gght-srlse-97">[1]</a>, <a class="el" href="citelist.html#CITEREF_gm-rad-98">[2]</a>, <a class="el" href="citelist.html#CITEREF_h-psifp-99">[4]</a>. In the study of robust geometric computing, it can be classified as a finite precision approximation technique. Iterated Snap Rounding (ISR, for short) is a modification of SR in which each vertex is at least half-the-width-of-a-pixel away from any non-incident edge <a class="el" href="citelist.html#CITEREF_cgal:hp-isr-02">[3]</a>. This package supports both methods. Algorithmic details and experimental results are given in <a class="el" href="citelist.html#CITEREF_cgal:hp-isr-02">[3]</a>.</p>
<p>Given a finite collection \( \Sc\) of segments in the plane, the arrangement of \( \Sc\) denoted \( \Ac(\Sc)\) is the subdivision of the plane into vertices, edges, and faces induced by \( \Sc\). A <em>vertex</em> of the arrangement is either a segment endpoint or the intersection of two segments. Given an arrangement of segments whose vertices are represented with arbitrary-precision coordinates, SR proceeds as follows. We tile the plane with a grid of unit squares, <em>pixels</em>, each centered at a point with integer coordinates. A pixel is <em>hot</em> if it contains a vertex of the arrangement. Each vertex of the arrangement is replaced by the center of the hot pixel containing it and each edge \( e\) is replaced by the polygonal chain through the centers of the hot pixels met by \( e\), in the same order as they are met by \( e\).</p>
<p>In a snap-rounded arrangement, the distance between a vertex and a non-incident edge can be extremely small compared with the width of a pixel in the grid used for rounding. ISR is a modification of SR which makes a vertex and a non-incident edge well separated (the distance between each is at least half-the-width-of-a-pixel). However, the guaranteed quality of the approximation in ISR degrades. For more details on ISR see <a class="el" href="citelist.html#CITEREF_cgal:hp-isr-02">[3]</a>.</p>
<p>The traits used here must support (arbitrary-precision) rational number type as this is a basic requirement of SR.</p>
<p><b>About the Number of kd-Trees</b><br>
</p>
<p>A basic query used in the algorithm is to report the hot pixels of size \( w\) that a certain segment \( s\) intersects. An alternative way to do the same is to query the hot pixels' centers contained in a Minkowski sum of \( s\) with a pixel of width \( w\) centered at the origin; we denote this Minkowski sum by \( M(s)\). Since efficiently implementing this kind of query is difficult, we use an orthogonal range-search structure instead. We query with the bounding box \( B(M(s))\) of \( M(s)\) in a two-dimensional kd-tree which stores the centers of hot pixels. Since \( B(M(s))\) in general is larger than \( M(s)\), we still need to filter out the hot pixels which do not intersect \( s\).</p>
<p>While this approach is easy to implement with <a class="elRef" href="../Manual/namespaceCGAL.html">CGAL</a>, it may incur considerable overhead since the area of \( B(M(s))\) may be much larger than the area of \( M(s)\), possibly resulting in many redundant hot pixels to filter out. Our heuristic solution, which we describe next, is to use a cluster of kd-trees rather than just one. The cluster includes several kd-trees, each has the plane, and hence the centers of hot pixels, rotated by a different angle in the first quadrant of the plane; for our purpose, a rotation by angles outside this quadrant is symmetric to a rotation by an angle in the first quadrant.</p>
<p>Given a parameter \( c\), the angles of rotation are \( (i - 1)
\frac{\pi}{2c}, i=1,\ldots,c\), and we construct a kd-tree corresponding to each of these angles. Then for a query segment \( s\), we choose the kd-tree for which the area of \( B(M(s))\) is the smallest, in order to (potentially) get less hot pixels to filter out. Since constructing many kd-trees may be costly, our algorithm avoids building a kd-tree which it expects to be queried a relatively small number of times (we estimate this number in advance). How many kd-trees should be used? It is difficult to provide a simple answer for that. There are inputs for which the time to build more than one kd-tree is far greater than the time saved by having to filter out less hot pixels (sparse arrangements demonstrate this behavior), and there are inputs which benefit from using several kd-trees. Thus, the user can control the number of kd-trees with the parameter <code>number_of_kd_trees</code>. Typically, but not always, one kd-tree (the default) is sufficient. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"></a> 1.9.6 </li>
  </ul>
</div>
</div>
</body>

</html>
