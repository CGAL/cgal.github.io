<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Manual/Tutorial_Triangulation_2.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=11">
<meta name="generator" content="Doxygen 1.9.6">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CGAL 6.1 - Manual: Getting Started With 2D Triangulations</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<link href="navtree.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      },
      equationNumbers: { autoNumber: "AMS" }
  }
}
);
MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
  var PARSE = MathJax.InputJax.TeX.Parse,
      TEXT = PARSE.prototype.InternalText;
  PARSE.Augment({
    InternalText: function (text,def) {
      text = text.replace(/\\/g,"");
      return TEXT.call(this,text,def);
    }
  });
});
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
          <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()">Â </span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""></a>
          </span>
        </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CGAL 6.1 - Manual
   </div>
  </td>
  <!-- We disable the search box because we have added it in the
  back-nav for stylistic reasons. -->
  <!-- <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td> -->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('Tutorial_Triangulation_2.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Getting Started With 2D Triangulations </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"> <div id="autotoc" class="toc"></div> <dl class="section author"><dt>Author</dt><dd>Andreas Fabri</dd></dl>
<p>A 2D triangulation is a decomposition of the 2D plane in vertices and triangular faces.</p>
<p>In the first section we will walk you through the API of a class representing a Delaunay triangulation which operates on a set of points, followed by a section covering the API of a class representing a constrained Delaunay triangulation which operates on a set of points and segments.</p>
<p>Note that this tutorial is not about computational geometry, so we assume you are familiar with Delaunay triangulation with and without constraints.</p>
<h1>Tutorial_Delaunay_2 Defining the Type of <a class="elRef" href="../Triangulation/classCGAL_1_1Triangulation.html">Triangulation</a></h1>
<p>In the example code of this section we use a class template <code><a class="elRef" href="../Triangulation_2/classCGAL_1_1Delaunay__triangulation__2.html">Delaunay_triangulation_2</a></code> together with a <em>kernel</em> which provides types for points, segments or triangles, as well as <em>predicates</em>, for example the incircle test needed for the empty circle property of this type of triangulations.</p>
<p>So we start with some <code>#include</code> and some <code>using</code> statements to define types.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Delaunay_triangulation_2.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/draw_triangulation_2.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/use.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span><a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a> = <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div>
<div class="line"><span class="keyword">using </span>Delaunay = <a class="code hl_classRef" href="../Triangulation_2/classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2&lt;Kernel&gt;</a>;</div>
<div class="line"><span class="keyword">using </span>Point = Delaunay::Point;</div>
<div class="ttc" id="aclassCGAL_1_1Delaunay__triangulation__2_html"><div class="ttname"><a href="../Triangulation_2/classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2</a></div></div>
<div class="ttc" id="aclassCGAL_1_1Exact__predicates__inexact__constructions__kernel_html"><div class="ttname"><a href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a></div></div>
<div class="ttc" id="anamespaceKernel_html"><div class="ttname"><a href="../Kernel_23/namespaceKernel.html">Kernel</a></div></div>
</div><!-- fragment --><h1>Tutorial_Delaunay_2_Insert Inserting Points</h1>
<p>When we insert a set of points in the triangulation, it generates a set of finite vertices corresponding to the points, and the decomposition of the convex hull of the points in finite triangular faces. Additionally, the triangulation generates infinite faces, which are incident to the edges of the convex hull and which have as third vertex a single infinite vertex. When we draw the triangulation we only draw finite vertices and faces.</p>
<div class="fragment"><div class="line">  std ::array&lt;Point, 4&gt; points = {Point(0, 0), Point(2, 0), Point(0, 2), Point(2, 2)};</div>
<div class="line">  Delaunay dt;</div>
<div class="line">  dt.insert(points.begin(), points.end());</div>
<div class="line">  <span class="keyword">auto</span> vh = dt.insert(Point(1, 1));</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_functionRef" href="../Polygon/group__PkgDrawPolygon2.html#ga56a8df4559b043b885be909514e6069f">CGAL::draw</a>(dt);</div>
<div class="ttc" id="agroup__PkgDrawPolygon2_html_ga56a8df4559b043b885be909514e6069f"><div class="ttname"><a href="../Polygon/group__PkgDrawPolygon2.html#ga56a8df4559b043b885be909514e6069f">CGAL::draw</a></div><div class="ttdeci">void draw(const P &amp;p, const GSOptions &amp;gso)</div></div>
</div><!-- fragment --><p>FIGURE</p>
<p>We inserted a range of points from a <code>std::array</code> but the insert functions can take any range type, e.g., a <code>std::vector</code> or <code>std::list</code>. When we insert an individual point we obtained a <em>vertex handle</em> <code>vh</code>. A handle is a pointer to a vertex object, and no surprise when we write <code>v-&gt;point()</code> into <code>std::cout</code> we will see <code>1 1</code> on the console.</p>
<h1>Tutorial_Delaunay_2_Enumerate Enumerating Vertices and Faces</h1>
<p>Just like the standard containers, the triangulation provides iterators to enumerate its elements, that is either all or only the finite vertices and faces. When we iterate over all elements we often have to check whether they are finite. It makes no sense to access the point of the infinite vertex, or to compute the area of an infinite face.</p>
<div class="fragment"><div class="line">  std::cout &lt;&lt; vh-&gt;point() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keyword">auto</span> it = dt.all_vertices_begin(); it != dt.all_vertices_end(); ++it)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span>(dt.is_infinite(it))</div>
<div class="line">      <span class="keywordflow">continue</span>;</div>
<div class="line">    std::cout &lt;&lt; it-&gt;point() &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keyword">auto</span> it = dt.finite_vertices_begin(); it != dt.finite_vertices_end(); ++it)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; it-&gt;point() &lt;&lt; std::endl;</div>
<div class="line">  }</div>
</div><!-- fragment --><h1>Tutorial_Delaunay_2_Navigation About Incidence Relationships</h1>
<p>We next see how to navigate between vertices and faces. For vertex <code>vh</code> we can obtain one incident face calling <code>vh-&gt;face()</code>. We next enumerate the faces incident to vertex handle <code>vh</code>. As there is no natural begin and end of incident faces the function call <code>dt.incident_faces(vh)</code> returns a <em>circulator</em>. Just like an iterator you can increment and dereference a circulator. While for an iterator you test for being past-the-end, for a circulator you test if you are again where you started using a <code>do</code>-loop.</p>
<p>While a vertex can have an arbitrary number of incident faces, a face has always three incident vertices, which we access in the nested <code>for</code>-loop.</p>
<div class="fragment"><div class="line">  <span class="keyword">auto</span> fh = vh-&gt;face();</div>
<div class="line">  <span class="keyword">auto</span> fc = dt.incident_faces(vh), done(fc);</div>
<div class="line">  <span class="keywordflow">do</span> {</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i){</div>
<div class="line">      <span class="keywordflow">if</span>(vh == fc-&gt;vertex(i))</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">"vh has index "</span> &lt;&lt; i  &lt;&lt; <span class="stringliteral">" in the face"</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">  }<span class="keywordflow">while</span>(++fc != done);</div>
</div><!-- fragment --><p>The call <code>dt.incident_vertices()</code> returns a circulator over the one-ring of a vertex. If you pass it a vertex on the convex hull, the infinite vertex is in the one-ring. If you pass it the infinite vertex, you will circulate over the vertices of the convex hull.</p>
<p>Let's return to our vertex <code>vh</code> and its incident face <code>fh</code> and determine the index of <code>vh</code> in <code>fh</code>. The index is either 0, 1, or 2, in counterclockwise order. The triangulation class has static functions <code>cw()</code> and <code>ccw()</code> for computing the index of the clockwise and counterclockwise neighbor vertex.</p>
<div class="fragment"><div class="line">  <span class="keywordtype">int</span> ind =  fh-&gt;index(vh);</div>
<div class="line">  <span class="keyword">auto</span> cwv = fh-&gt;vertex(Delaunay::cw(ind));</div>
<div class="line">  <span class="keyword">auto</span> ccwv = fh-&gt;vertex(Delaunay::ccw(ind));</div>
<div class="line">  assert((ind + fh-&gt;index(cwv) + fh-&gt;index(ccwv)) == 3);</div>
</div><!-- fragment --><p>With the <code>neighbor()</code> function we can obtain the face opposite to <code>vh</code>. And symmetrically, we now obtain the index of <code>fh</code> in <code>nh</code>, and finally the vertex opposite to <code>fh</code>.</p>
<div class="fragment"><div class="line">  <span class="keyword">auto</span> nh = fh-&gt;neighbor(ind);</div>
<div class="line">  <span class="keywordtype">int</span> nind = nh-&gt;index(fh);</div>
<div class="line">  <span class="keyword">auto</span> nvh = nh-&gt;vertex(nind);</div>
</div><!-- fragment --><p>FIGURE</p>
<h1>Tutorial_Delaunay_2_Auto Real Types instead of Auto</h1>
<p>We saw a lot of <code>auto</code> instead of real types. Depending on your programming style you may like them or you may prefer writing some more <code>using</code> statemenmts.</p>
<div class="fragment"><div class="line"><span class="keyword">using </span>Vertex_handle = Delaunay::Vertex_handle;</div>
<div class="line"><span class="keyword">using </span>Face_handle = Delaunay::Face_handle;</div>
</div><!-- fragment --><p>and then use them like this, so that when reading the code it is absolutely clear of what type a variable is.</p>
<div class="fragment"><div class="line">  {</div>
<div class="line">    Face_handle nh = fh-&gt;neighbor(ind);</div>
<div class="line">    <span class="keywordtype">int</span> nind = nh-&gt;index(fh);</div>
<div class="line">    Vertex_handle nvh = nh-&gt;vertex(nind);</div>
<div class="line">    CGAL_USE(nvh);</div>
<div class="line">  }</div>
</div><!-- fragment --><h1>Tutorial_Delaunay_2_Edges Edges</h1>
<p>In a triangulation we also have <em>edges</em>. However, they are just a <code>std::pair</code> and hold a face handle and an index. No surprise that the index is the one of the vertex opposite to the edge. The <code>mirror()</code> function, which for an edge returns the edge seen from the other side, is there for convenience. Note that an edge and its mirror edge are not equal.</p>
<div class="fragment"><div class="line">  Delaunay::Edge e(fh, ind);</div>
<div class="line">  Delaunay::Edge me =dt.mirror_edge(e);</div>
<div class="line">  assert(me.first-&gt;vertex(me.second) == nvh);</div>
</div><!-- fragment --><p>The triangulation offers iterators to enumerate all edges, and circulators to enumerate the edges incident to a vertex.</p>
<h1>Tutorial_Delaunay_2_Locate Point Location</h1>
<p>Given a 2D point <code>p</code> we want to determine where in the triangulation it is. The <code><a class="elRef" href="../Arrangement_on_surface_2/group__PkgArrangementOnSurface2PointLocation.html#ga278df8e4d85dcb6bf3dfa35e251a706e">locate()</a></code> function returns a face handle we store in <code>fh</code>. The point may be on a vertex of <code>fh</code>, on an edge of <code>fh</code>, inside <code>fh</code> in case it is a finite face, or it may be outside the convex hull. The function writes this information in the non-const parameter <code>lt</code> of type <code>Locate_type</code>. And it additionally writes into the non-const parameter <code>li</code>, the locate index, the index of the vertex or edge in face <code>fh</code> , in case <code>lt</code> is <code>Delaunay::VERTEX</code> or <code>Delaunay::EDGE</code>. If <code>lt</code> is <code>Delaunay::FACE</code> or <code>Delaunay::OUTSIDE_CONVEX_HULL</code> the locate index has no meaning.</p>
<div class="fragment"><div class="line">  fh = dt.locate(Point(1, 1));</div>
</div><!-- fragment --><p>The function <code>Delaunay::locate()</code> has another optional parameter, namely a face from where to start the point location. Let's explain how point location works to understand why the hint is important. Without the hint the algorithm starts at an arbitrary vertex, and traverses faces in the direction of the query point. So when you have query points which have some spatial coherence you better pass the result of a previous point location query as hint where to start for the current one. You might have a look at the function <code><a class="elRef" href="../Spatial_sorting/group__PkgSpatialSortingFunctions.html#ga9da67204747ac19dff65f9c9ff2fca9e">hilbert_sort()</a></code> to learn more about what we mean with spatial coherence.</p>
<h1>Tutorial_Delaunay_2_Line_face_circulator Walking Along a Line</h1>
<p>Concerning the traversal of a triangulation we finish with the <em>line face circulator</em>. This circulator enables to traverse all faces that are intersected by a line defined by two points <code>p0</code> and <code>p1</code>, and is obtained by the call <code>dt.line_walk(p0,p1)</code>. The traversal starts where <code>p0</code> is located. It is a circulator as the traversal wraps around where the line intersects the convex hull. Note that the points, and even the line may be outside of the convex hull. We refer to the Reference Manual for explaining in detail which faces are traversed in case the line passes through a vertex. Again a hint can be given for the point location of the first point. You may think that the <code>line_walk()</code> function gets used to get from <code>p0</code> to <code>p1</code>, but that is not the case. Instead a "zigag" walk is performed that makes less geometric tests.</p>
<div class="fragment"><div class="line">  <span class="keyword">auto</span> lfc = dt.line_walk(Point(0.5, 0.5), Point(1.5, 0.5)), lfcdone(lfc);</div>
<div class="line">  <span class="keywordflow">do</span>{</div>
<div class="line">    <span class="keywordflow">if</span>(! dt.is_infinite(lfc))</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">"."</span> ;</div>
<div class="line">  }<span class="keywordflow">while</span>(lfc != lfcdone);</div>
<div class="line">  std::cout &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>We invite you to have a look at the examples in the User Manual which show how to enrich vertices and faces with information, how to operate on 3D points when the triangulation is 2.5D and represents a terrain, and more. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"></a> 1.9.6 </li>
  </ul>
</div>
</div>
</body>

</html>
