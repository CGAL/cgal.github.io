<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Segment_Delaunay_graph_2/classCGAL_1_1Segment__Delaunay__graph__2.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=11">
<meta name="generator" content="Doxygen 1.9.6">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CGAL 6.2 - 2D Segment Delaunay Graphs: CGAL::Segment_Delaunay_graph_2&lt; Gt, St, DS &gt; Class Template Reference</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/doxygen.css" rel="stylesheet" type="text/css">
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      },
      equationNumbers: { autoNumber: "AMS" }
  }
}
);
MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
  var PARSE = MathJax.InputJax.TeX.Parse,
      TEXT = PARSE.prototype.InternalText;
  PARSE.Augment({
    InternalText: function (text,def) {
      text = text.replace(/\\/g,"");
      return TEXT.call(this,text,def);
    }
  });
});
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
      <span class="left">
         <span id="MSearchSelect" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"> 
        </span>
        <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
      </span>
      <span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.svg" alt=""></a>
      </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CGAL 6.2 - 2D Segment Delaunay Graphs
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search/",'.html');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classCGAL_1_1Segment__Delaunay__graph__2.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="classCGAL_1_1Segment__Delaunay__graph__2-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">CGAL::Segment_Delaunay_graph_2&lt; Gt, St, DS &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__PkgSegmentDelaunayGraph2Ref.html">Reference Manual</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;CGAL/Segment_Delaunay_graph_2.h&gt;</code></p>

<p>Inherited by <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__hierarchy__2.html">CGAL::Segment_Delaunay_graph_hierarchy_2&lt; Gt, St, STag, DS &gt;</a>.</p>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Gt, typename St, typename DS&gt;<br>
class CGAL::Segment_Delaunay_graph_2&lt; Gt, St, DS &gt;</div><p>The class <code><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html" title="The class Segment_Delaunay_graph_2 represents the segment Delaunay graph (which is the dual graph of ...">Segment_Delaunay_graph_2</a></code> represents the segment Delaunay graph (which is the dual graph of the 2D segment Voronoi diagram). </p>
<p>Currently it only supports the insertions of sites.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Gt</td><td>must be a model of <code><a class="el" href="classSegmentDelaunayGraphTraits__2.html">SegmentDelaunayGraphTraits_2</a></code>.</td></tr>
    <tr><td class="paramname">St</td><td>must be a model of <code><a class="el" href="classSegmentDelaunayGraphStorageTraits__2.html" title="The concept SegmentDelaunayGraphStorageTraits_2 provides the requirements for the storage traits of a...">SegmentDelaunayGraphStorageTraits_2</a></code>. By default, the storage traits is instantiated by <code><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__storage__traits__2.html" title="The class Segment_Delaunay_graph_storage_traits_2 provides a model for the SegmentDelaunayGraphStorag...">Segment_Delaunay_graph_storage_traits_2</a>&lt;Gt&gt;</code>.</td></tr>
    <tr><td class="paramname">DS</td><td>must be a model of <code><a class="el" href="classSegmentDelaunayGraphDataStructure__2.html" title="The concept SegmentDelaunayGraphDataStructure_2 refines the concept ApolloniusGraphDataStructure_2....">SegmentDelaunayGraphDataStructure_2</a></code> whose vertex and face are models of the concepts <code><a class="el" href="classSegmentDelaunayGraphVertexBase__2.html">SegmentDelaunayGraphVertexBase_2</a></code> and <code><a class="elRef" href="../Triangulation_2/classTriangulationFaceBase__2.html">TriangulationFaceBase_2</a></code>, respectively. It defaults to: <div class="fragment"><div class="line"><a class="code hl_classRef" href="../TDS_2/classCGAL_1_1Triangulation__data__structure__2.html">CGAL::Triangulation_data_structure_2</a>&lt;</div>
<div class="line">          <a class="code hl_class" href="classCGAL_1_1Segment__Delaunay__graph__vertex__base__2.html">CGAL::Segment_Delaunay_graph_vertex_base_2&lt;St&gt;</a>,</div>
<div class="line">          <a class="code hl_class" href="classCGAL_1_1Segment__Delaunay__graph__face__base__2.html">CGAL::Segment_Delaunay_graph_face_base_2&lt;Gt&gt;</a> &gt;</div>
<div class="ttc" id="aclassCGAL_1_1Segment__Delaunay__graph__face__base__2_html"><div class="ttname"><a href="classCGAL_1_1Segment__Delaunay__graph__face__base__2.html">CGAL::Segment_Delaunay_graph_face_base_2</a></div><div class="ttdef"><b>Definition:</b> Segment_Delaunay_graph_face_base_2.h:22</div></div>
<div class="ttc" id="aclassCGAL_1_1Segment__Delaunay__graph__vertex__base__2_html"><div class="ttname"><a href="classCGAL_1_1Segment__Delaunay__graph__vertex__base__2.html">CGAL::Segment_Delaunay_graph_vertex_base_2</a></div><div class="ttdef"><b>Definition:</b> Segment_Delaunay_graph_vertex_base_2.h:24</div></div>
<div class="ttc" id="aclassCGAL_1_1Triangulation__data__structure__2_html"><div class="ttname"><a href="../TDS_2/classCGAL_1_1Triangulation__data__structure__2.html">CGAL::Triangulation_data_structure_2</a></div></div>
</div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<p><b>Storage</b><br>
</p>
<p>To avoid redundancy in the storage of points, input points are stored in a container, and the various types of sites (input points and segments, points of intersection, subsegments with one or two points of intersection as endpoints) only store handles to the points in the container. See Section <a class="el" href="index.html#Segment_Delaunay_graph_2StronglyIntersecting">Strongly Intersecting Sites and their Representation</a> for more information.</p>
<p><b>Traversal of the Segment Delaunay Graph</b><br>
</p>
<p>A segment Delaunay graph can be seen as a container of faces and vertices. Therefore the <code><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html" title="The class Segment_Delaunay_graph_2 represents the segment Delaunay graph (which is the dual graph of ...">Segment_Delaunay_graph_2</a></code> class provides several iterators and circulators that allow to traverse it (completely or partially).</p>
<dl>
<dt>Is model of</dt>
<dd><code><a class="elRef" href="../Voronoi_diagram_2/classDelaunayGraph__2.html">DelaunayGraph_2</a></code> </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="structCGAL_1_1Segment__Delaunay__graph__traits__2.html" title="The class Segment_Delaunay_graph_traits_2 provides a model for the SegmentDelaunayGraphTraits_2 conce...">CGAL::Segment_Delaunay_graph_traits_2</a>&lt;K,MTag&gt;</code> </dd>
<dd>
<code><a class="el" href="structCGAL_1_1Segment__Delaunay__graph__traits__without__intersections__2.html" title="The class Segment_Delaunay_graph_traits_without_intersections_2 provides a model for the SegmentDelau...">CGAL::Segment_Delaunay_graph_traits_without_intersections_2</a>&lt;K,MTag&gt;</code> </dd>
<dd>
<code><a class="el" href="structCGAL_1_1Segment__Delaunay__graph__filtered__traits__2.html" title="The class Segment_Delaunay_graph_filtered_traits_2 provides a model for the SegmentDelaunayGraphTrait...">CGAL::Segment_Delaunay_graph_filtered_traits_2</a>&lt;CK,CM,EK,EM,FK,FM&gt;</code> </dd>
<dd>
<code><a class="el" href="structCGAL_1_1Segment__Delaunay__graph__filtered__traits__without__intersections__2.html" title="The class Segment_Delaunay_graph_filtered_traits_without_intersections_2 provides a model for the Seg...">CGAL::Segment_Delaunay_graph_filtered_traits_without_intersections_2</a>&lt;CK,CM,EK,EM,FK,FM&gt;</code> </dd>
<dd>
<code><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__hierarchy__2.html" title="We provide an alternative to the class Segment_Delaunay_graph_2&lt;Gt,St,DS&gt; for the incremental constru...">CGAL::Segment_Delaunay_graph_hierarchy_2</a>&lt;Gt,St,STag,DS&gt;</code> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Segment_Delaunay_graph_2_2sdg-count-sites_8cpp-example.html#_a3">Segment_Delaunay_graph_2/sdg-count-sites.cpp</a>, <a class="el" href="Segment_Delaunay_graph_2_2sdg-fast-sp-polygon_8cpp-example.html#_a2">Segment_Delaunay_graph_2/sdg-fast-sp-polygon.cpp</a>, <a class="el" href="Segment_Delaunay_graph_2_2sdg-fast-sp_8cpp-example.html#_a2">Segment_Delaunay_graph_2/sdg-fast-sp.cpp</a>, <a class="el" href="Segment_Delaunay_graph_2_2sdg-red-blue-info_8cpp-example.html#_a3">Segment_Delaunay_graph_2/sdg-red-blue-info.cpp</a>, and <a class="el" href="Segment_Delaunay_graph_2_2sdg-voronoi-edges_8cpp-example.html#_a2">Segment_Delaunay_graph_2/sdg-voronoi-edges.cpp</a>.</dd>
</dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Types</h2></td></tr>
<tr class="memitem:aff6c4ee1b70d55dde320c9886f27cbb2"><td class="memItemLeft" align="right" valign="top"><a id="aff6c4ee1b70d55dde320c9886f27cbb2" name="aff6c4ee1b70d55dde320c9886f27cbb2"></a>
typedef Gt </td><td class="memItemRight" valign="bottom"><b>Geom_traits</b></td></tr>
<tr class="memdesc:aff6c4ee1b70d55dde320c9886f27cbb2"><td class="mdescLeft"> </td><td class="mdescRight">Type for the geometric traits. <br></td></tr>
<tr class="separator:aff6c4ee1b70d55dde320c9886f27cbb2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab61d4320d4111a66959197ad0021756b"><td class="memItemLeft" align="right" valign="top"><a id="ab61d4320d4111a66959197ad0021756b" name="ab61d4320d4111a66959197ad0021756b"></a>
typedef St </td><td class="memItemRight" valign="bottom"><b>Storage_traits</b></td></tr>
<tr class="memdesc:ab61d4320d4111a66959197ad0021756b"><td class="mdescLeft"> </td><td class="mdescRight">Type for the storage traits. <br></td></tr>
<tr class="separator:ab61d4320d4111a66959197ad0021756b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a644b112649bab16159b430ae4932c1ab"><td class="memItemLeft" align="right" valign="top"><a id="a644b112649bab16159b430ae4932c1ab" name="a644b112649bab16159b430ae4932c1ab"></a>
typedef DS </td><td class="memItemRight" valign="bottom"><b>Data_structure</b></td></tr>
<tr class="memdesc:a644b112649bab16159b430ae4932c1ab"><td class="mdescLeft"> </td><td class="mdescRight">Type for the underlying data structure. <br></td></tr>
<tr class="separator:a644b112649bab16159b430ae4932c1ab"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a98e07e07272cd63907891704236b0316"><td class="memItemLeft" align="right" valign="top"><a id="a98e07e07272cd63907891704236b0316" name="a98e07e07272cd63907891704236b0316"></a>
typedef <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a644b112649bab16159b430ae4932c1ab">Data_structure</a> </td><td class="memItemRight" valign="bottom"><b>Triangulation_data_structure</b></td></tr>
<tr class="memdesc:a98e07e07272cd63907891704236b0316"><td class="mdescLeft"> </td><td class="mdescRight">This type has been added so that the <code><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html" title="The class Segment_Delaunay_graph_2 represents the segment Delaunay graph (which is the dual graph of ...">Segment_Delaunay_graph_2</a></code> class is a model of the <code><a class="elRef" href="../Voronoi_diagram_2/classDelaunayGraph__2.html">DelaunayGraph_2</a></code> concept. <br></td></tr>
<tr class="separator:a98e07e07272cd63907891704236b0316"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab93ec2700dd54a3dc52c8c658e540cf6"><td class="memItemLeft" align="right" valign="top"><a id="ab93ec2700dd54a3dc52c8c658e540cf6" name="ab93ec2700dd54a3dc52c8c658e540cf6"></a>
typedef DS::size_type </td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="memdesc:ab93ec2700dd54a3dc52c8c658e540cf6"><td class="mdescLeft"> </td><td class="mdescRight">Size type (an unsigned integral type) <br></td></tr>
<tr class="separator:ab93ec2700dd54a3dc52c8c658e540cf6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a74c365bebb7af7d301107ee94b650826"><td class="memItemLeft" align="right" valign="top"><a id="a74c365bebb7af7d301107ee94b650826" name="a74c365bebb7af7d301107ee94b650826"></a>
typedef Gt::Point_2 </td><td class="memItemRight" valign="bottom"><b>Point_2</b></td></tr>
<tr class="memdesc:a74c365bebb7af7d301107ee94b650826"><td class="mdescLeft"> </td><td class="mdescRight">Type for the point defined in the geometric traits. <br></td></tr>
<tr class="separator:a74c365bebb7af7d301107ee94b650826"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6f9279b27e0be7ee36cad459ed086075"><td class="memItemLeft" align="right" valign="top"><a id="a6f9279b27e0be7ee36cad459ed086075" name="a6f9279b27e0be7ee36cad459ed086075"></a>
typedef Gt::Site_2 </td><td class="memItemRight" valign="bottom"><b>Site_2</b></td></tr>
<tr class="memdesc:a6f9279b27e0be7ee36cad459ed086075"><td class="mdescLeft"> </td><td class="mdescRight">Type for the segment Delaunay graph site, defined in the geometric traits. <br></td></tr>
<tr class="separator:a6f9279b27e0be7ee36cad459ed086075"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0d263f63754b0c64bdf395917c10233d"><td class="memItemLeft" align="right" valign="top"><a id="a0d263f63754b0c64bdf395917c10233d" name="a0d263f63754b0c64bdf395917c10233d"></a>
typedef Storage_traits::Storage_site_2 </td><td class="memItemRight" valign="bottom"><b>Storage_site_2</b></td></tr>
<tr class="memdesc:a0d263f63754b0c64bdf395917c10233d"><td class="mdescLeft"> </td><td class="mdescRight">Type for the segment Delaunay storage site, defined in the storage traits. <br></td></tr>
<tr class="separator:a0d263f63754b0c64bdf395917c10233d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a964649be1037cdd27590b8f7d2822f94"><td class="memItemLeft" align="right" valign="top"><a id="a964649be1037cdd27590b8f7d2822f94" name="a964649be1037cdd27590b8f7d2822f94"></a>
typedef Storage_traits::Point_container </td><td class="memItemRight" valign="bottom"><b>Point_container</b></td></tr>
<tr class="memdesc:a964649be1037cdd27590b8f7d2822f94"><td class="mdescLeft"> </td><td class="mdescRight">Type for the container of points. <br></td></tr>
<tr class="separator:a964649be1037cdd27590b8f7d2822f94"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a73bb7134d819a60d94b4c0942beb0291"><td class="memItemLeft" align="right" valign="top"><a id="a73bb7134d819a60d94b4c0942beb0291" name="a73bb7134d819a60d94b4c0942beb0291"></a>
typedef Storage_traits::Point_handle </td><td class="memItemRight" valign="bottom"><b>Point_handle</b></td></tr>
<tr class="memdesc:a73bb7134d819a60d94b4c0942beb0291"><td class="mdescLeft"> </td><td class="mdescRight"><a class="elRef" href="../Circulator/classHandle.html">Handle</a> type for points in the point container. <br></td></tr>
<tr class="separator:a73bb7134d819a60d94b4c0942beb0291"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Iterators and Handles</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>The vertices and faces of the segment Delaunay graph are accessed through <code>handles</code>, <code>iterators</code> and <code>circulators</code>.</p>
<p>The iterators and circulators are all bidirectional and non-mutable. The circulators and iterators are assignable to the corresponding handle types, and they are also convertible to the corresponding handles. The edges of the segment Delaunay graph can also be visited through iterators and circulators, the edge circulators and iterators are also bidirectional and non-mutable. In the following, we call <em>infinite</em> any face or edge incident to the infinite vertex and the infinite vertex itself. Any other feature (face, edge or vertex) of the segment Delaunay graph is said to be <em>finite</em>. Some iterators (the <code>All</code> iterators ) allow to visit finite or infinite features while the others (the <code>Finite</code> iterators) visit only finite features. Circulators visit both infinite and finite features. </p>
</td></tr>
<tr class="memitem:a961dd5d5acab82d04ab89ccb4c17ea93"><td class="memItemLeft" align="right" valign="top">typedef DS::Edge </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a961dd5d5acab82d04ab89ccb4c17ea93">Edge</a></td></tr>
<tr class="memdesc:a961dd5d5acab82d04ab89ccb4c17ea93"><td class="mdescLeft"> </td><td class="mdescRight">The edge type.  <br></td></tr>
<tr class="separator:a961dd5d5acab82d04ab89ccb4c17ea93"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3b4edd7dcd894d79ec9a22237525fff5"><td class="memItemLeft" align="right" valign="top"><a id="a3b4edd7dcd894d79ec9a22237525fff5" name="a3b4edd7dcd894d79ec9a22237525fff5"></a>
typedef DS::Vertex </td><td class="memItemRight" valign="bottom"><b>Vertex</b></td></tr>
<tr class="memdesc:a3b4edd7dcd894d79ec9a22237525fff5"><td class="mdescLeft"> </td><td class="mdescRight">Type for a vertex. <br></td></tr>
<tr class="separator:a3b4edd7dcd894d79ec9a22237525fff5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a201b849093da7cccb3f74ef3bdf6d190"><td class="memItemLeft" align="right" valign="top"><a id="a201b849093da7cccb3f74ef3bdf6d190" name="a201b849093da7cccb3f74ef3bdf6d190"></a>
typedef DS::Face </td><td class="memItemRight" valign="bottom"><b>Face</b></td></tr>
<tr class="memdesc:a201b849093da7cccb3f74ef3bdf6d190"><td class="mdescLeft"> </td><td class="mdescRight">Type for a face. <br></td></tr>
<tr class="separator:a201b849093da7cccb3f74ef3bdf6d190"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9a7dbb0128a8b00322c23cbf930bcba9"><td class="memItemLeft" align="right" valign="top"><a id="a9a7dbb0128a8b00322c23cbf930bcba9" name="a9a7dbb0128a8b00322c23cbf930bcba9"></a>
typedef DS::Vertex_handle </td><td class="memItemRight" valign="bottom"><b>Vertex_handle</b></td></tr>
<tr class="memdesc:a9a7dbb0128a8b00322c23cbf930bcba9"><td class="mdescLeft"> </td><td class="mdescRight">Type for a handle to a vertex. <br></td></tr>
<tr class="separator:a9a7dbb0128a8b00322c23cbf930bcba9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aabcdc2d8f964ce64286285efd7b1fcc1"><td class="memItemLeft" align="right" valign="top"><a id="aabcdc2d8f964ce64286285efd7b1fcc1" name="aabcdc2d8f964ce64286285efd7b1fcc1"></a>
typedef DS::Face_handle </td><td class="memItemRight" valign="bottom"><b>Face_handle</b></td></tr>
<tr class="memdesc:aabcdc2d8f964ce64286285efd7b1fcc1"><td class="mdescLeft"> </td><td class="mdescRight">Type for a handle to a face. <br></td></tr>
<tr class="separator:aabcdc2d8f964ce64286285efd7b1fcc1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a546dc147bdd1a3071f3030912520c6b2"><td class="memItemLeft" align="right" valign="top"><a id="a546dc147bdd1a3071f3030912520c6b2" name="a546dc147bdd1a3071f3030912520c6b2"></a>
typedef DS::Vertex_circulator </td><td class="memItemRight" valign="bottom"><b>Vertex_circulator</b></td></tr>
<tr class="memdesc:a546dc147bdd1a3071f3030912520c6b2"><td class="mdescLeft"> </td><td class="mdescRight">Type for a circulator over vertices incident to a given vertex. <br></td></tr>
<tr class="separator:a546dc147bdd1a3071f3030912520c6b2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a70303659970be1b00476db944ab9d312"><td class="memItemLeft" align="right" valign="top"><a id="a70303659970be1b00476db944ab9d312" name="a70303659970be1b00476db944ab9d312"></a>
typedef DS::Face_circulator </td><td class="memItemRight" valign="bottom"><b>Face_circulator</b></td></tr>
<tr class="memdesc:a70303659970be1b00476db944ab9d312"><td class="mdescLeft"> </td><td class="mdescRight">Type for a circulator over faces incident to a given vertex. <br></td></tr>
<tr class="separator:a70303659970be1b00476db944ab9d312"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5cc24d678431de42b2577a7e20e8415d"><td class="memItemLeft" align="right" valign="top"><a id="a5cc24d678431de42b2577a7e20e8415d" name="a5cc24d678431de42b2577a7e20e8415d"></a>
typedef DS::Edge_circulator </td><td class="memItemRight" valign="bottom"><b>Edge_circulator</b></td></tr>
<tr class="memdesc:a5cc24d678431de42b2577a7e20e8415d"><td class="mdescLeft"> </td><td class="mdescRight">Type for a circulator over edges incident to a given vertex. <br></td></tr>
<tr class="separator:a5cc24d678431de42b2577a7e20e8415d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9483678cb338f7f6cd653e080e04fbd9"><td class="memItemLeft" align="right" valign="top"><a id="a9483678cb338f7f6cd653e080e04fbd9" name="a9483678cb338f7f6cd653e080e04fbd9"></a>
typedef DS::Vertex_iterator </td><td class="memItemRight" valign="bottom"><b>All_vertices_iterator</b></td></tr>
<tr class="memdesc:a9483678cb338f7f6cd653e080e04fbd9"><td class="mdescLeft"> </td><td class="mdescRight">Type for an iterator over all vertices. <br></td></tr>
<tr class="separator:a9483678cb338f7f6cd653e080e04fbd9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac49511156f955fc742814c228e037eca"><td class="memItemLeft" align="right" valign="top"><a id="ac49511156f955fc742814c228e037eca" name="ac49511156f955fc742814c228e037eca"></a>
typedef DS::Face_iterator </td><td class="memItemRight" valign="bottom"><b>All_faces_iterator</b></td></tr>
<tr class="memdesc:ac49511156f955fc742814c228e037eca"><td class="mdescLeft"> </td><td class="mdescRight">Type for an iterator over all faces. <br></td></tr>
<tr class="separator:ac49511156f955fc742814c228e037eca"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3cb65e75134b2279d0f31440d6c4825f"><td class="memItemLeft" align="right" valign="top"><a id="a3cb65e75134b2279d0f31440d6c4825f" name="a3cb65e75134b2279d0f31440d6c4825f"></a>
typedef DS::Edge_iterator </td><td class="memItemRight" valign="bottom"><b>All_edges_iterator</b></td></tr>
<tr class="memdesc:a3cb65e75134b2279d0f31440d6c4825f"><td class="mdescLeft"> </td><td class="mdescRight">Type for an iterator over all edges. <br></td></tr>
<tr class="separator:a3cb65e75134b2279d0f31440d6c4825f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6865572600bfd51a155b356ce9708900"><td class="memItemLeft" align="right" valign="top"><a id="a6865572600bfd51a155b356ce9708900" name="a6865572600bfd51a155b356ce9708900"></a>
typedef <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> </td><td class="memItemRight" valign="bottom"><b>Finite_vertices_iterator</b></td></tr>
<tr class="memdesc:a6865572600bfd51a155b356ce9708900"><td class="mdescLeft"> </td><td class="mdescRight">Type for an iterator over finite vertices. <br></td></tr>
<tr class="separator:a6865572600bfd51a155b356ce9708900"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae6e3d8bbaee3f8045e3a28047a2d9ec2"><td class="memItemLeft" align="right" valign="top"><a id="ae6e3d8bbaee3f8045e3a28047a2d9ec2" name="ae6e3d8bbaee3f8045e3a28047a2d9ec2"></a>
typedef <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> </td><td class="memItemRight" valign="bottom"><b>Finite_faces_iterator</b></td></tr>
<tr class="memdesc:ae6e3d8bbaee3f8045e3a28047a2d9ec2"><td class="mdescLeft"> </td><td class="mdescRight">Type for an iterator over finite faces. <br></td></tr>
<tr class="separator:ae6e3d8bbaee3f8045e3a28047a2d9ec2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1386ae2da6e5328ba8e2fb4d7139bfcc"><td class="memItemLeft" align="right" valign="top"><a id="a1386ae2da6e5328ba8e2fb4d7139bfcc" name="a1386ae2da6e5328ba8e2fb4d7139bfcc"></a>
typedef <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> </td><td class="memItemRight" valign="bottom"><b>Finite_edges_iterator</b></td></tr>
<tr class="memdesc:a1386ae2da6e5328ba8e2fb4d7139bfcc"><td class="mdescLeft"> </td><td class="mdescRight">Type for an iterator over finite edges. <br></td></tr>
<tr class="separator:a1386ae2da6e5328ba8e2fb4d7139bfcc"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Site Iterators</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>The following iterators allow respectively to visit all sites.</p>
<p>These iterators are non-mutable, bidirectional and their value type is <code>Site_2</code>. They are all invalidated by any change in the segment Delaunay graph. </p>
</td></tr>
<tr class="memitem:af788737a5aad8c8371813389805e631b"><td class="memItemLeft" align="right" valign="top"><a id="af788737a5aad8c8371813389805e631b" name="af788737a5aad8c8371813389805e631b"></a>
typedef <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> </td><td class="memItemRight" valign="bottom"><b>Input_sites_iterator</b></td></tr>
<tr class="memdesc:af788737a5aad8c8371813389805e631b"><td class="mdescLeft"> </td><td class="mdescRight">Type for a bidirectional iterator over all input sites. <br></td></tr>
<tr class="separator:af788737a5aad8c8371813389805e631b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a811a22cf59ece05315f8782e596e3c01"><td class="memItemLeft" align="right" valign="top"><a id="a811a22cf59ece05315f8782e596e3c01" name="a811a22cf59ece05315f8782e596e3c01"></a>
typedef <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> </td><td class="memItemRight" valign="bottom"><b>Output_sites_iterator</b></td></tr>
<tr class="memdesc:a811a22cf59ece05315f8782e596e3c01"><td class="mdescLeft"> </td><td class="mdescRight">Type for a bidirectional iterator over all output sites (the sites in the Delaunay graph). <br></td></tr>
<tr class="separator:a811a22cf59ece05315f8782e596e3c01"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac99449fb3651fd2587bf2f8b59ab660f"><td class="memItemLeft" align="right" valign="top"><a id="ac99449fb3651fd2587bf2f8b59ab660f" name="ac99449fb3651fd2587bf2f8b59ab660f"></a>
<a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#af788737a5aad8c8371813389805e631b">Input_sites_iterator</a> </td><td class="memItemRight" valign="bottom"><b>input_sites_begin</b> () const</td></tr>
<tr class="memdesc:ac99449fb3651fd2587bf2f8b59ab660f"><td class="mdescLeft"> </td><td class="mdescRight">Starts at an arbitrary input site. <br></td></tr>
<tr class="separator:ac99449fb3651fd2587bf2f8b59ab660f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a47cd3858386b0b2c85557e07856939dc"><td class="memItemLeft" align="right" valign="top"><a id="a47cd3858386b0b2c85557e07856939dc" name="a47cd3858386b0b2c85557e07856939dc"></a>
<a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#af788737a5aad8c8371813389805e631b">Input_sites_iterator</a> </td><td class="memItemRight" valign="bottom"><b>input_sites_end</b> () const</td></tr>
<tr class="memdesc:a47cd3858386b0b2c85557e07856939dc"><td class="mdescLeft"> </td><td class="mdescRight">Past-the-end iterator. <br></td></tr>
<tr class="separator:a47cd3858386b0b2c85557e07856939dc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9aa5c8c9b078d5787fc93d7d92861a63"><td class="memItemLeft" align="right" valign="top"><a id="a9aa5c8c9b078d5787fc93d7d92861a63" name="a9aa5c8c9b078d5787fc93d7d92861a63"></a>
<a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a811a22cf59ece05315f8782e596e3c01">Output_sites_iterator</a> </td><td class="memItemRight" valign="bottom"><b>output_sites_begin</b> () const</td></tr>
<tr class="memdesc:a9aa5c8c9b078d5787fc93d7d92861a63"><td class="mdescLeft"> </td><td class="mdescRight">Starts at an arbitrary output site. <br></td></tr>
<tr class="separator:a9aa5c8c9b078d5787fc93d7d92861a63"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a375bacc9efc9ae442d1553b2e0ab666c"><td class="memItemLeft" align="right" valign="top"><a id="a375bacc9efc9ae442d1553b2e0ab666c" name="a375bacc9efc9ae442d1553b2e0ab666c"></a>
<a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a811a22cf59ece05315f8782e596e3c01">Output_sites_iterator</a> </td><td class="memItemRight" valign="bottom"><b>output_sites_end</b> () const</td></tr>
<tr class="memdesc:a375bacc9efc9ae442d1553b2e0ab666c"><td class="mdescLeft"> </td><td class="mdescRight">Past-the-end iterator. <br></td></tr>
<tr class="separator:a375bacc9efc9ae442d1553b2e0ab666c"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Creation</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>In addition to the default and copy constructors the following constructors are defined: </p>
</td></tr>
<tr class="memitem:ae7b711ae6ec529623afbf9fbadb5f8d5"><td class="memItemLeft" align="right" valign="top"><a id="ae7b711ae6ec529623afbf9fbadb5f8d5" name="ae7b711ae6ec529623afbf9fbadb5f8d5"></a>
 </td><td class="memItemRight" valign="bottom"><b>Segment_Delaunay_graph_2</b> (Gt gt=Gt(), St st=St())</td></tr>
<tr class="memdesc:ae7b711ae6ec529623afbf9fbadb5f8d5"><td class="mdescLeft"> </td><td class="mdescRight">Creates the segment Delaunay graph using <code>gt</code> as geometric traits and <code>st</code> as storage traits. <br></td></tr>
<tr class="separator:ae7b711ae6ec529623afbf9fbadb5f8d5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a77e6d212e45bbce3b3582c0ed49de4d5"><td class="memTemplParams" colspan="2">template&lt;class Input_iterator &gt; </td></tr>
<tr class="memitem:a77e6d212e45bbce3b3582c0ed49de4d5"><td class="memTemplItemLeft" align="right" valign="top"> </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a77e6d212e45bbce3b3582c0ed49de4d5">Segment_Delaunay_graph_2</a> (Input_iterator first, Input_iterator beyond, Gt gt=Gt(), St gt=St())</td></tr>
<tr class="memdesc:a77e6d212e45bbce3b3582c0ed49de4d5"><td class="mdescLeft"> </td><td class="mdescRight">Creates the segment Delaunay graph using <code>gt</code> as geometric traits, <code>st</code> as storage traits, and inserts all sites in the range [<code>first</code>, <code>beyond</code>).  <br></td></tr>
<tr class="separator:a77e6d212e45bbce3b3582c0ed49de4d5"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Access Functions</h2></td></tr>
<tr class="memitem:ac22960b106fdd0096dcc0b9f2038adb4"><td class="memItemLeft" align="right" valign="top"><a id="ac22960b106fdd0096dcc0b9f2038adb4" name="ac22960b106fdd0096dcc0b9f2038adb4"></a>
const <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#aff6c4ee1b70d55dde320c9886f27cbb2">Geom_traits</a> &amp; </td><td class="memItemRight" valign="bottom"><b>geom_traits</b> () const</td></tr>
<tr class="memdesc:ac22960b106fdd0096dcc0b9f2038adb4"><td class="mdescLeft"> </td><td class="mdescRight">Returns a reference to the segment Delaunay graph geometric traits object. <br></td></tr>
<tr class="separator:ac22960b106fdd0096dcc0b9f2038adb4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9a42d008d34a5d1565dff38f0c4afb0a"><td class="memItemLeft" align="right" valign="top"><a id="a9a42d008d34a5d1565dff38f0c4afb0a" name="a9a42d008d34a5d1565dff38f0c4afb0a"></a>
const <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#ab61d4320d4111a66959197ad0021756b">Storage_traits</a> &amp; </td><td class="memItemRight" valign="bottom"><b>storage_traits</b> () const</td></tr>
<tr class="memdesc:a9a42d008d34a5d1565dff38f0c4afb0a"><td class="mdescLeft"> </td><td class="mdescRight">Returns a reference to the segment Delaunay graph storage traits object. <br></td></tr>
<tr class="separator:a9a42d008d34a5d1565dff38f0c4afb0a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad4e99f21b4d29d9c7f6b4b1a0951a121"><td class="memItemLeft" align="right" valign="top"><a id="ad4e99f21b4d29d9c7f6b4b1a0951a121" name="ad4e99f21b4d29d9c7f6b4b1a0951a121"></a>
const <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a964649be1037cdd27590b8f7d2822f94">Point_container</a> &amp; </td><td class="memItemRight" valign="bottom"><b>point_container</b> () const</td></tr>
<tr class="memdesc:ad4e99f21b4d29d9c7f6b4b1a0951a121"><td class="mdescLeft"> </td><td class="mdescRight">Returns a reference to the point container object. <br></td></tr>
<tr class="separator:ad4e99f21b4d29d9c7f6b4b1a0951a121"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3c5ab5beb60cc7c50ea4841e5108b087"><td class="memItemLeft" align="right" valign="top"><a id="a3c5ab5beb60cc7c50ea4841e5108b087" name="a3c5ab5beb60cc7c50ea4841e5108b087"></a>
const <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a644b112649bab16159b430ae4932c1ab">Data_structure</a> &amp; </td><td class="memItemRight" valign="bottom"><b>data_structure</b> () const</td></tr>
<tr class="memdesc:a3c5ab5beb60cc7c50ea4841e5108b087"><td class="mdescLeft"> </td><td class="mdescRight">Returns a reference to the segment Delaunay graph data structure object. <br></td></tr>
<tr class="separator:a3c5ab5beb60cc7c50ea4841e5108b087"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa681252013b753e58d3f3864ec5e390f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a644b112649bab16159b430ae4932c1ab">Data_structure</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#aa681252013b753e58d3f3864ec5e390f">tds</a> () const</td></tr>
<tr class="memdesc:aa681252013b753e58d3f3864ec5e390f"><td class="mdescLeft"> </td><td class="mdescRight">Same as <code><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a3c5ab5beb60cc7c50ea4841e5108b087" title="Returns a reference to the segment Delaunay graph data structure object.">data_structure()</a></code>.  <br></td></tr>
<tr class="separator:aa681252013b753e58d3f3864ec5e390f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ace396a1db19375a56ab024daee16551c"><td class="memItemLeft" align="right" valign="top">int </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#ace396a1db19375a56ab024daee16551c">dimension</a> () const</td></tr>
<tr class="memdesc:ace396a1db19375a56ab024daee16551c"><td class="mdescLeft"> </td><td class="mdescRight">Returns the dimension of the segment Delaunay graph.  <br></td></tr>
<tr class="separator:ace396a1db19375a56ab024daee16551c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aeb78ff99737811fd9fbdeb859f2f87cb"><td class="memItemLeft" align="right" valign="top"><a id="aeb78ff99737811fd9fbdeb859f2f87cb" name="aeb78ff99737811fd9fbdeb859f2f87cb"></a>
<a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#ab93ec2700dd54a3dc52c8c658e540cf6">size_type</a> </td><td class="memItemRight" valign="bottom"><b>number_of_vertices</b> () const</td></tr>
<tr class="memdesc:aeb78ff99737811fd9fbdeb859f2f87cb"><td class="mdescLeft"> </td><td class="mdescRight">Returns the number of finite vertices of the segment Delaunay graph. <br></td></tr>
<tr class="separator:aeb78ff99737811fd9fbdeb859f2f87cb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af829b9f6600f58de9bccab1c56170c87"><td class="memItemLeft" align="right" valign="top"><a id="af829b9f6600f58de9bccab1c56170c87" name="af829b9f6600f58de9bccab1c56170c87"></a>
<a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#ab93ec2700dd54a3dc52c8c658e540cf6">size_type</a> </td><td class="memItemRight" valign="bottom"><b>number_of_faces</b> () const</td></tr>
<tr class="memdesc:af829b9f6600f58de9bccab1c56170c87"><td class="mdescLeft"> </td><td class="mdescRight">Returns the number of faces (both finite and infinite) of the segment Delaunay graph. <br></td></tr>
<tr class="separator:af829b9f6600f58de9bccab1c56170c87"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a873f18ec3bd12c647c684b49f99ac910"><td class="memItemLeft" align="right" valign="top"><a id="a873f18ec3bd12c647c684b49f99ac910" name="a873f18ec3bd12c647c684b49f99ac910"></a>
<a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#ab93ec2700dd54a3dc52c8c658e540cf6">size_type</a> </td><td class="memItemRight" valign="bottom"><b>number_of_input_sites</b> () const</td></tr>
<tr class="memdesc:a873f18ec3bd12c647c684b49f99ac910"><td class="mdescLeft"> </td><td class="mdescRight">Return the number of input sites. <br></td></tr>
<tr class="separator:a873f18ec3bd12c647c684b49f99ac910"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a110e6a2e70491ffe5109b8f128999e60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#ab93ec2700dd54a3dc52c8c658e540cf6">size_type</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a110e6a2e70491ffe5109b8f128999e60">number_of_output_sites</a> () const</td></tr>
<tr class="memdesc:a110e6a2e70491ffe5109b8f128999e60"><td class="mdescLeft"> </td><td class="mdescRight">Return the number of output sites.  <br></td></tr>
<tr class="separator:a110e6a2e70491ffe5109b8f128999e60"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7e1e0b3096cd2f93157ad71e2a155f50"><td class="memItemLeft" align="right" valign="top"><a id="a7e1e0b3096cd2f93157ad71e2a155f50" name="a7e1e0b3096cd2f93157ad71e2a155f50"></a>
<a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#aabcdc2d8f964ce64286285efd7b1fcc1">Face_handle</a> </td><td class="memItemRight" valign="bottom"><b>infinite_face</b> () const</td></tr>
<tr class="memdesc:a7e1e0b3096cd2f93157ad71e2a155f50"><td class="mdescLeft"> </td><td class="mdescRight">Returns a face incident to the <code>infinite_vertex</code>. <br></td></tr>
<tr class="separator:a7e1e0b3096cd2f93157ad71e2a155f50"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abc11b8fd15d62a3cc469c2dd907c1401"><td class="memItemLeft" align="right" valign="top"><a id="abc11b8fd15d62a3cc469c2dd907c1401" name="abc11b8fd15d62a3cc469c2dd907c1401"></a>
<a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a9a7dbb0128a8b00322c23cbf930bcba9">Vertex_handle</a> </td><td class="memItemRight" valign="bottom"><b>infinite_vertex</b> () const</td></tr>
<tr class="memdesc:abc11b8fd15d62a3cc469c2dd907c1401"><td class="mdescLeft"> </td><td class="mdescRight">Returns the <code>infinite_vertex</code>. <br></td></tr>
<tr class="separator:abc11b8fd15d62a3cc469c2dd907c1401"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a32a4f10cc2ccb876c82ac669fa80701e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a9a7dbb0128a8b00322c23cbf930bcba9">Vertex_handle</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a32a4f10cc2ccb876c82ac669fa80701e">finite_vertex</a> () const</td></tr>
<tr class="memdesc:a32a4f10cc2ccb876c82ac669fa80701e"><td class="mdescLeft"> </td><td class="mdescRight">Returns a vertex distinct from the <code>infinite_vertex</code>.  <br></td></tr>
<tr class="separator:a32a4f10cc2ccb876c82ac669fa80701e"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Finite Face, Edge and Vertex Iterators</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>The following iterators allow respectively to visit finite faces, finite edges and finite vertices of the segment Delaunay graph.</p>
<p>These iterators are non-mutable, bidirectional and their value types are respectively <code>Face</code>, <code>Edge</code> and <code>Vertex</code>. They are all invalidated by any change in the segment Delaunay graph. </p>
</td></tr>
<tr class="memitem:a9253b1d8e0294f6b9ba3b9dd9dd309ba"><td class="memItemLeft" align="right" valign="top"><a id="a9253b1d8e0294f6b9ba3b9dd9dd309ba" name="a9253b1d8e0294f6b9ba3b9dd9dd309ba"></a>
<a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a6865572600bfd51a155b356ce9708900">Finite_vertices_iterator</a> </td><td class="memItemRight" valign="bottom"><b>finite_vertices_begin</b> () const</td></tr>
<tr class="memdesc:a9253b1d8e0294f6b9ba3b9dd9dd309ba"><td class="mdescLeft"> </td><td class="mdescRight">Starts at an arbitrary finite vertex. <br></td></tr>
<tr class="separator:a9253b1d8e0294f6b9ba3b9dd9dd309ba"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0e30fb7490bb6f5794d7617ac50e59b3"><td class="memItemLeft" align="right" valign="top"><a id="a0e30fb7490bb6f5794d7617ac50e59b3" name="a0e30fb7490bb6f5794d7617ac50e59b3"></a>
<a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a6865572600bfd51a155b356ce9708900">Finite_vertices_iterator</a> </td><td class="memItemRight" valign="bottom"><b>finite_vertices_end</b> () const</td></tr>
<tr class="memdesc:a0e30fb7490bb6f5794d7617ac50e59b3"><td class="mdescLeft"> </td><td class="mdescRight">Past-the-end iterator. <br></td></tr>
<tr class="separator:a0e30fb7490bb6f5794d7617ac50e59b3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2d1b5ff5235f6ee585a4cdffac2a71ba"><td class="memItemLeft" align="right" valign="top"><a id="a2d1b5ff5235f6ee585a4cdffac2a71ba" name="a2d1b5ff5235f6ee585a4cdffac2a71ba"></a>
<a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a1386ae2da6e5328ba8e2fb4d7139bfcc">Finite_edges_iterator</a> </td><td class="memItemRight" valign="bottom"><b>finite_edges_begin</b> () const</td></tr>
<tr class="memdesc:a2d1b5ff5235f6ee585a4cdffac2a71ba"><td class="mdescLeft"> </td><td class="mdescRight">Starts at an arbitrary finite edge. <br></td></tr>
<tr class="separator:a2d1b5ff5235f6ee585a4cdffac2a71ba"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a299e492f4cb896fd575755d3bc622d29"><td class="memItemLeft" align="right" valign="top"><a id="a299e492f4cb896fd575755d3bc622d29" name="a299e492f4cb896fd575755d3bc622d29"></a>
<a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a1386ae2da6e5328ba8e2fb4d7139bfcc">Finite_edges_iterator</a> </td><td class="memItemRight" valign="bottom"><b>finite_edges_end</b> () const</td></tr>
<tr class="memdesc:a299e492f4cb896fd575755d3bc622d29"><td class="mdescLeft"> </td><td class="mdescRight">Past-the-end iterator. <br></td></tr>
<tr class="separator:a299e492f4cb896fd575755d3bc622d29"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1eacc659c42f3d2e48677c24b857e501"><td class="memItemLeft" align="right" valign="top"><a id="a1eacc659c42f3d2e48677c24b857e501" name="a1eacc659c42f3d2e48677c24b857e501"></a>
<a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#ae6e3d8bbaee3f8045e3a28047a2d9ec2">Finite_faces_iterator</a> </td><td class="memItemRight" valign="bottom"><b>finite_faces_begin</b> () const</td></tr>
<tr class="memdesc:a1eacc659c42f3d2e48677c24b857e501"><td class="mdescLeft"> </td><td class="mdescRight">Starts at an arbitrary finite face. <br></td></tr>
<tr class="separator:a1eacc659c42f3d2e48677c24b857e501"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a05ddcd579436fbfb9e1481d6541e1130"><td class="memItemLeft" align="right" valign="top"><a id="a05ddcd579436fbfb9e1481d6541e1130" name="a05ddcd579436fbfb9e1481d6541e1130"></a>
<a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#ae6e3d8bbaee3f8045e3a28047a2d9ec2">Finite_faces_iterator</a> </td><td class="memItemRight" valign="bottom"><b>finite_faces_end</b> () const</td></tr>
<tr class="memdesc:a05ddcd579436fbfb9e1481d6541e1130"><td class="mdescLeft"> </td><td class="mdescRight">Past-the-end iterator. <br></td></tr>
<tr class="separator:a05ddcd579436fbfb9e1481d6541e1130"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Infinite Face, Edge, and Vertex Iterators</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>The following iterators allow respectively to visit all (both finite and infinite) faces, edges and vertices of the segment Delaunay graph.</p>
<p>These iterators are non-mutable, bidirectional and their value types are respectively <code>Face</code>, <code>Edge</code> and <code>Vertex</code>. They are all invalidated by any change in the segment Delaunay graph. </p>
</td></tr>
<tr class="memitem:a98a5678a7f3989208bcf797a9f19f70a"><td class="memItemLeft" align="right" valign="top"><a id="a98a5678a7f3989208bcf797a9f19f70a" name="a98a5678a7f3989208bcf797a9f19f70a"></a>
<a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a9483678cb338f7f6cd653e080e04fbd9">All_vertices_iterator</a> </td><td class="memItemRight" valign="bottom"><b>all_vertices_begin</b> () const</td></tr>
<tr class="memdesc:a98a5678a7f3989208bcf797a9f19f70a"><td class="mdescLeft"> </td><td class="mdescRight">Starts at an arbitrary vertex. <br></td></tr>
<tr class="separator:a98a5678a7f3989208bcf797a9f19f70a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7e9e44d8f2de87613f4613d663a7ce8e"><td class="memItemLeft" align="right" valign="top"><a id="a7e9e44d8f2de87613f4613d663a7ce8e" name="a7e9e44d8f2de87613f4613d663a7ce8e"></a>
<a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a9483678cb338f7f6cd653e080e04fbd9">All_vertices_iterator</a> </td><td class="memItemRight" valign="bottom"><b>all_vertices_end</b> () const</td></tr>
<tr class="memdesc:a7e9e44d8f2de87613f4613d663a7ce8e"><td class="mdescLeft"> </td><td class="mdescRight">Past-the-end iterator. <br></td></tr>
<tr class="separator:a7e9e44d8f2de87613f4613d663a7ce8e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afc4adc111ed17626459aae6cdd9809d2"><td class="memItemLeft" align="right" valign="top"><a id="afc4adc111ed17626459aae6cdd9809d2" name="afc4adc111ed17626459aae6cdd9809d2"></a>
<a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a3cb65e75134b2279d0f31440d6c4825f">All_edges_iterator</a> </td><td class="memItemRight" valign="bottom"><b>all_edges_begin</b> () const</td></tr>
<tr class="memdesc:afc4adc111ed17626459aae6cdd9809d2"><td class="mdescLeft"> </td><td class="mdescRight">Starts at an arbitrary edge. <br></td></tr>
<tr class="separator:afc4adc111ed17626459aae6cdd9809d2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3a411d83e179f46609dd277198b45284"><td class="memItemLeft" align="right" valign="top"><a id="a3a411d83e179f46609dd277198b45284" name="a3a411d83e179f46609dd277198b45284"></a>
<a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a3cb65e75134b2279d0f31440d6c4825f">All_edges_iterator</a> </td><td class="memItemRight" valign="bottom"><b>all_edges_end</b> () const</td></tr>
<tr class="memdesc:a3a411d83e179f46609dd277198b45284"><td class="mdescLeft"> </td><td class="mdescRight">Past-the-end iterator. <br></td></tr>
<tr class="separator:a3a411d83e179f46609dd277198b45284"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a797fe4428141ff2925ccfbc324ebdd31"><td class="memItemLeft" align="right" valign="top"><a id="a797fe4428141ff2925ccfbc324ebdd31" name="a797fe4428141ff2925ccfbc324ebdd31"></a>
<a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#ac49511156f955fc742814c228e037eca">All_faces_iterator</a> </td><td class="memItemRight" valign="bottom"><b>all_faces_begin</b> () const</td></tr>
<tr class="memdesc:a797fe4428141ff2925ccfbc324ebdd31"><td class="mdescLeft"> </td><td class="mdescRight">Starts at an arbitrary face. <br></td></tr>
<tr class="separator:a797fe4428141ff2925ccfbc324ebdd31"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a87f6cef1f8c431c1874a9891b51a7ee5"><td class="memItemLeft" align="right" valign="top"><a id="a87f6cef1f8c431c1874a9891b51a7ee5" name="a87f6cef1f8c431c1874a9891b51a7ee5"></a>
<a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#ac49511156f955fc742814c228e037eca">All_faces_iterator</a> </td><td class="memItemRight" valign="bottom"><b>all_faces_end</b> () const</td></tr>
<tr class="memdesc:a87f6cef1f8c431c1874a9891b51a7ee5"><td class="mdescLeft"> </td><td class="mdescRight">Past-the-end iterator. <br></td></tr>
<tr class="separator:a87f6cef1f8c431c1874a9891b51a7ee5"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Face, Edge and Vertex Circulators</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>The <code><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html" title="The class Segment_Delaunay_graph_2 represents the segment Delaunay graph (which is the dual graph of ...">Segment_Delaunay_graph_2</a></code> class also provides circulators that allow to visit respectively all faces or edges incident to a given vertex or all vertices adjacent to a given vertex.</p>
<p>These circulators are non-mutable and bidirectional. The operator <code>operator++</code> moves the circulator counterclockwise around the vertex while the <code>operator-</code> moves clockwise. A face circulator is invalidated by any modification of the face pointed to. An edge circulator is invalidated by any modification in one of the two faces incident to the edge pointed to. A vertex circulator is invalidated by any modification in any of the faces adjacent to the vertex pointed to.</p>
<p>Applied on the <code>infinite_vertex</code> the above methods allow to visit the vertices on the convex hull and the infinite edges and faces. Note that a counterclockwise traversal of the vertices adjacent to the <code>infinite_vertex</code> is a clockwise traversal of the convex hull. </p>
</td></tr>
<tr class="memitem:a5e2930d0ae146011d7020dbbeebb98ec"><td class="memItemLeft" align="right" valign="top"><a id="a5e2930d0ae146011d7020dbbeebb98ec" name="a5e2930d0ae146011d7020dbbeebb98ec"></a>
<a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a70303659970be1b00476db944ab9d312">Face_circulator</a> </td><td class="memItemRight" valign="bottom"><b>incident_faces</b> (<a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a9a7dbb0128a8b00322c23cbf930bcba9">Vertex_handle</a> v) const</td></tr>
<tr class="memdesc:a5e2930d0ae146011d7020dbbeebb98ec"><td class="mdescLeft"> </td><td class="mdescRight">Starts at an arbitrary face incident to <code>v</code>. <br></td></tr>
<tr class="separator:a5e2930d0ae146011d7020dbbeebb98ec"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a72357ff62983e5e7da76ab88e8d4ca27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a70303659970be1b00476db944ab9d312">Face_circulator</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a72357ff62983e5e7da76ab88e8d4ca27">incident_faces</a> (<a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a9a7dbb0128a8b00322c23cbf930bcba9">Vertex_handle</a> v, <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#aabcdc2d8f964ce64286285efd7b1fcc1">Face_handle</a> f) const</td></tr>
<tr class="memdesc:a72357ff62983e5e7da76ab88e8d4ca27"><td class="mdescLeft"> </td><td class="mdescRight">Starts at face <code>f</code>.  <br></td></tr>
<tr class="separator:a72357ff62983e5e7da76ab88e8d4ca27"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa30693cf070503b0f9c8fda2f2cade4c"><td class="memItemLeft" align="right" valign="top"><a id="aa30693cf070503b0f9c8fda2f2cade4c" name="aa30693cf070503b0f9c8fda2f2cade4c"></a>
<a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a5cc24d678431de42b2577a7e20e8415d">Edge_circulator</a> </td><td class="memItemRight" valign="bottom"><b>incident_edges</b> (<a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a9a7dbb0128a8b00322c23cbf930bcba9">Vertex_handle</a> v) const</td></tr>
<tr class="memdesc:aa30693cf070503b0f9c8fda2f2cade4c"><td class="mdescLeft"> </td><td class="mdescRight">Starts at an arbitrary edge incident to <code>v</code>. <br></td></tr>
<tr class="separator:aa30693cf070503b0f9c8fda2f2cade4c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4c916443215b0386f988f4822398161c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a5cc24d678431de42b2577a7e20e8415d">Edge_circulator</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a4c916443215b0386f988f4822398161c">incident_edges</a> (<a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a9a7dbb0128a8b00322c23cbf930bcba9">Vertex_handle</a> v, <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#aabcdc2d8f964ce64286285efd7b1fcc1">Face_handle</a> f) const</td></tr>
<tr class="memdesc:a4c916443215b0386f988f4822398161c"><td class="mdescLeft"> </td><td class="mdescRight">Starts at the first edge of <code>f</code> incident to <code>v</code>, in counterclockwise order around <code>v</code>.  <br></td></tr>
<tr class="separator:a4c916443215b0386f988f4822398161c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a01c8f3250c5d0d6584317d22df260b05"><td class="memItemLeft" align="right" valign="top"><a id="a01c8f3250c5d0d6584317d22df260b05" name="a01c8f3250c5d0d6584317d22df260b05"></a>
<a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a546dc147bdd1a3071f3030912520c6b2">Vertex_circulator</a> </td><td class="memItemRight" valign="bottom"><b>incident_vertices</b> (<a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a9a7dbb0128a8b00322c23cbf930bcba9">Vertex_handle</a> v) const</td></tr>
<tr class="memdesc:a01c8f3250c5d0d6584317d22df260b05"><td class="mdescLeft"> </td><td class="mdescRight">Starts at an arbitrary vertex incident to <code>v</code>. <br></td></tr>
<tr class="separator:a01c8f3250c5d0d6584317d22df260b05"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a694dfb542456d0aa2186fa60245418a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a546dc147bdd1a3071f3030912520c6b2">Vertex_circulator</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a694dfb542456d0aa2186fa60245418a8">incident_vertices</a> (<a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a9a7dbb0128a8b00322c23cbf930bcba9">Vertex_handle</a> v, <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#aabcdc2d8f964ce64286285efd7b1fcc1">Face_handle</a> f) const</td></tr>
<tr class="memdesc:a694dfb542456d0aa2186fa60245418a8"><td class="mdescLeft"> </td><td class="mdescRight">Starts at the first vertex of <code>f</code> adjacent to <code>v</code> in counterclockwise order around <code>v</code>.  <br></td></tr>
<tr class="separator:a694dfb542456d0aa2186fa60245418a8"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Predicates</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>The class <code><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html" title="The class Segment_Delaunay_graph_2 represents the segment Delaunay graph (which is the dual graph of ...">Segment_Delaunay_graph_2</a></code> provides methods to test the finite or infinite character of any feature. </p>
</td></tr>
<tr class="memitem:ace15a75982eaf86f1c7d2507cf80a870"><td class="memItemLeft" align="right" valign="top"><a id="ace15a75982eaf86f1c7d2507cf80a870" name="ace15a75982eaf86f1c7d2507cf80a870"></a>
bool </td><td class="memItemRight" valign="bottom"><b>is_infinite</b> (<a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a9a7dbb0128a8b00322c23cbf930bcba9">Vertex_handle</a> v) const</td></tr>
<tr class="memdesc:ace15a75982eaf86f1c7d2507cf80a870"><td class="mdescLeft"> </td><td class="mdescRight"><code>true</code>, iff <code>v</code> is the <code>infinite_vertex</code>. <br></td></tr>
<tr class="separator:ace15a75982eaf86f1c7d2507cf80a870"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a47f6e41999c64bc3f915ddda91d6a669"><td class="memItemLeft" align="right" valign="top"><a id="a47f6e41999c64bc3f915ddda91d6a669" name="a47f6e41999c64bc3f915ddda91d6a669"></a>
bool </td><td class="memItemRight" valign="bottom"><b>is_infinite</b> (<a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#aabcdc2d8f964ce64286285efd7b1fcc1">Face_handle</a> f) const</td></tr>
<tr class="memdesc:a47f6e41999c64bc3f915ddda91d6a669"><td class="mdescLeft"> </td><td class="mdescRight"><code>true</code>, iff face <code>f</code> is infinite. <br></td></tr>
<tr class="separator:a47f6e41999c64bc3f915ddda91d6a669"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a125ba2fc60742a07c85986ff73c2dc53"><td class="memItemLeft" align="right" valign="top"><a id="a125ba2fc60742a07c85986ff73c2dc53" name="a125ba2fc60742a07c85986ff73c2dc53"></a>
bool </td><td class="memItemRight" valign="bottom"><b>is_infinite</b> (<a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#aabcdc2d8f964ce64286285efd7b1fcc1">Face_handle</a> f, int i) const</td></tr>
<tr class="memdesc:a125ba2fc60742a07c85986ff73c2dc53"><td class="mdescLeft"> </td><td class="mdescRight"><code>true</code>, iff edge <code>(f,i)</code> is infinite. <br></td></tr>
<tr class="separator:a125ba2fc60742a07c85986ff73c2dc53"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad3b42d6dc006c704c4759f820ff3226f"><td class="memItemLeft" align="right" valign="top"><a id="ad3b42d6dc006c704c4759f820ff3226f" name="ad3b42d6dc006c704c4759f820ff3226f"></a>
bool </td><td class="memItemRight" valign="bottom"><b>is_infinite</b> (<a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a961dd5d5acab82d04ab89ccb4c17ea93">Edge</a> e) const</td></tr>
<tr class="memdesc:ad3b42d6dc006c704c4759f820ff3226f"><td class="mdescLeft"> </td><td class="mdescRight"><code>true</code>, iff edge <code>e</code> is infinite. <br></td></tr>
<tr class="separator:ad3b42d6dc006c704c4759f820ff3226f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a92e9bea4999d87150c894635e264b2f8"><td class="memItemLeft" align="right" valign="top"><a id="a92e9bea4999d87150c894635e264b2f8" name="a92e9bea4999d87150c894635e264b2f8"></a>
bool </td><td class="memItemRight" valign="bottom"><b>is_infinite</b> (<a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a5cc24d678431de42b2577a7e20e8415d">Edge_circulator</a> ec) const</td></tr>
<tr class="memdesc:a92e9bea4999d87150c894635e264b2f8"><td class="mdescLeft"> </td><td class="mdescRight"><code>true</code>, iff edge <code>*ec</code> is infinite. <br></td></tr>
<tr class="separator:a92e9bea4999d87150c894635e264b2f8"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Insertion</h2></td></tr>
<tr class="memitem:accb50cf54c7c8dcc93e643a67fe81891"><td class="memTemplParams" colspan="2">template&lt;class Input_iterator &gt; </td></tr>
<tr class="memitem:accb50cf54c7c8dcc93e643a67fe81891"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#ab93ec2700dd54a3dc52c8c658e540cf6">size_type</a> </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#accb50cf54c7c8dcc93e643a67fe81891">insert</a> (Input_iterator first, Input_iterator beyond)</td></tr>
<tr class="memdesc:accb50cf54c7c8dcc93e643a67fe81891"><td class="mdescLeft"> </td><td class="mdescRight">Iteratively inserts the sites in the range [<code>first</code>,<code>beyond</code>).  <br></td></tr>
<tr class="separator:accb50cf54c7c8dcc93e643a67fe81891"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4c38d30277b965be645f8b3b11bba92d"><td class="memTemplParams" colspan="2">template&lt;class Input_iterator &gt; </td></tr>
<tr class="memitem:a4c38d30277b965be645f8b3b11bba92d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#ab93ec2700dd54a3dc52c8c658e540cf6">size_type</a> </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a4c38d30277b965be645f8b3b11bba92d">insert</a> (Input_iterator first, Input_iterator beyond, <a class="elRef" href="../STL_Extension/group__PkgSTLExtensionUtilities.html#ga89d5ecf1540b2ec0a2bf5dd003e186d0">CGAL::Tag_false</a>)</td></tr>
<tr class="memdesc:a4c38d30277b965be645f8b3b11bba92d"><td class="mdescLeft"> </td><td class="mdescRight">Iteratively inserts the sites in the range [<code>first</code>,<code>beyond</code>).  <br></td></tr>
<tr class="separator:a4c38d30277b965be645f8b3b11bba92d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af95131302a9b3ae34940f1026658c177"><td class="memTemplParams" colspan="2">template&lt;class Input_iterator &gt; </td></tr>
<tr class="memitem:af95131302a9b3ae34940f1026658c177"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#ab93ec2700dd54a3dc52c8c658e540cf6">size_type</a> </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#af95131302a9b3ae34940f1026658c177">insert</a> (Input_iterator first, Input_iterator beyond, <a class="elRef" href="../STL_Extension/group__PkgSTLExtensionUtilities.html#gab3e2296107b5d26c32c8183028a217f1">CGAL::Tag_true</a>)</td></tr>
<tr class="memdesc:af95131302a9b3ae34940f1026658c177"><td class="mdescLeft"> </td><td class="mdescRight">Decomposes the range [first,beyond) into a range of input points and a range of input segments that are respectively passed to <code><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#aac42f0ea4bf167a0a09154acd6391cb1" title="Inserts the segments in the range [first,beyond) as sites.">insert_segments()</a></code> and <code><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#af34c5b5476782bfeab3065fd7cb843fd" title="Inserts the points in the range [first,beyond) as sites.">insert_points()</a></code>.  <br></td></tr>
<tr class="separator:af95131302a9b3ae34940f1026658c177"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af34c5b5476782bfeab3065fd7cb843fd"><td class="memTemplParams" colspan="2">template&lt;class PointIterator &gt; </td></tr>
<tr class="memitem:af34c5b5476782bfeab3065fd7cb843fd"><td class="memTemplItemLeft" align="right" valign="top">std::size_t </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#af34c5b5476782bfeab3065fd7cb843fd">insert_points</a> (PointIterator first, PointIterator beyond)</td></tr>
<tr class="memdesc:af34c5b5476782bfeab3065fd7cb843fd"><td class="mdescLeft"> </td><td class="mdescRight">Inserts the points in the range [first,beyond) as sites.  <br></td></tr>
<tr class="separator:af34c5b5476782bfeab3065fd7cb843fd"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aac42f0ea4bf167a0a09154acd6391cb1"><td class="memTemplParams" colspan="2">template&lt;class SegmentIterator &gt; </td></tr>
<tr class="memitem:aac42f0ea4bf167a0a09154acd6391cb1"><td class="memTemplItemLeft" align="right" valign="top">std::size_t </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#aac42f0ea4bf167a0a09154acd6391cb1">insert_segments</a> (SegmentIterator first, SegmentIterator beyond)</td></tr>
<tr class="memdesc:aac42f0ea4bf167a0a09154acd6391cb1"><td class="mdescLeft"> </td><td class="mdescRight">Inserts the segments in the range [first,beyond) as sites.  <br></td></tr>
<tr class="separator:aac42f0ea4bf167a0a09154acd6391cb1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a21f1ac813bf15063da2c2ecbcdf30daa"><td class="memTemplParams" colspan="2">template&lt;class PointIterator , class IndicesIterator &gt; </td></tr>
<tr class="memitem:a21f1ac813bf15063da2c2ecbcdf30daa"><td class="memTemplItemLeft" align="right" valign="top">std::size_t </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a21f1ac813bf15063da2c2ecbcdf30daa">insert_segments</a> (PointIterator points_first, PointIterator points_beyond, IndicesIterator indices_first, IndicesIterator indices_beyond)</td></tr>
<tr class="memdesc:a21f1ac813bf15063da2c2ecbcdf30daa"><td class="mdescLeft"> </td><td class="mdescRight">Same as above except that each segment is given as a pair of indices of the points in the range [points_first, points_beyond).  <br></td></tr>
<tr class="separator:a21f1ac813bf15063da2c2ecbcdf30daa"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0e5ac3c19398daedfe871fdacd63b728"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a9a7dbb0128a8b00322c23cbf930bcba9">Vertex_handle</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a0e5ac3c19398daedfe871fdacd63b728">insert</a> (const <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a74c365bebb7af7d301107ee94b650826">Point_2</a> &amp;p)</td></tr>
<tr class="memdesc:a0e5ac3c19398daedfe871fdacd63b728"><td class="mdescLeft"> </td><td class="mdescRight">Inserts the point <code>p</code> in the segment Delaunay graph.  <br></td></tr>
<tr class="separator:a0e5ac3c19398daedfe871fdacd63b728"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5f787c033d11114a86ca3877b02c9033"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a9a7dbb0128a8b00322c23cbf930bcba9">Vertex_handle</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a5f787c033d11114a86ca3877b02c9033">insert</a> (const <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a74c365bebb7af7d301107ee94b650826">Point_2</a> &amp;p, <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a9a7dbb0128a8b00322c23cbf930bcba9">Vertex_handle</a> vnear)</td></tr>
<tr class="memdesc:a5f787c033d11114a86ca3877b02c9033"><td class="mdescLeft"> </td><td class="mdescRight">Inserts <code>p</code> in the segment Delaunay graph using the site associated with <code>vnear</code> as an estimate for the nearest neighbor of <code>p</code>.  <br></td></tr>
<tr class="separator:a5f787c033d11114a86ca3877b02c9033"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab092560ed8f6186ec7ed5e819366f9e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a9a7dbb0128a8b00322c23cbf930bcba9">Vertex_handle</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#ab092560ed8f6186ec7ed5e819366f9e4">insert</a> (const <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a74c365bebb7af7d301107ee94b650826">Point_2</a> &amp;p1, const <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a74c365bebb7af7d301107ee94b650826">Point_2</a> &amp;p2)</td></tr>
<tr class="memdesc:ab092560ed8f6186ec7ed5e819366f9e4"><td class="mdescLeft"> </td><td class="mdescRight">Inserts the closed segment with endpoints <code>p1</code> and <code>p2</code> in the segment Delaunay graph.  <br></td></tr>
<tr class="separator:ab092560ed8f6186ec7ed5e819366f9e4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9be228deffb2ec2a3a799b33e4216b46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a9a7dbb0128a8b00322c23cbf930bcba9">Vertex_handle</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a9be228deffb2ec2a3a799b33e4216b46">insert</a> (const <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a74c365bebb7af7d301107ee94b650826">Point_2</a> &amp;p1, const <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a74c365bebb7af7d301107ee94b650826">Point_2</a> &amp;p2, <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a9a7dbb0128a8b00322c23cbf930bcba9">Vertex_handle</a> vnear)</td></tr>
<tr class="memdesc:a9be228deffb2ec2a3a799b33e4216b46"><td class="mdescLeft"> </td><td class="mdescRight">Inserts the segment whose endpoints are <code>p1</code> and <code>p2</code> in the segment Delaunay graph using the site associated with <code>vnear</code> as an estimate for the nearest neighbor of <code>p1</code>.  <br></td></tr>
<tr class="separator:a9be228deffb2ec2a3a799b33e4216b46"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa9ab750a38b8acbe5c0bf9b7ae5b5125"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a9a7dbb0128a8b00322c23cbf930bcba9">Vertex_handle</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#aa9ab750a38b8acbe5c0bf9b7ae5b5125">insert</a> (const <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a6f9279b27e0be7ee36cad459ed086075">Site_2</a> &amp;s)</td></tr>
<tr class="memdesc:aa9ab750a38b8acbe5c0bf9b7ae5b5125"><td class="mdescLeft"> </td><td class="mdescRight">Inserts the site <code>s</code> in the segment Delaunay graph.  <br></td></tr>
<tr class="separator:aa9ab750a38b8acbe5c0bf9b7ae5b5125"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af0baf24d13f3c93f1e52a67599824406"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a9a7dbb0128a8b00322c23cbf930bcba9">Vertex_handle</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#af0baf24d13f3c93f1e52a67599824406">insert</a> (const <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a6f9279b27e0be7ee36cad459ed086075">Site_2</a> &amp;s, <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a9a7dbb0128a8b00322c23cbf930bcba9">Vertex_handle</a> vnear)</td></tr>
<tr class="memdesc:af0baf24d13f3c93f1e52a67599824406"><td class="mdescLeft"> </td><td class="mdescRight">Inserts <code>s</code> in the segment Delaunay graph using the site associated with <code>vnear</code> as an estimate for the nearest neighbor of <code>s</code>, if <code>s</code> is a point, or the first endpoint of <code>s</code>, if <code>s</code> is a segment.  <br></td></tr>
<tr class="separator:af0baf24d13f3c93f1e52a67599824406"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Nearest neighbor location</h2></td></tr>
<tr class="memitem:ab77199a11e58fa7af85c987e676aec59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a9a7dbb0128a8b00322c23cbf930bcba9">Vertex_handle</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#ab77199a11e58fa7af85c987e676aec59">nearest_neighbor</a> (const <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a74c365bebb7af7d301107ee94b650826">Point_2</a> &amp;p) const</td></tr>
<tr class="memdesc:ab77199a11e58fa7af85c987e676aec59"><td class="mdescLeft"> </td><td class="mdescRight">Finds the nearest neighbor of the point <code>p</code>.  <br></td></tr>
<tr class="separator:ab77199a11e58fa7af85c987e676aec59"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a96b4599afe601a7ef4aa1f1e1c70df52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a9a7dbb0128a8b00322c23cbf930bcba9">Vertex_handle</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a96b4599afe601a7ef4aa1f1e1c70df52">nearest_neighbor</a> (const <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a74c365bebb7af7d301107ee94b650826">Point_2</a> &amp;p, <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a9a7dbb0128a8b00322c23cbf930bcba9">Vertex_handle</a> vnear) const</td></tr>
<tr class="memdesc:a96b4599afe601a7ef4aa1f1e1c70df52"><td class="mdescLeft"> </td><td class="mdescRight">Finds the nearest neighbor of the point <code>p</code> using the site associated with <code>vnear</code> as an estimate for the nearest neighbor of <code>p</code>.  <br></td></tr>
<tr class="separator:a96b4599afe601a7ef4aa1f1e1c70df52"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">I/O</h2></td></tr>
<tr class="memitem:a5eb5a19db73870391d2a32ca3dd38e45"><td class="memTemplParams" colspan="2">template&lt;class Stream &gt; </td></tr>
<tr class="memitem:a5eb5a19db73870391d2a32ca3dd38e45"><td class="memTemplItemLeft" align="right" valign="top">Stream &amp; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a5eb5a19db73870391d2a32ca3dd38e45">draw_dual</a> (Stream &amp;str) const</td></tr>
<tr class="memdesc:a5eb5a19db73870391d2a32ca3dd38e45"><td class="mdescLeft"> </td><td class="mdescRight">Draws the segment Voronoi diagram to the stream <code>str</code>.  <br></td></tr>
<tr class="separator:a5eb5a19db73870391d2a32ca3dd38e45"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a453733666c46d66f87661df78febda65"><td class="memTemplParams" colspan="2">template&lt;class Stream &gt; </td></tr>
<tr class="memitem:a453733666c46d66f87661df78febda65"><td class="memTemplItemLeft" align="right" valign="top">Stream &amp; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a453733666c46d66f87661df78febda65">draw_skeleton</a> (Stream &amp;str) const</td></tr>
<tr class="memdesc:a453733666c46d66f87661df78febda65"><td class="mdescLeft"> </td><td class="mdescRight">Draws the segment Voronoi diagram to the stream <code>str</code>, except the edges of the diagram corresponding to a segment and its endpoints.  <br></td></tr>
<tr class="separator:a453733666c46d66f87661df78febda65"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8facf6d405b3ed9ff076f73e4a7d21c1"><td class="memTemplParams" colspan="2">template&lt;class Stream &gt; </td></tr>
<tr class="memitem:a8facf6d405b3ed9ff076f73e4a7d21c1"><td class="memTemplItemLeft" align="right" valign="top">Stream &amp; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a8facf6d405b3ed9ff076f73e4a7d21c1">draw_dual_edge</a> (<a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a961dd5d5acab82d04ab89ccb4c17ea93">Edge</a> e, Stream &amp;str) const</td></tr>
<tr class="memdesc:a8facf6d405b3ed9ff076f73e4a7d21c1"><td class="mdescLeft"> </td><td class="mdescRight">Draws the edge <code>e</code> of the segment Voronoi diagram to the stream <code>str</code>.  <br></td></tr>
<tr class="separator:a8facf6d405b3ed9ff076f73e4a7d21c1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a86f340cf1f7b5d26e1f2f520f9d8a745"><td class="memTemplParams" colspan="2">template&lt;class Stream &gt; </td></tr>
<tr class="memitem:a86f340cf1f7b5d26e1f2f520f9d8a745"><td class="memTemplItemLeft" align="right" valign="top">Stream &amp; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a86f340cf1f7b5d26e1f2f520f9d8a745">draw_dual_edge</a> (<a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a5cc24d678431de42b2577a7e20e8415d">Edge_circulator</a> ec, Stream &amp;str) const</td></tr>
<tr class="memdesc:a86f340cf1f7b5d26e1f2f520f9d8a745"><td class="mdescLeft"> </td><td class="mdescRight">Draws the edge <code>*ec</code> of the segment Voronoi diagram to the stream <code>str</code>.  <br></td></tr>
<tr class="separator:a86f340cf1f7b5d26e1f2f520f9d8a745"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afcc2a36040df3845d67e1d14a97563db"><td class="memTemplParams" colspan="2">template&lt;class Stream &gt; </td></tr>
<tr class="memitem:afcc2a36040df3845d67e1d14a97563db"><td class="memTemplItemLeft" align="right" valign="top">Stream &amp; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#afcc2a36040df3845d67e1d14a97563db">draw_dual_edge</a> (<a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a3cb65e75134b2279d0f31440d6c4825f">All_edges_iterator</a> eit, Stream &amp;str) const</td></tr>
<tr class="memdesc:afcc2a36040df3845d67e1d14a97563db"><td class="mdescLeft"> </td><td class="mdescRight">Draws the edge <code>*eit</code> of the segment Voronoi diagram to the stream <code>str</code>.  <br></td></tr>
<tr class="separator:afcc2a36040df3845d67e1d14a97563db"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9b8ca967333ff8fa4d244038c16048c5"><td class="memTemplParams" colspan="2">template&lt;class Stream &gt; </td></tr>
<tr class="memitem:a9b8ca967333ff8fa4d244038c16048c5"><td class="memTemplItemLeft" align="right" valign="top">Stream &amp; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a9b8ca967333ff8fa4d244038c16048c5">draw_dual_edge</a> (<a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a1386ae2da6e5328ba8e2fb4d7139bfcc">Finite_edges_iterator</a> eit, Stream &amp;str) const</td></tr>
<tr class="memdesc:a9b8ca967333ff8fa4d244038c16048c5"><td class="mdescLeft"> </td><td class="mdescRight">Draws the edge <code>*eit</code> of the segment Voronoi diagram to the stream <code>str</code>.  <br></td></tr>
<tr class="separator:a9b8ca967333ff8fa4d244038c16048c5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7ba8284bef9be9d3f69dc4416de35de1"><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a7ba8284bef9be9d3f69dc4416de35de1">file_output</a> (std::ostream &amp;os)</td></tr>
<tr class="memdesc:a7ba8284bef9be9d3f69dc4416de35de1"><td class="mdescLeft"> </td><td class="mdescRight">Writes the current state of the segment Delaunay graph to an output stream.  <br></td></tr>
<tr class="separator:a7ba8284bef9be9d3f69dc4416de35de1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac9d57105a6e48884fc75e484379d6738"><td class="memItemLeft" align="right" valign="top"><a id="ac9d57105a6e48884fc75e484379d6738" name="ac9d57105a6e48884fc75e484379d6738"></a>
void </td><td class="memItemRight" valign="bottom"><b>file_input</b> (std::istream &amp;is)</td></tr>
<tr class="memdesc:ac9d57105a6e48884fc75e484379d6738"><td class="mdescLeft"> </td><td class="mdescRight">Reads the state of the segment Delaunay graph from an input stream. <br></td></tr>
<tr class="separator:ac9d57105a6e48884fc75e484379d6738"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab507797fdc0b20ac27458c78269e2f35"><td class="memItemLeft" align="right" valign="top"><a id="ab507797fdc0b20ac27458c78269e2f35" name="ab507797fdc0b20ac27458c78269e2f35"></a>
std::ostream &amp; </td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html">Segment_Delaunay_graph_2</a>&lt; Gt, St, DS &gt; &amp;sdg)</td></tr>
<tr class="memdesc:ab507797fdc0b20ac27458c78269e2f35"><td class="mdescLeft"> </td><td class="mdescRight">Writes the current state of the segment Delaunay graph to an output stream. <br></td></tr>
<tr class="separator:ab507797fdc0b20ac27458c78269e2f35"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5f07981544edce9443b7d83fa8898964"><td class="memItemLeft" align="right" valign="top"><a id="a5f07981544edce9443b7d83fa8898964" name="a5f07981544edce9443b7d83fa8898964"></a>
std::istream &amp; </td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (std::istream &amp;is, <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html">Segment_Delaunay_graph_2</a>&lt; Gt, St, DS &gt; &amp;sdg)</td></tr>
<tr class="memdesc:a5f07981544edce9443b7d83fa8898964"><td class="mdescLeft"> </td><td class="mdescRight">Reads the state of the segment Delaunay graph from an input stream. <br></td></tr>
<tr class="separator:a5f07981544edce9443b7d83fa8898964"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Validity check</h2></td></tr>
<tr class="memitem:a85fc80cedd5a0bf144d95f1ee38e482d"><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a85fc80cedd5a0bf144d95f1ee38e482d">is_valid</a> (bool verbose=false, int level=1) const</td></tr>
<tr class="memdesc:a85fc80cedd5a0bf144d95f1ee38e482d"><td class="mdescLeft"> </td><td class="mdescRight">Checks the validity of the segment Delaunay graph.  <br></td></tr>
<tr class="separator:a85fc80cedd5a0bf144d95f1ee38e482d"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Miscellaneous</h2></td></tr>
<tr class="memitem:ad5602c6ee3823208254aeca3cfe6495b"><td class="memItemLeft" align="right" valign="top"><a id="ad5602c6ee3823208254aeca3cfe6495b" name="ad5602c6ee3823208254aeca3cfe6495b"></a>
void </td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="memdesc:ad5602c6ee3823208254aeca3cfe6495b"><td class="mdescLeft"> </td><td class="mdescRight">Clears all contents of the segment Delaunay graph. <br></td></tr>
<tr class="separator:ad5602c6ee3823208254aeca3cfe6495b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a78495715f959802e35edb86cdffe18ca"><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a78495715f959802e35edb86cdffe18ca">swap</a> (<a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html">Segment_Delaunay_graph_2</a>&lt; Gt, St, DS &gt; &amp;other)</td></tr>
<tr class="memdesc:a78495715f959802e35edb86cdffe18ca"><td class="mdescLeft"> </td><td class="mdescRight">The segment Delaunay graphs <code>other</code> and <code>*this</code> are swapped.  <br></td></tr>
<tr class="separator:a78495715f959802e35edb86cdffe18ca"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a961dd5d5acab82d04ab89ccb4c17ea93" name="a961dd5d5acab82d04ab89ccb4c17ea93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a961dd5d5acab82d04ab89ccb4c17ea93">◆ </a></span>Edge</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Gt , typename St , typename DS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef DS::Edge <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html">CGAL::Segment_Delaunay_graph_2</a>&lt; Gt, St, DS &gt;::Edge</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The edge type. </p>
<p>The <code><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a961dd5d5acab82d04ab89ccb4c17ea93" title="The edge type.">Edge(f,i)</a></code> is the edge common to faces <code>f</code> and <code>f.neighbor(i)</code>. It is also the edge joining the vertices <code>vertex(cw(i))</code> and <code>vertex(ccw(i))</code> of <code>f</code>. </p><dl class="section pre"><dt>Precondition</dt><dd><code>i</code> must be <code>0</code>, <code>1</code> or <code>2</code>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a77e6d212e45bbce3b3582c0ed49de4d5" name="a77e6d212e45bbce3b3582c0ed49de4d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77e6d212e45bbce3b3582c0ed49de4d5">◆ </a></span>Segment_Delaunay_graph_2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Gt , typename St , typename DS &gt; </div>
<div class="memtemplate">
template&lt;class Input_iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html">CGAL::Segment_Delaunay_graph_2</a>&lt; Gt, St, DS &gt;::Segment_Delaunay_graph_2 </td>
          <td>(</td>
          <td class="paramtype">Input_iterator </td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Input_iterator </td>
          <td class="paramname"><em>beyond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Gt </td>
          <td class="paramname"><em>gt</em> = <code>Gt()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">St </td>
          <td class="paramname"><em>gt</em> = <code>St()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the segment Delaunay graph using <code>gt</code> as geometric traits, <code>st</code> as storage traits, and inserts all sites in the range [<code>first</code>, <code>beyond</code>). </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>Input_iterator</code> must be a model of <code><a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a></code>. The value type of <code>Input_iterator</code> must be either <code><a class="elRef" href="../Kernel_23/classCGAL_1_1Point__2.html">Point_2</a></code> or <code>Site_2</code>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ace396a1db19375a56ab024daee16551c" name="ace396a1db19375a56ab024daee16551c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace396a1db19375a56ab024daee16551c">◆ </a></span>dimension()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Gt , typename St , typename DS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html">CGAL::Segment_Delaunay_graph_2</a>&lt; Gt, St, DS &gt;::dimension </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the dimension of the segment Delaunay graph. </p>
<p>The dimension is \( -1\) if the graph contains no sites, \( 0\) if the graph contains one site, \( 1\) if it contains two sites and \( 2\) if it contains three or more sites. </p>

</div>
</div>
<a id="a5eb5a19db73870391d2a32ca3dd38e45" name="a5eb5a19db73870391d2a32ca3dd38e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eb5a19db73870391d2a32ca3dd38e45">◆ </a></span>draw_dual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Gt , typename St , typename DS &gt; </div>
<div class="memtemplate">
template&lt;class Stream &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Stream &amp; <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html">CGAL::Segment_Delaunay_graph_2</a>&lt; Gt, St, DS &gt;::draw_dual </td>
          <td>(</td>
          <td class="paramtype">Stream &amp; </td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draws the segment Voronoi diagram to the stream <code>str</code>. </p>
<p>The following operators must be defined:</p>
<p><code>Stream&amp; operator&lt;&lt;(Stream&amp;, Gt::Segment_2)</code></p>
<p><code>Stream&amp; operator&lt;&lt;(Stream&amp;, Gt::Ray_2)</code></p>
<p><code>Stream&amp; operator&lt;&lt;(Stream&amp;, Gt::Line_2)</code> </p>

</div>
</div>
<a id="afcc2a36040df3845d67e1d14a97563db" name="afcc2a36040df3845d67e1d14a97563db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcc2a36040df3845d67e1d14a97563db">◆ </a></span>draw_dual_edge() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Gt , typename St , typename DS &gt; </div>
<div class="memtemplate">
template&lt;class Stream &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Stream &amp; <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html">CGAL::Segment_Delaunay_graph_2</a>&lt; Gt, St, DS &gt;::draw_dual_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a3cb65e75134b2279d0f31440d6c4825f">All_edges_iterator</a> </td>
          <td class="paramname"><em>eit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Stream &amp; </td>
          <td class="paramname"><em>str</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draws the edge <code>*eit</code> of the segment Voronoi diagram to the stream <code>str</code>. </p>
<p>The following operators must be defined:</p>
<p><code>Stream&amp; operator&lt;&lt;(Stream&amp;, Gt::Segment_2)</code></p>
<p><code>Stream&amp; operator&lt;&lt;(Stream&amp;, Gt::Ray_2)</code></p>
<p><code>Stream&amp; operator&lt;&lt;(Stream&amp;, Gt::Line_2)</code> </p><dl class="section pre"><dt>Precondition</dt><dd><code>*eit</code> must be a finite edge. </dd></dl>

</div>
</div>
<a id="a8facf6d405b3ed9ff076f73e4a7d21c1" name="a8facf6d405b3ed9ff076f73e4a7d21c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8facf6d405b3ed9ff076f73e4a7d21c1">◆ </a></span>draw_dual_edge() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Gt , typename St , typename DS &gt; </div>
<div class="memtemplate">
template&lt;class Stream &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Stream &amp; <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html">CGAL::Segment_Delaunay_graph_2</a>&lt; Gt, St, DS &gt;::draw_dual_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a961dd5d5acab82d04ab89ccb4c17ea93">Edge</a> </td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Stream &amp; </td>
          <td class="paramname"><em>str</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draws the edge <code>e</code> of the segment Voronoi diagram to the stream <code>str</code>. </p>
<p>The following operators must be defined:</p>
<p><code>Stream&amp; operator&lt;&lt;(Stream&amp;, Gt::Segment_2)</code></p>
<p><code>Stream&amp; operator&lt;&lt;(Stream&amp;, Gt::Ray_2)</code></p>
<p><code>Stream&amp; operator&lt;&lt;(Stream&amp;, Gt::Line_2)</code> </p><dl class="section pre"><dt>Precondition</dt><dd><code>e</code> must be a finite edge. </dd></dl>

</div>
</div>
<a id="a86f340cf1f7b5d26e1f2f520f9d8a745" name="a86f340cf1f7b5d26e1f2f520f9d8a745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86f340cf1f7b5d26e1f2f520f9d8a745">◆ </a></span>draw_dual_edge() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Gt , typename St , typename DS &gt; </div>
<div class="memtemplate">
template&lt;class Stream &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Stream &amp; <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html">CGAL::Segment_Delaunay_graph_2</a>&lt; Gt, St, DS &gt;::draw_dual_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a5cc24d678431de42b2577a7e20e8415d">Edge_circulator</a> </td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Stream &amp; </td>
          <td class="paramname"><em>str</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draws the edge <code>*ec</code> of the segment Voronoi diagram to the stream <code>str</code>. </p>
<p>The following operators must be defined:</p>
<p><code>Stream&amp; operator&lt;&lt;(Stream&amp;, Gt::Segment_2)</code></p>
<p><code>Stream&amp; operator&lt;&lt;(Stream&amp;, Gt::Ray_2)</code></p>
<p><code>Stream&amp; operator&lt;&lt;(Stream&amp;, Gt::Line_2)</code> </p><dl class="section pre"><dt>Precondition</dt><dd><code>*ec</code> must be a finite edge. </dd></dl>

</div>
</div>
<a id="a9b8ca967333ff8fa4d244038c16048c5" name="a9b8ca967333ff8fa4d244038c16048c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b8ca967333ff8fa4d244038c16048c5">◆ </a></span>draw_dual_edge() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Gt , typename St , typename DS &gt; </div>
<div class="memtemplate">
template&lt;class Stream &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Stream &amp; <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html">CGAL::Segment_Delaunay_graph_2</a>&lt; Gt, St, DS &gt;::draw_dual_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a1386ae2da6e5328ba8e2fb4d7139bfcc">Finite_edges_iterator</a> </td>
          <td class="paramname"><em>eit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Stream &amp; </td>
          <td class="paramname"><em>str</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draws the edge <code>*eit</code> of the segment Voronoi diagram to the stream <code>str</code>. </p>
<p>The following operators must be defined:</p>
<p><code>Stream&amp; operator&lt;&lt;(Stream&amp;, Gt::Segment_2)</code></p>
<p><code>Stream&amp; operator&lt;&lt;(Stream&amp;, Gt::Ray_2)</code></p>
<p><code>Stream&amp; operator&lt;&lt;(Stream&amp;, Gt::Line_2)</code> </p>

</div>
</div>
<a id="a453733666c46d66f87661df78febda65" name="a453733666c46d66f87661df78febda65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a453733666c46d66f87661df78febda65">◆ </a></span>draw_skeleton()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Gt , typename St , typename DS &gt; </div>
<div class="memtemplate">
template&lt;class Stream &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Stream &amp; <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html">CGAL::Segment_Delaunay_graph_2</a>&lt; Gt, St, DS &gt;::draw_skeleton </td>
          <td>(</td>
          <td class="paramtype">Stream &amp; </td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draws the segment Voronoi diagram to the stream <code>str</code>, except the edges of the diagram corresponding to a segment and its endpoints. </p>
<p>The following operators must be defined:</p>
<p><code>Stream&amp; operator&lt;&lt;(Stream&amp;, Gt::Segment_2)</code></p>
<p><code>Stream&amp; operator&lt;&lt;(Stream&amp;, Gt::Ray_2)</code></p>
<p><code>Stream&amp; operator&lt;&lt;(Stream&amp;, Gt::Line_2)</code> </p>

</div>
</div>
<a id="a7ba8284bef9be9d3f69dc4416de35de1" name="a7ba8284bef9be9d3f69dc4416de35de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ba8284bef9be9d3f69dc4416de35de1">◆ </a></span>file_output()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Gt , typename St , typename DS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html">CGAL::Segment_Delaunay_graph_2</a>&lt; Gt, St, DS &gt;::file_output </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp; </td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the current state of the segment Delaunay graph to an output stream. </p>
<p>In particular, all sites in the diagram are written to the stream (represented through appropriate input sites), as well as the underlying combinatorial data structure. </p>

</div>
</div>
<a id="a32a4f10cc2ccb876c82ac669fa80701e" name="a32a4f10cc2ccb876c82ac669fa80701e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32a4f10cc2ccb876c82ac669fa80701e">◆ </a></span>finite_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Gt , typename St , typename DS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a9a7dbb0128a8b00322c23cbf930bcba9">Vertex_handle</a> <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html">CGAL::Segment_Delaunay_graph_2</a>&lt; Gt, St, DS &gt;::finite_vertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vertex distinct from the <code>infinite_vertex</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The number of sites in the segment Delaunay graph must be at least one. </dd></dl>

</div>
</div>
<a id="a4c916443215b0386f988f4822398161c" name="a4c916443215b0386f988f4822398161c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c916443215b0386f988f4822398161c">◆ </a></span>incident_edges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Gt , typename St , typename DS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a5cc24d678431de42b2577a7e20e8415d">Edge_circulator</a> <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html">CGAL::Segment_Delaunay_graph_2</a>&lt; Gt, St, DS &gt;::incident_edges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a9a7dbb0128a8b00322c23cbf930bcba9">Vertex_handle</a> </td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#aabcdc2d8f964ce64286285efd7b1fcc1">Face_handle</a> </td>
          <td class="paramname"><em>f</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts at the first edge of <code>f</code> incident to <code>v</code>, in counterclockwise order around <code>v</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Face <code>f</code> is incident to vertex <code>v</code>. </dd></dl>

</div>
</div>
<a id="a72357ff62983e5e7da76ab88e8d4ca27" name="a72357ff62983e5e7da76ab88e8d4ca27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72357ff62983e5e7da76ab88e8d4ca27">◆ </a></span>incident_faces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Gt , typename St , typename DS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a70303659970be1b00476db944ab9d312">Face_circulator</a> <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html">CGAL::Segment_Delaunay_graph_2</a>&lt; Gt, St, DS &gt;::incident_faces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a9a7dbb0128a8b00322c23cbf930bcba9">Vertex_handle</a> </td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#aabcdc2d8f964ce64286285efd7b1fcc1">Face_handle</a> </td>
          <td class="paramname"><em>f</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts at face <code>f</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Face <code>f</code> is incident to vertex <code>v</code>. </dd></dl>

</div>
</div>
<a id="a694dfb542456d0aa2186fa60245418a8" name="a694dfb542456d0aa2186fa60245418a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a694dfb542456d0aa2186fa60245418a8">◆ </a></span>incident_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Gt , typename St , typename DS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a546dc147bdd1a3071f3030912520c6b2">Vertex_circulator</a> <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html">CGAL::Segment_Delaunay_graph_2</a>&lt; Gt, St, DS &gt;::incident_vertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a9a7dbb0128a8b00322c23cbf930bcba9">Vertex_handle</a> </td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#aabcdc2d8f964ce64286285efd7b1fcc1">Face_handle</a> </td>
          <td class="paramname"><em>f</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts at the first vertex of <code>f</code> adjacent to <code>v</code> in counterclockwise order around <code>v</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Face <code>f</code> is incident to vertex <code>v</code>. </dd></dl>

</div>
</div>
<a id="a0e5ac3c19398daedfe871fdacd63b728" name="a0e5ac3c19398daedfe871fdacd63b728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e5ac3c19398daedfe871fdacd63b728">◆ </a></span>insert() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Gt , typename St , typename DS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a9a7dbb0128a8b00322c23cbf930bcba9">Vertex_handle</a> <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html">CGAL::Segment_Delaunay_graph_2</a>&lt; Gt, St, DS &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a74c365bebb7af7d301107ee94b650826">Point_2</a> &amp; </td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the point <code>p</code> in the segment Delaunay graph. </p>
<p>If <code>p</code> has already been inserted, then the vertex handle of its already inserted copy is returned. If <code>p</code> has not been inserted yet, the vertex handle of <code>p</code> is returned. </p>

</div>
</div>
<a id="a5f787c033d11114a86ca3877b02c9033" name="a5f787c033d11114a86ca3877b02c9033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f787c033d11114a86ca3877b02c9033">◆ </a></span>insert() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Gt , typename St , typename DS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a9a7dbb0128a8b00322c23cbf930bcba9">Vertex_handle</a> <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html">CGAL::Segment_Delaunay_graph_2</a>&lt; Gt, St, DS &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a74c365bebb7af7d301107ee94b650826">Point_2</a> &amp; </td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a9a7dbb0128a8b00322c23cbf930bcba9">Vertex_handle</a> </td>
          <td class="paramname"><em>vnear</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts <code>p</code> in the segment Delaunay graph using the site associated with <code>vnear</code> as an estimate for the nearest neighbor of <code>p</code>. </p>
<p>The vertex handle returned has the same semantics as the vertex handle returned by the method <code>Vertex_handle insert(Point_2 p)</code>. </p>

</div>
</div>
<a id="ab092560ed8f6186ec7ed5e819366f9e4" name="ab092560ed8f6186ec7ed5e819366f9e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab092560ed8f6186ec7ed5e819366f9e4">◆ </a></span>insert() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Gt , typename St , typename DS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a9a7dbb0128a8b00322c23cbf930bcba9">Vertex_handle</a> <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html">CGAL::Segment_Delaunay_graph_2</a>&lt; Gt, St, DS &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a74c365bebb7af7d301107ee94b650826">Point_2</a> &amp; </td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a74c365bebb7af7d301107ee94b650826">Point_2</a> &amp; </td>
          <td class="paramname"><em>p2</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the closed segment with endpoints <code>p1</code> and <code>p2</code> in the segment Delaunay graph. </p>
<p>If the segment has already been inserted in the Delaunay graph then the vertex handle of its already inserted copy is returned. If the segment does not intersect any segment in the existing diagram, the vertex handle corresponding to its corresponding open segment is returned. Finally, if the segment intersects other segments in the existing Delaunay graph, the vertex handle to one of its open subsegments is returned. </p>

</div>
</div>
<a id="a9be228deffb2ec2a3a799b33e4216b46" name="a9be228deffb2ec2a3a799b33e4216b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be228deffb2ec2a3a799b33e4216b46">◆ </a></span>insert() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Gt , typename St , typename DS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a9a7dbb0128a8b00322c23cbf930bcba9">Vertex_handle</a> <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html">CGAL::Segment_Delaunay_graph_2</a>&lt; Gt, St, DS &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a74c365bebb7af7d301107ee94b650826">Point_2</a> &amp; </td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a74c365bebb7af7d301107ee94b650826">Point_2</a> &amp; </td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a9a7dbb0128a8b00322c23cbf930bcba9">Vertex_handle</a> </td>
          <td class="paramname"><em>vnear</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the segment whose endpoints are <code>p1</code> and <code>p2</code> in the segment Delaunay graph using the site associated with <code>vnear</code> as an estimate for the nearest neighbor of <code>p1</code>. </p>
<p>The vertex handle returned has the same semantics as the vertex handle returned by the method <code>Vertex_handle insert(Point_2 p1, Point_2 p2)</code>. </p>

</div>
</div>
<a id="aa9ab750a38b8acbe5c0bf9b7ae5b5125" name="aa9ab750a38b8acbe5c0bf9b7ae5b5125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ab750a38b8acbe5c0bf9b7ae5b5125">◆ </a></span>insert() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Gt , typename St , typename DS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a9a7dbb0128a8b00322c23cbf930bcba9">Vertex_handle</a> <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html">CGAL::Segment_Delaunay_graph_2</a>&lt; Gt, St, DS &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a6f9279b27e0be7ee36cad459ed086075">Site_2</a> &amp; </td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the site <code>s</code> in the segment Delaunay graph. </p>
<p>The vertex handle returned has the same semantics as the vertex handle returned by the methods <code>Vertex_handle insert(Point_2 p)</code> and <code>Vertex_handle insert(Point_2 p1, Point_2 p2)</code>, depending on whether <code>s</code> represents a point or a segment respectively. </p><dl class="section pre"><dt>Precondition</dt><dd><code>s.is_input()</code> must be <code>true</code>. </dd></dl>

</div>
</div>
<a id="af0baf24d13f3c93f1e52a67599824406" name="af0baf24d13f3c93f1e52a67599824406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0baf24d13f3c93f1e52a67599824406">◆ </a></span>insert() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Gt , typename St , typename DS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a9a7dbb0128a8b00322c23cbf930bcba9">Vertex_handle</a> <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html">CGAL::Segment_Delaunay_graph_2</a>&lt; Gt, St, DS &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a6f9279b27e0be7ee36cad459ed086075">Site_2</a> &amp; </td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a9a7dbb0128a8b00322c23cbf930bcba9">Vertex_handle</a> </td>
          <td class="paramname"><em>vnear</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts <code>s</code> in the segment Delaunay graph using the site associated with <code>vnear</code> as an estimate for the nearest neighbor of <code>s</code>, if <code>s</code> is a point, or the first endpoint of <code>s</code>, if <code>s</code> is a segment. </p>
<p>The vertex handle returned has the same semantics as the vertex handle returned by the method <code>Vertex_handle insert(Site_2 s)</code>. </p><dl class="section pre"><dt>Precondition</dt><dd><code>s.is_input()</code> must be <code>true</code>. </dd></dl>

</div>
</div>
<a id="accb50cf54c7c8dcc93e643a67fe81891" name="accb50cf54c7c8dcc93e643a67fe81891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accb50cf54c7c8dcc93e643a67fe81891">◆ </a></span>insert() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Gt , typename St , typename DS &gt; </div>
<div class="memtemplate">
template&lt;class Input_iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#ab93ec2700dd54a3dc52c8c658e540cf6">size_type</a> <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html">CGAL::Segment_Delaunay_graph_2</a>&lt; Gt, St, DS &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">Input_iterator </td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Input_iterator </td>
          <td class="paramname"><em>beyond</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iteratively inserts the sites in the range [<code>first</code>,<code>beyond</code>). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Input_iterator</td><td>must be a model of <code><a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a></code> and its value type must be either <code><a class="elRef" href="../Kernel_23/classCGAL_1_1Point__2.html">Point_2</a></code> or <code>Site_2</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of sites inserted in the Delaunay graph </dd></dl>

</div>
</div>
<a id="a4c38d30277b965be645f8b3b11bba92d" name="a4c38d30277b965be645f8b3b11bba92d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c38d30277b965be645f8b3b11bba92d">◆ </a></span>insert() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Gt , typename St , typename DS &gt; </div>
<div class="memtemplate">
template&lt;class Input_iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#ab93ec2700dd54a3dc52c8c658e540cf6">size_type</a> <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html">CGAL::Segment_Delaunay_graph_2</a>&lt; Gt, St, DS &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">Input_iterator </td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Input_iterator </td>
          <td class="paramname"><em>beyond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../STL_Extension/group__PkgSTLExtensionUtilities.html#ga89d5ecf1540b2ec0a2bf5dd003e186d0">CGAL::Tag_false</a> </td>
          <td class="paramname"> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iteratively inserts the sites in the range [<code>first</code>,<code>beyond</code>). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Input_iterator</td><td>must be a model of <code><a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a></code> and its value type must be either <code><a class="elRef" href="../Kernel_23/classCGAL_1_1Point__2.html">Point_2</a></code> or <code>Site_2</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of sites inserted in the Delaunay graph </dd></dl>

</div>
</div>
<a id="af95131302a9b3ae34940f1026658c177" name="af95131302a9b3ae34940f1026658c177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af95131302a9b3ae34940f1026658c177">◆ </a></span>insert() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Gt , typename St , typename DS &gt; </div>
<div class="memtemplate">
template&lt;class Input_iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#ab93ec2700dd54a3dc52c8c658e540cf6">size_type</a> <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html">CGAL::Segment_Delaunay_graph_2</a>&lt; Gt, St, DS &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">Input_iterator </td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Input_iterator </td>
          <td class="paramname"><em>beyond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../STL_Extension/group__PkgSTLExtensionUtilities.html#gab3e2296107b5d26c32c8183028a217f1">CGAL::Tag_true</a> </td>
          <td class="paramname"> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decomposes the range [first,beyond) into a range of input points and a range of input segments that are respectively passed to <code><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#aac42f0ea4bf167a0a09154acd6391cb1" title="Inserts the segments in the range [first,beyond) as sites.">insert_segments()</a></code> and <code><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#af34c5b5476782bfeab3065fd7cb843fd" title="Inserts the points in the range [first,beyond) as sites.">insert_points()</a></code>. </p>
<p>Non-input sites are first random_shuffled and then inserted one by one. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Input_iterator</td><td>must be a model of <code><a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a></code> and its value type must be either <code><a class="elRef" href="../Kernel_23/classCGAL_1_1Point__2.html">Point_2</a></code>, <code><a class="elRef" href="../Kernel_23/classCGAL_1_1Segment__2.html">Segment_2</a></code> or <code>Site_2</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of sites inserted in the Delaunay graph </dd></dl>

</div>
</div>
<a id="af34c5b5476782bfeab3065fd7cb843fd" name="af34c5b5476782bfeab3065fd7cb843fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34c5b5476782bfeab3065fd7cb843fd">◆ </a></span>insert_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Gt , typename St , typename DS &gt; </div>
<div class="memtemplate">
template&lt;class PointIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html">CGAL::Segment_Delaunay_graph_2</a>&lt; Gt, St, DS &gt;::insert_points </td>
          <td>(</td>
          <td class="paramtype">PointIterator </td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointIterator </td>
          <td class="paramname"><em>beyond</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the points in the range [first,beyond) as sites. </p>
<p>Note that this function is not guaranteed to insert the points following the order of <code>PointInputIterator</code>, as <code>spatial_sort()</code> is used to improve efficiency. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointIterator</td><td>must be an input iterator <code><a class="elRef" href="../Kernel_23/classCGAL_1_1Point__2.html">Point_2</a></code> or <code>Site_2</code> as value_type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of points inserted in the Delaunay graph </dd></dl>

</div>
</div>
<a id="a21f1ac813bf15063da2c2ecbcdf30daa" name="a21f1ac813bf15063da2c2ecbcdf30daa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f1ac813bf15063da2c2ecbcdf30daa">◆ </a></span>insert_segments() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Gt , typename St , typename DS &gt; </div>
<div class="memtemplate">
template&lt;class PointIterator , class IndicesIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html">CGAL::Segment_Delaunay_graph_2</a>&lt; Gt, St, DS &gt;::insert_segments </td>
          <td>(</td>
          <td class="paramtype">PointIterator </td>
          <td class="paramname"><em>points_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointIterator </td>
          <td class="paramname"><em>points_beyond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndicesIterator </td>
          <td class="paramname"><em>indices_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndicesIterator </td>
          <td class="paramname"><em>indices_beyond</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as above except that each segment is given as a pair of indices of the points in the range [points_first, points_beyond). </p>
<p>The indices must start from 0 to <code>std::distance(points_first, points_beyond)</code> </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointIterator</td><td>is an input iterator with <code><a class="elRef" href="../Kernel_23/classCGAL_1_1Point__2.html">Point_2</a></code> as value type. </td></tr>
    <tr><td class="paramname">IndicesIterator</td><td>is an input iterator with <code>std::pair&lt;std::size_t, std::size_t&gt;</code> as value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of segments inserted in the Delaunay graph </dd></dl>

</div>
</div>
<a id="aac42f0ea4bf167a0a09154acd6391cb1" name="aac42f0ea4bf167a0a09154acd6391cb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac42f0ea4bf167a0a09154acd6391cb1">◆ </a></span>insert_segments() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Gt , typename St , typename DS &gt; </div>
<div class="memtemplate">
template&lt;class SegmentIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html">CGAL::Segment_Delaunay_graph_2</a>&lt; Gt, St, DS &gt;::insert_segments </td>
          <td>(</td>
          <td class="paramtype">SegmentIterator </td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SegmentIterator </td>
          <td class="paramname"><em>beyond</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the segments in the range [first,beyond) as sites. </p>
<p>Note that this function is not guaranteed to insert the segments following the order of <code>SegmentIterator</code>, as <code>spatial_sort()</code> is used to improve efficiency. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SegmentIterator</td><td>must be an input iterator with <code>Site_2</code>, <code><a class="elRef" href="../Kernel_23/classCGAL_1_1Segment__2.html">Segment_2</a></code> or <code>std::pair&lt;<a class="elRef" href="../Kernel_23/classCGAL_1_1Point__2.html">Point_2</a>,<a class="elRef" href="../Kernel_23/classCGAL_1_1Point__2.html">Point_2</a>&gt;</code> as value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of segments inserted in the Delaunay graph </dd></dl>

</div>
</div>
<a id="a85fc80cedd5a0bf144d95f1ee38e482d" name="a85fc80cedd5a0bf144d95f1ee38e482d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85fc80cedd5a0bf144d95f1ee38e482d">◆ </a></span>is_valid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Gt , typename St , typename DS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html">CGAL::Segment_Delaunay_graph_2</a>&lt; Gt, St, DS &gt;::is_valid </td>
          <td>(</td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>verbose</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>level</em> = <code>1</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the validity of the segment Delaunay graph. </p>
<p>If <code>verbose</code> is <code>true</code> a short message is sent to <code>std::cerr</code>. If <code>level</code> is 0, only the data structure is validated. If <code>level</code> is 1, then both the data structure and the segment Delaunay graph are validated. Negative values of <code>level</code> always return true, and values greater than 1 are equivalent to <code>level</code> being 1. </p>

</div>
</div>
<a id="ab77199a11e58fa7af85c987e676aec59" name="ab77199a11e58fa7af85c987e676aec59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab77199a11e58fa7af85c987e676aec59">◆ </a></span>nearest_neighbor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Gt , typename St , typename DS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a9a7dbb0128a8b00322c23cbf930bcba9">Vertex_handle</a> <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html">CGAL::Segment_Delaunay_graph_2</a>&lt; Gt, St, DS &gt;::nearest_neighbor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a74c365bebb7af7d301107ee94b650826">Point_2</a> &amp; </td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the nearest neighbor of the point <code>p</code>. </p>
<p>In other words it finds the site whose segment Voronoi diagram cell contains <code>p</code>. Ties are broken arbitrarily and one of the nearest neighbors of <code>p</code> is returned. If there are no sites in the segment Delaunay graph <code><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a9a7dbb0128a8b00322c23cbf930bcba9" title="Type for a handle to a vertex.">Vertex_handle()</a></code> is returned. </p>

</div>
</div>
<a id="a96b4599afe601a7ef4aa1f1e1c70df52" name="a96b4599afe601a7ef4aa1f1e1c70df52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96b4599afe601a7ef4aa1f1e1c70df52">◆ </a></span>nearest_neighbor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Gt , typename St , typename DS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a9a7dbb0128a8b00322c23cbf930bcba9">Vertex_handle</a> <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html">CGAL::Segment_Delaunay_graph_2</a>&lt; Gt, St, DS &gt;::nearest_neighbor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a74c365bebb7af7d301107ee94b650826">Point_2</a> &amp; </td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a9a7dbb0128a8b00322c23cbf930bcba9">Vertex_handle</a> </td>
          <td class="paramname"><em>vnear</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the nearest neighbor of the point <code>p</code> using the site associated with <code>vnear</code> as an estimate for the nearest neighbor of <code>p</code>. </p>
<p>Ties are broken arbitrarily and one of the nearest neighbors of <code>p</code> is returned. If there are no sites in the segment Delaunay graph <code><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a9a7dbb0128a8b00322c23cbf930bcba9" title="Type for a handle to a vertex.">Vertex_handle()</a></code> is returned. </p>

</div>
</div>
<a id="a110e6a2e70491ffe5109b8f128999e60" name="a110e6a2e70491ffe5109b8f128999e60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a110e6a2e70491ffe5109b8f128999e60">◆ </a></span>number_of_output_sites()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Gt , typename St , typename DS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#ab93ec2700dd54a3dc52c8c658e540cf6">size_type</a> <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html">CGAL::Segment_Delaunay_graph_2</a>&lt; Gt, St, DS &gt;::number_of_output_sites </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of output sites. </p>
<p>This is equal to the number of vertices in the segment Delaunay graph. </p>

</div>
</div>
<a id="a78495715f959802e35edb86cdffe18ca" name="a78495715f959802e35edb86cdffe18ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78495715f959802e35edb86cdffe18ca">◆ </a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Gt , typename St , typename DS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html">CGAL::Segment_Delaunay_graph_2</a>&lt; Gt, St, DS &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html">Segment_Delaunay_graph_2</a>&lt; Gt, St, DS &gt; &amp; </td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The segment Delaunay graphs <code>other</code> and <code>*this</code> are swapped. </p>
<p>For a segment Delaunay graph <code>sdg</code>, the operation <code>sdg</code>.<code>swap(other)</code> should be preferred to <code>sdg</code><code>= other</code> or to <code>sdg</code><code>(other)</code> if <code>other</code> is deleted afterwards. </p>

</div>
</div>
<a id="aa681252013b753e58d3f3864ec5e390f" name="aa681252013b753e58d3f3864ec5e390f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa681252013b753e58d3f3864ec5e390f">◆ </a></span>tds()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Gt , typename St , typename DS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a644b112649bab16159b430ae4932c1ab">Data_structure</a> &amp; <a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html">CGAL::Segment_Delaunay_graph_2</a>&lt; Gt, St, DS &gt;::tds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <code><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html#a3c5ab5beb60cc7c50ea4841e5108b087" title="Returns a reference to the segment Delaunay graph data structure object.">data_structure()</a></code>. </p>
<p>It has been added for compliance to the <code><a class="elRef" href="../Voronoi_diagram_2/classDelaunayGraph__2.html">DelaunayGraph_2</a></code> concept. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>CGAL</b></li><li class="navelem"><a class="el" href="classCGAL_1_1Segment__Delaunay__graph__2.html">Segment_Delaunay_graph_2</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"></a> 1.9.6 </li>
  </ul>
</div>
</div>
</body>



</html>
