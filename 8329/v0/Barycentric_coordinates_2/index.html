<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Barycentric_coordinates_2/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=11">
<meta name="generator" content="Doxygen 1.9.6">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CGAL 6.1 - 2D Generalized Barycentric Coordinates: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/doxygen.css" rel="stylesheet" type="text/css">
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      },
      equationNumbers: { autoNumber: "AMS" }
  }
}
);
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<script src="modules.js" type="text/javascript"></script>
<link href="cgal_stylesheet.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
      <span class="left">
         <span id="MSearchSelect" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()">Â 
        </span>
        <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
      </span>
      <span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.svg" alt=""></a>
      </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CGAL 6.1 - 2D Generalized Barycentric Coordinates
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search/",'.html');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">User Manual </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_2D_Generalized_Barycentric_Coordinates"></a></p> <div id="autotoc" class="toc"></div> <dl class="section author"><dt>Authors</dt><dd>Dmitry Anisimov, David Bommes, Kai Hormann, and Pierre Alliez</dd></dl>
<h1><a class="anchor" id="gbc_introduction"></a>
Introduction</h1>
<p>Barycentric coordinates are widely used in computer graphics and computational mechanics to determine a position of a point in the plane with respect to a triangle. These coordinates have been later generalized to support simple polygons in 2D and polyhedra in 3D.</p>
<p>This package offers an efficient and robust implementation of 2D generalized barycentric coordinates defined for simple polygons in the plane. If coordinates with respect to multivariate scattered points instead of a polygon are required, please refer to natural neighbor coordinates from the package <a class="elRef" href="../Interpolation/index.html#chapinterpolation">2D and Surface Function Interpolation</a>.</p>
<p>In particular, this package includes an implementation of <a class="el" href="index.html#wp_example">Wachspress</a>, <a class="el" href="index.html#dh_example">discrete harmonic</a>, <a class="el" href="index.html#mv_example">mean value</a>, and <a class="el" href="index.html#hm_example">harmonic</a> coordinates, and provides some extra functions to compute barycentric coordinates with respect to <a class="el" href="index.html#seg_example">segments</a> and <a class="el" href="index.html#tri_example">triangles</a>.</p>
<p><a class="anchor" id="fig__overview"></a> </p><div class="image">
<object type="image/svg+xml" data="overview.svg" style="pointer-events: none;"></object>
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__overview">Figure 104.1</a> Wachspress (WP), discrete harmonic (DH), mean value (MV), and harmonic (HM) coordinate functions for a convex polygon plotted with respect to the marked vertex. </p> </div> <p> <br>
</p>
<h1><a class="anchor" id="gbc_interface"></a>
Software Design</h1>
<p>Mean value and harmonic coordinates are the most generic coordinates in this package, because they allow an arbitrary simple polygon as input. Wachspress and discrete harmonic coordinates are, by definition, limited to strictly convex polygons. Segment coordinates take as input any non-degenerate segment, and triangle coordinates allow an arbitrary non-degenerate triangle.</p>
<p>Wachspress, discrete harmonic, mean value, and harmonic coordinates are all generalized barycentric coordinates. However, while Wachspress, discrete harmonic, and mean value coordinates can be computed analytically, harmonic coordinates cannot. They first need to be approximated over a triangulation of the interior part of the polygon. Once approximated, they can be evaluated analytically at any point inside the polygon.</p>
<p>For all analytic coordinates, we provide two algorithms. One has a linear time complexity, but may suffer imprecisions near the polygon boundary, while the second one is precise but has a quadratic time complexity. The user can choose the preferred algorithm by specifying a computation policy <code><a class="el" href="namespaceCGAL_1_1Barycentric__coordinates.html#a478bbcec416216b2274ee4b4e97b0e6c" title="Computation_policy_2 provides a way to choose an asymptotic time complexity of the algorithm and its ...">Barycentric_coordinates::Computation_policy_2</a></code>.</p>
<p>All analytic barycentric coordinates for polygons can be computed either by instantiating a class or through one of the free functions. Harmonic coordinates can be computed only by instantiating a class that must be parameterized by a model of the concept <code><a class="el" href="classCGAL_1_1Barycentric__coordinates_1_1DiscretizedDomain__2.html" title="A concept that describes the set of methods that should be defined for all discretized domains obtain...">DiscretizedDomain_2</a></code>. Segment and triangle coordinates can be computed only through the free functions. For more information see the <a class="el" href="group__PkgBarycentricCoordinates2Ref.html">Reference Manual</a>.</p>
<p>Any point in the plane may be taken as a query point. However, we do not recommend using Wachspress and discrete harmonic coordinates with query points outside the closure of a polygon, because they are not well-defined for some of these points. The same holds for harmonic coordinates, which are not defined everywhere outside the polygon. For more information see Section <a class="el" href="index.html#gbc_degeneracies">Edge Cases</a>.</p>
<p>The output of the computation is a set of coordinate values at the given query point with respect to the polygon vertices. That means that the number of returned coordinates per query point equates the number of polygon vertices. The ordering of the coordinates is the same as the ordering of polygon vertices.</p>
<p>All class and function templates are parameterized by a traits class, which is a model of the concept <code><a class="el" href="classCGAL_1_1Barycentric__coordinates_1_1BarycentricTraits__2.html" title="A concept that describes the set of requirements of the template parameter GeomTraits used to paramet...">BarycentricTraits_2</a></code>. It provides all necessary geometric primitives, predicates, and constructions, which are required for the computation. All models of <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> can be used. A polygon is provided as a range of vertices with a <a class="elRef" href="../Property_map/group__PkgPropertyMapRef.html">property map</a> that maps a vertex from the polygon to <code><a class="elRef" href="../Kernel_23/classCGAL_1_1Point__2.html">CGAL::Point_2</a></code>.</p>
<p>If you do not know which coordinate function best fits your application, you can address the table below for some advise.</p>
<table class="markdownTable" align="center">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Coordinates </th><th class="markdownTableHeadCenter">Properties </th><th class="markdownTableHeadCenter">Valid domain </th><th class="markdownTableHeadCenter">Closed form </th><th class="markdownTableHeadCenter">Queries </th><th class="markdownTableHeadCenter">Speed  </th></tr>
<tr class="markdownTableBody">
<td class="markdownTableBodyCenter">Segment </td><td class="markdownTableBodyCenter">All </td><td class="markdownTableBodyCenter">2D non-degenerate segments </td><td class="markdownTableBodyCenter">Yes </td><td class="markdownTableBodyCenter">Everywhere on the supporting line </td><td class="markdownTableBodyCenter">+++  </td></tr>
<tr class="markdownTableBody">
<td class="markdownTableBodyCenter">Triangle </td><td class="markdownTableBodyCenter">All </td><td class="markdownTableBodyCenter">2D non-degenerate triangles </td><td class="markdownTableBodyCenter">Yes </td><td class="markdownTableBodyCenter">Everywhere in 2D </td><td class="markdownTableBodyCenter">+++  </td></tr>
<tr class="markdownTableBody">
<td class="markdownTableBodyCenter">Discrete harmonic </td><td class="markdownTableBodyCenter">May be negative </td><td class="markdownTableBodyCenter">Strongly convex polygons </td><td class="markdownTableBodyCenter">Yes </td><td class="markdownTableBodyCenter">Everywhere inside the polygon </td><td class="markdownTableBodyCenter">++  </td></tr>
<tr class="markdownTableBody">
<td class="markdownTableBodyCenter">Wachspress </td><td class="markdownTableBodyCenter">All </td><td class="markdownTableBodyCenter">Strongly convex polygons </td><td class="markdownTableBodyCenter">Yes </td><td class="markdownTableBodyCenter">Everywhere inside the polygon </td><td class="markdownTableBodyCenter">++  </td></tr>
<tr class="markdownTableBody">
<td class="markdownTableBodyCenter">Mean value </td><td class="markdownTableBodyCenter">May be negative </td><td class="markdownTableBodyCenter">Simple polygons </td><td class="markdownTableBodyCenter">Yes </td><td class="markdownTableBodyCenter">Everywhere in 2D </td><td class="markdownTableBodyCenter">++  </td></tr>
<tr class="markdownTableBody">
<td class="markdownTableBodyCenter">Harmonic </td><td class="markdownTableBodyCenter">All </td><td class="markdownTableBodyCenter">Simple polygons </td><td class="markdownTableBodyCenter">No </td><td class="markdownTableBodyCenter">Everywhere inside the polygon </td><td class="markdownTableBodyCenter">+  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>This is the second version of the package with the modified and improved API. The package still supports the old API. See more details <a class="el" href="index.html#depr_example">here</a>.</dd></dl>
<h1><a class="anchor" id="gbc_examples"></a>
Examples</h1>
<p>In order to facilitate the process of learning this package, we provide various examples with a basic usage of different barycentric components.</p>
<h2><a class="anchor" id="seg_example"></a>
Segment Coordinates</h2>
<p>This example illustrates the use of the global function <code><a class="el" href="group__PkgBarycentricCoordinates2RefFunctions.html#gab856ca68d37f58e6cdf74c8aac6f4245" title="computes segment coordinates.">segment_coordinates_2()</a></code>. We compute coordinates at three green points along the segment \([v_0, v_1]\) and at two blue points outside this segment but along its supporting line. The symmetry of the query points helps recognizing errors that may have occurred during construction of the example. The used <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> is exact.</p>
<p><a class="anchor" id="seg_coord_example"></a><a class="anchor" id="fig__seg_example"></a> </p><div class="image">
<object type="image/svg+xml" data="seg_coord_example.svg" style="pointer-events: none;"></object>
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__seg_example">Figure 104.2</a> Example's point pattern. </p> </div> <p> <br>
</p>
<p><br>
<b>File</b> <a class="el" href="Barycentric_coordinates_2_2segment_coordinates_8cpp-example.html">Barycentric_coordinates_2/segment_coordinates.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Barycentric_coordinates_2/segment_coordinates_2.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Typedefs.</span></div>
<div class="line"><span class="keyword">using </span><a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a> = <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">CGAL::Exact_predicates_exact_constructions_kernel</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>FT      = Kernel::FT;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a> = <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> FT y = FT(2) / FT(5);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Construct a segment.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a> source(FT(0), y);</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a> target(FT(2), y);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Construct three interior and two exterior query points.</span></div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;Point_2&gt; queries = {</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(FT(2) / FT(5), y), <span class="comment">// interior query points</span></div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(FT(5) / FT(5), y),</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(FT(8) / FT(5), y),</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(-FT(1) / FT(5), y), <span class="comment">// exterior query points</span></div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(FT(11) / FT(5), y) };</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Compute segment coordinates.</span></div>
<div class="line">  std::vector&lt;FT&gt; coordinates;</div>
<div class="line">  coordinates.reserve(queries.size() * 2);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; query : queries) {</div>
<div class="line">    <a class="code hl_function" href="group__PkgBarycentricCoordinates2RefFunctions.html#gab856ca68d37f58e6cdf74c8aac6f4245">CGAL::Barycentric_coordinates::segment_coordinates_2</a>(</div>
<div class="line">      source, target, query, std::back_inserter(coordinates));</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Output all segment coordinates.</span></div>
<div class="line">  std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">"segment coordinates (all queries): "</span> &lt;&lt; std::endl &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; coordinates.size(); i += 2) {</div>
<div class="line">    std::cout &lt;&lt;</div>
<div class="line">    coordinates[i + 0] &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt;</div>
<div class="line">    coordinates[i + 1] &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  std::cout &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="ttc" id="aclassCGAL_1_1Exact__predicates__exact__constructions__kernel_html"><div class="ttname"><a href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">CGAL::Exact_predicates_exact_constructions_kernel</a></div></div>
<div class="ttc" id="aclassKernel_1_1Point__2_html"><div class="ttname"><a href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a></div></div>
<div class="ttc" id="agroup__PkgBarycentricCoordinates2RefFunctions_html_gab856ca68d37f58e6cdf74c8aac6f4245"><div class="ttname"><a href="group__PkgBarycentricCoordinates2RefFunctions.html#gab856ca68d37f58e6cdf74c8aac6f4245">CGAL::Barycentric_coordinates::segment_coordinates_2</a></div><div class="ttdeci">OutIterator segment_coordinates_2(const typename GeomTraits::Point_2 &amp;p0, const typename GeomTraits::Point_2 &amp;p1, const typename GeomTraits::Point_2 &amp;query, OutIterator c_begin, const GeomTraits &amp;traits)</div><div class="ttdoc">computes segment coordinates.</div><div class="ttdef"><b>Definition:</b> segment_coordinates_2.h:70</div></div>
<div class="ttc" id="anamespaceKernel_html"><div class="ttname"><a href="../Kernel_23/namespaceKernel.html">Kernel</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="tri_example"></a>
Triangle Coordinates</h2>
<p>In this example, we show how to use the global function <code><a class="el" href="group__PkgBarycentricCoordinates2RefFunctions.html#gaa378786f8996dbcefe7923ebb711e4dd" title="computes triangle coordinates.">triangle_coordinates_2()</a></code>. We compute coordinates for three sets of points: interior (green), boundary (red), and exterior (blue). Note that some of the coordinate values for the exterior points are negative. The used <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> is inexact.</p>
<p><a class="anchor" id="tri_coord_example"></a><a class="anchor" id="fig__tri_example"></a> </p><div class="image">
<object type="image/svg+xml" data="tri_coord_example.svg" style="pointer-events: none;"></object>
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__tri_example">Figure 104.3</a> Example's point pattern. </p> </div> <p> <br>
</p>
<p><br>
<b>File</b> <a class="el" href="Barycentric_coordinates_2_2triangle_coordinates_8cpp-example.html">Barycentric_coordinates_2/triangle_coordinates.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Barycentric_coordinates_2/triangle_coordinates_2.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Typedefs.</span></div>
<div class="line"><span class="keyword">using </span><a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a> = <a class="code hl_structRef" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>FT      = Kernel::FT;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a> = <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Construct a triangle.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a> p0(0.0, 0.0);</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a> p1(2.0, 0.5);</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a> p2(1.0, 2.0);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Construct several interior, boundary, and exterior query points.</span></div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;Point_2&gt; queries = {</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.50, 0.50), <span class="comment">// interior query points</span></div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(1.00, 0.50), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(1.0, 0.75), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(1.00, 1.0),</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(1.00, 1.25), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(1.0, 1.50), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.75, 1.0),</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(1.25, 1.00), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(1.5, 0.75),</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(2.0, 0.50), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(1.0, 2.00), <span class="comment">// boundary query points</span></div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(1.0, 0.25), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(1.5, 1.25), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.5, 1.0),</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.25, 1.00), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.50, 1.75), <span class="comment">// exterior query points</span></div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(1.50, 1.75), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(1.75, 1.50) };</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Compute triangle coordinates.</span></div>
<div class="line">  std::vector&lt;FT&gt; coordinates;</div>
<div class="line">  coordinates.reserve(queries.size() * 3);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; query : queries) {</div>
<div class="line">    <a class="code hl_function" href="group__PkgBarycentricCoordinates2RefFunctions.html#gaa378786f8996dbcefe7923ebb711e4dd">CGAL::Barycentric_coordinates::triangle_coordinates_2</a>(</div>
<div class="line">      p0, p1, p2, query, std::back_inserter(coordinates));</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Output all triangle coordinates.</span></div>
<div class="line">  std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">"triangle coordinates (all queries): "</span> &lt;&lt; std::endl &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; coordinates.size(); i += 3) {</div>
<div class="line">    std::cout &lt;&lt;</div>
<div class="line">    coordinates[i + 0] &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt;</div>
<div class="line">    coordinates[i + 1] &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt;</div>
<div class="line">    coordinates[i + 2] &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  std::cout &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__PkgBarycentricCoordinates2RefFunctions_html_gaa378786f8996dbcefe7923ebb711e4dd"><div class="ttname"><a href="group__PkgBarycentricCoordinates2RefFunctions.html#gaa378786f8996dbcefe7923ebb711e4dd">CGAL::Barycentric_coordinates::triangle_coordinates_2</a></div><div class="ttdeci">OutIterator triangle_coordinates_2(const typename GeomTraits::Point_2 &amp;p0, const typename GeomTraits::Point_2 &amp;p1, const typename GeomTraits::Point_2 &amp;p2, const typename GeomTraits::Point_2 &amp;query, OutIterator c_begin, const GeomTraits &amp;traits)</div><div class="ttdoc">computes triangle coordinates.</div><div class="ttdef"><b>Definition:</b> triangle_coordinates_2.h:72</div></div>
<div class="ttc" id="astructCGAL_1_1Simple__cartesian_html"><div class="ttname"><a href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="wp_example"></a>
Wachspress Coordinates</h2>
<p>In the following example, we generate 100 random points (green/red/black), then we take the convex hull (red/black) of this set of points as our polygon (black), and compute Wachspress coordinates at all the generated points. The used <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> is inexact.</p>
<p><a class="anchor" id="wp_coord_example"></a><a class="anchor" id="fig__wp_example"></a> </p><div class="image">
<object type="image/svg+xml" data="wp_coord_example.svg" style="pointer-events: none;"></object>
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__wp_example">Figure 104.4</a> Example's point pattern. </p> </div> <p> <br>
</p>
<p><br>
<b>File</b> <a class="el" href="Barycentric_coordinates_2_2wachspress_coordinates_8cpp-example.html">Barycentric_coordinates_2/wachspress_coordinates.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/convex_hull_2.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/point_generators_2.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Barycentric_coordinates_2/Wachspress_coordinates_2.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Typedefs.</span></div>
<div class="line"><span class="keyword">using </span><a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a> = <a class="code hl_structRef" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>FT      = Kernel::FT;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a> = <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>Creator   = <a class="code hl_classRef" href="../STL_Extension/classCGAL_1_1Creator__uniform__2.html">CGAL::Creator_uniform_2&lt;FT, Point_2&gt;</a>;</div>
<div class="line"><span class="keyword">using </span>Generator = <a class="code hl_classRef" href="../Generator/classCGAL_1_1Random__points__in__square__2.html">CGAL::Random_points_in_square_2&lt;Point_2, Creator&gt;</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Choose how many query points we want to generate.</span></div>
<div class="line">  <span class="keyword">const</span> std::size_t num_queries = 100;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create vectors to store query points and polygon vertices.</span></div>
<div class="line">  std::vector&lt;Point_2&gt; queries, convex;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Generate a set of query points.</span></div>
<div class="line">  queries.reserve(num_queries);</div>
<div class="line">  Generator generator(1.0);</div>
<div class="line">  std::copy_n(generator, num_queries, std::back_inserter(queries));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Find the convex hull of the generated query points.</span></div>
<div class="line">  <span class="comment">// This convex hull gives the vertices of a convex polygon</span></div>
<div class="line">  <span class="comment">// that contains all the generated points.</span></div>
<div class="line">  <a class="code hl_functionRef" href="../Convex_hull_2/group__PkgConvexHull2Functions.html#ga8241d43969ff61cb9be46811c2e9e176">CGAL::convex_hull_2</a>(</div>
<div class="line">    queries.begin(), queries.end(), std::back_inserter(convex));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Compute Wachspress coordinates for all query points.</span></div>
<div class="line">  std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">"Wachspress coordinates (interior + boundary): "</span> &lt;&lt; std::endl &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;FT&gt; coordinates;</div>
<div class="line">  coordinates.reserve(convex.size());</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; query : queries) {</div>
<div class="line">    coordinates.clear();</div>
<div class="line">    <a class="code hl_function" href="group__PkgBarycentricCoordinates2RefFunctions.html#ga2b78df5ac4952fef00a0f132c2ab946f">CGAL::Barycentric_coordinates::wachspress_coordinates_2</a>(</div>
<div class="line">      convex, query, std::back_inserter(coordinates));</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; coordinates.size() - 1; ++i) {</div>
<div class="line">      std::cout &lt;&lt; coordinates[i] &lt;&lt; <span class="stringliteral">", "</span>;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; coordinates[coordinates.size() - 1] &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="ttc" id="aclassCGAL_1_1Creator__uniform__2_html"><div class="ttname"><a href="../STL_Extension/classCGAL_1_1Creator__uniform__2.html">CGAL::Creator_uniform_2</a></div></div>
<div class="ttc" id="aclassCGAL_1_1Random__points__in__square__2_html"><div class="ttname"><a href="../Generator/classCGAL_1_1Random__points__in__square__2.html">CGAL::Random_points_in_square_2</a></div></div>
<div class="ttc" id="agroup__PkgBarycentricCoordinates2RefFunctions_html_ga2b78df5ac4952fef00a0f132c2ab946f"><div class="ttname"><a href="group__PkgBarycentricCoordinates2RefFunctions.html#ga2b78df5ac4952fef00a0f132c2ab946f">CGAL::Barycentric_coordinates::wachspress_coordinates_2</a></div><div class="ttdeci">OutIterator wachspress_coordinates_2(const PointRange &amp;polygon, const typename GeomTraits::Point_2 &amp;query, OutIterator c_begin, const GeomTraits &amp;traits, const Computation_policy_2 policy=Computation_policy_2::PRECISE_WITH_EDGE_CASES)</div><div class="ttdoc">computes 2D Wachspress coordinates.</div><div class="ttdef"><b>Definition:</b> Wachspress_coordinates_2.h:507</div></div>
<div class="ttc" id="agroup__PkgConvexHull2Functions_html_ga8241d43969ff61cb9be46811c2e9e176"><div class="ttname"><a href="../Convex_hull_2/group__PkgConvexHull2Functions.html#ga8241d43969ff61cb9be46811c2e9e176">CGAL::convex_hull_2</a></div><div class="ttdeci">OutputIterator convex_hull_2(InputIterator first, InputIterator beyond, OutputIterator result, const Traits &amp;ch_traits)</div></div>
</div><!-- fragment --><h2><a class="anchor" id="dh_example"></a>
Discrete Harmonic Coordinates</h2>
<p>In this example, we compute discrete harmonic coordinates for a set of green (interior), red (boundary), and blue (exterior) points with respect to a unit square. We also demonstrate the use of various containers, both random access and serial access, different property maps, and the ability to choose a computation policy. For points on the polygon boundary, we use the free function <code><a class="el" href="group__PkgBarycentricCoordinates2RefFunctions.html#ga4724a05781aa56db0faff8cd3013c924" title="computes 2D boundary coordinates.">boundary_coordinates_2()</a></code>. The used <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> is exact.</p>
<p><a class="anchor" id="dh_coord_example"></a><a class="anchor" id="fig__dh_example"></a> </p><div class="image">
<object type="image/svg+xml" data="dh_coord_example.svg" style="pointer-events: none;"></object>
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__dh_example">Figure 104.5</a> Example's point pattern. </p> </div> <p> <br>
</p>
<p><br>
<b>File</b> <a class="el" href="Barycentric_coordinates_2_2discrete_harmonic_coordinates_8cpp-example.html">Barycentric_coordinates_2/discrete_harmonic_coordinates.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Barycentric_coordinates_2/boundary_coordinates_2.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Barycentric_coordinates_2/Discrete_harmonic_coordinates_2.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Typedefs.</span></div>
<div class="line"><span class="keyword">using </span><a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a> = <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">CGAL::Exact_predicates_exact_constructions_kernel</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>FT      = Kernel::FT;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a> = <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Info {</div>
<div class="line"> </div>
<div class="line">  Info(<span class="keyword">const</span> std::string _name) :</div>
<div class="line">  name(_name) { }</div>
<div class="line">  std::string name;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>Vertex       = std::pair&lt;Point_2, Info&gt;;</div>
<div class="line"><span class="keyword">using </span>Point_map    = <a class="code hl_structRef" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Vertex&gt;</a>;</div>
<div class="line"><span class="keyword">using </span>Vertex_range = std::vector&lt;Vertex&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>Discrete_harmonic_coordinates_2 =</div>
<div class="line">  <a class="code hl_class" href="classCGAL_1_1Barycentric__coordinates_1_1Discrete__harmonic__coordinates__2.html">CGAL::Barycentric_coordinates::Discrete_harmonic_coordinates_2&lt;Vertex_range, Kernel, Point_map&gt;</a>;</div>
<div class="line"><span class="keyword">using </span>Policy =</div>
<div class="line">  <a class="code hl_enumeration" href="namespaceCGAL_1_1Barycentric__coordinates.html#a478bbcec416216b2274ee4b4e97b0e6c">CGAL::Barycentric_coordinates::Computation_policy_2</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a> kernel;</div>
<div class="line">  Point_map point_map;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Construct a unit square.</span></div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;Vertex&gt; <a class="code hl_functionRef" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga07001b5ddc5c43096c811c91a306be9a">square</a> = {</div>
<div class="line">    std::make_pair(<a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0, 0), Info(<span class="stringliteral">"1"</span>)), std::make_pair(<a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(1, 0), Info(<span class="stringliteral">"2"</span>)),</div>
<div class="line">    std::make_pair(<a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(1, 1), Info(<span class="stringliteral">"3"</span>)), std::make_pair(<a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0, 1), Info(<span class="stringliteral">"4"</span>))</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Construct the class with discrete harmonic weights.</span></div>
<div class="line">  <span class="comment">// We do not check for edge cases since we know the exact positions</span></div>
<div class="line">  <span class="comment">// of all our points. We speed up the computation by using the O(n) algorithm.</span></div>
<div class="line">  <span class="keyword">const</span> Policy policy = Policy::FAST;</div>
<div class="line">  Discrete_harmonic_coordinates_2 discrete_harmonic_2(<a class="code hl_functionRef" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga07001b5ddc5c43096c811c91a306be9a">square</a>, policy, kernel, point_map);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Construct the center point of the unit square.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a> center(FT(1) / FT(2), FT(1) / FT(2));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Compute discrete harmonic weights for the center point.</span></div>
<div class="line">  std::list&lt;FT&gt; weights;</div>
<div class="line">  discrete_harmonic_2.weights(center, std::back_inserter(weights));</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">"discrete harmonic weights (center): "</span>;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> FT&amp; weight : weights) {</div>
<div class="line">    std::cout &lt;&lt; weight &lt;&lt; <span class="stringliteral">" "</span>;</div>
<div class="line">  }</div>
<div class="line">  std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Compute discrete harmonic coordinates for the center point.</span></div>
<div class="line">  std::list&lt;FT&gt; coordinates;</div>
<div class="line">  discrete_harmonic_2(center, std::back_inserter(coordinates));</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">"discrete harmonic coordinates (center): "</span>;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> FT&amp; coordinate : coordinates) {</div>
<div class="line">    std::cout &lt;&lt; coordinate &lt;&lt; <span class="stringliteral">" "</span>;</div>
<div class="line">  }</div>
<div class="line">  std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Construct several interior points.</span></div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;Point_2&gt; interior_points = {</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(FT(1) / FT(5), FT(1) / FT(5)),</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(FT(4) / FT(5), FT(1) / FT(5)),</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(FT(4) / FT(5), FT(4) / FT(5)),</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(FT(1) / FT(5), FT(4) / FT(5)) };</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Compute discrete harmonic weights for all interior points.</span></div>
<div class="line">  std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">"discrete harmonic weights (interior): "</span> &lt;&lt; std::endl &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;FT&gt; ws;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; query : interior_points) {</div>
<div class="line">    ws.clear();</div>
<div class="line">    discrete_harmonic_2.weights(query, std::back_inserter(ws));</div>
<div class="line">    <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; ws.size() - 1; ++i) {</div>
<div class="line">      std::cout &lt;&lt; ws[i] &lt;&lt; <span class="stringliteral">", "</span>;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; ws[ws.size() - 1] &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Compute discrete harmonic coordinates for all interior point.</span></div>
<div class="line">  std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">"discrete harmonic coordinates (interior): "</span> &lt;&lt; std::endl &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;FT&gt; bs;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; query : interior_points) {</div>
<div class="line">    bs.clear();</div>
<div class="line">    discrete_harmonic_2(query, std::back_inserter(bs));</div>
<div class="line">    <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; bs.size() - 1; ++i) {</div>
<div class="line">      std::cout &lt;&lt; bs[i] &lt;&lt; <span class="stringliteral">", "</span>;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; bs[bs.size() - 1] &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Construct 2 boundary points on the second and fourth edges.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a> e2(1, FT(4) / FT(5));</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a> e4(0, FT(4) / FT(5));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Compute discrete harmonic coordinates = boundary coordinates</span></div>
<div class="line">  <span class="comment">// for these 2 points one by one.</span></div>
<div class="line">  coordinates.clear();</div>
<div class="line">  <a class="code hl_function" href="group__PkgBarycentricCoordinates2RefFunctions.html#ga4724a05781aa56db0faff8cd3013c924">CGAL::Barycentric_coordinates::boundary_coordinates_2</a>(</div>
<div class="line">    <a class="code hl_functionRef" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga07001b5ddc5c43096c811c91a306be9a">square</a>, e2, std::back_inserter(coordinates), kernel, point_map);</div>
<div class="line">  <a class="code hl_function" href="group__PkgBarycentricCoordinates2RefFunctions.html#ga4724a05781aa56db0faff8cd3013c924">CGAL::Barycentric_coordinates::boundary_coordinates_2</a>(</div>
<div class="line">    <a class="code hl_functionRef" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga07001b5ddc5c43096c811c91a306be9a">square</a>, e4, std::back_inserter(coordinates), kernel, point_map);</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">"boundary coordinates (edge 2 and edge 4): "</span>;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> FT&amp; coordinate : coordinates) {</div>
<div class="line">    std::cout &lt;&lt; coordinate &lt;&lt; <span class="stringliteral">" "</span>;</div>
<div class="line">  }</div>
<div class="line">  std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Construct 6 other boundary points: 2 on the first and third edges respectively</span></div>
<div class="line">  <span class="comment">// and 4 at the vertices.</span></div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;Point_2&gt; es13 = {</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(FT(1) / FT(2), 0), <span class="comment">// edges</span></div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(FT(1) / FT(2), 1),</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// vertices</span></div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0, 0), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(1, 0),</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(1, 1), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0, 1)</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Compute discrete harmonic coordinates = boundary coordinates for all 6 points.</span></div>
<div class="line">  std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">"boundary coordinates (edge 1, edge 3, and vertices): "</span> &lt;&lt; std::endl &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; query : es13) {</div>
<div class="line">    bs.clear();</div>
<div class="line">    <a class="code hl_function" href="group__PkgBarycentricCoordinates2RefFunctions.html#ga4724a05781aa56db0faff8cd3013c924">CGAL::Barycentric_coordinates::boundary_coordinates_2</a>(</div>
<div class="line">      <a class="code hl_functionRef" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga07001b5ddc5c43096c811c91a306be9a">square</a>, query, std::back_inserter(bs), point_map); <span class="comment">// we can skip kernel here</span></div>
<div class="line">    <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; bs.size() - 1; ++i) {</div>
<div class="line">      std::cout &lt;&lt; bs[i] &lt;&lt; <span class="stringliteral">", "</span>;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; bs[bs.size() - 1] &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Construct 2 points outside the unit square - one from the left and one from the right.</span></div>
<div class="line">  <span class="comment">// Even if discrete harmonic coordinates may not be valid for some exterior points,</span></div>
<div class="line">  <span class="comment">// we can still do it.</span></div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a> l(FT(-1) / FT(2), FT(1) / FT(2));</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a> r(FT(3)  / FT(2), FT(1) / FT(2));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Compute discrete harmonic coordinates for all exterior points.</span></div>
<div class="line">  coordinates.clear();</div>
<div class="line">  discrete_harmonic_2(l, std::back_inserter(coordinates));</div>
<div class="line">  discrete_harmonic_2(r, std::back_inserter(coordinates));</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">"discrete harmonic coordinates (exterior): "</span>;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> FT&amp; coordinate : coordinates) {</div>
<div class="line">    std::cout &lt;&lt; coordinate &lt;&lt; <span class="stringliteral">" "</span>;</div>
<div class="line">  }</div>
<div class="line">  std::cout &lt;&lt; std::endl &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="ttc" id="aclassCGAL_1_1Barycentric__coordinates_1_1Discrete__harmonic__coordinates__2_html"><div class="ttname"><a href="classCGAL_1_1Barycentric__coordinates_1_1Discrete__harmonic__coordinates__2.html">CGAL::Barycentric_coordinates::Discrete_harmonic_coordinates_2</a></div><div class="ttdoc">2D discrete harmonic coordinates.</div><div class="ttdef"><b>Definition:</b> Discrete_harmonic_coordinates_2.h:57</div></div>
<div class="ttc" id="agroup__PkgAlgebraicFoundationsRef_html_ga07001b5ddc5c43096c811c91a306be9a"><div class="ttname"><a href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga07001b5ddc5c43096c811c91a306be9a">CGAL::square</a></div><div class="ttdeci">NT square(const NT &amp;x)</div></div>
<div class="ttc" id="agroup__PkgBarycentricCoordinates2RefFunctions_html_ga4724a05781aa56db0faff8cd3013c924"><div class="ttname"><a href="group__PkgBarycentricCoordinates2RefFunctions.html#ga4724a05781aa56db0faff8cd3013c924">CGAL::Barycentric_coordinates::boundary_coordinates_2</a></div><div class="ttdeci">std::pair&lt; OutIterator, bool &gt; boundary_coordinates_2(const VertexRange &amp;polygon, const typename GeomTraits::Point_2 &amp;query, OutIterator c_begin, const GeomTraits &amp;traits, const PointMap point_map)</div><div class="ttdoc">computes 2D boundary coordinates.</div><div class="ttdef"><b>Definition:</b> boundary_coordinates_2.h:82</div></div>
<div class="ttc" id="anamespaceCGAL_1_1Barycentric__coordinates_html_a478bbcec416216b2274ee4b4e97b0e6c"><div class="ttname"><a href="namespaceCGAL_1_1Barycentric__coordinates.html#a478bbcec416216b2274ee4b4e97b0e6c">CGAL::Barycentric_coordinates::Computation_policy_2</a></div><div class="ttdeci">Computation_policy_2</div><div class="ttdoc">Computation_policy_2 provides a way to choose an asymptotic time complexity of the algorithm and its ...</div><div class="ttdef"><b>Definition:</b> barycentric_enum_2.h:36</div></div>
<div class="ttc" id="astructCGAL_1_1First__of__pair__property__map_html"><div class="ttname"><a href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="mv_example"></a>
Mean Value Coordinates</h2>
<p>This is an example that illustrates how to compute mean value coordinates for a set of green points in a star-shaped polygon. We note that this type of coordinates is well-defined for such a concave polygon while Wachspress and discrete harmonic coordinates are not. However, it may yield negative coordinate values for points outside <a href="https://en.wikipedia.org/wiki/Star-shaped_polygon">the polygon's kernel</a> (shown in red). We speed up the computation using the linear time complexity algorithm by specifying a computation policy <code><a class="el" href="namespaceCGAL_1_1Barycentric__coordinates.html#a478bbcec416216b2274ee4b4e97b0e6c" title="Computation_policy_2 provides a way to choose an asymptotic time complexity of the algorithm and its ...">Barycentric_coordinates::Computation_policy_2</a></code>. The used <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> is inexact.</p>
<p><a class="anchor" id="mv_coord_example"></a><a class="anchor" id="fig__mv_example"></a> </p><div class="image">
<object type="image/svg+xml" data="mv_coord_example.svg" style="pointer-events: none;"></object>
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__mv_example">Figure 104.6</a> Example's point pattern. </p> </div> <p> <br>
</p>
<p><br>
<b>File</b> <a class="el" href="Barycentric_coordinates_2_2mean_value_coordinates_8cpp-example.html">Barycentric_coordinates_2/mean_value_coordinates.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Barycentric_coordinates_2/Mean_value_coordinates_2.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Typedefs.</span></div>
<div class="line"><span class="keyword">using </span><a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a> = <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>FT      = Kernel::FT;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a> = <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>;</div>
<div class="line"><span class="keyword">using </span>Policy  = <a class="code hl_enumeration" href="namespaceCGAL_1_1Barycentric__coordinates.html#a478bbcec416216b2274ee4b4e97b0e6c">CGAL::Barycentric_coordinates::Computation_policy_2</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Construct a star-shaped polygon.</span></div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;Point_2&gt; star_shaped = {</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.0, 0.0), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>( 0.1, -0.8), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.3, 0.0), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.6, -0.5),</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.6, 0.1), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>( 1.1,  0.6), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.3, 0.2), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.1,  0.8),</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.1, 0.2), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(-0.7,  0.0) };</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Construct some interior points in the polygon.</span></div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;Point_2&gt; interior_points = {</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.12, -0.45), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.55, -0.3), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.9 , 0.45),</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.15,  0.35), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(-0.4, 0.04), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.11, 0.11),</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.28,  0.12), <span class="comment">// the only point in the kernel of the star shaped polygon</span></div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.55,  0.11) };</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Choose a computation policy.</span></div>
<div class="line">  <span class="comment">// We do not check for edge cases since we know</span></div>
<div class="line">  <span class="comment">// that all our points are strictly interior.</span></div>
<div class="line">  <span class="keyword">const</span> Policy policy = Policy::PRECISE;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create a vector `std::vector` to store coordinates.</span></div>
<div class="line">  std::vector&lt;FT&gt; coordinates;</div>
<div class="line">  coordinates.reserve(star_shaped.size());</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Compute mean value coordinates for all interior points.</span></div>
<div class="line">  std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">"mean value coordinates (interior): "</span> &lt;&lt; std::endl &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; query : interior_points) {</div>
<div class="line">    coordinates.clear();</div>
<div class="line">    <a class="code hl_function" href="group__PkgBarycentricCoordinates2RefFunctions.html#gad9337f53ea56d65708bb42e4ee3415aa">CGAL::Barycentric_coordinates::mean_value_coordinates_2</a>(</div>
<div class="line">      star_shaped, query, std::back_inserter(coordinates), policy);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Output mean value coordinates.</span></div>
<div class="line">    <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; coordinates.size() - 1; ++i) {</div>
<div class="line">      std::cout &lt;&lt; coordinates[i] &lt;&lt; <span class="stringliteral">", "</span>;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; coordinates[coordinates.size() - 1] &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="ttc" id="aclassCGAL_1_1Exact__predicates__inexact__constructions__kernel_html"><div class="ttname"><a href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a></div></div>
<div class="ttc" id="agroup__PkgBarycentricCoordinates2RefFunctions_html_gad9337f53ea56d65708bb42e4ee3415aa"><div class="ttname"><a href="group__PkgBarycentricCoordinates2RefFunctions.html#gad9337f53ea56d65708bb42e4ee3415aa">CGAL::Barycentric_coordinates::mean_value_coordinates_2</a></div><div class="ttdeci">OutIterator mean_value_coordinates_2(const PointRange &amp;polygon, const typename GeomTraits::Point_2 &amp;query, OutIterator c_begin, const GeomTraits &amp;traits, const Computation_policy_2 policy=Computation_policy_2::PRECISE_WITH_EDGE_CASES)</div><div class="ttdoc">computes 2D mean value coordinates.</div><div class="ttdef"><b>Definition:</b> Mean_value_coordinates_2.h:558</div></div>
</div><!-- fragment --><h2><a class="anchor" id="hm_example"></a>
Harmonic Coordinates</h2>
<p>This example illustrates how to <a class="el" href="index.html#terrain_triangulation_fig">discretize</a> the interior part of the <a class="el" href="index.html#terrain_example_fig">polygon</a> and compute harmonic coordinates at the vertices of the discretized domain, which is represented by a 2D Delaunay triangulation. Once computed, harmonic coordinate functions can be evaluated at any point in the closure of the polygon. To illustrate such an evaluation, we compute the barycenter of each triangle and evaluate harmonic coordinates at this barycenter. Since harmonic coordinates can only be approximated, the used <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> is inexact.</p>
<p><a class="anchor" id="hm_coord_example"></a><br>
<b>File</b> <a class="el" href="Barycentric_coordinates_2_2harmonic_coordinates_8cpp-example.html">Barycentric_coordinates_2/harmonic_coordinates.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Barycentric_coordinates_2/Delaunay_domain_2.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Barycentric_coordinates_2/Harmonic_coordinates_2.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Typedefs.</span></div>
<div class="line"><span class="keyword">using </span><a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>      = <a class="code hl_structRef" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>     = <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>;</div>
<div class="line"><span class="keyword">using </span>Point_range = std::vector&lt;Point_2&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>Domain =</div>
<div class="line">  <a class="code hl_class" href="classCGAL_1_1Barycentric__coordinates_1_1Delaunay__domain__2.html">CGAL::Barycentric_coordinates::Delaunay_domain_2&lt;Point_range, Kernel&gt;</a>;</div>
<div class="line"><span class="keyword">using </span>Harmonic_coordinates_2 =</div>
<div class="line">  <a class="code hl_class" href="classCGAL_1_1Barycentric__coordinates_1_1Harmonic__coordinates__2.html">CGAL::Barycentric_coordinates::Harmonic_coordinates_2&lt;Point_range, Domain, Kernel&gt;</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Construct a simple polygon.</span></div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;Point_2&gt; polygon = {</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.03, 0.05), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.07, 0.04), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.10, 0.04),</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.14, 0.04), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.17, 0.07), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.20, 0.09),</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.22, 0.11), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.25, 0.11), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.27, 0.10),</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.30, 0.07), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.31, 0.04), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.34, 0.03),</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.37, 0.02), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.40, 0.03), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.42, 0.04),</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.44, 0.07), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.45, 0.10), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.46, 0.13),</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.46, 0.19), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.47, 0.26), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.47, 0.31),</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.47, 0.35), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.45, 0.37), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.41, 0.38),</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.38, 0.37), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.35, 0.36), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.32, 0.35),</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.30, 0.37), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.28, 0.39), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.25, 0.40),</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.23, 0.39), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.21, 0.37), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.21, 0.34),</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.23, 0.32), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.24, 0.29), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.27, 0.24),</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.29, 0.21), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.29, 0.18), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.26, 0.16),</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.24, 0.17), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.23, 0.19), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.24, 0.22),</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.24, 0.25), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.21, 0.26), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.17, 0.26),</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.12, 0.24), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.07, 0.20), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.03, 0.15),</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.01, 0.10), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.02, 0.07)</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Use seeds to mark the interior part of the polygon.</span></div>
<div class="line">  std::list&lt;Point_2&gt; seeds;</div>
<div class="line">  seeds.push_back(<a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.1, 0.1));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Construct a Delaunay domain.</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> max_edge_length = 0.01;</div>
<div class="line">  Domain domain(polygon);</div>
<div class="line">  domain.create(max_edge_length, seeds);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Compute harmonic coordinates at the vertices of the domain.</span></div>
<div class="line">  Harmonic_coordinates_2 harmonic_coordinates_2(polygon, domain);</div>
<div class="line">  harmonic_coordinates_2.compute();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Use it to store coordinates.</span></div>
<div class="line">  std::vector&lt;double&gt; coordinates;</div>
<div class="line">  coordinates.reserve(polygon.size());</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Output harmonic coordinates.</span></div>
<div class="line">  <span class="comment">// We output only the first 20 results.</span></div>
<div class="line">  std::cout.precision(1);</div>
<div class="line">  std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">"harmonic coordinates (computed): "</span> &lt;&lt; std::endl &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (std::size_t k = 0; k &lt; 20; ++k) {</div>
<div class="line">    coordinates.clear();</div>
<div class="line">    harmonic_coordinates_2(k, std::back_inserter(coordinates));</div>
<div class="line">    <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; coordinates.size() - 1; ++i) {</div>
<div class="line">      std::cout &lt;&lt; coordinates[i] &lt;&lt; <span class="stringliteral">", "</span>;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; coordinates[coordinates.size() - 1] &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Evaluate harmonic coordinates at the barycenters of the domain triangles.</span></div>
<div class="line">  <span class="comment">// We output only the first 20 results.</span></div>
<div class="line">  std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">"harmonic coordinates (evaluated): "</span> &lt;&lt; std::endl &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;Point_2&gt; barycenters;</div>
<div class="line">  domain.barycenters(std::back_inserter(barycenters));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (std::size_t k = 0; k &lt; 20; ++k) {</div>
<div class="line">    coordinates.clear();</div>
<div class="line">    harmonic_coordinates_2(barycenters[k], std::back_inserter(coordinates));</div>
<div class="line">    <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; coordinates.size() - 1; ++i) {</div>
<div class="line">      std::cout &lt;&lt; coordinates[i] &lt;&lt; <span class="stringliteral">", "</span>;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; coordinates[coordinates.size() - 1] &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="ttc" id="aclassCGAL_1_1Barycentric__coordinates_1_1Delaunay__domain__2_html"><div class="ttname"><a href="classCGAL_1_1Barycentric__coordinates_1_1Delaunay__domain__2.html">CGAL::Barycentric_coordinates::Delaunay_domain_2</a></div><div class="ttdoc">2D Delaunay domain restricted to a simple polygon.</div><div class="ttdef"><b>Definition:</b> Delaunay_domain_2.h:60</div></div>
<div class="ttc" id="aclassCGAL_1_1Barycentric__coordinates_1_1Harmonic__coordinates__2_html"><div class="ttname"><a href="classCGAL_1_1Barycentric__coordinates_1_1Harmonic__coordinates__2.html">CGAL::Barycentric_coordinates::Harmonic_coordinates_2</a></div><div class="ttdoc">2D harmonic coordinates.</div><div class="ttdef"><b>Definition:</b> Harmonic_coordinates_2.h:74</div></div>
</div><!-- fragment --><h2><a class="anchor" id="height_inter_example"></a>
Terrain Modeling</h2>
<p>This is an advanced example that illustrates how to use generalized barycentric coordinates for height interpolation with applications to terrain modeling. It also shows how to use a non-default traits class with our package instead of a <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> traits class. Suppose we know the boundary of three-dimensional piece of terrain that can be represented as a polygon with several three-dimensional vertices, where the third dimension indicates the corresponding height. The task is to propagate the height from the known sample points on the boundary to the polygon's interior. This gives an approximate estimation of the terrain's surface in this region.</p>
<p><a class="anchor" id="terrain_example_fig"></a><a class="anchor" id="fig__terrain_example"></a> </p><div class="image">
<object type="image/svg+xml" data="terrain.svg" style="pointer-events: none;"></object>
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__terrain_example">Figure 104.7</a> A 2D polygon with 50 vertices representing a piece of terrain with convex and concave parts. The height is not shown. </p> </div> <p> <br>
</p>
<p>In this example, we project a 3D polygon orthogonally onto the 2D plane using the class <code><a class="elRef" href="../Kernel_23/classCGAL_1_1Projection__traits__xy__3.html">CGAL::Projection_traits_xy_3</a></code>, triangulate its interior using the class <code><a class="el" href="classCGAL_1_1Barycentric__coordinates_1_1Delaunay__domain__2.html" title="2D Delaunay domain restricted to a simple polygon.">Delaunay_domain_2</a></code>, and compute mean value coordinates at the vertices of this triangulation with respect to the polygon vertices. Finally, we interpolate the height data from the polygon boundary to its interior using the computed coordinates and the global interpolation function from the package <a class="elRef" href="../Interpolation/index.html#chapinterpolation">2D and Surface Function Interpolation</a>.</p>
<p><a class="anchor" id="terrain_example"></a><br>
<b>File</b> <a class="el" href="Barycentric_coordinates_2_2terrain_height_modeling_8cpp-example.html">Barycentric_coordinates_2/terrain_height_modeling.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Projection_traits_xy_3.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/interpolation_functions.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Barycentric_coordinates_2/Delaunay_domain_2.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Barycentric_coordinates_2/Mean_value_coordinates_2.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Typedefs.</span></div>
<div class="line"><span class="keyword">using </span><a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>     = <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div>
<div class="line"><span class="keyword">using </span>Projection = <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Projection__traits__xy__3.html">CGAL::Projection_traits_xy_3&lt;Kernel&gt;</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>FT          = <span class="keyword">typename</span> Projection::FT;</div>
<div class="line"><span class="keyword">using </span>Point       = <span class="keyword">typename</span> Projection::Point_2;</div>
<div class="line"><span class="keyword">using </span>Point_range = std::vector&lt;Point&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>Domain =</div>
<div class="line">  <a class="code hl_class" href="classCGAL_1_1Barycentric__coordinates_1_1Delaunay__domain__2.html">CGAL::Barycentric_coordinates::Delaunay_domain_2&lt;Point_range, Projection&gt;</a>;</div>
<div class="line"><span class="keyword">using </span>Mean_value_coordinates_2 =</div>
<div class="line">  <a class="code hl_class" href="classCGAL_1_1Barycentric__coordinates_1_1Mean__value__coordinates__2.html">CGAL::Barycentric_coordinates::Mean_value_coordinates_2&lt;Point_range, Projection&gt;</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>Vertex_function_value = std::map&lt;Point, FT, typename Projection::Less_xy_2&gt;;</div>
<div class="line"><span class="keyword">using </span>Function_value_access = <a class="code hl_structRef" href="../Interpolation/structCGAL_1_1Data__access.html">CGAL::Data_access&lt;Vertex_function_value&gt;</a>;</div>
<div class="line"><span class="keyword">using </span>Point_with_coordinate = std::pair&lt;Point, FT&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Construct a polygon that bounds a three-dimensional terrain.</span></div>
<div class="line">  <span class="comment">// Note that the z-coordinate of each vertex represents the height function.</span></div>
<div class="line">  <span class="comment">// Projection in 2D is performed automatically by the Projection traits class.</span></div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;Point&gt; polygon = {</div>
<div class="line">    Point(0.03, 0.05, 0.00), Point(0.07, 0.04, 0.02), Point(0.10, 0.04, 0.04),</div>
<div class="line">    Point(0.14, 0.04, 0.06), Point(0.17, 0.07, 0.08), Point(0.20, 0.09, 0.10),</div>
<div class="line">    Point(0.22, 0.11, 0.12), Point(0.25, 0.11, 0.14), Point(0.27, 0.10, 0.16),</div>
<div class="line">    Point(0.30, 0.07, 0.18), Point(0.31, 0.04, 0.20), Point(0.34, 0.03, 0.22),</div>
<div class="line">    Point(0.37, 0.02, 0.24), Point(0.40, 0.03, 0.26), Point(0.42, 0.04, 0.28),</div>
<div class="line">    Point(0.44, 0.07, 0.30), Point(0.45, 0.10, 0.32), Point(0.46, 0.13, 0.34),</div>
<div class="line">    Point(0.46, 0.19, 0.36), Point(0.47, 0.26, 0.38), Point(0.47, 0.31, 0.40),</div>
<div class="line">    Point(0.47, 0.35, 0.42), Point(0.45, 0.37, 0.44), Point(0.41, 0.38, 0.46),</div>
<div class="line">    Point(0.38, 0.37, 0.48), Point(0.35, 0.36, 0.50), Point(0.32, 0.35, 0.52),</div>
<div class="line">    Point(0.30, 0.37, 0.54), Point(0.28, 0.39, 0.56), Point(0.25, 0.40, 0.58),</div>
<div class="line">    Point(0.23, 0.39, 0.60), Point(0.21, 0.37, 0.62), Point(0.21, 0.34, 0.64),</div>
<div class="line">    Point(0.23, 0.32, 0.66), Point(0.24, 0.29, 0.68), Point(0.27, 0.24, 0.70),</div>
<div class="line">    Point(0.29, 0.21, 0.72), Point(0.29, 0.18, 0.74), Point(0.26, 0.16, 0.76),</div>
<div class="line">    Point(0.24, 0.17, 0.78), Point(0.23, 0.19, 0.80), Point(0.24, 0.22, 0.82),</div>
<div class="line">    Point(0.24, 0.25, 0.84), Point(0.21, 0.26, 0.86), Point(0.17, 0.26, 0.88),</div>
<div class="line">    Point(0.12, 0.24, 0.90), Point(0.07, 0.20, 0.92), Point(0.03, 0.15, 0.94),</div>
<div class="line">    Point(0.01, 0.10, 0.97), Point(0.02, 0.07, 1.00)</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Construct a Delaunay domain.</span></div>
<div class="line">  std::vector&lt;Point&gt; seeds;</div>
<div class="line">  seeds.push_back(Point(0.1, 0.1, 0.0));</div>
<div class="line"> </div>
<div class="line">  Domain domain(polygon);</div>
<div class="line">  domain.create(0.05, seeds);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Associate each polygon vertex with the corresponding function value.</span></div>
<div class="line">  Vertex_function_value vertex_function_value;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; vertex : polygon) {</div>
<div class="line">    vertex_function_value.insert(</div>
<div class="line">      std::make_pair(vertex, vertex.z()));</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Construct the class with the mean value weights.</span></div>
<div class="line">  Mean_value_coordinates_2 <a class="code hl_function" href="group__PkgBarycentricCoordinates2RefFunctions.html#gad9337f53ea56d65708bb42e4ee3415aa">mean_value_coordinates_2</a>(polygon);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Compute mean value coordinates and use them to interpolate data</span></div>
<div class="line">  <span class="comment">// from the polygon boundary to its interior.</span></div>
<div class="line">  std::vector&lt;FT&gt; coordinates;</div>
<div class="line">  coordinates.reserve(polygon.size());</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;Point_with_coordinate&gt; boundary;</div>
<div class="line">  boundary.resize(polygon.size());</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;Point&gt; queries;</div>
<div class="line">  queries.reserve(domain.number_of_vertices());</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; domain.number_of_vertices(); ++i) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; query = domain.vertex(i);</div>
<div class="line"> </div>
<div class="line">    coordinates.clear();</div>
<div class="line">    <a class="code hl_function" href="group__PkgBarycentricCoordinates2RefFunctions.html#gad9337f53ea56d65708bb42e4ee3415aa">mean_value_coordinates_2</a>(query, std::back_inserter(coordinates));</div>
<div class="line">    <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; polygon.size(); ++i) {</div>
<div class="line">      boundary[i] = std::make_pair(polygon[i], coordinates[i]);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> FT f = <a class="code hl_functionRef" href="../Interpolation/group__PkgInterpolation2Interpolation.html#ga2f8a2f88b5b91b9f3db2d5e40bfa1df7">CGAL::linear_interpolation</a>(</div>
<div class="line">      boundary.begin(), boundary.end(), FT(1),</div>
<div class="line">      Function_value_access(vertex_function_value));</div>
<div class="line">    queries.push_back(Point(query.x(), query.y(), f));</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Output interpolated heights.</span></div>
<div class="line">  std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">"interpolated heights (all queries): "</span> &lt;&lt; std::endl &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; query : queries) {</div>
<div class="line">    std::cout &lt;&lt; query.z() &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="ttc" id="aclassCGAL_1_1Barycentric__coordinates_1_1Mean__value__coordinates__2_html"><div class="ttname"><a href="classCGAL_1_1Barycentric__coordinates_1_1Mean__value__coordinates__2.html">CGAL::Barycentric_coordinates::Mean_value_coordinates_2</a></div><div class="ttdoc">2D mean value coordinates.</div><div class="ttdef"><b>Definition:</b> Mean_value_coordinates_2.h:62</div></div>
<div class="ttc" id="aclassCGAL_1_1Projection__traits__xy__3_html"><div class="ttname"><a href="../Kernel_23/classCGAL_1_1Projection__traits__xy__3.html">CGAL::Projection_traits_xy_3</a></div></div>
<div class="ttc" id="agroup__PkgInterpolation2Interpolation_html_ga2f8a2f88b5b91b9f3db2d5e40bfa1df7"><div class="ttname"><a href="../Interpolation/group__PkgInterpolation2Interpolation.html#ga2f8a2f88b5b91b9f3db2d5e40bfa1df7">CGAL::linear_interpolation</a></div><div class="ttdeci">ValueFunctor::result_type::first_type linear_interpolation(CoordinateInputIterator first, CoordinateInputIterator beyond, const typename std::iterator_traits&lt; CoordinateInputIterator &gt;::value_type::second_type &amp;norm, ValueFunctor value_function)</div></div>
<div class="ttc" id="astructCGAL_1_1Data__access_html"><div class="ttname"><a href="../Interpolation/structCGAL_1_1Data__access.html">CGAL::Data_access</a></div></div>
</div><!-- fragment --><p>As a result, we get a smooth function inside the polygon that approximates the underlying terrain surface.</p>
<p><a class="anchor" id="fig__terrain_interpolation_example"></a> </p><div class="image">
<img src="terrain_interpolation.png" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__terrain_interpolation_example">Figure 104.8</a> The interpolated data. The color bar represents the corresponding height. </p> </div> <p> <br>
</p>
<h2><a class="anchor" id="shape_deform_example"></a>
Shape Deformation</h2>
<p>This is another advanced example that shows how to use generalized barycentric coordinates in order to deform a given 2D shape into another shape as shown in the figure below. Harmonic coordinates satisfy all the properties of barycentric coordinates for complicated concave polygons and hence this is our choice to perform a shape deformation. Note that even though harmonic coordinates are guaranteed to be positive inside a polygon, they do not guarantee a bijective mapping between the source and target shapes that is the target mesh can fold-over the target polygon after the mapping (see the little fold-over in the left shoulder of the target shape).</p>
<p><a class="anchor" id="fig__shape_deformation_example"></a> </p><div class="image">
<object type="image/svg+xml" data="shape_deformation.svg" style="pointer-events: none;"></object>
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__shape_deformation_example">Figure 104.9</a> The shape on the left is deformed into the shape on the right. The zoom shows a fold-over in the left shoulder of the target shape where the red triangle goes over the polygon boundary. </p> </div> <p> <br>
</p>
<p><a class="anchor" id="deformation_example"></a><br>
<b>File</b> <a class="el" href="Barycentric_coordinates_2_2shape_deformation_8cpp-example.html">Barycentric_coordinates_2/shape_deformation.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Barycentric_coordinates_2/Delaunay_domain_2.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Barycentric_coordinates_2/Harmonic_coordinates_2.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Typedefs.</span></div>
<div class="line"><span class="keyword">using </span><a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>      = <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div>
<div class="line"><span class="keyword">using </span>FT          = Kernel::FT;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>     = <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>;</div>
<div class="line"><span class="keyword">using </span>Point_range = std::vector&lt;Point_2&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>Domain =</div>
<div class="line">  <a class="code hl_class" href="classCGAL_1_1Barycentric__coordinates_1_1Delaunay__domain__2.html">CGAL::Barycentric_coordinates::Delaunay_domain_2&lt;Point_range, Kernel&gt;</a>;</div>
<div class="line"><span class="keyword">using </span>Harmonic_coordinates_2 =</div>
<div class="line">  <a class="code hl_class" href="classCGAL_1_1Barycentric__coordinates_1_1Harmonic__coordinates__2.html">CGAL::Barycentric_coordinates::Harmonic_coordinates_2&lt;Point_range, Domain, Kernel&gt;</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Construct the source and target shapes.</span></div>
<div class="line">  <span class="comment">// The number of vertices in both shapes must be equal.</span></div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;Point_2&gt; source_shape = {</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(1, 0), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(2, 0), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(3, 3), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(4, 0), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(5, 0),</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(4, 3), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(4, 5), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(5, 4), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(5, 5), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(4, 6),</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(2, 6), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(1, 5), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(1, 4), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(2, 5), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(2, 3)</div>
<div class="line">  };</div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;Point_2&gt; target_shape = {</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(2, 0), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(3, 0), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(3, 3), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(3, 0), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(4, 0),</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(4, 3), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(4, 5), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(5, 6), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(5, 7), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(4, 6),</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(2, 6), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(1, 7), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(1, 6), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(2, 5), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(2, 3)</div>
<div class="line">  };</div>
<div class="line">  assert(target_shape.size() == source_shape.size());</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Use seeds to mark the interior part of the source shape.</span></div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;Point_2&gt; seeds = { <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(3, 5) };</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Construct a Delaunay domain.</span></div>
<div class="line">  <span class="keyword">const</span> FT max_edge_length = FT(1) / FT(3);</div>
<div class="line">  Domain domain(source_shape);</div>
<div class="line">  domain.create(max_edge_length, seeds);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Use it to store coordinates.</span></div>
<div class="line">  std::vector&lt; std::vector&lt;FT&gt; &gt; coordinates;</div>
<div class="line">  coordinates.reserve(domain.number_of_vertices());</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Compute harmonic coordinates at the vertices of the</span></div>
<div class="line">  <span class="comment">// discretized interior domain of the source shape.</span></div>
<div class="line">  Harmonic_coordinates_2 harmonic_coordinates_2(source_shape, domain);</div>
<div class="line">  harmonic_coordinates_2.compute();</div>
<div class="line">  harmonic_coordinates_2(std::back_inserter(coordinates));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Deform the source domain into the target domain.</span></div>
<div class="line">  <span class="comment">// We output only the first 20 results.</span></div>
<div class="line">  std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">"shape deformation: "</span> &lt;&lt; std::endl &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (std::size_t k = 0; k &lt; 20; ++k) {</div>
<div class="line">    FT x = FT(0), y = FT(0);</div>
<div class="line">    <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; coordinates[k].size(); ++i) {</div>
<div class="line">      x += coordinates[k][i] * target_shape[i].x();</div>
<div class="line">      y += coordinates[k][i] * target_shape[i].y();</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">"deformed domain vertex: ("</span> &lt;&lt; x &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; y &lt;&lt; <span class="stringliteral">")"</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><p>But despite the possible fold-overs, a similar technique can be used for image warping in 2D and character articulation in 3D. For example in 2D, we first enclose an image, which we want to deform, into a simple polygon so-called <em>cage</em>, we then bound each image pixel to this cage using barycentric coordinates, and finally deform this cage into a new one, which also deforms the underlying image, as shown in the figure below for harmonic coordinates.</p>
<p><a class="anchor" id="fig__image_warping_example"></a> </p><div class="image">
<img src="image_warping.png" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__image_warping_example">Figure 104.10</a> An image on the left is deformed into a new image on the right using a 2D concave polygon (grey) and harmonic coordinates computed at each image pixel with respect to the vertices of this polygon. </p> </div> <p> <br>
</p>
<h2><a class="anchor" id="aff_example"></a>
Affine Coordinates</h2>
<p>This is an example, where we show how a <a href="https://en.cppreference.com/w/cpp/language/lambda">lambda expression</a> can be used to define a model of generalized barycentric coordinates. To make this example useful, we implement affine generalized coordinates for a set of scattered points. The used <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> is inexact.</p>
<p><a class="anchor" id="aff_coord_example_fig"></a><a class="anchor" id="fig__aff_example"></a> </p><div class="image">
<object type="image/svg+xml" data="aff_coord_example.svg" style="pointer-events: none;"></object>
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__aff_example">Figure 104.11</a> Example's point pattern. </p> </div> <p> <br>
</p>
<p><a class="anchor" id="aff_coord_example"></a><br>
<b>File</b> <a class="el" href="Barycentric_coordinates_2_2affine_coordinates_8cpp-example.html">Barycentric_coordinates_2/affine_coordinates.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/Core&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;Eigen/Dense&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/barycenter.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/iterator/transform_iterator.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Typedefs.</span></div>
<div class="line"><span class="keyword">using </span><a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>   = <a class="code hl_structRef" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>  = <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>;</div>
<div class="line"><span class="keyword">using </span>VectorXd = Eigen::VectorXd;</div>
<div class="line"><span class="keyword">using </span>MatrixXd = Eigen::MatrixXd;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>Output_iterator =</div>
<div class="line">  std::back_insert_iterator&lt; std::vector&lt;double&gt; &gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create a set of vertices.</span></div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;Point_2&gt; vertices = {</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.0, 0.0), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.75, 0.25), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.5, 0.5), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.4, -0.2) };</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create a set of query points.</span></div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;Point_2&gt; queries = {</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.2, 0.2), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.3, 0.3), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.4, 0.4) };</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create a lambda function with affine coordinates.</span></div>
<div class="line">  <span class="comment">// This implementation is based on the following paper:</span></div>
<div class="line">  <span class="comment">// S. Waldron. Affine generalized barycentric coordinates.</span></div>
<div class="line">  <span class="comment">// Jaen Journal on Approximation, 3(2):209-226, 2011.</span></div>
<div class="line">  <span class="comment">// This function is a model of the `AnalyticWeights_2` concept.</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> affine = [&amp;](</div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>&amp; query,</div>
<div class="line">    Output_iterator coordinates) {</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> std::size_t n = vertices.size();</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> lambda = [](<span class="keyword">const</span> <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>&amp; p){ <span class="keywordflow">return</span> std::make_pair(p, 1.0); };</div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a> b = <a class="code hl_functionRef" href="../Kernel_23/group__barycenter__grp.html#ga93e459977649c2430139b5778101529b">CGAL::barycenter</a>(</div>
<div class="line">      boost::make_transform_iterator(vertices.begin(), lambda),</div>
<div class="line">      boost::make_transform_iterator(vertices.end()  , lambda), <a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>());</div>
<div class="line"> </div>
<div class="line">    MatrixXd V(2, n);</div>
<div class="line">    <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; n; ++i) {</div>
<div class="line">      V(0, i) = vertices[i].x() - b.x();</div>
<div class="line">      V(1, i) = vertices[i].y() - b.y();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> A   = V.adjoint();</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> mat = V * A;</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> inv = mat.inverse();</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a> diff; VectorXd vec(2);</div>
<div class="line">    <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; n; ++i) {</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> x = query.x() - b.x();</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> y = query.y() - b.y();</div>
<div class="line">      diff = <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(x, y);</div>
<div class="line"> </div>
<div class="line">      vec(0) = V(0, i);</div>
<div class="line">      vec(1) = V(1, i);</div>
<div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> res = inv * vec;</div>
<div class="line"> </div>
<div class="line">      *(coordinates++) =</div>
<div class="line">        diff.x() * res(0) + diff.y() * res(1) + 1.0 / double(n);</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Compute affine coordinates for all query points.</span></div>
<div class="line">  std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">"affine coordinates (all queries): "</span> &lt;&lt; std::endl &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;double&gt; coordinates;</div>
<div class="line">  coordinates.reserve(4);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; query : queries) {</div>
<div class="line">    coordinates.clear();</div>
<div class="line">    affine(query, std::back_inserter(coordinates));</div>
<div class="line">    <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; coordinates.size() - 1; ++i) {</div>
<div class="line">      std::cout &lt;&lt; coordinates[i] &lt;&lt; <span class="stringliteral">", "</span>;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; coordinates[coordinates.size() - 1] &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__barycenter__grp_html_ga93e459977649c2430139b5778101529b"><div class="ttname"><a href="../Kernel_23/group__barycenter__grp.html#ga93e459977649c2430139b5778101529b">CGAL::barycenter</a></div><div class="ttdeci">CGAL::Point_2&lt; Kernel &gt; barycenter(const CGAL::Point_2&lt; Kernel &gt; &amp;p1, const Kernel::FT &amp;w1, const CGAL::Point_2&lt; Kernel &gt; &amp;p2)</div></div>
</div><!-- fragment --><h2><a class="anchor" id="depr_example"></a>
Deprecated Coordinates</h2>
<p>This example illustrates how to use the deprecated API of this package. The used <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> is inexact and the used coordinates are mean value coordinates. The result is identical to the one from <a class="el" href="index.html#mv_coord_example">this example</a>.</p>
<p><a class="anchor" id="depr_coord_example"></a><br>
<b>File</b> <a class="el" href="Barycentric_coordinates_2_2deprecated_coordinates_8cpp-example.html">Barycentric_coordinates_2/deprecated_coordinates.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Installation/internal/disable_deprecation_warnings_and_errors.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Barycentric_coordinates_2/Generalized_barycentric_coordinates_2.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Barycentric_coordinates_2/Mean_value_2.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Typedefs.</span></div>
<div class="line"><span class="keyword">using </span><a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a> = <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>FT      = Kernel::FT;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a> = <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>Mean_value =</div>
<div class="line">  <a class="code hl_class" href="classCGAL_1_1Barycentric__coordinates_1_1Mean__value__2.html">CGAL::Barycentric_coordinates::Mean_value_2&lt;Kernel&gt;</a>;</div>
<div class="line"><span class="keyword">using </span>Mean_value_coordinates =</div>
<div class="line">  <a class="code hl_class" href="classCGAL_1_1Barycentric__coordinates_1_1Generalized__barycentric__coordinates__2.html">CGAL::Barycentric_coordinates::Generalized_barycentric_coordinates_2&lt;Mean_value, Kernel&gt;</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Construct a star-shaped polygon.</span></div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;Point_2&gt; star_shaped = {</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.0, 0.0), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>( 0.1, -0.8), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.3, 0.0), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.6, -0.5),</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.6, 0.1), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>( 1.1,  0.6), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.3, 0.2), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.1,  0.8),</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.1, 0.2), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(-0.7,  0.0) };</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Construct the class with mean value coordinates</span></div>
<div class="line">  <span class="comment">// for the star-shaped polygon defined above.</span></div>
<div class="line">  Mean_value_coordinates mean_value_coordinates(</div>
<div class="line">    star_shaped.begin(), star_shaped.end());</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Print some information about the polygon and coordinates.</span></div>
<div class="line">  mean_value_coordinates.print_information();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Construct some interior points in the polygon.</span></div>
<div class="line">  <span class="keyword">const</span> std::vector&lt;Point_2&gt; interior_points = {</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.12, -0.45), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.55, -0.3), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.9 , 0.45),</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.15,  0.35), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(-0.4, 0.04), <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.11, 0.11),</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.28,  0.12), <span class="comment">// the only point in the kernel of the star shaped polygon</span></div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Point_2</a>(0.55,  0.11) };</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// We speed up the computation using the O(n) algorithm called with the</span></div>
<div class="line">  <span class="comment">// parameter CGAL::Barycentric_coordinates::FAST.</span></div>
<div class="line">  <span class="comment">// The default one is CGAL::Barycentric_coordinates::PRECISE.</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> type_of_algorithm = <a class="code hl_enumvalue" href="namespaceCGAL_1_1Barycentric__coordinates.html#a5e5682512438422f23d6080edc49c05baa29350a20af70a27cca8f0715055118f">CGAL::Barycentric_coordinates::FAST</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// We also speed up the computation by using the parameter</span></div>
<div class="line">  <span class="comment">// query_point_location = CGAL::Barycentric_coordinates::ON_BOUNDED_SIDE.</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> query_point_location = <a class="code hl_enumvalue" href="namespaceCGAL_1_1Barycentric__coordinates.html#aedeeb072a2024053a016afd15e591331ae39bd08a2cdcb80b675b80d816742e6c">CGAL::Barycentric_coordinates::ON_BOUNDED_SIDE</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create a vector `std::vector` to store coordinates.</span></div>
<div class="line">  std::vector&lt;FT&gt; coordinates;</div>
<div class="line">  coordinates.reserve(star_shaped.size());</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Compute mean value coordinates for all interior points.</span></div>
<div class="line">  std::size_t count = 0;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; query : interior_points) {</div>
<div class="line">    coordinates.clear();</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> result = mean_value_coordinates(</div>
<div class="line">      query, std::back_inserter(coordinates), query_point_location, type_of_algorithm);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Status of the computation.</span></div>
<div class="line">    <span class="keyword">const</span> std::string status = (result ? <span class="stringliteral">"SUCCESS."</span> : <span class="stringliteral">"FAILURE."</span>);</div>
<div class="line">    std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">"point: "</span> &lt;&lt; count &lt;&lt; <span class="stringliteral">", status of the computation: "</span> &lt;&lt; status &lt;&lt; std::endl;</div>
<div class="line">    ++count;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Output the coordinates.</span></div>
<div class="line">    <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; coordinates.size() - 1; ++i) {</div>
<div class="line">      std::cout &lt;&lt; coordinates[i] &lt;&lt; <span class="stringliteral">", "</span>;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; coordinates[coordinates.size() - 1] &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="ttc" id="aclassCGAL_1_1Barycentric__coordinates_1_1Generalized__barycentric__coordinates__2_html"><div class="ttname"><a href="classCGAL_1_1Barycentric__coordinates_1_1Generalized__barycentric__coordinates__2.html">CGAL::Barycentric_coordinates::Generalized_barycentric_coordinates_2</a></div><div class="ttdoc">The class Generalized_barycentric_coordinates_2 implements generalized barycentric coordinates along ...</div><div class="ttdef"><b>Definition:</b> Generalized_barycentric_coordinates_2.h:57</div></div>
<div class="ttc" id="aclassCGAL_1_1Barycentric__coordinates_1_1Mean__value__2_html"><div class="ttname"><a href="classCGAL_1_1Barycentric__coordinates_1_1Mean__value__2.html">CGAL::Barycentric_coordinates::Mean_value_2</a></div><div class="ttdoc">The class Mean_value_2 implements 2D mean value coordinates ( , ,  ).</div><div class="ttdef"><b>Definition:</b> Mean_value_2.h:112</div></div>
<div class="ttc" id="anamespaceCGAL_1_1Barycentric__coordinates_html_a5e5682512438422f23d6080edc49c05baa29350a20af70a27cca8f0715055118f"><div class="ttname"><a href="namespaceCGAL_1_1Barycentric__coordinates.html#a5e5682512438422f23d6080edc49c05baa29350a20af70a27cca8f0715055118f">CGAL::Barycentric_coordinates::FAST</a></div><div class="ttdeci">@ FAST</div><div class="ttdoc">A fast algorithm, which is less precise but much faster.</div><div class="ttdef"><b>Definition:</b> barycentric_enum_2.h:122</div></div>
<div class="ttc" id="anamespaceCGAL_1_1Barycentric__coordinates_html_aedeeb072a2024053a016afd15e591331ae39bd08a2cdcb80b675b80d816742e6c"><div class="ttname"><a href="namespaceCGAL_1_1Barycentric__coordinates.html#aedeeb072a2024053a016afd15e591331ae39bd08a2cdcb80b675b80d816742e6c">CGAL::Barycentric_coordinates::ON_BOUNDED_SIDE</a></div><div class="ttdeci">@ ON_BOUNDED_SIDE</div><div class="ttdoc">Query point is located inside the polygon, excluding the boundary.</div><div class="ttdef"><b>Definition:</b> barycentric_enum_2.h:99</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The headers <code>Segment_coordinates_2.h</code> and <code>Triangle_coordinates_2.h</code> are not capitalized in the new version that is they are named <code>segment_coordinates_2.h</code> and <code>triangle_coordinates_2.h</code>.</dd></dl>
<h1><a class="anchor" id="gbc_degeneracies"></a>
Edge Cases</h1>
<p>Not all presented coordinates are general enough to handle any query point in the plane, that is why we highly recommend reading this section in order to learn what can be expected from each coordinate function. If you want to get more mathematical details about each coordinate function as well as the complete history and theory behind barycentric coordinates, you should read <a class="el" href="citelist.html#CITEREF_cgal:bc:hs-gbcicg-17">[6]</a>. You can also read an overview <a href="https://susi.usi.ch/usi/documents/318813">here</a> (chapters 1 and 2).</p>
<p><a class="anchor" id="compute_seg_coord"></a></p>
<h2><a class="anchor" id="gbc_deg_segment_coordinates"></a>
Segment Coordinates</h2>
<p>The segment coordinate function with respect to a given segment vertex is a linear function along the supporting line of this segment that grows from zero at the opposite vertex to one at the chosen vertex (see the figure below).</p>
<p><a class="anchor" id="fig__seg_coord"></a> </p><div class="image">
<object type="image/svg+xml" data="seg_coord.svg" style="pointer-events: none;"></object>
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__seg_coord">Figure 104.12</a> The segment coordinate function with respect to the vertex \(v_0\). </p> </div> <p> <br>
</p>
<p>Segment coordinates can be computed exactly if an exact number type is chosen. The segment itself, with respect to which we compute coordinates, must be non-degenerate. If both conditions are satisfied, then the computation never fails. However, to compute coordinates, the user must ensure that the query point lies exactly on the line \(L\) supporting the segment. Since in many applications this is not the case, and a query point may lie very close but not exactly on this line, we provide a solution to remedy this situation.</p>
<p><a class="anchor" id="fig__seg_coord_projection"></a> </p><div class="image">
<object type="image/svg+xml" data="seg_coord_projection.svg" style="pointer-events: none;"></object>
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__seg_coord_projection">Figure 104.13</a> The orthogonal projection \(p'\) of the vector \(p\) (green) onto the vector \(q\) (red). </p> </div> <p> <br>
</p>
<p>Suppose that some query point \(v\) does not lie exactly on the line \(L\), but is some distance \(d\) away as shown in the figure above. If we want to compute the segment coordinate \(b_1(v)\) with respect to the vertex \(v_1\), we first find the orthogonal projection \(p'\) of the vector \(p\) onto the vector \(q\) and then normalize it by the length of \(q\). This yields the segment coordinate \(b_1(v') = b_1(v)\) if \(v\) lies exactly on the line. The other segment coordinate \(b_0(v')\) that is equal to \(b_0(v)\) when \(v\) is on the line \(L\) is computed the same way but with the projection of the vector \(\vec{vv_1}\).</p>
<p><b>Warning:</b> do not abuse the feature described above, because it does not yield correct segment coordinates for the point \(v\) but rather those for \(v'\). Moreover, segment coordinates for a point \(v\), which does not lie exactly on the line \(L\), do not exist. But if the non-zero distance \(d\) is due to some numerical instability when computing the location of the point \(v\) or any other problem, which causes the point to be not exactly on the line, the final segment coordinates will be, at least approximately, correct.</p>
<p>With inexact number types, the resulting coordinate values are correct up to the precision of the chosen type.</p>
<p><a class="anchor" id="compute_tri_coord"></a></p>
<h2><a class="anchor" id="gbc_deg_triangular_coordinates"></a>
Triangle Coordinates</h2>
<p>The triangle coordinate function with respect to a given triangle vertex is a linear function that grows from zero along the opposite edge to one at the chosen vertex (see the figure below).</p>
<p><a class="anchor" id="fig__tri_coord"></a> </p><div class="image">
<object type="image/svg+xml" data="tri_coord.svg" style="pointer-events: none;"></object>
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__tri_coord">Figure 104.14</a> The triangle coordinate function with respect to the vertex \(v_0\). </p> </div> <p> <br>
</p>
<p>To compute the triangle coordinates of the query point \(v\), we adopt the standard simple formula</p>
<center> \(b_i = \frac{A_i}{A}\) with \(i = 0\dots 2\) </center><p>where \(A_i\) is the signed area of the sub-triangle opposite to the vertex \(i\) and \(A\) is the total area of the triangle that is \(A = A_0 + A_1 + A_2\) (see the figure below).</p>
<p><a class="anchor" id="tri_notations"></a><a class="anchor" id="fig__tri_notations"></a> </p><div class="image">
<object type="image/svg+xml" data="tri_notations.svg" style="pointer-events: none;"></object>
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__tri_notations">Figure 104.15</a> Notation for triangle coordinates. </p> </div> <p> <br>
</p>
<p>These coordinates can be computed exactly if an exact number type is chosen, for any query point in the plane and with respect to any non-degenerate triangle. No special cases are handled. The computation always yields the correct result. The notion of correctness depends on the precision of the used number type. Note that for exterior points some coordinate values will be negative.</p>
<p><a class="anchor" id="compute_wp_coord"></a></p>
<h2><a class="anchor" id="gbc_deg_wachspress_coordinates"></a>
Wachspress Coordinates</h2>
<p>Wachspress coordinates are well-defined in the closure of any <em>strictly convex polygon</em>. Therefore, when using an exact number type, for any query point from the polygon's closure, these coordinates are computed exactly and no false result is expected. For exterior query points, the coordinates can also be computed but not everywhere (see below for more details). For inexact number types, the resulting precision of the computation is due to the involved algorithm and a chosen number type. In the following paragraph, we discuss two available algorithms for computing Wachspress coordinates when an inexact number type is used. The chosen algorithm is specified by a computation policy <code><a class="el" href="namespaceCGAL_1_1Barycentric__coordinates.html#a478bbcec416216b2274ee4b4e97b0e6c" title="Computation_policy_2 provides a way to choose an asymptotic time complexity of the algorithm and its ...">Barycentric_coordinates::Computation_policy_2</a></code>.</p>
<p><a class="anchor" id="wp_polygon"></a><a class="anchor" id="fig__wp_notations"></a> </p><div class="image">
<object type="image/svg+xml" data="wp_notations.svg" style="pointer-events: none;"></object>
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__wp_notations">Figure 104.16</a> Notation for Wachspress coordinates. </p> </div> <p> <br>
</p>
<p>To compute Wachspress weights, we follow <a class="el" href="citelist.html#CITEREF_cgal:bc:fhk-gcbcocp-06">[2]</a> and use the formula</p>
<center> \(w_i = \frac{C_i}{A_{i-1}A_i}\) </center><p>with \(i = 1\dots n\) where \(n\) is the number of polygon vertices. In order to compute the coordinates, we normalize these weights,</p>
<center> \(b_i = \frac{w_i}{W^{wp}}\qquad\) with \(\qquad W^{wp} = \sum_{j=1}^n w_j.\) </center><p>This formula becomes unstable when approaching the boundary of the polygon ( \(\approx 1.0e-10\) and closer). To fix the problem, we modify the weights \(w_i\) as</p>
<center> \(\bar{w}_i = C_i\prod_{j\not=i-1,i} A_j\). </center><p>After the above normalization, this gives us the precise algorithm to compute Wachspress coordinates but with \(O(n^2)\) performance only. The max speed \(O(n)\) algorithm uses the standard weights \(w_i\). Note that mathematically this modification does not change the coordinates. One should be cautious when using the unnormalized Wachspress weights. In that case, you must choose the \(O(n)\) type.</p>
<p>It is known that for strictly convex polygons the denominator's zero set of the Wachspress coordinates ( \(W^{wp} = 0~\)) is a curve, which (in many cases) lies quite far away from the polygon. More specifically, it interpolates the intersection points of the supporting lines of the polygon edges. Therefore, the computation of Wachspress coordinates outside the polygon is possible only at points that do not belong to this curve.</p>
<p><a class="anchor" id="fig__wp_zero_set"></a> </p><div class="image">
<object type="image/svg+xml" data="wp_zero_set.svg" style="pointer-events: none;"></object>
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__wp_zero_set">Figure 104.17</a> Zero set (red) of the Wachspress coordinates' denominator \(W^{wp}\) for a non-regular hexagon. </p> </div> <p> <br>
</p>
<p><b>Warning:</b> we do not recommend using Wachspress coordinates for exterior points!</p>
<p><a class="anchor" id="compute_dh_coord"></a></p>
<h2><a class="anchor" id="gbc_deg_discrete_harmonic_coordinates"></a>
Discrete Harmonic Coordinates</h2>
<p>Discrete harmonic coordinates have the same requirements as Wachspress coordinates. They are well-defined in the closure of any <em>strictly convex polygon</em> and, if an exact number type is chosen, they are computed exactly. However, and unlike Wachspress basis functions, these coordinates are not necessarily positive. In particular, the weight \(w_i\) is positive if and only if \(\alpha+\beta &lt; \pi\) (see the figure below for notation). For inexact number types, the precision of the computation is due to the involved algorithm and a chosen number type. Again, we describe two algorithms to compute the coordinates when an inexact number type is used: one is of max precision and one is of max speed.</p>
<p><a class="anchor" id="dh_polygon"></a><a class="anchor" id="fig__dh_notations"></a> </p><div class="image">
<object type="image/svg+xml" data="dh_notations.svg" style="pointer-events: none;"></object>
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__dh_notations">Figure 104.18</a> Notation for discrete harmonic coordinates. </p> </div> <p> <br>
</p>
<p>To compute discrete harmonic weights, we follow <a class="el" href="citelist.html#CITEREF_cgal:bc:fhk-gcbcocp-06">[2]</a> and use the formula</p>
<center> \(w_i = \frac{r_{i+1}^2A_{i-1}-r_i^2B_i+r_{i-1}^2A_i}{A_{i-1}A_i}\) </center><p>with \(i = 1\dots n\) where \(n\) is the number of polygon vertices. In order to compute the coordinates, we normalize these weights,</p>
<center> \(b_i = \frac{w_i}{W^{dh}}\qquad\) with \(\qquad W^{dh} = \sum_{j=1}^n w_j.\) </center><p>This formula becomes unstable when approaching the boundary of the polygon ( \(\approx 1.0e-10\) and closer). To fix the problem, similarly to the previous subsection, we modify the weights \(w_i\) as</p>
<center> \(\bar{w}_i = (r_{i+1}^2A_{i-1}-r_i^2B_i+r_{i-1}^2A_i)\prod_{j\not=i-1,i} A_j\). </center><p>After the above normalization, this yields the precise algorithm to compute discrete harmonic coordinates but with \(O(n^2)\) performance only. The max speed \(O(n)\) algorithm uses the standard weights \(w_i\). Again, mathematically this modification does not change the coordinates, one should be cautious when using the unnormalized discrete harmonic weights. In that case, you must choose the \(O(n)\) type.</p>
<p><b>Warning:</b> as for Wachspress coordinates, we do not recommend using discrete harmonic coordinates for exterior points, because the curve \(W^{dh} = 0\) may have several components, and one of them interpolates the polygon vertices. However, if you are sure that the query point does not belong to this curve, you can compute the coordinates as shown in <a class="el" href="index.html#dh_example">this example</a>.</p>
<p><a class="anchor" id="compute_mv_coord"></a></p>
<h2><a class="anchor" id="gbc_deg_mean_value_coordinates"></a>
Mean Value Coordinates</h2>
<p>Unlike the previous coordinates, mean value coordinates cannot be computed exactly due to an inevitable square root operation. Although, if an exact number type is used, the default precision of the computation depends only on two CGAL functions: <code><a class="elRef" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1f1bcd74fce34fd532445590bbda5cd5">CGAL::to_double()</a></code> and <code><a class="elRef" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">CGAL::sqrt()</a></code>. It is worth saying that providing a number type that supports exact or nearly exact computation of the square root is possible, however since such types are usually impractical due to the large overhead, the conversion to a floating-point format above is always effective. On the other hand, mean value coordinates are well-defined everywhere in the plane for any simple polygon. In addition, if your traits class provides a more precise version of the square root function, the final precision of the computation with exact number types will depend only on the precision of that function.</p>
<p><a class="anchor" id="mv_polygon"></a><a class="anchor" id="fig__mv_notations"></a> </p><div class="image">
<object type="image/svg+xml" data="mv_notations.svg" style="pointer-events: none;"></object>
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__mv_notations">Figure 104.19</a> Notation for mean value coordinates. </p> </div> <p> <br>
</p>
<p>For these coordinates, we provide two algorithms: one is of max precision and one is of max speed. The first one works everywhere in the plane, and the precision of the computation depends only on the chosen number type, including the remarks above. This algorithm is based on the following weight formula from <a class="el" href="citelist.html#CITEREF_cgal:bc:f-wmvc-14">[4]</a></p>
<center> \(w_i = \sigma_i\bar{w}_i\qquad\) with \(\qquad\bar{w}_i = (r_{i-1}r_{i+1}-d_{i-1}d_{i+1})^{1/2}\prod_{j\not= i-1,i}(r_jr_{j+1} + d_jd_{j+1})^{1/2}\qquad\) where \(\qquad r_i = \|d_i\|.\) </center><p>Since \(\bar{w}_i\) is always positive, we must append to it the proper sign \(\sigma_i\) of the signed mean value weight, which can be found efficiently (see the figures below). This weight is always positive to the left of the red piecewise linear curve, and it is negative to the right of this curve, moving in the counterclockwise direction.</p>
<p><a class="anchor" id="fig__mv_weight_signs"></a> </p><div class="image">
<object type="image/svg+xml" data="mv_weight_signs.svg" style="pointer-events: none;"></object>
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__mv_weight_signs">Figure 104.20</a> Signs of the mean value weight \(w_i\) depending on the region with respect to a convex polygon \(P\) and a concave polygon \(P'\). </p> </div> <p> <br>
</p>
<p>After the normalization of these weights as before</p>
<center> \(b_i = \frac{w_i}{W^{mv}}\qquad\) with \(\qquad W^{mv} = \sum_{j=1}^n w_j\) </center><p>we obtain the max precision \(O(n^2)\) algorithm. The max speed \(O(n)\) algorithm computes the weights \(w_i\) using the pseudocode from <a href="https://www.inf.usi.ch/hormann/nsfworkshop/presentations/Hormann.pdf">here</a>. These weights</p>
<center> \(w_i = \frac{t_{i-1} + t_i}{r_i}\qquad\) with \(\qquad t_i = \frac{\text{det}(d_i, d_{i+1})}{r_ir_{i+1} + d_id_{i+1}}\) </center><p>are also normalized. Note that they are unstable if a query point is closer than \(\approx 1.0e-10\) to the polygon boundary, similarly to Wachspress and discrete harmonic coordinates and one should be cautious when using the unnormalized mean value weights. In that case, you must choose the \(O(n)\) type.</p>
<p><a class="anchor" id="compute_hm_coord"></a></p>
<h2><a class="anchor" id="gbc_deg_harmonic_coordinates"></a>
Harmonic Coordinates</h2>
<p>The harmonic coordinates are computed by solving the Laplace equation</p>
<center> \(\Delta b = 0\) </center><p>subject to suitable Dirichlet boundary conditions. Harmonic coordinates are the only coordinates in this package, which are guaranteed to be non-negative in the closure of any simple polygon and satisfy all properties of barycentric coordinates, however such desirable properties come with the fact that these coordinates are well-defined only inside a polygon. If an exterior query point is provided, its coordinates are set to zero.</p>
<p>Another disadvantage of these coordinates is that they cannot be computed exactly, because harmonic coordinates do not have a simple closed-form expression and must be approximated. The common way to approximate these coordinates is by discretizing over the space of piecewise linear functions with respect to a triangulation of the polygon. The denser triangulation of the interior part of the polygon, the better approximation of the coordinates. To get a high quality approximation of the coordinates, the user should provide a rather dense partition of the polygon's interior domain that in turn leads to larger running times when computing the coordinates.</p>
<p><a class="anchor" id="terrain_triangulation_fig"></a><a class="anchor" id="fig__terrain_triangulation"></a> </p><div class="image">
<object type="image/svg+xml" data="terrain_triangulation.svg" style="pointer-events: none;"></object>
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__terrain_triangulation">Figure 104.21</a> Sparse triangulation of the polygon's interior domain (left): smaller running times, lower coordinates quality; dense triangulation (right): larger running times, higher coordinates quality. </p> </div> <p> <br>
</p>
<p>From all this follows, that any exact <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> will be rejected and it is not possible to compute analytic harmonic weights. However, once the coordinates are computed at the vertices of the triangulation, they can be evaluated analytically at any interior query point. For evaluation, we first locate a triangle that contains the query point and then linearly interpolate harmonic coordinates defined at the vertices of this triangle to the query point with the help of <a class="el" href="index.html#gbc_deg_triangular_coordinates">triangle coordinates</a> as</p>
<center> \(b_i = b_0^{tr} b_i^0 + b_1^{tr} b_i^1 + b_2^{tr} b_i^2\) </center><p>with \(i = 1\dots n\), where \(n\) is the number of polygon vertices, \(b_{0}^{tr}\), \(b_{1}^{tr}\), and \(b_{2}^{tr}\) are the triangle coordinates of the query point with respect the three vertices of the located triangle, and \(b_i^{0}\), \(b_i^{1}\), and \(b_i^{2}\) are the harmonic coordinates pre-computed at the triangle vertices.</p>
<h1><a class="anchor" id="gbc_performance"></a>
Performance</h1>
<p>We strive for robustness and efficiency at the same time. Efficiency is especially important. These coordinates are used in many applications where they must be computed for millions of points and, thus, the real time computation of coordinates has been made possible. In this section, we present next the computation runtimes of the implemented algorithms.</p>
<p>The structure of the speed test that we use to evaluate the running times consists of computing coordinate values (or weights) at &gt;= 1 million strictly interior points with respect to a polygon (or triangle, or segment). At each iteration of the loop, we create a query point and compute its coordinates. The time presented in the log-log scale plot at the end of the section is the arithmetic mean of all trials in the loop of 10 iterations. The time presented in the plot is for analytic coordinates only since harmonic coordinates of a reasonable (application-dependent) quality are substantially slower to compute and cannot be fairly compared to the analytic coordinate functions.</p>
<p>The time to compute coordinates depends on many factors such as memory allocation, input kernel, output container, number of points, etc. In our tests, we used the most standard C++ and CGAL features with minimum memory allocation. Therefore, the final time presented is the average time that can be expected without deep optimization but still with efficient memory allocation. It also means that it may vary depending on the usage of the package.</p>
<p>To benchmark analytic coordinates, we used a MacBook Pro 2011 with 2 GHz Intel Core i7 processor (2 cores) and 8 GB 1333 MHz DDR3 memory. The installed operating system was OS X 10.9 Maverick. The resulting timings for all closed-form coordinates can be found in the figure below.</p>
<p><a class="anchor" id="fig__analytic_timings"></a> </p><div class="image">
<img src="analytic_timings.png" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__analytic_timings">Figure 104.22</a> Time in seconds to compute \(n\) coordinate values for a polygon with \(n\) vertices at 1 million query points with the max speed \(O(n)\) algorithms (dashed) and the max precision \(0(n^2)\) algorithms (solid) for Wachspress (blue), discrete harmonic (red), and mean value (green) coordinates. </p> </div> <p> <br>
</p>
<p>From the figure above we observe that the \(O(n^2)\) algorithm is as fast as the \(O(n)\) algorithm if we have a polygon with a small number of vertices. But as the number of vertices is increased, the linear algorithm outperforms the squared one, as expected. One of the reasons for this behavior is that for a small number of vertices the multiplications of \(n-2\) elements inside the \(O(n^2)\) algorithm take almost the same time as the corresponding divisions in the \(O(n)\) algorithm. For a polygon with many vertices, these multiplications are substantially slower.</p>
<p>To benchmark harmonic coordinates, we used a MacBook Pro 2018 with 2.2 GHz Intel Core i7 processor (6 cores) and 32 GB 2400 MHz DDR4 memory. The installed operating system was OS X 10.15 Catalina. The average time to compute harmonic coordinates in the loop of 10 iterations can be found in the tables below.</p>
<p>The first table shows how the time to compute the coordinates on a unit square depends on the number of triangulation vertices. We show separately the time to setup the matrix, factorize it, and solve it with respect to the four vertices of the unit square.</p>
<table class="markdownTable" align="center">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Number of queries (approx.) </th><th class="markdownTableHeadCenter">Setup (in seconds) </th><th class="markdownTableHeadCenter">Factorize (in seconds) </th><th class="markdownTableHeadCenter">Solve (in seconds) </th><th class="markdownTableHeadCenter">Total (in seconds)  </th></tr>
<tr class="markdownTableBody">
<td class="markdownTableBodyCenter">100 </td><td class="markdownTableBodyCenter">0.000056 </td><td class="markdownTableBodyCenter">0.000099 </td><td class="markdownTableBodyCenter">0.000015 </td><td class="markdownTableBodyCenter">0.000170  </td></tr>
<tr class="markdownTableBody">
<td class="markdownTableBodyCenter">500 </td><td class="markdownTableBodyCenter">0.000266 </td><td class="markdownTableBodyCenter">0.000574 </td><td class="markdownTableBodyCenter">0.000064 </td><td class="markdownTableBodyCenter">0.000904  </td></tr>
<tr class="markdownTableBody">
<td class="markdownTableBodyCenter">1,000 </td><td class="markdownTableBodyCenter">0.000509 </td><td class="markdownTableBodyCenter">0.001194 </td><td class="markdownTableBodyCenter">0.000147 </td><td class="markdownTableBodyCenter">0.001850  </td></tr>
<tr class="markdownTableBody">
<td class="markdownTableBodyCenter">25,000 </td><td class="markdownTableBodyCenter">0.014749 </td><td class="markdownTableBodyCenter">0.071152 </td><td class="markdownTableBodyCenter">0.008191 </td><td class="markdownTableBodyCenter">0.094092  </td></tr>
<tr class="markdownTableBody">
<td class="markdownTableBodyCenter">50,000 </td><td class="markdownTableBodyCenter">0.034255 </td><td class="markdownTableBodyCenter">0.184237 </td><td class="markdownTableBodyCenter">0.018166 </td><td class="markdownTableBodyCenter">0.236658  </td></tr>
<tr class="markdownTableBody">
<td class="markdownTableBodyCenter">100,000 </td><td class="markdownTableBodyCenter">0.065117 </td><td class="markdownTableBodyCenter">0.543177 </td><td class="markdownTableBodyCenter">0.044088 </td><td class="markdownTableBodyCenter">0.652382  </td></tr>
<tr class="markdownTableBody">
<td class="markdownTableBodyCenter">500,000 </td><td class="markdownTableBodyCenter">0.576530 </td><td class="markdownTableBodyCenter">7.697143 </td><td class="markdownTableBodyCenter">0.310765 </td><td class="markdownTableBodyCenter">8.584438  </td></tr>
<tr class="markdownTableBody">
<td class="markdownTableBodyCenter">1,000,000 </td><td class="markdownTableBodyCenter">1.295163 </td><td class="markdownTableBodyCenter">26.76945 </td><td class="markdownTableBodyCenter">0.737372 </td><td class="markdownTableBodyCenter">28.80199  </td></tr>
</table>
<p>The same results can be seen in the figure.</p>
<p><a class="anchor" id="fig__hm_4_bench"></a> </p><div class="image">
<object type="image/svg+xml" data="hm_4_bench.svg" style="pointer-events: none;"></object>
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__hm_4_bench">Figure 104.23</a> Time in seconds to setup (red), factorize (green), and solve (blue) for harmonic coordinate values with respect to a unit square. </p> </div> <p> <br>
</p>
<p>The second table shows how the time to compute the coordinates for 100k queries depends on the number of the polygon vertices. We show separately the time to setup the matrix, factorize it, and solve it with respect to the \(n\) vertices of the polygon. It can be seen that, unlike in the first table, the time to factorize the matrix here stays constant.</p>
<table class="markdownTable" align="center">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Number of vertices (approx.) </th><th class="markdownTableHeadCenter">Setup (in seconds) </th><th class="markdownTableHeadCenter">Factorize (in seconds) </th><th class="markdownTableHeadCenter">Solve (in seconds) </th><th class="markdownTableHeadCenter">Total (in seconds)  </th></tr>
<tr class="markdownTableBody">
<td class="markdownTableBodyCenter">5 </td><td class="markdownTableBodyCenter">0.083444 </td><td class="markdownTableBodyCenter">0.631823 </td><td class="markdownTableBodyCenter">0.059827 </td><td class="markdownTableBodyCenter">0.775094  </td></tr>
<tr class="markdownTableBody">
<td class="markdownTableBodyCenter">10 </td><td class="markdownTableBodyCenter">0.060294 </td><td class="markdownTableBodyCenter">0.450534 </td><td class="markdownTableBodyCenter">0.094583 </td><td class="markdownTableBodyCenter">0.605411  </td></tr>
<tr class="markdownTableBody">
<td class="markdownTableBodyCenter">25 </td><td class="markdownTableBodyCenter">0.062760 </td><td class="markdownTableBodyCenter">0.478683 </td><td class="markdownTableBodyCenter">0.254953 </td><td class="markdownTableBodyCenter">0.796396  </td></tr>
<tr class="markdownTableBody">
<td class="markdownTableBodyCenter">50 </td><td class="markdownTableBodyCenter">0.097359 </td><td class="markdownTableBodyCenter">0.492233 </td><td class="markdownTableBodyCenter">0.539654 </td><td class="markdownTableBodyCenter">1.129246  </td></tr>
<tr class="markdownTableBody">
<td class="markdownTableBodyCenter">100 </td><td class="markdownTableBodyCenter">0.129487 </td><td class="markdownTableBodyCenter">0.450771 </td><td class="markdownTableBodyCenter">1.152544 </td><td class="markdownTableBodyCenter">1.732802  </td></tr>
<tr class="markdownTableBody">
<td class="markdownTableBodyCenter">500 </td><td class="markdownTableBodyCenter">0.430694 </td><td class="markdownTableBodyCenter">0.460321 </td><td class="markdownTableBodyCenter">6.620061 </td><td class="markdownTableBodyCenter">7.511076  </td></tr>
<tr class="markdownTableBody">
<td class="markdownTableBodyCenter">1000 </td><td class="markdownTableBodyCenter">0.812362 </td><td class="markdownTableBodyCenter">0.480052 </td><td class="markdownTableBodyCenter">16.14239 </td><td class="markdownTableBodyCenter">17.43480  </td></tr>
</table>
<p>The same results can be seen in the figure.</p>
<p><a class="anchor" id="fig__hm_n_bench"></a> </p><div class="image">
<object type="image/svg+xml" data="hm_n_bench.svg" style="pointer-events: none;"></object>
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__hm_n_bench">Figure 104.24</a> Time in seconds to setup (red), factorize (green), and solve (blue) for harmonic coordinate values with respect to a polygon with \(n\) vertices at 100k query points. </p> </div> <p> <br>
</p>
<p>While, in the first table, the most significant step is to factorize the matrix, in the second table, the slowest step is to solve for coordinates, as expected.</p>
<h1><a class="anchor" id="gbc_history"></a>
History</h1>
<p>The package was first released in 2015 and included segment, triangle, Wachspress, discrete harmonic, and mean value coordinates. The API of that version is now deprecated but can still be used. An example of the old API can be found <a class="el" href="index.html#depr_example">here</a>. The docs of that API are also preserved and maintained <a class="el" href="group__PkgBarycentricCoordinates2RefDeprecated.html">here</a>.</p>
<p>In 2018, this package was modified and improved by Keyu Chen and Dmitry Anisimov during the Google Summer of Code. The API was changed to the current version. In 2020, the new version was cleaned up and documented that includes:</p><ul>
<li>the classes <code><a class="el" href="classCGAL_1_1Barycentric__coordinates_1_1Segment__coordinates__2.html" title="The class Segment_coordinates_2 implements barycentric coordinates with respect to an arbitrary non-d...">Segment_coordinates_2</a></code> and <code><a class="el" href="classCGAL_1_1Barycentric__coordinates_1_1Triangle__coordinates__2.html" title="The class Triangle_coordinates_2 implements barycentric coordinates ( [1], [2] ) with respect to an a...">Triangle_coordinates_2</a></code> have been removed, only the free functions are preserved;</li>
<li>the entry class <code><a class="el" href="classCGAL_1_1Barycentric__coordinates_1_1Generalized__barycentric__coordinates__2.html" title="The class Generalized_barycentric_coordinates_2 implements generalized barycentric coordinates along ...">Generalized_barycentric_coordinates_2</a></code> was removed since it is not flexible enough to accommodate all types of 2D barycentric coordinates;</li>
<li>the classes <code><a class="el" href="classCGAL_1_1Barycentric__coordinates_1_1Wachspress__2.html" title="The class Wachspress_2 implements 2D Wachspress coordinates ( , ,  ).">Wachspress_2</a></code>, <code>Discrete harmonic_2</code>, and <code><a class="el" href="classCGAL_1_1Barycentric__coordinates_1_1Mean__value__2.html" title="The class Mean_value_2 implements 2D mean value coordinates ( , ,  ).">Mean_value_2</a></code> have been renamed and modified so that they can be used now on their own without the class <code><a class="el" href="classCGAL_1_1Barycentric__coordinates_1_1Generalized__barycentric__coordinates__2.html" title="The class Generalized_barycentric_coordinates_2 implements generalized barycentric coordinates along ...">Generalized_barycentric_coordinates_2</a></code>;</li>
<li>harmonic coordinates have been added;</li>
<li>the free functions for segment and triangle coordinates have been modified and improved;</li>
<li>the free functions for Wachspress, discrete harmonic, and mean value weights and coordinates have been added;</li>
<li>the free functions to compute barycentric coordinates for points on the polygon boundary have been added;</li>
<li>all functions and classes are now using ranges and property maps;</li>
<li>examples, tests, and benchmarks are modified/extended/improved;</li>
<li>the docs are refactored and simplified.</li>
</ul>
<h1><a class="anchor" id="gbc_acknowledgments"></a>
Acknowledgments</h1>
<p>The authors wish to thank <a href="https://cs.nyu.edu/~teseo/">Teseo Schneider</a> and Randolf Schaerfig for helpful comments and discussions. We also appreciate the great effort invested in this package by our reviewers Andreas Fabri, SÃ©bastien Loriot, and Efi Fogel. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"></a> 1.9.6 </li>
  </ul>
</div>
</div>
</body>


</html>
