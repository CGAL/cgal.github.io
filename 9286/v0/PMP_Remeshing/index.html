<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/PMP_Remeshing/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=11">
<meta name="generator" content="Doxygen 1.9.6">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CGAL 6.2 - Meshing and Remeshing of Polygonal Meshes: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/doxygen.css" rel="stylesheet" type="text/css">
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      },
      equationNumbers: { autoNumber: "AMS" }
  }
}
);
MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
  var PARSE = MathJax.InputJax.TeX.Parse,
      TEXT = PARSE.prototype.InternalText;
  PARSE.Augment({
    InternalText: function (text,def) {
      text = text.replace(/\\/g,"");
      return TEXT.call(this,text,def);
    }
  });
});
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
      <span class="left">
         <span id="MSearchSelect" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"> 
        </span>
        <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
      </span>
      <span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.svg" alt=""></a>
      </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CGAL 6.2 - Meshing and Remeshing of Polygonal Meshes
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search/",'.html');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">User Manual </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_PMPRemeshing"></a> </p> <div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Authors</dt><dd>Sébastien Loriot, Jane Tournois, Mael Rouxel-Labbé, Konstantinos Katrioplas, Ivan Pađen, Hossam Saeed, Ilker O. Yaz, and Sébastien Valette</dd></dl>
<p><a class="anchor" id="fig__PMPRemeshingBanner"></a></p><center> <img src="pmp-remeshing-banner.png" alt="" style="max-width:60%;" class="inline"> </center><h1><a class="anchor" id="PMPRemeshingIntro"></a>
Introduction</h1>
<p>The number of elements as well as their quality are key factors for the efficiency of algorithms involving polygonal meshes: too many elements lead to high computational costs, while poorly-shaped elements may lead to numerical instabilities and inaccurate results. Remeshing techniques aim at improving the quality of a mesh by modifying its combinatorial structure and geometric embedding.</p>
<p>This package provides a collection of methods and classes to perform meshing and remeshing of polygonal meshes. One can distinguish between <em>local</em> remeshing algorithms, which work on the input using only local modifications (edge splits, collapses, flips, vertex relocations), from <em>global</em> remeshing algorithms, which construct a new mesh from scratch.</p>
<p>Another important distinction exists between <em>combinatorial</em> remeshing algorithms, which only modify the combinatorial structure of the mesh (i.e., its connectivity), and <em>geometric</em> remeshing algorithms, which also modify the position of the mesh vertices.</p>
<p>Selecting the most suitable remeshing algorithm depends on the specific requirements of the application.</p>
<p>For reference, two other CGAL packages provide related functionalities:</p><ul>
<li><a class="elRef" href="../Manual/packages.html#PkgSurfaceMeshSimplification">Triangulated Surface Mesh Simplification</a> implements algorithms for reducing the number of mesh elements while preserving overall shape and features.</li>
<li><a class="elRef" href="../Manual/packages.html#PkgSurfaceSubdivisionMethod3">3D Surface Subdivision Methods</a> provides subdivision schemes for refining and smoothing polygonal meshes.</li>
</ul>
<h2><a class="anchor" id="PMPRemeshingOutline"></a>
Outline</h2>
<p>This manual is organized as follows:</p><ul>
<li><a class="el" href="index.html#PMPRemeshingLocal">Local Remeshing</a> : Local remeshing algorithms, including isotropic remeshing, approximated discrete centroidal Voronoi diagram remeshing, and smoothing algorithms.</li>
<li><a class="el" href="index.html#PMPmesh3rem">Delaunay-Based Surface Remeshing</a> : Global remeshing algorithm based on Delaunay refinement.</li>
<li><a class="el" href="index.html#PMPdecimate">Remeshing of (Almost) Planar Patches</a> : Global remeshing of (almost) planar patches to minimize the number of elements.</li>
<li><a class="el" href="index.html#Extrusion">Extrusion</a> : Extrusion of triangle meshes with boundaries.</li>
</ul>
<h1><a class="anchor" id="PMPRemeshingCombi"></a>
Combinatorial Remeshing</h1>
<p>Many algorithms require input meshes in which all faces have the same degree, or are exclusively triangles. Triangulating all polygonal faces of a mesh is therefore often necessary.</p>
<p>This package provides the function <code><a class="el" href="group__PMP__combi__remeshing__grp.html#ga5e4f69483f6506429c4743de745e7b09" title="triangulates given faces of a polygon mesh.">CGAL::Polygon_mesh_processing::triangulate_faces()</a></code>, which triangulates all faces of the input polygon mesh. For each face, an approximated support plane is selected, orthogonal to the normal vector computed by <code><a class="elRef" href="../Polygon_mesh_processing/group__PMP__normal__grp.html#ga8d98ee0b7fdfe2e3a0fad7ec18e2cb71">CGAL::Polygon_mesh_processing::compute_face_normal()</a></code>. The triangulation is performed by constructing a <code><a class="elRef" href="../Triangulation_2/classCGAL_1_1Constrained__Delaunay__triangulation__2.html">CGAL::Constrained_Delaunay_triangulation_2</a></code> in this plane. This approach is chosen because the constrained Delaunay triangulation maximizes the minimum angle among all triangles, given the edges of the face.</p>
<p><b>Example: </b> <a class="el" href="PMP_Remeshing_2triangulate_faces_example_8cpp-example.html">PMP_Remeshing/triangulate_faces_example.cpp</a> <br>
</p><details>
<summary>
Show / Hide</summary>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/triangulate_faces.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/IO/polygon_mesh_io.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/helpers.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> <a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                                     Point;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point&gt;</a>                           Mesh;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>PMP = CGAL::Polygon_mesh_processing;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : <a class="code hl_functionRef" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/P.off"</span>);</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* outfilename = (argc &gt; 2) ? argv[2] : <span class="stringliteral">"P_tri.off"</span>;</div>
<div class="line"> </div>
<div class="line">  Mesh mesh;</div>
<div class="line">  <span class="keywordflow">if</span>(!PMP::IO::read_polygon_mesh(filename, mesh))</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: Invalid input."</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span>(<a class="code hl_functionRef" href="../BGL/group__PkgBGLHelperFct.html#gab6e6f18e6de73b9f85e38d0b56145172">is_empty</a>(mesh))</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Warning: empty file?"</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span>(!<a class="code hl_functionRef" href="../BGL/group__PkgBGLHelperFct.html#ga11883d231eec1b58f37efe4acedd9588">CGAL::is_triangle_mesh</a>(mesh))</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Input mesh is not triangulated."</span> &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Input mesh is triangulated."</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="group__PMP__combi__remeshing__grp.html#ga5e4f69483f6506429c4743de745e7b09">PMP::triangulate_faces</a>(mesh);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Confirm that all faces are triangles.</span></div>
<div class="line">  <span class="keywordflow">for</span>(boost::graph_traits&lt;Mesh&gt;::face_descriptor f : faces(mesh))</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span>(!<a class="code hl_functionRef" href="../BGL/group__PkgBGLHelperFct.html#gaa552f609541c09f6d38ce92c19cd60c8">CGAL::is_triangle</a>(halfedge(f, mesh), mesh))</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">"Error: non-triangular face left in mesh."</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_functionRef" href="../BGL/group__PkgBGLIOFct.html#gafa143949a33371dc6df8307be1ab8a66">CGAL::IO::write_polygon_mesh</a>(outfilename, mesh, CGAL::parameters::stream_precision(17));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="ttc" id="aclassCGAL_1_1Exact__predicates__inexact__constructions__kernel_html"><div class="ttname"><a href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a></div></div>
<div class="ttc" id="aclassCGAL_1_1Surface__mesh_html"><div class="ttname"><a href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh</a></div></div>
<div class="ttc" id="aclassKernel_1_1Point__3_html"><div class="ttname"><a href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a></div></div>
<div class="ttc" id="agroup__PMP__combi__remeshing__grp_html_ga5e4f69483f6506429c4743de745e7b09"><div class="ttname"><a href="group__PMP__combi__remeshing__grp.html#ga5e4f69483f6506429c4743de745e7b09">CGAL::Polygon_mesh_processing::triangulate_faces</a></div><div class="ttdeci">bool triangulate_faces(const FaceRange &amp;face_range, PolygonMesh &amp;pmesh, const NamedParameters &amp;np=parameters::default_values())</div><div class="ttdoc">triangulates given faces of a polygon mesh.</div><div class="ttdef"><b>Definition:</b> triangulate_faces.h:381</div></div>
<div class="ttc" id="agroup__PkgBGLHelperFct_html_ga11883d231eec1b58f37efe4acedd9588"><div class="ttname"><a href="../BGL/group__PkgBGLHelperFct.html#ga11883d231eec1b58f37efe4acedd9588">CGAL::is_triangle_mesh</a></div><div class="ttdeci">bool is_triangle_mesh(const FaceGraph &amp;g)</div></div>
<div class="ttc" id="agroup__PkgBGLHelperFct_html_gaa552f609541c09f6d38ce92c19cd60c8"><div class="ttname"><a href="../BGL/group__PkgBGLHelperFct.html#gaa552f609541c09f6d38ce92c19cd60c8">CGAL::is_triangle</a></div><div class="ttdeci">bool is_triangle(typename boost::graph_traits&lt; FaceGraph &gt;::halfedge_descriptor hd, const FaceGraph &amp;g)</div></div>
<div class="ttc" id="agroup__PkgBGLHelperFct_html_gab6e6f18e6de73b9f85e38d0b56145172"><div class="ttname"><a href="../BGL/group__PkgBGLHelperFct.html#gab6e6f18e6de73b9f85e38d0b56145172">CGAL::is_empty</a></div><div class="ttdeci">bool is_empty(const FaceGraph &amp;g)</div></div>
<div class="ttc" id="agroup__PkgBGLIOFct_html_gafa143949a33371dc6df8307be1ab8a66"><div class="ttname"><a href="../BGL/group__PkgBGLIOFct.html#gafa143949a33371dc6df8307be1ab8a66">CGAL::IO::write_polygon_mesh</a></div><div class="ttdeci">bool write_polygon_mesh(const std::string &amp;fname, Graph &amp;g, const NamedParameters &amp;np=parameters::default_values())</div></div>
<div class="ttc" id="anamespaceCGAL_html_acdae9a147ad2a3998cc21f88bc292dac"><div class="ttname"><a href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a></div><div class="ttdeci">std::string data_file_path(const std::string &amp;filename)</div></div>
<div class="ttc" id="anamespaceKernel_html"><div class="ttname"><a href="../Kernel_23/namespaceKernel.html">Kernel</a></div></div>
</div><!-- fragment --> </details>
<p>An optional parameter, <code>visitor</code>, enables tracking of how faces are subdivided during triangulation. The following example demonstrates its usage.</p>
<p><b>Example: </b> <a class="el" href="PMP_Remeshing_2triangulate_faces_split_visitor_example_8cpp-example.html">PMP_Remeshing/triangulate_faces_split_visitor_example.cpp</a> <br>
</p><details>
<summary>
Show / Hide</summary>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/triangulate_faces.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/copy_face_graph.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;unordered_map&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> <a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                                     Point;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point&gt;</a>                           Mesh;</div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::face_descriptor          face_descriptor;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Insert_iterator</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">typedef</span> std::unordered_map&lt;face_descriptor,face_descriptor&gt; <a class="code hl_classRef" href="../Manual/classContainer.html">Container</a>;</div>
<div class="line">  <a class="code hl_classRef" href="../Manual/classContainer.html">Container</a>&amp; container;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  Insert_iterator(<a class="code hl_classRef" href="../Manual/classContainer.html">Container</a> &amp;c)</div>
<div class="line">  : container(c) {}</div>
<div class="line"> </div>
<div class="line">  Insert_iterator&amp;</div>
<div class="line">  operator=(<span class="keyword">const</span> std::pair&lt;face_descriptor, face_descriptor&gt;&amp; p)</div>
<div class="line">  {</div>
<div class="line">    container[p.second] = p.first;</div>
<div class="line">    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_functionRef" href="../STL_Extension/classCGAL_1_1Insert__iterator.html#ae32b2940b590afe06fecd9ccb3473608">Insert_iterator</a>&amp;</div>
<div class="line">  <a class="code hl_functionRef" href="../Kernel_23/group__Kernel__operator__prod.html#ga8427cff04588dc338b8acf3e1b116dce">operator*</a>() { <span class="keywordflow">return</span> *<span class="keyword">this</span>; }</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_functionRef" href="../STL_Extension/classCGAL_1_1Insert__iterator.html#ae32b2940b590afe06fecd9ccb3473608">Insert_iterator</a></div>
<div class="line">  operator++(<span class="keywordtype">int</span>) { <span class="keywordflow">return</span> *<span class="keyword">this</span>; }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Visitor</div>
<div class="line">  : <span class="keyword">public</span> <a class="code hl_struct" href="structCGAL_1_1Polygon__mesh__processing_1_1Triangulate__faces_1_1Default__visitor.html">CGAL::Polygon_mesh_processing::Triangulate_faces::Default_visitor</a>&lt;Mesh&gt;</div>
<div class="line">{</div>
<div class="line">   <span class="keyword">typedef</span> std::unordered_map&lt;face_descriptor,face_descriptor&gt; <a class="code hl_classRef" href="../Manual/classContainer.html">Container</a>;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_classRef" href="../Manual/classContainer.html">Container</a>&amp; container;</div>
<div class="line">  face_descriptor qfd;</div>
<div class="line"> </div>
<div class="line">  Visitor(<a class="code hl_classRef" href="../Manual/classContainer.html">Container</a>&amp; container)</div>
<div class="line">    : container(container)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> before_subface_creations(face_descriptor fd)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">"split : "</span> &lt;&lt; fd &lt;&lt; <span class="stringliteral">" into:"</span> &lt;&lt; std::endl;</div>
<div class="line">    Container::iterator it = container.find(fd);</div>
<div class="line">    qfd = it-&gt;second;</div>
<div class="line">    container.erase(it);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> after_subface_created(face_descriptor fd)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">"  "</span> &lt;&lt; fd;</div>
<div class="line">    container[fd]=qfd;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> after_subface_creations()</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : <a class="code hl_functionRef" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/P.off"</span>);</div>
<div class="line">  std::ifstream input(filename);</div>
<div class="line"> </div>
<div class="line">  Mesh mesh;</div>
<div class="line">  <span class="keywordflow">if</span> (!input || !(input &gt;&gt; mesh) || mesh.is_empty())</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Not a valid off file."</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  std::unordered_map&lt;face_descriptor,face_descriptor&gt; t2q;</div>
<div class="line"> </div>
<div class="line">  Mesh copy;</div>
<div class="line">  <a class="code hl_functionRef" href="../BGL/group__PkgBGLHelperFct.html#ga2682fb7d5f4ff4eb65607ae4118e31bc">CGAL::copy_face_graph</a>(mesh, copy, CGAL::parameters::face_to_face_output_iterator(Insert_iterator(t2q)));</div>
<div class="line"> </div>
<div class="line">  Visitor v(t2q);</div>
<div class="line">  <a class="code hl_function" href="group__PMP__combi__remeshing__grp.html#ga5e4f69483f6506429c4743de745e7b09">CGAL::Polygon_mesh_processing::triangulate_faces</a>(copy, CGAL::parameters::visitor(v));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span>(std::unordered_map&lt;face_descriptor,face_descriptor&gt;::iterator it = t2q.begin(); it != t2q.end(); ++it){</div>
<div class="line">    std::cout &lt;&lt; it-&gt;first &lt;&lt; <span class="stringliteral">"  "</span>  &lt;&lt; it-&gt;second &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassCGAL_1_1Insert__iterator_html_ae32b2940b590afe06fecd9ccb3473608"><div class="ttname"><a href="../STL_Extension/classCGAL_1_1Insert__iterator.html#ae32b2940b590afe06fecd9ccb3473608">CGAL::Insert_iterator::Insert_iterator</a></div><div class="ttdeci">Insert_iterator(Container &amp;c)</div></div>
<div class="ttc" id="aclassContainer_html"><div class="ttname"><a href="../Manual/classContainer.html">Container</a></div></div>
<div class="ttc" id="agroup__Kernel__operator__prod_html_ga8427cff04588dc338b8acf3e1b116dce"><div class="ttname"><a href="../Kernel_23/group__Kernel__operator__prod.html#ga8427cff04588dc338b8acf3e1b116dce">operator*</a></div><div class="ttdeci">Vector_2&lt; Kernel &gt; operator*(const Vector_2&lt; Kernel &gt; &amp;v, const Kernel::RT &amp;s)</div></div>
<div class="ttc" id="agroup__PkgBGLHelperFct_html_ga2682fb7d5f4ff4eb65607ae4118e31bc"><div class="ttname"><a href="../BGL/group__PkgBGLHelperFct.html#ga2682fb7d5f4ff4eb65607ae4118e31bc">CGAL::copy_face_graph</a></div><div class="ttdeci">void copy_face_graph(const SourceMesh &amp;sm, TargetMesh &amp;tm, const NamedParameters1 &amp;np1=parameters::default_values(), const NamedParameters2 &amp;np2=parameters::default_values())</div></div>
<div class="ttc" id="astructCGAL_1_1Polygon__mesh__processing_1_1Triangulate__faces_1_1Default__visitor_html"><div class="ttname"><a href="structCGAL_1_1Polygon__mesh__processing_1_1Triangulate__faces_1_1Default__visitor.html">CGAL::Polygon_mesh_processing::Triangulate_faces::Default_visitor</a></div><div class="ttdoc">Default new face visitor model of PMPTriangulateFaceVisitor.</div><div class="ttdef"><b>Definition:</b> triangulate_faces.h:47</div></div>
</div><!-- fragment --> </details>
<h1><a class="anchor" id="PMPRemeshingLocal"></a>
Local Remeshing</h1>
<h2><a class="anchor" id="isorem"></a>
Isotropic Incremental Remeshing</h2>
<p>The incremental triangle-based isotropic remeshing algorithm introduced by Botsch et al <a class="el" href="citelist.html#CITEREF_botsch2004remeshing">[2]</a>, <a class="el" href="citelist.html#CITEREF_botsch2010PMP">[4]</a> is implemented in this package. This algorithm incrementally performs simple operations such as edge splits, edge collapses, edge flips, and Laplacian smoothing. All the vertices of the remeshed patch are reprojected to the original surface to maintain a good approximation of the input.</p>
<p>A triangulated region of a polygon mesh can be remeshed using the function <code><a class="el" href="group__PMP__local__remeshing__grp.html#ga412f696ec3009074bf957f1bba638248" title="remeshes a triangulated region of a polygon mesh.">CGAL::Polygon_mesh_processing::isotropic_remeshing()</a></code>, as illustrated by <a class="el" href="index.html#fig__iso_remeshing">Figure 77.2</a>. The algorithm has two parameters: the sizing field object for the remeshed surface patch, and the number of iterations of the abovementioned sequence of operations.</p>
<p>As the number of iterations increases, the mesh tends to be smoother and closer to the target edge length.</p>
<p><a class="anchor" id="fig__iso_remeshing"></a> </p><div class="image">
<img src="iso_remeshing.png" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__iso_remeshing">Figure 77.2</a> Isotropic remeshing. (a) Triangulated input surface mesh. (b) Surface uniformly and entirely remeshed. (c) Selection of a range of faces to be remeshed. (d) Surface mesh with the selection uniformly remeshed. </p> </div> <p> <br>
</p>
<p>The sizing field establishes the local target edge length for the remeshed surface. Two sizing fields are provided:</p><ul>
<li><code><a class="el" href="classCGAL_1_1Polygon__mesh__processing_1_1Uniform__sizing__field.html" title="A sizing field describing a uniform target edge length for CGAL::Polygon_mesh_processing::isotropic_r...">CGAL::Polygon_mesh_processing::Uniform_sizing_field</a></code>: all triangle edges are targeted to have equal lengths.</li>
<li><code><a class="el" href="classCGAL_1_1Polygon__mesh__processing_1_1Adaptive__sizing__field.html" title="A sizing field describing variable target mesh edge lengths for CGAL::Polygon_mesh_processing::isotro...">CGAL::Polygon_mesh_processing::Adaptive_sizing_field</a></code>: triangle edge lengths depend on the local curvature – shorter edges appear in regions with a higher curvature and vice versa. The outline of the adaptive sizing field algorithm is available in <a class="el" href="citelist.html#CITEREF_dunyach2013curvRemesh">[6]</a>.</li>
</ul>
<p>The distinction between uniform and adaptive sizing fields is illustrated in <a class="el" href="index.html#fig__uniform_and_adaptive">Figure 77.3</a>.</p>
<p><a class="anchor" id="fig__uniform_and_adaptive"></a> </p><div class="image">
<img src="uniform_and_adaptive.png" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__uniform_and_adaptive">Figure 77.3</a> Sizing fields in isotropic remeshing. (a) Uniform sizing field. (b) Curvature-based adaptive sizing field. </p> </div> <p> <br>
</p>
<p>An additional option allows for the protection (i.e., preservation) of specified polylines. In some cases, these polylines may be too long, making it impossible to achieve the desired target edge length while maintaining their integrity. This can lead to infinite loops of edge splits in incident faces. To avoid this, the function <code><a class="el" href="group__PMP__local__remeshing__grp.html#ga173007e56da9246f63f2730e30b87844" title="splits the edges listed in edges into sub-edges that are not longer than the given threshold max_leng...">CGAL::Polygon_mesh_processing::split_long_edges()</a></code> should be applied to the list of constrained edges prior to remeshing.</p>
<p>The following example demonstrates a complete usage of the isotropic remeshing function.</p>
<p><b>Example: </b> <a class="el" href="PMP_Remeshing_2isotropic_remeshing_example_8cpp-example.html">PMP_Remeshing/isotropic_remeshing_example.cpp</a> <br>
</p><details>
<summary>
Show / Hide</summary>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/border.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/remesh.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/IO/polygon_mesh_io.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;boost/iterator/function_output_iterator.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>   K;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;K::Point_3&gt;</a>                        Mesh;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::halfedge_descriptor        halfedge_descriptor;</div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::edge_descriptor            edge_descriptor;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>PMP = CGAL::Polygon_mesh_processing;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>halfedge2edge</div>
<div class="line">{</div>
<div class="line">  halfedge2edge(<span class="keyword">const</span> Mesh&amp; m, std::vector&lt;edge_descriptor&gt;&amp; edges)</div>
<div class="line">    : m_mesh(m), m_edges(edges)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> halfedge_descriptor&amp; h)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    m_edges.push_back(edge(h, m_mesh));</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> Mesh&amp; m_mesh;</div>
<div class="line">  std::vector&lt;edge_descriptor&gt;&amp; m_edges;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : <a class="code hl_functionRef" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/pig.off"</span>);</div>
<div class="line"> </div>
<div class="line">  Mesh mesh;</div>
<div class="line">  <span class="keywordflow">if</span>(!PMP::IO::read_polygon_mesh(filename, mesh) || !<a class="code hl_functionRef" href="../BGL/group__PkgBGLHelperFct.html#ga11883d231eec1b58f37efe4acedd9588">CGAL::is_triangle_mesh</a>(mesh))</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input."</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">double</span> target_edge_length = (argc &gt; 2) ? std::stod(std::string(argv[2])) : 0.04;</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nb_iter = (argc &gt; 3) ? std::stoi(std::string(argv[3])) : 10;</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Split border..."</span>;</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;edge_descriptor&gt; border;</div>
<div class="line">  <a class="code hl_functionRef" href="../BGL/group__PkgBGLHelperFct.html#gad9e4e6644bc6e2c79101b25e280ea633">CGAL::border_halfedges</a>(faces(mesh), mesh, boost::make_function_output_iterator(halfedge2edge(mesh, border)));</div>
<div class="line">  <a class="code hl_function" href="group__PMP__local__remeshing__grp.html#ga173007e56da9246f63f2730e30b87844">PMP::split_long_edges</a>(border, target_edge_length, mesh);</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"done."</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Start remeshing of "</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">" ("</span> &lt;&lt; num_faces(mesh) &lt;&lt; <span class="stringliteral">" faces)..."</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="group__PMP__local__remeshing__grp.html#ga412f696ec3009074bf957f1bba638248">PMP::isotropic_remeshing</a>(faces(mesh), target_edge_length, mesh,</div>
<div class="line">                           CGAL::parameters::number_of_iterations(nb_iter)</div>
<div class="line">                                            .protect_constraints(<span class="keyword">true</span>)); <span class="comment">//i.e. protect border, here</span></div>
<div class="line"> </div>
<div class="line">  <a class="code hl_functionRef" href="../BGL/group__PkgBGLIOFct.html#gafa143949a33371dc6df8307be1ab8a66">CGAL::IO::write_polygon_mesh</a>(<span class="stringliteral">"out.off"</span>, mesh, CGAL::parameters::stream_precision(17));</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Remeshing done."</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__PMP__local__remeshing__grp_html_ga173007e56da9246f63f2730e30b87844"><div class="ttname"><a href="group__PMP__local__remeshing__grp.html#ga173007e56da9246f63f2730e30b87844">CGAL::Polygon_mesh_processing::split_long_edges</a></div><div class="ttdeci">void split_long_edges(const EdgeRange &amp;edges, SizingFunction &amp;sizing, PolygonMesh &amp;pmesh, const NamedParameters &amp;np=parameters::default_values())</div><div class="ttdoc">splits the edges listed in edges into sub-edges that are not longer than the given threshold max_leng...</div><div class="ttdef"><b>Definition:</b> remesh.h:457</div></div>
<div class="ttc" id="agroup__PMP__local__remeshing__grp_html_ga412f696ec3009074bf957f1bba638248"><div class="ttname"><a href="group__PMP__local__remeshing__grp.html#ga412f696ec3009074bf957f1bba638248">CGAL::Polygon_mesh_processing::isotropic_remeshing</a></div><div class="ttdeci">void isotropic_remeshing(const FaceRange &amp;faces, SizingFunction &amp;sizing, PolygonMesh &amp;pmesh, const NamedParameters &amp;np=parameters::default_values())</div><div class="ttdoc">remeshes a triangulated region of a polygon mesh.</div><div class="ttdef"><b>Definition:</b> remesh.h:217</div></div>
<div class="ttc" id="agroup__PkgBGLHelperFct_html_gad9e4e6644bc6e2c79101b25e280ea633"><div class="ttname"><a href="../BGL/group__PkgBGLHelperFct.html#gad9e4e6644bc6e2c79101b25e280ea633">CGAL::border_halfedges</a></div><div class="ttdeci">HalfedgeOutputIterator border_halfedges(const FaceRange &amp;face_range, const Graph &amp;g, HalfedgeOutputIterator out, const NamedParameters &amp;np=parameters::default_values())</div></div>
</div><!-- fragment --> </details>
<h2><a class="anchor" id="acvdrem"></a>
Approximated Discrete Centroidal Voronoi Diagram (ACVD) Remeshing</h2>
<p>This remeshing algorithm employs clustering on polygonal meshes to approximate a Centroidal Voronoi Diagram construction. It is inspired by the method presented in <a class="el" href="citelist.html#CITEREF_cgal:vc-acvdupmc-04">[10]</a> and further developed in <a class="el" href="citelist.html#CITEREF_cgal:audette2011approach">[1]</a> and <a class="el" href="citelist.html#CITEREF_cgal:vcp-grtmmdvd-08">[11]</a>. The algorithm is analogous to Lloyd's algorithm (or k-means), where clusters are initialized from randomly selected input vertices and grown to minimize a specific energy function until convergence. Upon convergence, output vertices are computed from the vertices of each cluster.</p>
<p>The function <code><a class="el" href="group__PMP__local__remeshing__grp.html#gaed23e63b12c7fe8268927d17b4d379f1" title="performs Approximated Centroidal Voronoi Diagram (ACVD) remeshing on a triangle mesh.">CGAL::Polygon_mesh_processing::approximated_centroidal_Voronoi_diagram_remeshing()</a></code> accepts a triangle mesh and an expected number of output vertices, updating the mesh with the remeshed result. Note that the final vertex count may exceed the input parameter if the mesh is not closed or if the specified vertex budget is insufficient to produce a manifold mesh, which may affect the uniformity of output triangles. The output mesh is not guaranteed to preserve the input topology; for example, small handles contained within a cluster may be omitted.</p>
<p>For meshes with sharp features or corners, quadric error metrics can be used to either move output vertices (fast, but may produce poorly shaped triangles) or to incorporate quadric error metrics directly into the cluster energy formulation (slower, but yields higher quality triangles). Adaptive remeshing based on surface curvature is also supported.</p>
<p><a class="anchor" id="fig__acvd_remeshing"></a> </p><div class="image">
<img src="acvd_remeshing.png" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__acvd_remeshing">Figure 77.4</a> ACVD remeshing. From left to right: Input; with default parameters; using adaptive option; using QEM-based energy. </p> </div> <p> <br>
</p>
<h2><a class="anchor" id="PMPRemeshingRefineFair"></a>
Refine and Fair</h2>
<p>A surface patch can be refined by inserting new vertices and flipping edges to get a triangulation. Using a criterion presented in <a class="el" href="citelist.html#CITEREF_liepa2003filling">[8]</a>, the density of triangles near the boundary of the patch is approximated by the refinement function. The validity of the mesh is enforced by flipping edges. An edge is flipped only if the opposite edge does not exist in the original mesh and if no degenerate triangles are generated.</p>
<p>A region of the surface mesh (e.g., the refined region) can be faired to obtain a tangentially continuous and smooth surface patch. The region to be faired is defined as a set of vertices to be relocated. The fairing step minimizes a linear bi-Laplacian system with boundary constraints, as described in <a class="el" href="citelist.html#CITEREF_Botsch2008OnLinearVariational">[3]</a>. Visual results of these steps are shown in <a class="elRef" href="../PMP_Mesh_repair/index.html#fig__Mech_steps">Figure 78.1</a> (c and d).</p>
<p>Refinement and fairing functions can be applied to arbitrary regions on a triangle mesh using:</p><ul>
<li><code><a class="el" href="group__PMP__local__remeshing__grp.html#ga047c58233b234917fd310e190103e0cd" title="refines a region of a triangle mesh.">CGAL::Polygon_mesh_processing::refine()</a></code>: refines a specified set of facets on a mesh.</li>
<li><code><a class="el" href="group__PMP__local__remeshing__grp.html#ga9988e9a2eaf92740b3009d06c792f2cd" title="fairs a region on a triangle mesh.">CGAL::Polygon_mesh_processing::fair()</a></code>: fairs a specified set of vertices on a mesh.</li>
</ul>
<p>Fairing requires a sparse linear solver; we recommend using <a class="elRef" href="../Manual/thirdparty.html#thirdpartyEigen">Eigen</a> 3.2 or later. Note that fairing may fail if the set of fixed vertices used as boundary conditions is insufficient to solve the linear system.</p>
<p>The following example calls the functions <code><a class="el" href="group__PMP__local__remeshing__grp.html#ga047c58233b234917fd310e190103e0cd" title="refines a region of a triangle mesh.">CGAL::Polygon_mesh_processing::refine()</a></code> and <code><a class="el" href="group__PMP__local__remeshing__grp.html#ga9988e9a2eaf92740b3009d06c792f2cd" title="fairs a region on a triangle mesh.">CGAL::Polygon_mesh_processing::fair()</a></code> for some selected regions on the input triangle mesh.</p>
<p><b>Example: </b> <a class="el" href="PMP_Remeshing_2refine_fair_example_8cpp-example.html">PMP_Remeshing/refine_fair_example.cpp</a> <br>
</p><details>
<summary>
Show / Hide</summary>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/refine.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/fair.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/IO/polygon_mesh_io.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iterator&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> <a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;Kernel&gt;</a>                          Mesh;</div>
<div class="line"><span class="keyword">typedef</span> Mesh::Vertex_handle                                 Vertex_handle;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>PMP = CGAL::Polygon_mesh_processing;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// extract vertices which are at most k (inclusive)</span></div>
<div class="line"><span class="comment">// far from vertex v in the graph of edges</span></div>
<div class="line"><span class="keywordtype">void</span> extract_k_ring(Vertex_handle v,</div>
<div class="line">                    <span class="keywordtype">int</span> k,</div>
<div class="line">                    std::vector&lt;Vertex_handle&gt;&amp; qv)</div>
<div class="line">{</div>
<div class="line">  std::map&lt;Vertex_handle, int&gt;  D;</div>
<div class="line">  qv.push_back(v);</div>
<div class="line">  D[v] = 0;</div>
<div class="line">  std::size_t current_index = 0;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> dist_v;</div>
<div class="line">  <span class="keywordflow">while</span> (current_index &lt; qv.size() &amp;&amp; (dist_v = D[qv[current_index]]) &lt; k)</div>
<div class="line">  {</div>
<div class="line">    v = qv[current_index++];</div>
<div class="line"> </div>
<div class="line">    Mesh::Halfedge_around_vertex_circulator e(v-&gt;vertex_begin()), e_end(e);</div>
<div class="line">    <span class="keywordflow">do</span> {</div>
<div class="line">      Vertex_handle new_v = e-&gt;opposite()-&gt;vertex();</div>
<div class="line">      <span class="keywordflow">if</span> (D.insert(std::make_pair(new_v, dist_v + 1)).second)</div>
<div class="line">        qv.push_back(new_v);</div>
<div class="line">    } <span class="keywordflow">while</span> (++e != e_end);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : <a class="code hl_functionRef" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/blobby.off"</span>);</div>
<div class="line"> </div>
<div class="line">  Mesh poly;</div>
<div class="line">  <span class="keywordflow">if</span>(!PMP::IO::read_polygon_mesh(filename, poly) || !<a class="code hl_functionRef" href="../BGL/group__PkgBGLHelperFct.html#ga11883d231eec1b58f37efe4acedd9588">CGAL::is_triangle_mesh</a>(poly))</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input."</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;Mesh::Facet_handle&gt;  new_facets;</div>
<div class="line">  std::vector&lt;Vertex_handle&gt; new_vertices;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="group__PMP__local__remeshing__grp.html#ga047c58233b234917fd310e190103e0cd">PMP::refine</a>(poly, faces(poly),</div>
<div class="line">              std::back_inserter(new_facets),</div>
<div class="line">              std::back_inserter(new_vertices),</div>
<div class="line">              CGAL::parameters::density_control_factor(2.));</div>
<div class="line"> </div>
<div class="line">  std::ofstream refined_off(<span class="stringliteral">"refined.off"</span>);</div>
<div class="line">  refined_off.precision(17);</div>
<div class="line">  refined_off &lt;&lt; poly;</div>
<div class="line">  refined_off.close();</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Refinement added "</span> &lt;&lt; new_vertices.size() &lt;&lt; <span class="stringliteral">" vertices."</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  Mesh::Vertex_iterator v = poly.vertices_begin();</div>
<div class="line">  std::advance(v, 82<span class="comment">/*e.g.*/</span>);</div>
<div class="line">  std::vector&lt;Vertex_handle&gt; region;</div>
<div class="line">  extract_k_ring(v, 12<span class="comment">/*e.g.*/</span>, region);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">bool</span> success = <a class="code hl_function" href="group__PMP__local__remeshing__grp.html#ga9988e9a2eaf92740b3009d06c792f2cd">PMP::fair</a>(poly, region);</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Fairing : "</span> &lt;&lt; (success ? <span class="stringliteral">"succeeded"</span> : <span class="stringliteral">"failed"</span>) &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  std::ofstream faired_off(<span class="stringliteral">"faired.off"</span>);</div>
<div class="line">  faired_off.precision(17);</div>
<div class="line">  faired_off &lt;&lt; poly;</div>
<div class="line">  faired_off.close();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassCGAL_1_1Polyhedron__3_html"><div class="ttname"><a href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3</a></div></div>
<div class="ttc" id="agroup__PMP__local__remeshing__grp_html_ga047c58233b234917fd310e190103e0cd"><div class="ttname"><a href="group__PMP__local__remeshing__grp.html#ga047c58233b234917fd310e190103e0cd">CGAL::Polygon_mesh_processing::refine</a></div><div class="ttdeci">std::pair&lt; FaceOutputIterator, VertexOutputIterator &gt; refine(TriangleMesh &amp;tmesh, const FaceRange &amp;faces, FaceOutputIterator faces_out, VertexOutputIterator vertices_out, const NamedParameters &amp;np=parameters::default_values())</div><div class="ttdoc">refines a region of a triangle mesh.</div><div class="ttdef"><b>Definition:</b> refine.h:78</div></div>
<div class="ttc" id="agroup__PMP__local__remeshing__grp_html_ga9988e9a2eaf92740b3009d06c792f2cd"><div class="ttname"><a href="group__PMP__local__remeshing__grp.html#ga9988e9a2eaf92740b3009d06c792f2cd">CGAL::Polygon_mesh_processing::fair</a></div><div class="ttdeci">bool fair(TriangleMesh &amp;tmesh, const VertexRange &amp;vertices, const NamedParameters &amp;np=parameters::default_values())</div><div class="ttdoc">fairs a region on a triangle mesh.</div><div class="ttdef"><b>Definition:</b> fair.h:130</div></div>
</div><!-- fragment --> </details>
<h2><a class="anchor" id="PMPRemeshingSmoothing"></a>
Smoothing</h2>
<p>Smoothing of a triangulated mesh region can be performed using algorithms that target either mesh smoothing or shape smoothing. Mesh smoothing improves triangle quality based on criteria such as angle and area, while shape smoothing is designed to be intrinsic, minimizing dependence on discretization and focusing on smoothing the underlying shape.</p>
<ul>
<li>Mesh smoothing by angle and area optimization: <code><a class="el" href="group__PMP__local__remeshing__grp.html#gad5a9a90355bab0613d94a6b9d73d54ed" title="smooths a region of a triangle mesh.">CGAL::Polygon_mesh_processing::angle_and_area_smoothing()</a></code> moves vertices to optimize the geometry around each vertex, aiming to equalize angles between incident edges and/or equalize areas of adjacent triangles. Border vertices are treated as constrained and remain fixed throughout the procedure. No new vertices are inserted. The algorithms are based on Surazhsky and Gotsman <a class="el" href="citelist.html#CITEREF_cgal:sg-hqct-04">[9]</a>. Area smoothing alone may produce long and skinny triangles; to mitigate this, an optional step of Delaunay-based edge flips can be applied. Area smoothing improves the spatial distribution of vertices over the smoothed region.</li>
</ul>
<p>A simple example is provided below.</p>
<p><b>Example: </b> <a class="el" href="PMP_Remeshing_2mesh_smoothing_example_8cpp-example.html">PMP_Remeshing/mesh_smoothing_example.cpp</a> <br>
</p><details>
<summary>
Show / Hide</summary>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/angle_and_area_smoothing.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/detect_features.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/IO/polygon_mesh_io.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>     K;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;K::Point_3&gt;</a>                          Mesh;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::edge_descriptor              edge_descriptor;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>PMP = CGAL::Polygon_mesh_processing;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> std::string filename = argc &gt; 1 ? argv[1] : <a class="code hl_functionRef" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/anchor_dense.off"</span>);</div>
<div class="line"> </div>
<div class="line">  Mesh mesh;</div>
<div class="line">  <span class="keywordflow">if</span>(!PMP::IO::read_polygon_mesh(filename, mesh))</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input."</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Constrain edges with a dihedral angle over 60°</span></div>
<div class="line">  <span class="keyword">typedef</span> boost::property_map&lt;Mesh, CGAL::edge_is_feature_t&gt;::type EIFMap;</div>
<div class="line">  EIFMap eif = get(CGAL::edge_is_feature, mesh);</div>
<div class="line">  <a class="code hl_functionRef" href="../Polygon_mesh_processing/group__PMP__detect__features__grp.html#gadd3d18c0a9773463cd57902f85d0b23d">PMP::detect_sharp_edges</a>(mesh, 60, eif);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> sharp_counter = 0;</div>
<div class="line">  <span class="keywordflow">for</span>(edge_descriptor e : edges(mesh))</div>
<div class="line">    <span class="keywordflow">if</span>(get(eif, e))</div>
<div class="line">      ++sharp_counter;</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; sharp_counter &lt;&lt; <span class="stringliteral">" sharp edges"</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nb_iterations = (argc &gt; 2) ? std::atoi(argv[2]) : 10;</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Smoothing mesh... ("</span> &lt;&lt; nb_iterations &lt;&lt; <span class="stringliteral">" iterations)"</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Smooth with both angle and area criteria + Delaunay flips</span></div>
<div class="line">  <a class="code hl_function" href="group__PMP__local__remeshing__grp.html#gad5a9a90355bab0613d94a6b9d73d54ed">PMP::angle_and_area_smoothing</a>(mesh, CGAL::parameters::number_of_iterations(nb_iterations)</div>
<div class="line">                                                       .use_safety_constraints(<span class="keyword">false</span>) <span class="comment">// authorize all moves</span></div>
<div class="line">                                                       .edge_is_constrained_map(eif));</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_functionRef" href="../BGL/group__PkgBGLIOFct.html#gafa143949a33371dc6df8307be1ab8a66">CGAL::IO::write_polygon_mesh</a>(<span class="stringliteral">"mesh_smoothed.off"</span>, mesh, CGAL::parameters::stream_precision(17));</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Done!"</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__PMP__detect__features__grp_html_gadd3d18c0a9773463cd57902f85d0b23d"><div class="ttname"><a href="../Polygon_mesh_processing/group__PMP__detect__features__grp.html#gadd3d18c0a9773463cd57902f85d0b23d">CGAL::Polygon_mesh_processing::detect_sharp_edges</a></div><div class="ttdeci">void detect_sharp_edges(const PolygonMesh &amp;pmesh, FT angle_in_deg, EdgeIsFeatureMap edge_is_feature_map, const NamedParameters &amp;np=parameters::default_values())</div></div>
<div class="ttc" id="agroup__PMP__local__remeshing__grp_html_gad5a9a90355bab0613d94a6b9d73d54ed"><div class="ttname"><a href="group__PMP__local__remeshing__grp.html#gad5a9a90355bab0613d94a6b9d73d54ed">CGAL::Polygon_mesh_processing::angle_and_area_smoothing</a></div><div class="ttdeci">void angle_and_area_smoothing(const FaceRange &amp;faces, TriangleMesh &amp;tmesh, const NamedParameters &amp;np=parameters::default_values())</div><div class="ttdoc">smooths a region of a triangle mesh.</div><div class="ttdef"><b>Definition:</b> angle_and_area_smoothing.h:137</div></div>
</div><!-- fragment --> </details>
<p><a class="anchor" id="fig__PMPFigMeshSmoothing"></a></p><center> <img src="mesh_smoothing.png" alt="" style="max-width:70%;" class="inline"> </center>  <div class="cgal_figure_caption"> <p> <a class="el" href="index.html#fig__PMPFigMeshSmoothing">Figure 77.5</a> Mesh smoothing of the closed surface <em>blobby</em>, containing self-intersections (circled in red). For each smoothing combination, 10 iterations were applied. From left to right: (a) Input mesh; (b) Smoothing based on areas without Delaunay flips; (c) Smoothing based on areas with Delaunay flips; (d) Smoothing based on angles; (e) Smoothing based on angles and areas, with Delaunay flips. </p> </div> <p> <br>
</p>
<p><a class="anchor" id="fig__Fig_smooth_stats"></a> </p><div class="image">
<img src="smooth_statistics.png" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__Fig_smooth_stats">Figure 77.6</a> Statistics for the various combinations of mesh smoothing. </p> </div> <p> <br>
</p>
<ul>
<li>Mesh smoothing by tangential relaxation: <code><a class="el" href="group__PMP__local__remeshing__grp.html#ga136c659162e5360354db5879db7431b4" title="applies an iterative area-based tangential smoothing to the given range of vertices.">CGAL::Polygon_mesh_processing::tangential_relaxation()</a></code> moves vertices following an area-based Laplacian smoothing scheme, performed at each vertex in an estimated tangent plane to the surface. The full algorithm is described in <a class="el" href="citelist.html#CITEREF_botsch2010PMP">[4]</a>. The example <a class="el" href="PMP_Remeshing_2tangential_relaxation_example_8cpp-example.html">PMP_Remeshing/tangential_relaxation_example.cpp</a> shows how this mesh relaxation function can be used.</li>
</ul>
<p><b>Example: </b> <a class="el" href="PMP_Remeshing_2tangential_relaxation_example_8cpp-example.html">PMP_Remeshing/tangential_relaxation_example.cpp</a> <br>
</p><details>
<summary>
Show / Hide</summary>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/tangential_relaxation.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/IO/polygon_mesh_io.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>   K;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;K::Point_3&gt;</a>                        Mesh;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>PMP = CGAL::Polygon_mesh_processing;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : <a class="code hl_functionRef" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/pig.off"</span>);</div>
<div class="line"> </div>
<div class="line">  Mesh mesh;</div>
<div class="line">  <span class="keywordflow">if</span>(!PMP::IO::read_polygon_mesh(filename, mesh) || !<a class="code hl_functionRef" href="../BGL/group__PkgBGLHelperFct.html#ga11883d231eec1b58f37efe4acedd9588">CGAL::is_triangle_mesh</a>(mesh))</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input."</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nb_iter = (argc &gt; 2) ? std::stoi(std::string(argv[2])) : 10;</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Relax..."</span>;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="group__PMP__local__remeshing__grp.html#ga136c659162e5360354db5879db7431b4">PMP::tangential_relaxation</a>(mesh, CGAL::parameters::number_of_iterations(nb_iter));</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"done."</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__PMP__local__remeshing__grp_html_ga136c659162e5360354db5879db7431b4"><div class="ttname"><a href="group__PMP__local__remeshing__grp.html#ga136c659162e5360354db5879db7431b4">CGAL::Polygon_mesh_processing::tangential_relaxation</a></div><div class="ttdeci">void tangential_relaxation(const VertexRange &amp;vertices, TriangleMesh &amp;tm, const NamedParameters &amp;np=parameters::default_values())</div><div class="ttdoc">applies an iterative area-based tangential smoothing to the given range of vertices.</div><div class="ttdef"><b>Definition:</b> tangential_relaxation.h:134</div></div>
</div><!-- fragment --> </details>
<ul>
<li>Shape smoothing: <code><a class="el" href="group__PMP__local__remeshing__grp.html#ga57fa999abe8dc557003482444df2a189" title="smooths the overall shape of the mesh by using the mean curvature flow.">CGAL::Polygon_mesh_processing::smooth_shape()</a></code> moves vertices towards a weighted barycenter of their neighbors along the mean curvature flow. The curvature flow algorithm for shape smoothing is based on Desbrun et al. <a class="el" href="citelist.html#CITEREF_cgal:dmsb-ifamdcf-99">[5]</a> and Kazhdan et al. <a class="el" href="citelist.html#CITEREF_kazhdan2012can">[7]</a>. Vertices are translated along the surface normal at a speed proportional to the mean curvature of the region being smoothed. Vertices on sharp corners move faster, while those in flat regions remain stationary (zero curvature). To prevent undesirable neck pinches (singularities in cylindrical regions), the algorithm slows evolution in such areas. The smoothed shape converges toward a sphere while remaining conformally equivalent to its original form.</li>
</ul>
<p>A simple example is provided below.</p>
<p><b>Example: </b> <a class="el" href="PMP_Remeshing_2shape_smoothing_example_8cpp-example.html">PMP_Remeshing/shape_smoothing_example.cpp</a> <br>
</p><details>
<summary>
Show / Hide</summary>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/smooth_shape.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/IO/polygon_mesh_io.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;set&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>   K;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;K::Point_3&gt;</a>                        Mesh;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>PMP = CGAL::Polygon_mesh_processing;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : <a class="code hl_functionRef" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/pig.off"</span>);</div>
<div class="line"> </div>
<div class="line">  Mesh mesh;</div>
<div class="line">  <span class="keywordflow">if</span>(!PMP::IO::read_polygon_mesh(filename, mesh))</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input."</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nb_iterations = (argc &gt; 2) ? std::atoi(argv[2]) : 10;</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> time = (argc &gt; 3) ? std::atof(argv[3]) : 0.0001;</div>
<div class="line"> </div>
<div class="line">  std::set&lt;Mesh::Vertex_index&gt; constrained_vertices;</div>
<div class="line">  <span class="keywordflow">for</span>(Mesh::Vertex_index v : vertices(mesh))</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span>(<a class="code hl_functionRef" href="../BGL/group__PkgBGLHelperFct.html#gad93e429ad24efeaddeb836c437e719ab">is_border</a>(v, mesh))</div>
<div class="line">      constrained_vertices.insert(v);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Constraining: "</span> &lt;&lt; constrained_vertices.size() &lt;&lt; <span class="stringliteral">" border vertices"</span> &lt;&lt; std::endl;</div>
<div class="line">  <a class="code hl_structRef" href="../Property_map/structCGAL_1_1Boolean__property__map.html">CGAL::Boolean_property_map&lt;std::set&lt;Mesh::Vertex_index&gt;</a> &gt; vcmap(constrained_vertices);</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Smoothing shape... ("</span> &lt;&lt; nb_iterations &lt;&lt; <span class="stringliteral">" iterations)"</span> &lt;&lt; std::endl;</div>
<div class="line">  <a class="code hl_function" href="group__PMP__local__remeshing__grp.html#ga57fa999abe8dc557003482444df2a189">PMP::smooth_shape</a>(mesh, time, CGAL::parameters::number_of_iterations(nb_iterations)</div>
<div class="line">                                                 .vertex_is_constrained_map(vcmap));</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_functionRef" href="../BGL/group__PkgBGLIOFct.html#gafa143949a33371dc6df8307be1ab8a66">CGAL::IO::write_polygon_mesh</a>(<span class="stringliteral">"mesh_shape_smoothed.off"</span>, mesh, CGAL::parameters::stream_precision(17));</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Done!"</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__PMP__local__remeshing__grp_html_ga57fa999abe8dc557003482444df2a189"><div class="ttname"><a href="group__PMP__local__remeshing__grp.html#ga57fa999abe8dc557003482444df2a189">CGAL::Polygon_mesh_processing::smooth_shape</a></div><div class="ttdeci">void smooth_shape(const FaceRange &amp;faces, TriangleMesh &amp;tmesh, const double time, const NamedParameters &amp;np=parameters::default_values())</div><div class="ttdoc">smooths the overall shape of the mesh by using the mean curvature flow.</div><div class="ttdef"><b>Definition:</b> smooth_shape.h:115</div></div>
<div class="ttc" id="agroup__PkgBGLHelperFct_html_gad93e429ad24efeaddeb836c437e719ab"><div class="ttname"><a href="../BGL/group__PkgBGLHelperFct.html#gad93e429ad24efeaddeb836c437e719ab">CGAL::is_border</a></div><div class="ttdeci">bool is_border(typename boost::graph_traits&lt; FaceGraph &gt;::halfedge_descriptor hd, const FaceGraph &amp;g)</div></div>
<div class="ttc" id="astructCGAL_1_1Boolean__property__map_html"><div class="ttname"><a href="../Property_map/structCGAL_1_1Boolean__property__map.html">CGAL::Boolean_property_map</a></div></div>
</div><!-- fragment --> </details>
<p><a class="anchor" id="fig__PMPFigShapeSmoothing"></a></p><center> <img src="shape_smoothing.png" alt="" style="max-width:70%;" class="inline"> </center>  <div class="cgal_figure_caption"> <p> <a class="el" href="index.html#fig__PMPFigShapeSmoothing">Figure 77.7</a> Shape smoothing of the devil model, using mean curvature flow with a time step of <code>0.05</code> and constraining border vertices (located at the neck, where the mesh is open). </p> </div> <p> <br>
</p>
<h1><a class="anchor" id="PMPmesh3rem"></a>
Delaunay-Based Surface Remeshing</h1>
<p>The mesh generation algorithm implemented in the <a class="elRef" href="../Manual/packages.html#PkgMesh3">3D Mesh Generation</a> package can be used to remesh a given triangulated surface mesh. This algorithm, based on Delaunay refinement of a restricted Delaunay triangulation, produces a triangle surface mesh with guaranteed properties regarding simplex size, surface approximation, facet shape, and surface topology. A set of edges from the input mesh can be specified as constraints to build and protect polylines features, which are resampled while preserving the topology of the input feature graph.</p>
<p>This triangle surface remeshing solution is available in this package via the function <code><a class="el" href="group__PMP__global__remeshing__grp.html#gaff62f9415d2fe96d1d3095351f156ced" title="remeshes a surface triangle mesh following the Delaunay refinement algorithm described in the 3D Mesh...">CGAL::Polygon_mesh_processing::surface_Delaunay_remeshing()</a></code>. All meshing criteria defined for <code><a class="elRef" href="../Mesh_3/group__PkgMesh3Functions.html#gac8599a0c967075f740bf8e2e92c4770e">CGAL::make_mesh_3()</a></code> can be used directly, including those for simplex size, facet shape, surface approximation, topology, and one-dimensional feature sampling.</p>
<p>An example demonstrating remeshing of a triangulated surface mesh with the Delaunay refinement algorithm, while preserving detected sharp edges, is provided below.</p>
<p><b>Example: </b> <a class="el" href="PMP_Remeshing_2delaunay_remeshing_example_8cpp-example.html">PMP_Remeshing/delaunay_remeshing_example.cpp</a> <br>
</p><details>
<summary>
Show / Hide</summary>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/detect_features.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/surface_Delaunay_remeshing.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/IO/polygon_mesh_io.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Mesh_constant_domain_field_3.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>   K;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;K::Point_3&gt;</a>                        Mesh;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Mesh_3/classCGAL_1_1Mesh__constant__domain__field__3.html">CGAL::Mesh_constant_domain_field_3&lt;K, int&gt;</a>            Sizing_field;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>PMP = CGAL::Polygon_mesh_processing;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  std::string filename = (argc &gt; 1) ? std::string(argv[1]) : <a class="code hl_functionRef" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/anchor_dense.off"</span>);</div>
<div class="line"> </div>
<div class="line">  Mesh mesh;</div>
<div class="line">  <span class="keywordflow">if</span> (!PMP::IO::read_polygon_mesh(filename, mesh) || !<a class="code hl_functionRef" href="../BGL/group__PkgBGLHelperFct.html#ga11883d231eec1b58f37efe4acedd9588">CGAL::is_triangle_mesh</a>(mesh))</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input."</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">double</span> target_edge_length = (argc &gt; 2) ? std::stod(std::string(argv[2])) : 0.02;</div>
<div class="line">  Sizing_field size(target_edge_length);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">double</span> fdist = (argc &gt; 3) ? std::stod(std::string(argv[3])) : 0.01;</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Detect features..."</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">using </span>EIFMap = boost::property_map&lt;Mesh, CGAL::edge_is_feature_t&gt;::type;</div>
<div class="line">  EIFMap eif = get(CGAL::edge_is_feature, mesh);</div>
<div class="line">  <a class="code hl_functionRef" href="../Polygon_mesh_processing/group__PMP__detect__features__grp.html#gadd3d18c0a9773463cd57902f85d0b23d">PMP::detect_sharp_edges</a>(mesh, 45, eif);</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Start remeshing of "</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">" ("</span> &lt;&lt; num_faces(mesh) &lt;&lt; <span class="stringliteral">" faces)..."</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  Mesh outmesh = <a class="code hl_function" href="group__PMP__global__remeshing__grp.html#gaff62f9415d2fe96d1d3095351f156ced">PMP::surface_Delaunay_remeshing</a>(mesh, CGAL::parameters::protect_constraints(<span class="keyword">true</span>)</div>
<div class="line">                                                                        .mesh_edge_size(size)</div>
<div class="line">                                                                        .mesh_facet_distance(fdist)</div>
<div class="line">                                                                        .edge_is_constrained_map(eif));</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Remeshing done."</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_functionRef" href="../BGL/group__PkgBGLIOFct.html#gafa143949a33371dc6df8307be1ab8a66">CGAL::IO::write_polygon_mesh</a>(<span class="stringliteral">"anchor_remeshed.off"</span>, outmesh, CGAL::parameters::stream_precision(17));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassCGAL_1_1Mesh__constant__domain__field__3_html"><div class="ttname"><a href="../Mesh_3/classCGAL_1_1Mesh__constant__domain__field__3.html">CGAL::Mesh_constant_domain_field_3</a></div></div>
<div class="ttc" id="agroup__PMP__global__remeshing__grp_html_gaff62f9415d2fe96d1d3095351f156ced"><div class="ttname"><a href="group__PMP__global__remeshing__grp.html#gaff62f9415d2fe96d1d3095351f156ced">CGAL::Polygon_mesh_processing::surface_Delaunay_remeshing</a></div><div class="ttdeci">TriangleMeshOut surface_Delaunay_remeshing(const TriangleMesh &amp;tmesh, const NamedParameters &amp;np=parameters::default_values())</div><div class="ttdoc">remeshes a surface triangle mesh following the Delaunay refinement algorithm described in the 3D Mesh...</div><div class="ttdef"><b>Definition:</b> surface_Delaunay_remeshing.h:181</div></div>
</div><!-- fragment --> </details>
<h1><a class="anchor" id="PMPdecimate"></a>
Remeshing of (Almost) Planar Patches</h1>
<p>When a planar region of a model is described by many triangles, it may be desirable to simplify the mesh in this region, reducing the number of elements or even representing the region as a single large polygonal face if it forms a simply connected patch.</p>
<p>This can be accomplished using the function <code><a class="el" href="group__PMP__planar__remeshing__grp.html#ga7fca6fa2db94560ab6d32e6a77fc35b6" title="generates a new triangle mesh pm_out with the minimal number of triangles while preserving the shape ...">CGAL::Polygon_mesh_processing::remesh_planar_patches()</a></code>, which detects planar regions using geometric predicates for coplanarity and collinearity.</p>
<p><b>Example: </b> <a class="el" href="PMP_Remeshing_2remesh_planar_patches_8cpp-example.html">PMP_Remeshing/remesh_planar_patches.cpp</a> <br>
</p><details>
<summary>
Show / Hide</summary>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/remesh_planar_patches.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/remesh.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/detect_features.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/triangulate_faces.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/IO/polygon_mesh_io.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> <a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point_3;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Kernel::Point_3&gt;</a> Mesh;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>PMP = CGAL::Polygon_mesh_processing;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  Mesh sm;</div>
<div class="line">  <a class="code hl_functionRef" href="../BGL/group__PkgBGLIOFct.html#ga49f5b5e6fbfcbfaaac7604c88e10915c">CGAL::IO::read_polygon_mesh</a>(<a class="code hl_functionRef" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/cube_quad.off"</span>), sm);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// triangulate faces;</span></div>
<div class="line">  <a class="code hl_function" href="group__PMP__combi__remeshing__grp.html#ga5e4f69483f6506429c4743de745e7b09">PMP::triangulate_faces</a>(sm);</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Input mesh has "</span> &lt;&lt; faces(sm).size() &lt;&lt; <span class="stringliteral">" faces"</span> &lt;&lt; std::endl;</div>
<div class="line">  assert(faces(sm).size() == 12);</div>
<div class="line"> </div>
<div class="line">  Mesh::Property_map&lt;Mesh::Edge_index, bool&gt; ecm =</div>
<div class="line">    sm.add_property_map&lt;Mesh::Edge_index, <span class="keywordtype">bool</span>&gt;(<span class="stringliteral">"ecm"</span>, <span class="keyword">false</span>).first;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// detect sharp edges of the cube</span></div>
<div class="line">  <a class="code hl_functionRef" href="../Polygon_mesh_processing/group__PMP__detect__features__grp.html#gadd3d18c0a9773463cd57902f85d0b23d">PMP::detect_sharp_edges</a>(sm, 60, ecm);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// create a remeshed version of the cube with many elements</span></div>
<div class="line">  <a class="code hl_function" href="group__PMP__local__remeshing__grp.html#ga412f696ec3009074bf957f1bba638248">PMP::isotropic_remeshing</a>(faces(sm), 0.1, sm, CGAL::parameters::edge_is_constrained_map(ecm));</div>
<div class="line">  <a class="code hl_functionRef" href="../BGL/group__PkgBGLIOFct.html#gafa143949a33371dc6df8307be1ab8a66">CGAL::IO::write_polygon_mesh</a>(<span class="stringliteral">"cube_remeshed.off"</span>, sm, CGAL::parameters::stream_precision(17));</div>
<div class="line">  assert(faces(sm).size() &gt; 100);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// decimate the mesh</span></div>
<div class="line">  Mesh out;</div>
<div class="line">  <a class="code hl_function" href="group__PMP__planar__remeshing__grp.html#ga7fca6fa2db94560ab6d32e6a77fc35b6">PMP::remesh_planar_patches</a>(sm, out);</div>
<div class="line">  <a class="code hl_functionRef" href="../BGL/group__PkgBGLIOFct.html#gafa143949a33371dc6df8307be1ab8a66">CGAL::IO::write_polygon_mesh</a>(<span class="stringliteral">"cube_decimated.off"</span>, out, CGAL::parameters::stream_precision(17));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// we should be back to 12 faces</span></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Output mesh has "</span> &lt;&lt; faces(out).size() &lt;&lt; <span class="stringliteral">" faces"</span> &lt;&lt; std::endl;</div>
<div class="line">  assert(faces(out).size() == 12);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__PMP__planar__remeshing__grp_html_ga7fca6fa2db94560ab6d32e6a77fc35b6"><div class="ttname"><a href="group__PMP__planar__remeshing__grp.html#ga7fca6fa2db94560ab6d32e6a77fc35b6">CGAL::Polygon_mesh_processing::remesh_planar_patches</a></div><div class="ttdeci">void remesh_planar_patches(const TriangleMeshIn &amp;tm_in, PolygonMeshOut &amp;pm_out, const NamedParametersIn &amp;np_in=parameters::default_values(), const NamedParametersOut &amp;np_out=parameters::default_values())</div><div class="ttdoc">generates a new triangle mesh pm_out with the minimal number of triangles while preserving the shape ...</div><div class="ttdef"><b>Definition:</b> remesh_planar_patches.h:1436</div></div>
<div class="ttc" id="agroup__PkgBGLIOFct_html_ga49f5b5e6fbfcbfaaac7604c88e10915c"><div class="ttname"><a href="../BGL/group__PkgBGLIOFct.html#ga49f5b5e6fbfcbfaaac7604c88e10915c">CGAL::IO::read_polygon_mesh</a></div><div class="ttdeci">bool read_polygon_mesh(const std::string &amp;fname, Graph &amp;g, const NamedParameters &amp;np=parameters::default_values())</div></div>
</div><!-- fragment --> </details>
<p>Exact coplanarity and collinearity tests may result in unexpectedly small planar regions due to imperfections in the input geometry. To address this, a threshold on the angle between adjacent faces (or segments) can be specified, allowing faces to be considered coplanar (or segments collinear) within a local tolerance. However, this threshold is only local and does not provide global control, which may lead to undesired effects, such as in the case of a densely sampled circular arc where all points are eventually found to be nearly collinear.</p>
<p>To overcome this limitation, the function <code><a class="el" href="group__PMP__planar__remeshing__grp.html#ga0e6da479548199a5d82c3cf0ed36e8a0" title="generates a new triangle mesh pm_out with the minimal number of triangles from a partition of tm_in.">CGAL::Polygon_mesh_processing::remesh_almost_planar_patches()</a></code> is provided. It expects the segmentation into planar patches and corners to be supplied by the user. Such segmentation can be obtained using <code><a class="elRef" href="../Polygon_mesh_processing/group__PMP__detect__features__grp.html#ga50dcd2f6295f584d2e378b57290ae2af">CGAL::Polygon_mesh_processing::region_growing_of_planes_on_faces()</a></code>, which applies a region growing algorithm to detect planar regions in a mesh using both global and local criteria.</p>
<p>Similarly, the function <code><a class="elRef" href="../Polygon_mesh_processing/group__PMP__detect__features__grp.html#gac8e445730d718a2fc49604e865017d2e">CGAL::Polygon_mesh_processing::detect_corners_of_regions()</a></code> can be used to detect corner vertices on the border of the planar regions detected by running the region growing algorithm on border segments of the patch.</p>
<p><b>Example: </b> <a class="el" href="PMP_Remeshing_2remesh_almost_planar_patches_8cpp-example.html">PMP_Remeshing/remesh_almost_planar_patches.cpp</a> <br>
</p><details>
<summary>
Show / Hide</summary>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/remesh_planar_patches.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/region_growing.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/IO/polygon_mesh_io.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/random_perturbation.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;boost/property_map/vector_property_map.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> <a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point_3;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Kernel::Point_3&gt;</a> Mesh;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>PMP = CGAL::Polygon_mesh_processing;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  Mesh sm;</div>
<div class="line">  <a class="code hl_functionRef" href="../BGL/group__PkgBGLIOFct.html#ga49f5b5e6fbfcbfaaac7604c88e10915c">CGAL::IO::read_polygon_mesh</a>(<a class="code hl_functionRef" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/fandisk.off"</span>), sm);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//apply a perturbation to input vertices so that points are no longer coplanar</span></div>
<div class="line">  <a class="code hl_function" href="group__PMP__local__remeshing__grp.html#gae6be1cd5e76dcc3d6b63a0c55ae78999">PMP::random_perturbation</a>(sm, 0.001);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// declare vectors to store mesh properties</span></div>
<div class="line">  std::vector&lt;std::size_t&gt; region_ids(num_faces(sm));</div>
<div class="line">  std::vector&lt;std::size_t&gt; corner_id_map(num_vertices(sm), -1); <span class="comment">// corner status of vertices</span></div>
<div class="line">  std::vector&lt;bool&gt; ecm(num_edges(sm), <span class="keyword">false</span>); <span class="comment">// mark edges at the boundary of regions</span></div>
<div class="line">  boost::vector_property_map&lt;CGAL::Epick::Vector_3&gt; normal_map; <span class="comment">// normal of the supporting planes of the regions detected</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// detect planar regions in the mesh</span></div>
<div class="line">  std::size_t nb_regions =</div>
<div class="line">    <a class="code hl_functionRef" href="../Polygon_mesh_processing/group__PMP__detect__features__grp.html#ga50dcd2f6295f584d2e378b57290ae2af">PMP::region_growing_of_planes_on_faces</a>(sm,</div>
<div class="line">                                           CGAL::make_random_access_property_map(region_ids),</div>
<div class="line">                                           CGAL::parameters::cosine_of_maximum_angle(0.98).</div>
<div class="line">                                                             region_primitive_map(normal_map).</div>
<div class="line">                                                             maximum_distance(0.011));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// detect corner vertices on the boundary of planar regions</span></div>
<div class="line">  std::size_t nb_corners =</div>
<div class="line">    <a class="code hl_functionRef" href="../Polygon_mesh_processing/group__PMP__detect__features__grp.html#gac8e445730d718a2fc49604e865017d2e">PMP::detect_corners_of_regions</a>(sm,</div>
<div class="line">                                   CGAL::make_random_access_property_map(region_ids),</div>
<div class="line">                                   nb_regions,</div>
<div class="line">                                   CGAL::make_random_access_property_map(corner_id_map),</div>
<div class="line">                                   CGAL::parameters::cosine_of_maximum_angle(0.98).</div>
<div class="line">                                                     maximum_distance(0.011).</div>
<div class="line">                                                     edge_is_constrained_map(CGAL::make_random_access_property_map(ecm)));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// run the remeshing algorithm using filled properties</span></div>
<div class="line">  Mesh out;</div>
<div class="line">  <a class="code hl_function" href="group__PMP__planar__remeshing__grp.html#ga0e6da479548199a5d82c3cf0ed36e8a0">PMP::remesh_almost_planar_patches</a>(sm,</div>
<div class="line">                                    out,</div>
<div class="line">                                    nb_regions, nb_corners,</div>
<div class="line">                                    CGAL::make_random_access_property_map(region_ids),</div>
<div class="line">                                    CGAL::make_random_access_property_map(corner_id_map),</div>
<div class="line">                                    CGAL::make_random_access_property_map(ecm),</div>
<div class="line">                                    CGAL::parameters::patch_normal_map(normal_map));</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_functionRef" href="../BGL/group__PkgBGLIOFct.html#gafa143949a33371dc6df8307be1ab8a66">CGAL::IO::write_polygon_mesh</a>(<span class="stringliteral">"fandisk_remeshed.off"</span>, out);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__PMP__detect__features__grp_html_ga50dcd2f6295f584d2e378b57290ae2af"><div class="ttname"><a href="../Polygon_mesh_processing/group__PMP__detect__features__grp.html#ga50dcd2f6295f584d2e378b57290ae2af">CGAL::Polygon_mesh_processing::region_growing_of_planes_on_faces</a></div><div class="ttdeci">std::size_t region_growing_of_planes_on_faces(const PolygonMesh &amp;mesh, RegionMap region_map, const NamedParameters &amp;np=parameters::default_values())</div></div>
<div class="ttc" id="agroup__PMP__detect__features__grp_html_gac8e445730d718a2fc49604e865017d2e"><div class="ttname"><a href="../Polygon_mesh_processing/group__PMP__detect__features__grp.html#gac8e445730d718a2fc49604e865017d2e">CGAL::Polygon_mesh_processing::detect_corners_of_regions</a></div><div class="ttdeci">std::size_t detect_corners_of_regions(const PolygonMesh &amp;mesh, RegionMap region_map, std::size_t nb_regions, CornerIdMap corner_id_map, const NamedParameters &amp;np=parameters::default_values())</div></div>
<div class="ttc" id="agroup__PMP__local__remeshing__grp_html_gae6be1cd5e76dcc3d6b63a0c55ae78999"><div class="ttname"><a href="group__PMP__local__remeshing__grp.html#gae6be1cd5e76dcc3d6b63a0c55ae78999">CGAL::Polygon_mesh_processing::random_perturbation</a></div><div class="ttdeci">void random_perturbation(VertexRange vertices, TriangleMesh &amp;tmesh, const double &amp;perturbation_max_size, const NamedParameters &amp;np=parameters::default_values())</div><div class="ttdoc">randomly perturbs the locations of non-border vertices of a triangulated surface mesh.</div><div class="ttdef"><b>Definition:</b> random_perturbation.h:156</div></div>
<div class="ttc" id="agroup__PMP__planar__remeshing__grp_html_ga0e6da479548199a5d82c3cf0ed36e8a0"><div class="ttname"><a href="group__PMP__planar__remeshing__grp.html#ga0e6da479548199a5d82c3cf0ed36e8a0">CGAL::Polygon_mesh_processing::remesh_almost_planar_patches</a></div><div class="ttdeci">bool remesh_almost_planar_patches(const TriangleMeshIn &amp;tm_in, PolygonMeshOut &amp;pm_out, std::size_t nb_patches, std::size_t nb_corners, FacePatchMap face_patch_map, VertexCornerMap vertex_corner_map, EdgeIsConstrainedMap ecm, const NamedParametersIn &amp;np_in=parameters::default_values(), const NamedParametersOut &amp;np_out=parameters::default_values())</div><div class="ttdoc">generates a new triangle mesh pm_out with the minimal number of triangles from a partition of tm_in.</div><div class="ttdef"><b>Definition:</b> remesh_planar_patches.h:1619</div></div>
</div><!-- fragment --> </details>
<p><a class="anchor" id="fig__decimate_cheese"></a></p><center> <table border="0">
<tr>
<td><img src="decimate_cheese.png" alt="" style="width:100%;" class="inline"> </td><td><img src="decimate_colors.png" alt="" style="width:100%;" class="inline">  </td></tr>
<tr align="center">
<td>(a)</td><td>(b) </td></tr>
</table>
</center>  <div class="cgal_figure_caption"> <p> <a class="el" href="index.html#fig__decimate_cheese">Figure 77.8</a> Remeshing of planar patches in two models: (a) planar patches in the cheese model are retriangulated; (b) the remeshed version of this model contains 14 vertices and has not been retriangulated. Patch IDs have been assigned to both input and output meshes, enabling an identical color scheme. </p> </div> <p> <br>
</p>
<p><a class="anchor" id="fig__decimate_rg_sphere"></a></p><center> <table border="0">
<tr>
<td><img src="decimate_rg_joint.png" alt="" style="width:100%;" class="inline">  </td></tr>
</table>
</center>  <div class="cgal_figure_caption"> <p> <a class="el" href="index.html#fig__decimate_rg_sphere">Figure 77.9</a> Remeshing of planar patches using region growing for planar patch detection. From left to right: input mesh, remeshed version, remeshed version using the same angle threshold but larger approximation error. </p> </div> <p> <br>
</p>
<h1><a class="anchor" id="Extrusion"></a>
Extrusion</h1>
<p>This package provides two functions for extruding triangle meshes with boundaries. The first extrudes by offsetting each vertex by a user-provided vector. The second is more general, accepting two user-provided functors to extrude "up" and "down". In both cases, boundaries are connected by a triangle strip. Note that extrusion may produce self-intersecting surfaces.</p>
<p>The following example demonstrates extrusion in both directions by projecting points along the vertex normal. If the <code>Bottom</code> function were the identity, this would result in a one-sided extrusion.</p>
<p><b>Example: </b> <a class="el" href="PMP_Remeshing_2extrude_8cpp-example.html">PMP_Remeshing/extrude.cpp</a> <br>
</p><details>
<summary>
Show / Hide</summary>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/compute_normal.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/extrude.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/IO/polygon_mesh_io.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>    <a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Kernel::Point_3&gt;</a>                    Mesh;</div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::vertex_descriptor           vertex_descriptor;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a>                                       Vector;</div>
<div class="line"><span class="keyword">typedef</span> boost::property_map&lt;Mesh, CGAL::vertex_point_t&gt;::type  VPMap;</div>
<div class="line"><span class="keyword">typedef</span> Mesh::template Property_map&lt;vertex_descriptor, Vector&gt; VNMap;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Bottom</div>
<div class="line">{</div>
<div class="line">  Bottom(VPMap pmap, VNMap nmap, <span class="keywordtype">double</span> vlen)</div>
<div class="line">    : pmap(pmap), nmap(nmap), vlen(vlen)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> vertex_descriptor&amp; vin, <span class="keyword">const</span> vertex_descriptor vout)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    put(pmap, vout, get(pmap, vout) - vlen* get(nmap, vin));</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  VPMap pmap;</div>
<div class="line">  VNMap nmap;</div>
<div class="line">  <span class="keywordtype">double</span> vlen;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Top</div>
<div class="line">{</div>
<div class="line">  Top(VPMap pmap, VNMap nmap, <span class="keywordtype">double</span> vlen)</div>
<div class="line">    : pmap(pmap), nmap(nmap), vlen(vlen)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> vertex_descriptor&amp; vin, <span class="keyword">const</span> vertex_descriptor vout)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    put(pmap, vout, get(pmap, vout) + vlen* get(nmap, vin));</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  VPMap pmap;</div>
<div class="line">  VNMap nmap;</div>
<div class="line">  <span class="keywordtype">double</span> vlen;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  Mesh in, out;</div>
<div class="line"> </div>
<div class="line">  std::string filename = (argc &gt; 1) ? std::string(argv[1]) : <a class="code hl_functionRef" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/cube-ouvert.off"</span>);</div>
<div class="line">  <span class="keywordtype">double</span> vlen = (argc &gt; 2) ? std::stod(argv[2]) : 0.1;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_functionRef" href="../BGL/group__PkgBGLIOFct.html#ga49f5b5e6fbfcbfaaac7604c88e10915c">CGAL::IO::read_polygon_mesh</a>(filename, in);</div>
<div class="line"> </div>
<div class="line">  VNMap vnormals = in.template add_property_map&lt;vertex_descriptor, Vector&gt;(<span class="stringliteral">"v:normal"</span>, <a class="code hl_variableRef" href="../Kernel_23/group__kernel__enums.html#ga4a98ec6bd9dfd8fe8c46fea553b5d238">CGAL::NULL_VECTOR</a>).first;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_functionRef" href="../Polygon_mesh_processing/group__PMP__normal__grp.html#ga74e6b247d7e28beb677076aad5614d8c">CGAL::Polygon_mesh_processing::compute_vertex_normals</a>(in, vnormals);</div>
<div class="line">  Bottom bottom(get(CGAL::vertex_point,out), vnormals, vlen);</div>
<div class="line">  Top top(get(CGAL::vertex_point,out), vnormals, vlen);</div>
<div class="line">  <a class="code hl_function" href="group__PMP__meshing__grp.html#ga300c5eedd7d62bbd10ad2655405562f4">CGAL::Polygon_mesh_processing::extrude_mesh</a>(in, out, bottom, top);</div>
<div class="line"> </div>
<div class="line">  filename = filename.substr(filename.find_last_of(<span class="stringliteral">"/"</span>) + 1, filename.length() - 1);</div>
<div class="line">  filename = filename.substr(0, filename.find_last_of(<span class="stringliteral">"."</span>));</div>
<div class="line">  filename = filename + <span class="stringliteral">"_"</span> + std::to_string(vlen) + <span class="stringliteral">".off"</span>;</div>
<div class="line">  <a class="code hl_functionRef" href="../BGL/group__PkgBGLIOFct.html#gafa143949a33371dc6df8307be1ab8a66">CGAL::IO::write_polygon_mesh</a>(filename, out, CGAL::parameters::stream_precision(17));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassKernel_1_1Vector__3_html"><div class="ttname"><a href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a></div></div>
<div class="ttc" id="agroup__PMP__meshing__grp_html_ga300c5eedd7d62bbd10ad2655405562f4"><div class="ttname"><a href="group__PMP__meshing__grp.html#ga300c5eedd7d62bbd10ad2655405562f4">CGAL::Polygon_mesh_processing::extrude_mesh</a></div><div class="ttdeci">void extrude_mesh(const InputMesh &amp;input, OutputMesh &amp;output, const BottomFunctor &amp;bot, const TopFunctor &amp;top, const NamedParameters1 &amp;np_in=parameters::default_values(), const NamedParameters2 &amp;np_out=parameters::default_values())</div><div class="ttdoc">performs a generalized extrusion of input and puts it in output.</div><div class="ttdef"><b>Definition:</b> extrude.h:163</div></div>
<div class="ttc" id="agroup__PMP__normal__grp_html_ga74e6b247d7e28beb677076aad5614d8c"><div class="ttname"><a href="../Polygon_mesh_processing/group__PMP__normal__grp.html#ga74e6b247d7e28beb677076aad5614d8c">CGAL::Polygon_mesh_processing::compute_vertex_normals</a></div><div class="ttdeci">void compute_vertex_normals(const PolygonMesh &amp;pmesh, VertexNormalMap vertex_normals, const NamedParameters &amp;np=parameters::default_values())</div></div>
<div class="ttc" id="agroup__kernel__enums_html_ga4a98ec6bd9dfd8fe8c46fea553b5d238"><div class="ttname"><a href="../Kernel_23/group__kernel__enums.html#ga4a98ec6bd9dfd8fe8c46fea553b5d238">CGAL::NULL_VECTOR</a></div><div class="ttdeci">const CGAL::Null_vector NULL_VECTOR</div></div>
</div><!-- fragment --> </details>
<h1><a class="anchor" id="PMPRemeshingHistory"></a>
Implementation History</h1>
<p>A prototype for mesh and shape smoothing was developed during the 2017 Google Summer of Code by Konstantinos Katrioplas, supervised by Jane Tournois. It was finalized by Mael Rouxel-Labbé and integrated in CGAL 5.0.</p>
<p>The curvature-based sizing field for isotropic remeshing was added by Ivan Pađen during GSoC 2023, supervised by Sébastien Loriot and Jane Tournois.</p>
<p>The ACVD Remeshing method implementation was initiated by Hossam Saeed during GSoC 2023, supervised by Sébastien Valette and Sébastien Loriot, who later finalized the work. The implementation is based on <a class="el" href="citelist.html#CITEREF_cgal:vcp-grtmmdvd-08">[11]</a> and preceding work. <a href="https://www.creatis.insa-lyon.fr/~valette/public/project/acvd/">ACVD's implementation</a> was also used as a reference during the project. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"></a> 1.9.6 </li>
  </ul>
</div>
</div>
</body>


</html>
