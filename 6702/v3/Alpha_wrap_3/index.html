<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="https://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Alpha_wrap_3/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 5.6 - 3D Alpha Wrapping: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//&amp;lt;![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      }
  }
}
);
//]]&amp;gt;
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.6 - 3D Alpha Wrapping
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_3D_Alpha_wrapping"></a> </p><div id="autotoc" class="toc"></div> 
<dl class="section author"><dt>Authors</dt><dd>Pierre Alliez, David Cohen-Steiner, Michael Hemmer, Cédric Portaneri, Mael Rouxel-Labbé</dd></dl>
<center> <div class="image">
<img src="aw3_bike_lod.jpg" style="max-width:70%;" />
</div>
 </center><h1><a class="anchor" id="aw3_introduction"></a>
Introduction</h1>
<p>Various tasks in geometric modeling and processing require 3D objects represented as valid surface meshes, where "valid" refers to meshes that are watertight, intersection-free, orientable, and 2-manifold. Such representations offer well-defined notions of interior/exterior and geodesic neighborhoods.</p>
<p>3D data are usually acquired through measurements followed by reconstruction, designed by humans, or generated through imperfect automated processes. As a result, they can exhibit a wide variety of defects including gaps, missing data, self-intersections, degeneracies such as zero-volume structures, and non-manifold features.</p>
<p>Given the large repertoire of possible defects, many methods and data structures have been proposed to repair specific defects, usually with the goal of guaranteeing specific properties in the repaired 3D model. Reliably repairing all types of defects is notoriously difficult and is often an ill-posed problem as many valid solutions exist for a given 3D model with defects. In addition, the input model can be overly complex with unnecessary geometric details, spurious topological structures, nonessential inner components, or excessively fine discretizations. For applications such as collision avoidance, path planning, or simulation, getting an approximation of the input can be more relevant than repairing it. Approximation herein refers to an approach capable of filtering out inner structures, fine details and cavities, as well as wrapping the input within a user-defined offset margin.</p>
<p>Given an input 3D geometry, we address the problem of computing a conservative approximation, where conservative means that the output is guaranteed to strictly enclose the input. We seek unconditional robustness in the sense that the output mesh should be valid (oriented, 2-manifold, and without self-intersections), even for raw input with many defects and degeneracies. The default input is a soup of 3D triangles, but the generic interface leaves the door open to other types of finite 3D primitives such as triangle soups and point sets.</p>
<p><a class="anchor" id="fig__1"></a></p><center> <div class="image">
<img src="aw3_triangle_soup.jpg" style="max-width:70%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__1">Figure 62.1</a> Shrink-wrapping output from a triangle soup, with many intersections and gaps. From left to right, input model, output wrap, and superposition.  </div> <br /> 
<p><a class="anchor" id="fig__2"></a></p><center> <div class="image">
<img src="aw3_non_manifold_cases.jpg" style="max-width:75%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__2">Figure 62.2</a> Dealing with non-manifold features and degeneracies. From left to right, a non-manifold vertex, self-intersecting faces and two adjacent triangles representing a zero-volume structure. The algorithm handles these cases by wrapping an offset of the input.  </div> <br /> 
<h1><a class="anchor" id="aw3_definition"></a>
Approach</h1>
<p>Many approaches have been devised to enclose a 3D model within a volume, featuring different balances between the runtime and quality (i.e., tightness) of the approximation. Within the simplest cases, an axis-aligned or oriented bounding box clearly satisfies some desired properties; however, the approximation error is uncontrollable and often very large. Computing the convex hull of the input also matches some of the desired properties and improves the quality of the result, albeit at the price of increasing the runtime. However, the approximation remains crude, especially in the case of several components.</p>
<p>The convex hull is, in fact, a special case of alpha shapes (<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Alpha_shapes_3.tag:../Alpha_shapes_3/" href="../Alpha_shapes_3/index.html#Chapter_3D_Alpha_Shapes">Chapter_3D_Alpha_Shapes</a>). Mathematically, the alpha shape is a subcomplex of the Delaunay triangulation, with simplicies being part of the complex depending on the size of their minimal (empty) Delaunay ball. Intuitively, constructing 3D alpha shapes can be thought of as carving 3D space with an empty ball of user-defined radius alpha. Alpha shapes yield provable, good piecewise-linear approximations of a shape <a class="el" href="citelist.html#CITEREF_bb-srmua-97t">[1]</a>, but are defined on point sets, whereas we wish to deal with more general input data, such as triangle soups. Even after sampling the triangle soup, alpha shapes do not guarantee to be conservative for any alpha. Finally, inner structures are also carved within the volumes, instead of being filtered out.</p>
<p>Inspired by alpha shapes, we replace the above notion of carving by <em>shrink-wrapping</em>: we iteratively construct a subcomplex of a 3D Delaunay triangulation by starting from a simple 3D Delaunay triangulation enclosing the input, and then iteratively removing eligible tetrahedra that lie on the boundary of the complex. In addition, the underlying triangulation—and thus the complex incidentally—is refined as shrinking proceeds. Thus, instead of carving from the convex hull of the input data as in alpha shapes, we construct an entirely new mesh through a Delaunay refinement-like algorithm. The refinement algorithm inserts Steiner points on the boundary of an offset volume, defined as a level set of the unsigned distance field to the input.</p>
<p>This process both prevents the creation of inner structures within the output and avoids superfluous computations. In addition, detaching our mesh construction from the geometry and discretization of the input has several advantages: (1) the underlying data is not restricted to a specific format (triangle soups, polygon soups, point clouds, etc.) as all that is required is answering three basic geometric queries: (a) the distance between a point and the input, (b) the projection of a query point onto the input, (c) an intersection test between a tetrahedron and the input, and (2) The user has more freedom to trade tightness to the input for final mesh complexity, as constructing a conservative approximation on a large offset of the input requires fewer mesh elements.</p>
<h2><a class="anchor" id="aw3_algorithm"></a>
Algorithm</h2>
<p><b>Initialization</b>. The algorithm is initialized by inserting the eight corner vertices of a loose bounding box into a 3D Delaunay triangulation. In the 3D Delaunay triangulation of CGAL, all triangle facets are adjacent to two tetrahedron cells. Each facet of the boundary of the Delaunay triangulation, which coincides with one facet of the convex hull of the triangulation vertices, is adjacent to a so-called <em>infinite</em> tetrahedron cell, an abstract cell connected to the so-called <em>infinite vertex</em> to ensure the aforementioned double-facet adjacency. Initially, all infinite cells are tagged as outside, and all finite tetrahedron cells are tagged as inside.</p>
<p><b>Shrink-wrapping</b>. The shrink-wrapping algorithm proceeds by traversing the cells of the Delaunay triangulation from outside to inside, flood-filling from one cell to its adjacent cell, and tagging the adjacent cell as outside whenever possible (the term possible is specified later). Flood filling is implemented via a priority queue of Delaunay triangle facets representing the traversal between the two adjacent cells of the facet, from outside to inside. These triangle facets are referred to as <em>gates</em> in the following.</p>
<p>Given an outside cell and its adjacent inside cell, the common facet (i.e., a gate) is said to be <em>alpha-traversable</em> if its circumradius is larger than the user-defined parameter alpha, where circumradius refers to the radius of the relating triangle's Delaunay ball. Intuitively, cavities smaller than alpha are not accessible as their gates are not alpha-traversable.</p>
<p>Initialized by the alpha-traversable gates on the convex hull, the priority queue contains only alpha-traversable gates and is sorted by decreasing order of the circumradius of the gate. Traversal can be seen as a continuous process that advances along dual Voronoi edges of the gates, with a pencil of empty balls circumscribing the gate.</p>
<p><a class="anchor" id="fig__3"></a></p><center> <div class="image">
<img src="aw3_pencil.png" style="max-width:40%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__3">Figure 62.3</a> (Left) Pencil of empty circles (blue) circumscribing a Delaunay edge (green) in a 2D Delaunay triangulation (black). From the top triangle circumcenter <em>c1</em> to the bottom triangle circumcenter <em>c2</em>, the dual Voronoi edge denoted by <em>e</em> (doted red) is the trace of centers of the largest circles that are empty of Delaunay vertex. (Right) The graph corresponding to the left example. The x-axis corresponds to the position of empty circle centers located on the Voronoi edge <em>e</em>, from <em>c1</em> to <em>c2</em>. The y-axis is the radius value of the corresponding empty circles. In this case, the minimum radius of this pencil of empty circle is located at the midpoint of the green Delaunay edge. In our algorithm, a gate (green Delaunay edge) is said to be not alpha-traversable when the minimum radius of the pencil of empty circle is smaller than alpha.  </div> <br /> 
<p>When traversing from an outside cell \( c_o \) to an inside cell \( c_i \) through an alpha-traversable facet \( f \), two criteria are tested to prevent the wrapping process from colliding with the input:</p>
<p>(1) We check for an intersection between the dual Voronoi edge of \( f \), i.e. the segment between the circumcenters of the two incident cells, and the <em>offset surface</em>, defined as the level set of unsigned isosurface to the input. If one or several intersections exists, the first intersection point, along the dual Voronoi edge oriented from outside to inside is inserted into the triangulation as a Steiner point.</p>
<p>(2) If the dual Voronoi edge does not intersect the offset surface but the neighboring cell \( c_i \) intersects the input, we compute the projection of the circumcenter of \( c_i \) onto the offset surface, and insert it into the triangulation as a Steiner point (which destroys \( c_i \)).</p>
<p>After each of the above Steiner point insertions, all new incident cells are tagged as inside, and the newly alpha-traversable gates are pushed into the priority queue.</p>
<p>If none of the above two criteria are met, the neighboring cell \( c_i \) is traversed and tagged as outside. Alpha-Traversable facets of \( c_i \) that are separating inside from outside cells are pushed as new gates into the priority queue.</p>
<p>Once the queue empties—a process that is guaranteed as facets (and their circumradii) become smaller due to the insertion of new Steiner points—the construction phase terminates. The output triangle surface mesh is extracted from the Delaunay triangulation as the set of facets separating inside from outside cells.</p>
<p>The figure below depicts the steps of the algorithm in 2D.</p>
<p><a class="anchor" id="fig__4"></a></p><center> <div class="image">
<img src="aw3_steps.jpg" style="max-width:95%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__4">Figure 62.4</a> Steps of the shrink-wrapping algorithm in 2D. The algorithm is initialized by inserting the corners of the loose bounding box of the input (red) into a Delaunay triangulation, and all finite triangles are tagged inside (grey). The current gate (green edge) popped out from the queue is alpha-traversable. The triangle adjacent to the gate is tagged outside when it does not intersect the input, and new alpha-traversable gates are pushed to the queue. When the adjacent triangle intersects the input, a new Steiner point (large green disc) is computed and inserted into the triangulation, all neighboring triangles are tagged inside, new alpha-traversable gates are pushed to the queue, and traversal is resumed. Grey edges depict the Delaunay triangulation. Blue edges depict the Voronoi diagram. Pink circles depict the empty circle of radius alpha. The output edges (dark blue) separate inside from outside triangles.  </div> <br /> 
<h2><a class="anchor" id="aw3_guarantees"></a>
Guarantees</h2>
<p>The algorithm is proven to terminate and to produce a 2-manifold triangulated surface mesh that strictly encloses the input data. The key element to the proof is that we wrap from outside to inside and never allow a cell that intersects the input to be flagged inside. Furthermore, both criteria that lead to refinement of the triangulation insert Steiner points that are guaranteed to break the cells in need of refinement and reduce the neighbor facets circumradii.</p>
<p>Because the main refinement criterion is the insertion of an intersection between a dual Voronoi edge and an offset of the input, or the projection of a Voronoi vertex onto the offset of the input, the algorithm has similarities to popular meshing algorithms based on Delaunay filtering and refinement (see <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Mesh_3.tag:../Mesh_3/" href="../Mesh_3/index.html#Chapter_3D_Mesh_Generation">Chapter_3D_Mesh_Generation</a>).</p>
<h1><a class="anchor" id="aw3_interface"></a>
Interface</h1>
<p>Our algorithm takes as input a set of triangles in 3D, provided either as a triangle soup or as a triangle surface mesh, and two user-defined scalar parameters: the <em>alpha</em> and the <em>offset</em> values. It proceeds by shrink-wrapping and refining a 3D Delaunay triangulation starting from a loose bounding box of the input. The parameter <em>alpha</em> refers to the size of cavities or holes that cannot be traversed during wrapping, and hence to the final level of detail, as alpha acts like a sizing field in a common Delaunay refinement algorithm (<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Mesh_3.tag:../Mesh_3/" href="../Mesh_3/index.html#Chapter_3D_Mesh_Generation">Chapter_3D_Mesh_Generation</a>). The parameter <em>offset</em> refers to the distance between the vertices of the refined triangulation and the input, so that a large offset translates into a loose enclosing of the input. This second parameter offers a means to control the trade-off between tightness and complexity.</p>
<p>The main entry point of the component is the global function <code><a class="el" href="group__AW3__free__functions__grp.html#ga3fcacd2397bd86329faa2855f8475ea5" title="computes a watertight, 2-manifold, and intersection-free triangulated surface mesh that strictly cont...">CGAL::alpha_wrap_3()</a></code> that generates the alpha wrap; this function takes as input a polygon soup or a polygon mesh. There is no prerequisite on the input connectivity so that it can take an arbitrary triangle soup, with islands, self-intersections, or overlaps, as well as combinatorial or geometrical degeneracies.</p>
<p>The underlying traits class must be a model of the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a></code> concept. It should use a floating point number type as inexactness is inherent to the algorithm since there is no closed form description of new vertices on the offset surface.</p>
<p>The output is a triangle surface mesh whose type is chosen by the user, under the constraint that it must be a model of the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/classMutableFaceGraph.html">MutableFaceGraph</a></code> concept.</p>
<h1><a class="anchor" id="aw3_parameters"></a>
Choosing Parameters</h1>
<p>The two parameters of the algorithm impact both the level of detail and complexity of the output mesh.</p>
<h2><a class="anchor" id="aw3_alpha"></a>
Alpha</h2>
<p>The main parameter, alpha, controls whether a Delaunay facet is traversable during shrink-wrapping. Alpha's main purpose is to control the size of the empty balls used during wrapping, and thus to determine which features will appear in the output: indeed, a facet is alpha-traversable if its circumradius is larger than alpha; hence, the algorithm can only shrink-wrap through straits or holes with diameters larger than alpha. A second, less direct consequence is that as long as a facet has a circumradius larger than alpha, the incident inside cell will be visited and possibly refined. Therefore, when the algorithm terminates, all facets have a circumradius smaller than alpha. This parameter thus also behaves like a sizing criterion on the triangle facets of the output.</p>
<p><a class="anchor" id="fig__5"></a></p><center> <div class="image">
<img src="aw3_church_lod.jpg" style="max-width:90%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__5">Figure 62.5</a> Impact of the alpha parameter on the output. (Left) The input triangle mesh, generated by surface reconstruction from a raw point cloud, has many non-manifold edges and vertices, superfluous geometric details and spurious topological structures. (Right) This component approximates the input conservatively and produces valid meshes with different complexity and fidelity to the input, depending on the alpha parameter. The smaller the alpha, the deeper the shrink-wrapping process will enter cavities. The alpha parameter is decreasing from left to right, to respectively 1/50, 1/100 and 1/300 of the longest diagonal of the input bounding box. A large alpha will produce an output less complex but less faithful to the input.  </div> <br /> 
<h2><a class="anchor" id="aw3_offset"></a>
Offset</h2>
<p>The second parameter, the offset distance, controls the distance from the input and thus the definition of the offset isosurface onto which the vertices of the output mesh are located. This parameter controls the tightness of the result, which has, in turn, a few consequences. Firstly, locating vertices away from the input enables the algorithm to generate a less complex mesh, especially in convex areas. A trivial example of this behavior would be a very dense mesh of a sphere, for which an as-tight-as-possible envelope would also be very dense. Secondly, the farther the isosurface is from the input, the more new points are inserted through the first criterion (i.e., through intersection with dual Voronoi edge, see Section <a class="el" href="index.html#aw3_algorithm">Algorithm</a>); thus, the quality of the output improves in terms of angles of the triangle elements. Finally, and depending on the value of the alpha parameter, a large offset can also offer defeaturing capabilities. However using a small offset parameter will tend to better preserve sharp features as projection Steiner points tend to project onto convex sharp features.</p>
<p><a class="anchor" id="fig__6"></a></p><center> <div class="image">
<img src="aw3_sharp_feature.jpg" style="max-width:90%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__6">Figure 62.6</a> Impact of the offset parameter on the output. (Left) Input mesh generated by meshing a NURBS CAD model in parameter space. (Right) The smaller the offset, the closest sample points are to the input. The offset parameter is decreasing from left to right, to respectively 1/50, 1/200 and 1/1000 of the longest diagonal of the input bounding box. The alpha parameter is equal to 1/50 of the longest diagonal of the input bounding box for all level of details. A larger offset will produce an output less complex with better triangle quality. However the sharp features (red edges) are well preserved when the offset parameter is small.  </div> <br /> 
<p><a class="anchor" id="fig__7"></a></p><center> <div class="image">
<img src="aw3_steiner.jpg" style="max-width:90%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__7">Figure 62.7</a> Steiner points. The projection Steiner points (green) are computed by projecting the triangle circumcenter onto the offset. The intersection Steiner points (blue) are computed as the first intersection point between the Voronoi edge and the offset. (Left) When the offset parameter is small, the algorithm produces more projection Steiner points, which tends to improve the preservation of convex sharp features. (Right) When the offset parameter is large, the algorithm produces more intersection Steiner points, which tends to generate triangles with better quality in terms of angles, in 3D.  </div> <br /> 
<p>By default, we recommend to set the offset parameter to a small fraction of alpha, so that alpha becomes the main parameter that controls the final level of detail.</p>
<p>The image below illustrates the impact of both parameters.</p>
<p><a class="anchor" id="fig__8"></a></p><center> <div class="image">
<img src="aw3_alpha_offset_bike.jpg" style="max-width:80%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__8">Figure 62.8</a> Different alpha and offset values on the bike model (533,000 triangles). The x-axis represents the offset value equal to 1/5000, 1/2000, 1/500, 1/200, 1/50, 1/20 and 1/5 of the longest diagonal of the input bounding box, from left to right. The y-axis represents the alpha value equal to 1/300, 1/100, 1/50, 1/20 and 1/5 of the longest diagonal of the input bounding box, from bottom to top. The numbers below each level of detail represents their number of triangles. Depending on the alpha value, an offset too small or too large will produce output mesh with higher complexity. For each alpha, the models with lower complexity can be used as a scale-space representations for collision detection, from near to far distances.  </div> <br /> 
<h2><a class="anchor" id="aw3_two_side"></a>
A Note on "Two-Sided" Wraps</h2>
<p>The offset parameter is crucial to our approach because it guarantees that the output is a closed, 2-manifold surface mesh. Indeed, and even when the input is a zero-volume structure such as a single 3D triangle, the output wrap is a thin volume enclosing the said triangle <a class="el" href="index.html#fig__2">Figure 62.2</a>.</p>
<p>Users should keep in mind that the wrapping algorithm has no means of determining whether it is acting on the inside or the outside of the unsigned distance field, and will thus produce two-sided wraps in the case of holes in the input and values of alpha smaller than the size of the holes.</p>
<p><a class="anchor" id="fig__9"></a></p><center> <div class="image">
<img src="aw3_double_sided.jpg" style="max-width:80%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__9">Figure 62.9</a> Two-sided wrap. (Left) Wrapping a Bunny in 2D, with decreasing values for alpha. (Right) Wrapping a defect-laden Bunny in 3D. The rightmost column depicts a clipped visualization of the inside. When alpha is small enough with respect the diamater of the holes, the algorithm generates a two-sided wrap.  </div> <br /> 
<h1><a class="anchor" id="aw3_performance"></a>
Performance</h1>
<p>The charts below plots the computation times of the wrapping algorithm on the Thingi10k dataset, as well as the complexity of the output triangle mesh.</p>
<p><a class="anchor" id="fig__10"></a></p><center> <div class="image">
<img src="aw3_thingi10k_benchmark.jpg" style="max-width:80%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__9">Figure 62.9</a> Execution times and output complexity for different values of alpha on the Thingi10k data set. Alpha increases from 1/20 to 1/200 of the length of bounding box diagonal. The x axis represents the complexity of the output wrap mesh in number of triangle facets. The y axis represents the total computation time, in seconds. The color and diameter of the dots represent the number of faces in the input triangle soup, ranging from 10 (green) to 3154000 (blue).  </div> <br /> 
<h1><a class="anchor" id="aw3_examples"></a>
Examples</h1>
<p>Here is an example with an input triangle mesh, with alpha set to 1/20 of the bounding box longest diagonal edge length, and offset set to 1/30 of alpha (i.e., 1/600 of the bounding box diagonal edge length).</p>
<p><br />
<b>File</b> <a class="el" href="Alpha_wrap_3_2triangle_mesh_wrap_8cpp-example.html">Alpha_wrap_3/triangle_mesh_wrap.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/alpha_wrap_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/bbox.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/IO/polygon_mesh_io.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>AW3 = <a class="code" href="namespaceCGAL_1_1Alpha__wraps__3.html">CGAL::Alpha_wraps_3</a>;</div><div class="line"><span class="keyword">namespace </span>PMP = CGAL::Polygon_mesh_processing;</div><div class="line"></div><div class="line"><span class="keyword">using</span> K = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div><div class="line"><span class="keyword">using</span> Point_3 = K::Point_3;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Mesh = CGAL::Surface_mesh&lt;Point_3&gt;;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::cout.precision(17);</div><div class="line"></div><div class="line">  <span class="comment">// Read the input</span></div><div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : CGAL::data_file_path(<span class="stringliteral">"meshes/armadillo.off"</span>);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Reading "</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">"..."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  Mesh mesh;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLIOFct.html#ga49f5b5e6fbfcbfaaac7604c88e10915c">PMP::IO::read_polygon_mesh</a>(filename, mesh) || <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#gab6e6f18e6de73b9f85e38d0b56145172">is_empty</a>(mesh) || !<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#ga11883d231eec1b58f37efe4acedd9588">is_triangle_mesh</a>(mesh))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Input: "</span> &lt;&lt; num_vertices(mesh) &lt;&lt; <span class="stringliteral">" vertices, "</span> &lt;&lt; num_faces(mesh) &lt;&lt; <span class="stringliteral">" faces"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Compute the alpha and offset values</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> relative_alpha = (argc &gt; 2) ? std::stod(argv[2]) : 20.;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> relative_offset = (argc &gt; 3) ? std::stod(argv[3]) : 600.;</div><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html">CGAL::Bbox_3</a> bbox = CGAL::Polygon_mesh_processing::bbox(mesh);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> diag_length = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">std::sqrt</a>(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga07001b5ddc5c43096c811c91a306be9a">CGAL::square</a>(bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a3f5e323700e1509624a02d151237cc4c">xmax</a>() - bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#aab574470a2591f187553ca1166e682e1">xmin</a>()) +</div><div class="line">                                       <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga07001b5ddc5c43096c811c91a306be9a">CGAL::square</a>(bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a9d06f61bd89faa841e011ff53edf745f">ymax</a>() - bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a2088e16a1f0a20e011e5b94c2e9c222a">ymin</a>()) +</div><div class="line">                                       <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga07001b5ddc5c43096c811c91a306be9a">CGAL::square</a>(bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a98def8b9515f31ded759d781969ddaf6">zmax</a>() - bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a6c55430abc7fda54571cf1075c7f2f8b">zmin</a>()));</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> alpha = diag_length / relative_alpha;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> offset = diag_length / relative_offset;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"alpha: "</span> &lt;&lt; alpha &lt;&lt; <span class="stringliteral">", offset: "</span> &lt;&lt; offset &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Construct the wrap</span></div><div class="line">  CGAL::Real_timer t;</div><div class="line">  t.start();</div><div class="line"></div><div class="line">  Mesh wrap;</div><div class="line">  <a class="code" href="group__AW3__free__functions__grp.html#ga3fcacd2397bd86329faa2855f8475ea5">CGAL::alpha_wrap_3</a>(mesh, alpha, offset, wrap);</div><div class="line"></div><div class="line">  t.stop();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Result: "</span> &lt;&lt; num_vertices(wrap) &lt;&lt; <span class="stringliteral">" vertices, "</span> &lt;&lt; num_faces(wrap) &lt;&lt; <span class="stringliteral">" faces"</span> &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Took "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" s."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save the result</span></div><div class="line">  std::string input_name = std::string(filename);</div><div class="line">  input_name = input_name.substr(input_name.find_last_of(<span class="stringliteral">"/"</span>) + 1, input_name.length() - 1);</div><div class="line">  input_name = input_name.substr(0, input_name.find_last_of(<span class="stringliteral">"."</span>));</div><div class="line">  std::string output_name = input_name</div><div class="line">                            + <span class="stringliteral">"_"</span> + std::to_string(static_cast&lt;int&gt;(relative_alpha))</div><div class="line">                            + <span class="stringliteral">"_"</span> + std::to_string(static_cast&lt;int&gt;(relative_offset)) + <span class="stringliteral">".off"</span>;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Writing to "</span> &lt;&lt; output_name &lt;&lt; std::endl;</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLIOFct.html#gafa143949a33371dc6df8307be1ab8a66">CGAL::IO::write_polygon_mesh</a>(output_name, wrap, CGAL::parameters::stream_precision(17));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><p>Some triangle soups might not be representable as a mesh due to non-manifoldness or incompatible orientations. Such triangle soup is nevertheless a valid input for the wrapping algorithm, as illustrated in the following example.</p>
<p><br />
<b>File</b> <a class="el" href="Alpha_wrap_3_2triangle_soup_wrap_8cpp-example.html">Alpha_wrap_3/triangle_soup_wrap.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/alpha_wrap_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/bbox.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/polygon_soup_io.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;array&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>AW3 = <a class="code" href="namespaceCGAL_1_1Alpha__wraps__3.html">CGAL::Alpha_wraps_3</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> K = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div><div class="line"><span class="keyword">using</span> Point_3 = K::Point_3;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Mesh = CGAL::Surface_mesh&lt;Point_3&gt;;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::cout.precision(17);</div><div class="line"></div><div class="line">  <span class="comment">// Read the input</span></div><div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : CGAL::data_file_path(<span class="stringliteral">"meshes/blobby-shuffled.off"</span>);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Reading "</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">"..."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::vector&lt;Point_3&gt; points;</div><div class="line">  std::vector&lt;std::array&lt;std::size_t, 3&gt; &gt; faces;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__IOstreamFunctions.html#gaafb0e02f4669802c727709743065804c">CGAL::IO::read_polygon_soup</a>(filename, points, faces) || faces.empty())</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Input: "</span> &lt;&lt; points.size() &lt;&lt; <span class="stringliteral">" points, "</span> &lt;&lt; faces.size() &lt;&lt; <span class="stringliteral">" faces"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Compute the alpha and offset values</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> relative_alpha = (argc &gt; 2) ? std::stod(argv[2]) : 20.;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> relative_offset = (argc &gt; 3) ? std::stod(argv[3]) : 600.;</div><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html">CGAL::Bbox_3</a> bbox;</div><div class="line">  <span class="keywordflow">for</span>(<span class="keyword">const</span> Point_3&amp; p : points)</div><div class="line">    bbox += p.bbox();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> diag_length = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">std::sqrt</a>(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga07001b5ddc5c43096c811c91a306be9a">CGAL::square</a>(bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a3f5e323700e1509624a02d151237cc4c">xmax</a>() - bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#aab574470a2591f187553ca1166e682e1">xmin</a>()) +</div><div class="line">                                       <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga07001b5ddc5c43096c811c91a306be9a">CGAL::square</a>(bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a9d06f61bd89faa841e011ff53edf745f">ymax</a>() - bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a2088e16a1f0a20e011e5b94c2e9c222a">ymin</a>()) +</div><div class="line">                                       <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga07001b5ddc5c43096c811c91a306be9a">CGAL::square</a>(bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a98def8b9515f31ded759d781969ddaf6">zmax</a>() - bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a6c55430abc7fda54571cf1075c7f2f8b">zmin</a>()));</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> alpha = diag_length / relative_alpha;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> offset = diag_length / relative_offset;</div><div class="line"></div><div class="line">  <span class="comment">// Construct the wrap</span></div><div class="line">  CGAL::Real_timer t;</div><div class="line">  t.start();</div><div class="line"></div><div class="line">  Mesh wrap;</div><div class="line">  <a class="code" href="group__AW3__free__functions__grp.html#ga3fcacd2397bd86329faa2855f8475ea5">CGAL::alpha_wrap_3</a>(points, faces, alpha, offset, wrap);</div><div class="line"></div><div class="line">  t.stop();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Result: "</span> &lt;&lt; num_vertices(wrap) &lt;&lt; <span class="stringliteral">" vertices, "</span> &lt;&lt; num_faces(wrap) &lt;&lt; <span class="stringliteral">" faces"</span> &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Took "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" s."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save the result</span></div><div class="line">  std::string input_name = std::string(filename);</div><div class="line">  input_name = input_name.substr(input_name.find_last_of(<span class="stringliteral">"/"</span>) + 1, input_name.length() - 1);</div><div class="line">  input_name = input_name.substr(0, input_name.find_last_of(<span class="stringliteral">"."</span>));</div><div class="line">  std::string output_name = input_name</div><div class="line">                            + <span class="stringliteral">"_"</span> + std::to_string(static_cast&lt;int&gt;(relative_alpha))</div><div class="line">                            + <span class="stringliteral">"_"</span> + std::to_string(static_cast&lt;int&gt;(relative_offset)) + <span class="stringliteral">".off"</span>;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Writing to "</span> &lt;&lt; output_name &lt;&lt; std::endl;</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLIOFct.html#gafa143949a33371dc6df8307be1ab8a66">CGAL::IO::write_polygon_mesh</a>(output_name, wrap, CGAL::parameters::stream_precision(17));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><p>Here is an example with a point cloud.</p>
<p><br />
<b>File</b> <a class="el" href="Alpha_wrap_3_2point_set_wrap_8cpp-example.html">Alpha_wrap_3/point_set_wrap.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/alpha_wrap_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>AW3 = <a class="code" href="namespaceCGAL_1_1Alpha__wraps__3.html">CGAL::Alpha_wraps_3</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> K = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div><div class="line"><span class="keyword">using</span> Point_3 = K::Point_3;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Point_container = std::vector&lt;Point_3&gt;;</div><div class="line"><span class="keyword">using</span> Mesh = CGAL::Surface_mesh&lt;Point_3&gt;;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::cout.precision(17);</div><div class="line"></div><div class="line">  <span class="comment">// Read the input</span></div><div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : CGAL::data_file_path(<span class="stringliteral">"points_3/oni.pwn"</span>);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Reading "</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">"..."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  Point_container points;</div><div class="line">  <span class="keywordflow">if</span>(!CGAL::IO::read_points(filename, std::back_inserter(points)) || points.empty())</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; points.size() &lt;&lt; <span class="stringliteral">" points"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Compute the alpha and offset values</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> relative_alpha = (argc &gt; 2) ? std::stod(argv[2]) : 10.;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> relative_offset = (argc &gt; 3) ? std::stod(argv[3]) : 300.;</div><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html">CGAL::Bbox_3</a> bbox = CGAL::bbox_3(std::cbegin(points), std::cend(points));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> diag_length = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">std::sqrt</a>(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga07001b5ddc5c43096c811c91a306be9a">CGAL::square</a>(bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a3f5e323700e1509624a02d151237cc4c">xmax</a>() - bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#aab574470a2591f187553ca1166e682e1">xmin</a>()) +</div><div class="line">                                       <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga07001b5ddc5c43096c811c91a306be9a">CGAL::square</a>(bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a9d06f61bd89faa841e011ff53edf745f">ymax</a>() - bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a2088e16a1f0a20e011e5b94c2e9c222a">ymin</a>()) +</div><div class="line">                                       <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga07001b5ddc5c43096c811c91a306be9a">CGAL::square</a>(bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a98def8b9515f31ded759d781969ddaf6">zmax</a>() - bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a6c55430abc7fda54571cf1075c7f2f8b">zmin</a>()));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> alpha = diag_length / relative_alpha;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> offset = diag_length / relative_offset;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"absolute alpha = "</span> &lt;&lt; alpha &lt;&lt; <span class="stringliteral">" absolute offset = "</span> &lt;&lt; offset &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Construct the wrap</span></div><div class="line">  CGAL::Real_timer t;</div><div class="line">  t.start();</div><div class="line"></div><div class="line">  Mesh wrap;</div><div class="line">  <a class="code" href="group__AW3__free__functions__grp.html#ga3fcacd2397bd86329faa2855f8475ea5">CGAL::alpha_wrap_3</a>(points, alpha, offset, wrap);</div><div class="line"></div><div class="line">  t.stop();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Result: "</span> &lt;&lt; num_vertices(wrap) &lt;&lt; <span class="stringliteral">" vertices, "</span> &lt;&lt; num_faces(wrap) &lt;&lt; <span class="stringliteral">" faces"</span> &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Took "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" s."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save the result</span></div><div class="line">  std::string input_name = std::string(filename);</div><div class="line">  input_name = input_name.substr(input_name.find_last_of(<span class="stringliteral">"/"</span>) + 1, input_name.length() - 1);</div><div class="line">  input_name = input_name.substr(0, input_name.find_last_of(<span class="stringliteral">"."</span>));</div><div class="line">  std::string output_name = input_name + <span class="stringliteral">"_"</span> + std::to_string(static_cast&lt;int&gt;(relative_alpha))</div><div class="line">                            + <span class="stringliteral">"_"</span> + std::to_string(static_cast&lt;int&gt;(relative_offset)) + <span class="stringliteral">".off"</span>;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Writing to "</span> &lt;&lt; output_name &lt;&lt; std::endl;</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLIOFct.html#gafa143949a33371dc6df8307be1ab8a66">CGAL::IO::write_polygon_mesh</a>(output_name, wrap, CGAL::parameters::stream_precision(17));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Dec 22 2022 12:48:40 for CGAL 5.6 - 3D Alpha Wrapping by
    <a href="https://www.doxygen.nl/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>


</html>
