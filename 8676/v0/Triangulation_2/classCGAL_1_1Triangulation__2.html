<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Triangulation_2/classCGAL_1_1Triangulation__2.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=11">
<meta name="generator" content="Doxygen 1.9.6">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CGAL 6.1 - 2D Triangulations: CGAL::Triangulation_2&lt; Traits, Tds &gt; Class Template Reference</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/doxygen.css" rel="stylesheet" type="text/css">
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      },
      equationNumbers: { autoNumber: "AMS" }
  }
}
);
MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
  var PARSE = MathJax.InputJax.TeX.Parse,
      TEXT = PARSE.prototype.InternalText;
  PARSE.Augment({
    InternalText: function (text,def) {
      text = text.replace(/\\/g,"");
      return TEXT.call(this,text,def);
    }
  });
});
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<script src="modules.js" type="text/javascript"></script>
<link href="cgal_stylesheet.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
      <span class="left">
         <span id="MSearchSelect" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"> 
        </span>
        <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
      </span>
      <span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.svg" alt=""></a>
      </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CGAL 6.1 - 2D Triangulations
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search/",'.html');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classCGAL_1_1Triangulation__2.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="classCGAL_1_1Triangulation__2-members.html">List of all members</a> |
<a href="#related">Related Functions</a>  </div>
  <div class="headertitle"><div class="title">CGAL::Triangulation_2&lt; Traits, Tds &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__PkgTriangulation2Ref.html">2D Triangulations Reference</a> » <a class="el" href="group__PkgTriangulation2TriangulationClasses.html">Triangulation Classes</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;CGAL/Triangulation_2.h&gt;</code></p>

<h2 class="groupheader">Inherits from</h2><p><a class="el" href="classCGAL_1_1Triangulation__cw__ccw__2.html">CGAL::Triangulation_cw_ccw_2</a>.</p>

<p>Inherited by <a class="el" href="classCGAL_1_1Constrained__triangulation__2.html">CGAL::Constrained_triangulation_2&lt; Traits, Tds, Itag &gt;</a>, <a class="el" href="classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2&lt; Traits, Tds &gt;</a>, and <a class="el" href="classCGAL_1_1Regular__triangulation__2.html">CGAL::Regular_triangulation_2&lt; Traits, Tds &gt;</a>.</p>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Traits, typename Tds&gt;<br>
class CGAL::Triangulation_2&lt; Traits, Tds &gt;</div><p>The class <code><a class="el" href="classCGAL_1_1Triangulation__2.html" title="The class Triangulation_2 is the basic class designed to handle triangulations of set of points  in t...">Triangulation_2</a></code> is the basic class designed to handle triangulations of set of points \( { A}\) in the plane. </p>
<p>Such a triangulation has vertices at the points of \( { A}\) and its domain covers the convex hull of \( { A}\). It can be viewed as a planar partition of the plane whose bounded faces are triangular and cover the convex hull of \( { A}\). The single unbounded face of this partition is the complementary of the convex hull of \( { A}\).</p>
<p>In many applications, it is convenient to deal only with triangular faces. Therefore, we add to the triangulation a fictitious vertex, called the <code>infinite vertex</code> and we make each convex hull edge incident to an <code>infinite</code> face having as third vertex the <code>infinite vertex</code>. In that way, each edge is incident to exactly two faces and special cases at the boundary of the convex hull are simpler to deal with.</p>
<p><a class="anchor" id="Triangulation_ref_Fig_infinite_vertex"></a></p><div class="image">
<img src="infinite_vertex.png" alt="">
<div class="caption">
The infinite vertex.</div></div>
 <p>The class <code><a class="el" href="classCGAL_1_1Triangulation__2.html" title="The class Triangulation_2 is the basic class designed to handle triangulations of set of points  in t...">Triangulation_2</a></code> implements this point of view and therefore considers the triangulation of the set of points as a set of triangular, finite and infinite faces. Although it is convenient to draw a triangulation as in figure <a class="el" href="classCGAL_1_1Triangulation__2.html#Triangulation_ref_Fig_infinite_vertex">Triangulation_ref_Fig_infinite_vertex</a>, note that the <code>infinite vertex</code> has no significant coordinates and that no geometric predicate can be applied on it or on an infinite face.</p>
<p>A triangulation is a collection of vertices and faces that are linked together through incidence and adjacency relations. Each face give access to its three incident vertices and to its three adjacent faces. Each vertex give access to one of its incident faces.</p>
<p>The three vertices of a face are indexed with 0, 1 and 2 in counterclockwise order. The neighbor of a face are also indexed with 0,1,2 in such a way that the neighbor indexed by \( i\) is opposite to the vertex with the same index.</p>
<p>The triangulation class offers two functions <code>int cw(int i)</code> and <code>int ccw(int i)</code> which, given the index of a vertex in a face, compute the index of the next vertex of the same face in clockwise or counterclockwise order. Thus, for example the neighbor <code>neighbor(cw(i))</code> is the neighbor of <code>f</code> which is next to <code>neighbor(i)</code> turning clockwise around <code>f</code>. The face <code>neighbor(cw(i))</code> is also the first face encountered after <code>f</code> when turning clockwise around vertex <code>i</code> of <code>f</code> (see Figure <a class="el" href="classCGAL_1_1Triangulation__2.html#Triangulation_ref_Fig_neighbors">Triangulation_ref_Fig_neighbors</a>).</p>
<p><a class="anchor" id="Triangulation_ref_Fig_neighbors"></a></p><div class="image">
<img src="neighbors.png" alt="">
<div class="caption">
Vertices and neighbors.</div></div>
 <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Traits</td><td>is the geometric traits which must be a model of the concept <code><a class="el" href="classTriangulationTraits__2.html">TriangulationTraits_2</a></code>.</td></tr>
    <tr><td class="paramname">Tds</td><td>is the triangulation data structure which must be a model of the concept <code><a class="elRef" href="../TDS_2/classTriangulationDataStructure__2.html">TriangulationDataStructure_2</a></code>. By default, the triangulation data structure is instantiated by <code><a class="elRef" href="../TDS_2/classCGAL_1_1Triangulation__data__structure__2.html">Triangulation_data_structure_2</a> &lt; <a class="el" href="classCGAL_1_1Triangulation__vertex__base__2.html" title="The class Triangulation_vertex_base_2 is the default model for the concept TriangulationVertexBase_2.">Triangulation_vertex_base_2</a>&lt;Gt&gt;, <a class="el" href="classCGAL_1_1Triangulation__face__base__2.html" title="The class Triangulation_face_base_2 is a model for the concept TriangulationFaceBase_2.">Triangulation_face_base_2</a>&lt;Gt&gt; &gt;</code>.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Traversal of the Triangulation</b><br>
</p>
<p>A triangulation can be seen as a container of faces and vertices. Therefore the triangulation provides several iterators and circulators that allow to traverse it completely or partially.</p>
<p><b>Traversal of the Convex Hull</b><br>
</p>
<p>Applied on the infinite vertex the above functions allow to visit the vertices on the convex hull and the infinite edges and faces. Note that a counterclockwise traversal of the vertices adjacent to the infinite vertex is a clockwise traversal of the convex hull.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2&lt;Traits, Tds&gt;</a> <a class="code hl_class" href="classCGAL_1_1Triangulation__2.html">Triangulation_2</a>;</div>
<div class="line"><a class="code hl_class" href="classCGAL_1_1Triangulation__2.html">Triangulation_2</a> t;</div>
<div class="line"><a class="code hl_typedef" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Triangulation_2::Face_handle</a> f;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_classRef" href="../Manual/classunspecified__type.html">Face_circulator</a> <a class="code hl_function" href="classCGAL_1_1Triangulation__2.html#a1ca68226e40c30304c4d54685a77a7ca">incident_faces</a>(t.<a class="code hl_function" href="classCGAL_1_1Triangulation__2.html#ae146d68059cd9d1430bafba2cbe25461">infinite_vertex</a>()) <span class="keyword">const</span>;</div>
<div class="line"><a class="code hl_classRef" href="../Manual/classunspecified__type.html">Face_circulator</a> <a class="code hl_function" href="classCGAL_1_1Triangulation__2.html#a1ca68226e40c30304c4d54685a77a7ca">incident_faces</a>(t.<a class="code hl_function" href="classCGAL_1_1Triangulation__2.html#ae146d68059cd9d1430bafba2cbe25461">infinite_vertex</a>(), f) <span class="keyword">const</span>;</div>
<div class="line"><a class="code hl_classRef" href="../Manual/classunspecified__type.html">Edge_circulator</a> <a class="code hl_function" href="classCGAL_1_1Triangulation__2.html#a1708a62dea4a40f63025848e4afaefa0">incident_edges</a>(t.<a class="code hl_function" href="classCGAL_1_1Triangulation__2.html#ae146d68059cd9d1430bafba2cbe25461">infinite_vertex</a>()) <span class="keyword">const</span>;</div>
<div class="line"><a class="code hl_classRef" href="../Manual/classunspecified__type.html">Edge_circulator</a> <a class="code hl_function" href="classCGAL_1_1Triangulation__2.html#a1708a62dea4a40f63025848e4afaefa0">incident_edges</a>(t.<a class="code hl_function" href="classCGAL_1_1Triangulation__2.html#ae146d68059cd9d1430bafba2cbe25461">infinite_vertex</a>(), f);</div>
<div class="line"><a class="code hl_classRef" href="../Manual/classunspecified__type.html">Vertex_circulator</a> <a class="code hl_function" href="classCGAL_1_1Triangulation__2.html#afebc0e18dc93bce4b62b1e06944a6921">incident_vertices</a>(t.<a class="code hl_function" href="classCGAL_1_1Triangulation__2.html#ae146d68059cd9d1430bafba2cbe25461">infinite_vertex</a>() v) ;</div>
<div class="line"><a class="code hl_classRef" href="../Manual/classunspecified__type.html">Vertex_circulator</a> <a class="code hl_function" href="classCGAL_1_1Triangulation__2.html#afebc0e18dc93bce4b62b1e06944a6921">incident_vertices</a>(t.<a class="code hl_function" href="classCGAL_1_1Triangulation__2.html#ae146d68059cd9d1430bafba2cbe25461">infinite_vertex</a>(), f) ;</div>
<div class="ttc" id="aclassCGAL_1_1Triangulation__2_html"><div class="ttname"><a href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a></div><div class="ttdoc">The class Triangulation_2 is the basic class designed to handle triangulations of set of points  in t...</div><div class="ttdef"><b>Definition:</b> Triangulation_2.h:170</div></div>
<div class="ttc" id="aclassCGAL_1_1Triangulation__2_html_a1708a62dea4a40f63025848e4afaefa0"><div class="ttname"><a href="classCGAL_1_1Triangulation__2.html#a1708a62dea4a40f63025848e4afaefa0">CGAL::Triangulation_2::incident_edges</a></div><div class="ttdeci">Edge_circulator incident_edges(Vertex_handle v) const</div><div class="ttdoc">Starts at an arbitrary edge incident to v.</div></div>
<div class="ttc" id="aclassCGAL_1_1Triangulation__2_html_a1ca68226e40c30304c4d54685a77a7ca"><div class="ttname"><a href="classCGAL_1_1Triangulation__2.html#a1ca68226e40c30304c4d54685a77a7ca">CGAL::Triangulation_2::incident_faces</a></div><div class="ttdeci">Face_circulator incident_faces(Vertex_handle v) const</div><div class="ttdoc">Starts at an arbitrary face incident to v.</div></div>
<div class="ttc" id="aclassCGAL_1_1Triangulation__2_html_aaa702188ca1171deece65da34c8f134b"><div class="ttname"><a href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">CGAL::Triangulation_2::Face_handle</a></div><div class="ttdeci">Tds::Face_handle Face_handle</div><div class="ttdoc">handle to a face.</div><div class="ttdef"><b>Definition:</b> Triangulation_2.h:266</div></div>
<div class="ttc" id="aclassCGAL_1_1Triangulation__2_html_ae146d68059cd9d1430bafba2cbe25461"><div class="ttname"><a href="classCGAL_1_1Triangulation__2.html#ae146d68059cd9d1430bafba2cbe25461">CGAL::Triangulation_2::infinite_vertex</a></div><div class="ttdeci">Vertex_handle infinite_vertex() const</div><div class="ttdoc">the infinite vertex.</div></div>
<div class="ttc" id="aclassCGAL_1_1Triangulation__2_html_afebc0e18dc93bce4b62b1e06944a6921"><div class="ttname"><a href="classCGAL_1_1Triangulation__2.html#afebc0e18dc93bce4b62b1e06944a6921">CGAL::Triangulation_2::incident_vertices</a></div><div class="ttdeci">Vertex_circulator incident_vertices(Vertex_handle v) const</div><div class="ttdoc">Starts at an arbitrary vertex incident to v.</div></div>
<div class="ttc" id="aclassunspecified__type_html"><div class="ttname"><a href="../Manual/classunspecified__type.html">unspecified_type</a></div></div>
</div><!-- fragment --><p><b>I/O</b><br>
</p>
<p>The I/O operators are defined for <code>iostream</code>. The format for the iostream is an internal format.</p>
<p>The information output in the <code>iostream</code> is:</p>
<ul>
<li>the number of vertices (including the infinite one), the number of faces (including infinite ones), and the dimension.</li>
<li>for each vertex (except the infinite vertex), the non combinatorial information stored in that vertex (point, etc.).</li>
<li>for each faces, the indices of its vertices and the non combinatorial information (if any) in this face.</li>
<li>for each face again the indices of the neighboring faces.</li>
</ul>
<p>The index of an item (vertex of face) is the rank of this item in the output order. When dimension \( &lt;\) 2, the same information is output for faces of maximal dimension instead of faces.</p>
<p><b>Implementation</b><br>
</p>
<p>Locate is implemented by a line walk from a vertex of the face given as optional parameter (or from a finite vertex of <code><a class="el" href="classCGAL_1_1Triangulation__2.html#a5758b4f843e2d884d759f278e154ed87" title="a face incident to the infinite vertex.">infinite_face()</a></code> if no optional parameter is given). It takes time \(O(n)\) in the worst case, but only \(O(\sqrt{n})\) on average if the vertices are distributed uniformly at random.</p>
<p>Insertion of a point is done by locating a face that contains the point, and then splitting this face. If the point falls outside the convex hull, the triangulation is restored by flips. Apart from the location, insertion takes a time time \(O(1)\). This bound is only an amortized bound for points located outside the convex hull.</p>
<p>Removal of a vertex is done by removing all adjacent triangles, and re-triangulating the hole. Removal takes time \(O(d^2)\) in the worst case, if \( d\) is the degree of the removed vertex, which is \(O(1)\) for a random vertex.</p>
<p>The face, edge, and vertex iterators on finite features are derived from their counterparts visiting all (finite and infinite) features which are themselves derived from the corresponding iterators of the triangulation data structure.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classTriangulationTraits__2.html">TriangulationTraits_2</a></code> </dd>
<dd>
<code><a class="elRef" href="../TDS_2/classTriangulationDataStructure__2.html">TriangulationDataStructure_2</a></code> </dd>
<dd>
<code><a class="elRef" href="../TDS_2/classTriangulationDataStructure__2_1_1Face.html">TriangulationDataStructure_2::Face</a></code> </dd>
<dd>
<code><a class="elRef" href="../TDS_2/classTriangulationDataStructure__2_1_1Vertex.html">TriangulationDataStructure_2::Vertex</a></code> </dd>
<dd>
<code><a class="elRef" href="../TDS_2/classCGAL_1_1Triangulation__data__structure__2.html">CGAL::Triangulation_data_structure_2</a>&lt;Vb,Fb&gt;</code> </dd>
<dd>
<code><a class="el" href="classCGAL_1_1Triangulation__vertex__base__2.html" title="The class Triangulation_vertex_base_2 is the default model for the concept TriangulationVertexBase_2.">CGAL::Triangulation_vertex_base_2</a>&lt;Traits&gt;</code> </dd>
<dd>
<code><a class="el" href="classCGAL_1_1Triangulation__face__base__2.html" title="The class Triangulation_face_base_2 is a model for the concept TriangulationFaceBase_2.">CGAL::Triangulation_face_base_2</a>&lt;Traits&gt;</code> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Triangulation_2_2adding_handles_8cpp-example.html#_a2">Triangulation_2/adding_handles.cpp</a>, <a class="el" href="Triangulation_2_2colored_face_8cpp-example.html#_a4">Triangulation_2/colored_face.cpp</a>, <a class="el" href="Triangulation_2_2draw_triangulation_2_8cpp-example.html#_a1">Triangulation_2/draw_triangulation_2.cpp</a>, <a class="el" href="Triangulation_2_2for_loop_2_8cpp-example.html#_a1">Triangulation_2/for_loop_2.cpp</a>, <a class="el" href="Triangulation_2_2low_dimensional_8cpp-example.html#_a1">Triangulation_2/low_dimensional.cpp</a>, and <a class="el" href="Triangulation_2_2triangulation_prog1_8cpp-example.html#_a1">Triangulation_2/triangulation_prog1.cpp</a>.</dd>
</dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:ac7351668deed7464974684ab3c7147ea"><td class="memItemLeft" align="right" valign="top">ostream &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#ac7351668deed7464974684ab3c7147ea">operator&lt;&lt;</a> (ostream &amp;os, const <a class="el" href="classCGAL_1_1Triangulation__2.html">Triangulation_2</a>&lt; Traits, Tds &gt; &amp;T)</td></tr>
<tr class="memdesc:ac7351668deed7464974684ab3c7147ea"><td class="mdescLeft"> </td><td class="mdescRight">Inserts the triangulation into the stream <code>os</code>.  <br></td></tr>
<tr class="separator:ac7351668deed7464974684ab3c7147ea"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8dc99f907cc125ce7a55024da5ddb4c0"><td class="memItemLeft" align="right" valign="top">istream &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#a8dc99f907cc125ce7a55024da5ddb4c0">operator&gt;&gt;</a> (istream &amp;is, const <a class="el" href="classCGAL_1_1Triangulation__2.html">Triangulation_2</a>&lt; Traits, Tds &gt; &amp;T)</td></tr>
<tr class="memdesc:a8dc99f907cc125ce7a55024da5ddb4c0"><td class="mdescLeft"> </td><td class="mdescRight">Reads a triangulation from stream <code>is</code> and assigns it to the triangulation.  <br></td></tr>
<tr class="separator:a8dc99f907cc125ce7a55024da5ddb4c0"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Handles, Iterators, and Circulators</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>The vertices and faces of the triangulations are accessed through handles, iterators and circulators.</p>
<p>The handles are models of the concept <code><a class="elRef" href="../Circulator/classHandle.html">Handle</a></code> which basically offers the two dereference operators and <code>-&gt;</code>. The handles are also model of the concepts <code><a class="elRef" href="../Manual/classLessThanComparable.html">LessThanComparable</a></code> and <code><a class="elRef" href="../STL_Extension/classHashable.html">Hashable</a></code>, that is they can be used as keys in containers such as <code>std::map</code> and <code>boost::unordered_map</code>. The iterators and circulators are all bidirectional and non-mutable. The circulators and iterators are convertible to handles with the same value type, so that whenever a handle appear in the parameter list of a function, an appropriate iterator or circulator can be passed as well.</p>
<p>The edges of the triangulation can also be visited through iterators and circulators, the edge circulators and iterators are also bidirectional and non mutable.</p>
<p>In the following, we called <em>infinite</em> any face or edge incident to the infinite vertex and the infinite vertex itself. Any other feature (face, edge or vertex) of the triangulation is said to be <em>finite</em>. Some iterators (the <code>All</code> iterators ) allows to visit finite or infinite feature while others (the <code>Finite</code> iterators) visit only finite features. Circulators visit infinite features as well as finite ones. The triangulation class also defines the following enum type to specify which case occurs when locating a point in the triangulation.</p>
<p>In order to write C++ 11 <code>for</code>-loops we provide range types. </p>
</td></tr>
<tr class="memitem:a22dbae3b466c50924759754de5865db6"><td class="memItemLeft" align="right" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#a22dbae3b466c50924759754de5865db6">Locate_type</a> { <br>
  <a class="el" href="classCGAL_1_1Triangulation__2.html#a22dbae3b466c50924759754de5865db6a4fc5b644a7c38197036955ba1662afe5">VERTEX</a> =0
, <a class="el" href="classCGAL_1_1Triangulation__2.html#a22dbae3b466c50924759754de5865db6a5111882933f6615f618c8900e2bc6acf">EDGE</a>
, <a class="el" href="classCGAL_1_1Triangulation__2.html#a22dbae3b466c50924759754de5865db6a937da59ce47b08cfc0d452901e6c3625">FACE</a>
, <a class="el" href="classCGAL_1_1Triangulation__2.html#a22dbae3b466c50924759754de5865db6afd690e18b1d2857068085d771fc354d4">OUTSIDE_CONVEX_HULL</a>
, <br>
  <a class="el" href="classCGAL_1_1Triangulation__2.html#a22dbae3b466c50924759754de5865db6ae8b775f120094d9b0a6871f53446184f">OUTSIDE_AFFINE_HULL</a>
<br>
 }</td></tr>
<tr class="memdesc:a22dbae3b466c50924759754de5865db6"><td class="mdescLeft"> </td><td class="mdescRight">specifies which case occurs when locating a point in the triangulation.  <a href="classCGAL_1_1Triangulation__2.html#a22dbae3b466c50924759754de5865db6">More...</a><br></td></tr>
<tr class="separator:a22dbae3b466c50924759754de5865db6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa7993454afb8684835b6ca96731a9eca"><td class="memItemLeft" align="right" valign="top"><a id="aa7993454afb8684835b6ca96731a9eca" name="aa7993454afb8684835b6ca96731a9eca"></a>
typedef Tds::Vertex_handle </td><td class="memItemRight" valign="bottom"><b>Vertex_handle</b></td></tr>
<tr class="memdesc:aa7993454afb8684835b6ca96731a9eca"><td class="mdescLeft"> </td><td class="mdescRight">handle to a vertex. <br></td></tr>
<tr class="separator:aa7993454afb8684835b6ca96731a9eca"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aaa702188ca1171deece65da34c8f134b"><td class="memItemLeft" align="right" valign="top"><a id="aaa702188ca1171deece65da34c8f134b" name="aaa702188ca1171deece65da34c8f134b"></a>
typedef Tds::Face_handle </td><td class="memItemRight" valign="bottom"><b>Face_handle</b></td></tr>
<tr class="memdesc:aaa702188ca1171deece65da34c8f134b"><td class="mdescLeft"> </td><td class="mdescRight">handle to a face. <br></td></tr>
<tr class="separator:aaa702188ca1171deece65da34c8f134b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae5363996414e60613b556b14a9f87891"><td class="memItemLeft" align="right" valign="top"><a id="ae5363996414e60613b556b14a9f87891" name="ae5363996414e60613b556b14a9f87891"></a>
typedef Tds::Face_iterator </td><td class="memItemRight" valign="bottom"><b>All_faces_iterator</b></td></tr>
<tr class="memdesc:ae5363996414e60613b556b14a9f87891"><td class="mdescLeft"> </td><td class="mdescRight">iterator over all faces. <br></td></tr>
<tr class="separator:ae5363996414e60613b556b14a9f87891"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5b63aff651ae1e485ea2c7d20421b4b9"><td class="memItemLeft" align="right" valign="top"><a id="a5b63aff651ae1e485ea2c7d20421b4b9" name="a5b63aff651ae1e485ea2c7d20421b4b9"></a>
typedef Tds::Edge_iterator </td><td class="memItemRight" valign="bottom"><b>All_edges_iterator</b></td></tr>
<tr class="memdesc:a5b63aff651ae1e485ea2c7d20421b4b9"><td class="mdescLeft"> </td><td class="mdescRight">iterator over all edges. <br></td></tr>
<tr class="separator:a5b63aff651ae1e485ea2c7d20421b4b9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1d4600a9428fed798c112964ba57d9f1"><td class="memItemLeft" align="right" valign="top"><a id="a1d4600a9428fed798c112964ba57d9f1" name="a1d4600a9428fed798c112964ba57d9f1"></a>
typedef Tds::Vertex_iterator </td><td class="memItemRight" valign="bottom"><b>All_vertices_iterator</b></td></tr>
<tr class="memdesc:a1d4600a9428fed798c112964ba57d9f1"><td class="mdescLeft"> </td><td class="mdescRight">iterator over all vertices. <br></td></tr>
<tr class="separator:a1d4600a9428fed798c112964ba57d9f1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a84923815e1cfca537c93cee97c0ed24f"><td class="memItemLeft" align="right" valign="top"><a id="a84923815e1cfca537c93cee97c0ed24f" name="a84923815e1cfca537c93cee97c0ed24f"></a>
typedef <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> </td><td class="memItemRight" valign="bottom"><b>Finite_faces_iterator</b></td></tr>
<tr class="memdesc:a84923815e1cfca537c93cee97c0ed24f"><td class="mdescLeft"> </td><td class="mdescRight">iterator over finite faces. <br></td></tr>
<tr class="separator:a84923815e1cfca537c93cee97c0ed24f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af70ca2702b9de4ae712b953f6a94b9a2"><td class="memItemLeft" align="right" valign="top"><a id="af70ca2702b9de4ae712b953f6a94b9a2" name="af70ca2702b9de4ae712b953f6a94b9a2"></a>
typedef <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> </td><td class="memItemRight" valign="bottom"><b>Finite_edges_iterator</b></td></tr>
<tr class="memdesc:af70ca2702b9de4ae712b953f6a94b9a2"><td class="mdescLeft"> </td><td class="mdescRight">iterator over finite edges. <br></td></tr>
<tr class="separator:af70ca2702b9de4ae712b953f6a94b9a2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3dfacc0bd86f726c637b7ff86f404f84"><td class="memItemLeft" align="right" valign="top"><a id="a3dfacc0bd86f726c637b7ff86f404f84" name="a3dfacc0bd86f726c637b7ff86f404f84"></a>
typedef <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> </td><td class="memItemRight" valign="bottom"><b>Finite_vertices_iterator</b></td></tr>
<tr class="memdesc:a3dfacc0bd86f726c637b7ff86f404f84"><td class="mdescLeft"> </td><td class="mdescRight">iterator over finite vertices. <br></td></tr>
<tr class="separator:a3dfacc0bd86f726c637b7ff86f404f84"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a06ec87f55894738972350f631f6dc1fe"><td class="memItemLeft" align="right" valign="top"><a id="a06ec87f55894738972350f631f6dc1fe" name="a06ec87f55894738972350f631f6dc1fe"></a>
typedef <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> </td><td class="memItemRight" valign="bottom"><b>Point_iterator</b></td></tr>
<tr class="memdesc:a06ec87f55894738972350f631f6dc1fe"><td class="mdescLeft"> </td><td class="mdescRight">iterator over the points corresponding to the finite vertices of the triangulation. <br></td></tr>
<tr class="separator:a06ec87f55894738972350f631f6dc1fe"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a40f06313bd485eed99b6ba119da98bb5"><td class="memItemLeft" align="right" valign="top"><a id="a40f06313bd485eed99b6ba119da98bb5" name="a40f06313bd485eed99b6ba119da98bb5"></a>
typedef <a class="elRef" href="../STL_Extension/classCGAL_1_1Iterator__range.html">Iterator_range</a>&lt; <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> &gt; </td><td class="memItemRight" valign="bottom"><b>All_face_handles</b></td></tr>
<tr class="memdesc:a40f06313bd485eed99b6ba119da98bb5"><td class="mdescLeft"> </td><td class="mdescRight">range type for iterating over all faces (including infinite faces), with a nested type <code>iterator</code> that has as value type <code>Face_handle</code>. <br></td></tr>
<tr class="separator:a40f06313bd485eed99b6ba119da98bb5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aab68c0408fce72a3294d76f6ded2ea56"><td class="memItemLeft" align="right" valign="top"><a id="aab68c0408fce72a3294d76f6ded2ea56" name="aab68c0408fce72a3294d76f6ded2ea56"></a>
typedef <a class="elRef" href="../STL_Extension/classCGAL_1_1Iterator__range.html">Iterator_range</a>&lt; <a class="el" href="classCGAL_1_1Triangulation__2.html#a5b63aff651ae1e485ea2c7d20421b4b9">All_edges_iterator</a> &gt; </td><td class="memItemRight" valign="bottom"><b>All_edges</b></td></tr>
<tr class="memdesc:aab68c0408fce72a3294d76f6ded2ea56"><td class="mdescLeft"> </td><td class="mdescRight">range type for iterating over all edges (including infinite ones). <br></td></tr>
<tr class="separator:aab68c0408fce72a3294d76f6ded2ea56"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aaed9fdd0b481d9ec138548fb243752ab"><td class="memItemLeft" align="right" valign="top"><a id="aaed9fdd0b481d9ec138548fb243752ab" name="aaed9fdd0b481d9ec138548fb243752ab"></a>
typedef <a class="elRef" href="../STL_Extension/classCGAL_1_1Iterator__range.html">Iterator_range</a>&lt; <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> &gt; </td><td class="memItemRight" valign="bottom"><b>All_vertex_handles</b></td></tr>
<tr class="memdesc:aaed9fdd0b481d9ec138548fb243752ab"><td class="mdescLeft"> </td><td class="mdescRight">range type for iterating over all vertices (including the infinite vertex), with a nested type <code>iterator</code> that has as value type <code>Vertex_handle</code>. <br></td></tr>
<tr class="separator:aaed9fdd0b481d9ec138548fb243752ab"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae89fd1a46ae755c79ac650fc41f6d3dd"><td class="memItemLeft" align="right" valign="top"><a id="ae89fd1a46ae755c79ac650fc41f6d3dd" name="ae89fd1a46ae755c79ac650fc41f6d3dd"></a>
typedef <a class="elRef" href="../STL_Extension/classCGAL_1_1Iterator__range.html">Iterator_range</a>&lt; <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> &gt; </td><td class="memItemRight" valign="bottom"><b>Finite_face_handles</b></td></tr>
<tr class="memdesc:ae89fd1a46ae755c79ac650fc41f6d3dd"><td class="mdescLeft"> </td><td class="mdescRight">range type for iterating over finite faces, with a nested type <code>iterator</code> that has as value type <code>Face_handle</code>. <br></td></tr>
<tr class="separator:ae89fd1a46ae755c79ac650fc41f6d3dd"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af7f5d22e7244c73be90bec59a502e7aa"><td class="memItemLeft" align="right" valign="top"><a id="af7f5d22e7244c73be90bec59a502e7aa" name="af7f5d22e7244c73be90bec59a502e7aa"></a>
typedef <a class="elRef" href="../STL_Extension/classCGAL_1_1Iterator__range.html">Iterator_range</a>&lt; <a class="el" href="classCGAL_1_1Triangulation__2.html#af70ca2702b9de4ae712b953f6a94b9a2">Finite_edges_iterator</a> &gt; </td><td class="memItemRight" valign="bottom"><b>Finite_edges</b></td></tr>
<tr class="memdesc:af7f5d22e7244c73be90bec59a502e7aa"><td class="mdescLeft"> </td><td class="mdescRight">range type for iterating over finite edges. <br></td></tr>
<tr class="separator:af7f5d22e7244c73be90bec59a502e7aa"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a07f0b236b51b0e8a69512561dc12734a"><td class="memItemLeft" align="right" valign="top"><a id="a07f0b236b51b0e8a69512561dc12734a" name="a07f0b236b51b0e8a69512561dc12734a"></a>
typedef <a class="elRef" href="../STL_Extension/classCGAL_1_1Iterator__range.html">Iterator_range</a>&lt; <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> &gt; </td><td class="memItemRight" valign="bottom"><b>Finite_vertex_handles</b></td></tr>
<tr class="memdesc:a07f0b236b51b0e8a69512561dc12734a"><td class="mdescLeft"> </td><td class="mdescRight">range type for iterating over finite vertices, with a nested type <code>iterator</code> that has as value type <code>Vertex_handle</code>. <br></td></tr>
<tr class="separator:a07f0b236b51b0e8a69512561dc12734a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a55aff11c6b56078d7384374a898bc1b9"><td class="memItemLeft" align="right" valign="top"><a id="a55aff11c6b56078d7384374a898bc1b9" name="a55aff11c6b56078d7384374a898bc1b9"></a>
typedef <a class="elRef" href="../STL_Extension/classCGAL_1_1Iterator__range.html">Iterator_range</a>&lt; <a class="el" href="classCGAL_1_1Triangulation__2.html#a06ec87f55894738972350f631f6dc1fe">Point_iterator</a> &gt; </td><td class="memItemRight" valign="bottom"><b>Points</b></td></tr>
<tr class="memdesc:a55aff11c6b56078d7384374a898bc1b9"><td class="mdescLeft"> </td><td class="mdescRight">range type for iterating over the points of the finite vertices. <br></td></tr>
<tr class="separator:a55aff11c6b56078d7384374a898bc1b9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad720b1a9adc835ed1a27c228eea1e36c"><td class="memItemLeft" align="right" valign="top"><a id="ad720b1a9adc835ed1a27c228eea1e36c" name="ad720b1a9adc835ed1a27c228eea1e36c"></a>
typedef <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> </td><td class="memItemRight" valign="bottom"><b>Line_face_circulator</b></td></tr>
<tr class="memdesc:ad720b1a9adc835ed1a27c228eea1e36c"><td class="mdescLeft"> </td><td class="mdescRight">circulator over all faces intersected by a line. <br></td></tr>
<tr class="separator:ad720b1a9adc835ed1a27c228eea1e36c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1bda2ab92ccf638bb22fc223ae281b96"><td class="memItemLeft" align="right" valign="top"><a id="a1bda2ab92ccf638bb22fc223ae281b96" name="a1bda2ab92ccf638bb22fc223ae281b96"></a>
typedef <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> </td><td class="memItemRight" valign="bottom"><b>Face_circulator</b></td></tr>
<tr class="memdesc:a1bda2ab92ccf638bb22fc223ae281b96"><td class="mdescLeft"> </td><td class="mdescRight">circulator over all faces incident to a given vertex. <br></td></tr>
<tr class="separator:a1bda2ab92ccf638bb22fc223ae281b96"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a997ed97a0ac906a0342ad18c91a1ec81"><td class="memItemLeft" align="right" valign="top"><a id="a997ed97a0ac906a0342ad18c91a1ec81" name="a997ed97a0ac906a0342ad18c91a1ec81"></a>
typedef <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> </td><td class="memItemRight" valign="bottom"><b>Edge_circulator</b></td></tr>
<tr class="memdesc:a997ed97a0ac906a0342ad18c91a1ec81"><td class="mdescLeft"> </td><td class="mdescRight">circulator over all edges incident to a given vertex. <br></td></tr>
<tr class="separator:a997ed97a0ac906a0342ad18c91a1ec81"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ade901d47c7c422f7978adf3ac0188a9d"><td class="memItemLeft" align="right" valign="top"><a id="ade901d47c7c422f7978adf3ac0188a9d" name="ade901d47c7c422f7978adf3ac0188a9d"></a>
typedef <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> </td><td class="memItemRight" valign="bottom"><b>Vertex_circulator</b></td></tr>
<tr class="memdesc:ade901d47c7c422f7978adf3ac0188a9d"><td class="mdescLeft"> </td><td class="mdescRight">circulator over all vertices incident to a given vertex. <br></td></tr>
<tr class="separator:ade901d47c7c422f7978adf3ac0188a9d"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Types</h2></td></tr>
<tr class="memitem:a94f47e3c6bdf5e36ae51180bcd013ad6"><td class="memItemLeft" align="right" valign="top"><a id="a94f47e3c6bdf5e36ae51180bcd013ad6" name="a94f47e3c6bdf5e36ae51180bcd013ad6"></a>
typedef Traits </td><td class="memItemRight" valign="bottom"><b>Geom_traits</b></td></tr>
<tr class="memdesc:a94f47e3c6bdf5e36ae51180bcd013ad6"><td class="mdescLeft"> </td><td class="mdescRight">the traits class. <br></td></tr>
<tr class="separator:a94f47e3c6bdf5e36ae51180bcd013ad6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:addbcd86ae5679a10363f46080159d00d"><td class="memItemLeft" align="right" valign="top"><a id="addbcd86ae5679a10363f46080159d00d" name="addbcd86ae5679a10363f46080159d00d"></a>
typedef Tds </td><td class="memItemRight" valign="bottom"><b>Triangulation_data_structure</b></td></tr>
<tr class="memdesc:addbcd86ae5679a10363f46080159d00d"><td class="mdescLeft"> </td><td class="mdescRight">the triangulation data structure type. <br></td></tr>
<tr class="separator:addbcd86ae5679a10363f46080159d00d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adf800f903a06c19d07d27afb2927fc71"><td class="memItemLeft" align="right" valign="top"><a id="adf800f903a06c19d07d27afb2927fc71" name="adf800f903a06c19d07d27afb2927fc71"></a>
typedef Traits::Point_2 </td><td class="memItemRight" valign="bottom"><b>Point</b></td></tr>
<tr class="memdesc:adf800f903a06c19d07d27afb2927fc71"><td class="mdescLeft"> </td><td class="mdescRight">the point type. <br></td></tr>
<tr class="separator:adf800f903a06c19d07d27afb2927fc71"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae7b5594c15ef61394d76826e1fc1e8e6"><td class="memItemLeft" align="right" valign="top"><a id="ae7b5594c15ef61394d76826e1fc1e8e6" name="ae7b5594c15ef61394d76826e1fc1e8e6"></a>
typedef Traits::Segment_2 </td><td class="memItemRight" valign="bottom"><b>Segment</b></td></tr>
<tr class="memdesc:ae7b5594c15ef61394d76826e1fc1e8e6"><td class="mdescLeft"> </td><td class="mdescRight">the segment type. <br></td></tr>
<tr class="separator:ae7b5594c15ef61394d76826e1fc1e8e6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a48984e6735c075b17d7a956cb396d1f5"><td class="memItemLeft" align="right" valign="top"><a id="a48984e6735c075b17d7a956cb396d1f5" name="a48984e6735c075b17d7a956cb396d1f5"></a>
typedef Traits::Triangle_2 </td><td class="memItemRight" valign="bottom"><b>Triangle</b></td></tr>
<tr class="memdesc:a48984e6735c075b17d7a956cb396d1f5"><td class="mdescLeft"> </td><td class="mdescRight">the triangle type. <br></td></tr>
<tr class="separator:a48984e6735c075b17d7a956cb396d1f5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af48b3f6c165d50c74fe67a75caec129a"><td class="memItemLeft" align="right" valign="top"><a id="af48b3f6c165d50c74fe67a75caec129a" name="af48b3f6c165d50c74fe67a75caec129a"></a>
typedef Tds::Vertex </td><td class="memItemRight" valign="bottom"><b>Vertex</b></td></tr>
<tr class="memdesc:af48b3f6c165d50c74fe67a75caec129a"><td class="mdescLeft"> </td><td class="mdescRight">the vertex type. <br></td></tr>
<tr class="separator:af48b3f6c165d50c74fe67a75caec129a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6c6a38b0ce694a47c2323834107fa758"><td class="memItemLeft" align="right" valign="top"><a id="a6c6a38b0ce694a47c2323834107fa758" name="a6c6a38b0ce694a47c2323834107fa758"></a>
typedef Tds::Face </td><td class="memItemRight" valign="bottom"><b>Face</b></td></tr>
<tr class="memdesc:a6c6a38b0ce694a47c2323834107fa758"><td class="mdescLeft"> </td><td class="mdescRight">the face type. <br></td></tr>
<tr class="separator:a6c6a38b0ce694a47c2323834107fa758"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad28c6e0e0e65b8aaecb1ae76d8744b33"><td class="memItemLeft" align="right" valign="top"><a id="ad28c6e0e0e65b8aaecb1ae76d8744b33" name="ad28c6e0e0e65b8aaecb1ae76d8744b33"></a>
typedef Tds::Edge </td><td class="memItemRight" valign="bottom"><b>Edge</b></td></tr>
<tr class="memdesc:ad28c6e0e0e65b8aaecb1ae76d8744b33"><td class="mdescLeft"> </td><td class="mdescRight">the edge type. <br></td></tr>
<tr class="separator:ad28c6e0e0e65b8aaecb1ae76d8744b33"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa7b0b96c9ed11cab337313f34cd96a59"><td class="memItemLeft" align="right" valign="top"><a id="aa7b0b96c9ed11cab337313f34cd96a59" name="aa7b0b96c9ed11cab337313f34cd96a59"></a>
typedef Tds::size_type </td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="memdesc:aa7b0b96c9ed11cab337313f34cd96a59"><td class="mdescLeft"> </td><td class="mdescRight">Size type (an unsigned integral type). <br></td></tr>
<tr class="separator:aa7b0b96c9ed11cab337313f34cd96a59"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae837aea43417f936cefb715765d332e1"><td class="memItemLeft" align="right" valign="top"><a id="ae837aea43417f936cefb715765d332e1" name="ae837aea43417f936cefb715765d332e1"></a>
typedef Tds::difference_type </td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr class="memdesc:ae837aea43417f936cefb715765d332e1"><td class="mdescLeft"> </td><td class="mdescRight">Difference type (a signed integral type). <br></td></tr>
<tr class="separator:ae837aea43417f936cefb715765d332e1"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Creation</h2></td></tr>
<tr class="memitem:a97deb44f4edfb6baa30c12a22f928dc7"><td class="memItemLeft" align="right" valign="top"><a id="a97deb44f4edfb6baa30c12a22f928dc7" name="a97deb44f4edfb6baa30c12a22f928dc7"></a>
 </td><td class="memItemRight" valign="bottom"><b>Triangulation_2</b> (const Traits &amp;gt=Traits())</td></tr>
<tr class="memdesc:a97deb44f4edfb6baa30c12a22f928dc7"><td class="mdescLeft"> </td><td class="mdescRight">Introduces an empty triangulation. <br></td></tr>
<tr class="separator:a97deb44f4edfb6baa30c12a22f928dc7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6e43f49405b43057d1b911a9f6e39404"><td class="memItemLeft" align="right" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#a6e43f49405b43057d1b911a9f6e39404">Triangulation_2</a> (const <a class="el" href="classCGAL_1_1Triangulation__2.html">Triangulation_2</a> &amp;tr)</td></tr>
<tr class="memdesc:a6e43f49405b43057d1b911a9f6e39404"><td class="mdescLeft"> </td><td class="mdescRight">Copy constructor.  <br></td></tr>
<tr class="separator:a6e43f49405b43057d1b911a9f6e39404"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6cfa7d3aaa375a25d217858b49e2eb07"><td class="memTemplParams" colspan="2"><a id="a6cfa7d3aaa375a25d217858b49e2eb07" name="a6cfa7d3aaa375a25d217858b49e2eb07"></a>
template&lt;class <a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> &gt; </td></tr>
<tr class="memitem:a6cfa7d3aaa375a25d217858b49e2eb07"><td class="memTemplItemLeft" align="right" valign="top"> </td><td class="memTemplItemRight" valign="bottom"><b>Triangulation_2</b> (<a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> first, <a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> last, const Traits &amp;gt=Traits())</td></tr>
<tr class="memdesc:a6cfa7d3aaa375a25d217858b49e2eb07"><td class="mdescLeft"> </td><td class="mdescRight">Equivalent to constructing an empty triangulation with the optional traits class argument and calling insert(first,last). <br></td></tr>
<tr class="separator:a6cfa7d3aaa375a25d217858b49e2eb07"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a40701ad345813f8df044fd197d3c9d96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__2.html">Triangulation_2</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#a40701ad345813f8df044fd197d3c9d96">operator=</a> (const <a class="el" href="classCGAL_1_1Triangulation__2.html">Triangulation_2</a>&lt; Traits, Tds &gt; &amp;tr)</td></tr>
<tr class="memdesc:a40701ad345813f8df044fd197d3c9d96"><td class="mdescLeft"> </td><td class="mdescRight">Assignment.  <br></td></tr>
<tr class="separator:a40701ad345813f8df044fd197d3c9d96"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1788d6ffa3f5986b2b07e7e0b48a2ffc"><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#a1788d6ffa3f5986b2b07e7e0b48a2ffc">swap</a> (<a class="el" href="classCGAL_1_1Triangulation__2.html">Triangulation_2</a> &amp;tr)</td></tr>
<tr class="memdesc:a1788d6ffa3f5986b2b07e7e0b48a2ffc"><td class="mdescLeft"> </td><td class="mdescRight">The triangulations <code>tr</code> and <code>*this</code> are swapped.  <br></td></tr>
<tr class="separator:a1788d6ffa3f5986b2b07e7e0b48a2ffc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a031db533d1f567a2c7b0e9736f85a4f1"><td class="memItemLeft" align="right" valign="top"><a id="a031db533d1f567a2c7b0e9736f85a4f1" name="a031db533d1f567a2c7b0e9736f85a4f1"></a>
void </td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="memdesc:a031db533d1f567a2c7b0e9736f85a4f1"><td class="mdescLeft"> </td><td class="mdescRight">Deletes all faces and finite vertices resulting in an empty triangulation. <br></td></tr>
<tr class="separator:a031db533d1f567a2c7b0e9736f85a4f1"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Access Functions</h2></td></tr>
<tr class="memitem:a644f9730fdece05c0e951201e0012805"><td class="memItemLeft" align="right" valign="top"><a id="a644f9730fdece05c0e951201e0012805" name="a644f9730fdece05c0e951201e0012805"></a>
int </td><td class="memItemRight" valign="bottom"><b>dimension</b> () const</td></tr>
<tr class="memdesc:a644f9730fdece05c0e951201e0012805"><td class="mdescLeft"> </td><td class="mdescRight">Returns the dimension of the convex hull. <br></td></tr>
<tr class="separator:a644f9730fdece05c0e951201e0012805"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abb274869c3eac8fb775702bf68c4e8f1"><td class="memItemLeft" align="right" valign="top"><a id="abb274869c3eac8fb775702bf68c4e8f1" name="abb274869c3eac8fb775702bf68c4e8f1"></a>
<a class="el" href="classCGAL_1_1Triangulation__2.html#aa7b0b96c9ed11cab337313f34cd96a59">size_type</a> </td><td class="memItemRight" valign="bottom"><b>number_of_vertices</b> () const</td></tr>
<tr class="memdesc:abb274869c3eac8fb775702bf68c4e8f1"><td class="mdescLeft"> </td><td class="mdescRight">Returns the number of finite vertices. <br></td></tr>
<tr class="separator:abb274869c3eac8fb775702bf68c4e8f1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab18fcf7127c007253348fcfb37b67df4"><td class="memItemLeft" align="right" valign="top"><a id="ab18fcf7127c007253348fcfb37b67df4" name="ab18fcf7127c007253348fcfb37b67df4"></a>
<a class="el" href="classCGAL_1_1Triangulation__2.html#aa7b0b96c9ed11cab337313f34cd96a59">size_type</a> </td><td class="memItemRight" valign="bottom"><b>number_of_faces</b> () const</td></tr>
<tr class="memdesc:ab18fcf7127c007253348fcfb37b67df4"><td class="mdescLeft"> </td><td class="mdescRight">Returns the number of finite faces. <br></td></tr>
<tr class="separator:ab18fcf7127c007253348fcfb37b67df4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5758b4f843e2d884d759f278e154ed87"><td class="memItemLeft" align="right" valign="top"><a id="a5758b4f843e2d884d759f278e154ed87" name="a5758b4f843e2d884d759f278e154ed87"></a>
<a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> </td><td class="memItemRight" valign="bottom"><b>infinite_face</b> () const</td></tr>
<tr class="memdesc:a5758b4f843e2d884d759f278e154ed87"><td class="mdescLeft"> </td><td class="mdescRight">a face incident to the infinite vertex. <br></td></tr>
<tr class="separator:a5758b4f843e2d884d759f278e154ed87"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae146d68059cd9d1430bafba2cbe25461"><td class="memItemLeft" align="right" valign="top"><a id="ae146d68059cd9d1430bafba2cbe25461" name="ae146d68059cd9d1430bafba2cbe25461"></a>
<a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> </td><td class="memItemRight" valign="bottom"><b>infinite_vertex</b> () const</td></tr>
<tr class="memdesc:ae146d68059cd9d1430bafba2cbe25461"><td class="mdescLeft"> </td><td class="mdescRight">the infinite vertex. <br></td></tr>
<tr class="separator:ae146d68059cd9d1430bafba2cbe25461"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a78d0a3bd3637897ab1abe06389899b63"><td class="memItemLeft" align="right" valign="top"><a id="a78d0a3bd3637897ab1abe06389899b63" name="a78d0a3bd3637897ab1abe06389899b63"></a>
<a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> </td><td class="memItemRight" valign="bottom"><b>finite_vertex</b> () const</td></tr>
<tr class="memdesc:a78d0a3bd3637897ab1abe06389899b63"><td class="mdescLeft"> </td><td class="mdescRight">a vertex distinct from the infinite vertex. <br></td></tr>
<tr class="separator:a78d0a3bd3637897ab1abe06389899b63"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4e201a26ae4f2593c8dd2607b333ff48"><td class="memItemLeft" align="right" valign="top"><a id="a4e201a26ae4f2593c8dd2607b333ff48" name="a4e201a26ae4f2593c8dd2607b333ff48"></a>
const <a class="el" href="classCGAL_1_1Triangulation__2.html#a94f47e3c6bdf5e36ae51180bcd013ad6">Geom_traits</a> &amp; </td><td class="memItemRight" valign="bottom"><b>geom_traits</b> () const</td></tr>
<tr class="memdesc:a4e201a26ae4f2593c8dd2607b333ff48"><td class="mdescLeft"> </td><td class="mdescRight">Returns a const reference to the triangulation traits object. <br></td></tr>
<tr class="separator:a4e201a26ae4f2593c8dd2607b333ff48"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6de738928cfecde1ae15bcbac16327ac"><td class="memItemLeft" align="right" valign="top"><a id="a6de738928cfecde1ae15bcbac16327ac" name="a6de738928cfecde1ae15bcbac16327ac"></a>
const <a class="elRef" href="../TDS_2/classTriangulationDataStructure__2.html">TriangulationDataStructure_2</a> &amp; </td><td class="memItemRight" valign="bottom"><b>tds</b> () const</td></tr>
<tr class="memdesc:a6de738928cfecde1ae15bcbac16327ac"><td class="mdescLeft"> </td><td class="mdescRight">Returns a const reference to the triangulation data structure. <br></td></tr>
<tr class="separator:a6de738928cfecde1ae15bcbac16327ac"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Non const access</h2></td></tr>
<tr><td class="ititle" colspan="2"><dl class="section attention"><dt>Attention</dt><dd>The responsibility of keeping a valid triangulation belongs to the user when using advanced operations allowing a direct manipulation of the <code>tds</code>. This method is mainly a help for users implementing their own triangulation algorithms. </dd></dl>
</td></tr>
<tr class="memitem:a9a215e702f4b5a03d77cc8c5e27a6b54"><td class="memItemLeft" align="right" valign="top"><a id="a9a215e702f4b5a03d77cc8c5e27a6b54" name="a9a215e702f4b5a03d77cc8c5e27a6b54"></a>
<a class="elRef" href="../TDS_2/classTriangulationDataStructure__2.html">TriangulationDataStructure_2</a> &amp; </td><td class="memItemRight" valign="bottom"><b>tds</b> ()</td></tr>
<tr class="memdesc:a9a215e702f4b5a03d77cc8c5e27a6b54"><td class="mdescLeft"> </td><td class="mdescRight">Returns a reference to the triangulation data structure. <br></td></tr>
<tr class="separator:a9a215e702f4b5a03d77cc8c5e27a6b54"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Predicates</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>The class <code><a class="el" href="classCGAL_1_1Triangulation__2.html" title="The class Triangulation_2 is the basic class designed to handle triangulations of set of points  in t...">Triangulation_2</a></code> provides methods to test the finite or infinite character of any feature, and also methods to test the presence in the triangulation of a particular feature (edge or face). </p>
</td></tr>
<tr class="memitem:acf8596038ef09d0d3ffcba99e912d1da"><td class="memItemLeft" align="right" valign="top"><a id="acf8596038ef09d0d3ffcba99e912d1da" name="acf8596038ef09d0d3ffcba99e912d1da"></a>
bool </td><td class="memItemRight" valign="bottom"><b>is_infinite</b> (<a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> v) const</td></tr>
<tr class="memdesc:acf8596038ef09d0d3ffcba99e912d1da"><td class="mdescLeft"> </td><td class="mdescRight"><code>true</code> iff <code>v</code> is the infinite vertex. <br></td></tr>
<tr class="separator:acf8596038ef09d0d3ffcba99e912d1da"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:acf8e2ef548683138d8766b6c89794fbb"><td class="memItemLeft" align="right" valign="top"><a id="acf8e2ef548683138d8766b6c89794fbb" name="acf8e2ef548683138d8766b6c89794fbb"></a>
bool </td><td class="memItemRight" valign="bottom"><b>is_infinite</b> (<a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> f) const</td></tr>
<tr class="memdesc:acf8e2ef548683138d8766b6c89794fbb"><td class="mdescLeft"> </td><td class="mdescRight"><code>true</code> iff face <code>f</code> is infinite. <br></td></tr>
<tr class="separator:acf8e2ef548683138d8766b6c89794fbb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8009eb06cbe50a3fa1358d203a1fa924"><td class="memItemLeft" align="right" valign="top"><a id="a8009eb06cbe50a3fa1358d203a1fa924" name="a8009eb06cbe50a3fa1358d203a1fa924"></a>
bool </td><td class="memItemRight" valign="bottom"><b>is_infinite</b> (<a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> f, int i) const</td></tr>
<tr class="memdesc:a8009eb06cbe50a3fa1358d203a1fa924"><td class="mdescLeft"> </td><td class="mdescRight"><code>true</code> iff edge <code>(f,i)</code> is infinite. <br></td></tr>
<tr class="separator:a8009eb06cbe50a3fa1358d203a1fa924"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac7519fb75001a53abba7e8d9127d22c5"><td class="memItemLeft" align="right" valign="top"><a id="ac7519fb75001a53abba7e8d9127d22c5" name="ac7519fb75001a53abba7e8d9127d22c5"></a>
bool </td><td class="memItemRight" valign="bottom"><b>is_infinite</b> (<a class="el" href="classCGAL_1_1Triangulation__2.html#ad28c6e0e0e65b8aaecb1ae76d8744b33">Edge</a> e) const</td></tr>
<tr class="memdesc:ac7519fb75001a53abba7e8d9127d22c5"><td class="mdescLeft"> </td><td class="mdescRight"><code>true</code> iff edge <code>e</code> is infinite. <br></td></tr>
<tr class="separator:ac7519fb75001a53abba7e8d9127d22c5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae4becba370b2929508ec894aa2b0370d"><td class="memItemLeft" align="right" valign="top"><a id="ae4becba370b2929508ec894aa2b0370d" name="ae4becba370b2929508ec894aa2b0370d"></a>
bool </td><td class="memItemRight" valign="bottom"><b>is_infinite</b> (<a class="el" href="classCGAL_1_1Triangulation__2.html#a997ed97a0ac906a0342ad18c91a1ec81">Edge_circulator</a> ec) const</td></tr>
<tr class="memdesc:ae4becba370b2929508ec894aa2b0370d"><td class="mdescLeft"> </td><td class="mdescRight"><code>true</code> iff edge <code>*ec</code> is infinite. <br></td></tr>
<tr class="separator:ae4becba370b2929508ec894aa2b0370d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa9ca70cc8b0cb3e0b6c0bf062d710613"><td class="memItemLeft" align="right" valign="top"><a id="aa9ca70cc8b0cb3e0b6c0bf062d710613" name="aa9ca70cc8b0cb3e0b6c0bf062d710613"></a>
bool </td><td class="memItemRight" valign="bottom"><b>is_infinite</b> (<a class="el" href="classCGAL_1_1Triangulation__2.html#a5b63aff651ae1e485ea2c7d20421b4b9">All_edges_iterator</a> ei) const</td></tr>
<tr class="memdesc:aa9ca70cc8b0cb3e0b6c0bf062d710613"><td class="mdescLeft"> </td><td class="mdescRight"><code>true</code> iff edge <code>*ei</code> is infinite. <br></td></tr>
<tr class="separator:aa9ca70cc8b0cb3e0b6c0bf062d710613"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a37b3896ab3a416fe4adff475ed625e16"><td class="memItemLeft" align="right" valign="top"><a id="a37b3896ab3a416fe4adff475ed625e16" name="a37b3896ab3a416fe4adff475ed625e16"></a>
bool </td><td class="memItemRight" valign="bottom"><b>is_edge</b> (<a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> va, <a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> vb)</td></tr>
<tr class="memdesc:a37b3896ab3a416fe4adff475ed625e16"><td class="mdescLeft"> </td><td class="mdescRight"><code>true</code> if there is an edge having <code>va</code> and <code>vb</code> as vertices. <br></td></tr>
<tr class="separator:a37b3896ab3a416fe4adff475ed625e16"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adbeb9736f9bfc588658316669cd7fb44"><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#adbeb9736f9bfc588658316669cd7fb44">is_edge</a> (<a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> va, <a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> vb, <a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> &amp;fr, int &amp;i)</td></tr>
<tr class="memdesc:adbeb9736f9bfc588658316669cd7fb44"><td class="mdescLeft"> </td><td class="mdescRight">as above.  <br></td></tr>
<tr class="separator:adbeb9736f9bfc588658316669cd7fb44"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a171d77fc26d48860fa8a5711000ee690"><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#a171d77fc26d48860fa8a5711000ee690">includes_edge</a> (<a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> va, <a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> vb, <a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> &amp;vbb, <a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> &amp;fr, int &amp;i)</td></tr>
<tr class="memdesc:a171d77fc26d48860fa8a5711000ee690"><td class="mdescLeft"> </td><td class="mdescRight"><code>true</code> if the line segment from <code>va</code> to <code>vb</code> includes an edge <code>e</code> incident to <code>va</code>.  <br></td></tr>
<tr class="separator:a171d77fc26d48860fa8a5711000ee690"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7a94b10ae76a8d4d6e762c19e05b6343"><td class="memItemLeft" align="right" valign="top"><a id="a7a94b10ae76a8d4d6e762c19e05b6343" name="a7a94b10ae76a8d4d6e762c19e05b6343"></a>
bool </td><td class="memItemRight" valign="bottom"><b>is_face</b> (<a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> v1, <a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> v2, <a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> v3)</td></tr>
<tr class="memdesc:a7a94b10ae76a8d4d6e762c19e05b6343"><td class="mdescLeft"> </td><td class="mdescRight"><code>true</code> if there is a face having <code>v1</code>, <code>v2</code> and <code>v3</code> as vertices. <br></td></tr>
<tr class="separator:a7a94b10ae76a8d4d6e762c19e05b6343"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4084823ee026d7a00a3991cd2b553fe0"><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#a4084823ee026d7a00a3991cd2b553fe0">is_face</a> (<a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> v1, <a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> v2, <a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> v3, <a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> &amp;fr)</td></tr>
<tr class="memdesc:a4084823ee026d7a00a3991cd2b553fe0"><td class="mdescLeft"> </td><td class="mdescRight">as above.  <br></td></tr>
<tr class="separator:a4084823ee026d7a00a3991cd2b553fe0"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Queries</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>The class <code><a class="el" href="classCGAL_1_1Triangulation__2.html" title="The class Triangulation_2 is the basic class designed to handle triangulations of set of points  in t...">Triangulation_2</a></code> provides methods to locate a given point with respect to a triangulation.</p>
<p>It also provides methods to locate a point with respect to a given finite face of the triangulation. </p>
</td></tr>
<tr class="memitem:a940567120751e7864c7b345eaf756642"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#a940567120751e7864c7b345eaf756642">locate</a> (const <a class="el" href="classCGAL_1_1Triangulation__2.html#adf800f903a06c19d07d27afb2927fc71">Point</a> &amp;query, <a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> f=<a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a>()) const</td></tr>
<tr class="memdesc:a940567120751e7864c7b345eaf756642"><td class="mdescLeft"> </td><td class="mdescRight">If the point <code>query</code> lies inside the convex hull of the points, a face that contains the query in its interior or on its boundary is returned.  <br></td></tr>
<tr class="separator:a940567120751e7864c7b345eaf756642"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0d62215704e84f18ef9294b27f9e82b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#a0d62215704e84f18ef9294b27f9e82b0">inexact_locate</a> (const <a class="el" href="classCGAL_1_1Triangulation__2.html#adf800f903a06c19d07d27afb2927fc71">Point</a> &amp;query, <a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> start=<a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a>()) const</td></tr>
<tr class="memdesc:a0d62215704e84f18ef9294b27f9e82b0"><td class="mdescLeft"> </td><td class="mdescRight">Same as <code><a class="el" href="classCGAL_1_1Triangulation__2.html#a940567120751e7864c7b345eaf756642" title="If the point query lies inside the convex hull of the points, a face that contains the query in its i...">locate()</a></code> but uses inexact predicates.  <br></td></tr>
<tr class="separator:a0d62215704e84f18ef9294b27f9e82b0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af61a05a0a53d009e111a3873c1796b52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#af61a05a0a53d009e111a3873c1796b52">locate</a> (const <a class="el" href="classCGAL_1_1Triangulation__2.html#adf800f903a06c19d07d27afb2927fc71">Point</a> &amp;query, <a class="el" href="classCGAL_1_1Triangulation__2.html#a22dbae3b466c50924759754de5865db6">Locate_type</a> &amp;lt, int &amp;li, <a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> h=<a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a>()) const</td></tr>
<tr class="memdesc:af61a05a0a53d009e111a3873c1796b52"><td class="mdescLeft"> </td><td class="mdescRight">Same as above.  <br></td></tr>
<tr class="separator:af61a05a0a53d009e111a3873c1796b52"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a01fbafc011677846a729a809b4b21a99"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="../Kernel_23/group__kernel__enums.html#ga5006dd2552d97fa577d81bd819c0f979">Oriented_side</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#a01fbafc011677846a729a809b4b21a99">oriented_side</a> (<a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> f, const <a class="el" href="classCGAL_1_1Triangulation__2.html#adf800f903a06c19d07d27afb2927fc71">Point</a> &amp;p) const</td></tr>
<tr class="memdesc:a01fbafc011677846a729a809b4b21a99"><td class="mdescLeft"> </td><td class="mdescRight">Returns on which side of the oriented boundary of <code>f</code> lies the point <code>p</code>.  <br></td></tr>
<tr class="separator:a01fbafc011677846a729a809b4b21a99"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abc885b3d116e1d0b6943b211e750e472"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="../Kernel_23/group__kernel__enums.html#ga5006dd2552d97fa577d81bd819c0f979">Oriented_side</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#abc885b3d116e1d0b6943b211e750e472">side_of_oriented_circle</a> (<a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> f, const <a class="el" href="classCGAL_1_1Triangulation__2.html#adf800f903a06c19d07d27afb2927fc71">Point</a> &amp;p)</td></tr>
<tr class="memdesc:abc885b3d116e1d0b6943b211e750e472"><td class="mdescLeft"> </td><td class="mdescRight">Returns on which side of the circumcircle of face <code>f</code> lies the point <code>p</code>.  <br></td></tr>
<tr class="separator:abc885b3d116e1d0b6943b211e750e472"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Modifiers</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>The following operations are guaranteed to lead to a valid triangulation when they are applied on a valid triangulation.</p>
<p><a class="anchor" id="Triangulation_ref_Fig_inser1t"></a></p><div class="image">
<img src="insert1.png" alt="">
<div class="caption">
Insertion of a point on an edge.</div></div>
 <p><a class="anchor" id="Triangulation_ref_Fig_insert2"></a></p><div class="image">
<img src="insert2.png" alt="">
<div class="caption">
Insertion in a face.</div></div>
<p>  <a class="anchor" id="Triangulation_ref_Fig_insert3"></a></p><div class="image">
<img src="insert3.png" alt="">
<div class="caption">
Insertion outside the convex hull.</div></div>
<p>  <a class="anchor" id="Triangulation_ref_Fig_remove"></a></p><div class="image">
<img src="remove.png" alt="">
<div class="caption">
Removal.</div></div>
  </td></tr>
<tr class="memitem:aa47a446fc11809d30146fbcdb689a396"><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#aa47a446fc11809d30146fbcdb689a396">flip</a> (<a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> f, int i)</td></tr>
<tr class="memdesc:aa47a446fc11809d30146fbcdb689a396"><td class="mdescLeft"> </td><td class="mdescRight">Exchanges the edge incident to <code>f</code> and <code>f-&gt;neighbor(i)</code> with the other diagonal of the quadrilateral formed by <code>f</code> and <code>f-&gt;neighbor(i)</code>.  <br></td></tr>
<tr class="separator:aa47a446fc11809d30146fbcdb689a396"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1025cd7e7226ccb44d82f0fb1d63ad4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#a1025cd7e7226ccb44d82f0fb1d63ad4e">insert</a> (const <a class="el" href="classCGAL_1_1Triangulation__2.html#adf800f903a06c19d07d27afb2927fc71">Point</a> &amp;p, <a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> f=<a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a>())</td></tr>
<tr class="memdesc:a1025cd7e7226ccb44d82f0fb1d63ad4e"><td class="mdescLeft"> </td><td class="mdescRight">Inserts point <code>p</code> in the triangulation and returns the corresponding vertex.  <br></td></tr>
<tr class="separator:a1025cd7e7226ccb44d82f0fb1d63ad4e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab5282f769ba8445b872b4d32e8b38487"><td class="memItemLeft" align="right" valign="top"><a id="ab5282f769ba8445b872b4d32e8b38487" name="ab5282f769ba8445b872b4d32e8b38487"></a>
<a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> </td><td class="memItemRight" valign="bottom"><b>insert</b> (const <a class="el" href="classCGAL_1_1Triangulation__2.html#adf800f903a06c19d07d27afb2927fc71">Point</a> &amp;p, <a class="el" href="classCGAL_1_1Triangulation__2.html#a22dbae3b466c50924759754de5865db6">Locate_type</a> lt, <a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> loc, int li)</td></tr>
<tr class="memdesc:ab5282f769ba8445b872b4d32e8b38487"><td class="mdescLeft"> </td><td class="mdescRight">Same as above except that the location of the point <code>p</code> to be inserted is assumed to be given by <code>(lt,loc,i)</code> (see the description of the <code>locate</code> method above.) <br></td></tr>
<tr class="separator:ab5282f769ba8445b872b4d32e8b38487"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a21109eb748cd3800fe2ef92ff5f1e77e"><td class="memItemLeft" align="right" valign="top"><a id="a21109eb748cd3800fe2ef92ff5f1e77e" name="a21109eb748cd3800fe2ef92ff5f1e77e"></a>
<a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> </td><td class="memItemRight" valign="bottom"><b>push_back</b> (const <a class="el" href="classCGAL_1_1Triangulation__2.html#adf800f903a06c19d07d27afb2927fc71">Point</a> &amp;p)</td></tr>
<tr class="memdesc:a21109eb748cd3800fe2ef92ff5f1e77e"><td class="mdescLeft"> </td><td class="mdescRight">Equivalent to <code>insert(p)</code>. <br></td></tr>
<tr class="separator:a21109eb748cd3800fe2ef92ff5f1e77e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a02f3c7c337f38cd9b534e6807856c106"><td class="memTemplParams" colspan="2">template&lt;class PointInputIterator &gt; </td></tr>
<tr class="memitem:a02f3c7c337f38cd9b534e6807856c106"><td class="memTemplItemLeft" align="right" valign="top">std::ptrdiff_t </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#a02f3c7c337f38cd9b534e6807856c106">insert</a> (PointInputIterator first, PointInputIterator last)</td></tr>
<tr class="memdesc:a02f3c7c337f38cd9b534e6807856c106"><td class="mdescLeft"> </td><td class="mdescRight">Inserts the points in the range <code>[first,last)</code> in the given order, and returns the number of inserted points.  <br></td></tr>
<tr class="separator:a02f3c7c337f38cd9b534e6807856c106"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac5e9bc8adef80dc01a0b31c2d0234545"><td class="memTemplParams" colspan="2">template&lt;class PointWithInfoInputIterator &gt; </td></tr>
<tr class="memitem:ac5e9bc8adef80dc01a0b31c2d0234545"><td class="memTemplItemLeft" align="right" valign="top">std::ptrdiff_t </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#ac5e9bc8adef80dc01a0b31c2d0234545">insert</a> (PointWithInfoInputIterator first, PointWithInfoInputIterator last)</td></tr>
<tr class="memdesc:ac5e9bc8adef80dc01a0b31c2d0234545"><td class="mdescLeft"> </td><td class="mdescRight">inserts the points in the iterator range <code>[first,last)</code> in the given order, and returns the number of inserted points.  <br></td></tr>
<tr class="separator:ac5e9bc8adef80dc01a0b31c2d0234545"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9a5dc75ed6ce4a645a5b61e5a8e88974"><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#a9a5dc75ed6ce4a645a5b61e5a8e88974">remove</a> (<a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> v)</td></tr>
<tr class="memdesc:a9a5dc75ed6ce4a645a5b61e5a8e88974"><td class="mdescLeft"> </td><td class="mdescRight">Removes the vertex from the triangulation.  <br></td></tr>
<tr class="separator:a9a5dc75ed6ce4a645a5b61e5a8e88974"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a433cff4ceaeaba390df1a968d93a4899"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#a433cff4ceaeaba390df1a968d93a4899">move_if_no_collision</a> (<a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> v, const <a class="el" href="classCGAL_1_1Triangulation__2.html#adf800f903a06c19d07d27afb2927fc71">Point</a> &amp;p)</td></tr>
<tr class="memdesc:a433cff4ceaeaba390df1a968d93a4899"><td class="mdescLeft"> </td><td class="mdescRight">If there is not already another vertex placed on <code>p</code>, the triangulation is modified such that the new position of vertex <code>v</code> is <code>p</code>, and <code>v</code> is returned.  <br></td></tr>
<tr class="separator:a433cff4ceaeaba390df1a968d93a4899"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a62de40896ebe056bbf008eb4090eb76b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#a62de40896ebe056bbf008eb4090eb76b">move</a> (<a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> v, const <a class="el" href="classCGAL_1_1Triangulation__2.html#adf800f903a06c19d07d27afb2927fc71">Point</a> &amp;p)</td></tr>
<tr class="memdesc:a62de40896ebe056bbf008eb4090eb76b"><td class="mdescLeft"> </td><td class="mdescRight">If there is no collision during the move, this function is the same as <code>move_if_no_collision</code> .  <br></td></tr>
<tr class="separator:a62de40896ebe056bbf008eb4090eb76b"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Specialized Modifiers</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>The following member functions offer more specialized versions of the insertion or removal operations to be used when one knows to be in the corresponding case. </p>
</td></tr>
<tr class="memitem:a359b4c5e12af04f9235b5f2f42cae709"><td class="memItemLeft" align="right" valign="top"><a id="a359b4c5e12af04f9235b5f2f42cae709" name="a359b4c5e12af04f9235b5f2f42cae709"></a>
<a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> </td><td class="memItemRight" valign="bottom"><b>insert_first</b> (const <a class="el" href="classCGAL_1_1Triangulation__2.html#adf800f903a06c19d07d27afb2927fc71">Point</a> &amp;p)</td></tr>
<tr class="memdesc:a359b4c5e12af04f9235b5f2f42cae709"><td class="mdescLeft"> </td><td class="mdescRight">Inserts the first finite vertex . <br></td></tr>
<tr class="separator:a359b4c5e12af04f9235b5f2f42cae709"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6a30184b0267dc1cdc9cc516440cbb4e"><td class="memItemLeft" align="right" valign="top"><a id="a6a30184b0267dc1cdc9cc516440cbb4e" name="a6a30184b0267dc1cdc9cc516440cbb4e"></a>
<a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> </td><td class="memItemRight" valign="bottom"><b>insert_second</b> (const <a class="el" href="classCGAL_1_1Triangulation__2.html#adf800f903a06c19d07d27afb2927fc71">Point</a> &amp;p)</td></tr>
<tr class="memdesc:a6a30184b0267dc1cdc9cc516440cbb4e"><td class="mdescLeft"> </td><td class="mdescRight">Inserts the second finite vertex . <br></td></tr>
<tr class="separator:a6a30184b0267dc1cdc9cc516440cbb4e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8f4a1ca36147ac331db5be089e17a2a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#a8f4a1ca36147ac331db5be089e17a2a5">insert_in_face</a> (const <a class="el" href="classCGAL_1_1Triangulation__2.html#adf800f903a06c19d07d27afb2927fc71">Point</a> &amp;p, <a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> f)</td></tr>
<tr class="memdesc:a8f4a1ca36147ac331db5be089e17a2a5"><td class="mdescLeft"> </td><td class="mdescRight">Inserts vertex <code>v</code> in face <code>f</code>.  <br></td></tr>
<tr class="separator:a8f4a1ca36147ac331db5be089e17a2a5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aefd64b3be7364535e808ed62faaa6a67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#aefd64b3be7364535e808ed62faaa6a67">insert_in_edge</a> (const <a class="el" href="classCGAL_1_1Triangulation__2.html#adf800f903a06c19d07d27afb2927fc71">Point</a> &amp;p, <a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> f, int i)</td></tr>
<tr class="memdesc:aefd64b3be7364535e808ed62faaa6a67"><td class="mdescLeft"> </td><td class="mdescRight">Inserts vertex v in edge <code>i</code> of <code>f</code>.  <br></td></tr>
<tr class="separator:aefd64b3be7364535e808ed62faaa6a67"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2c35ed5fa9ea46b55687c36a4755d592"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#a2c35ed5fa9ea46b55687c36a4755d592">insert_outside_convex_hull</a> (const <a class="el" href="classCGAL_1_1Triangulation__2.html#adf800f903a06c19d07d27afb2927fc71">Point</a> &amp;p, <a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> f)</td></tr>
<tr class="memdesc:a2c35ed5fa9ea46b55687c36a4755d592"><td class="mdescLeft"> </td><td class="mdescRight">Inserts a point which is outside the convex hull but in the affine hull.  <br></td></tr>
<tr class="separator:a2c35ed5fa9ea46b55687c36a4755d592"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad8a56f1fb051ce731a079671799010de"><td class="memItemLeft" align="right" valign="top"><a id="ad8a56f1fb051ce731a079671799010de" name="ad8a56f1fb051ce731a079671799010de"></a>
<a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> </td><td class="memItemRight" valign="bottom"><b>insert_outside_affine_hull</b> (const <a class="el" href="classCGAL_1_1Triangulation__2.html#adf800f903a06c19d07d27afb2927fc71">Point</a> &amp;p)</td></tr>
<tr class="memdesc:ad8a56f1fb051ce731a079671799010de"><td class="mdescLeft"> </td><td class="mdescRight">Inserts a point which is outside the affine hull. <br></td></tr>
<tr class="separator:ad8a56f1fb051ce731a079671799010de"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4b3389b24fe7bfe703151375d15a745a"><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#a4b3389b24fe7bfe703151375d15a745a">remove_degree_3</a> (<a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> v)</td></tr>
<tr class="memdesc:a4b3389b24fe7bfe703151375d15a745a"><td class="mdescLeft"> </td><td class="mdescRight">Removes a vertex of degree three.  <br></td></tr>
<tr class="separator:a4b3389b24fe7bfe703151375d15a745a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a44461f8dc31540c015f24ee3d36870ab"><td class="memItemLeft" align="right" valign="top"><a id="a44461f8dc31540c015f24ee3d36870ab" name="a44461f8dc31540c015f24ee3d36870ab"></a>
void </td><td class="memItemRight" valign="bottom"><b>remove_second</b> (<a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> v)</td></tr>
<tr class="memdesc:a44461f8dc31540c015f24ee3d36870ab"><td class="mdescLeft"> </td><td class="mdescRight">Removes the before last finite vertex. <br></td></tr>
<tr class="separator:a44461f8dc31540c015f24ee3d36870ab"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac00496f74f7d05465407861f5a447768"><td class="memItemLeft" align="right" valign="top"><a id="ac00496f74f7d05465407861f5a447768" name="ac00496f74f7d05465407861f5a447768"></a>
void </td><td class="memItemRight" valign="bottom"><b>remove_first</b> (<a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> v)</td></tr>
<tr class="memdesc:ac00496f74f7d05465407861f5a447768"><td class="mdescLeft"> </td><td class="mdescRight">Removes the last finite vertex. <br></td></tr>
<tr class="separator:ac00496f74f7d05465407861f5a447768"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8b058b055ef24a4b6fc25bf110e46638"><td class="memTemplParams" colspan="2">template&lt;class EdgeIt &gt; </td></tr>
<tr class="memitem:a8b058b055ef24a4b6fc25bf110e46638"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#a8b058b055ef24a4b6fc25bf110e46638">star_hole</a> (<a class="el" href="classCGAL_1_1Triangulation__2.html#adf800f903a06c19d07d27afb2927fc71">Point</a> p, EdgeIt edge_begin, EdgeIt edge_end)</td></tr>
<tr class="memdesc:a8b058b055ef24a4b6fc25bf110e46638"><td class="mdescLeft"> </td><td class="mdescRight">creates a new vertex <code>v</code> and use it to star the hole whose boundary is described by the sequence of edges <code>[edge_begin, edge_end)</code>.  <br></td></tr>
<tr class="separator:a8b058b055ef24a4b6fc25bf110e46638"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4511afae77c0c2978b6412d9411e4fe2"><td class="memTemplParams" colspan="2">template&lt;class EdgeIt , class FaceIt &gt; </td></tr>
<tr class="memitem:a4511afae77c0c2978b6412d9411e4fe2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#a4511afae77c0c2978b6412d9411e4fe2">star_hole</a> (<a class="el" href="classCGAL_1_1Triangulation__2.html#adf800f903a06c19d07d27afb2927fc71">Point</a> p, EdgeIt edge_begin, EdgeIt edge_end, FaceIt face_begin, FaceIt face_end)</td></tr>
<tr class="memdesc:a4511afae77c0c2978b6412d9411e4fe2"><td class="mdescLeft"> </td><td class="mdescRight">same as above, except that the algorithm first recycles faces in the sequence <code>[face_begin, face_end)</code> and create new ones only when the sequence is exhausted.  <br></td></tr>
<tr class="separator:a4511afae77c0c2978b6412d9411e4fe2"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Finite Face, Edge and Vertex Iterators</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>The following iterators allow respectively to visit finite faces, finite edges and finite vertices of the triangulation.</p>
<p>These iterators are non mutable, bidirectional and their value types are respectively <code>Face</code>, <code>Edge</code> and <code>Vertex</code>. They are all invalidated by any change in the triangulation. </p>
</td></tr>
<tr class="memitem:afec203a9cabc1700b76a3f7d4b388840"><td class="memItemLeft" align="right" valign="top"><a id="afec203a9cabc1700b76a3f7d4b388840" name="afec203a9cabc1700b76a3f7d4b388840"></a>
<a class="el" href="classCGAL_1_1Triangulation__2.html#a3dfacc0bd86f726c637b7ff86f404f84">Finite_vertices_iterator</a> </td><td class="memItemRight" valign="bottom"><b>finite_vertices_begin</b> () const</td></tr>
<tr class="memdesc:afec203a9cabc1700b76a3f7d4b388840"><td class="mdescLeft"> </td><td class="mdescRight">Starts at an arbitrary finite vertex. <br></td></tr>
<tr class="separator:afec203a9cabc1700b76a3f7d4b388840"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a00acf9a6484acec989b945dca69cac0b"><td class="memItemLeft" align="right" valign="top"><a id="a00acf9a6484acec989b945dca69cac0b" name="a00acf9a6484acec989b945dca69cac0b"></a>
<a class="el" href="classCGAL_1_1Triangulation__2.html#a3dfacc0bd86f726c637b7ff86f404f84">Finite_vertices_iterator</a> </td><td class="memItemRight" valign="bottom"><b>finite_vertices_end</b> () const</td></tr>
<tr class="memdesc:a00acf9a6484acec989b945dca69cac0b"><td class="mdescLeft"> </td><td class="mdescRight">Past-the-end iterator. <br></td></tr>
<tr class="separator:a00acf9a6484acec989b945dca69cac0b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3d7335c51c4c777fec2b9c2560f2635f"><td class="memItemLeft" align="right" valign="top"><a id="a3d7335c51c4c777fec2b9c2560f2635f" name="a3d7335c51c4c777fec2b9c2560f2635f"></a>
<a class="el" href="classCGAL_1_1Triangulation__2.html#af70ca2702b9de4ae712b953f6a94b9a2">Finite_edges_iterator</a> </td><td class="memItemRight" valign="bottom"><b>finite_edges_begin</b> () const</td></tr>
<tr class="memdesc:a3d7335c51c4c777fec2b9c2560f2635f"><td class="mdescLeft"> </td><td class="mdescRight">Starts at an arbitrary finite edge. <br></td></tr>
<tr class="separator:a3d7335c51c4c777fec2b9c2560f2635f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6bd40af3800321a0d0d43f489b37fc2a"><td class="memItemLeft" align="right" valign="top"><a id="a6bd40af3800321a0d0d43f489b37fc2a" name="a6bd40af3800321a0d0d43f489b37fc2a"></a>
<a class="el" href="classCGAL_1_1Triangulation__2.html#af70ca2702b9de4ae712b953f6a94b9a2">Finite_edges_iterator</a> </td><td class="memItemRight" valign="bottom"><b>finite_edges_end</b> () const</td></tr>
<tr class="memdesc:a6bd40af3800321a0d0d43f489b37fc2a"><td class="mdescLeft"> </td><td class="mdescRight">Past-the-end iterator. <br></td></tr>
<tr class="separator:a6bd40af3800321a0d0d43f489b37fc2a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a66241217c984aa597d36d4ff6f0ff3f2"><td class="memItemLeft" align="right" valign="top"><a id="a66241217c984aa597d36d4ff6f0ff3f2" name="a66241217c984aa597d36d4ff6f0ff3f2"></a>
<a class="el" href="classCGAL_1_1Triangulation__2.html#a84923815e1cfca537c93cee97c0ed24f">Finite_faces_iterator</a> </td><td class="memItemRight" valign="bottom"><b>finite_faces_begin</b> () const</td></tr>
<tr class="memdesc:a66241217c984aa597d36d4ff6f0ff3f2"><td class="mdescLeft"> </td><td class="mdescRight">Starts at an arbitrary finite face. <br></td></tr>
<tr class="separator:a66241217c984aa597d36d4ff6f0ff3f2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3df949e116750967bc46db9ba53da7c0"><td class="memItemLeft" align="right" valign="top"><a id="a3df949e116750967bc46db9ba53da7c0" name="a3df949e116750967bc46db9ba53da7c0"></a>
<a class="el" href="classCGAL_1_1Triangulation__2.html#a84923815e1cfca537c93cee97c0ed24f">Finite_faces_iterator</a> </td><td class="memItemRight" valign="bottom"><b>finite_faces_end</b> () const</td></tr>
<tr class="memdesc:a3df949e116750967bc46db9ba53da7c0"><td class="mdescLeft"> </td><td class="mdescRight">Past-the-end iterator. <br></td></tr>
<tr class="separator:a3df949e116750967bc46db9ba53da7c0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a048beaadce99c9bdfeaa69dd68701c32"><td class="memItemLeft" align="right" valign="top"><a id="a048beaadce99c9bdfeaa69dd68701c32" name="a048beaadce99c9bdfeaa69dd68701c32"></a>
<a class="el" href="classCGAL_1_1Triangulation__2.html#a06ec87f55894738972350f631f6dc1fe">Point_iterator</a> </td><td class="memItemRight" valign="bottom"><b>points_begin</b> () const</td></tr>
<tr class="separator:a048beaadce99c9bdfeaa69dd68701c32"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adb17161924b6d2b6e7ac537d6b760728"><td class="memItemLeft" align="right" valign="top"><a id="adb17161924b6d2b6e7ac537d6b760728" name="adb17161924b6d2b6e7ac537d6b760728"></a>
<a class="el" href="classCGAL_1_1Triangulation__2.html#a06ec87f55894738972350f631f6dc1fe">Point_iterator</a> </td><td class="memItemRight" valign="bottom"><b>points_end</b> () const</td></tr>
<tr class="memdesc:adb17161924b6d2b6e7ac537d6b760728"><td class="mdescLeft"> </td><td class="mdescRight">Past-the-end iterator. <br></td></tr>
<tr class="separator:adb17161924b6d2b6e7ac537d6b760728"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a742d528593275c1fe119979b4ce74a90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__2.html#a07f0b236b51b0e8a69512561dc12734a">Finite_vertex_handles</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#a742d528593275c1fe119979b4ce74a90">finite_vertex_handles</a> () const</td></tr>
<tr class="memdesc:a742d528593275c1fe119979b4ce74a90"><td class="mdescLeft"> </td><td class="mdescRight">returns a range of iterators over finite vertices.  <br></td></tr>
<tr class="separator:a742d528593275c1fe119979b4ce74a90"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a837c6fe6f8daaec60b0276e294daf5ca"><td class="memItemLeft" align="right" valign="top"><a id="a837c6fe6f8daaec60b0276e294daf5ca" name="a837c6fe6f8daaec60b0276e294daf5ca"></a>
<a class="el" href="classCGAL_1_1Triangulation__2.html#af7f5d22e7244c73be90bec59a502e7aa">Finite_edges</a> </td><td class="memItemRight" valign="bottom"><b>finite_edges</b> () const</td></tr>
<tr class="memdesc:a837c6fe6f8daaec60b0276e294daf5ca"><td class="mdescLeft"> </td><td class="mdescRight">returns a range of iterators over finite edges. <br></td></tr>
<tr class="separator:a837c6fe6f8daaec60b0276e294daf5ca"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a01c421302be46c33fd6d8de75945a1ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__2.html#ae89fd1a46ae755c79ac650fc41f6d3dd">Finite_face_handles</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#a01c421302be46c33fd6d8de75945a1ad">finite_face_handles</a> () const</td></tr>
<tr class="memdesc:a01c421302be46c33fd6d8de75945a1ad"><td class="mdescLeft"> </td><td class="mdescRight">returns a range of iterators over finite faces.  <br></td></tr>
<tr class="separator:a01c421302be46c33fd6d8de75945a1ad"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:acae6c6bf678ec1a90b49498862bb7fa2"><td class="memItemLeft" align="right" valign="top"><a id="acae6c6bf678ec1a90b49498862bb7fa2" name="acae6c6bf678ec1a90b49498862bb7fa2"></a>
<a class="el" href="classCGAL_1_1Triangulation__2.html#a55aff11c6b56078d7384374a898bc1b9">Points</a> </td><td class="memItemRight" valign="bottom"><b>points</b> () const</td></tr>
<tr class="memdesc:acae6c6bf678ec1a90b49498862bb7fa2"><td class="mdescLeft"> </td><td class="mdescRight">returns a range of iterators over the points of finite vertices. <br></td></tr>
<tr class="separator:acae6c6bf678ec1a90b49498862bb7fa2"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">All Face, Edge and Vertex Iterators</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>The following iterators allow respectively to visit all (finite or infinite) faces, edges and vertices of the triangulation.</p>
<p>These iterators are non mutable, bidirectional and their value types are respectively <code>Face</code>, <code>Edge</code> and <code>Vertex</code>. They are all invalidated by any change in the triangulation. </p>
</td></tr>
<tr class="memitem:adb9bbf3918a8081d21fc0c1de20b157e"><td class="memItemLeft" align="right" valign="top"><a id="adb9bbf3918a8081d21fc0c1de20b157e" name="adb9bbf3918a8081d21fc0c1de20b157e"></a>
<a class="el" href="classCGAL_1_1Triangulation__2.html#a1d4600a9428fed798c112964ba57d9f1">All_vertices_iterator</a> </td><td class="memItemRight" valign="bottom"><b>all_vertices_begin</b> () const</td></tr>
<tr class="memdesc:adb9bbf3918a8081d21fc0c1de20b157e"><td class="mdescLeft"> </td><td class="mdescRight">Starts at an arbitrary vertex. <br></td></tr>
<tr class="separator:adb9bbf3918a8081d21fc0c1de20b157e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a99d052d1f8a1f99c8defec48604192f5"><td class="memItemLeft" align="right" valign="top"><a id="a99d052d1f8a1f99c8defec48604192f5" name="a99d052d1f8a1f99c8defec48604192f5"></a>
<a class="el" href="classCGAL_1_1Triangulation__2.html#a1d4600a9428fed798c112964ba57d9f1">All_vertices_iterator</a> </td><td class="memItemRight" valign="bottom"><b>all_vertices_end</b> () const</td></tr>
<tr class="memdesc:a99d052d1f8a1f99c8defec48604192f5"><td class="mdescLeft"> </td><td class="mdescRight">Past-the-end iterator. <br></td></tr>
<tr class="separator:a99d052d1f8a1f99c8defec48604192f5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a83de89d7d1c6e306b331b7158728bb57"><td class="memItemLeft" align="right" valign="top"><a id="a83de89d7d1c6e306b331b7158728bb57" name="a83de89d7d1c6e306b331b7158728bb57"></a>
<a class="el" href="classCGAL_1_1Triangulation__2.html#a5b63aff651ae1e485ea2c7d20421b4b9">All_edges_iterator</a> </td><td class="memItemRight" valign="bottom"><b>all_edges_begin</b> () const</td></tr>
<tr class="memdesc:a83de89d7d1c6e306b331b7158728bb57"><td class="mdescLeft"> </td><td class="mdescRight">Starts at an arbitrary edge. <br></td></tr>
<tr class="separator:a83de89d7d1c6e306b331b7158728bb57"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aee85b73cb094f95603939be436e63438"><td class="memItemLeft" align="right" valign="top"><a id="aee85b73cb094f95603939be436e63438" name="aee85b73cb094f95603939be436e63438"></a>
<a class="el" href="classCGAL_1_1Triangulation__2.html#a5b63aff651ae1e485ea2c7d20421b4b9">All_edges_iterator</a> </td><td class="memItemRight" valign="bottom"><b>all_edges_end</b> () const</td></tr>
<tr class="memdesc:aee85b73cb094f95603939be436e63438"><td class="mdescLeft"> </td><td class="mdescRight">Past-the-end iterator. <br></td></tr>
<tr class="separator:aee85b73cb094f95603939be436e63438"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a93f4b88a11e455e4af2f5442e5d4824d"><td class="memItemLeft" align="right" valign="top"><a id="a93f4b88a11e455e4af2f5442e5d4824d" name="a93f4b88a11e455e4af2f5442e5d4824d"></a>
<a class="el" href="classCGAL_1_1Triangulation__2.html#ae5363996414e60613b556b14a9f87891">All_faces_iterator</a> </td><td class="memItemRight" valign="bottom"><b>all_faces_begin</b> () const</td></tr>
<tr class="memdesc:a93f4b88a11e455e4af2f5442e5d4824d"><td class="mdescLeft"> </td><td class="mdescRight">Starts at an arbitrary face. <br></td></tr>
<tr class="separator:a93f4b88a11e455e4af2f5442e5d4824d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a395ece5a58ae27040ccbbb9503899671"><td class="memItemLeft" align="right" valign="top"><a id="a395ece5a58ae27040ccbbb9503899671" name="a395ece5a58ae27040ccbbb9503899671"></a>
<a class="el" href="classCGAL_1_1Triangulation__2.html#ae5363996414e60613b556b14a9f87891">All_faces_iterator</a> </td><td class="memItemRight" valign="bottom"><b>all_faces_end</b> () const</td></tr>
<tr class="memdesc:a395ece5a58ae27040ccbbb9503899671"><td class="mdescLeft"> </td><td class="mdescRight">Past-the-end iterator. <br></td></tr>
<tr class="separator:a395ece5a58ae27040ccbbb9503899671"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abb3ae01ea08e705e49ced503e4a83026"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__2.html#aaed9fdd0b481d9ec138548fb243752ab">All_vertex_handles</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#abb3ae01ea08e705e49ced503e4a83026">all_vertex_handles</a> () const</td></tr>
<tr class="memdesc:abb3ae01ea08e705e49ced503e4a83026"><td class="mdescLeft"> </td><td class="mdescRight">returns a range of iterators over all vertices.  <br></td></tr>
<tr class="separator:abb3ae01ea08e705e49ced503e4a83026"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6126344554bd1af7dcd166a705e4e0ff"><td class="memItemLeft" align="right" valign="top"><a id="a6126344554bd1af7dcd166a705e4e0ff" name="a6126344554bd1af7dcd166a705e4e0ff"></a>
<a class="el" href="classCGAL_1_1Triangulation__2.html#aab68c0408fce72a3294d76f6ded2ea56">All_edges</a> </td><td class="memItemRight" valign="bottom"><b>all_edges</b> () const</td></tr>
<tr class="memdesc:a6126344554bd1af7dcd166a705e4e0ff"><td class="mdescLeft"> </td><td class="mdescRight">returns a range of iterators over all edges. <br></td></tr>
<tr class="separator:a6126344554bd1af7dcd166a705e4e0ff"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae0bd242bbe0d505aa1f7c4c366d5d56f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__2.html#a40f06313bd485eed99b6ba119da98bb5">All_face_handles</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#ae0bd242bbe0d505aa1f7c4c366d5d56f">all_face_handles</a> () const</td></tr>
<tr class="memdesc:ae0bd242bbe0d505aa1f7c4c366d5d56f"><td class="mdescLeft"> </td><td class="mdescRight">returns a range of iterators over all faces.  <br></td></tr>
<tr class="separator:ae0bd242bbe0d505aa1f7c4c366d5d56f"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Line Face Circulator</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>The triangulation defines a circulator that allows to visit all faces that are intersected by a line.</p>
<p>A face <code>f</code> is considered has being intersected by the oriented line <code>l</code> if either:</p><ul>
<li><code>f</code> is a finite face whose interior intersects <code>l</code>, or</li>
<li><code>f</code> is a finite face with an edge collinear with <code>l</code> and lies to the left of <code>l</code>, or</li>
<li><code>f</code> is an infinite face incident to a convex hull edge whose interior is intersected by <code>l</code>, or</li>
<li><code>f</code> is an infinite face incident to a convex hull vertex lying on <code>l</code> and the finite edge of <code>f</code> lies to the left of <code>l</code>.</li>
</ul>
<p>The circulator has a singular value if the line <code>l</code> intersect no finite face of the triangulation. This circulator is non-mutable and bidirectional. Its value type is <code>Face</code>. Figure <a class="el" href="classCGAL_1_1Triangulation__2.html#Triangulation_ref_Fig_Line_face_circulator">Triangulation_ref_Fig_Line_face_circulator</a> illustrates which finite faces are enumerated. Lines \( l_1\) and \( l_2\) have no face to their left. Lines \( l_3\) and \( l_4\) have faces to their left. Note that the finite faces that are only vertex incident to lines \( l_3\) and \( l_4\) are not enumerated.</p>
<p><a class="anchor" id="Triangulation_ref_Fig_Line_face_circulator"></a></p><div class="image">
<img src="walk.png" alt="">
<div class="caption">
The line face circulator. A line face circulator is invalidated if the face the circulator refers to is changed.</div></div>
  </td></tr>
<tr class="memitem:a41a46211193d767f122504f2eb99189a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__2.html#ad720b1a9adc835ed1a27c228eea1e36c">Line_face_circulator</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#a41a46211193d767f122504f2eb99189a">line_walk</a> (const <a class="el" href="classCGAL_1_1Triangulation__2.html#adf800f903a06c19d07d27afb2927fc71">Point</a> &amp;p, const <a class="el" href="classCGAL_1_1Triangulation__2.html#adf800f903a06c19d07d27afb2927fc71">Point</a> &amp;q, <a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> f=<a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a>()) const</td></tr>
<tr class="memdesc:a41a46211193d767f122504f2eb99189a"><td class="mdescLeft"> </td><td class="mdescRight">This function returns a circulator that allows to visit the faces intersected by the line <code>pq</code>.  <br></td></tr>
<tr class="separator:a41a46211193d767f122504f2eb99189a"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Face, Edge and Vertex Circulators</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>The triangulation also provides circulators that allows to visit respectively all faces or edges incident to a given vertex or all vertices adjacent to a given vertex.</p>
<p>These circulators are non-mutable and bidirectional. The <code>operator++</code> moves the circulator counterclockwise around the vertex while the <code>operator-</code> moves clockwise. A face circulator is invalidated by any modification of the face pointed to. An edge or a vertex circulator are invalidated by any modification of one of the two faces incident to the edge pointed to. </p>
</td></tr>
<tr class="memitem:a1ca68226e40c30304c4d54685a77a7ca"><td class="memItemLeft" align="right" valign="top"><a id="a1ca68226e40c30304c4d54685a77a7ca" name="a1ca68226e40c30304c4d54685a77a7ca"></a>
<a class="el" href="classCGAL_1_1Triangulation__2.html#a1bda2ab92ccf638bb22fc223ae281b96">Face_circulator</a> </td><td class="memItemRight" valign="bottom"><b>incident_faces</b> (<a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> v) const</td></tr>
<tr class="memdesc:a1ca68226e40c30304c4d54685a77a7ca"><td class="mdescLeft"> </td><td class="mdescRight">Starts at an arbitrary face incident to <code>v</code>. <br></td></tr>
<tr class="separator:a1ca68226e40c30304c4d54685a77a7ca"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a341c4f3888b6ede6b9df55c2bb745ca3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__2.html#a1bda2ab92ccf638bb22fc223ae281b96">Face_circulator</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#a341c4f3888b6ede6b9df55c2bb745ca3">incident_faces</a> (<a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> v, <a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> f) const</td></tr>
<tr class="memdesc:a341c4f3888b6ede6b9df55c2bb745ca3"><td class="mdescLeft"> </td><td class="mdescRight">Starts at face <code>f</code>.  <br></td></tr>
<tr class="separator:a341c4f3888b6ede6b9df55c2bb745ca3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1708a62dea4a40f63025848e4afaefa0"><td class="memItemLeft" align="right" valign="top"><a id="a1708a62dea4a40f63025848e4afaefa0" name="a1708a62dea4a40f63025848e4afaefa0"></a>
<a class="el" href="classCGAL_1_1Triangulation__2.html#a997ed97a0ac906a0342ad18c91a1ec81">Edge_circulator</a> </td><td class="memItemRight" valign="bottom"><b>incident_edges</b> (<a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> v) const</td></tr>
<tr class="memdesc:a1708a62dea4a40f63025848e4afaefa0"><td class="mdescLeft"> </td><td class="mdescRight">Starts at an arbitrary edge incident to <code>v</code>. <br></td></tr>
<tr class="separator:a1708a62dea4a40f63025848e4afaefa0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a843853eb19644389ba8d6024765eb4f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__2.html#a997ed97a0ac906a0342ad18c91a1ec81">Edge_circulator</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#a843853eb19644389ba8d6024765eb4f7">incident_edges</a> (<a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> v, <a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> f) const</td></tr>
<tr class="memdesc:a843853eb19644389ba8d6024765eb4f7"><td class="mdescLeft"> </td><td class="mdescRight">Starts at the first edge of <code>f</code> incident to <code>v</code>, in counterclockwise order around <code>v</code>.  <br></td></tr>
<tr class="separator:a843853eb19644389ba8d6024765eb4f7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afebc0e18dc93bce4b62b1e06944a6921"><td class="memItemLeft" align="right" valign="top"><a id="afebc0e18dc93bce4b62b1e06944a6921" name="afebc0e18dc93bce4b62b1e06944a6921"></a>
<a class="el" href="classCGAL_1_1Triangulation__2.html#ade901d47c7c422f7978adf3ac0188a9d">Vertex_circulator</a> </td><td class="memItemRight" valign="bottom"><b>incident_vertices</b> (<a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> v) const</td></tr>
<tr class="memdesc:afebc0e18dc93bce4b62b1e06944a6921"><td class="mdescLeft"> </td><td class="mdescRight">Starts at an arbitrary vertex incident to <code>v</code>. <br></td></tr>
<tr class="separator:afebc0e18dc93bce4b62b1e06944a6921"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a58c9a0c9f69a356a31c8a7c02eff1841"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__2.html#ade901d47c7c422f7978adf3ac0188a9d">Vertex_circulator</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#a58c9a0c9f69a356a31c8a7c02eff1841">incident_vertices</a> (<a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> v, <a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> f)</td></tr>
<tr class="memdesc:a58c9a0c9f69a356a31c8a7c02eff1841"><td class="mdescLeft"> </td><td class="mdescRight">Starts at the first vertex of <code>f</code> adjacent to <code>v</code> in counterclockwise order around <code>v</code>.  <br></td></tr>
<tr class="separator:a58c9a0c9f69a356a31c8a7c02eff1841"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Traversal Between Adjacent Faces</h2></td></tr>
<tr class="memitem:a9213aedceda4c17381960d041d4f297a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#a9213aedceda4c17381960d041d4f297a">mirror_vertex</a> (<a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> f, int i) const</td></tr>
<tr class="memdesc:a9213aedceda4c17381960d041d4f297a"><td class="mdescLeft"> </td><td class="mdescRight">returns the vertex of the \( i^{th}\) neighbor of <code>f</code> that is opposite to <code>f</code>.  <br></td></tr>
<tr class="separator:a9213aedceda4c17381960d041d4f297a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9c54807a29595dc1116054cc4ac214fd"><td class="memItemLeft" align="right" valign="top">int </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#a9c54807a29595dc1116054cc4ac214fd">mirror_index</a> (<a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> f, int i) const</td></tr>
<tr class="memdesc:a9c54807a29595dc1116054cc4ac214fd"><td class="mdescLeft"> </td><td class="mdescRight">returns the index of <code>f</code> in its \( i^{th}\) neighbor.  <br></td></tr>
<tr class="separator:a9c54807a29595dc1116054cc4ac214fd"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab97ce60b20674d0a7a4455e88c2eadb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__2.html#ad28c6e0e0e65b8aaecb1ae76d8744b33">Edge</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#ab97ce60b20674d0a7a4455e88c2eadb1">mirror_edge</a> (<a class="el" href="classCGAL_1_1Triangulation__2.html#ad28c6e0e0e65b8aaecb1ae76d8744b33">Edge</a> e) const</td></tr>
<tr class="memdesc:ab97ce60b20674d0a7a4455e88c2eadb1"><td class="mdescLeft"> </td><td class="mdescRight">returns the same edge seen from the other adjacent face.  <br></td></tr>
<tr class="separator:ab97ce60b20674d0a7a4455e88c2eadb1"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Miscellaneous</h2></td></tr>
<tr class="memitem:a38ffc4db3bc10b11ae77bbcd4fe21005"><td class="memItemLeft" align="right" valign="top">int </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#a38ffc4db3bc10b11ae77bbcd4fe21005">ccw</a> (int i) const</td></tr>
<tr class="memdesc:a38ffc4db3bc10b11ae77bbcd4fe21005"><td class="mdescLeft"> </td><td class="mdescRight">Returns \( i+1\) modulo 3.  <br></td></tr>
<tr class="separator:a38ffc4db3bc10b11ae77bbcd4fe21005"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a49fc8cd3cd899d0c0aa6bc0f20c72a0f"><td class="memItemLeft" align="right" valign="top">int </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#a49fc8cd3cd899d0c0aa6bc0f20c72a0f">cw</a> (int i) const</td></tr>
<tr class="memdesc:a49fc8cd3cd899d0c0aa6bc0f20c72a0f"><td class="mdescLeft"> </td><td class="mdescRight">Returns \( i+2\) modulo 3.  <br></td></tr>
<tr class="separator:a49fc8cd3cd899d0c0aa6bc0f20c72a0f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a176b3903b04aaad6996d1c2a56a14dcc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__2.html#a48984e6735c075b17d7a956cb396d1f5">Triangle</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#a176b3903b04aaad6996d1c2a56a14dcc">triangle</a> (<a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> f) const</td></tr>
<tr class="memdesc:a176b3903b04aaad6996d1c2a56a14dcc"><td class="mdescLeft"> </td><td class="mdescRight">Returns the triangle formed by the three vertices of <code>f</code>.  <br></td></tr>
<tr class="separator:a176b3903b04aaad6996d1c2a56a14dcc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac3beee6618a86505bfc03bcbfbb46a4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__2.html#ae7b5594c15ef61394d76826e1fc1e8e6">Segment</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#ac3beee6618a86505bfc03bcbfbb46a4a">segment</a> (<a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> f, int i) const</td></tr>
<tr class="memdesc:ac3beee6618a86505bfc03bcbfbb46a4a"><td class="mdescLeft"> </td><td class="mdescRight">Returns the line segment formed by the vertices <code>ccw(i)</code> and <code>cw(i)</code> of face <code>f</code>.  <br></td></tr>
<tr class="separator:ac3beee6618a86505bfc03bcbfbb46a4a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a06f3967c92db0fe28368c31ff671c658"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__2.html#ae7b5594c15ef61394d76826e1fc1e8e6">Segment</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#a06f3967c92db0fe28368c31ff671c658">segment</a> (const <a class="el" href="classCGAL_1_1Triangulation__2.html#ad28c6e0e0e65b8aaecb1ae76d8744b33">Edge</a> &amp;e) const</td></tr>
<tr class="memdesc:a06f3967c92db0fe28368c31ff671c658"><td class="mdescLeft"> </td><td class="mdescRight">Returns the line segment corresponding to edge <code>e</code>.  <br></td></tr>
<tr class="separator:a06f3967c92db0fe28368c31ff671c658"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad43c112fe392ea9194b449e6116499c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__2.html#ae7b5594c15ef61394d76826e1fc1e8e6">Segment</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#ad43c112fe392ea9194b449e6116499c5">segment</a> (const <a class="el" href="classCGAL_1_1Triangulation__2.html#a997ed97a0ac906a0342ad18c91a1ec81">Edge_circulator</a> &amp;ec) const</td></tr>
<tr class="memdesc:ad43c112fe392ea9194b449e6116499c5"><td class="mdescLeft"> </td><td class="mdescRight">Returns the line segment corresponding to edge <code>*ec</code>.  <br></td></tr>
<tr class="separator:ad43c112fe392ea9194b449e6116499c5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afd84762f5a856ebdbd9786de8744feda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__2.html#ae7b5594c15ef61394d76826e1fc1e8e6">Segment</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#afd84762f5a856ebdbd9786de8744feda">segment</a> (const Edge_iterator &amp;ei) const</td></tr>
<tr class="memdesc:afd84762f5a856ebdbd9786de8744feda"><td class="mdescLeft"> </td><td class="mdescRight">Returns the line segment corresponding to edge <code>*ei</code>.  <br></td></tr>
<tr class="separator:afd84762f5a856ebdbd9786de8744feda"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4185c75ba2c5ec34181fdef8fa57401c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__2.html#adf800f903a06c19d07d27afb2927fc71">Point</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#a4185c75ba2c5ec34181fdef8fa57401c">circumcenter</a> (<a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> f) const</td></tr>
<tr class="memdesc:a4185c75ba2c5ec34181fdef8fa57401c"><td class="mdescLeft"> </td><td class="mdescRight">Compute the circumcenter of the face pointed to by f.  <br></td></tr>
<tr class="separator:a4185c75ba2c5ec34181fdef8fa57401c"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Setting</h2></td></tr>
<tr class="memitem:a25a5eaabf6ba1d9c9acf240b4453c09a"><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#a25a5eaabf6ba1d9c9acf240b4453c09a">set_infinite_vertex</a> (const <a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> &amp;v)</td></tr>
<tr class="memdesc:a25a5eaabf6ba1d9c9acf240b4453c09a"><td class="mdescLeft"> </td><td class="mdescRight">This is an advanced function.  <br></td></tr>
<tr class="separator:a25a5eaabf6ba1d9c9acf240b4453c09a"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Checking</h2></td></tr>
<tr><td class="ititle" colspan="2"> <div class="CGALAdvanced"> <div>Advanced</div> <p>The responsibility of keeping a valid triangulation belongs to the users if advanced operations are used.</p>
<p>Obviously the advanced user, who implements higher levels operations may have to make a triangulation invalid at some times. The following method is provided to help the debugging. </p> </div>  </td></tr>
<tr class="memitem:a8bcea78e9ffd5cc836331c5021cd851a"><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__2.html#a8bcea78e9ffd5cc836331c5021cd851a">is_valid</a> (bool verbose=false, int level=0) const</td></tr>
<tr class="memdesc:a8bcea78e9ffd5cc836331c5021cd851a"><td class="mdescLeft"> </td><td class="mdescRight">Checks the combinatorial validity of the triangulation and also the validity of its geometric embedding.  <br></td></tr>
<tr class="separator:a8bcea78e9ffd5cc836331c5021cd851a"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_methods_classCGAL_1_1Triangulation__cw__ccw__2"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classCGAL_1_1Triangulation__cw__ccw__2')"><img src="closed.png" alt="-"> Public Member Functions inherited from <a class="el" href="classCGAL_1_1Triangulation__cw__ccw__2.html">CGAL::Triangulation_cw_ccw_2</a></td></tr>
<tr class="memitem:a7069704014f0d62aa327453e5bcfb44d inherit pub_methods_classCGAL_1_1Triangulation__cw__ccw__2"><td class="memItemLeft" align="right" valign="top"><a id="a7069704014f0d62aa327453e5bcfb44d" name="a7069704014f0d62aa327453e5bcfb44d"></a>
 </td><td class="memItemRight" valign="bottom"><b>Triangulation_cw_ccw_2</b> ()</td></tr>
<tr class="memdesc:a7069704014f0d62aa327453e5bcfb44d inherit pub_methods_classCGAL_1_1Triangulation__cw__ccw__2"><td class="mdescLeft"> </td><td class="mdescRight">default constructor. <br></td></tr>
<tr class="separator:a7069704014f0d62aa327453e5bcfb44d inherit pub_methods_classCGAL_1_1Triangulation__cw__ccw__2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af248465f1304095d3cd83cf14aa48898 inherit pub_methods_classCGAL_1_1Triangulation__cw__ccw__2"><td class="memItemLeft" align="right" valign="top"><a id="af248465f1304095d3cd83cf14aa48898" name="af248465f1304095d3cd83cf14aa48898"></a>
int </td><td class="memItemRight" valign="bottom"><b>ccw</b> (const int i) const</td></tr>
<tr class="memdesc:af248465f1304095d3cd83cf14aa48898 inherit pub_methods_classCGAL_1_1Triangulation__cw__ccw__2"><td class="mdescLeft"> </td><td class="mdescRight">returns the index of the neighbor or vertex that is next to the neighbor or vertex with index <code>i</code> in counterclockwise order around a face. <br></td></tr>
<tr class="separator:af248465f1304095d3cd83cf14aa48898 inherit pub_methods_classCGAL_1_1Triangulation__cw__ccw__2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a71e0431519f8b26787dde770ebdceac7 inherit pub_methods_classCGAL_1_1Triangulation__cw__ccw__2"><td class="memItemLeft" align="right" valign="top"><a id="a71e0431519f8b26787dde770ebdceac7" name="a71e0431519f8b26787dde770ebdceac7"></a>
int </td><td class="memItemRight" valign="bottom"><b>cw</b> (const int i) const</td></tr>
<tr class="memdesc:a71e0431519f8b26787dde770ebdceac7 inherit pub_methods_classCGAL_1_1Triangulation__cw__ccw__2"><td class="mdescLeft"> </td><td class="mdescRight">returns the index of the neighbor or vertex that is next to the neighbor or vertex with index <code>i</code> in counterclockwise order around a face. <br></td></tr>
<tr class="separator:a71e0431519f8b26787dde770ebdceac7 inherit pub_methods_classCGAL_1_1Triangulation__cw__ccw__2"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a22dbae3b466c50924759754de5865db6" name="a22dbae3b466c50924759754de5865db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22dbae3b466c50924759754de5865db6">◆ </a></span>Locate_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classCGAL_1_1Triangulation__2.html#a22dbae3b466c50924759754de5865db6">CGAL::Triangulation_2::Locate_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>specifies which case occurs when locating a point in the triangulation. </p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classCGAL_1_1Triangulation__2.html" title="The class Triangulation_2 is the basic class designed to handle triangulations of set of points  in t...">CGAL::Triangulation_2</a>&lt;Traits,Tds&gt;</code> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a22dbae3b466c50924759754de5865db6a4fc5b644a7c38197036955ba1662afe5" name="a22dbae3b466c50924759754de5865db6a4fc5b644a7c38197036955ba1662afe5"></a>VERTEX </td><td class="fielddoc"><p>when the located point coincides with a vertex of the triangulation </p>
</td></tr>
<tr><td class="fieldname"><a id="a22dbae3b466c50924759754de5865db6a5111882933f6615f618c8900e2bc6acf" name="a22dbae3b466c50924759754de5865db6a5111882933f6615f618c8900e2bc6acf"></a>EDGE </td><td class="fielddoc"><p>when the point is in the relative interior of an edge </p>
</td></tr>
<tr><td class="fieldname"><a id="a22dbae3b466c50924759754de5865db6a937da59ce47b08cfc0d452901e6c3625" name="a22dbae3b466c50924759754de5865db6a937da59ce47b08cfc0d452901e6c3625"></a>FACE </td><td class="fielddoc"><p>when the point is in the interior of a facet </p>
</td></tr>
<tr><td class="fieldname"><a id="a22dbae3b466c50924759754de5865db6afd690e18b1d2857068085d771fc354d4" name="a22dbae3b466c50924759754de5865db6afd690e18b1d2857068085d771fc354d4"></a>OUTSIDE_CONVEX_HULL </td><td class="fielddoc"><p>when the point is outside the convex hull but in the affine hull of the current triangulation </p>
</td></tr>
<tr><td class="fieldname"><a id="a22dbae3b466c50924759754de5865db6ae8b775f120094d9b0a6871f53446184f" name="a22dbae3b466c50924759754de5865db6ae8b775f120094d9b0a6871f53446184f"></a>OUTSIDE_AFFINE_HULL </td><td class="fielddoc"><p>when the point is outside the affine hull of the current triangulation. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6e43f49405b43057d1b911a9f6e39404" name="a6e43f49405b43057d1b911a9f6e39404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e43f49405b43057d1b911a9f6e39404">◆ </a></span>Triangulation_2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::Triangulation_2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__2.html">Triangulation_2</a>&lt; Traits, Tds &gt; &amp; </td>
          <td class="paramname"><em>tr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>All the vertices and faces are duplicated. After the copy, <code>*this</code> and <code>tr</code> refer to different triangulations: if <code>tr</code> is modified, <code>*this</code> is not. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae0bd242bbe0d505aa1f7c4c366d5d56f" name="ae0bd242bbe0d505aa1f7c4c366d5d56f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0bd242bbe0d505aa1f7c4c366d5d56f">◆ </a></span>all_face_handles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__2.html#a40f06313bd485eed99b6ba119da98bb5">All_face_handles</a> <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::all_face_handles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a range of iterators over all faces. </p>
<dl class="section note"><dt>Note</dt><dd>While the value type of <code>All_faces_iterator</code> is <code>Face</code>, the value type of <code><a class="elRef" href="../STL_Extension/classCGAL_1_1Iterator__range.html#a1d3ce46c713f038f903619aff460f828">All_face_handles::iterator</a></code> is <code>Face_handle</code>. </dd></dl>

</div>
</div>
<a id="abb3ae01ea08e705e49ced503e4a83026" name="abb3ae01ea08e705e49ced503e4a83026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb3ae01ea08e705e49ced503e4a83026">◆ </a></span>all_vertex_handles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__2.html#aaed9fdd0b481d9ec138548fb243752ab">All_vertex_handles</a> <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::all_vertex_handles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a range of iterators over all vertices. </p>
<dl class="section note"><dt>Note</dt><dd>While the value type of <code>All_vertices_iterator</code> is <code>Vertex</code>, the value type of <code><a class="elRef" href="../STL_Extension/classCGAL_1_1Iterator__range.html#a1d3ce46c713f038f903619aff460f828">All_vertex_handles::iterator</a></code> is <code>Vertex_handle</code>. </dd></dl>

</div>
</div>
<a id="a38ffc4db3bc10b11ae77bbcd4fe21005" name="a38ffc4db3bc10b11ae77bbcd4fe21005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38ffc4db3bc10b11ae77bbcd4fe21005">◆ </a></span>ccw()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::ccw </td>
          <td>(</td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns \( i+1\) modulo 3. </p>
<dl class="section pre"><dt>Precondition</dt><dd>\( 0\leq i \leq2\). </dd></dl>

</div>
</div>
<a id="a4185c75ba2c5ec34181fdef8fa57401c" name="a4185c75ba2c5ec34181fdef8fa57401c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4185c75ba2c5ec34181fdef8fa57401c">◆ </a></span>circumcenter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__2.html#adf800f903a06c19d07d27afb2927fc71">Point</a> <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::circumcenter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> </td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the circumcenter of the face pointed to by f. </p>
<p>This function is available only if the corresponding function is provided in the geometric traits. </p>

</div>
</div>
<a id="a49fc8cd3cd899d0c0aa6bc0f20c72a0f" name="a49fc8cd3cd899d0c0aa6bc0f20c72a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49fc8cd3cd899d0c0aa6bc0f20c72a0f">◆ </a></span>cw()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::cw </td>
          <td>(</td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns \( i+2\) modulo 3. </p>
<dl class="section pre"><dt>Precondition</dt><dd>\( 0\leq i \leq2\). </dd></dl>

</div>
</div>
<a id="a01c421302be46c33fd6d8de75945a1ad" name="a01c421302be46c33fd6d8de75945a1ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01c421302be46c33fd6d8de75945a1ad">◆ </a></span>finite_face_handles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__2.html#ae89fd1a46ae755c79ac650fc41f6d3dd">Finite_face_handles</a> <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::finite_face_handles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a range of iterators over finite faces. </p>
<dl class="section note"><dt>Note</dt><dd>While the value type of <code>Finite_faces_iterator</code> is <code>Face</code>, the value type of <code><a class="elRef" href="../STL_Extension/classCGAL_1_1Iterator__range.html#a1d3ce46c713f038f903619aff460f828">Finite_face_handles::iterator</a></code> is <code>Face_handle</code>. </dd></dl>

</div>
</div>
<a id="a742d528593275c1fe119979b4ce74a90" name="a742d528593275c1fe119979b4ce74a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a742d528593275c1fe119979b4ce74a90">◆ </a></span>finite_vertex_handles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__2.html#a07f0b236b51b0e8a69512561dc12734a">Finite_vertex_handles</a> <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::finite_vertex_handles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a range of iterators over finite vertices. </p>
<dl class="section note"><dt>Note</dt><dd>While the value type of <code>Finite_vertices_iterator</code> is <code>Vertex</code>, the value type of <code><a class="elRef" href="../STL_Extension/classCGAL_1_1Iterator__range.html#a1d3ce46c713f038f903619aff460f828">Finite_vertex_handles::iterator</a></code> is <code>Vertex_handle</code>. </dd></dl>

</div>
</div>
<a id="aa47a446fc11809d30146fbcdb689a396" name="aa47a446fc11809d30146fbcdb689a396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa47a446fc11809d30146fbcdb689a396">◆ </a></span>flip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::flip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> </td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>i</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exchanges the edge incident to <code>f</code> and <code>f-&gt;neighbor(i)</code> with the other diagonal of the quadrilateral formed by <code>f</code> and <code>f-&gt;neighbor(i)</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The faces <code>f</code> and <code>f-&gt;neighbor(i)</code> are finite faces and their union form a convex quadrilateral. </dd></dl>

</div>
</div>
<a id="a843853eb19644389ba8d6024765eb4f7" name="a843853eb19644389ba8d6024765eb4f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a843853eb19644389ba8d6024765eb4f7">◆ </a></span>incident_edges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__2.html#a997ed97a0ac906a0342ad18c91a1ec81">Edge_circulator</a> <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::incident_edges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> </td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> </td>
          <td class="paramname"><em>f</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts at the first edge of <code>f</code> incident to <code>v</code>, in counterclockwise order around <code>v</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Face <code>f</code> is incident to vertex <code>v</code>. </dd></dl>

</div>
</div>
<a id="a341c4f3888b6ede6b9df55c2bb745ca3" name="a341c4f3888b6ede6b9df55c2bb745ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a341c4f3888b6ede6b9df55c2bb745ca3">◆ </a></span>incident_faces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__2.html#a1bda2ab92ccf638bb22fc223ae281b96">Face_circulator</a> <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::incident_faces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> </td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> </td>
          <td class="paramname"><em>f</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts at face <code>f</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Face <code>f</code> is incident to vertex <code>v</code>. </dd></dl>

</div>
</div>
<a id="a58c9a0c9f69a356a31c8a7c02eff1841" name="a58c9a0c9f69a356a31c8a7c02eff1841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58c9a0c9f69a356a31c8a7c02eff1841">◆ </a></span>incident_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__2.html#ade901d47c7c422f7978adf3ac0188a9d">Vertex_circulator</a> <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::incident_vertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> </td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> </td>
          <td class="paramname"><em>f</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts at the first vertex of <code>f</code> adjacent to <code>v</code> in counterclockwise order around <code>v</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Face <code>f</code> is incident to vertex <code>v</code>. </dd></dl>

</div>
</div>
<a id="a171d77fc26d48860fa8a5711000ee690" name="a171d77fc26d48860fa8a5711000ee690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a171d77fc26d48860fa8a5711000ee690">◆ </a></span>includes_edge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::includes_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> </td>
          <td class="paramname"><em>va</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> </td>
          <td class="paramname"><em>vb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> &amp; </td>
          <td class="paramname"><em>vbb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> &amp; </td>
          <td class="paramname"><em>fr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp; </td>
          <td class="paramname"><em>i</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>true</code> if the line segment from <code>va</code> to <code>vb</code> includes an edge <code>e</code> incident to <code>va</code>. </p>
<p>If <code>true</code>, <code>vbb</code> becomes the other vertex of <code>e</code>, <code>e</code> is the edge <code>(fr,i)</code> where <code>fr</code> is a handle to the face incident to <code>e</code> and on the right side <code>e</code> oriented from <code>va</code> to <code>vb</code>. </p>

</div>
</div>
<a id="a0d62215704e84f18ef9294b27f9e82b0" name="a0d62215704e84f18ef9294b27f9e82b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d62215704e84f18ef9294b27f9e82b0">◆ </a></span>inexact_locate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::inexact_locate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__2.html#adf800f903a06c19d07d27afb2927fc71">Point</a> &amp; </td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> </td>
          <td class="paramname"><em>start</em> = <code><a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a>()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <code><a class="el" href="classCGAL_1_1Triangulation__2.html#a940567120751e7864c7b345eaf756642" title="If the point query lies inside the convex hull of the points, a face that contains the query in its i...">locate()</a></code> but uses inexact predicates. </p>
<p>This function returns a handle on a face that is a good approximation of the exact location of <code>query</code>, while being faster. Note that it may return a handle on a face whose interior does not contain <code>query</code>. When the triangulation has dimension smaller than 2, <code>start</code> is returned. </p>

</div>
</div>
<a id="a1025cd7e7226ccb44d82f0fb1d63ad4e" name="a1025cd7e7226ccb44d82f0fb1d63ad4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1025cd7e7226ccb44d82f0fb1d63ad4e">◆ </a></span>insert() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__2.html#adf800f903a06c19d07d27afb2927fc71">Point</a> &amp; </td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> </td>
          <td class="paramname"><em>f</em> = <code><a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a>()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts point <code>p</code> in the triangulation and returns the corresponding vertex. </p>
<p>If point <code>p</code> coincides with an already existing vertex, this vertex is returned and the triangulation remains unchanged.</p>
<p>If point <code>p</code> is on an edge, the two incident faces are split in two.</p>
<p>If point <code>p</code> is strictly inside a face of the triangulation, the face is split in three.</p>
<p>If point <code>p</code> is strictly outside the convex hull, <code>p</code> is linked to all visible points on the convex hull to form the new triangulation.</p>
<p>At last, if <code>p</code> is outside the affine hull (in case of degenerate 1-dimensional or 0-dimensional triangulations), <code>p</code> is linked all the other vertices to form a triangulation whose dimension is increased by one. The last argument <code>f</code> is an indication to the underlying locate algorithm of where to start. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Triangulation_2_2adding_handles_8cpp-example.html#a3">Triangulation_2/adding_handles.cpp</a>, <a class="el" href="Triangulation_2_2colored_face_8cpp-example.html#a5">Triangulation_2/colored_face.cpp</a>, and <a class="el" href="Triangulation_2_2for_loop_2_8cpp-example.html#a2">Triangulation_2/for_loop_2.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a02f3c7c337f38cd9b534e6807856c106" name="a02f3c7c337f38cd9b534e6807856c106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02f3c7c337f38cd9b534e6807856c106">◆ </a></span>insert() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
<div class="memtemplate">
template&lt;class PointInputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ptrdiff_t <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">PointInputIterator </td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointInputIterator </td>
          <td class="paramname"><em>last</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the points in the range <code>[first,last)</code> in the given order, and returns the number of inserted points. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointInputIterator</td><td>must be an input iterator with value type <code>Point</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5e9bc8adef80dc01a0b31c2d0234545" name="ac5e9bc8adef80dc01a0b31c2d0234545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5e9bc8adef80dc01a0b31c2d0234545">◆ </a></span>insert() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
<div class="memtemplate">
template&lt;class PointWithInfoInputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ptrdiff_t <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">PointWithInfoInputIterator </td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointWithInfoInputIterator </td>
          <td class="paramname"><em>last</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>inserts the points in the iterator range <code>[first,last)</code> in the given order, and returns the number of inserted points. </p>
<p>Given a pair <code>(p,i)</code>, the vertex <code>v</code> storing <code>p</code> also stores <code>i</code>, that is <code>v.point() == p</code> and <code>v.info() == i</code>. If several pairs have the same point, only one vertex is created, and one of the objects of type <code>Vertex::Info</code> will be stored in the vertex. </p><dl class="section pre"><dt>Precondition</dt><dd><code>Vertex</code> must be model of the concept <code><a class="el" href="classTriangulationVertexBaseWithInfo__2.html" title="A type model of this concept can be used as vertex base by a triangulation and provides an additional...">TriangulationVertexBaseWithInfo_2</a></code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointWithInfoInputIterator</td><td>must be an input iterator with the value type <code>std::pair&lt;Point,Vertex::Info&gt;</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aefd64b3be7364535e808ed62faaa6a67" name="aefd64b3be7364535e808ed62faaa6a67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefd64b3be7364535e808ed62faaa6a67">◆ </a></span>insert_in_edge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::insert_in_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__2.html#adf800f903a06c19d07d27afb2927fc71">Point</a> &amp; </td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> </td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>i</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts vertex v in edge <code>i</code> of <code>f</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The point in vertex <code>v</code> lies on the edge opposite to the vertex <code>i</code> of face <code>f</code>. </dd></dl>

</div>
</div>
<a id="a8f4a1ca36147ac331db5be089e17a2a5" name="a8f4a1ca36147ac331db5be089e17a2a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f4a1ca36147ac331db5be089e17a2a5">◆ </a></span>insert_in_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::insert_in_face </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__2.html#adf800f903a06c19d07d27afb2927fc71">Point</a> &amp; </td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> </td>
          <td class="paramname"><em>f</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts vertex <code>v</code> in face <code>f</code>. </p>
<p>Face <code>f</code> is modified, two new faces are created. </p><dl class="section pre"><dt>Precondition</dt><dd>The point in vertex <code>v</code> lies inside face <code>f</code>. </dd></dl>

</div>
</div>
<a id="a2c35ed5fa9ea46b55687c36a4755d592" name="a2c35ed5fa9ea46b55687c36a4755d592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c35ed5fa9ea46b55687c36a4755d592">◆ </a></span>insert_outside_convex_hull()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::insert_outside_convex_hull </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__2.html#adf800f903a06c19d07d27afb2927fc71">Point</a> &amp; </td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> </td>
          <td class="paramname"><em>f</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a point which is outside the convex hull but in the affine hull. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The handle <code>f</code> points to a face which is a proof of the location of<code>p</code>, see the description of the <code>locate</code> method above. </dd></dl>

</div>
</div>
<a id="adbeb9736f9bfc588658316669cd7fb44" name="adbeb9736f9bfc588658316669cd7fb44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbeb9736f9bfc588658316669cd7fb44">◆ </a></span>is_edge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::is_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> </td>
          <td class="paramname"><em>va</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> </td>
          <td class="paramname"><em>vb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> &amp; </td>
          <td class="paramname"><em>fr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp; </td>
          <td class="paramname"><em>i</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>as above. </p>
<p>In addition, if <code>true</code> is returned, the edge with vertices <code>va</code> and <code>vb</code> is the edge <code>e=(fr,i)</code> where <code>fr</code> is a handle to the face incident to <code>e</code> and on the right side of <code>e</code> oriented from <code>va</code> to <code>vb</code>. </p>

</div>
</div>
<a id="a4084823ee026d7a00a3991cd2b553fe0" name="a4084823ee026d7a00a3991cd2b553fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4084823ee026d7a00a3991cd2b553fe0">◆ </a></span>is_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::is_face </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> </td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> </td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> </td>
          <td class="paramname"><em>v3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> &amp; </td>
          <td class="paramname"><em>fr</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>as above. </p>
<p>In addition, if <code>true</code> is returned, fr is a handle to the face with <code>v1</code>, <code>v2</code> and <code>v3</code> as vertices. </p>

</div>
</div>
<a id="a8bcea78e9ffd5cc836331c5021cd851a" name="a8bcea78e9ffd5cc836331c5021cd851a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bcea78e9ffd5cc836331c5021cd851a">◆ </a></span>is_valid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::is_valid </td>
          <td>(</td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>verbose</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>level</em> = <code>0</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the combinatorial validity of the triangulation and also the validity of its geometric embedding. </p>
<p>This method is mainly a debugging help for the users of advanced features. </p>

</div>
</div>
<a id="a41a46211193d767f122504f2eb99189a" name="a41a46211193d767f122504f2eb99189a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41a46211193d767f122504f2eb99189a">◆ </a></span>line_walk()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__2.html#ad720b1a9adc835ed1a27c228eea1e36c">Line_face_circulator</a> <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::line_walk </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__2.html#adf800f903a06c19d07d27afb2927fc71">Point</a> &amp; </td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__2.html#adf800f903a06c19d07d27afb2927fc71">Point</a> &amp; </td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> </td>
          <td class="paramname"><em>f</em> = <code><a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a>()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns a circulator that allows to visit the faces intersected by the line <code>pq</code>. </p>
<p>If there is no such face the circulator has a singular value.</p>
<p>The starting point of the circulator is the face <code>f</code>, or the first finite face traversed by <code>l</code> , if <code>f</code> is omitted.</p>
<p>The circulator wraps around the infinite vertex: after the last traversed finite face, it steps through the infinite face adjacent to this face then through the infinite face adjacent to the first traversed finite face then through the first finite traversed face again. </p><dl class="section pre"><dt>Precondition</dt><dd>The triangulation must have dimension 2. </dd>
<dd>
Points <code>p</code> and <code>q</code> must be different points. </dd>
<dd>
If <code>f != nullptr</code>, it must point to a finite face and the point <code>p</code> must be inside or on the boundary of <code>f</code>. </dd></dl>

</div>
</div>
<a id="a940567120751e7864c7b345eaf756642" name="a940567120751e7864c7b345eaf756642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a940567120751e7864c7b345eaf756642">◆ </a></span>locate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::locate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__2.html#adf800f903a06c19d07d27afb2927fc71">Point</a> &amp; </td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> </td>
          <td class="paramname"><em>f</em> = <code><a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a>()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the point <code>query</code> lies inside the convex hull of the points, a face that contains the query in its interior or on its boundary is returned. </p>
<p>If the point <code>query</code> lies outside the convex hull of the triangulation but in the affine hull, the returned face is an infinite face which is a proof of the point's location:</p>
<ul>
<li>for a two dimensional triangulation, it is a face \( (\infty, p, q)\) such that <code>query</code> lies to the left of the oriented line \( pq\) (the rest of the triangulation lying to the right of this line).</li>
<li>for a degenerate one dimensional triangulation it is the (degenerate one dimensional) face \( (\infty, p, nullptr)\) such that <code>query</code> and the triangulation lie on either side of <code>p</code>.</li>
</ul>
<p>If the point <code>query</code> lies outside the affine hull, the returned <code>Face_handle</code> is <code>nullptr</code>.</p>
<p>The optional <code>Face_handle</code> argument, if provided, is used as a hint of where the locate process has to start its search. </p>

</div>
</div>
<a id="af61a05a0a53d009e111a3873c1796b52" name="af61a05a0a53d009e111a3873c1796b52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af61a05a0a53d009e111a3873c1796b52">◆ </a></span>locate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::locate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__2.html#adf800f903a06c19d07d27afb2927fc71">Point</a> &amp; </td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__2.html#a22dbae3b466c50924759754de5865db6">Locate_type</a> &amp; </td>
          <td class="paramname"><em>lt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp; </td>
          <td class="paramname"><em>li</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> </td>
          <td class="paramname"><em>h</em> = <code><a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a>()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as above. </p>
<p>Additionally, the parameters <code>lt</code> and <code>li</code> describe where the query point is located. The variable <code>lt</code> is set to the locate type of the query. If <code>lt==VERTEX</code> the variable <code>li</code> is set to the index of the vertex, and if <code>lt==EDGE</code> <code>li</code> is set to the index of the vertex opposite to the edge. Be careful that <code>li</code> has no meaning when the query type is <code>FACE</code>, <code>OUTSIDE_CONVEX_HULL</code>, or <code>OUTSIDE_AFFINE_HULL</code> or when the triangulation is \( 0\)-dimensional. </p>

</div>
</div>
<a id="ab97ce60b20674d0a7a4455e88c2eadb1" name="ab97ce60b20674d0a7a4455e88c2eadb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab97ce60b20674d0a7a4455e88c2eadb1">◆ </a></span>mirror_edge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__2.html#ad28c6e0e0e65b8aaecb1ae76d8744b33">Edge</a> <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::mirror_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__2.html#ad28c6e0e0e65b8aaecb1ae76d8744b33">Edge</a> </td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the same edge seen from the other adjacent face. </p>
<dl class="section pre"><dt>Precondition</dt><dd>\( 0\leq i \leq2\). </dd></dl>

</div>
</div>
<a id="a9c54807a29595dc1116054cc4ac214fd" name="a9c54807a29595dc1116054cc4ac214fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c54807a29595dc1116054cc4ac214fd">◆ </a></span>mirror_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::mirror_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> </td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>i</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the index of <code>f</code> in its \( i^{th}\) neighbor. </p>
<dl class="section pre"><dt>Precondition</dt><dd>\( 0\leq i \leq2\). </dd></dl>

</div>
</div>
<a id="a9213aedceda4c17381960d041d4f297a" name="a9213aedceda4c17381960d041d4f297a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9213aedceda4c17381960d041d4f297a">◆ </a></span>mirror_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::mirror_vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> </td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>i</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the vertex of the \( i^{th}\) neighbor of <code>f</code> that is opposite to <code>f</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>\( 0\leq i \leq2\). </dd></dl>

</div>
</div>
<a id="a62de40896ebe056bbf008eb4090eb76b" name="a62de40896ebe056bbf008eb4090eb76b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62de40896ebe056bbf008eb4090eb76b">◆ </a></span>move()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::move </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> </td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__2.html#adf800f903a06c19d07d27afb2927fc71">Point</a> &amp; </td>
          <td class="paramname"><em>p</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If there is no collision during the move, this function is the same as <code>move_if_no_collision</code> . </p>
<p>Otherwise, <code>v</code> is removed and the vertex at point <code>p</code> is returned. </p><dl class="section pre"><dt>Precondition</dt><dd>Vertex <code>v</code> must be finite. </dd></dl>

</div>
</div>
<a id="a433cff4ceaeaba390df1a968d93a4899" name="a433cff4ceaeaba390df1a968d93a4899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a433cff4ceaeaba390df1a968d93a4899">◆ </a></span>move_if_no_collision()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::move_if_no_collision </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> </td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__2.html#adf800f903a06c19d07d27afb2927fc71">Point</a> &amp; </td>
          <td class="paramname"><em>p</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If there is not already another vertex placed on <code>p</code>, the triangulation is modified such that the new position of vertex <code>v</code> is <code>p</code>, and <code>v</code> is returned. </p>
<p>Otherwise, the triangulation is not modified and the vertex at point <code>p</code> is returned. </p><dl class="section pre"><dt>Precondition</dt><dd>Vertex <code>v</code> must be finite. </dd></dl>

</div>
</div>
<a id="a40701ad345813f8df044fd197d3c9d96" name="a40701ad345813f8df044fd197d3c9d96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40701ad345813f8df044fd197d3c9d96">◆ </a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__2.html">Triangulation_2</a> <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__2.html">Triangulation_2</a>&lt; Traits, Tds &gt; &amp; </td>
          <td class="paramname"><em>tr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment. </p>
<p>All the vertices and faces are duplicated. After the assignment, <code>*this</code> and <code>tr</code> refer to different triangulations: if <code>tr</code> is modified, <code>*this</code> is not. </p>

</div>
</div>
<a id="a01fbafc011677846a729a809b4b21a99" name="a01fbafc011677846a729a809b4b21a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01fbafc011677846a729a809b4b21a99">◆ </a></span>oriented_side()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="../Kernel_23/group__kernel__enums.html#ga5006dd2552d97fa577d81bd819c0f979">Oriented_side</a> <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::oriented_side </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> </td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__2.html#adf800f903a06c19d07d27afb2927fc71">Point</a> &amp; </td>
          <td class="paramname"><em>p</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns on which side of the oriented boundary of <code>f</code> lies the point <code>p</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>f</code> is finite. </dd></dl>

</div>
</div>
<a id="a9a5dc75ed6ce4a645a5b61e5a8e88974" name="a9a5dc75ed6ce4a645a5b61e5a8e88974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a5dc75ed6ce4a645a5b61e5a8e88974">◆ </a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> </td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the vertex from the triangulation. </p>
<p>The created hole is re-triangulated. </p><dl class="section pre"><dt>Precondition</dt><dd>Vertex <code>v</code> must be finite. </dd></dl>

</div>
</div>
<a id="a4b3389b24fe7bfe703151375d15a745a" name="a4b3389b24fe7bfe703151375d15a745a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b3389b24fe7bfe703151375d15a745a">◆ </a></span>remove_degree_3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::remove_degree_3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> </td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a vertex of degree three. </p>
<p>Two of the incident faces are destroyed, the third one is modified. </p><dl class="section pre"><dt>Precondition</dt><dd>Vertex <code>v</code> is a finite vertex with degree three. </dd></dl>

</div>
</div>
<a id="a06f3967c92db0fe28368c31ff671c658" name="a06f3967c92db0fe28368c31ff671c658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06f3967c92db0fe28368c31ff671c658">◆ </a></span>segment() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__2.html#ae7b5594c15ef61394d76826e1fc1e8e6">Segment</a> <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::segment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__2.html#ad28c6e0e0e65b8aaecb1ae76d8744b33">Edge</a> &amp; </td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the line segment corresponding to edge <code>e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>e</code> is a finite edge. </dd></dl>

</div>
</div>
<a id="ad43c112fe392ea9194b449e6116499c5" name="ad43c112fe392ea9194b449e6116499c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43c112fe392ea9194b449e6116499c5">◆ </a></span>segment() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__2.html#ae7b5594c15ef61394d76826e1fc1e8e6">Segment</a> <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::segment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__2.html#a997ed97a0ac906a0342ad18c91a1ec81">Edge_circulator</a> &amp; </td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the line segment corresponding to edge <code>*ec</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*ec</code> is a finite edge. </dd></dl>

</div>
</div>
<a id="afd84762f5a856ebdbd9786de8744feda" name="afd84762f5a856ebdbd9786de8744feda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd84762f5a856ebdbd9786de8744feda">◆ </a></span>segment() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__2.html#ae7b5594c15ef61394d76826e1fc1e8e6">Segment</a> <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::segment </td>
          <td>(</td>
          <td class="paramtype">const Edge_iterator &amp; </td>
          <td class="paramname"><em>ei</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the line segment corresponding to edge <code>*ei</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>*ei</code> is a finite edge. </dd></dl>

</div>
</div>
<a id="ac3beee6618a86505bfc03bcbfbb46a4a" name="ac3beee6618a86505bfc03bcbfbb46a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3beee6618a86505bfc03bcbfbb46a4a">◆ </a></span>segment() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__2.html#ae7b5594c15ef61394d76826e1fc1e8e6">Segment</a> <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::segment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> </td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>i</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the line segment formed by the vertices <code>ccw(i)</code> and <code>cw(i)</code> of face <code>f</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>\( 0\leq i \leq2\). The vertices <code>ccw(i)</code> and <code>cw(i)</code> of <code>f</code> are finite. </dd></dl>

</div>
</div>
<a id="a25a5eaabf6ba1d9c9acf240b4453c09a" name="a25a5eaabf6ba1d9c9acf240b4453c09a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25a5eaabf6ba1d9c9acf240b4453c09a">◆ </a></span>set_infinite_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::set_infinite_vertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> &amp; </td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an advanced function. </p>
 <div class="CGALAdvanced"> <div>Advanced</div> <p>This method is meant to be used only if you have done a low-level operation on the underlying tds that invalidated the infinite vertex. Sets the infinite vertex. </p> </div>  
</div>
</div>
<a id="abc885b3d116e1d0b6943b211e750e472" name="abc885b3d116e1d0b6943b211e750e472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc885b3d116e1d0b6943b211e750e472">◆ </a></span>side_of_oriented_circle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="../Kernel_23/group__kernel__enums.html#ga5006dd2552d97fa577d81bd819c0f979">Oriented_side</a> <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::side_of_oriented_circle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> </td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__2.html#adf800f903a06c19d07d27afb2927fc71">Point</a> &amp; </td>
          <td class="paramname"><em>p</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns on which side of the circumcircle of face <code>f</code> lies the point <code>p</code>. </p>
<p>The circle is assumed to be counterclockwise oriented, so its positive side correspond to its bounded side. This predicate is available only if the corresponding predicates on points is provided in the geometric traits class. </p>

</div>
</div>
<a id="a8b058b055ef24a4b6fc25bf110e46638" name="a8b058b055ef24a4b6fc25bf110e46638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b058b055ef24a4b6fc25bf110e46638">◆ </a></span>star_hole() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
<div class="memtemplate">
template&lt;class EdgeIt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::star_hole </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__2.html#adf800f903a06c19d07d27afb2927fc71">Point</a> </td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeIt </td>
          <td class="paramname"><em>edge_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeIt </td>
          <td class="paramname"><em>edge_end</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a new vertex <code>v</code> and use it to star the hole whose boundary is described by the sequence of edges <code>[edge_begin, edge_end)</code>. </p>
<p>Returns a handle to the new vertex.</p>
<p>This function is intended to be used in conjunction with the <code>find_conflicts()</code> member functions of Delaunay and constrained Delaunay triangulations to perform insertions. </p>

</div>
</div>
<a id="a4511afae77c0c2978b6412d9411e4fe2" name="a4511afae77c0c2978b6412d9411e4fe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4511afae77c0c2978b6412d9411e4fe2">◆ </a></span>star_hole() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
<div class="memtemplate">
template&lt;class EdgeIt , class FaceIt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__2.html#aa7993454afb8684835b6ca96731a9eca">Vertex_handle</a> <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::star_hole </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__2.html#adf800f903a06c19d07d27afb2927fc71">Point</a> </td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeIt </td>
          <td class="paramname"><em>edge_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeIt </td>
          <td class="paramname"><em>edge_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FaceIt </td>
          <td class="paramname"><em>face_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FaceIt </td>
          <td class="paramname"><em>face_end</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>same as above, except that the algorithm first recycles faces in the sequence <code>[face_begin, face_end)</code> and create new ones only when the sequence is exhausted. </p>
<p>This function is intended to be used in conjunction with the <code>find_conflicts()</code> member functions of Delaunay and constrained Delaunay triangulations to perform insertions. </p>

</div>
</div>
<a id="a1788d6ffa3f5986b2b07e7e0b48a2ffc" name="a1788d6ffa3f5986b2b07e7e0b48a2ffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1788d6ffa3f5986b2b07e7e0b48a2ffc">◆ </a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__2.html">Triangulation_2</a>&lt; Traits, Tds &gt; &amp; </td>
          <td class="paramname"><em>tr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The triangulations <code>tr</code> and <code>*this</code> are swapped. </p>
<p>This method should be used instead of assignment of copy constructor. if <code>tr</code> is deleted after that. </p>

</div>
</div>
<a id="a176b3903b04aaad6996d1c2a56a14dcc" name="a176b3903b04aaad6996d1c2a56a14dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a176b3903b04aaad6996d1c2a56a14dcc">◆ </a></span>triangle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__2.html#a48984e6735c075b17d7a956cb396d1f5">Triangle</a> <a class="el" href="classCGAL_1_1Triangulation__2.html">CGAL::Triangulation_2</a>&lt; Traits, Tds &gt;::triangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__2.html#aaa702188ca1171deece65da34c8f134b">Face_handle</a> </td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the triangle formed by the three vertices of <code>f</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The face is finite. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ac7351668deed7464974684ab3c7147ea" name="ac7351668deed7464974684ab3c7147ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7351668deed7464974684ab3c7147ea">◆ </a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp; </td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__2.html">Triangulation_2</a>&lt; Traits, Tds &gt; &amp; </td>
          <td class="paramname"><em>T</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the triangulation into the stream <code>os</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The insert operator must be defined for <code>Point</code>. </dd></dl>

</div>
</div>
<a id="a8dc99f907cc125ce7a55024da5ddb4c0" name="a8dc99f907cc125ce7a55024da5ddb4c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dc99f907cc125ce7a55024da5ddb4c0">◆ </a></span>operator&gt;&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename Tds &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">istream &amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">istream &amp; </td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__2.html">Triangulation_2</a>&lt; Traits, Tds &gt; &amp; </td>
          <td class="paramname"><em>T</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a triangulation from stream <code>is</code> and assigns it to the triangulation. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The extract operator must be defined for <code>Point</code>. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>CGAL</b></li><li class="navelem"><a class="el" href="classCGAL_1_1Triangulation__2.html">Triangulation_2</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"></a> 1.9.6 </li>
  </ul>
</div>
</div>
</body>



</html>
