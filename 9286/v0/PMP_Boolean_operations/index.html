<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/PMP_Boolean_operations/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=11">
<meta name="generator" content="Doxygen 1.9.6">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CGAL 6.2 - Boolean Operations on Meshes: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/doxygen.css" rel="stylesheet" type="text/css">
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      },
      equationNumbers: { autoNumber: "AMS" }
  }
}
);
MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
  var PARSE = MathJax.InputJax.TeX.Parse,
      TEXT = PARSE.prototype.InternalText;
  PARSE.Augment({
    InternalText: function (text,def) {
      text = text.replace(/\\/g,"");
      return TEXT.call(this,text,def);
    }
  });
});
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
      <span class="left">
         <span id="MSearchSelect" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"> 
        </span>
        <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
      </span>
      <span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.svg" alt=""></a>
      </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CGAL 6.2 - Boolean Operations on Meshes
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search/",'.html');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">User Manual </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_PMPBooleanOperations"></a> </p> <div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Authors</dt><dd>Sébastien Loriot, Léo Valque, and Ilker O. Yaz</dd></dl>
<p><a class="anchor" id="fig__PMPBoolOPBanner"></a></p><center> <img src="david_bool_op.png" alt="" style="max-width:70%;" class="inline"> </center><h1><a class="anchor" id="Introduction"></a>
Introduction</h1>
<p>The computation of mesh Boolean operations is one of the most essential parts of the geometry processing toolkit, with numerous applications in CAD and computer graphics. As an example, it constitutes the essential operation of Constructive Solid Geometry (CSG).</p>
<p>This CGAL package offers functions to compute the union, intersection, and difference of volumes bounded by triangle meshes. The core of the method is the <em>corefinement</em> technique, which refines two meshes such that they become conformal. This technique is re-used to also propose functions that enable trimming a mesh ("clipping") and bisecting a mesh ("splitting") with a plane, a box, or another mesh.</p>
<h2><a class="anchor" id="PMPBoolOpOutline"></a>
Outline</h2>
<p>We begin by introducing the core concepts of this package in <a class="el" href="index.html#coref_def_subsec">Definitions</a>. Mesh Boolean functions and their input requirements are described in <a class="el" href="index.html#coref_bolop_subsec">Computing Mesh Boolean Operations</a>, and the guarantees on the output are discussed in <a class="el" href="index.html#coref_valid_subsec">Kernel Choice and Output Validity</a>. Related functions for clipping, splitting, and slicing are documented in <a class="el" href="index.html#coref_clip">Clipping and Splitting Meshes</a> and <a class="el" href="index.html#PMPSlicer">Slicer</a>.</p>
<h1><a class="anchor" id="PMPBoolOpDef"></a>
Core Concepts and Definitions</h1>
<h2><a class="anchor" id="coref_def_subsec"></a>
Definitions</h2>
<p><b>Corefinement</b>: Given two triangulated surface meshes, the <em>corefinement</em> of these two meshes consists in refining both meshes such that their intersection polylines form a subset of the edges of both refined meshes.</p>
<p><b>Autorefinement</b>: Given a triangle mesh or a triangle soup, the <em>autorefinement</em> consists in refining the mesh/soup such that all intersections between triangles form a subset of the edges of the output.</p>
<p><a class="anchor" id="fig__coref_fig"></a> </p><div class="image">
<img src="corefine.png" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__coref_fig">Figure 76.2</a> Corefinement of two triangulated surface meshes. (Left) Input meshes; (Right) The two input meshes after corefinement. The common edges of the two meshes are drawn in green. </p> </div> <p> <br>
</p>
<p><b>Volume bounded by a triangulated surface mesh</b> Given a closed triangulated surface mesh, each connected component splits the 3D space into two subspaces. The vertex sequence of each face of a component is seen either clockwise or counterclockwise from these two subspaces. The subspace that sees the sequence in a clockwise (resp. counterclockwise) manner is on the negative (resp. positive) side of the component. Given a closed triangulated surface mesh <code>tm</code> with no self-intersections, the connected components of <code>tm</code> divide the 3D space into subspaces. We say that <code>tm</code> bounds a volume if each subspace lies exclusively on the positive (or negative) side of all the incident connected components of <code>tm</code>. The volume bounded by <code>tm</code> is the union of all subspaces that are on negative sides of their incident connected components of <code>tm</code>.</p>
<p><a class="anchor" id="fig__boundedvol_fig"></a> </p><div class="image">
<img src="bounded_vols.jpg" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__boundedvol_fig">Figure 76.3</a> Volumes bounded by a triangulated surface mesh: The figure shows meshes representing three nested spheres (three connected components). The left side of the picture shows a clipped triangulated surface mesh, with the two possible orientations of the faces for which a volume is bounded by the mesh. The positive and negative sides of each connected component are displayed in light and dark blue, respectively. The right part of the picture shows clipped tetrahedral meshes of the corresponding bounded volumes. </p> </div> <p> <br>
</p>
<h1><a class="anchor" id="coref_coref_sec"></a>
Mesh Boolean Operations</h1>
<h2><a class="anchor" id="coref_coref_subsec"></a>
Computing Corefinement and Autorefinement</h2>
<p>Corefinement of two triangulated surface meshes can be performed using the function <code><a class="el" href="group__PMP__boolop__grp.html#ga54baccf4fbd1b1ada67465ec1d4bddc1" title="corefines  tm1 and tm2.">CGAL::Polygon_mesh_processing::corefine()</a></code>. If constrained edge maps are provided, edges belonging to the intersection of the input meshes will be marked as constrained. Additionally, if a constrained edge is split during corefinement, the resulting sub-edges will also be marked as constrained.</p>
<p><b>Example: </b> <a class="el" href="PMP_Boolean_operations_2corefinement_SM_8cpp-example.html">PMP_Boolean_operations/corefinement_SM.cpp</a> <br>
</p><details>
<summary>
Show / Hide</summary>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/corefinement.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/IO/polygon_mesh_io.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>   K;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;K::Point_3&gt;</a>                        Mesh;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>PMP = CGAL::Polygon_mesh_processing;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> std::string filename1 = (argc &gt; 1) ? argv[1] : <a class="code hl_functionRef" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/blobby.off"</span>);</div>
<div class="line">  <span class="keyword">const</span> std::string filename2 = (argc &gt; 2) ? argv[2] : <a class="code hl_functionRef" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/eight.off"</span>);</div>
<div class="line"> </div>
<div class="line">  Mesh mesh1, mesh2;</div>
<div class="line">  <span class="keywordflow">if</span>(!PMP::IO::read_polygon_mesh(filename1, mesh1) || !PMP::IO::read_polygon_mesh(filename2, mesh2))</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input."</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Number of vertices before corefinement "</span></div>
<div class="line">            &lt;&lt; num_vertices(mesh1) &lt;&lt; <span class="stringliteral">" and "</span></div>
<div class="line">            &lt;&lt; num_vertices(mesh2) &lt;&lt; <span class="stringliteral">"\n"</span>;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="group__PMP__boolop__grp.html#ga54baccf4fbd1b1ada67465ec1d4bddc1">PMP::corefine</a>(mesh1,mesh2);</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Number of vertices after corefinement "</span></div>
<div class="line">            &lt;&lt; num_vertices(mesh1) &lt;&lt; <span class="stringliteral">" and "</span></div>
<div class="line">            &lt;&lt; num_vertices(mesh2) &lt;&lt; <span class="stringliteral">"\n"</span>;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_functionRef" href="../BGL/group__PkgBGLIOFct.html#gafa143949a33371dc6df8307be1ab8a66">CGAL::IO::write_polygon_mesh</a>(<span class="stringliteral">"mesh1_refined.off"</span>, mesh1, CGAL::parameters::stream_precision(17));</div>
<div class="line">  <a class="code hl_functionRef" href="../BGL/group__PkgBGLIOFct.html#gafa143949a33371dc6df8307be1ab8a66">CGAL::IO::write_polygon_mesh</a>(<span class="stringliteral">"mesh2_refined.off"</span>, mesh2, CGAL::parameters::stream_precision(17));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassCGAL_1_1Exact__predicates__inexact__constructions__kernel_html"><div class="ttname"><a href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a></div></div>
<div class="ttc" id="aclassCGAL_1_1Surface__mesh_html"><div class="ttname"><a href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh</a></div></div>
<div class="ttc" id="agroup__PMP__boolop__grp_html_ga54baccf4fbd1b1ada67465ec1d4bddc1"><div class="ttname"><a href="group__PMP__boolop__grp.html#ga54baccf4fbd1b1ada67465ec1d4bddc1">CGAL::Polygon_mesh_processing::corefine</a></div><div class="ttdeci">void corefine(TriangleMesh &amp;tm1, TriangleMesh &amp;tm2, const NamedParameters1 &amp;np1=parameters::default_values(), const NamedParameters2 &amp;np2=parameters::default_values())</div><div class="ttdoc">corefines  tm1 and tm2.</div><div class="ttdef"><b>Definition:</b> corefinement.h:757</div></div>
<div class="ttc" id="agroup__PkgBGLIOFct_html_gafa143949a33371dc6df8307be1ab8a66"><div class="ttname"><a href="../BGL/group__PkgBGLIOFct.html#gafa143949a33371dc6df8307be1ab8a66">CGAL::IO::write_polygon_mesh</a></div><div class="ttdeci">bool write_polygon_mesh(const std::string &amp;fname, Graph &amp;g, const NamedParameters &amp;np=parameters::default_values())</div></div>
<div class="ttc" id="anamespaceCGAL_html_acdae9a147ad2a3998cc21f88bc292dac"><div class="ttname"><a href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a></div><div class="ttdeci">std::string data_file_path(const std::string &amp;filename)</div></div>
</div><!-- fragment --> </details>
<p>The function <code><a class="el" href="group__PMP__corefinement__grp.html#gaf7747d676c459d9e5da9b13be7d12bb5" title="refines a soup of triangles so that no pair of triangles intersects.">CGAL::Polygon_mesh_processing::autorefine_triangle_soup()</a></code> provides a way to refine a triangle soup using the intersections of the triangles from the soup. In particular, if some points are duplicated they will be merged.</p>
<p><b>Example: </b> <a class="el" href="PMP_Boolean_operations_2soup_autorefinement_8cpp-example.html">PMP_Boolean_operations/soup_autorefinement.cpp</a> <br>
</p><details>
<summary>
Show / Hide</summary>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/autorefinement.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/repair_polygon_soup.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/polygon_soup_to_polygon_mesh.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/triangulate_faces.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/IO/polygon_soup_io.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;boost/container/small_vector.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> <a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                                     Point;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>PMP = CGAL::Polygon_mesh_processing;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> std::string filename = argc == 1 ? <a class="code hl_functionRef" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/elephant.off"</span>)</div>
<div class="line">                                         : <a class="code hl_namespace" href="namespacestd.html">std</a>::string(argv[1]);</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;Point&gt; input_points;</div>
<div class="line">  std::vector&lt;boost::container::small_vector&lt;std::size_t, 3&gt;&gt; input_triangles;</div>
<div class="line">  <span class="keywordflow">if</span> (!<a class="code hl_functionRef" href="../Stream_support/group__IOstreamFunctions.html#gaafb0e02f4669802c727709743065804c">CGAL::IO::read_polygon_soup</a>(filename, input_points, input_triangles))</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Cannot read "</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">"\n"</span>;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line">  <a class="code hl_functionRef" href="../PMP_Mesh_repair/group__PMP__combinatorial__repair__grp.html#ga3b35133783759402828325b91ab559cc">PMP::repair_polygon_soup</a>(input_points, input_triangles);</div>
<div class="line">  <a class="code hl_functionRef" href="../PMP_Remeshing/group__PMP__combi__remeshing__grp.html#ga8b7db6aa8c3e79526b594739ba926d82">PMP::triangulate_polygons</a>(input_points, input_triangles);</div>
<div class="line"> </div>
<div class="line">  CGAL::Real_timer t;</div>
<div class="line">  t.start();</div>
<div class="line">  <a class="code hl_function" href="group__PMP__corefinement__grp.html#gaf7747d676c459d9e5da9b13be7d12bb5">PMP::autorefine_triangle_soup</a>(input_points, input_triangles,</div>
<div class="line">                                CGAL::parameters::concurrency_tag(<a class="code hl_structRef" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a>()));</div>
<div class="line">  t.stop();</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"#points = "</span> &lt;&lt; input_points.size() &lt;&lt; <span class="stringliteral">" and #triangles = "</span> &lt;&lt; input_triangles.size() &lt;&lt; <span class="stringliteral">" in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" sec."</span> &lt;&lt; std::endl;</div>
<div class="line">  <a class="code hl_functionRef" href="../Stream_support/group__IOstreamFunctions.html#ga030115449f48c379b0c080328fd730b0">CGAL::IO::write_polygon_soup</a>(<span class="stringliteral">"autorefined.off"</span>, input_points, input_triangles, CGAL::parameters::stream_precision(17));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassKernel_1_1Point__3_html"><div class="ttname"><a href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a></div></div>
<div class="ttc" id="agroup__IOstreamFunctions_html_ga030115449f48c379b0c080328fd730b0"><div class="ttname"><a href="../Stream_support/group__IOstreamFunctions.html#ga030115449f48c379b0c080328fd730b0">CGAL::IO::write_polygon_soup</a></div><div class="ttdeci">bool write_polygon_soup(const std::string &amp;fname, const PointRange &amp;points, const PolygonRange &amp;polygons, const NamedParameters &amp;np=parameters::default_values())</div></div>
<div class="ttc" id="agroup__IOstreamFunctions_html_gaafb0e02f4669802c727709743065804c"><div class="ttname"><a href="../Stream_support/group__IOstreamFunctions.html#gaafb0e02f4669802c727709743065804c">CGAL::IO::read_polygon_soup</a></div><div class="ttdeci">bool read_polygon_soup(const std::string &amp;fname, PointRange &amp;points, PolygonRange &amp;polygons, const NamedParameters &amp;np=parameters::default_values())</div></div>
<div class="ttc" id="agroup__PMP__combi__remeshing__grp_html_ga8b7db6aa8c3e79526b594739ba926d82"><div class="ttname"><a href="../PMP_Remeshing/group__PMP__combi__remeshing__grp.html#ga8b7db6aa8c3e79526b594739ba926d82">CGAL::Polygon_mesh_processing::triangulate_polygons</a></div><div class="ttdeci">bool triangulate_polygons(const PointRange &amp;points, PolygonRange &amp;polygons, const NamedParameters &amp;np=parameters::default_values())</div></div>
<div class="ttc" id="agroup__PMP__combinatorial__repair__grp_html_ga3b35133783759402828325b91ab559cc"><div class="ttname"><a href="../PMP_Mesh_repair/group__PMP__combinatorial__repair__grp.html#ga3b35133783759402828325b91ab559cc">CGAL::Polygon_mesh_processing::repair_polygon_soup</a></div><div class="ttdeci">void repair_polygon_soup(PointRange &amp;points, PolygonRange &amp;polygons, const NamedParameters &amp;np=parameters::default_values())</div></div>
<div class="ttc" id="agroup__PMP__corefinement__grp_html_gaf7747d676c459d9e5da9b13be7d12bb5"><div class="ttname"><a href="group__PMP__corefinement__grp.html#gaf7747d676c459d9e5da9b13be7d12bb5">CGAL::Polygon_mesh_processing::autorefine_triangle_soup</a></div><div class="ttdeci">bool autorefine_triangle_soup(PointRange &amp;soup_points, TriangleRange &amp;soup_triangles, const NamedParameters &amp;np=parameters::default_values())</div><div class="ttdoc">refines a soup of triangles so that no pair of triangles intersects.</div><div class="ttdef"><b>Definition:</b> autorefinement.h:1725</div></div>
<div class="ttc" id="anamespaceKernel_html"><div class="ttname"><a href="../Kernel_23/namespaceKernel.html">Kernel</a></div></div>
<div class="ttc" id="anamespacestd_html"><div class="ttname"><a href="namespacestd.html">std</a></div><div class="ttdoc">STL namespace.</div></div>
<div class="ttc" id="astructCGAL_1_1Parallel__if__available__tag_html"><div class="ttname"><a href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a></div></div>
</div><!-- fragment --> </details>
<h2><a class="anchor" id="coref_bolop_subsec"></a>
Computing Mesh Boolean Operations</h2>
<p>Corefinement of two triangulated surface meshes is a natural basis for computing Boolean operations on volumes. Given two triangulated surface meshes, each bounding a volume, the following functions are provided:</p><ul>
<li><code><a class="el" href="group__PMP__boolop__grp.html#ga95f618914f8d54d840065204b029492f" title="corefines  tm1 and tm2 and puts in tm_out a triangulated surface mesh bounding  the union of the volu...">CGAL::Polygon_mesh_processing::corefine_and_compute_union()</a></code>,</li>
<li><code><a class="el" href="group__PMP__boolop__grp.html#ga3ff96d36cad8f37efcdada916c46fbbe" title="corefines  tm1 and tm2 and puts in tm_out a triangulated surface mesh bounding  the intersection of t...">CGAL::Polygon_mesh_processing::corefine_and_compute_intersection()</a></code>,</li>
<li><code><a class="el" href="group__PMP__boolop__grp.html#ga02fa6ed9116a759ecfb87063392f5455" title="corefines  tm1 and tm2 and puts in tm_out a triangulated surface mesh bounding  the volume bounded by...">CGAL::Polygon_mesh_processing::corefine_and_compute_difference()</a></code>.</li>
</ul>
<p>respectively compute the union, intersection, and difference of the two volumes.</p>
<p>If several Boolean operations must be computed at the same time, the function <code><a class="el" href="group__PMP__boolop__grp.html#gaafa5e46c35c3fef461a47d73b4566961" title="corefines  tm1 and tm2 and for each triangle mesh tm_out passed as an optional in output different fr...">CGAL::Polygon_mesh_processing::corefine_and_compute_boolean_operations()</a></code> should be used as to factorize the corefinement operation, which makes up for the essential of the runtime.</p>
<p>The following basic example illustrates how to compute the union of two meshes:</p>
<p><b>Example: </b> <a class="el" href="PMP_Boolean_operations_2corefinement_mesh_union_8cpp-example.html">PMP_Boolean_operations/corefinement_mesh_union.cpp</a> <br>
</p><details>
<summary>
Show / Hide</summary>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/corefinement.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/IO/polygon_mesh_io.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>   K;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;K::Point_3&gt;</a>                        Mesh;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>PMP = CGAL::Polygon_mesh_processing;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> std::string filename1 = (argc &gt; 1) ? argv[1] : <a class="code hl_functionRef" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/blobby.off"</span>);</div>
<div class="line">  <span class="keyword">const</span> std::string filename2 = (argc &gt; 2) ? argv[2] : <a class="code hl_functionRef" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/eight.off"</span>);</div>
<div class="line"> </div>
<div class="line">  Mesh mesh1, mesh2;</div>
<div class="line">  <span class="keywordflow">if</span>(!PMP::IO::read_polygon_mesh(filename1, mesh1) || !PMP::IO::read_polygon_mesh(filename2, mesh2))</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input."</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  Mesh out;</div>
<div class="line">  <span class="keywordtype">bool</span> valid_union = <a class="code hl_function" href="group__PMP__boolop__grp.html#ga95f618914f8d54d840065204b029492f">PMP::corefine_and_compute_union</a>(mesh1,mesh2, out);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span>(valid_union)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Union was successfully computed\n"</span>;</div>
<div class="line">    <a class="code hl_functionRef" href="../BGL/group__PkgBGLIOFct.html#gafa143949a33371dc6df8307be1ab8a66">CGAL::IO::write_polygon_mesh</a>(<span class="stringliteral">"union.off"</span>, out, CGAL::parameters::stream_precision(17));</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Union could not be computed\n"</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__PMP__boolop__grp_html_ga95f618914f8d54d840065204b029492f"><div class="ttname"><a href="group__PMP__boolop__grp.html#ga95f618914f8d54d840065204b029492f">CGAL::Polygon_mesh_processing::corefine_and_compute_union</a></div><div class="ttdeci">bool corefine_and_compute_union(TriangleMesh &amp;tm1, TriangleMesh &amp;tm2, TriangleMesh &amp;tm_out, const NamedParameters1 &amp;np1=parameters::default_values(), const NamedParameters2 &amp;np2=parameters::default_values(), const NamedParametersOut &amp;np_out=parameters::default_values())</div><div class="ttdoc">corefines  tm1 and tm2 and puts in tm_out a triangulated surface mesh bounding  the union of the volu...</div><div class="ttdef"><b>Definition:</b> corefinement.h:605</div></div>
</div><!-- fragment --> </details>
<p><a class="anchor" id="fig__boolop_fig"></a> </p><div class="image">
<img src="bool_op.png" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__boolop_fig">Figure 76.4</a> Let <code>C</code> and <code>S</code> be the volumes bounded by the triangulated surface meshes of a cube and a sphere, respectively. From left to right, the picture shows the triangulated surface meshes bounding the union of <code>C</code> and <code>S</code>, <code>C</code> minus <code>S</code>, the intersection of <code>C</code> and <code>S</code>, and <code>S</code> minus <code>C</code>. </p> </div> <p> <br>
</p>
<h2><a class="anchor" id="coref_bolop_input"></a>
Input and Output Requirements</h2>
<h3><a class="anchor" id="coref_bolop_input_corefsub"></a>
Corefinement Based Operations</h3>
<p>There is no restriction on the topology of the input volumes. However, certain requirements must be met to ensure that the operation is feasible. First, the input meshes must be manifold triangulated surfaces bounding volumes. In particular, this means that they should not self-intersect. Second, the operation is only possible if the output can be bounded by a manifold triangulated surface mesh. In particular, this means that the output volume must not contain regions of zero thickness. Mathematically, the intersection with an infinitesimally small ball centered at any point of the output volume must be a topological ball. At the surface level, this means that no non-manifold vertex or edge is allowed in the output. For example, it is not possible to compute the union of two cubes that are disjoint but share an edge. If such scenarios arise, consider using the package <a class="elRef" href="../Manual/packages.html#PkgNef3">3D Boolean Operations on Nef Polyhedra</a>. Alternatively, a special visitor (<code><a class="el" href="structCGAL_1_1Polygon__mesh__processing_1_1Corefinement_1_1Non__manifold__output__visitor.html">CGAL::Polygon_mesh_processing::Corefinement::Non_manifold_output_visitor</a></code>) is provided for such cases and enables the user to get a triangle soup representing such a non-manifold output. See the example <a class="el" href="PMP_Boolean_operations_2corefinement_mesh_non_manifold_intersection_8cpp-example.html">PMP_Boolean_operations/corefinement_mesh_non_manifold_intersection.cpp</a></p>
<p>It is possible to update the input so that it contains the result (in-place operation). In this case, the entire mesh is not copied; only the region around the intersection polyline is modified. However, note that if the Boolean operation is not possible, the input mesh will still be corefined.</p>
<p>If the input meshes contain triangles that are coplanar, it is guaranteed that the triangulations of those triangles in the two corefined meshes will be identical. Also all edges of those refined triangles will be reported as intersection edges (both in the function <code><a class="el" href="group__PMP__corefinement__grp.html#ga6e6c4a724ce19e7a207de56f3a7408ab">CGAL::Polygon_mesh_processing::surface_intersection()</a></code> and in the named parameter <code>edge_is_constrained_map()</code> of corefine prefixed functions).</p>
<h3><a class="anchor" id="coref_bolop_input_autorefsub"></a>
Autorefinement</h3>
<p>There is no restriction on the input for the function <code><a class="el" href="group__PMP__corefinement__grp.html#gaf7747d676c459d9e5da9b13be7d12bb5" title="refines a soup of triangles so that no pair of triangles intersects.">CGAL::Polygon_mesh_processing::autorefine_triangle_soup()</a></code>. Degenerate triangles will be eliminated, duplicated points will be merged. If several triangles are coplanar, the output will contain as many copies of the triangulation of those refined triangles.</p>
<h2><a class="anchor" id="coref_valid_subsec"></a>
Kernel Choice and Output Validity</h2>
<h3><a class="anchor" id="coref_valid_subsubsec"></a>
Corefinement Based Operations</h3>
<p>The minimal requirements of the corefinement based operations to terminate without crashing is to use a CGAL <a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a> with exact predicates (such as <code><a class="elRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a></code>). The graph structure is then always guaranteed to have the right topology as exact constructions are used internally. However, because of the rounding of the coordinates of the new intersection points, the embedding of the output surface meshes in the chosen kernel may feature self-intersections. This embedding issue goes away if a kernel with additionally exact constructions (such as <code><a class="elRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">CGAL::Exact_predicates_exact_constructions_kernel</a></code>) is used. In particular, for consecutive operations, it is recommended to use a kernel with exact predicates and exact constructions.</p>
<p>From a user point of view, the choice of the kernel is done using the named parameter <code>geom_traits()</code>. If not provided, the kernel is deduced from the point type of the named parameter <code>vertex_point_map()</code>, which is by default the internal vertex point map of the mutable face graph used as input. If we take the example of <code><a class="elRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh</a>&lt;<a class="elRef" href="../Kernel_23/classCGAL_1_1Point__3.html">CGAL::Point_3</a>&lt;K&gt;&gt;</code>, the kernel used will be <code>K</code>.</p>
<h3><a class="anchor" id="autoref_valid_subsubsec"></a>
Autorefinement</h3>
<p>As for corefinement based operations described in the previous section, the function <code><a class="el" href="group__PMP__corefinement__grp.html#gaf7747d676c459d9e5da9b13be7d12bb5" title="refines a soup of triangles so that no pair of triangles intersects.">CGAL::Polygon_mesh_processing::autorefine_triangle_soup()</a></code> requires a kernel with exact predicates in order to guarantee to terminate without issue. The output will then have the same topology as the exact output (for a triangle soup this means the indexed points and triangles will be the same as if exact computations were used). If non-exact constructions are used, points will be naively rounded and self-intersection might be created. In order to avoid that, we provide a robust heuristic that can be enabled using the named parameter <code>apply_iterative_snap_rounding()</code>. When set to <code>true</code>, it ensures that coordinates are rounded to fit in <code>double</code> with potential additional subdivisions, preventing self-intersections.</p>
<p>The following table illustrates the strength of the approach over the 10 000 models of the <a href="https://ten-thousand-models.appspot.com/">Thingi10k data set</a>, demonstrating that naive rounding to floating point types is insufficient and fails to eliminate all self-intersections despite autorefinement, whereas the combination of autorefinement and iterative snap rounding resolves all of them on all meshes: </p><center> <table cellspacing="3">
<tr>
<td align="left" nowrap colspan="5"><hr>
 </td></tr>
<tr>
<td align="center" nowrap>Inputs<br>
with self-intersections </td><td width="50"></td><td align="center" nowrap>Autorefinement<br>
with naive rounding </td><td width="50"></td><td align="center" nowrap>Autorefinement<br>
with iterative snap rounding </td></tr>
<tr>
<td align="left" nowrap colspan="5"><hr>
 </td></tr>
<tr>
<td align="center" nowrap>3870 </td><td width="50"></td><td align="center" nowrap>529 </td><td width="50"></td><td align="center" nowrap><b>0</b> </td></tr>
<tr>
<td align="left" nowrap colspan="5"><hr>
 </td></tr>
</table>
</center><h2><a class="anchor" id="coref_ex_subsec"></a>
Advanced Examples</h2>
<h3><a class="anchor" id="coref_ex_refine_subsec"></a>
Boolean Operation and Local Remeshing</h3>
<p>This example is similar to the previous one, but here we subtract a volume and update the first input triangulated surface mesh (in-place operation). The edges that are on the intersection of the input meshes are marked and the region around them is remeshed isotropically while preserving the intersection polyline.</p>
<p><b>Example: </b> <a class="el" href="PMP_Boolean_operations_2corefinement_difference_remeshed_8cpp-example.html">PMP_Boolean_operations/corefinement_difference_remeshed.cpp</a> <br>
</p><details>
<summary>
Show / Hide</summary>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/corefinement.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/IO/polygon_mesh_io.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/remesh.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/selection.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iterator&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>   K;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;K::Point_3&gt;</a>                        Mesh;</div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::halfedge_descriptor        halfedge_descriptor;</div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::edge_descriptor            edge_descriptor;</div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::face_descriptor            face_descriptor;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>PMP = CGAL::Polygon_mesh_processing;</div>
<div class="line"><span class="keyword">namespace </span>params = <a class="code hl_namespaceRef" href="../STL_Extension/namespaceCGAL_1_1parameters.html">CGAL::parameters</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Vector_pmap_wrapper</div>
<div class="line">{</div>
<div class="line">  std::vector&lt;bool&gt;&amp; vect;</div>
<div class="line">  Vector_pmap_wrapper(std::vector&lt;bool&gt;&amp; v) : vect(v) {}</div>
<div class="line">  <span class="keyword">friend</span> <span class="keywordtype">bool</span> get(<span class="keyword">const</span> Vector_pmap_wrapper&amp; m, face_descriptor f)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> m.vect[f];</div>
<div class="line">  }</div>
<div class="line">  <span class="keyword">friend</span> <span class="keywordtype">void</span> put(<span class="keyword">const</span> Vector_pmap_wrapper&amp; m, face_descriptor f, <span class="keywordtype">bool</span> b)</div>
<div class="line">  {</div>
<div class="line">    m.vect[f]=b;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> std::string filename1 = (argc &gt; 1) ? argv[1] : <a class="code hl_functionRef" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/blobby.off"</span>);</div>
<div class="line">  <span class="keyword">const</span> std::string filename2 = (argc &gt; 2) ? argv[2] : <a class="code hl_functionRef" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/eight.off"</span>);</div>
<div class="line"> </div>
<div class="line">  Mesh mesh1, mesh2;</div>
<div class="line">  <span class="keywordflow">if</span> (!PMP::IO::read_polygon_mesh(filename1, mesh1) || !PMP::IO::read_polygon_mesh(filename2, mesh2))</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input."</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// create a property on edges to indicate whether they are constrained</span></div>
<div class="line">  Mesh::Property_map&lt;edge_descriptor,bool&gt; is_constrained_map =</div>
<div class="line">    mesh1.add_property_map&lt;edge_descriptor,<span class="keywordtype">bool</span>&gt;(<span class="stringliteral">"e:is_constrained"</span>, <span class="keyword">false</span>).first;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// update mesh1 to contain the mesh bounding the difference</span></div>
<div class="line">  <span class="comment">// of the two input volumes.</span></div>
<div class="line">  <span class="keywordtype">bool</span> valid_difference =</div>
<div class="line">    <a class="code hl_function" href="group__PMP__boolop__grp.html#ga02fa6ed9116a759ecfb87063392f5455">PMP::corefine_and_compute_difference</a>(mesh1,</div>
<div class="line">                                         mesh2,</div>
<div class="line">                                         mesh1,</div>
<div class="line">                                         params::default_values(), <span class="comment">// default parameters for mesh1</span></div>
<div class="line">                                         params::default_values(), <span class="comment">// default parameters for mesh2</span></div>
<div class="line">                                         params::edge_is_constrained_map(is_constrained_map));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (valid_difference)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Difference was successfully computed\n"</span>;</div>
<div class="line">    <a class="code hl_functionRef" href="../BGL/group__PkgBGLIOFct.html#gafa143949a33371dc6df8307be1ab8a66">CGAL::IO::write_polygon_mesh</a>(<span class="stringliteral">"difference.off"</span>, mesh1, CGAL::parameters::stream_precision(17));</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Difference could not be computed\n"</span>;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// collect faces incident to a constrained edge</span></div>
<div class="line">  std::vector&lt;face_descriptor&gt; selected_faces;</div>
<div class="line">  std::vector&lt;bool&gt; is_selected(num_faces(mesh1), <span class="keyword">false</span>);</div>
<div class="line">  <span class="keywordflow">for</span> (edge_descriptor e : edges(mesh1))</div>
<div class="line">    <span class="keywordflow">if</span> (is_constrained_map[e])</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// insert all faces incident to the target vertex</span></div>
<div class="line">      <span class="keywordflow">for</span> (halfedge_descriptor h : <a class="code hl_functionRef" href="../BGL/group__PkgBGLIterators.html#ga295060a50555471eab7f24addbb9bb49">halfedges_around_target</a>(halfedge(e,mesh1),mesh1))</div>
<div class="line">      {</div>
<div class="line">        <span class="keywordflow">if</span> (!<a class="code hl_functionRef" href="../BGL/group__PkgBGLHelperFct.html#gad93e429ad24efeaddeb836c437e719ab">is_border</a>(h, mesh1) )</div>
<div class="line">        {</div>
<div class="line">          face_descriptor f = face(h, mesh1);</div>
<div class="line">          <span class="keywordflow">if</span> (!is_selected[f])</div>
<div class="line">          {</div>
<div class="line">            selected_faces.push_back(f);</div>
<div class="line">            is_selected[f] = <span class="keyword">true</span>;</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// increase the face selection</span></div>
<div class="line">  <a class="code hl_functionRef" href="../BGL/group__PkgBGLSelectionFct.html#ga569fe26f889e5e4eed27746ac921651b">CGAL::expand_face_selection</a>(selected_faces, mesh1, 2,</div>
<div class="line">                              Vector_pmap_wrapper(is_selected),</div>
<div class="line">                              std::back_inserter(selected_faces));</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; selected_faces.size() &lt;&lt; <span class="stringliteral">" faces were selected for the remeshing step\n"</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// remesh the region around the intersection polylines</span></div>
<div class="line">  <a class="code hl_functionRef" href="../PMP_Remeshing/group__PMP__local__remeshing__grp.html#ga412f696ec3009074bf957f1bba638248">PMP::isotropic_remeshing</a>(selected_faces, 0.02, mesh1,</div>
<div class="line">                           params::edge_is_constrained_map(is_constrained_map));</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_functionRef" href="../BGL/group__PkgBGLIOFct.html#gafa143949a33371dc6df8307be1ab8a66">CGAL::IO::write_polygon_mesh</a>(<span class="stringliteral">"difference_remeshed.off"</span>, mesh1, CGAL::parameters::stream_precision(17));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__PMP__boolop__grp_html_ga02fa6ed9116a759ecfb87063392f5455"><div class="ttname"><a href="group__PMP__boolop__grp.html#ga02fa6ed9116a759ecfb87063392f5455">CGAL::Polygon_mesh_processing::corefine_and_compute_difference</a></div><div class="ttdeci">bool corefine_and_compute_difference(TriangleMesh &amp;tm1, TriangleMesh &amp;tm2, TriangleMesh &amp;tm_out, const NamedParameters1 &amp;np1=parameters::default_values(), const NamedParameters2 &amp;np2=parameters::default_values(), const NamedParametersOut &amp;np_out=parameters::default_values())</div><div class="ttdoc">corefines  tm1 and tm2 and puts in tm_out a triangulated surface mesh bounding  the volume bounded by...</div><div class="ttdef"><b>Definition:</b> corefinement.h:669</div></div>
<div class="ttc" id="agroup__PMP__local__remeshing__grp_html_ga412f696ec3009074bf957f1bba638248"><div class="ttname"><a href="../PMP_Remeshing/group__PMP__local__remeshing__grp.html#ga412f696ec3009074bf957f1bba638248">CGAL::Polygon_mesh_processing::isotropic_remeshing</a></div><div class="ttdeci">void isotropic_remeshing(const FaceRange &amp;faces, SizingFunction &amp;sizing, PolygonMesh &amp;pmesh, const NamedParameters &amp;np=parameters::default_values())</div></div>
<div class="ttc" id="agroup__PkgBGLHelperFct_html_gad93e429ad24efeaddeb836c437e719ab"><div class="ttname"><a href="../BGL/group__PkgBGLHelperFct.html#gad93e429ad24efeaddeb836c437e719ab">CGAL::is_border</a></div><div class="ttdeci">bool is_border(typename boost::graph_traits&lt; FaceGraph &gt;::halfedge_descriptor hd, const FaceGraph &amp;g)</div></div>
<div class="ttc" id="agroup__PkgBGLIterators_html_ga295060a50555471eab7f24addbb9bb49"><div class="ttname"><a href="../BGL/group__PkgBGLIterators.html#ga295060a50555471eab7f24addbb9bb49">CGAL::halfedges_around_target</a></div><div class="ttdeci">Iterator_range&lt; Halfedge_around_target_iterator&lt; Graph &gt; &gt; halfedges_around_target(typename boost::graph_traits&lt; Graph &gt;::halfedge_descriptor h, const Graph &amp;g)</div></div>
<div class="ttc" id="agroup__PkgBGLSelectionFct_html_ga569fe26f889e5e4eed27746ac921651b"><div class="ttname"><a href="../BGL/group__PkgBGLSelectionFct.html#ga569fe26f889e5e4eed27746ac921651b">CGAL::expand_face_selection</a></div><div class="ttdeci">OutputIterator expand_face_selection(const FaceRange &amp;selection, FaceGraph &amp;fg, unsigned int k, IsFaceSelectedPMap is_selected, OutputIterator out)</div></div>
<div class="ttc" id="anamespaceCGAL_1_1parameters_html"><div class="ttname"><a href="../STL_Extension/namespaceCGAL_1_1parameters.html">CGAL::parameters</a></div></div>
</div><!-- fragment --> </details>
<h3><a class="anchor" id="coref_ex_consq_subsec"></a>
Robustness of Consecutive Operations</h3>
<p>This example computes the intersection of two volumes and then performs the union of the result with one of the input volumes. This operation is in general not possible when using inexact constructions. Instead of using a mesh with points from a kernel with exact constructions, the exact points are stored as a property of the mesh vertices and can be reused in later operations. With this property, it is possible to manipulate a mesh with points having floating point coordinates while benefiting from the robustness provided by exact constructions.</p>
<p><b>Example: </b> <a class="el" href="PMP_Boolean_operations_2corefinement_consecutive_bool_op_8cpp-example.html">PMP_Boolean_operations/corefinement_consecutive_bool_op.cpp</a> <br>
</p><details>
<summary>
Show / Hide</summary>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/corefinement.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/IO/polygon_mesh_io.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">CGAL::Exact_predicates_exact_constructions_kernel</a> EK;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;K::Point_3&gt;</a> Mesh;</div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Mesh&gt;::vertex_descriptor vertex_descriptor;</div>
<div class="line"><span class="keyword">typedef</span> Mesh::Property_map&lt;vertex_descriptor,EK::Point_3&gt; Exact_point_map;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>PMP = CGAL::Polygon_mesh_processing;</div>
<div class="line"><span class="keyword">namespace </span>params = <a class="code hl_namespaceRef" href="../STL_Extension/namespaceCGAL_1_1parameters.html">CGAL::parameters</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// One could perform Boolean operations directly on inexact meshes as an exact computation</span></div>
<div class="line"><span class="comment">// is done internally. However, if we want to perform consecutive Boolean operations,</span></div>
<div class="line"><span class="comment">// we can avoid multiple conversions and possible precision issues by maintaining</span></div>
<div class="line"><span class="comment">// explicitely the exact points in the meshes.</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Exact_vertex_point_map</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// typedef for the property map</span></div>
<div class="line">  <span class="keyword">typedef</span> boost::property_traits&lt;Exact_point_map&gt;::value_type value_type;</div>
<div class="line">  <span class="keyword">typedef</span> boost::property_traits&lt;Exact_point_map&gt;::reference reference;</div>
<div class="line">  <span class="keyword">typedef</span> boost::property_traits&lt;Exact_point_map&gt;::key_type key_type;</div>
<div class="line">  <span class="keyword">typedef</span> boost::read_write_property_map_tag category;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// exterior references</span></div>
<div class="line">  Exact_point_map exact_point_map;</div>
<div class="line">  Mesh* tm_ptr;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Converters</span></div>
<div class="line">  <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Cartesian__converter.html">CGAL::Cartesian_converter&lt;K, EK&gt;</a> to_exact;</div>
<div class="line">  <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Cartesian__converter.html">CGAL::Cartesian_converter&lt;EK, K&gt;</a> to_input;</div>
<div class="line"> </div>
<div class="line">  Exact_vertex_point_map()</div>
<div class="line">    : tm_ptr(nullptr)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line">  Exact_vertex_point_map(<span class="keyword">const</span> Exact_point_map&amp; ep, Mesh&amp; tm)</div>
<div class="line">    : exact_point_map(ep)</div>
<div class="line">    , tm_ptr(&amp;tm)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">for</span> (Mesh::Vertex_index v : vertices(tm))</div>
<div class="line">      exact_point_map[v]=to_exact(tm.point(v));</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">friend</span></div>
<div class="line">  reference get(<span class="keyword">const</span> Exact_vertex_point_map&amp; map, key_type k)</div>
<div class="line">  {</div>
<div class="line">    CGAL_precondition(map.tm_ptr!=<span class="keyword">nullptr</span>);</div>
<div class="line">    <span class="keywordflow">return</span> map.exact_point_map[k];</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">friend</span></div>
<div class="line">  <span class="keywordtype">void</span> put(<span class="keyword">const</span> Exact_vertex_point_map&amp; map, key_type k, <span class="keyword">const</span> EK::Point_3&amp; p)</div>
<div class="line">  {</div>
<div class="line">    CGAL_precondition(map.tm_ptr!=<span class="keyword">nullptr</span>);</div>
<div class="line">    map.exact_point_map[k]=p;</div>
<div class="line">    <span class="comment">// create the input point from the exact one</span></div>
<div class="line">    map.tm_ptr-&gt;point(k)=map.to_input(p);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> std::string filename1 = (argc &gt; 1) ? argv[1] : <a class="code hl_functionRef" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/blobby.off"</span>);</div>
<div class="line">  <span class="keyword">const</span> std::string filename2 = (argc &gt; 2) ? argv[2] : <a class="code hl_functionRef" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/eight.off"</span>);</div>
<div class="line"> </div>
<div class="line">  Mesh mesh1, mesh2;</div>
<div class="line">  <span class="keywordflow">if</span>(!PMP::IO::read_polygon_mesh(filename1, mesh1) || !PMP::IO::read_polygon_mesh(filename2, mesh2))</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input."</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  Exact_point_map mesh1_exact_points =</div>
<div class="line">    mesh1.add_property_map&lt;vertex_descriptor,EK::Point_3&gt;(<span class="stringliteral">"v:exact_point"</span>).first;</div>
<div class="line"> </div>
<div class="line">  Exact_point_map mesh2_exact_points =</div>
<div class="line">    mesh2.add_property_map&lt;vertex_descriptor,EK::Point_3&gt;(<span class="stringliteral">"v:exact_point"</span>).first;</div>
<div class="line"> </div>
<div class="line">  Exact_vertex_point_map mesh1_vpm(mesh1_exact_points, mesh1);</div>
<div class="line">  Exact_vertex_point_map mesh2_vpm(mesh2_exact_points, mesh2);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> ( <a class="code hl_function" href="group__PMP__boolop__grp.html#ga3ff96d36cad8f37efcdada916c46fbbe">PMP::corefine_and_compute_intersection</a>(mesh1,</div>
<div class="line">                                              mesh2,</div>
<div class="line">                                              mesh1,</div>
<div class="line">                                              params::vertex_point_map(mesh1_vpm),</div>
<div class="line">                                              params::vertex_point_map(mesh2_vpm),</div>
<div class="line">                                              params::vertex_point_map(mesh1_vpm) ) )</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span> ( <a class="code hl_function" href="group__PMP__boolop__grp.html#ga95f618914f8d54d840065204b029492f">PMP::corefine_and_compute_union</a>(mesh1,</div>
<div class="line">                                         mesh2,</div>
<div class="line">                                         mesh2,</div>
<div class="line">                                         params::vertex_point_map(mesh1_vpm),</div>
<div class="line">                                         params::vertex_point_map(mesh2_vpm),</div>
<div class="line">                                         params::vertex_point_map(mesh2_vpm) ) )</div>
<div class="line">    {</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">"Intersection and union were successfully computed\n"</span>;</div>
<div class="line">      <a class="code hl_functionRef" href="../BGL/group__PkgBGLIOFct.html#gafa143949a33371dc6df8307be1ab8a66">CGAL::IO::write_polygon_mesh</a>(<span class="stringliteral">"inter_union.off"</span>, mesh2, CGAL::parameters::stream_precision(17));</div>
<div class="line">      <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Union could not be computed\n"</span>;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Intersection could not be computed\n"</span>;</div>
<div class="line">  <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
<div class="ttc" id="aclassCGAL_1_1Cartesian__converter_html"><div class="ttname"><a href="../Kernel_23/classCGAL_1_1Cartesian__converter.html">CGAL::Cartesian_converter</a></div></div>
<div class="ttc" id="aclassCGAL_1_1Exact__predicates__exact__constructions__kernel_html"><div class="ttname"><a href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">CGAL::Exact_predicates_exact_constructions_kernel</a></div></div>
<div class="ttc" id="agroup__PMP__boolop__grp_html_ga3ff96d36cad8f37efcdada916c46fbbe"><div class="ttname"><a href="group__PMP__boolop__grp.html#ga3ff96d36cad8f37efcdada916c46fbbe">CGAL::Polygon_mesh_processing::corefine_and_compute_intersection</a></div><div class="ttdeci">bool corefine_and_compute_intersection(TriangleMesh &amp;tm1, TriangleMesh &amp;tm2, TriangleMesh &amp;tm_out, const NamedParameters1 &amp;np1=parameters::default_values(), const NamedParameters2 &amp;np2=parameters::default_values(), const NamedParametersOut &amp;np_out=parameters::default_values())</div><div class="ttdoc">corefines  tm1 and tm2 and puts in tm_out a triangulated surface mesh bounding  the intersection of t...</div><div class="ttdef"><b>Definition:</b> corefinement.h:637</div></div>
</div><!-- fragment --> </details>
<h1><a class="anchor" id="coref_clip"></a>
Clipping and Splitting Meshes</h1>
<p>The corefinement of two meshes can be also used to provide <em>clipping</em> functionalities with a volume bounded by a closed mesh and a clipper. The clipper can be a plane, a box, or another closed mesh. For example, in the case of plane clipping, the input mesh is corefined with the plane, and all parts of the mesh lying on the negative side of the plane are retained. Alternatively, one may choose not to discard any part, but simply <em>split</em> the input according to a plane, box, or mesh. This operation is called <em>splitting</em>.</p>
<p>The functions implementing these operations are:</p><ul>
<li><code><a class="el" href="group__PMP__clip__grp.html#ga5dc9e7acf8433235adc7b91ac93a7d42" title="clips tm by keeping the part that is inside the volume bounded  by clipper.">CGAL::Polygon_mesh_processing::clip()</a></code>,</li>
<li><code><a class="el" href="group__PMP__clip__grp.html#ga642520055888a41a3e1a76965a1f9fbb" title="corefines tm and splitter and duplicates edges in tm that are on the intersection with splitter.">CGAL::Polygon_mesh_processing::split()</a></code>.</li>
</ul>
<p>Both functions offer options to select whether clipping should be performed at the volume or surface level, and whether the clipper should be considered compact. This is illustrated in <a class="el" href="index.html#fig__coref_clip_close_open">Figure 76.5</a> and <a class="el" href="index.html#fig__coref_clip_compact">Figure 76.6</a>.</p>
<p><a class="anchor" id="fig__coref_clip_close_open"></a></p><center> <img src="clip_open_close.png" alt="" style="max-width:70%;" class="inline"> </center>  <div class="cgal_figure_caption"> <p> <a class="el" href="index.html#fig__coref_clip_close_open">Figure 76.5</a> Clipping a cube with a halfspace. From left to right: (i) initial cube and the plane defining the clipping halfspace; (ii) <code>clip_volume=false</code>: clipping of the surface mesh (boundary edges depicted in red); (iii) <code>clip_volume=true</code>: clipping of the volume bounded by the surface mesh. </p> </div> <p> <br>
</p>
<p><a class="anchor" id="fig__coref_clip_compact"></a></p><center> <img src="clip_compact.png" alt="" style="max-width:70%;" class="inline"> </center>  <div class="cgal_figure_caption"> <p> <a class="el" href="index.html#fig__coref_clip_compact">Figure 76.6</a> Clipping a cube with a halfspace: compactivity of the clipper (<code>clip_volume=false</code> in both cases). From left to right: (i) initial cube and the plane defining the clipping halfspace, note that a whole face of the cube (2 triangles) is exactly contained in the plane; (ii) <code>use_compact_clipper=true</code>: clipping of the surface mesh with a compact halfspace: coplanar faces are part of the output; (iii) <code>use_compact_clipper=false</code>: clipping of the surface mesh with a non-compact halfspace: coplanar faces are not part of the output. </p> </div> <p> <br>
</p>
<h1><a class="anchor" id="PMPSlicer"></a>
Slicer</h1>
<p>The <code><a class="el" href="classCGAL_1_1Polygon__mesh__slicer.html" title="Function object that computes the intersection of a plane with a triangulated surface mesh.">CGAL::Polygon_mesh_slicer</a></code> is an operator that intersects a triangle surface mesh with a plane. It records the intersection as a set of polylines since the intersection can be made of more than one connected component. The degenerate case where the intersection is a single point is also handled.</p>
<p><a class="el" href="index.html#fig__SlicerFig">Figure 76.7</a> shows the polylines returned by the slicing operation for a triangle mesh and a set of parallel planes.</p>
<p><a class="anchor" id="fig__SlicerFig"></a> </p><div class="image">
<img src="slicer.jpg" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__SlicerFig">Figure 76.7</a> Slicing a mesh. A triangle mesh (left) and the polylines computed by the mesh slicer by intersecting a set of parallel planes (right). </p> </div> <p> <br>
</p>
<p>The example below illustrates how to use the mesh slicer for a given triangle mesh and a plane. Two constructors are used in the example for pedagogical purposes.</p>
<p><b>Example: </b> <a class="el" href="PMP_Boolean_operations_2mesh_slicer_example_8cpp-example.html">PMP_Boolean_operations/mesh_slicer_example.cpp</a> <br>
</p><details>
<summary>
Show / Hide</summary>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_slicer.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/IO/polygon_mesh_io.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/AABB_halfedge_graph_segment_primitive.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/AABB_tree.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/AABB_traits_3.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>   K;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;K::Point_3&gt;</a>                        Mesh;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> std::vector&lt;K::Point_3&gt;                               Polyline_type;</div>
<div class="line"><span class="keyword">typedef</span> std::list&lt;Polyline_type&gt;                              Polylines;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../AABB_tree/classCGAL_1_1AABB__halfedge__graph__segment__primitive.html">CGAL::AABB_halfedge_graph_segment_primitive&lt;Mesh&gt;</a>     HGSP;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../AABB_tree/classCGAL_1_1AABB__traits__3.html">CGAL::AABB_traits_3&lt;K, HGSP&gt;</a>                            <a class="code hl_typedefRef" href="../AABB_tree/group__PkgAABBTreeRef.html#ga764f0fc59c96355877536810aa1aca5b">AABB_traits</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../AABB_tree/classCGAL_1_1AABB__tree.html">CGAL::AABB_tree&lt;AABB_traits&gt;</a>                          AABB_tree;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>PMP = CGAL::Polygon_mesh_processing;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : <a class="code hl_functionRef" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/eight.off"</span>);</div>
<div class="line"> </div>
<div class="line">  Mesh mesh;</div>
<div class="line">  <span class="keywordflow">if</span>(!PMP::IO::read_polygon_mesh(filename, mesh) || <a class="code hl_functionRef" href="../BGL/group__PkgBGLHelperFct.html#gab6e6f18e6de73b9f85e38d0b56145172">CGAL::is_empty</a>(mesh) || !<a class="code hl_functionRef" href="../BGL/group__PkgBGLHelperFct.html#ga11883d231eec1b58f37efe4acedd9588">CGAL::is_triangle_mesh</a>(mesh))</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input."</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Slicer constructor from the mesh</span></div>
<div class="line">  <a class="code hl_class" href="classCGAL_1_1Polygon__mesh__slicer.html">CGAL::Polygon_mesh_slicer&lt;Mesh, K&gt;</a> slicer(mesh);</div>
<div class="line"> </div>
<div class="line">  Polylines polylines;</div>
<div class="line">  slicer(K::Plane_3(0, 0, 1, -0.4), std::back_inserter(polylines));</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"At z = 0.4, the slicer intersects "</span></div>
<div class="line">            &lt;&lt; polylines.size() &lt;&lt; <span class="stringliteral">" polylines"</span> &lt;&lt; std::endl;</div>
<div class="line">  polylines.clear();</div>
<div class="line"> </div>
<div class="line">  slicer(K::Plane_3(0, 0, 1, 0.2), std::back_inserter(polylines));</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"At z = -0.2, the slicer intersects "</span></div>
<div class="line">            &lt;&lt; polylines.size() &lt;&lt; <span class="stringliteral">" polylines"</span> &lt;&lt; std::endl;</div>
<div class="line">  polylines.clear();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Use the Slicer constructor from a pre-built AABB_tree</span></div>
<div class="line">  AABB_tree tree(edges(mesh).first, edges(mesh).second, mesh);</div>
<div class="line">  <a class="code hl_class" href="classCGAL_1_1Polygon__mesh__slicer.html">CGAL::Polygon_mesh_slicer&lt;Mesh, K&gt;</a> slicer_aabb(mesh, tree);</div>
<div class="line">  slicer_aabb(K::Plane_3(0, 0, 1, -0.4), std::back_inserter(polylines));</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"At z = 0.4, the slicer intersects "</span></div>
<div class="line">            &lt;&lt; polylines.size() &lt;&lt; <span class="stringliteral">" polylines"</span> &lt;&lt; std::endl;</div>
<div class="line">  polylines.clear();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassCGAL_1_1AABB__halfedge__graph__segment__primitive_html"><div class="ttname"><a href="../AABB_tree/classCGAL_1_1AABB__halfedge__graph__segment__primitive.html">CGAL::AABB_halfedge_graph_segment_primitive</a></div></div>
<div class="ttc" id="aclassCGAL_1_1AABB__traits__3_html"><div class="ttname"><a href="../AABB_tree/classCGAL_1_1AABB__traits__3.html">CGAL::AABB_traits_3</a></div></div>
<div class="ttc" id="aclassCGAL_1_1AABB__tree_html"><div class="ttname"><a href="../AABB_tree/classCGAL_1_1AABB__tree.html">CGAL::AABB_tree</a></div></div>
<div class="ttc" id="aclassCGAL_1_1Polygon__mesh__slicer_html"><div class="ttname"><a href="classCGAL_1_1Polygon__mesh__slicer.html">CGAL::Polygon_mesh_slicer</a></div><div class="ttdoc">Function object that computes the intersection of a plane with a triangulated surface mesh.</div><div class="ttdef"><b>Definition:</b> Polygon_mesh_slicer.h:90</div></div>
<div class="ttc" id="agroup__PkgAABBTreeRef_html_ga764f0fc59c96355877536810aa1aca5b"><div class="ttname"><a href="../AABB_tree/group__PkgAABBTreeRef.html#ga764f0fc59c96355877536810aa1aca5b">CGAL::AABB_traits</a></div><div class="ttdeci">AABB_traits_3&lt; GeomTraits, AABBPrimitive, BboxMap &gt; AABB_traits</div></div>
<div class="ttc" id="agroup__PkgBGLHelperFct_html_ga11883d231eec1b58f37efe4acedd9588"><div class="ttname"><a href="../BGL/group__PkgBGLHelperFct.html#ga11883d231eec1b58f37efe4acedd9588">CGAL::is_triangle_mesh</a></div><div class="ttdeci">bool is_triangle_mesh(const FaceGraph &amp;g)</div></div>
<div class="ttc" id="agroup__PkgBGLHelperFct_html_gab6e6f18e6de73b9f85e38d0b56145172"><div class="ttname"><a href="../BGL/group__PkgBGLHelperFct.html#gab6e6f18e6de73b9f85e38d0b56145172">CGAL::is_empty</a></div><div class="ttdeci">bool is_empty(const FaceGraph &amp;g)</div></div>
</div><!-- fragment --> </details>
<h1><a class="anchor" id="coref_kernel"></a>
Mesh Kernels</h1>
<p>The kernel of a mesh is defined as the set of points from which the entire (oriented) surface of the mesh is visible. More formally, a point belongs to the kernel if, for every point on the mesh, the segment connecting them lies inside the mesh. Equivalently, the kernel is the intersection of all the half-spaces on the negative side of the oriented supporting planes of the faces of the mesh.</p>
<p><a class="anchor" id="fig__coref_kernel_figure"></a> </p><div class="image">
<img src="kernel.png" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__coref_kernel_figure">Figure 76.8</a> Mesh kernel: From left to right: (i) The input mesh; (ii) The kernel of the input; (iii) The kernel inside the mesh. All segments between a point of the kernel and a point of the mesh are inside the mesh. </p> </div> <p> <br>
</p>
<p>The functions <code><a class="el" href="group__PMP__kernel__grp.html#ga778059f8efd21fb9a9ffc7ede16c5abc" title="computes the kernel of the given faces of a polygon mesh.">CGAL::Polygon_mesh_processing::kernel()</a></code>, <code><a class="el" href="group__PMP__kernel__grp.html#gaea657a1fbac5d35c3d51735c3ec2fede" title="returns a point inside the kernel of the given faces of a polygon mesh.">CGAL::Polygon_mesh_processing::kernel_point()</a></code> and <code><a class="el" href="group__PMP__kernel__grp.html#gaf5b25f2dc1e3d96e9f81ed182f9600de" title="indicates whether the kernel of the given faces of a polygon mesh is empty.">CGAL::Polygon_mesh_processing::has_empty_kernel()</a></code> output the full kernel, a single point inside it or a Boolean indicating whether the kernel exists or not, respectively.</p>
<h1><a class="anchor" id="PMPBoolOpHistory"></a>
Implementation History</h1>
<p>Corefinement was introduced in CGAL 4.10 by Sébastien Loriot.</p>
<p>The <code>apply_iterative_snap_rounding</code> option for autorefinement was developed by Sylvain Lazard and Léo Vaque <a class="el" href="citelist.html#CITEREF_valquelazard2025">[2]</a>, and implemented by Léo Valque in 2025.</p>
<p>The kernel functions and the specialization of clipping and plane refinement to convex inputs were implemented in 2025 by Léo Valque, inspired by the work of Sorgente et al. <a class="el" href="citelist.html#CITEREF_sorgente2022polyhedron">[1]</a>. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"></a> 1.9.6 </li>
  </ul>
</div>
</div>
</body>


</html>
