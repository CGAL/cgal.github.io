<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Straight_skeleton_2/classCGAL_1_1Straight__skeleton__2.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=11">
<meta name="generator" content="Doxygen 1.9.6">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CGAL 6.2 - 2D Straight Skeleton and Polygon Offsetting: CGAL::Straight_skeleton_2&lt; Traits &gt; Class Template Reference</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/doxygen.css" rel="stylesheet" type="text/css">
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      },
      equationNumbers: { autoNumber: "AMS" }
  }
}
);
MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
  var PARSE = MathJax.InputJax.TeX.Parse,
      TEXT = PARSE.prototype.InternalText;
  PARSE.Augment({
    InternalText: function (text,def) {
      text = text.replace(/\\/g,"");
      return TEXT.call(this,text,def);
    }
  });
});
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
      <span class="left">
         <span id="MSearchSelect" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"> 
        </span>
        <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
      </span>
      <span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.svg" alt=""></a>
      </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CGAL 6.2 - 2D Straight Skeleton and Polygon Offsetting
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search/",'.html');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classCGAL_1_1Straight__skeleton__2.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="classCGAL_1_1Straight__skeleton__2-members.html">List of all members</a> |
<a href="#pub-types">Public Types</a>  </div>
  <div class="headertitle"><div class="title">CGAL::Straight_skeleton_2&lt; Traits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__PkgStraightSkeleton2Ref.html">Reference Manual</a> » <a class="el" href="group__PkgStraightSkeleton2Classes.html">Classes</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;CGAL/Straight_skeleton_2.h&gt;</code></p>

<h2 class="groupheader">Inherits from</h2><p><a class="elRef" href="../HalfedgeDS/classCGAL_1_1HalfedgeDS__default.html">CGAL::HalfedgeDS_default&lt; Traits &gt;</a>.</p>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Traits&gt;<br>
class CGAL::Straight_skeleton_2&lt; Traits &gt;</div><p>The class <code><a class="el" href="classCGAL_1_1Straight__skeleton__2.html" title="The class Straight_skeleton_2 provides a model for the StraightSkeleton_2 concept which is the class ...">Straight_skeleton_2</a></code> provides a model for the <code><a class="el" href="classStraightSkeleton__2.html">StraightSkeleton_2</a></code> concept which is the class type used to represent a straight skeleton. </p>
<dl>
<dt>Is model of</dt>
<dd><code><a class="el" href="classStraightSkeleton__2.html">StraightSkeleton_2</a></code> </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Traits</td><td>must be a model of <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code></td></tr>
  </table>
  </dd>
</dl>
<p>The only purpose of this class is to protect all the modifying operations in a <code><a class="elRef" href="../HalfedgeDS/classHalfedgeDS.html">HalfedgeDS</a></code>. Normal users should not modify a straight skeleton. If an advanced user needs to get access to the modifying operations, it must call the required methods through the <code>Base</code> class.</p>
<p>Below is an in-depth description of the combinatorial representation used in the straight skeleton class, starting with a few definitions describing the different concepts appearing in the algorithm.</p>
<p><b>Angular Bisecting Lines and Offset Bisectors</b><br>
</p>
<p>We make use of definitions from the user manual, see Section <a class="el" href="index.html#Straight_skeleton_2Definitions">Definitions</a>.</p>
<p>Given two points and a line passing through them, the perpendicular line passing through the midpoint is the bisecting line (or bisector) of those points. Two non-parallel lines, intersecting at a point, are bisected by two other lines passing through that intersection point. Two parallel lines are bisected by another parallel line placed halfway in between. Given just one line, any perpendicular line can be considered the bisecting line (any bisector of any two points along the single line). The bisecting lines of two edges are the lines bisecting the supporting lines of the edges (if the edges are parallel or collinear, there is just one bisecting line).</p>
<p>The halfplane to the bounded side of the line supporting a contour (input) edge is called the <em>offset zone</em> of the contour edge. Given any number of contour edges (not necessarily consecutive), the intersection of their offset zones is called their <em>combined offset zone</em>.</p>
<p>Any two contour edges define an <em>offset bisector</em>, as follows: If the edges are non-parallel, their bisecting lines can be decomposed as 4 rays originating at the intersection of the supporting lines. Only one of these rays is contained in the combined offset zone of the edges (which one depends on the possible combinations of orientations). This ray is the offset bisector of the non-parallel contour edges.</p>
<p>If the edges are parallel (but not collinear) and have opposite orientation, the entire and unique bisecting line is their offset bisector. If the edges are parallel but have the same orientation, there is no offset bisector between them.</p>
<p>If the edges are collinear and have the same orientation, their offset bisector is given by a perpendicular ray to the left of the edges which originates at the midpoint of the combined complement of the edges. (The <em>complement</em> of an edge/segment are the two rays along its supporting line which are not the segment and the <em>combined complement</em> of <code>N</code> collinear segments is the intersection of the complements of each segment). If the edges are collinear but have opposite orientation, there is no offset bisector between them.</p>
<p><b>Faces, Edges, and Vertices</b><br>
</p>
<p>Each region of the partitioning defined by a straight skeleton is called a <em>face</em>. Each face is bounded by straight line segments, called <em>edges</em>. Exactly one edge per face is a <em>contour edge</em> (corresponds to a side of the polygon) and the rest of the edges, located in the interior of the polygon, are called <em>skeleton edges</em>, or <em>bisectors</em>.</p>
<p>The bisectors of the straight skeleton are segments of the offset bisectors as defined previously. Since an offset bisector is a ray of a bisecting line of 2 contour edges, each skeleton edge (or bisector) is uniquely given by two contour edges. These edges are called the <em>defining contour edges</em> of the bisector.</p>
<p>The intersection of the edges are called <em>vertices</em>. Although in a simple polygon, only 2 edges intersect at a vertex, in a straight skeleton, 3 or more edges intersect at any given vertex. That is, vertices in a straight skeleton have degree \( &gt;=3\).</p>
<p>A <em>contour vertex</em> is a vertex for which 2 of its incident edges are contour edges.</p>
<p>A <em>skeleton vertex</em> is a vertex whose incident edges are all skeleton edges.</p>
<p>A <em>contour bisector</em> is a bisector whose defining contour edges are consecutive. Such a bisector is incident upon 1 contour vertex and 1 skeleton vertex, and touches the input polygon at exactly 1 endpoint.</p>
<p>An <em>inner bisector</em> is a bisector whose defining contour edges are not consecutive. Such a bisector is incident upon 2 skeleton vertices and is strictly contained in the interior of the polygon.</p>
<p><b>Implementation Details</b><br>
</p>
<p>This CGAL package represents a straight skeleton as a specialized <code>CGAL::HalfedgeDS</code> (HDS) whose vertices embed 2D Points (see the <code><a class="el" href="classStraightSkeleton__2.html">StraightSkeleton_2</a></code> concept in the reference manual for details).</p>
<p>Its halfedges, by considering the source and target points, implicitly embed 2D oriented straight line segments (each halfedge per se does not embed a segment explicitly).</p>
<p>A face of the straight skeleton is represented as a face in the HDS. Both contour and skeleton edges are represented by pairs of opposite HDS halfedges, and both contour and skeleton vertices are represented by HDS vertices.</p>
<p>In a HDS, a border halfedge is a halfedge which does not have an incident face. In the case of the straight skeleton HDS, such border halfedges are oriented such that their left side faces outwards the polygon. Therefore, the opposite halfedge of any border halfedge is oriented such that its left side faces inward the polygon.</p>
<p>This CGAL package requires the input polygon (with holes) to be weakly simple and oriented counterclockwise.</p>
<p>The skeleton halfedges are oriented such that their <em>left</em> side faces inward the region they bound. That is, the vertices (both contour and skeleton) of a face are circulated in counterclockwise order. There is one and only one contour halfedge incident upon any face.</p>
<p>The contours of the input polygon are traced by the border halfedges of the HDS (those facing outward), but in the opposite direction. That is, the vertices of the contours can only be traced from the straight skeleton data structure by circulating the border halfedges, and the resulting vertex sequence will be reversed w.r.t. the input vertex sequence.</p>
<p>A skeleton edge, according to the definition given in the previous section, is defined by 2 contour edges. In the representation, each one of the opposite halfedges that represent a skeleton edge is associated with one of the opposite halfedges that correspond to one of its defining contour edges. Thus, the 2 opposite halfedges of a skeleton edge link the edge to its 2 defining contour edges.</p>
<p>Starting from any border contour halfedge, circulating the structure walks through border counter halfedges and traces the vertices of the polygon's contours (in opposite order).</p>
<p>Starting from any non-border but contour halfedge, circulating the structure walks counterclockwise around the face corresponding to that contour halfedge. The vertices around a face always describe a non-convex weakly simple polygon.</p>
<p>A vertex is the intersection of contour and/or skeleton edges. Since a skeleton edge is defined by 2 contour edges, any vertex is itself defined by a unique set of contour edges. These are called the <em>defining contour edges</em> of the vertex.</p>
<p>A vertex is identified by its set of defining contour edges. Two vertices are distinct if they have differing sets of defining contour edges. Note that vertices can be distinct even if they are geometrically embedded at the same point.</p>
<p>The <em>degree</em> of a vertex is the number of halfedges around the vertex incident upon (pointing to) the vertex. As with any halfedge data structure, there is one outgoing halfedge for each incoming (incident) halfedge around a vertex. The degree of the vertex counts only incoming (incident) halfedges.</p>
<p>In a straight skeleton, the degree of a vertex is not only the number of incident halfedges around the vertex but also the number of defining contour halfedges. The vertex itself is the point where all the defining contour edges simultaneously collide.</p>
<p>Contour vertices have exactly two defining contour halfedges, which are the contour edges incident upon the vertex; and 3 incident halfedges. One and only one of the incident halfedges is a skeleton halfedge. The degree of a contour vertex is exactly 3.</p>
<p>Skeleton vertices have at least 3 defining contour halfedges and 3 incident skeleton halfedges. If more than 3 edges collide simultaneously at the same point and time (like in any regular polygon with more than 3 sides), the corresponding skeleton vertex will have more than 3 defining contour halfedges and incident skeleton halfedges. That is, the degree of a skeleton vertex is \( &gt;=3\) (the algorithm initially produces nodes of degree 3 but in the end all coincident nodes are merged to form higher degree nodes). All halfedges incident upon a skeleton vertex are skeleton halfedges.</p>
<p>The defining contour halfedges and incident halfedges around a vertex can be traced using the circulators provided by the vertex class. The degree of a vertex is not cached and cannot be directly obtained from the vertex, but you can calculate this number by manually counting the number of incident halfedges around the vertex.</p>
<p>Each vertex stores a 2D point and a time, which is the Euclidean distance from the vertex's point to the lines supporting each of the defining contour edges of the vertex (the distance is the same to each line). Unless the polygon is convex, this distance is not equal to the edges, as in the case of a Medial Axis, therefore, the time of a skeleton vertex does not correspond to the distance from the polygon to the vertex (so it cannot be used to obtain the deep of a region in a shape, for instance).</p>
<p>If the polygon is convex, the straight skeleton is exactly equivalent to the polygon's Voronoi diagram and each vertex time is the equidistance to the defining edges.</p>
<p>Contour vertices have time zero.</p>
<p><a class="anchor" id="fig__Simplepolyoffsets"></a> </p><div class="image">
<img src="fig6.png" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="classCGAL_1_1Straight__skeleton__2.html#fig__Simplepolyoffsets">Figure 21.1</a> Straight Skeleton Data Structure </p> </div> <p> <br>
</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classStraightSkeletonVertex__2.html">StraightSkeletonVertex_2</a></code> </dd>
<dd>
<code><a class="el" href="classStraightSkeletonHalfedge__2.html">StraightSkeletonHalfedge_2</a></code> </dd>
<dd>
<code><a class="el" href="classStraightSkeletonFace__2.html">StraightSkeletonFace_2</a></code> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Straight_skeleton_2_2Create_offset_polygons_2_8cpp-example.html#_a2">Straight_skeleton_2/Create_offset_polygons_2.cpp</a>, <a class="el" href="Straight_skeleton_2_2Create_saop_from_polygon_with_holes_2_8cpp-example.html#_a3">Straight_skeleton_2/Create_saop_from_polygon_with_holes_2.cpp</a>, <a class="el" href="Straight_skeleton_2_2Create_skeleton_and_offset_polygons_2_8cpp-example.html#_a2">Straight_skeleton_2/Create_skeleton_and_offset_polygons_2.cpp</a>, <a class="el" href="Straight_skeleton_2_2Create_straight_skeleton_2_8cpp-example.html#_a2">Straight_skeleton_2/Create_straight_skeleton_2.cpp</a>, <a class="el" href="Straight_skeleton_2_2Create_straight_skeleton_from_polygon_with_holes_2_8cpp-example.html#_a3">Straight_skeleton_2/Create_straight_skeleton_from_polygon_with_holes_2.cpp</a>, <a class="el" href="Straight_skeleton_2_2Low_level_API_8cpp-example.html#_a3">Straight_skeleton_2/Low_level_API.cpp</a>, <a class="el" href="Straight_skeleton_2_2Show_straight_skeleton_8cpp-example.html#_a3">Straight_skeleton_2/Show_straight_skeleton.cpp</a>, and <a class="el" href="Straight_skeleton_2_2extrude_skeleton_8cpp-example.html#_a3">Straight_skeleton_2/extrude_skeleton.cpp</a>.</dd>
</dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a539e4c8e38ebba214e06bdc778d7f0b5"><td class="memItemLeft" align="right" valign="top"><a id="a539e4c8e38ebba214e06bdc778d7f0b5" name="a539e4c8e38ebba214e06bdc778d7f0b5"></a>
typedef <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> </td><td class="memItemRight" valign="bottom"><b>Base</b></td></tr>
<tr class="memdesc:a539e4c8e38ebba214e06bdc778d7f0b5"><td class="mdescLeft"> </td><td class="mdescRight">Access to the base (HDS) class. <br></td></tr>
<tr class="separator:a539e4c8e38ebba214e06bdc778d7f0b5"><td class="memSeparator" colspan="2"> </td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>CGAL</b></li><li class="navelem"><a class="el" href="classCGAL_1_1Straight__skeleton__2.html">Straight_skeleton_2</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"></a> 1.9.6 </li>
  </ul>
</div>
</div>
</body>




</html>
