<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/AABB_tree/classCGAL_1_1AABB__tree.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=11">
<meta name="generator" content="Doxygen 1.9.6">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CGAL 6.1 - Fast Intersection and Distance Computation (AABB Tree): CGAL::AABB_tree&lt; AABBTraits &gt; Class Template Reference</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/doxygen.css" rel="stylesheet" type="text/css">
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      },
      equationNumbers: { autoNumber: "AMS" }
  }
}
);
MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
  var PARSE = MathJax.InputJax.TeX.Parse,
      TEXT = PARSE.prototype.InternalText;
  PARSE.Augment({
    InternalText: function (text,def) {
      text = text.replace(/\\/g,"");
      return TEXT.call(this,text,def);
    }
  });
});
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
      <span class="left">
         <span id="MSearchSelect" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()">Â 
        </span>
        <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
      </span>
      <span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.svg" alt=""></a>
      </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CGAL 6.1 - Fast Intersection and Distance Computation (AABB Tree)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search/",'.html');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classCGAL_1_1AABB__tree.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="classCGAL_1_1AABB__tree-members.html">List of all members</a> |
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle"><div class="title">CGAL::AABB_tree&lt; AABBTraits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__PkgAABBTreeRef.html">Reference Manual</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;CGAL/AABB_tree.h&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename <a class="el" href="classAABBTraits.html">AABBTraits</a>&gt;<br>
class CGAL::AABB_tree&lt; AABBTraits &gt;</div><p>Static data structure for efficient intersection and distance computations in 2D and 3D. </p>
<p>It builds a hierarchy of axis-aligned bounding boxes (an AABB tree) from a set of geometric objects, and can receive intersection and distance queries, provided that the corresponding predicates are implemented in the traits class <a class="el" href="classAABBTraits.html" title="The concept AABBTraits provides the geometric primitive types and methods for the class CGAL::AABB_tr...">AABBTraits</a>. An instance of the class <code><a class="el" href="classAABBTraits.html" title="The concept AABBTraits provides the geometric primitive types and methods for the class CGAL::AABB_tr...">AABBTraits</a></code> is internally stored.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classAABBTraits.html" title="The concept AABBTraits provides the geometric primitive types and methods for the class CGAL::AABB_tr...">AABBTraits</a></code> </dd>
<dd>
<code><a class="el" href="classAABBPrimitive.html" title="The concept AABBPrimitive describes the requirements for the primitives stored in the AABB tree data ...">AABBPrimitive</a></code> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="AABB_tree_2AABB_custom_example_8cpp-example.html#_a3">AABB_tree/AABB_custom_example.cpp</a>, <a class="el" href="AABB_tree_2AABB_custom_indexed_triangle_set_array_example_8cpp-example.html#_a2">AABB_tree/AABB_custom_indexed_triangle_set_array_example.cpp</a>, <a class="el" href="AABB_tree_2AABB_custom_indexed_triangle_set_example_8cpp-example.html#_a2">AABB_tree/AABB_custom_indexed_triangle_set_example.cpp</a>, <a class="el" href="AABB_tree_2AABB_custom_triangle_soup_example_8cpp-example.html#_a2">AABB_tree/AABB_custom_triangle_soup_example.cpp</a>, <a class="el" href="AABB_tree_2AABB_face_graph_triangle_example_8cpp-example.html#_a4">AABB_tree/AABB_face_graph_triangle_example.cpp</a>, <a class="el" href="AABB_tree_2AABB_halfedge_graph_edge_example_8cpp-example.html#_a4">AABB_tree/AABB_halfedge_graph_edge_example.cpp</a>, <a class="el" href="AABB_tree_2AABB_indexed_triangle_2_example_8cpp-example.html#_a3">AABB_tree/AABB_indexed_triangle_2_example.cpp</a>, <a class="el" href="AABB_tree_2AABB_insertion_example_8cpp-example.html#_a4">AABB_tree/AABB_insertion_example.cpp</a>, <a class="el" href="AABB_tree_2AABB_polyhedron_edge_example_8cpp-example.html#_a4">AABB_tree/AABB_polyhedron_edge_example.cpp</a>, <a class="el" href="AABB_tree_2AABB_polyhedron_facet_distance_example_8cpp-example.html#_a4">AABB_tree/AABB_polyhedron_facet_distance_example.cpp</a>, <a class="el" href="AABB_tree_2AABB_polyhedron_facet_intersection_example_8cpp-example.html#_a4">AABB_tree/AABB_polyhedron_facet_intersection_example.cpp</a>, <a class="el" href="AABB_tree_2AABB_polyline_segment_2_example_8cpp-example.html#_a3">AABB_tree/AABB_polyline_segment_2_example.cpp</a>, <a class="el" href="AABB_tree_2AABB_ray_shooting_example_8cpp-example.html#_a3">AABB_tree/AABB_ray_shooting_example.cpp</a>, <a class="el" href="AABB_tree_2AABB_segment_2_example_8cpp-example.html#_a4">AABB_tree/AABB_segment_2_example.cpp</a>, <a class="el" href="AABB_tree_2AABB_segment_3_example_8cpp-example.html#_a4">AABB_tree/AABB_segment_3_example.cpp</a>, <a class="el" href="AABB_tree_2AABB_triangle_2_example_8cpp-example.html#_a4">AABB_tree/AABB_triangle_2_example.cpp</a>, and <a class="el" href="AABB_tree_2AABB_triangle_3_example_8cpp-example.html#_a4">AABB_tree/AABB_triangle_3_example.cpp</a>.</dd>
</dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a796da95e5579fe92edcec9f28cc629be"><td class="memItemLeft" align="right" valign="top"><a id="a796da95e5579fe92edcec9f28cc629be" name="a796da95e5579fe92edcec9f28cc629be"></a>
AABBTraits::Primitive::Datum_referenceÂ </td><td class="memItemRight" valign="bottom"><b>datum</b> (<a class="el" href="classCGAL_1_1AABB__tree.html#aa27d769aa89e77dd5ab3769c21f64e7e">Primitive</a> &amp;p) const</td></tr>
<tr class="memdesc:a796da95e5579fe92edcec9f28cc629be"><td class="mdescLeft">Â </td><td class="mdescRight">Returns the datum (geometric object) represented <code>p</code>. <br></td></tr>
<tr class="separator:a796da95e5579fe92edcec9f28cc629be"><td class="memSeparator" colspan="2">Â </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Types</h2></td></tr>
<tr class="memitem:abc411ecfc01a20f0fa05d490926f40e4"><td class="memItemLeft" align="right" valign="top"><a id="abc411ecfc01a20f0fa05d490926f40e4" name="abc411ecfc01a20f0fa05d490926f40e4"></a>
typedef <a class="el" href="classAABBTraits.html#a1ee53f64a2ab05d4389003d4f36539e4">AABBTraits::FT</a>Â </td><td class="memItemRight" valign="bottom"><b>FT</b></td></tr>
<tr class="memdesc:abc411ecfc01a20f0fa05d490926f40e4"><td class="mdescLeft">Â </td><td class="mdescRight">Number type returned by the distance queries. <br></td></tr>
<tr class="separator:abc411ecfc01a20f0fa05d490926f40e4"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:ac3f4cc3966bfa5ec398b52b2330940af"><td class="memItemLeft" align="right" valign="top"><a id="ac3f4cc3966bfa5ec398b52b2330940af" name="ac3f4cc3966bfa5ec398b52b2330940af"></a>
typedef <a class="el" href="classAABBTraits.html#a88a622647c5438503237ce957d99801f">AABBTraits::Point</a>Â </td><td class="memItemRight" valign="bottom"><b>Point</b></td></tr>
<tr class="memdesc:ac3f4cc3966bfa5ec398b52b2330940af"><td class="mdescLeft">Â </td><td class="mdescRight">Type of point. <br></td></tr>
<tr class="separator:ac3f4cc3966bfa5ec398b52b2330940af"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:aa27d769aa89e77dd5ab3769c21f64e7e"><td class="memItemLeft" align="right" valign="top"><a id="aa27d769aa89e77dd5ab3769c21f64e7e" name="aa27d769aa89e77dd5ab3769c21f64e7e"></a>
typedef <a class="el" href="classAABBTraits.html#a18812bafada570757269e313ab06ff51">AABBTraits::Primitive</a>Â </td><td class="memItemRight" valign="bottom"><b>Primitive</b></td></tr>
<tr class="memdesc:aa27d769aa89e77dd5ab3769c21f64e7e"><td class="mdescLeft">Â </td><td class="mdescRight">Type of input primitive. <br></td></tr>
<tr class="separator:aa27d769aa89e77dd5ab3769c21f64e7e"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:a3f107d7a22b491cb71c6d7b6c660e19c"><td class="memItemLeft" align="right" valign="top"><a id="a3f107d7a22b491cb71c6d7b6c660e19c" name="a3f107d7a22b491cb71c6d7b6c660e19c"></a>
typedef Primitive::IdÂ </td><td class="memItemRight" valign="bottom"><b>Primitive_id</b></td></tr>
<tr class="memdesc:a3f107d7a22b491cb71c6d7b6c660e19c"><td class="mdescLeft">Â </td><td class="mdescRight">Identifier for a primitive in the tree. <br></td></tr>
<tr class="separator:a3f107d7a22b491cb71c6d7b6c660e19c"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:a6f03da4364c74c764681c84c3f14dcfe"><td class="memItemLeft" align="right" valign="top"><a id="a6f03da4364c74c764681c84c3f14dcfe" name="a6f03da4364c74c764681c84c3f14dcfe"></a>
typedef Primitives::size_typeÂ </td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="memdesc:a6f03da4364c74c764681c84c3f14dcfe"><td class="mdescLeft">Â </td><td class="mdescRight">Unsigned integral size type. <br></td></tr>
<tr class="separator:a6f03da4364c74c764681c84c3f14dcfe"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:ad0e923c3e39a12596648c1b6ba057e17"><td class="memItemLeft" align="right" valign="top"><a id="ad0e923c3e39a12596648c1b6ba057e17" name="ad0e923c3e39a12596648c1b6ba057e17"></a>
typedef <a class="el" href="classAABBTraits.html#a71832e63c8ab85c356fa6b3fc792ed3e">AABBTraits::Bounding_box</a>Â </td><td class="memItemRight" valign="bottom"><b>Bounding_box</b></td></tr>
<tr class="memdesc:ad0e923c3e39a12596648c1b6ba057e17"><td class="mdescLeft">Â </td><td class="mdescRight">Type of bounding box. <br></td></tr>
<tr class="separator:ad0e923c3e39a12596648c1b6ba057e17"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:a74ce5787605d37cd218701ea98968e82"><td class="memItemLeft" align="right" valign="top"><a id="a74ce5787605d37cd218701ea98968e82" name="a74ce5787605d37cd218701ea98968e82"></a>
typedef <a class="el" href="classAABBTraits.html#a3c855ac5072a7a039cc043ff2b8e74c6">AABBTraits::Point_and_primitive_id</a>Â </td><td class="memItemRight" valign="bottom"><b>Point_and_primitive_id</b></td></tr>
<tr class="memdesc:a74ce5787605d37cd218701ea98968e82"><td class="mdescLeft">Â </td><td class="mdescRight">Point and Primitive Id type. <br></td></tr>
<tr class="separator:a74ce5787605d37cd218701ea98968e82"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:afe6da1de3ad3c806512de7b091cd37f7"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classAABBTraits.html#afeb8685b51df66ec98d9bf72e04007bf">AABBTraits::Object_and_primitive_id</a>Â </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1AABB__tree.html#afe6da1de3ad3c806512de7b091cd37f7">Object_and_primitive_id</a></td></tr>
<tr class="separator:afe6da1de3ad3c806512de7b091cd37f7"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:adcd65e098e0a79ce66a7df0097ba98aa"><td class="memTemplParams" colspan="2"><a id="adcd65e098e0a79ce66a7df0097ba98aa" name="adcd65e098e0a79ce66a7df0097ba98aa"></a>
template&lt;typename Query &gt; </td></tr>
<tr class="memitem:adcd65e098e0a79ce66a7df0097ba98aa"><td class="memTemplItemLeft" align="right" valign="top">usingÂ </td><td class="memTemplItemRight" valign="bottom"><b>Intersection_and_primitive_id</b> = <a class="el" href="classAABBTraits.html#af5b2ef75e7fca67d9ab37b0d4984000b">AABBTraits::Intersection_and_primitive_id</a>&lt; Query &gt;</td></tr>
<tr class="memdesc:adcd65e098e0a79ce66a7df0097ba98aa"><td class="mdescLeft">Â </td><td class="mdescRight">An alias to <code><a class="el" href="classAABBTraits.html#af5b2ef75e7fca67d9ab37b0d4984000b" title="A nested class template providing as a pair the intersection result of a Query object and a Primitive...">AABBTraits::Intersection_and_primitive_id</a>&lt;Query&gt;</code> <br></td></tr>
<tr class="separator:adcd65e098e0a79ce66a7df0097ba98aa"><td class="memSeparator" colspan="2">Â </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Creation</h2></td></tr>
<tr class="memitem:a9f207cf5480458cb4ecfce46e60c9d06"><td class="memItemLeft" align="right" valign="top"><a id="a9f207cf5480458cb4ecfce46e60c9d06" name="a9f207cf5480458cb4ecfce46e60c9d06"></a>
Â </td><td class="memItemRight" valign="bottom"><b>AABB_tree</b> (const <a class="el" href="classAABBTraits.html">AABBTraits</a> &amp;<a class="el" href="classCGAL_1_1AABB__tree.html#a11f25b1717ba0422d13e06fdd603aa67">traits</a>=<a class="el" href="classAABBTraits.html">AABBTraits</a>())</td></tr>
<tr class="memdesc:a9f207cf5480458cb4ecfce46e60c9d06"><td class="mdescLeft">Â </td><td class="mdescRight">constructs an empty tree, and initializes the internally stored traits class using <code>traits</code>. <br></td></tr>
<tr class="separator:a9f207cf5480458cb4ecfce46e60c9d06"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:a2d424e50e44392f9f88ee91411edabcc"><td class="memItemLeft" align="right" valign="top"><a id="a2d424e50e44392f9f88ee91411edabcc" name="a2d424e50e44392f9f88ee91411edabcc"></a>
Â </td><td class="memItemRight" valign="bottom"><b>AABB_tree</b> (<a class="el" href="classCGAL_1_1AABB__tree.html">Self</a> &amp;&amp;) noexcept</td></tr>
<tr class="memdesc:a2d424e50e44392f9f88ee91411edabcc"><td class="mdescLeft">Â </td><td class="mdescRight">move constructor <br></td></tr>
<tr class="separator:a2d424e50e44392f9f88ee91411edabcc"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:a8843ab883443df5f9d353c51bc6c13bc"><td class="memItemLeft" align="right" valign="top"><a id="a8843ab883443df5f9d353c51bc6c13bc" name="a8843ab883443df5f9d353c51bc6c13bc"></a>
<a class="el" href="classCGAL_1_1AABB__tree.html">Self</a> &amp;Â </td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classCGAL_1_1AABB__tree.html">Self</a> &amp;&amp;) noexcept</td></tr>
<tr class="memdesc:a8843ab883443df5f9d353c51bc6c13bc"><td class="mdescLeft">Â </td><td class="mdescRight">assignment operator <br></td></tr>
<tr class="separator:a8843ab883443df5f9d353c51bc6c13bc"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:ae4b6bf22ae8ab2c912b33f711b7cef44"><td class="memItemLeft" align="right" valign="top"><a id="ae4b6bf22ae8ab2c912b33f711b7cef44" name="ae4b6bf22ae8ab2c912b33f711b7cef44"></a>
Â </td><td class="memItemRight" valign="bottom"><b>AABB_tree</b> (const <a class="el" href="classCGAL_1_1AABB__tree.html">Self</a> &amp;)=delete</td></tr>
<tr class="separator:ae4b6bf22ae8ab2c912b33f711b7cef44"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:a80f58011bbd87fb9a6148766f98d2d61"><td class="memItemLeft" align="right" valign="top"><a id="a80f58011bbd87fb9a6148766f98d2d61" name="a80f58011bbd87fb9a6148766f98d2d61"></a>
<a class="el" href="classCGAL_1_1AABB__tree.html">Self</a> &amp;Â </td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classCGAL_1_1AABB__tree.html">Self</a> &amp;)=delete</td></tr>
<tr class="separator:a80f58011bbd87fb9a6148766f98d2d61"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:a27943b5072da1f829432c49683a896b4"><td class="memTemplParams" colspan="2">template&lt;typename <a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> , typename ... T&gt; </td></tr>
<tr class="memitem:a27943b5072da1f829432c49683a896b4"><td class="memTemplItemLeft" align="right" valign="top">Â </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1AABB__tree.html#a27943b5072da1f829432c49683a896b4">AABB_tree</a> (<a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> first, <a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> beyond, T &amp;&amp;...)</td></tr>
<tr class="memdesc:a27943b5072da1f829432c49683a896b4"><td class="mdescLeft">Â </td><td class="mdescRight">builds the data structure from a sequence of primitives.  <br></td></tr>
<tr class="separator:a27943b5072da1f829432c49683a896b4"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:a817b811901a9f3c43400ddb49f4cc121"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a817b811901a9f3c43400ddb49f4cc121"><td class="memTemplItemLeft" align="right" valign="top">voidÂ </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1AABB__tree.html#a817b811901a9f3c43400ddb49f4cc121">build</a> (T &amp;&amp;...)</td></tr>
<tr class="memdesc:a817b811901a9f3c43400ddb49f4cc121"><td class="mdescLeft">Â </td><td class="mdescRight">triggers the (re)construction of the internal tree structure.  <br></td></tr>
<tr class="separator:a817b811901a9f3c43400ddb49f4cc121"><td class="memSeparator" colspan="2">Â </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Operations</h2></td></tr>
<tr class="memitem:af09ea7b0be4ad9b1135bc0052025dcc3"><td class="memTemplParams" colspan="2"><a id="af09ea7b0be4ad9b1135bc0052025dcc3" name="af09ea7b0be4ad9b1135bc0052025dcc3"></a>
template&lt;typename ConstPrimitiveIterator , typename ... T&gt; </td></tr>
<tr class="memitem:af09ea7b0be4ad9b1135bc0052025dcc3"><td class="memTemplItemLeft" align="right" valign="top">voidÂ </td><td class="memTemplItemRight" valign="bottom"><b>rebuild</b> (ConstPrimitiveIterator first, ConstPrimitiveIterator beyond, T &amp;&amp;...)</td></tr>
<tr class="memdesc:af09ea7b0be4ad9b1135bc0052025dcc3"><td class="mdescLeft">Â </td><td class="mdescRight">is equivalent to calling <code><a class="el" href="classCGAL_1_1AABB__tree.html#a5d804c64b784edc629a0db86154336d3" title="clears the tree and the search tree if it was constructed, and switches on the usage of the search tr...">clear()</a></code>, <code>insert(first,last,t...)</code>, and <code>build()</code> <br></td></tr>
<tr class="separator:af09ea7b0be4ad9b1135bc0052025dcc3"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:a5de00f7e7563d40132ec0676b5caf979"><td class="memTemplParams" colspan="2">template&lt;typename <a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> , typename ... T&gt; </td></tr>
<tr class="memitem:a5de00f7e7563d40132ec0676b5caf979"><td class="memTemplItemLeft" align="right" valign="top">voidÂ </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1AABB__tree.html#a5de00f7e7563d40132ec0676b5caf979">insert</a> (<a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> first, <a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> beyond, T &amp;&amp;...)</td></tr>
<tr class="memdesc:a5de00f7e7563d40132ec0676b5caf979"><td class="mdescLeft">Â </td><td class="mdescRight">adds a sequence of primitives to the set of primitives of the AABB tree.  <br></td></tr>
<tr class="separator:a5de00f7e7563d40132ec0676b5caf979"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:a7fd6771ded7d4699733c9e921506c603"><td class="memItemLeft" align="right" valign="top"><a id="a7fd6771ded7d4699733c9e921506c603" name="a7fd6771ded7d4699733c9e921506c603"></a>
voidÂ </td><td class="memItemRight" valign="bottom"><b>insert</b> (const <a class="el" href="classCGAL_1_1AABB__tree.html#aa27d769aa89e77dd5ab3769c21f64e7e">Primitive</a> &amp;p)</td></tr>
<tr class="memdesc:a7fd6771ded7d4699733c9e921506c603"><td class="mdescLeft">Â </td><td class="mdescRight">adds a primitive to the set of primitives of the tree. <br></td></tr>
<tr class="separator:a7fd6771ded7d4699733c9e921506c603"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:ad1889027637e1a5f0b19c91508eddfa3"><td class="memItemLeft" align="right" valign="top"><a id="ad1889027637e1a5f0b19c91508eddfa3" name="ad1889027637e1a5f0b19c91508eddfa3"></a>
Â </td><td class="memItemRight" valign="bottom"><b>~AABB_tree</b> ()</td></tr>
<tr class="memdesc:ad1889027637e1a5f0b19c91508eddfa3"><td class="mdescLeft">Â </td><td class="mdescRight">clears and destroys the tree. <br></td></tr>
<tr class="separator:ad1889027637e1a5f0b19c91508eddfa3"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:a11f25b1717ba0422d13e06fdd603aa67"><td class="memItemLeft" align="right" valign="top"><a id="a11f25b1717ba0422d13e06fdd603aa67" name="a11f25b1717ba0422d13e06fdd603aa67"></a>
const <a class="el" href="classAABBTraits.html">AABBTraits</a> &amp;Â </td><td class="memItemRight" valign="bottom"><b>traits</b> () const</td></tr>
<tr class="memdesc:a11f25b1717ba0422d13e06fdd603aa67"><td class="mdescLeft">Â </td><td class="mdescRight">returns a const reference to the internally stored traits class. <br></td></tr>
<tr class="separator:a11f25b1717ba0422d13e06fdd603aa67"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:a5d804c64b784edc629a0db86154336d3"><td class="memItemLeft" align="right" valign="top"><a id="a5d804c64b784edc629a0db86154336d3" name="a5d804c64b784edc629a0db86154336d3"></a>
voidÂ </td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="memdesc:a5d804c64b784edc629a0db86154336d3"><td class="mdescLeft">Â </td><td class="mdescRight">clears the tree and the search tree if it was constructed, and switches on the usage of the search tree to find the hint for the distance queries <br></td></tr>
<tr class="separator:a5d804c64b784edc629a0db86154336d3"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:a50e221f6910aacdef2ecba85f8f459b4"><td class="memItemLeft" align="right" valign="top"><a id="a50e221f6910aacdef2ecba85f8f459b4" name="a50e221f6910aacdef2ecba85f8f459b4"></a>
const <a class="el" href="classCGAL_1_1AABB__tree.html#ad0e923c3e39a12596648c1b6ba057e17">Bounding_box</a>Â </td><td class="memItemRight" valign="bottom"><b>bbox</b> () const</td></tr>
<tr class="memdesc:a50e221f6910aacdef2ecba85f8f459b4"><td class="mdescLeft">Â </td><td class="mdescRight">returns the axis-aligned bounding box of the whole tree. <br></td></tr>
<tr class="separator:a50e221f6910aacdef2ecba85f8f459b4"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:a55f67db717c1e202806cb77be1b13795"><td class="memItemLeft" align="right" valign="top"><a id="a55f67db717c1e202806cb77be1b13795" name="a55f67db717c1e202806cb77be1b13795"></a>
<a class="el" href="classCGAL_1_1AABB__tree.html#a6f03da4364c74c764681c84c3f14dcfe">size_type</a>Â </td><td class="memItemRight" valign="bottom"><b>size</b> () const</td></tr>
<tr class="memdesc:a55f67db717c1e202806cb77be1b13795"><td class="mdescLeft">Â </td><td class="mdescRight">returns the number of primitives in the tree. <br></td></tr>
<tr class="separator:a55f67db717c1e202806cb77be1b13795"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:a45053dc4244f0f55390dbad088f1c707"><td class="memItemLeft" align="right" valign="top"><a id="a45053dc4244f0f55390dbad088f1c707" name="a45053dc4244f0f55390dbad088f1c707"></a>
boolÂ </td><td class="memItemRight" valign="bottom"><b>empty</b> () const</td></tr>
<tr class="memdesc:a45053dc4244f0f55390dbad088f1c707"><td class="mdescLeft">Â </td><td class="mdescRight">returns <code>true</code>, iff the tree contains no primitive. <br></td></tr>
<tr class="separator:a45053dc4244f0f55390dbad088f1c707"><td class="memSeparator" colspan="2">Â </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Intersection Tests</h2></td></tr>
<tr class="memitem:a36b4cfa21c223461bde0da2b020a67d1"><td class="memTemplParams" colspan="2">template&lt;typename Query &gt; </td></tr>
<tr class="memitem:a36b4cfa21c223461bde0da2b020a67d1"><td class="memTemplItemLeft" align="right" valign="top">boolÂ </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1AABB__tree.html#a36b4cfa21c223461bde0da2b020a67d1">do_intersect</a> (const Query &amp;query) const</td></tr>
<tr class="memdesc:a36b4cfa21c223461bde0da2b020a67d1"><td class="mdescLeft">Â </td><td class="mdescRight">returns <code>true</code>, iff the query intersects at least one of the input primitives.  <br></td></tr>
<tr class="separator:a36b4cfa21c223461bde0da2b020a67d1"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:a872a72b57bbbb1d322fc8ef696e19057"><td class="memTemplParams" colspan="2">template&lt;typename Query &gt; </td></tr>
<tr class="memitem:a872a72b57bbbb1d322fc8ef696e19057"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1AABB__tree.html#a6f03da4364c74c764681c84c3f14dcfe">size_type</a>Â </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1AABB__tree.html#a872a72b57bbbb1d322fc8ef696e19057">number_of_intersected_primitives</a> (const Query &amp;query) const</td></tr>
<tr class="memdesc:a872a72b57bbbb1d322fc8ef696e19057"><td class="mdescLeft">Â </td><td class="mdescRight">returns the number of primitives intersected by the query.  <br></td></tr>
<tr class="separator:a872a72b57bbbb1d322fc8ef696e19057"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:a9f40594599eded5f9a79f74186710697"><td class="memTemplParams" colspan="2">template&lt;typename Query , typename <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> &gt; </td></tr>
<tr class="memitem:a9f40594599eded5f9a79f74186710697"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a>Â </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1AABB__tree.html#a9f40594599eded5f9a79f74186710697">all_intersected_primitives</a> (const Query &amp;query, <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> out) const</td></tr>
<tr class="memdesc:a9f40594599eded5f9a79f74186710697"><td class="mdescLeft">Â </td><td class="mdescRight">puts in <code>out</code> the ids of all intersected primitives.  <br></td></tr>
<tr class="separator:a9f40594599eded5f9a79f74186710697"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:af4d94dc88ad5bd31d6368d96d3d07780"><td class="memTemplParams" colspan="2">template&lt;typename Query &gt; </td></tr>
<tr class="memitem:af4d94dc88ad5bd31d6368d96d3d07780"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classCGAL_1_1AABB__tree.html#a3f107d7a22b491cb71c6d7b6c660e19c">Primitive_id</a> &gt;Â </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1AABB__tree.html#af4d94dc88ad5bd31d6368d96d3d07780">any_intersected_primitive</a> (const Query &amp;query) const</td></tr>
<tr class="memdesc:af4d94dc88ad5bd31d6368d96d3d07780"><td class="mdescLeft">Â </td><td class="mdescRight">returns the id of the intersected primitive that is encountered first in the tree traversal, iff the query intersects at least one of the input primitives.  <br></td></tr>
<tr class="separator:af4d94dc88ad5bd31d6368d96d3d07780"><td class="memSeparator" colspan="2">Â </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Intersections</h2></td></tr>
<tr class="memitem:adf42c2edae69f92db5646d2c81d3bbff"><td class="memTemplParams" colspan="2">template&lt;typename Query , typename <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> &gt; </td></tr>
<tr class="memitem:adf42c2edae69f92db5646d2c81d3bbff"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a>Â </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1AABB__tree.html#adf42c2edae69f92db5646d2c81d3bbff">all_intersections</a> (const Query &amp;query, <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> out) const</td></tr>
<tr class="memdesc:adf42c2edae69f92db5646d2c81d3bbff"><td class="mdescLeft">Â </td><td class="mdescRight">puts in <code>out</code> all intersections, as objects of <code>Intersection_and_primitive_id&lt;Query&gt;::Type</code>, between the query and the input data to the iterator.  <br></td></tr>
<tr class="separator:adf42c2edae69f92db5646d2c81d3bbff"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:a8ccaea5223809316c67d03713109e7a1"><td class="memTemplParams" colspan="2">template&lt;typename Query &gt; </td></tr>
<tr class="memitem:a8ccaea5223809316c67d03713109e7a1"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; typename <a class="el" href="classCGAL_1_1AABB__tree.html#adcd65e098e0a79ce66a7df0097ba98aa">Intersection_and_primitive_id</a>&lt; Query &gt;::Type &gt;Â </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1AABB__tree.html#a8ccaea5223809316c67d03713109e7a1">any_intersection</a> (const Query &amp;query) const</td></tr>
<tr class="memdesc:a8ccaea5223809316c67d03713109e7a1"><td class="mdescLeft">Â </td><td class="mdescRight">returns if any the intersection that is encountered first in the tree traversal.  <br></td></tr>
<tr class="separator:a8ccaea5223809316c67d03713109e7a1"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:a3d24bfdc557114acc305658f9730eb60"><td class="memTemplParams" colspan="2">template&lt;typename Ray , typename SkipFunctor &gt; </td></tr>
<tr class="memitem:a3d24bfdc557114acc305658f9730eb60"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; typename <a class="el" href="classCGAL_1_1AABB__tree.html#adcd65e098e0a79ce66a7df0097ba98aa">Intersection_and_primitive_id</a>&lt; Ray &gt;::Type &gt;Â </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1AABB__tree.html#a3d24bfdc557114acc305658f9730eb60">first_intersection</a> (const Ray &amp;query, const SkipFunctor &amp;skip) const</td></tr>
<tr class="memdesc:a3d24bfdc557114acc305658f9730eb60"><td class="mdescLeft">Â </td><td class="mdescRight">returns the intersection and primitive id closest to the source point of the ray query.  <br></td></tr>
<tr class="separator:a3d24bfdc557114acc305658f9730eb60"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:adfc6a7887966a2d8c726143f5a52a77d"><td class="memTemplParams" colspan="2">template&lt;typename Ray , typename SkipFunctor &gt; </td></tr>
<tr class="memitem:adfc6a7887966a2d8c726143f5a52a77d"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classCGAL_1_1AABB__tree.html#a3f107d7a22b491cb71c6d7b6c660e19c">Primitive_id</a> &gt;Â </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1AABB__tree.html#adfc6a7887966a2d8c726143f5a52a77d">first_intersected_primitive</a> (const Ray &amp;query, const SkipFunctor &amp;skip) const</td></tr>
<tr class="memdesc:adfc6a7887966a2d8c726143f5a52a77d"><td class="mdescLeft">Â </td><td class="mdescRight">returns the primitive id closest to the source point of the ray query.  <br></td></tr>
<tr class="separator:adfc6a7887966a2d8c726143f5a52a77d"><td class="memSeparator" colspan="2">Â </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Distance Queries</h2></td></tr>
<tr class="memitem:a24efb545081b6796d8843861a4bf49e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1AABB__tree.html#abc411ecfc01a20f0fa05d490926f40e4">FT</a>Â </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1AABB__tree.html#a24efb545081b6796d8843861a4bf49e6">squared_distance</a> (const <a class="el" href="classCGAL_1_1AABB__tree.html#ac3f4cc3966bfa5ec398b52b2330940af">Point</a> &amp;query) const</td></tr>
<tr class="memdesc:a24efb545081b6796d8843861a4bf49e6"><td class="mdescLeft">Â </td><td class="mdescRight">returns the minimum squared distance between the query point and all input primitives.  <br></td></tr>
<tr class="separator:a24efb545081b6796d8843861a4bf49e6"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:abe3e1ab4a89de2623b6930324343b2fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1AABB__tree.html#ac3f4cc3966bfa5ec398b52b2330940af">Point</a>Â </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1AABB__tree.html#abe3e1ab4a89de2623b6930324343b2fa">closest_point</a> (const <a class="el" href="classCGAL_1_1AABB__tree.html#ac3f4cc3966bfa5ec398b52b2330940af">Point</a> &amp;query) const</td></tr>
<tr class="memdesc:abe3e1ab4a89de2623b6930324343b2fa"><td class="mdescLeft">Â </td><td class="mdescRight">returns the point in the union of all input primitives which is closest to the query.  <br></td></tr>
<tr class="separator:abe3e1ab4a89de2623b6930324343b2fa"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:a1b3ac9521fd7257f760deafff3743437"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1AABB__tree.html#a74ce5787605d37cd218701ea98968e82">Point_and_primitive_id</a>Â </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1AABB__tree.html#a1b3ac9521fd7257f760deafff3743437">closest_point_and_primitive</a> (const <a class="el" href="classCGAL_1_1AABB__tree.html#ac3f4cc3966bfa5ec398b52b2330940af">Point</a> &amp;query) const</td></tr>
<tr class="memdesc:a1b3ac9521fd7257f760deafff3743437"><td class="mdescLeft">Â </td><td class="mdescRight">returns a <code>Point_and_primitive_id</code> which realizes the smallest distance between the query point and all input primitives.  <br></td></tr>
<tr class="separator:a1b3ac9521fd7257f760deafff3743437"><td class="memSeparator" colspan="2">Â </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Accelerating the Distance Queries</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>In the following paragraphs, we discuss details of the implementation of the distance queries.</p>
<p>We explain the internal use of hints, how the user can pass his own hints to the tree, and how the user can influence the construction of the secondary data structure used for accelerating distance queries. Internally, the distance queries algorithms are initialized with some hint, which has the same type as the return type of the query, and this value is refined along a traversal of the tree, until it is optimal, that is to say until it realizes the shortest distance to the primitives. In particular, the exact specification of these internal algorithms is that they minimize the distance to the object composed of the union of the primitives and the hint. It follows that</p><ul>
<li>in order to return the exact distance to the set of primitives, the algorithms need the hint to be exactly on the primitives;</li>
<li>if this is not the case, and if the hint happens to be closer to the query point than any of the primitives, then the hint is returned.</li>
</ul>
<p>This second observation is reasonable, in the sense that providing a hint to the algorithm means claiming that this hint belongs to the union of the primitives. These considerations about the hints being exactly on the primitives or not are important: in the case where the set of primitives is a triangle soup, and if some of the primitives are large, one may want to provide a much better hint than a vertex of the triangle soup could be. It could be, for example, the barycenter of one of the triangles. But, except with the use of a kernel with exact constructions, one cannot easily construct points other than the vertices, that lie exactly on a triangle soup. Hence, providing a good hint sometimes means not being able to provide it exactly on the primitives. In rare occasions, this hint can be returned as the closest point. In order to accelerate distance queries significantly, the AABB tree builds an internal KD-tree containing a set of potential hints. This KD-tree provides very good hints that allow the algorithms to run much faster than when <code><a class="el" href="classCGAL_1_1AABB__tree.html#abde62f52ccdf411847151aa5000ba4a4" title="turns off the usage of the internal search tree and clears it if it was already constructed.">do_not_accelerate_distance_queries()</a></code> that makes the hint to always be the <code>reference_point</code> of the first primitive. The set of potential hints is a sampling of the union of the primitives, which is obtained, by default, by calling the method <code>reference_point</code> of each of the primitives. However, such a sampling with one point per primitive may not be the most relevant one: if some primitives are very large, it helps inserting more than one sample on them. Conversely, a sparser sampling with less than one point per input primitive is relevant in some cases. The internal KD-tree is always used if no call to <code><a class="el" href="classCGAL_1_1AABB__tree.html#abde62f52ccdf411847151aa5000ba4a4" title="turns off the usage of the internal search tree and clears it if it was already constructed.">do_not_accelerate_distance_queries()</a></code> was made since object creation or the last call to <code><a class="el" href="classCGAL_1_1AABB__tree.html#a5d804c64b784edc629a0db86154336d3" title="clears the tree and the search tree if it was constructed, and switches on the usage of the search tr...">clear()</a></code>. It will be built by the first distance query or by a call to <code><a class="el" href="classCGAL_1_1AABB__tree.html#a5d3877d3f2afbd09341eb4b8c230080b" title="constructs the internal search tree from a point set taken on the internal primitives returns true if...">accelerate_distance_queries()</a></code>. </p>
</td></tr>
<tr class="memitem:a5d3877d3f2afbd09341eb4b8c230080b"><td class="memItemLeft" align="right" valign="top"><a id="a5d3877d3f2afbd09341eb4b8c230080b" name="a5d3877d3f2afbd09341eb4b8c230080b"></a>
boolÂ </td><td class="memItemRight" valign="bottom"><b>accelerate_distance_queries</b> ()</td></tr>
<tr class="memdesc:a5d3877d3f2afbd09341eb4b8c230080b"><td class="mdescLeft">Â </td><td class="mdescRight">constructs the internal search tree from a point set taken on the internal primitives returns <code>true</code> iff successful memory allocation <br></td></tr>
<tr class="separator:a5d3877d3f2afbd09341eb4b8c230080b"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:abde62f52ccdf411847151aa5000ba4a4"><td class="memItemLeft" align="right" valign="top"><a id="abde62f52ccdf411847151aa5000ba4a4" name="abde62f52ccdf411847151aa5000ba4a4"></a>
voidÂ </td><td class="memItemRight" valign="bottom"><b>do_not_accelerate_distance_queries</b> ()</td></tr>
<tr class="memdesc:abde62f52ccdf411847151aa5000ba4a4"><td class="mdescLeft">Â </td><td class="mdescRight">turns off the usage of the internal search tree and clears it if it was already constructed. <br></td></tr>
<tr class="separator:abde62f52ccdf411847151aa5000ba4a4"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:a974e4c1bf69cfd46fd32631a80321a27"><td class="memTemplParams" colspan="2">template&lt;typename ConstPointIterator &gt; </td></tr>
<tr class="memitem:a974e4c1bf69cfd46fd32631a80321a27"><td class="memTemplItemLeft" align="right" valign="top">boolÂ </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1AABB__tree.html#a974e4c1bf69cfd46fd32631a80321a27">accelerate_distance_queries</a> (ConstPointIterator first, ConstPointIterator beyond)</td></tr>
<tr class="memdesc:a974e4c1bf69cfd46fd32631a80321a27"><td class="mdescLeft">Â </td><td class="mdescRight">constructs an internal KD-tree containing the specified point set, to be used as the set of potential hints for accelerating the distance queries.  <br></td></tr>
<tr class="separator:a974e4c1bf69cfd46fd32631a80321a27"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:aa542b5235ab36f004f4c6b953b909aff"><td class="memTemplParams" colspan="2">template&lt;typename ConstPointIterator , typename PointMap &gt; </td></tr>
<tr class="memitem:aa542b5235ab36f004f4c6b953b909aff"><td class="memTemplItemLeft" align="right" valign="top">boolÂ </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1AABB__tree.html#aa542b5235ab36f004f4c6b953b909aff">accelerate_distance_queries</a> (ConstPointIterator first, ConstPointIterator beyond, PointMap pmap)</td></tr>
<tr class="memdesc:aa542b5235ab36f004f4c6b953b909aff"><td class="mdescLeft">Â </td><td class="mdescRight">constructs an internal KD-tree containing the specified point set, to be used as the set of potential hints for accelerating the distance queries.  <br></td></tr>
<tr class="separator:aa542b5235ab36f004f4c6b953b909aff"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:a3c2a4681e3440beb909b2596b0988bad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1AABB__tree.html#abc411ecfc01a20f0fa05d490926f40e4">FT</a>Â </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1AABB__tree.html#a3c2a4681e3440beb909b2596b0988bad">squared_distance</a> (const <a class="el" href="classCGAL_1_1AABB__tree.html#ac3f4cc3966bfa5ec398b52b2330940af">Point</a> &amp;query, const <a class="el" href="classCGAL_1_1AABB__tree.html#ac3f4cc3966bfa5ec398b52b2330940af">Point</a> &amp;hint) const</td></tr>
<tr class="memdesc:a3c2a4681e3440beb909b2596b0988bad"><td class="mdescLeft">Â </td><td class="mdescRight">returns the minimum squared distance between the query point and all input primitives.  <br></td></tr>
<tr class="separator:a3c2a4681e3440beb909b2596b0988bad"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:a5aeffff0695b818998279aae800915b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1AABB__tree.html#ac3f4cc3966bfa5ec398b52b2330940af">Point</a>Â </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1AABB__tree.html#a5aeffff0695b818998279aae800915b5">closest_point</a> (const <a class="el" href="classCGAL_1_1AABB__tree.html#ac3f4cc3966bfa5ec398b52b2330940af">Point</a> &amp;query, const <a class="el" href="classCGAL_1_1AABB__tree.html#ac3f4cc3966bfa5ec398b52b2330940af">Point</a> &amp;hint) const</td></tr>
<tr class="memdesc:a5aeffff0695b818998279aae800915b5"><td class="mdescLeft">Â </td><td class="mdescRight">returns the point in the union of all input primitives which is closest to the query.  <br></td></tr>
<tr class="separator:a5aeffff0695b818998279aae800915b5"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:a3a42a8e1d5594e7a708fdfe833474205"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1AABB__tree.html#a74ce5787605d37cd218701ea98968e82">Point_and_primitive_id</a>Â </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1AABB__tree.html#a3a42a8e1d5594e7a708fdfe833474205">closest_point_and_primitive</a> (const <a class="el" href="classCGAL_1_1AABB__tree.html#ac3f4cc3966bfa5ec398b52b2330940af">Point</a> &amp;query, const <a class="el" href="classCGAL_1_1AABB__tree.html#a74ce5787605d37cd218701ea98968e82">Point_and_primitive_id</a> &amp;hint) const</td></tr>
<tr class="memdesc:a3a42a8e1d5594e7a708fdfe833474205"><td class="mdescLeft">Â </td><td class="mdescRight">returns a <code>Point_and_primitive_id</code> which realizes the smallest distance between the query point and all input primitives.  <br></td></tr>
<tr class="separator:a3a42a8e1d5594e7a708fdfe833474205"><td class="memSeparator" colspan="2">Â </td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="afe6da1de3ad3c806512de7b091cd37f7" name="afe6da1de3ad3c806512de7b091cd37f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe6da1de3ad3c806512de7b091cd37f7">âÂ </a></span>Object_and_primitive_id</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classAABBTraits.html">AABBTraits</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classAABBTraits.html#afeb8685b51df66ec98d9bf72e04007bf">AABBTraits::Object_and_primitive_id</a> <a class="el" href="classCGAL_1_1AABB__tree.html">CGAL::AABB_tree</a>&lt; <a class="el" href="classAABBTraits.html">AABBTraits</a> &gt;::Object_and_primitive_id</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd></dd></dl>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a27943b5072da1f829432c49683a896b4" name="a27943b5072da1f829432c49683a896b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27943b5072da1f829432c49683a896b4">âÂ </a></span>AABB_tree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classAABBTraits.html">AABBTraits</a> &gt; </div>
<div class="memtemplate">
template&lt;typename <a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> , typename ... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1AABB__tree.html">CGAL::AABB_tree</a>&lt; <a class="el" href="classAABBTraits.html">AABBTraits</a> &gt;::AABB_tree </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a>Â </td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a>Â </td>
          <td class="paramname"><em>beyond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;Â </td>
          <td class="paramname"><em>...</em>Â </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>builds the data structure from a sequence of primitives. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator over first primitive to insert </td></tr>
    <tr><td class="paramname">beyond</td><td>past-the-end iterator</td></tr>
  </table>
  </dd>
</dl>
<p>constructs an empty tree followed by a call to <code>insert(first,last,t...)</code>. The tree stays empty if the memory allocation is not successful. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a974e4c1bf69cfd46fd32631a80321a27" name="a974e4c1bf69cfd46fd32631a80321a27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a974e4c1bf69cfd46fd32631a80321a27">âÂ </a></span>accelerate_distance_queries() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classAABBTraits.html">AABBTraits</a> &gt; </div>
<div class="memtemplate">
template&lt;typename ConstPointIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1AABB__tree.html">CGAL::AABB_tree</a>&lt; <a class="el" href="classAABBTraits.html">AABBTraits</a> &gt;::accelerate_distance_queries </td>
          <td>(</td>
          <td class="paramtype">ConstPointIteratorÂ </td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstPointIteratorÂ </td>
          <td class="paramname"><em>beyond</em>Â </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructs an internal KD-tree containing the specified point set, to be used as the set of potential hints for accelerating the distance queries. </p>
<p>Note that the search tree built in this function will not be invalidated by the insertion of a new primitive, and an explicit call to <code><a class="el" href="classCGAL_1_1AABB__tree.html#a5d3877d3f2afbd09341eb4b8c230080b" title="constructs the internal search tree from a point set taken on the internal primitives returns true if...">accelerate_distance_queries()</a></code> is needed to update the search tree. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ConstPointIterator</td><td>is an iterator with value type <code>Point_and_primitive_id</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa542b5235ab36f004f4c6b953b909aff" name="aa542b5235ab36f004f4c6b953b909aff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa542b5235ab36f004f4c6b953b909aff">âÂ </a></span>accelerate_distance_queries() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classAABBTraits.html">AABBTraits</a> &gt; </div>
<div class="memtemplate">
template&lt;typename ConstPointIterator , typename PointMap &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1AABB__tree.html">CGAL::AABB_tree</a>&lt; <a class="el" href="classAABBTraits.html">AABBTraits</a> &gt;::accelerate_distance_queries </td>
          <td>(</td>
          <td class="paramtype">ConstPointIteratorÂ </td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstPointIteratorÂ </td>
          <td class="paramname"><em>beyond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointMapÂ </td>
          <td class="paramname"><em>pmap</em>Â </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructs an internal KD-tree containing the specified point set, to be used as the set of potential hints for accelerating the distance queries. </p>
<p>Note that the search tree built in this function will not be invalidated by the insertion of a new primitive, and an explicit call to <code><a class="el" href="classCGAL_1_1AABB__tree.html#a5d3877d3f2afbd09341eb4b8c230080b" title="constructs the internal search tree from a point set taken on the internal primitives returns true if...">accelerate_distance_queries()</a></code> is needed to update the search tree. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ConstPointIterator</td><td>is an iterator with a value type being the key type of <code>PointMap</code> </td></tr>
    <tr><td class="paramname">PointMap</td><td>a model of <code><a class="elRef" href="../Manual/classReadablePropertyMap.html">ReadablePropertyMap</a></code> with the value type of <code>ConstPointIterator</code> as key type and <code>Point</code> as value type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f40594599eded5f9a79f74186710697" name="a9f40594599eded5f9a79f74186710697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f40594599eded5f9a79f74186710697">âÂ </a></span>all_intersected_primitives()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tr &gt; </div>
<div class="memtemplate">
template&lt;typename Query , typename <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> <a class="el" href="classCGAL_1_1AABB__tree.html">CGAL::AABB_tree</a>&lt; Tr &gt;::all_intersected_primitives </td>
          <td>(</td>
          <td class="paramtype">const Query &amp;Â </td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a>Â </td>
          <td class="paramname"><em>out</em>Â </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>puts in <code>out</code> the ids of all intersected primitives. </p>
<p>This function does not compute the intersection points and is hence faster than the function <code><a class="el" href="classCGAL_1_1AABB__tree.html#adf42c2edae69f92db5646d2c81d3bbff" title="puts in out all intersections, as objects of Intersection_and_primitive_id&lt;Query&gt;::Type,...">all_intersections()</a></code> function below. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Query</td><td>must be a type for which <code>Do_intersect</code> operators are defined in the traits class <code><a class="el" href="classAABBTraits.html" title="The concept AABBTraits provides the geometric primitive types and methods for the class CGAL::AABB_tr...">AABBTraits</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf42c2edae69f92db5646d2c81d3bbff" name="adf42c2edae69f92db5646d2c81d3bbff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf42c2edae69f92db5646d2c81d3bbff">âÂ </a></span>all_intersections()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tr &gt; </div>
<div class="memtemplate">
template&lt;typename Query , typename <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> <a class="el" href="classCGAL_1_1AABB__tree.html">CGAL::AABB_tree</a>&lt; Tr &gt;::all_intersections </td>
          <td>(</td>
          <td class="paramtype">const Query &amp;Â </td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a>Â </td>
          <td class="paramname"><em>out</em>Â </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>puts in <code>out</code> all intersections, as objects of <code>Intersection_and_primitive_id&lt;Query&gt;::Type</code>, between the query and the input data to the iterator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Query</td><td>must be a type for which <code>Do_intersect</code> and <code>Intersection</code> operators are defined in the traits class <code><a class="el" href="classAABBTraits.html" title="The concept AABBTraits provides the geometric primitive types and methods for the class CGAL::AABB_tr...">AABBTraits</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af4d94dc88ad5bd31d6368d96d3d07780" name="af4d94dc88ad5bd31d6368d96d3d07780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d94dc88ad5bd31d6368d96d3d07780">âÂ </a></span>any_intersected_primitive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classAABBTraits.html">AABBTraits</a> &gt; </div>
<div class="memtemplate">
template&lt;typename Query &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classCGAL_1_1AABB__tree.html#a3f107d7a22b491cb71c6d7b6c660e19c">Primitive_id</a> &gt; <a class="el" href="classCGAL_1_1AABB__tree.html">CGAL::AABB_tree</a>&lt; <a class="el" href="classAABBTraits.html">AABBTraits</a> &gt;::any_intersected_primitive </td>
          <td>(</td>
          <td class="paramtype">const Query &amp;Â </td>
          <td class="paramname"><em>query</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the id of the intersected primitive that is encountered first in the tree traversal, iff the query intersects at least one of the input primitives. </p>
<p>No particular order is guaranteed over the tree traversal, such that, e.g, the primitive returned is not necessarily the closest from the source point of a ray query. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Query</td><td>must be a type for which <code>Do_intersect</code> operators are defined in the traits class <code><a class="el" href="classAABBTraits.html" title="The concept AABBTraits provides the geometric primitive types and methods for the class CGAL::AABB_tr...">AABBTraits</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ccaea5223809316c67d03713109e7a1" name="a8ccaea5223809316c67d03713109e7a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ccaea5223809316c67d03713109e7a1">âÂ </a></span>any_intersection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classAABBTraits.html">AABBTraits</a> &gt; </div>
<div class="memtemplate">
template&lt;typename Query &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; typename <a class="el" href="classCGAL_1_1AABB__tree.html#adcd65e098e0a79ce66a7df0097ba98aa">Intersection_and_primitive_id</a>&lt; Query &gt;::Type &gt; <a class="el" href="classCGAL_1_1AABB__tree.html">CGAL::AABB_tree</a>&lt; <a class="el" href="classAABBTraits.html">AABBTraits</a> &gt;::any_intersection </td>
          <td>(</td>
          <td class="paramtype">const Query &amp;Â </td>
          <td class="paramname"><em>query</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns if any the intersection that is encountered first in the tree traversal. </p>
<p>No particular order is guaranteed over the tree traversal, e.g, the primitive returned is not necessarily the closest from the query. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Query</td><td>must be a type for which <code>Do_intersect</code> and <code>Intersection</code> operators are defined in the traits class <code><a class="el" href="classAABBTraits.html" title="The concept AABBTraits provides the geometric primitive types and methods for the class CGAL::AABB_tr...">AABBTraits</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a817b811901a9f3c43400ddb49f4cc121" name="a817b811901a9f3c43400ddb49f4cc121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a817b811901a9f3c43400ddb49f4cc121">âÂ </a></span>build()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classAABBTraits.html">AABBTraits</a> &gt; </div>
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCGAL_1_1AABB__tree.html">CGAL::AABB_tree</a>&lt; <a class="el" href="classAABBTraits.html">AABBTraits</a> &gt;::build </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;Â </td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>triggers the (re)construction of the internal tree structure. </p>
<p>The internal tree structure is automatically invalidated by the insertion of any primitives after one or more calls to <code><a class="el" href="classCGAL_1_1AABB__tree.html#a5de00f7e7563d40132ec0676b5caf979" title="adds a sequence of primitives to the set of primitives of the AABB tree.">insert()</a></code>. This procedure is called implicitly at the first call to a query member function. An explicit call to <code>build()</code> must be made to ensure that the next call to a query function will not trigger the construction of the data structure. A call to <code>AABBTraits::set_shared_data(t...)</code> is made using the internally stored traits. This procedure has a complexity of \(O(n log(n))\), where \(n\) is the number of primitives of the tree. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="AABB_tree_2AABB_polyline_segment_2_example_8cpp-example.html#a4">AABB_tree/AABB_polyline_segment_2_example.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="abe3e1ab4a89de2623b6930324343b2fa" name="abe3e1ab4a89de2623b6930324343b2fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe3e1ab4a89de2623b6930324343b2fa">âÂ </a></span>closest_point() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1AABB__tree.html">AABB_tree</a>&lt; Tr &gt;<a class="el" href="classCGAL_1_1AABB__tree.html#ac3f4cc3966bfa5ec398b52b2330940af">::Point</a> <a class="el" href="classCGAL_1_1AABB__tree.html">CGAL::AABB_tree</a>&lt; Tr &gt;::closest_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1AABB__tree.html#ac3f4cc3966bfa5ec398b52b2330940af">Point</a> &amp;Â </td>
          <td class="paramname"><em>query</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the point in the union of all input primitives which is closest to the query. </p>
<p>In case there are several closest points, one arbitrarily chosen closest point is returned. </p><dl class="section pre"><dt>Precondition</dt><dd><code>!empty()</code> </dd></dl>

</div>
</div>
<a id="a5aeffff0695b818998279aae800915b5" name="a5aeffff0695b818998279aae800915b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aeffff0695b818998279aae800915b5">âÂ </a></span>closest_point() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1AABB__tree.html">AABB_tree</a>&lt; Tr &gt;<a class="el" href="classCGAL_1_1AABB__tree.html#ac3f4cc3966bfa5ec398b52b2330940af">::Point</a> <a class="el" href="classCGAL_1_1AABB__tree.html">CGAL::AABB_tree</a>&lt; Tr &gt;::closest_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1AABB__tree.html#ac3f4cc3966bfa5ec398b52b2330940af">Point</a> &amp;Â </td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1AABB__tree.html#ac3f4cc3966bfa5ec398b52b2330940af">Point</a> &amp;Â </td>
          <td class="paramname"><em>hint</em>Â </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the point in the union of all input primitives which is closest to the query. </p>
<p>In case there are several closest points, one arbitrarily chosen closest point is returned. The internal KD-tree is not used. </p><dl class="section pre"><dt>Precondition</dt><dd><code>!empty()</code> </dd></dl>

</div>
</div>
<a id="a1b3ac9521fd7257f760deafff3743437" name="a1b3ac9521fd7257f760deafff3743437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b3ac9521fd7257f760deafff3743437">âÂ </a></span>closest_point_and_primitive() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1AABB__tree.html">AABB_tree</a>&lt; Tr &gt;<a class="el" href="classCGAL_1_1AABB__tree.html#a74ce5787605d37cd218701ea98968e82">::Point_and_primitive_id</a> <a class="el" href="classCGAL_1_1AABB__tree.html">CGAL::AABB_tree</a>&lt; Tr &gt;::closest_point_and_primitive </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1AABB__tree.html#ac3f4cc3966bfa5ec398b52b2330940af">Point</a> &amp;Â </td>
          <td class="paramname"><em>query</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a <code>Point_and_primitive_id</code> which realizes the smallest distance between the query point and all input primitives. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>!empty()</code> </dd></dl>

</div>
</div>
<a id="a3a42a8e1d5594e7a708fdfe833474205" name="a3a42a8e1d5594e7a708fdfe833474205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a42a8e1d5594e7a708fdfe833474205">âÂ </a></span>closest_point_and_primitive() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1AABB__tree.html">AABB_tree</a>&lt; Tr &gt;<a class="el" href="classCGAL_1_1AABB__tree.html#a74ce5787605d37cd218701ea98968e82">::Point_and_primitive_id</a> <a class="el" href="classCGAL_1_1AABB__tree.html">CGAL::AABB_tree</a>&lt; Tr &gt;::closest_point_and_primitive </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1AABB__tree.html#ac3f4cc3966bfa5ec398b52b2330940af">Point</a> &amp;Â </td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1AABB__tree.html#a74ce5787605d37cd218701ea98968e82">Point_and_primitive_id</a> &amp;Â </td>
          <td class="paramname"><em>hint</em>Â </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a <code>Point_and_primitive_id</code> which realizes the smallest distance between the query point and all input primitives. </p>
<p>The internal KD-tree is not used. </p><dl class="section pre"><dt>Precondition</dt><dd><code>!empty()</code> </dd></dl>

</div>
</div>
<a id="a36b4cfa21c223461bde0da2b020a67d1" name="a36b4cfa21c223461bde0da2b020a67d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b4cfa21c223461bde0da2b020a67d1">âÂ </a></span>do_intersect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tr &gt; </div>
<div class="memtemplate">
template&lt;typename Query &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1AABB__tree.html">CGAL::AABB_tree</a>&lt; Tr &gt;::do_intersect </td>
          <td>(</td>
          <td class="paramtype">const Query &amp;Â </td>
          <td class="paramname"><em>query</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns <code>true</code>, iff the query intersects at least one of the input primitives. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Query</td><td>must be a type for which <code>Do_intersect</code> operators are defined in the traits class <code><a class="el" href="classAABBTraits.html" title="The concept AABBTraits provides the geometric primitive types and methods for the class CGAL::AABB_tr...">AABBTraits</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adfc6a7887966a2d8c726143f5a52a77d" name="adfc6a7887966a2d8c726143f5a52a77d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfc6a7887966a2d8c726143f5a52a77d">âÂ </a></span>first_intersected_primitive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classAABBTraits.html">AABBTraits</a> &gt; </div>
<div class="memtemplate">
template&lt;typename Ray , typename SkipFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classCGAL_1_1AABB__tree.html#a3f107d7a22b491cb71c6d7b6c660e19c">Primitive_id</a> &gt; <a class="el" href="classCGAL_1_1AABB__tree.html">CGAL::AABB_tree</a>&lt; <a class="el" href="classAABBTraits.html">AABBTraits</a> &gt;::first_intersected_primitive </td>
          <td>(</td>
          <td class="paramtype">const Ray &amp;Â </td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SkipFunctor &amp;Â </td>
          <td class="paramname"><em>skip</em>Â </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the primitive id closest to the source point of the ray query. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ray</td><td>must be the same as <code>AABBTraits::Ray</code> and <code>do_intersect</code> predicates and intersections for it must be defined. </td></tr>
    <tr><td class="paramname">Skip</td><td>a functor with an operator <code>bool operator()(const Primitive_id&amp; id) const</code> that returns <code>true</code> in order to skip the primitive. Defaults to a functor that always returns <code>false</code>.</td></tr>
  </table>
  </dd>
</dl>
<p><code><a class="el" href="classAABBTraits.html" title="The concept AABBTraits provides the geometric primitive types and methods for the class CGAL::AABB_tr...">AABBTraits</a></code> must be a model of <code><a class="el" href="classAABBRayIntersectionTraits.html" title="The concept AABBRayIntersectionTraits is a refinement of the concept AABBTraits. In addition to the t...">AABBRayIntersectionTraits</a></code> to call this member function. </p>

</div>
</div>
<a id="a3d24bfdc557114acc305658f9730eb60" name="a3d24bfdc557114acc305658f9730eb60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d24bfdc557114acc305658f9730eb60">âÂ </a></span>first_intersection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classAABBTraits.html">AABBTraits</a> &gt; </div>
<div class="memtemplate">
template&lt;typename Ray , typename SkipFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; typename <a class="el" href="classCGAL_1_1AABB__tree.html#adcd65e098e0a79ce66a7df0097ba98aa">Intersection_and_primitive_id</a>&lt; Ray &gt;::Type &gt; <a class="el" href="classCGAL_1_1AABB__tree.html">CGAL::AABB_tree</a>&lt; <a class="el" href="classAABBTraits.html">AABBTraits</a> &gt;::first_intersection </td>
          <td>(</td>
          <td class="paramtype">const Ray &amp;Â </td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SkipFunctor &amp;Â </td>
          <td class="paramname"><em>skip</em>Â </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the intersection and primitive id closest to the source point of the ray query. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ray</td><td>must be the same as <code>AABBTraits::Ray</code> and <code>do_intersect</code> predicates and intersections for it must be defined. </td></tr>
    <tr><td class="paramname">Skip</td><td>a functor with an operator <code>bool operator()(const Primitive_id&amp; id) const</code> that returns <code>true</code> in order to skip the primitive. Defaults to a functor that always returns <code>false</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>skip</code> might be given some primitives that are not intersected by <code>query</code> because the intersection test is done after the skip test. Also note that the order the primitives are given to <code>skip</code> is not necessarily the intersection order with <code>query</code>.</dd></dl>
<p><code><a class="el" href="classAABBTraits.html" title="The concept AABBTraits provides the geometric primitive types and methods for the class CGAL::AABB_tr...">AABBTraits</a></code> must be a model of <code><a class="el" href="classAABBRayIntersectionTraits.html" title="The concept AABBRayIntersectionTraits is a refinement of the concept AABBTraits. In addition to the t...">AABBRayIntersectionTraits</a></code> to call this member function. </p>

</div>
</div>
<a id="a5de00f7e7563d40132ec0676b5caf979" name="a5de00f7e7563d40132ec0676b5caf979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5de00f7e7563d40132ec0676b5caf979">âÂ </a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classAABBTraits.html">AABBTraits</a> &gt; </div>
<div class="memtemplate">
template&lt;typename <a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> , typename ... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCGAL_1_1AABB__tree.html">CGAL::AABB_tree</a>&lt; <a class="el" href="classAABBTraits.html">AABBTraits</a> &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a>Â </td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a>Â </td>
          <td class="paramname"><em>beyond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;Â </td>
          <td class="paramname"><em>...</em>Â </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds a sequence of primitives to the set of primitives of the AABB tree. </p>
<p><code>InputIterator</code> is any iterator and the parameter pack <code>T</code> contains any types such that <code>Primitive</code> has a constructor with the following signature: <code>Primitive(InputIterator, T...)</code>. If <code>Primitive</code> is a model of the concept <code><a class="el" href="classAABBPrimitiveWithSharedData.html" title="The concept AABBPrimitiveWithSharedData describes the requirements for the primitives stored in the A...">AABBPrimitiveWithSharedData</a></code>, a call to <code>AABBTraits::set_shared_data(t...)</code> is made using the internally stored traits. </p>

</div>
</div>
<a id="a872a72b57bbbb1d322fc8ef696e19057" name="a872a72b57bbbb1d322fc8ef696e19057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a872a72b57bbbb1d322fc8ef696e19057">âÂ </a></span>number_of_intersected_primitives()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classAABBTraits.html">AABBTraits</a> &gt; </div>
<div class="memtemplate">
template&lt;typename Query &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1AABB__tree.html#a6f03da4364c74c764681c84c3f14dcfe">size_type</a> <a class="el" href="classCGAL_1_1AABB__tree.html">CGAL::AABB_tree</a>&lt; <a class="el" href="classAABBTraits.html">AABBTraits</a> &gt;::number_of_intersected_primitives </td>
          <td>(</td>
          <td class="paramtype">const Query &amp;Â </td>
          <td class="paramname"><em>query</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the number of primitives intersected by the query. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Query</td><td>must be a type for which <code>Do_intersect</code> operators are defined in the traits class <code><a class="el" href="classAABBTraits.html" title="The concept AABBTraits provides the geometric primitive types and methods for the class CGAL::AABB_tr...">AABBTraits</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24efb545081b6796d8843861a4bf49e6" name="a24efb545081b6796d8843861a4bf49e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24efb545081b6796d8843861a4bf49e6">âÂ </a></span>squared_distance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1AABB__tree.html">AABB_tree</a>&lt; Tr &gt;<a class="el" href="classCGAL_1_1AABB__tree.html#abc411ecfc01a20f0fa05d490926f40e4">::FT</a> <a class="el" href="classCGAL_1_1AABB__tree.html">CGAL::AABB_tree</a>&lt; Tr &gt;::squared_distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1AABB__tree.html#ac3f4cc3966bfa5ec398b52b2330940af">Point</a> &amp;Â </td>
          <td class="paramname"><em>query</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the minimum squared distance between the query point and all input primitives. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>!empty()</code> </dd></dl>

</div>
</div>
<a id="a3c2a4681e3440beb909b2596b0988bad" name="a3c2a4681e3440beb909b2596b0988bad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c2a4681e3440beb909b2596b0988bad">âÂ </a></span>squared_distance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1AABB__tree.html">AABB_tree</a>&lt; Tr &gt;<a class="el" href="classCGAL_1_1AABB__tree.html#abc411ecfc01a20f0fa05d490926f40e4">::FT</a> <a class="el" href="classCGAL_1_1AABB__tree.html">CGAL::AABB_tree</a>&lt; Tr &gt;::squared_distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1AABB__tree.html#ac3f4cc3966bfa5ec398b52b2330940af">Point</a> &amp;Â </td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1AABB__tree.html#ac3f4cc3966bfa5ec398b52b2330940af">Point</a> &amp;Â </td>
          <td class="paramname"><em>hint</em>Â </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the minimum squared distance between the query point and all input primitives. </p>
<p>The internal KD-tree is not used. </p><dl class="section pre"><dt>Precondition</dt><dd><code>!empty()</code> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>CGAL</b></li><li class="navelem"><a class="el" href="classCGAL_1_1AABB__tree.html">AABB_tree</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"></a> 1.9.6 </li>
  </ul>
</div>
</div>
</body>



</html>
