<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="https://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Optimal_bounding_box/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 5.6 - Optimal Bounding Box: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//&amp;lt;![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      }
  }
}
);
//]]&amp;gt;
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.6 - Optimal Bounding Box
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Building_Optimal_Bounding_Box"></a> </p><div id="autotoc" class="toc"></div> 
<p><a class="anchor" id="fig__OBBBanner"></a></p><center> <div class="image">
<img src="obb_chess.png" style="max-width:70%;" />
</div>
 </center><dl class="section author"><dt>Authors</dt><dd>Konstantinos Katrioplas, Mael Rouxel-Labbé</dd></dl>
<h1><a class="anchor" id="OBBIntro"></a>
Introduction</h1>
<p>Encompassing a model within a volume is a common approach to accelerate a number of applications such as collision detection or visibility testing: the proxy volume provides a rapid way to test a configuration or filter results, with the real model only being used when required. Typical coarser volumes that can be used to approximate a more complex model are simplified meshes (for example using the package <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceMeshSimplification">Triangulated Surface Mesh Simplification</a>), convex hulls, or simple rectangular boxes. Within this last category, the axis-aligned bounding box (AABB) has obvious advantages: it is extremely simple to compute and one may build a hierarchical structure of successively tighter volumes to further speed up intersection and distance computations. One such example of structure is the CGAL AABB tree (<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgAABBTree">3D Fast Intersection and Distance Computation</a>). The disadvantage is also clear: the box is usually poorly fitting most models. A good compromise between the good approximation offered by convex hulls or simplified meshes and the speed offered by axis-aligned bounding boxes are <em>Optimal Bounding Boxes</em>. Contrary to the AABB, the optimal bounding box of a model is not necessarily axis-aligned, but provides a tight approximation.</p>
<p><a class="anchor" id="fig__obb_aabb_vs_obb"></a></p><center> <div class="image">
<img src="aabb_vs_obb.jpg" style="max-width:70%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__obb_aabb_vs_obb">Figure 99.2</a> Left: the axis-aligned bounding box. Right: the optimal bounding box, a much better fit.
<p> </p></div> <br /> 
<p>In 2D, the optimal bounding rectangle of an input can be computed in linear time using the technique of <em>rotating calipers</em>, first introduced by Toussaint <a class="el" href="citelist.html#CITEREF_cgal:t-sgprc-83">[4]</a> (see also the CGAL package <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgBoundingVolumes">Bounding Volumes</a>). An algorithm to compute the optimal oriented bounding box in 3D was proposed by O’Rourke <a class="el" href="citelist.html#CITEREF_cgal:or-fmeb-85">[3]</a>, but its cubic complexity in the number of points makes it unusable in practice. The implementation proposed in this package is based on the paper of Chang et al.<a class="el" href="citelist.html#CITEREF_cgal:cgm-fobbo-11">[1]</a>, who introduced an algorithm to compute a close approximation of the optimal bounding box. As this is but an approximation of the optimal bounding box, we call the resulting box, the <em>Oriented Bounding Box</em>.</p>
<h1><a class="anchor" id="OBBOrientedBoundingBox"></a>
Oriented Bounding Box</h1>
<p>The algorithm introduced by Chang et al. formulates the computation of the optimal bounding box as an unconstrained optimization problem on the 3D matrix rotation group. The function to optimize is defined as the volume of the box. Because this function is non-differentiable, in particular near local optima, traditional optimization methods might encounter convergence issues. Consequently, Chang et al.'s algorithm employs a combination of a derivative-free optimization method, the Nelder-Mead simplex method <a class="el" href="citelist.html#CITEREF_cgal:nm-smfm-65">[2]</a>, and a metaheuristics method based on biological evolution principles to maintain and evolve a population of tentative rotation matrices. The purpose of this evolution is to oppose a global approach to the local Nelder-Mead optimization, enabling the algorithm to explore the search space as much as possible, and to find not only a local minimum, but a global optimum.</p>
<h2><a class="anchor" id="OBBOptimality"></a>
Missing the Optimality</h2>
<p>In theory, the genetic algorithms used by Chang et al. enable - given enough time - the algorithm to explore the complete search space. In practice, an algorithm does not have infinite time at its disposal. In addition, there is no simple way to check if the current-best solution is optimal. Thus, an implementation of the algorithm cannot provide the same guarantees that the theoretical algorithm offers. However, we observe that in practice the algorithm constructs a close approximation of the optimal bounding box most of the time.</p>
<h2><a class="anchor" id="OBBConvexHull"></a>
Convex Hull Computation as Preprocessing</h2>
<p>As the bounding box only depends on the convex hull of the object, computing its convex hull as a preprocessing step is a good way to reduce the number of points in subsequent computations. The computational trade-off is developed in more details in Section <a class="el" href="index.html#OBBComplexityPerformance">Complexity and Performance</a>.</p>
<h1><a class="anchor" id="OBBImplementation"></a>
Design and Implementation</h1>
<p>The computation of the oriented bounding box can be performed by calling the free function <code><a class="el" href="group__PkgOptimalBoundingBox__Oriented__bounding__box.html#gac1917f59df722d338d44a63d3a8aa14a" title="The function oriented_bounding_box() computes an approximation of the optimal bounding box...">CGAL::oriented_bounding_box()</a></code>. Convex hull computation is performed using the package <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgConvexHull3">3D Convex Hulls</a>, and is enabled by default.</p>
<h2><a class="anchor" id="OBBInnOut"></a>
Input and Output</h2>
<p>The input can be a range of 3D points, or a mesh, with a variety of <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__bgl__namedparameters.html">Named Parameters</a> enabling using further custom inputs.</p>
<p>The result of the algorithm can be retrieved as:</p><ul>
<li>the best affine transformation \({\mathcal R}_b\) that the algorithm has found;</li>
<li>an array of eight points, representing the best oriented bounding box that the algorithm has constructed, which is related to \( {\mathcal R}_b\) as it is the inverse transformation of the axis-aligned bounding box of the transformed input object. The order of the points in the array is the same as in the function <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html"><code>CGAL::make_hexahedron()</code> </a>, which can be used to construct a mesh from these points.</li>
<li>a model of <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/classMutableFaceGraph.html">MutableFaceGraph</a></code>, a quadrangular mesh representing the oriented bounding box.</li>
</ul>
<h2><a class="anchor" id="OBBTraitsnKernels"></a>
Traits and Kernel Choice</h2>
<p>The requirements on geometric objects and operations on these objects are described in the traits class concept <code><a class="el" href="classOrientedBoundingBoxTraits__3.html" title="The concept OrientedBoundingBoxTraits_3 describes the requirements of the traits class used in the fu...">OrientedBoundingBoxTraits_3</a></code>. A model of this concept is provided: <code><a class="el" href="classCGAL_1_1Oriented__bounding__box__traits__3.html" title="The class CGAL::Oriented_bounding_box_traits_3 is a traits type to be used with the overloads of the ...">CGAL::Oriented_bounding_box_traits_3</a></code>.</p>
<p>If the approach using the convex hull is chosen, a kernel offering exact predicates must be used to ensure a correct hull. In addition, the eight bounding vertices are constructed using the best found affine transformation; consequently, a kernel providing exact construction may also be useful.</p>
<h1><a class="anchor" id="OBBComplexityPerformance"></a>
Complexity and Performance</h1>
<p>A major drawback of the exact algorithm of O’Rourke is its cubic complexity and consequent large runtimes. In this section, we investigate the speedup gained by preprocessing the input data with a convex hull computation, and show that the oriented bounding box algorithm exhibits linear complexity.</p>
<p>Models from the <a href="https://ten-thousand-models.appspot.com/">Thingi10k</a> data set are used with speeds being averaged over 100 runs for each model. The machine used is a laptop running Fedora 30 64-bits, with two 6-core Intel(R) i9-8950HK CPU clocked at 2.90GHz, and with 32GB of RAM. The CGAL kernel used is <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a></code>.</p>
<h2><a class="anchor" id="OBBConvexHullComplexity"></a>
Cost and Gain of Convex Hull Computations</h2>
<p>Computing the convex hull as a preliminary step provides a significant speed advantage.</p>
<p><a class="anchor" id="fig__ch_speed_up"></a></p><center> <div class="image">
<img src="ch_speedup.png" style="max-width:70%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__ch_speed_up">Figure 99.3</a> Computation of the speedup achieved on the total runtime of the algorithm when the convex hull is computed and used afterwards. Note that the total runtime includes the construction of the convex hull (when it is used). The color and size of the dots represent the number of vertices in the input data (larger, bluer points having more input vertices than greener, smaller points). Computing the convex hull is beneficial for all but a handful of cases.  </div> <br /> 
<h2><a class="anchor" id="OBBOrientedBoundingBoxComplexity"></a>
Performance of the Oriented Bounding Box Algorithm</h2>
<p>We analyze in this section the computation time of the algorithm based on the number of vertices on the convex hull.</p>
<p><a class="anchor" id="fig__obb_timings"></a></p><center> <div class="image">
<img src="obb_time.png" style="max-width:70%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__obb_timings">Figure 99.4</a> Running times for the oriented bounding box construction of the convex hull of models of the <a href="https://ten-thousand-models.appspot.com/">Thingi10k</a> data set. The color and size of the dots represent the number of vertices in the input data (larger, bluer points having more input vertices than greener, smaller points). The algorithm exhibits linear complexity in practice. For visibility reasons, the few models whose convex hull has more than 10000 vertices are excluded from this graph, but consistent results are observed.  </div> <br /> 
<h1><a class="anchor" id="OBBexamples"></a>
Examples</h1>
<h2><a class="anchor" id="OBBBasicExample"></a>
Basic Example</h2>
<p>The following example illustrates a basic usage of the algorithm: an input mesh is read, its oriented bounding box is computed using an array as output, and a mesh is constructed from the eight points.</p>
<p><br />
<b>File</b> <a class="el" href="Optimal_bounding_box_2obb_example_8cpp-example.html">Optimal_bounding_box/obb_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optimal__bounding__box_8h.html">CGAL/optimal_bounding_box.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/triangulate_faces.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/measure.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/IO/polygon_mesh_io.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>PMP = CGAL::Polygon_mesh_processing;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>    K;</div><div class="line"><span class="keyword">typedef</span> K::Point_3                                             Point;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point&gt;</a>                              Surface_mesh;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : CGAL::data_file_path(<span class="stringliteral">"meshes/pig.off"</span>);</div><div class="line"></div><div class="line">  Surface_mesh sm;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLIOFct.html#ga49f5b5e6fbfcbfaaac7604c88e10915c">PMP::IO::read_polygon_mesh</a>(filename, sm) || sm.is_empty())</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input file."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  CGAL::Real_timer timer;</div><div class="line">  timer.start();</div><div class="line"></div><div class="line">  <span class="comment">// Compute the extreme points of the mesh, and then a tightly fitted oriented bounding box</span></div><div class="line">  std::array&lt;Point, 8&gt; obb_points;</div><div class="line">  <a class="code" href="group__PkgOptimalBoundingBox__Oriented__bounding__box.html#gac1917f59df722d338d44a63d3a8aa14a">CGAL::oriented_bounding_box</a>(sm, obb_points,</div><div class="line">                              CGAL::parameters::use_convex_hull(<span class="keyword">true</span>));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Elapsed time: "</span> &lt;&lt; timer.time() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Make a mesh out of the oriented bounding box</span></div><div class="line">  Surface_mesh obb_sm;</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#gad9df350e98780f0c213046d8a257358e">CGAL::make_hexahedron</a>(obb_points[0], obb_points[1], obb_points[2], obb_points[3],</div><div class="line">                        obb_points[4], obb_points[5], obb_points[6], obb_points[7], obb_sm);</div><div class="line">  std::ofstream(<span class="stringliteral">"obb.off"</span>) &lt;&lt; obb_sm;</div><div class="line"></div><div class="line">  PMP::triangulate_faces(obb_sm);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Volume: "</span> &lt;&lt; <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__volume__grp.html#ga4ba6790576ca34b8421e120ec7562d9a">PMP::volume</a>(obb_sm) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="OBBExampleNP"></a>
Using Named Parameters</h2>
<p>The following example illustrates how to use <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__bgl__namedparameters.html">Named Parameters</a> to efficiently compute the oriented bounding box of a mesh whose vertices' positions are modified on the fly.</p>
<p><br />
<b>File</b> <a class="el" href="Optimal_bounding_box_2obb_with_point_maps_example_8cpp-example.html">Optimal_bounding_box/obb_with_point_maps_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optimal__bounding__box_8h.html">CGAL/optimal_bounding_box.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/IO/polygon_mesh_io.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;array&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;unordered_map&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>    K;</div><div class="line"><span class="keyword">typedef</span> K::Point_3                                             Point;</div><div class="line"><span class="keyword">typedef</span> K::Vector_3                                            Vector;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point&gt;</a>                              Surface_mesh;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Surface_mesh&gt;::vertex_descriptor   vertex_descriptor;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>CP = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL_1_1parameters.html">CGAL::parameters</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : CGAL::data_file_path(<span class="stringliteral">"meshes/pig.off"</span>);</div><div class="line"></div><div class="line">  Surface_mesh sm;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLIOFct.html#ga49f5b5e6fbfcbfaaac7604c88e10915c">CGAL::Polygon_mesh_processing::IO::read_polygon_mesh</a>(filename, sm) || sm.is_empty())</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input file."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// a typical call</span></div><div class="line">  std::array&lt;Point, 8&gt; obb_points;</div><div class="line">  <a class="code" href="group__PkgOptimalBoundingBox__Oriented__bounding__box.html#gac1917f59df722d338d44a63d3a8aa14a">CGAL::oriented_bounding_box</a>(sm, obb_points);</div><div class="line"></div><div class="line">  <span class="comment">// one can associate positions to the vertices of the mesh without changing the mesh</span></div><div class="line">  std::unordered_map&lt;vertex_descriptor, Point&gt; translated_positions;</div><div class="line">  <span class="keywordflow">for</span>(<span class="keyword">const</span> vertex_descriptor&amp; v : vertices(sm))</div><div class="line">    translated_positions[v] = sm.point(v) + Vector(1, 2, 3);</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgOptimalBoundingBox__Oriented__bounding__box.html#gac1917f59df722d338d44a63d3a8aa14a">CGAL::oriented_bounding_box</a>(sm, obb_points,</div><div class="line">                              CP::vertex_point_map(boost::make_assoc_property_map(translated_positions)));</div><div class="line"></div><div class="line">  <span class="comment">// using a range of points</span></div><div class="line">  std::vector&lt;Point&gt; points;</div><div class="line">  <span class="keywordflow">for</span>(<span class="keyword">const</span> vertex_descriptor&amp; v : vertices(sm))</div><div class="line">    points.push_back(sm.point(v));</div><div class="line">  <a class="code" href="group__PkgOptimalBoundingBox__Oriented__bounding__box.html#gac1917f59df722d338d44a63d3a8aa14a">CGAL::oriented_bounding_box</a>(points, obb_points);</div><div class="line"></div><div class="line">  <span class="comment">// one can associate positions to the range without changing the range</span></div><div class="line">  std::map&lt;Point, Point&gt; scaled_positions;</div><div class="line">  <span class="keywordflow">for</span>(<span class="keyword">const</span> Point&amp; p : points)</div><div class="line">    scaled_positions[p] = p + (p - <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga9d272a8e3a8080b851741b6d3a44afdc">CGAL::ORIGIN</a>);</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgOptimalBoundingBox__Oriented__bounding__box.html#gac1917f59df722d338d44a63d3a8aa14a">CGAL::oriented_bounding_box</a>(points, obb_points,</div><div class="line">                              CP::point_map(boost::make_assoc_property_map(scaled_positions)));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="OBBRotatedTree"></a>
Rotated AABB Tree</h2>
<p>The following example uses the affine transformation, which is the affine transformation such that the axis-aligned bounding box of the transformed vertices of the mesh has minimum volume, returned by the algorithm to build a custom vertex point property map. An AABB tree of the (on the fly) rotated faces of the mesh is then constructed.</p>
<p><br />
<b>File</b> <a class="el" href="Optimal_bounding_box_2rotated_aabb_tree_example_8cpp-example.html">Optimal_bounding_box/rotated_aabb_tree_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/AABB_tree.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/AABB_traits.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/AABB_face_graph_triangle_primitive.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optimal__bounding__box_8h.html">CGAL/optimal_bounding_box.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/IO/polygon_mesh_io.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/property_map/function_property_map.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>    K;</div><div class="line"><span class="keyword">typedef</span> K::Point_3                                             Point;</div><div class="line"><span class="keyword">typedef</span> K::Aff_transformation_3                                Aff_transformation;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point&gt;</a>                              Surface_mesh;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Surface_mesh&gt;::vertex_descriptor   vertex_descriptor;</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Aff_tr_fct</div><div class="line">{</div><div class="line">  Aff_tr_fct() : m_at(nullptr), m_sm(nullptr) { }</div><div class="line">  Aff_tr_fct(<span class="keyword">const</span> Aff_transformation&amp; at, <span class="keyword">const</span> Surface_mesh&amp; sm) : m_at(&amp;at), m_sm(&amp;sm) { }</div><div class="line"></div><div class="line">  Point operator()(<span class="keyword">const</span> vertex_descriptor v)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_at-&gt;transform(m_sm-&gt;point(v)); }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> Aff_transformation* m_at;</div><div class="line">  <span class="keyword">const</span> Surface_mesh* m_sm;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : CGAL::data_file_path(<span class="stringliteral">"meshes/pig.off"</span>);</div><div class="line"></div><div class="line">  Surface_mesh sm;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLIOFct.html#ga49f5b5e6fbfcbfaaac7604c88e10915c">CGAL::Polygon_mesh_processing::IO::read_polygon_mesh</a>(filename, sm) || sm.is_empty())</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input file."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// get the transformation that yields the optimal bounding box</span></div><div class="line">  Aff_transformation at;</div><div class="line">  <a class="code" href="group__PkgOptimalBoundingBox__Oriented__bounding__box.html#gac1917f59df722d338d44a63d3a8aa14a">CGAL::oriented_bounding_box</a>(sm, at);</div><div class="line"></div><div class="line">  <span class="comment">// functor to apply the affine transformation to a vertex of the mesh</span></div><div class="line">  Aff_tr_fct aff_tr_fct(at, sm);</div><div class="line">  <span class="keyword">auto</span> aff_tr_vpm = boost::make_function_property_map&lt;vertex_descriptor&gt;(aff_tr_fct);</div><div class="line"></div><div class="line">  <span class="comment">// rotated AABB tree</span></div><div class="line">  <span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/AABB_tree.tag:../AABB_tree/" href="../AABB_tree/classCGAL_1_1AABB__face__graph__triangle__primitive.html">CGAL::AABB_face_graph_triangle_primitive&lt;Surface_mesh, decltype(aff_tr_vpm)&gt;</a> AABB_face_graph_primitive;</div><div class="line">  <span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/AABB_tree.tag:../AABB_tree/" href="../AABB_tree/classCGAL_1_1AABB__traits.html">CGAL::AABB_traits&lt;K, AABB_face_graph_primitive&gt;</a>                              AABB_face_graph_traits;</div><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/AABB_tree.tag:../AABB_tree/" href="../AABB_tree/classCGAL_1_1AABB__tree.html">CGAL::AABB_tree&lt;AABB_face_graph_traits&gt;</a> tree(faces(sm).begin(), faces(sm).end(), sm, aff_tr_vpm);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="OBBHistory"></a>
Implementation History</h1>
<p>A prototype was created by Konstantinos Katrioplas in 2018. Mael Rouxel-Labbé worked to speed up and robustify the implementation, and to submit the first version of this package. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jan 30 2023 13:47:16 for CGAL 5.6 - Optimal Bounding Box by
    <a href="https://www.doxygen.nl/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>
</html><html xmlns="http://www.w3.org/1999/xhtml"><body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.6 - Optimal Bounding Box
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Building_Optimal_Bounding_Box"></a> </p><div id="autotoc" class="toc"></div> 
<p><a class="anchor" id="fig__OBBBanner"></a></p><center> <div class="image">
<img src="obb_chess.png" style="max-width:70%;" />
</div>
 </center><dl class="section author"><dt>Authors</dt><dd>Konstantinos Katrioplas, Mael Rouxel-Labbé</dd></dl>
<h1><a class="anchor" id="OBBIntro"></a>
Introduction</h1>
<p>Encompassing a model within a volume is a common approach to accelerate a number of applications such as collision detection or visibility testing: the proxy volume provides a rapid way to test a configuration or filter results, with the real model only being used when required. Typical coarser volumes that can be used to approximate a more complex model are simplified meshes (for example using the package <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceMeshSimplification">Triangulated Surface Mesh Simplification</a>), convex hulls, or simple rectangular boxes. Within this last category, the axis-aligned bounding box (AABB) has obvious advantages: it is extremely simple to compute and one may build a hierarchical structure of successively tighter volumes to further speed up intersection and distance computations. One such example of structure is the CGAL AABB tree (<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgAABBTree">3D Fast Intersection and Distance Computation</a>). The disadvantage is also clear: the box is usually poorly fitting most models. A good compromise between the good approximation offered by convex hulls or simplified meshes and the speed offered by axis-aligned bounding boxes are <em>Optimal Bounding Boxes</em>. Contrary to the AABB, the optimal bounding box of a model is not necessarily axis-aligned, but provides a tight approximation.</p>
<p><a class="anchor" id="fig__obb_aabb_vs_obb"></a></p><center> <div class="image">
<img src="aabb_vs_obb.jpg" style="max-width:70%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__obb_aabb_vs_obb">Figure 99.2</a> Left: the axis-aligned bounding box. Right: the optimal bounding box, a much better fit.
<p> </p></div> <br /> 
<p>In 2D, the optimal bounding rectangle of an input can be computed in linear time using the technique of <em>rotating calipers</em>, first introduced by Toussaint <a class="el" href="citelist.html#CITEREF_cgal:t-sgprc-83">[4]</a> (see also the CGAL package <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgBoundingVolumes">Bounding Volumes</a>). An algorithm to compute the optimal oriented bounding box in 3D was proposed by O’Rourke <a class="el" href="citelist.html#CITEREF_cgal:or-fmeb-85">[3]</a>, but its cubic complexity in the number of points makes it unusable in practice. The implementation proposed in this package is based on the paper of Chang et al.<a class="el" href="citelist.html#CITEREF_cgal:cgm-fobbo-11">[1]</a>, who introduced an algorithm to compute a close approximation of the optimal bounding box. As this is but an approximation of the optimal bounding box, we call the resulting box, the <em>Oriented Bounding Box</em>.</p>
<h1><a class="anchor" id="OBBOrientedBoundingBox"></a>
Oriented Bounding Box</h1>
<p>The algorithm introduced by Chang et al. formulates the computation of the optimal bounding box as an unconstrained optimization problem on the 3D matrix rotation group. The function to optimize is defined as the volume of the box. Because this function is non-differentiable, in particular near local optima, traditional optimization methods might encounter convergence issues. Consequently, Chang et al.'s algorithm employs a combination of a derivative-free optimization method, the Nelder-Mead simplex method <a class="el" href="citelist.html#CITEREF_cgal:nm-smfm-65">[2]</a>, and a metaheuristics method based on biological evolution principles to maintain and evolve a population of tentative rotation matrices. The purpose of this evolution is to oppose a global approach to the local Nelder-Mead optimization, enabling the algorithm to explore the search space as much as possible, and to find not only a local minimum, but a global optimum.</p>
<h2><a class="anchor" id="OBBOptimality"></a>
Missing the Optimality</h2>
<p>In theory, the genetic algorithms used by Chang et al. enable - given enough time - the algorithm to explore the complete search space. In practice, an algorithm does not have infinite time at its disposal. In addition, there is no simple way to check if the current-best solution is optimal. Thus, an implementation of the algorithm cannot provide the same guarantees that the theoretical algorithm offers. However, we observe that in practice the algorithm constructs a close approximation of the optimal bounding box most of the time.</p>
<h2><a class="anchor" id="OBBConvexHull"></a>
Convex Hull Computation as Preprocessing</h2>
<p>As the bounding box only depends on the convex hull of the object, computing its convex hull as a preprocessing step is a good way to reduce the number of points in subsequent computations. The computational trade-off is developed in more details in Section <a class="el" href="index.html#OBBComplexityPerformance">Complexity and Performance</a>.</p>
<h1><a class="anchor" id="OBBImplementation"></a>
Design and Implementation</h1>
<p>The computation of the oriented bounding box can be performed by calling the free function <code><a class="el" href="group__PkgOptimalBoundingBox__Oriented__bounding__box.html#gac1917f59df722d338d44a63d3a8aa14a" title="The function oriented_bounding_box() computes an approximation of the optimal bounding box...">CGAL::oriented_bounding_box()</a></code>. Convex hull computation is performed using the package <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgConvexHull3">3D Convex Hulls</a>, and is enabled by default.</p>
<h2><a class="anchor" id="OBBInnOut"></a>
Input and Output</h2>
<p>The input can be a range of 3D points, or a mesh, with a variety of <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__bgl__namedparameters.html">Named Parameters</a> enabling using further custom inputs.</p>
<p>The result of the algorithm can be retrieved as:</p><ul>
<li>the best affine transformation \({\mathcal R}_b\) that the algorithm has found;</li>
<li>an array of eight points, representing the best oriented bounding box that the algorithm has constructed, which is related to \( {\mathcal R}_b\) as it is the inverse transformation of the axis-aligned bounding box of the transformed input object. The order of the points in the array is the same as in the function <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html"><code>CGAL::make_hexahedron()</code> </a>, which can be used to construct a mesh from these points.</li>
<li>a model of <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/classMutableFaceGraph.html">MutableFaceGraph</a></code>, a quadrangular mesh representing the oriented bounding box.</li>
</ul>
<h2><a class="anchor" id="OBBTraitsnKernels"></a>
Traits and Kernel Choice</h2>
<p>The requirements on geometric objects and operations on these objects are described in the traits class concept <code><a class="el" href="classOrientedBoundingBoxTraits__3.html" title="The concept OrientedBoundingBoxTraits_3 describes the requirements of the traits class used in the fu...">OrientedBoundingBoxTraits_3</a></code>. A model of this concept is provided: <code><a class="el" href="classCGAL_1_1Oriented__bounding__box__traits__3.html" title="The class CGAL::Oriented_bounding_box_traits_3 is a traits type to be used with the overloads of the ...">CGAL::Oriented_bounding_box_traits_3</a></code>.</p>
<p>If the approach using the convex hull is chosen, a kernel offering exact predicates must be used to ensure a correct hull. In addition, the eight bounding vertices are constructed using the best found affine transformation; consequently, a kernel providing exact construction may also be useful.</p>
<h1><a class="anchor" id="OBBComplexityPerformance"></a>
Complexity and Performance</h1>
<p>A major drawback of the exact algorithm of O’Rourke is its cubic complexity and consequent large runtimes. In this section, we investigate the speedup gained by preprocessing the input data with a convex hull computation, and show that the oriented bounding box algorithm exhibits linear complexity.</p>
<p>Models from the <a href="https://ten-thousand-models.appspot.com/">Thingi10k</a> data set are used with speeds being averaged over 100 runs for each model. The machine used is a laptop running Fedora 30 64-bits, with two 6-core Intel(R) i9-8950HK CPU clocked at 2.90GHz, and with 32GB of RAM. The CGAL kernel used is <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a></code>.</p>
<h2><a class="anchor" id="OBBConvexHullComplexity"></a>
Cost and Gain of Convex Hull Computations</h2>
<p>Computing the convex hull as a preliminary step provides a significant speed advantage.</p>
<p><a class="anchor" id="fig__ch_speed_up"></a></p><center> <div class="image">
<img src="ch_speedup.png" style="max-width:70%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__ch_speed_up">Figure 99.3</a> Computation of the speedup achieved on the total runtime of the algorithm when the convex hull is computed and used afterwards. Note that the total runtime includes the construction of the convex hull (when it is used). The color and size of the dots represent the number of vertices in the input data (larger, bluer points having more input vertices than greener, smaller points). Computing the convex hull is beneficial for all but a handful of cases.  </div> <br /> 
<h2><a class="anchor" id="OBBOrientedBoundingBoxComplexity"></a>
Performance of the Oriented Bounding Box Algorithm</h2>
<p>We analyze in this section the computation time of the algorithm based on the number of vertices on the convex hull.</p>
<p><a class="anchor" id="fig__obb_timings"></a></p><center> <div class="image">
<img src="obb_time.png" style="max-width:70%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__obb_timings">Figure 99.4</a> Running times for the oriented bounding box construction of the convex hull of models of the <a href="https://ten-thousand-models.appspot.com/">Thingi10k</a> data set. The color and size of the dots represent the number of vertices in the input data (larger, bluer points having more input vertices than greener, smaller points). The algorithm exhibits linear complexity in practice. For visibility reasons, the few models whose convex hull has more than 10000 vertices are excluded from this graph, but consistent results are observed.  </div> <br /> 
<h1><a class="anchor" id="OBBexamples"></a>
Examples</h1>
<h2><a class="anchor" id="OBBBasicExample"></a>
Basic Example</h2>
<p>The following example illustrates a basic usage of the algorithm: an input mesh is read, its oriented bounding box is computed using an array as output, and a mesh is constructed from the eight points.</p>
<p><br />
<b>File</b> <a class="el" href="Optimal_bounding_box_2obb_example_8cpp-example.html">Optimal_bounding_box/obb_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optimal__bounding__box_8h.html">CGAL/optimal_bounding_box.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/triangulate_faces.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/measure.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/IO/polygon_mesh_io.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>PMP = CGAL::Polygon_mesh_processing;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>    K;</div><div class="line"><span class="keyword">typedef</span> K::Point_3                                             Point;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point&gt;</a>                              Surface_mesh;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : CGAL::data_file_path(<span class="stringliteral">"meshes/pig.off"</span>);</div><div class="line"></div><div class="line">  Surface_mesh sm;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLIOFct.html#ga49f5b5e6fbfcbfaaac7604c88e10915c">PMP::IO::read_polygon_mesh</a>(filename, sm) || sm.is_empty())</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input file."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  CGAL::Real_timer timer;</div><div class="line">  timer.start();</div><div class="line"></div><div class="line">  <span class="comment">// Compute the extreme points of the mesh, and then a tightly fitted oriented bounding box</span></div><div class="line">  std::array&lt;Point, 8&gt; obb_points;</div><div class="line">  <a class="code" href="group__PkgOptimalBoundingBox__Oriented__bounding__box.html#gac1917f59df722d338d44a63d3a8aa14a">CGAL::oriented_bounding_box</a>(sm, obb_points,</div><div class="line">                              CGAL::parameters::use_convex_hull(<span class="keyword">true</span>));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Elapsed time: "</span> &lt;&lt; timer.time() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Make a mesh out of the oriented bounding box</span></div><div class="line">  Surface_mesh obb_sm;</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#gad9df350e98780f0c213046d8a257358e">CGAL::make_hexahedron</a>(obb_points[0], obb_points[1], obb_points[2], obb_points[3],</div><div class="line">                        obb_points[4], obb_points[5], obb_points[6], obb_points[7], obb_sm);</div><div class="line">  std::ofstream(<span class="stringliteral">"obb.off"</span>) &lt;&lt; obb_sm;</div><div class="line"></div><div class="line">  PMP::triangulate_faces(obb_sm);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Volume: "</span> &lt;&lt; <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__volume__grp.html#ga4ba6790576ca34b8421e120ec7562d9a">PMP::volume</a>(obb_sm) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="OBBExampleNP"></a>
Using Named Parameters</h2>
<p>The following example illustrates how to use <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__bgl__namedparameters.html">Named Parameters</a> to efficiently compute the oriented bounding box of a mesh whose vertices' positions are modified on the fly.</p>
<p><br />
<b>File</b> <a class="el" href="Optimal_bounding_box_2obb_with_point_maps_example_8cpp-example.html">Optimal_bounding_box/obb_with_point_maps_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optimal__bounding__box_8h.html">CGAL/optimal_bounding_box.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/IO/polygon_mesh_io.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;array&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;unordered_map&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>    K;</div><div class="line"><span class="keyword">typedef</span> K::Point_3                                             Point;</div><div class="line"><span class="keyword">typedef</span> K::Vector_3                                            Vector;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point&gt;</a>                              Surface_mesh;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Surface_mesh&gt;::vertex_descriptor   vertex_descriptor;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>CP = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL_1_1parameters.html">CGAL::parameters</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : CGAL::data_file_path(<span class="stringliteral">"meshes/pig.off"</span>);</div><div class="line"></div><div class="line">  Surface_mesh sm;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLIOFct.html#ga49f5b5e6fbfcbfaaac7604c88e10915c">CGAL::Polygon_mesh_processing::IO::read_polygon_mesh</a>(filename, sm) || sm.is_empty())</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input file."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// a typical call</span></div><div class="line">  std::array&lt;Point, 8&gt; obb_points;</div><div class="line">  <a class="code" href="group__PkgOptimalBoundingBox__Oriented__bounding__box.html#gac1917f59df722d338d44a63d3a8aa14a">CGAL::oriented_bounding_box</a>(sm, obb_points);</div><div class="line"></div><div class="line">  <span class="comment">// one can associate positions to the vertices of the mesh without changing the mesh</span></div><div class="line">  std::unordered_map&lt;vertex_descriptor, Point&gt; translated_positions;</div><div class="line">  <span class="keywordflow">for</span>(<span class="keyword">const</span> vertex_descriptor&amp; v : vertices(sm))</div><div class="line">    translated_positions[v] = sm.point(v) + Vector(1, 2, 3);</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgOptimalBoundingBox__Oriented__bounding__box.html#gac1917f59df722d338d44a63d3a8aa14a">CGAL::oriented_bounding_box</a>(sm, obb_points,</div><div class="line">                              CP::vertex_point_map(boost::make_assoc_property_map(translated_positions)));</div><div class="line"></div><div class="line">  <span class="comment">// using a range of points</span></div><div class="line">  std::vector&lt;Point&gt; points;</div><div class="line">  <span class="keywordflow">for</span>(<span class="keyword">const</span> vertex_descriptor&amp; v : vertices(sm))</div><div class="line">    points.push_back(sm.point(v));</div><div class="line">  <a class="code" href="group__PkgOptimalBoundingBox__Oriented__bounding__box.html#gac1917f59df722d338d44a63d3a8aa14a">CGAL::oriented_bounding_box</a>(points, obb_points);</div><div class="line"></div><div class="line">  <span class="comment">// one can associate positions to the range without changing the range</span></div><div class="line">  std::map&lt;Point, Point&gt; scaled_positions;</div><div class="line">  <span class="keywordflow">for</span>(<span class="keyword">const</span> Point&amp; p : points)</div><div class="line">    scaled_positions[p] = p + (p - <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga9d272a8e3a8080b851741b6d3a44afdc">CGAL::ORIGIN</a>);</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgOptimalBoundingBox__Oriented__bounding__box.html#gac1917f59df722d338d44a63d3a8aa14a">CGAL::oriented_bounding_box</a>(points, obb_points,</div><div class="line">                              CP::point_map(boost::make_assoc_property_map(scaled_positions)));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="OBBRotatedTree"></a>
Rotated AABB Tree</h2>
<p>The following example uses the affine transformation, which is the affine transformation such that the axis-aligned bounding box of the transformed vertices of the mesh has minimum volume, returned by the algorithm to build a custom vertex point property map. An AABB tree of the (on the fly) rotated faces of the mesh is then constructed.</p>
<p><br />
<b>File</b> <a class="el" href="Optimal_bounding_box_2rotated_aabb_tree_example_8cpp-example.html">Optimal_bounding_box/rotated_aabb_tree_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/AABB_tree.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/AABB_traits.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/AABB_face_graph_triangle_primitive.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optimal__bounding__box_8h.html">CGAL/optimal_bounding_box.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/IO/polygon_mesh_io.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/property_map/function_property_map.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>    K;</div><div class="line"><span class="keyword">typedef</span> K::Point_3                                             Point;</div><div class="line"><span class="keyword">typedef</span> K::Aff_transformation_3                                Aff_transformation;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point&gt;</a>                              Surface_mesh;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Surface_mesh&gt;::vertex_descriptor   vertex_descriptor;</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Aff_tr_fct</div><div class="line">{</div><div class="line">  Aff_tr_fct() : m_at(nullptr), m_sm(nullptr) { }</div><div class="line">  Aff_tr_fct(<span class="keyword">const</span> Aff_transformation&amp; at, <span class="keyword">const</span> Surface_mesh&amp; sm) : m_at(&amp;at), m_sm(&amp;sm) { }</div><div class="line"></div><div class="line">  Point operator()(<span class="keyword">const</span> vertex_descriptor v)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_at-&gt;transform(m_sm-&gt;point(v)); }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> Aff_transformation* m_at;</div><div class="line">  <span class="keyword">const</span> Surface_mesh* m_sm;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : CGAL::data_file_path(<span class="stringliteral">"meshes/pig.off"</span>);</div><div class="line"></div><div class="line">  Surface_mesh sm;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLIOFct.html#ga49f5b5e6fbfcbfaaac7604c88e10915c">CGAL::Polygon_mesh_processing::IO::read_polygon_mesh</a>(filename, sm) || sm.is_empty())</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input file."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// get the transformation that yields the optimal bounding box</span></div><div class="line">  Aff_transformation at;</div><div class="line">  <a class="code" href="group__PkgOptimalBoundingBox__Oriented__bounding__box.html#gac1917f59df722d338d44a63d3a8aa14a">CGAL::oriented_bounding_box</a>(sm, at);</div><div class="line"></div><div class="line">  <span class="comment">// functor to apply the affine transformation to a vertex of the mesh</span></div><div class="line">  Aff_tr_fct aff_tr_fct(at, sm);</div><div class="line">  <span class="keyword">auto</span> aff_tr_vpm = boost::make_function_property_map&lt;vertex_descriptor&gt;(aff_tr_fct);</div><div class="line"></div><div class="line">  <span class="comment">// rotated AABB tree</span></div><div class="line">  <span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/AABB_tree.tag:../AABB_tree/" href="../AABB_tree/classCGAL_1_1AABB__face__graph__triangle__primitive.html">CGAL::AABB_face_graph_triangle_primitive&lt;Surface_mesh, decltype(aff_tr_vpm)&gt;</a> AABB_face_graph_primitive;</div><div class="line">  <span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/AABB_tree.tag:../AABB_tree/" href="../AABB_tree/classCGAL_1_1AABB__traits.html">CGAL::AABB_traits&lt;K, AABB_face_graph_primitive&gt;</a>                              AABB_face_graph_traits;</div><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/AABB_tree.tag:../AABB_tree/" href="../AABB_tree/classCGAL_1_1AABB__tree.html">CGAL::AABB_tree&lt;AABB_face_graph_traits&gt;</a> tree(faces(sm).begin(), faces(sm).end(), sm, aff_tr_vpm);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="OBBHistory"></a>
Implementation History</h1>
<p>A prototype was created by Konstantinos Katrioplas in 2018. Mael Rouxel-Labbé worked to speed up and robustify the implementation, and to submit the first version of this package. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jan 30 2023 13:47:16 for CGAL 5.6 - Optimal Bounding Box by
    <a href="https://www.doxygen.nl/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>
</html>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.6 - Optimal Bounding Box
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Building_Optimal_Bounding_Box"></a> </p><div id="autotoc" class="toc"></div> 
<p><a class="anchor" id="fig__OBBBanner"></a></p><center> <div class="image">
<img src="obb_chess.png" style="max-width:70%;" />
</div>
 </center><dl class="section author"><dt>Authors</dt><dd>Konstantinos Katrioplas, Mael Rouxel-Labbé</dd></dl>
<h1><a class="anchor" id="OBBIntro"></a>
Introduction</h1>
<p>Encompassing a model within a volume is a common approach to accelerate a number of applications such as collision detection or visibility testing: the proxy volume provides a rapid way to test a configuration or filter results, with the real model only being used when required. Typical coarser volumes that can be used to approximate a more complex model are simplified meshes (for example using the package <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceMeshSimplification">Triangulated Surface Mesh Simplification</a>), convex hulls, or simple rectangular boxes. Within this last category, the axis-aligned bounding box (AABB) has obvious advantages: it is extremely simple to compute and one may build a hierarchical structure of successively tighter volumes to further speed up intersection and distance computations. One such example of structure is the CGAL AABB tree (<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgAABBTree">3D Fast Intersection and Distance Computation</a>). The disadvantage is also clear: the box is usually poorly fitting most models. A good compromise between the good approximation offered by convex hulls or simplified meshes and the speed offered by axis-aligned bounding boxes are <em>Optimal Bounding Boxes</em>. Contrary to the AABB, the optimal bounding box of a model is not necessarily axis-aligned, but provides a tight approximation.</p>
<p><a class="anchor" id="fig__obb_aabb_vs_obb"></a></p><center> <div class="image">
<img src="aabb_vs_obb.jpg" style="max-width:70%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__obb_aabb_vs_obb">Figure 99.2</a> Left: the axis-aligned bounding box. Right: the optimal bounding box, a much better fit.
<p> </p></div> <br /> 
<p>In 2D, the optimal bounding rectangle of an input can be computed in linear time using the technique of <em>rotating calipers</em>, first introduced by Toussaint <a class="el" href="citelist.html#CITEREF_cgal:t-sgprc-83">[4]</a> (see also the CGAL package <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgBoundingVolumes">Bounding Volumes</a>). An algorithm to compute the optimal oriented bounding box in 3D was proposed by O’Rourke <a class="el" href="citelist.html#CITEREF_cgal:or-fmeb-85">[3]</a>, but its cubic complexity in the number of points makes it unusable in practice. The implementation proposed in this package is based on the paper of Chang et al.<a class="el" href="citelist.html#CITEREF_cgal:cgm-fobbo-11">[1]</a>, who introduced an algorithm to compute a close approximation of the optimal bounding box. As this is but an approximation of the optimal bounding box, we call the resulting box, the <em>Oriented Bounding Box</em>.</p>
<h1><a class="anchor" id="OBBOrientedBoundingBox"></a>
Oriented Bounding Box</h1>
<p>The algorithm introduced by Chang et al. formulates the computation of the optimal bounding box as an unconstrained optimization problem on the 3D matrix rotation group. The function to optimize is defined as the volume of the box. Because this function is non-differentiable, in particular near local optima, traditional optimization methods might encounter convergence issues. Consequently, Chang et al.'s algorithm employs a combination of a derivative-free optimization method, the Nelder-Mead simplex method <a class="el" href="citelist.html#CITEREF_cgal:nm-smfm-65">[2]</a>, and a metaheuristics method based on biological evolution principles to maintain and evolve a population of tentative rotation matrices. The purpose of this evolution is to oppose a global approach to the local Nelder-Mead optimization, enabling the algorithm to explore the search space as much as possible, and to find not only a local minimum, but a global optimum.</p>
<h2><a class="anchor" id="OBBOptimality"></a>
Missing the Optimality</h2>
<p>In theory, the genetic algorithms used by Chang et al. enable - given enough time - the algorithm to explore the complete search space. In practice, an algorithm does not have infinite time at its disposal. In addition, there is no simple way to check if the current-best solution is optimal. Thus, an implementation of the algorithm cannot provide the same guarantees that the theoretical algorithm offers. However, we observe that in practice the algorithm constructs a close approximation of the optimal bounding box most of the time.</p>
<h2><a class="anchor" id="OBBConvexHull"></a>
Convex Hull Computation as Preprocessing</h2>
<p>As the bounding box only depends on the convex hull of the object, computing its convex hull as a preprocessing step is a good way to reduce the number of points in subsequent computations. The computational trade-off is developed in more details in Section <a class="el" href="index.html#OBBComplexityPerformance">Complexity and Performance</a>.</p>
<h1><a class="anchor" id="OBBImplementation"></a>
Design and Implementation</h1>
<p>The computation of the oriented bounding box can be performed by calling the free function <code><a class="el" href="group__PkgOptimalBoundingBox__Oriented__bounding__box.html#gac1917f59df722d338d44a63d3a8aa14a" title="The function oriented_bounding_box() computes an approximation of the optimal bounding box...">CGAL::oriented_bounding_box()</a></code>. Convex hull computation is performed using the package <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgConvexHull3">3D Convex Hulls</a>, and is enabled by default.</p>
<h2><a class="anchor" id="OBBInnOut"></a>
Input and Output</h2>
<p>The input can be a range of 3D points, or a mesh, with a variety of <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__bgl__namedparameters.html">Named Parameters</a> enabling using further custom inputs.</p>
<p>The result of the algorithm can be retrieved as:</p><ul>
<li>the best affine transformation \({\mathcal R}_b\) that the algorithm has found;</li>
<li>an array of eight points, representing the best oriented bounding box that the algorithm has constructed, which is related to \( {\mathcal R}_b\) as it is the inverse transformation of the axis-aligned bounding box of the transformed input object. The order of the points in the array is the same as in the function <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html"><code>CGAL::make_hexahedron()</code> </a>, which can be used to construct a mesh from these points.</li>
<li>a model of <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/classMutableFaceGraph.html">MutableFaceGraph</a></code>, a quadrangular mesh representing the oriented bounding box.</li>
</ul>
<h2><a class="anchor" id="OBBTraitsnKernels"></a>
Traits and Kernel Choice</h2>
<p>The requirements on geometric objects and operations on these objects are described in the traits class concept <code><a class="el" href="classOrientedBoundingBoxTraits__3.html" title="The concept OrientedBoundingBoxTraits_3 describes the requirements of the traits class used in the fu...">OrientedBoundingBoxTraits_3</a></code>. A model of this concept is provided: <code><a class="el" href="classCGAL_1_1Oriented__bounding__box__traits__3.html" title="The class CGAL::Oriented_bounding_box_traits_3 is a traits type to be used with the overloads of the ...">CGAL::Oriented_bounding_box_traits_3</a></code>.</p>
<p>If the approach using the convex hull is chosen, a kernel offering exact predicates must be used to ensure a correct hull. In addition, the eight bounding vertices are constructed using the best found affine transformation; consequently, a kernel providing exact construction may also be useful.</p>
<h1><a class="anchor" id="OBBComplexityPerformance"></a>
Complexity and Performance</h1>
<p>A major drawback of the exact algorithm of O’Rourke is its cubic complexity and consequent large runtimes. In this section, we investigate the speedup gained by preprocessing the input data with a convex hull computation, and show that the oriented bounding box algorithm exhibits linear complexity.</p>
<p>Models from the <a href="https://ten-thousand-models.appspot.com/">Thingi10k</a> data set are used with speeds being averaged over 100 runs for each model. The machine used is a laptop running Fedora 30 64-bits, with two 6-core Intel(R) i9-8950HK CPU clocked at 2.90GHz, and with 32GB of RAM. The CGAL kernel used is <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a></code>.</p>
<h2><a class="anchor" id="OBBConvexHullComplexity"></a>
Cost and Gain of Convex Hull Computations</h2>
<p>Computing the convex hull as a preliminary step provides a significant speed advantage.</p>
<p><a class="anchor" id="fig__ch_speed_up"></a></p><center> <div class="image">
<img src="ch_speedup.png" style="max-width:70%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__ch_speed_up">Figure 99.3</a> Computation of the speedup achieved on the total runtime of the algorithm when the convex hull is computed and used afterwards. Note that the total runtime includes the construction of the convex hull (when it is used). The color and size of the dots represent the number of vertices in the input data (larger, bluer points having more input vertices than greener, smaller points). Computing the convex hull is beneficial for all but a handful of cases.  </div> <br /> 
<h2><a class="anchor" id="OBBOrientedBoundingBoxComplexity"></a>
Performance of the Oriented Bounding Box Algorithm</h2>
<p>We analyze in this section the computation time of the algorithm based on the number of vertices on the convex hull.</p>
<p><a class="anchor" id="fig__obb_timings"></a></p><center> <div class="image">
<img src="obb_time.png" style="max-width:70%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__obb_timings">Figure 99.4</a> Running times for the oriented bounding box construction of the convex hull of models of the <a href="https://ten-thousand-models.appspot.com/">Thingi10k</a> data set. The color and size of the dots represent the number of vertices in the input data (larger, bluer points having more input vertices than greener, smaller points). The algorithm exhibits linear complexity in practice. For visibility reasons, the few models whose convex hull has more than 10000 vertices are excluded from this graph, but consistent results are observed.  </div> <br /> 
<h1><a class="anchor" id="OBBexamples"></a>
Examples</h1>
<h2><a class="anchor" id="OBBBasicExample"></a>
Basic Example</h2>
<p>The following example illustrates a basic usage of the algorithm: an input mesh is read, its oriented bounding box is computed using an array as output, and a mesh is constructed from the eight points.</p>
<p><br />
<b>File</b> <a class="el" href="Optimal_bounding_box_2obb_example_8cpp-example.html">Optimal_bounding_box/obb_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optimal__bounding__box_8h.html">CGAL/optimal_bounding_box.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/triangulate_faces.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/measure.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/IO/polygon_mesh_io.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>PMP = CGAL::Polygon_mesh_processing;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>    K;</div><div class="line"><span class="keyword">typedef</span> K::Point_3                                             Point;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point&gt;</a>                              Surface_mesh;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : CGAL::data_file_path(<span class="stringliteral">"meshes/pig.off"</span>);</div><div class="line"></div><div class="line">  Surface_mesh sm;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLIOFct.html#ga49f5b5e6fbfcbfaaac7604c88e10915c">PMP::IO::read_polygon_mesh</a>(filename, sm) || sm.is_empty())</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input file."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  CGAL::Real_timer timer;</div><div class="line">  timer.start();</div><div class="line"></div><div class="line">  <span class="comment">// Compute the extreme points of the mesh, and then a tightly fitted oriented bounding box</span></div><div class="line">  std::array&lt;Point, 8&gt; obb_points;</div><div class="line">  <a class="code" href="group__PkgOptimalBoundingBox__Oriented__bounding__box.html#gac1917f59df722d338d44a63d3a8aa14a">CGAL::oriented_bounding_box</a>(sm, obb_points,</div><div class="line">                              CGAL::parameters::use_convex_hull(<span class="keyword">true</span>));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Elapsed time: "</span> &lt;&lt; timer.time() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Make a mesh out of the oriented bounding box</span></div><div class="line">  Surface_mesh obb_sm;</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#gad9df350e98780f0c213046d8a257358e">CGAL::make_hexahedron</a>(obb_points[0], obb_points[1], obb_points[2], obb_points[3],</div><div class="line">                        obb_points[4], obb_points[5], obb_points[6], obb_points[7], obb_sm);</div><div class="line">  std::ofstream(<span class="stringliteral">"obb.off"</span>) &lt;&lt; obb_sm;</div><div class="line"></div><div class="line">  PMP::triangulate_faces(obb_sm);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Volume: "</span> &lt;&lt; <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__volume__grp.html#ga4ba6790576ca34b8421e120ec7562d9a">PMP::volume</a>(obb_sm) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="OBBExampleNP"></a>
Using Named Parameters</h2>
<p>The following example illustrates how to use <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__bgl__namedparameters.html">Named Parameters</a> to efficiently compute the oriented bounding box of a mesh whose vertices' positions are modified on the fly.</p>
<p><br />
<b>File</b> <a class="el" href="Optimal_bounding_box_2obb_with_point_maps_example_8cpp-example.html">Optimal_bounding_box/obb_with_point_maps_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optimal__bounding__box_8h.html">CGAL/optimal_bounding_box.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/IO/polygon_mesh_io.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;array&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;unordered_map&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>    K;</div><div class="line"><span class="keyword">typedef</span> K::Point_3                                             Point;</div><div class="line"><span class="keyword">typedef</span> K::Vector_3                                            Vector;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point&gt;</a>                              Surface_mesh;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Surface_mesh&gt;::vertex_descriptor   vertex_descriptor;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>CP = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL_1_1parameters.html">CGAL::parameters</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : CGAL::data_file_path(<span class="stringliteral">"meshes/pig.off"</span>);</div><div class="line"></div><div class="line">  Surface_mesh sm;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLIOFct.html#ga49f5b5e6fbfcbfaaac7604c88e10915c">CGAL::Polygon_mesh_processing::IO::read_polygon_mesh</a>(filename, sm) || sm.is_empty())</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input file."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// a typical call</span></div><div class="line">  std::array&lt;Point, 8&gt; obb_points;</div><div class="line">  <a class="code" href="group__PkgOptimalBoundingBox__Oriented__bounding__box.html#gac1917f59df722d338d44a63d3a8aa14a">CGAL::oriented_bounding_box</a>(sm, obb_points);</div><div class="line"></div><div class="line">  <span class="comment">// one can associate positions to the vertices of the mesh without changing the mesh</span></div><div class="line">  std::unordered_map&lt;vertex_descriptor, Point&gt; translated_positions;</div><div class="line">  <span class="keywordflow">for</span>(<span class="keyword">const</span> vertex_descriptor&amp; v : vertices(sm))</div><div class="line">    translated_positions[v] = sm.point(v) + Vector(1, 2, 3);</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgOptimalBoundingBox__Oriented__bounding__box.html#gac1917f59df722d338d44a63d3a8aa14a">CGAL::oriented_bounding_box</a>(sm, obb_points,</div><div class="line">                              CP::vertex_point_map(boost::make_assoc_property_map(translated_positions)));</div><div class="line"></div><div class="line">  <span class="comment">// using a range of points</span></div><div class="line">  std::vector&lt;Point&gt; points;</div><div class="line">  <span class="keywordflow">for</span>(<span class="keyword">const</span> vertex_descriptor&amp; v : vertices(sm))</div><div class="line">    points.push_back(sm.point(v));</div><div class="line">  <a class="code" href="group__PkgOptimalBoundingBox__Oriented__bounding__box.html#gac1917f59df722d338d44a63d3a8aa14a">CGAL::oriented_bounding_box</a>(points, obb_points);</div><div class="line"></div><div class="line">  <span class="comment">// one can associate positions to the range without changing the range</span></div><div class="line">  std::map&lt;Point, Point&gt; scaled_positions;</div><div class="line">  <span class="keywordflow">for</span>(<span class="keyword">const</span> Point&amp; p : points)</div><div class="line">    scaled_positions[p] = p + (p - <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga9d272a8e3a8080b851741b6d3a44afdc">CGAL::ORIGIN</a>);</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgOptimalBoundingBox__Oriented__bounding__box.html#gac1917f59df722d338d44a63d3a8aa14a">CGAL::oriented_bounding_box</a>(points, obb_points,</div><div class="line">                              CP::point_map(boost::make_assoc_property_map(scaled_positions)));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="OBBRotatedTree"></a>
Rotated AABB Tree</h2>
<p>The following example uses the affine transformation, which is the affine transformation such that the axis-aligned bounding box of the transformed vertices of the mesh has minimum volume, returned by the algorithm to build a custom vertex point property map. An AABB tree of the (on the fly) rotated faces of the mesh is then constructed.</p>
<p><br />
<b>File</b> <a class="el" href="Optimal_bounding_box_2rotated_aabb_tree_example_8cpp-example.html">Optimal_bounding_box/rotated_aabb_tree_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/AABB_tree.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/AABB_traits.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/AABB_face_graph_triangle_primitive.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optimal__bounding__box_8h.html">CGAL/optimal_bounding_box.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/IO/polygon_mesh_io.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/property_map/function_property_map.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>    K;</div><div class="line"><span class="keyword">typedef</span> K::Point_3                                             Point;</div><div class="line"><span class="keyword">typedef</span> K::Aff_transformation_3                                Aff_transformation;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point&gt;</a>                              Surface_mesh;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Surface_mesh&gt;::vertex_descriptor   vertex_descriptor;</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Aff_tr_fct</div><div class="line">{</div><div class="line">  Aff_tr_fct() : m_at(nullptr), m_sm(nullptr) { }</div><div class="line">  Aff_tr_fct(<span class="keyword">const</span> Aff_transformation&amp; at, <span class="keyword">const</span> Surface_mesh&amp; sm) : m_at(&amp;at), m_sm(&amp;sm) { }</div><div class="line"></div><div class="line">  Point operator()(<span class="keyword">const</span> vertex_descriptor v)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_at-&gt;transform(m_sm-&gt;point(v)); }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> Aff_transformation* m_at;</div><div class="line">  <span class="keyword">const</span> Surface_mesh* m_sm;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : CGAL::data_file_path(<span class="stringliteral">"meshes/pig.off"</span>);</div><div class="line"></div><div class="line">  Surface_mesh sm;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLIOFct.html#ga49f5b5e6fbfcbfaaac7604c88e10915c">CGAL::Polygon_mesh_processing::IO::read_polygon_mesh</a>(filename, sm) || sm.is_empty())</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input file."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// get the transformation that yields the optimal bounding box</span></div><div class="line">  Aff_transformation at;</div><div class="line">  <a class="code" href="group__PkgOptimalBoundingBox__Oriented__bounding__box.html#gac1917f59df722d338d44a63d3a8aa14a">CGAL::oriented_bounding_box</a>(sm, at);</div><div class="line"></div><div class="line">  <span class="comment">// functor to apply the affine transformation to a vertex of the mesh</span></div><div class="line">  Aff_tr_fct aff_tr_fct(at, sm);</div><div class="line">  <span class="keyword">auto</span> aff_tr_vpm = boost::make_function_property_map&lt;vertex_descriptor&gt;(aff_tr_fct);</div><div class="line"></div><div class="line">  <span class="comment">// rotated AABB tree</span></div><div class="line">  <span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/AABB_tree.tag:../AABB_tree/" href="../AABB_tree/classCGAL_1_1AABB__face__graph__triangle__primitive.html">CGAL::AABB_face_graph_triangle_primitive&lt;Surface_mesh, decltype(aff_tr_vpm)&gt;</a> AABB_face_graph_primitive;</div><div class="line">  <span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/AABB_tree.tag:../AABB_tree/" href="../AABB_tree/classCGAL_1_1AABB__traits.html">CGAL::AABB_traits&lt;K, AABB_face_graph_primitive&gt;</a>                              AABB_face_graph_traits;</div><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/AABB_tree.tag:../AABB_tree/" href="../AABB_tree/classCGAL_1_1AABB__tree.html">CGAL::AABB_tree&lt;AABB_face_graph_traits&gt;</a> tree(faces(sm).begin(), faces(sm).end(), sm, aff_tr_vpm);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="OBBHistory"></a>
Implementation History</h1>
<p>A prototype was created by Konstantinos Katrioplas in 2018. Mael Rouxel-Labbé worked to speed up and robustify the implementation, and to submit the first version of this package. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jan 30 2023 13:47:16 for CGAL 5.6 - Optimal Bounding Box by
    <a href="https://www.doxygen.nl/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>
</html><html xmlns="http://www.w3.org/1999/xhtml"><body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.6 - Optimal Bounding Box
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Building_Optimal_Bounding_Box"></a> </p><div id="autotoc" class="toc"></div> 
<p><a class="anchor" id="fig__OBBBanner"></a></p><center> <div class="image">
<img src="obb_chess.png" style="max-width:70%;" />
</div>
 </center><dl class="section author"><dt>Authors</dt><dd>Konstantinos Katrioplas, Mael Rouxel-Labbé</dd></dl>
<h1><a class="anchor" id="OBBIntro"></a>
Introduction</h1>
<p>Encompassing a model within a volume is a common approach to accelerate a number of applications such as collision detection or visibility testing: the proxy volume provides a rapid way to test a configuration or filter results, with the real model only being used when required. Typical coarser volumes that can be used to approximate a more complex model are simplified meshes (for example using the package <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceMeshSimplification">Triangulated Surface Mesh Simplification</a>), convex hulls, or simple rectangular boxes. Within this last category, the axis-aligned bounding box (AABB) has obvious advantages: it is extremely simple to compute and one may build a hierarchical structure of successively tighter volumes to further speed up intersection and distance computations. One such example of structure is the CGAL AABB tree (<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgAABBTree">3D Fast Intersection and Distance Computation</a>). The disadvantage is also clear: the box is usually poorly fitting most models. A good compromise between the good approximation offered by convex hulls or simplified meshes and the speed offered by axis-aligned bounding boxes are <em>Optimal Bounding Boxes</em>. Contrary to the AABB, the optimal bounding box of a model is not necessarily axis-aligned, but provides a tight approximation.</p>
<p><a class="anchor" id="fig__obb_aabb_vs_obb"></a></p><center> <div class="image">
<img src="aabb_vs_obb.jpg" style="max-width:70%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__obb_aabb_vs_obb">Figure 99.2</a> Left: the axis-aligned bounding box. Right: the optimal bounding box, a much better fit.
<p> </p></div> <br /> 
<p>In 2D, the optimal bounding rectangle of an input can be computed in linear time using the technique of <em>rotating calipers</em>, first introduced by Toussaint <a class="el" href="citelist.html#CITEREF_cgal:t-sgprc-83">[4]</a> (see also the CGAL package <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgBoundingVolumes">Bounding Volumes</a>). An algorithm to compute the optimal oriented bounding box in 3D was proposed by O’Rourke <a class="el" href="citelist.html#CITEREF_cgal:or-fmeb-85">[3]</a>, but its cubic complexity in the number of points makes it unusable in practice. The implementation proposed in this package is based on the paper of Chang et al.<a class="el" href="citelist.html#CITEREF_cgal:cgm-fobbo-11">[1]</a>, who introduced an algorithm to compute a close approximation of the optimal bounding box. As this is but an approximation of the optimal bounding box, we call the resulting box, the <em>Oriented Bounding Box</em>.</p>
<h1><a class="anchor" id="OBBOrientedBoundingBox"></a>
Oriented Bounding Box</h1>
<p>The algorithm introduced by Chang et al. formulates the computation of the optimal bounding box as an unconstrained optimization problem on the 3D matrix rotation group. The function to optimize is defined as the volume of the box. Because this function is non-differentiable, in particular near local optima, traditional optimization methods might encounter convergence issues. Consequently, Chang et al.'s algorithm employs a combination of a derivative-free optimization method, the Nelder-Mead simplex method <a class="el" href="citelist.html#CITEREF_cgal:nm-smfm-65">[2]</a>, and a metaheuristics method based on biological evolution principles to maintain and evolve a population of tentative rotation matrices. The purpose of this evolution is to oppose a global approach to the local Nelder-Mead optimization, enabling the algorithm to explore the search space as much as possible, and to find not only a local minimum, but a global optimum.</p>
<h2><a class="anchor" id="OBBOptimality"></a>
Missing the Optimality</h2>
<p>In theory, the genetic algorithms used by Chang et al. enable - given enough time - the algorithm to explore the complete search space. In practice, an algorithm does not have infinite time at its disposal. In addition, there is no simple way to check if the current-best solution is optimal. Thus, an implementation of the algorithm cannot provide the same guarantees that the theoretical algorithm offers. However, we observe that in practice the algorithm constructs a close approximation of the optimal bounding box most of the time.</p>
<h2><a class="anchor" id="OBBConvexHull"></a>
Convex Hull Computation as Preprocessing</h2>
<p>As the bounding box only depends on the convex hull of the object, computing its convex hull as a preprocessing step is a good way to reduce the number of points in subsequent computations. The computational trade-off is developed in more details in Section <a class="el" href="index.html#OBBComplexityPerformance">Complexity and Performance</a>.</p>
<h1><a class="anchor" id="OBBImplementation"></a>
Design and Implementation</h1>
<p>The computation of the oriented bounding box can be performed by calling the free function <code><a class="el" href="group__PkgOptimalBoundingBox__Oriented__bounding__box.html#gac1917f59df722d338d44a63d3a8aa14a" title="The function oriented_bounding_box() computes an approximation of the optimal bounding box...">CGAL::oriented_bounding_box()</a></code>. Convex hull computation is performed using the package <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgConvexHull3">3D Convex Hulls</a>, and is enabled by default.</p>
<h2><a class="anchor" id="OBBInnOut"></a>
Input and Output</h2>
<p>The input can be a range of 3D points, or a mesh, with a variety of <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__bgl__namedparameters.html">Named Parameters</a> enabling using further custom inputs.</p>
<p>The result of the algorithm can be retrieved as:</p><ul>
<li>the best affine transformation \({\mathcal R}_b\) that the algorithm has found;</li>
<li>an array of eight points, representing the best oriented bounding box that the algorithm has constructed, which is related to \( {\mathcal R}_b\) as it is the inverse transformation of the axis-aligned bounding box of the transformed input object. The order of the points in the array is the same as in the function <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html"><code>CGAL::make_hexahedron()</code> </a>, which can be used to construct a mesh from these points.</li>
<li>a model of <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/classMutableFaceGraph.html">MutableFaceGraph</a></code>, a quadrangular mesh representing the oriented bounding box.</li>
</ul>
<h2><a class="anchor" id="OBBTraitsnKernels"></a>
Traits and Kernel Choice</h2>
<p>The requirements on geometric objects and operations on these objects are described in the traits class concept <code><a class="el" href="classOrientedBoundingBoxTraits__3.html" title="The concept OrientedBoundingBoxTraits_3 describes the requirements of the traits class used in the fu...">OrientedBoundingBoxTraits_3</a></code>. A model of this concept is provided: <code><a class="el" href="classCGAL_1_1Oriented__bounding__box__traits__3.html" title="The class CGAL::Oriented_bounding_box_traits_3 is a traits type to be used with the overloads of the ...">CGAL::Oriented_bounding_box_traits_3</a></code>.</p>
<p>If the approach using the convex hull is chosen, a kernel offering exact predicates must be used to ensure a correct hull. In addition, the eight bounding vertices are constructed using the best found affine transformation; consequently, a kernel providing exact construction may also be useful.</p>
<h1><a class="anchor" id="OBBComplexityPerformance"></a>
Complexity and Performance</h1>
<p>A major drawback of the exact algorithm of O’Rourke is its cubic complexity and consequent large runtimes. In this section, we investigate the speedup gained by preprocessing the input data with a convex hull computation, and show that the oriented bounding box algorithm exhibits linear complexity.</p>
<p>Models from the <a href="https://ten-thousand-models.appspot.com/">Thingi10k</a> data set are used with speeds being averaged over 100 runs for each model. The machine used is a laptop running Fedora 30 64-bits, with two 6-core Intel(R) i9-8950HK CPU clocked at 2.90GHz, and with 32GB of RAM. The CGAL kernel used is <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a></code>.</p>
<h2><a class="anchor" id="OBBConvexHullComplexity"></a>
Cost and Gain of Convex Hull Computations</h2>
<p>Computing the convex hull as a preliminary step provides a significant speed advantage.</p>
<p><a class="anchor" id="fig__ch_speed_up"></a></p><center> <div class="image">
<img src="ch_speedup.png" style="max-width:70%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__ch_speed_up">Figure 99.3</a> Computation of the speedup achieved on the total runtime of the algorithm when the convex hull is computed and used afterwards. Note that the total runtime includes the construction of the convex hull (when it is used). The color and size of the dots represent the number of vertices in the input data (larger, bluer points having more input vertices than greener, smaller points). Computing the convex hull is beneficial for all but a handful of cases.  </div> <br /> 
<h2><a class="anchor" id="OBBOrientedBoundingBoxComplexity"></a>
Performance of the Oriented Bounding Box Algorithm</h2>
<p>We analyze in this section the computation time of the algorithm based on the number of vertices on the convex hull.</p>
<p><a class="anchor" id="fig__obb_timings"></a></p><center> <div class="image">
<img src="obb_time.png" style="max-width:70%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__obb_timings">Figure 99.4</a> Running times for the oriented bounding box construction of the convex hull of models of the <a href="https://ten-thousand-models.appspot.com/">Thingi10k</a> data set. The color and size of the dots represent the number of vertices in the input data (larger, bluer points having more input vertices than greener, smaller points). The algorithm exhibits linear complexity in practice. For visibility reasons, the few models whose convex hull has more than 10000 vertices are excluded from this graph, but consistent results are observed.  </div> <br /> 
<h1><a class="anchor" id="OBBexamples"></a>
Examples</h1>
<h2><a class="anchor" id="OBBBasicExample"></a>
Basic Example</h2>
<p>The following example illustrates a basic usage of the algorithm: an input mesh is read, its oriented bounding box is computed using an array as output, and a mesh is constructed from the eight points.</p>
<p><br />
<b>File</b> <a class="el" href="Optimal_bounding_box_2obb_example_8cpp-example.html">Optimal_bounding_box/obb_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optimal__bounding__box_8h.html">CGAL/optimal_bounding_box.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/triangulate_faces.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/measure.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/IO/polygon_mesh_io.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>PMP = CGAL::Polygon_mesh_processing;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>    K;</div><div class="line"><span class="keyword">typedef</span> K::Point_3                                             Point;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point&gt;</a>                              Surface_mesh;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : CGAL::data_file_path(<span class="stringliteral">"meshes/pig.off"</span>);</div><div class="line"></div><div class="line">  Surface_mesh sm;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLIOFct.html#ga49f5b5e6fbfcbfaaac7604c88e10915c">PMP::IO::read_polygon_mesh</a>(filename, sm) || sm.is_empty())</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input file."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  CGAL::Real_timer timer;</div><div class="line">  timer.start();</div><div class="line"></div><div class="line">  <span class="comment">// Compute the extreme points of the mesh, and then a tightly fitted oriented bounding box</span></div><div class="line">  std::array&lt;Point, 8&gt; obb_points;</div><div class="line">  <a class="code" href="group__PkgOptimalBoundingBox__Oriented__bounding__box.html#gac1917f59df722d338d44a63d3a8aa14a">CGAL::oriented_bounding_box</a>(sm, obb_points,</div><div class="line">                              CGAL::parameters::use_convex_hull(<span class="keyword">true</span>));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Elapsed time: "</span> &lt;&lt; timer.time() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Make a mesh out of the oriented bounding box</span></div><div class="line">  Surface_mesh obb_sm;</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#gad9df350e98780f0c213046d8a257358e">CGAL::make_hexahedron</a>(obb_points[0], obb_points[1], obb_points[2], obb_points[3],</div><div class="line">                        obb_points[4], obb_points[5], obb_points[6], obb_points[7], obb_sm);</div><div class="line">  std::ofstream(<span class="stringliteral">"obb.off"</span>) &lt;&lt; obb_sm;</div><div class="line"></div><div class="line">  PMP::triangulate_faces(obb_sm);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Volume: "</span> &lt;&lt; <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__volume__grp.html#ga4ba6790576ca34b8421e120ec7562d9a">PMP::volume</a>(obb_sm) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="OBBExampleNP"></a>
Using Named Parameters</h2>
<p>The following example illustrates how to use <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__bgl__namedparameters.html">Named Parameters</a> to efficiently compute the oriented bounding box of a mesh whose vertices' positions are modified on the fly.</p>
<p><br />
<b>File</b> <a class="el" href="Optimal_bounding_box_2obb_with_point_maps_example_8cpp-example.html">Optimal_bounding_box/obb_with_point_maps_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optimal__bounding__box_8h.html">CGAL/optimal_bounding_box.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/IO/polygon_mesh_io.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;array&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;unordered_map&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>    K;</div><div class="line"><span class="keyword">typedef</span> K::Point_3                                             Point;</div><div class="line"><span class="keyword">typedef</span> K::Vector_3                                            Vector;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point&gt;</a>                              Surface_mesh;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Surface_mesh&gt;::vertex_descriptor   vertex_descriptor;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>CP = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL_1_1parameters.html">CGAL::parameters</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : CGAL::data_file_path(<span class="stringliteral">"meshes/pig.off"</span>);</div><div class="line"></div><div class="line">  Surface_mesh sm;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLIOFct.html#ga49f5b5e6fbfcbfaaac7604c88e10915c">CGAL::Polygon_mesh_processing::IO::read_polygon_mesh</a>(filename, sm) || sm.is_empty())</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input file."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// a typical call</span></div><div class="line">  std::array&lt;Point, 8&gt; obb_points;</div><div class="line">  <a class="code" href="group__PkgOptimalBoundingBox__Oriented__bounding__box.html#gac1917f59df722d338d44a63d3a8aa14a">CGAL::oriented_bounding_box</a>(sm, obb_points);</div><div class="line"></div><div class="line">  <span class="comment">// one can associate positions to the vertices of the mesh without changing the mesh</span></div><div class="line">  std::unordered_map&lt;vertex_descriptor, Point&gt; translated_positions;</div><div class="line">  <span class="keywordflow">for</span>(<span class="keyword">const</span> vertex_descriptor&amp; v : vertices(sm))</div><div class="line">    translated_positions[v] = sm.point(v) + Vector(1, 2, 3);</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgOptimalBoundingBox__Oriented__bounding__box.html#gac1917f59df722d338d44a63d3a8aa14a">CGAL::oriented_bounding_box</a>(sm, obb_points,</div><div class="line">                              CP::vertex_point_map(boost::make_assoc_property_map(translated_positions)));</div><div class="line"></div><div class="line">  <span class="comment">// using a range of points</span></div><div class="line">  std::vector&lt;Point&gt; points;</div><div class="line">  <span class="keywordflow">for</span>(<span class="keyword">const</span> vertex_descriptor&amp; v : vertices(sm))</div><div class="line">    points.push_back(sm.point(v));</div><div class="line">  <a class="code" href="group__PkgOptimalBoundingBox__Oriented__bounding__box.html#gac1917f59df722d338d44a63d3a8aa14a">CGAL::oriented_bounding_box</a>(points, obb_points);</div><div class="line"></div><div class="line">  <span class="comment">// one can associate positions to the range without changing the range</span></div><div class="line">  std::map&lt;Point, Point&gt; scaled_positions;</div><div class="line">  <span class="keywordflow">for</span>(<span class="keyword">const</span> Point&amp; p : points)</div><div class="line">    scaled_positions[p] = p + (p - <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga9d272a8e3a8080b851741b6d3a44afdc">CGAL::ORIGIN</a>);</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgOptimalBoundingBox__Oriented__bounding__box.html#gac1917f59df722d338d44a63d3a8aa14a">CGAL::oriented_bounding_box</a>(points, obb_points,</div><div class="line">                              CP::point_map(boost::make_assoc_property_map(scaled_positions)));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="OBBRotatedTree"></a>
Rotated AABB Tree</h2>
<p>The following example uses the affine transformation, which is the affine transformation such that the axis-aligned bounding box of the transformed vertices of the mesh has minimum volume, returned by the algorithm to build a custom vertex point property map. An AABB tree of the (on the fly) rotated faces of the mesh is then constructed.</p>
<p><br />
<b>File</b> <a class="el" href="Optimal_bounding_box_2rotated_aabb_tree_example_8cpp-example.html">Optimal_bounding_box/rotated_aabb_tree_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/AABB_tree.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/AABB_traits.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/AABB_face_graph_triangle_primitive.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optimal__bounding__box_8h.html">CGAL/optimal_bounding_box.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/IO/polygon_mesh_io.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/property_map/function_property_map.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>    K;</div><div class="line"><span class="keyword">typedef</span> K::Point_3                                             Point;</div><div class="line"><span class="keyword">typedef</span> K::Aff_transformation_3                                Aff_transformation;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point&gt;</a>                              Surface_mesh;</div><div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Surface_mesh&gt;::vertex_descriptor   vertex_descriptor;</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Aff_tr_fct</div><div class="line">{</div><div class="line">  Aff_tr_fct() : m_at(nullptr), m_sm(nullptr) { }</div><div class="line">  Aff_tr_fct(<span class="keyword">const</span> Aff_transformation&amp; at, <span class="keyword">const</span> Surface_mesh&amp; sm) : m_at(&amp;at), m_sm(&amp;sm) { }</div><div class="line"></div><div class="line">  Point operator()(<span class="keyword">const</span> vertex_descriptor v)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_at-&gt;transform(m_sm-&gt;point(v)); }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> Aff_transformation* m_at;</div><div class="line">  <span class="keyword">const</span> Surface_mesh* m_sm;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : CGAL::data_file_path(<span class="stringliteral">"meshes/pig.off"</span>);</div><div class="line"></div><div class="line">  Surface_mesh sm;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLIOFct.html#ga49f5b5e6fbfcbfaaac7604c88e10915c">CGAL::Polygon_mesh_processing::IO::read_polygon_mesh</a>(filename, sm) || sm.is_empty())</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input file."</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// get the transformation that yields the optimal bounding box</span></div><div class="line">  Aff_transformation at;</div><div class="line">  <a class="code" href="group__PkgOptimalBoundingBox__Oriented__bounding__box.html#gac1917f59df722d338d44a63d3a8aa14a">CGAL::oriented_bounding_box</a>(sm, at);</div><div class="line"></div><div class="line">  <span class="comment">// functor to apply the affine transformation to a vertex of the mesh</span></div><div class="line">  Aff_tr_fct aff_tr_fct(at, sm);</div><div class="line">  <span class="keyword">auto</span> aff_tr_vpm = boost::make_function_property_map&lt;vertex_descriptor&gt;(aff_tr_fct);</div><div class="line"></div><div class="line">  <span class="comment">// rotated AABB tree</span></div><div class="line">  <span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/AABB_tree.tag:../AABB_tree/" href="../AABB_tree/classCGAL_1_1AABB__face__graph__triangle__primitive.html">CGAL::AABB_face_graph_triangle_primitive&lt;Surface_mesh, decltype(aff_tr_vpm)&gt;</a> AABB_face_graph_primitive;</div><div class="line">  <span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/AABB_tree.tag:../AABB_tree/" href="../AABB_tree/classCGAL_1_1AABB__traits.html">CGAL::AABB_traits&lt;K, AABB_face_graph_primitive&gt;</a>                              AABB_face_graph_traits;</div><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/AABB_tree.tag:../AABB_tree/" href="../AABB_tree/classCGAL_1_1AABB__tree.html">CGAL::AABB_tree&lt;AABB_face_graph_traits&gt;</a> tree(faces(sm).begin(), faces(sm).end(), sm, aff_tr_vpm);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="OBBHistory"></a>
Implementation History</h1>
<p>A prototype was created by Konstantinos Katrioplas in 2018. Mael Rouxel-Labbé worked to speed up and robustify the implementation, and to submit the first version of this package. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jan 30 2023 13:47:16 for CGAL 5.6 - Optimal Bounding Box by
    <a href="https://www.doxygen.nl/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>
</html>

</html>
