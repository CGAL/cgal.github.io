<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Bounding_volumes/classCGAL_1_1Min__circle__2.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=11">
<meta name="generator" content="Doxygen 1.9.6">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CGAL 6.2 - Bounding Volumes: CGAL::Min_circle_2&lt; Traits &gt; Class Template Reference</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/doxygen.css" rel="stylesheet" type="text/css">
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      },
      equationNumbers: { autoNumber: "AMS" }
  }
}
);
MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
  var PARSE = MathJax.InputJax.TeX.Parse,
      TEXT = PARSE.prototype.InternalText;
  PARSE.Augment({
    InternalText: function (text,def) {
      text = text.replace(/\\/g,"");
      return TEXT.call(this,text,def);
    }
  });
});
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
      <span class="left">
         <span id="MSearchSelect" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"> 
        </span>
        <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
      </span>
      <span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.svg" alt=""></a>
      </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CGAL 6.2 - Bounding Volumes
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search/",'.html');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classCGAL_1_1Min__circle__2.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="classCGAL_1_1Min__circle__2-members.html">List of all members</a> |
<a href="#related">Related Functions</a>  </div>
  <div class="headertitle"><div class="title">CGAL::Min_circle_2&lt; Traits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__PkgBoundingVolumesRef.html">Reference Manual</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;CGAL/Min_circle_2.h&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Traits&gt;<br>
class CGAL::Min_circle_2&lt; Traits &gt;</div><p>An object of the class <code><a class="el" href="classCGAL_1_1Min__circle__2.html" title="An object of the class Min_circle_2 is the unique circle of smallest area enclosing a finite (multi)s...">Min_circle_2</a></code> is the unique circle of smallest area enclosing a finite (multi)set of points in two-dimensional Euclidean space \( \E^2\). </p>
<p>For a point set \( P\) we denote by \( mc(P)\) the smallest circle that contains all points of \( P\). Note that \( mc(P)\) can be degenerate, i.e. \( mc(P)=\emptyset\) if \( P=\emptyset\) and \( mc(P)=\{p\}\) if \( P=\{p\}\).</p>
<p>An inclusion-minimal subset \( S\) of \( P\) with \( mc(S)=mc(P)\) is called a <em>support set</em>, the points in \( S\) are the <em>support points</em>. A support set has size at most three, and all its points lie on the boundary of \( mc(P)\). In general, neither the support set nor its size are necessarily unique.</p>
<p>The underlying algorithm can cope with all kinds of input, e.g. \( P\) may be empty or points may occur more than once. The algorithm computes a support set \( S\) which remains fixed until the next insert or clear operation.</p>
<dl class="section note"><dt>Note</dt><dd>This class is (almost) obsolete. The class <code><a class="el" href="classCGAL_1_1Min__sphere__of__spheres__d.html" title="An object of the class Min_sphere_of_spheres_d is a data structure that represents the unique sphere ...">CGAL::Min_sphere_of_spheres_d</a>&lt;Traits&gt;</code> solves a more general problem and is faster than <code><a class="el" href="classCGAL_1_1Min__circle__2.html" title="An object of the class Min_circle_2 is the unique circle of smallest area enclosing a finite (multi)s...">Min_circle_2</a></code> even if used only for points in two dimensions as input. Most importantly, <code><a class="el" href="classCGAL_1_1Min__sphere__of__spheres__d.html" title="An object of the class Min_sphere_of_spheres_d is a data structure that represents the unique sphere ...">CGAL::Min_sphere_of_spheres_d</a>&lt;Traits&gt;</code> has a specialized implementation for floating-point arithmetic which ensures correct results in a large number of cases (including highly degenerate ones). In contrast, <code><a class="el" href="classCGAL_1_1Min__circle__2.html" title="An object of the class Min_circle_2 is the unique circle of smallest area enclosing a finite (multi)s...">Min_circle_2</a></code> is not tuned for floating-point computations. The only advantage of <code><a class="el" href="classCGAL_1_1Min__circle__2.html" title="An object of the class Min_circle_2 is the unique circle of smallest area enclosing a finite (multi)s...">Min_circle_2</a></code> over <code><a class="el" href="classCGAL_1_1Min__sphere__of__spheres__d.html" title="An object of the class Min_sphere_of_spheres_d is a data structure that represents the unique sphere ...">CGAL::Min_sphere_of_spheres_d</a>&lt;Traits&gt;</code> is that the former can deal with points in homogeneous coordinates, in which case the algorithm is division-free. Thus, <code><a class="el" href="classCGAL_1_1Min__circle__2.html" title="An object of the class Min_circle_2 is the unique circle of smallest area enclosing a finite (multi)s...">Min_circle_2</a></code> might still be an option in case your input number type cannot (efficiently) divide.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Traits</td><td>must be a model for <code><a class="el" href="classMinCircle2Traits.html" title="This concept defines the requirements for traits classes of CGAL::Min_circle_2&lt;Traits&gt;.">MinCircle2Traits</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<p>We provide the model <code><a class="el" href="classCGAL_1_1Min__circle__2__traits__2.html" title="The class Min_circle_2_traits_2 is a traits class for Min_circle_2&lt;Traits&gt; using the two-dimensional ...">CGAL::Min_circle_2_traits_2</a></code> using the two-dimensional CGAL kernel.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classCGAL_1_1Min__ellipse__2.html" title="An object of the class Min_ellipse_2 is the unique ellipse of smallest area enclosing a finite (multi...">CGAL::Min_ellipse_2</a>&lt;Traits&gt;</code> </dd>
<dd>
<code><a class="el" href="classCGAL_1_1Min__sphere__d.html" title="An object of the class Min_sphere_d is the unique sphere of smallest volume enclosing a finite (multi...">CGAL::Min_sphere_d</a>&lt;Traits&gt;</code> </dd>
<dd>
<code><a class="el" href="classCGAL_1_1Min__sphere__of__spheres__d.html" title="An object of the class Min_sphere_of_spheres_d is a data structure that represents the unique sphere ...">CGAL::Min_sphere_of_spheres_d</a>&lt;Traits&gt;</code> </dd>
<dd>
<code><a class="el" href="classCGAL_1_1Min__circle__2__traits__2.html" title="The class Min_circle_2_traits_2 is a traits class for Min_circle_2&lt;Traits&gt; using the two-dimensional ...">CGAL::Min_circle_2_traits_2</a>&lt;K&gt;</code> </dd>
<dd>
<code><a class="el" href="classMinCircle2Traits.html" title="This concept defines the requirements for traits classes of CGAL::Min_circle_2&lt;Traits&gt;.">MinCircle2Traits</a></code></dd></dl>
<p><b>Implementation</b><br>
</p>
<p>We implement the incremental algorithm of Welzl, with move-to-front heuristic <a class="el" href="citelist.html#CITEREF_w-sedbe-91a">[16]</a>. The whole implementation is described in <a class="el" href="citelist.html#CITEREF_cgal:gs-seceg-98">[5]</a>.</p>
<p>If randomization is chosen, the creation time is almost always linear in the number of points. Access functions and predicates take constant time, inserting a point might take up to linear time, but substantially less than computing the new smallest enclosing circle from scratch. The clear operation and the check for validity each takes linear time.</p>
<p><b>Example</b><br>
</p>
<p>To illustrate the creation of <code><a class="el" href="classCGAL_1_1Min__circle__2.html" title="An object of the class Min_circle_2 is the unique circle of smallest area enclosing a finite (multi)s...">Min_circle_2</a></code> and to show that randomization can be useful in certain cases, we give an example.</p>
<p><br>
<b>File</b> <a class="el" href="Min_circle_2_2min_circle_2_8cpp-example.html">Min_circle_2/min_circle_2.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Min_sphere_of_spheres_d.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Min_sphere_of_points_d_traits_2.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Random.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;array&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span>  <a class="code hl_structRef" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>                   K;</div>
<div class="line"><span class="keyword">typedef</span>  <a class="code hl_class" href="classCGAL_1_1Min__sphere__of__points__d__traits__2.html">CGAL::Min_sphere_of_points_d_traits_2&lt;K,double&gt;</a>  Traits;</div>
<div class="line"><span class="keyword">typedef</span>  <a class="code hl_class" href="classCGAL_1_1Min__sphere__of__spheres__d.html">CGAL::Min_sphere_of_spheres_d&lt;Traits&gt;</a>            Min_circle;</div>
<div class="line"><span class="keyword">typedef</span>  K::Point_2                                       <a class="code hl_typedef" href="classCGAL_1_1Min__circle__2.html#acaff2d7da19f3c8ca5bf8845253f6039">Point</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main( <span class="keywordtype">int</span>, <span class="keywordtype">char</span>**)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> n = 100;</div>
<div class="line">    std::array&lt;Point, n&gt; P;</div>
<div class="line">    CGAL::Random  r;                     <span class="comment">// random number generator</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt; n; ++i){</div>
<div class="line">      P.at(i) = <a class="code hl_typedef" href="classCGAL_1_1Min__circle__2.html#acaff2d7da19f3c8ca5bf8845253f6039">Point</a>(r.get_double(), r.get_double());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    Min_circle  mc( P.begin(), P.end());</div>
<div class="line"> </div>
<div class="line">    Min_circle::Cartesian_const_iterator ccib = mc.center_cartesian_begin(), ccie = mc.center_cartesian_end();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">"center:"</span>;</div>
<div class="line">    <span class="keywordflow">for</span>( ; ccib != ccie; ++ccib){</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; *ccib;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">"radius: "</span> &lt;&lt; mc.radius() &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassCGAL_1_1Min__circle__2_html_acaff2d7da19f3c8ca5bf8845253f6039"><div class="ttname"><a href="classCGAL_1_1Min__circle__2.html#acaff2d7da19f3c8ca5bf8845253f6039">CGAL::Min_circle_2::Point</a></div><div class="ttdeci">unspecified_type Point</div><div class="ttdoc">typedef to Traits::Point.</div><div class="ttdef"><b>Definition:</b> Min_circle_2.h:84</div></div>
<div class="ttc" id="aclassCGAL_1_1Min__sphere__of__points__d__traits__2_html"><div class="ttname"><a href="classCGAL_1_1Min__sphere__of__points__d__traits__2.html">CGAL::Min_sphere_of_points_d_traits_2</a></div><div class="ttdoc">The class Min_sphere_of_points_d_traits_2&lt;K,FT,UseSqrt,Algorithm&gt; is a model for concept MinSphereOfS...</div><div class="ttdef"><b>Definition:</b> Min_sphere_of_points_d_traits_2.h:33</div></div>
<div class="ttc" id="aclassCGAL_1_1Min__sphere__of__spheres__d_html"><div class="ttname"><a href="classCGAL_1_1Min__sphere__of__spheres__d.html">CGAL::Min_sphere_of_spheres_d</a></div><div class="ttdoc">An object of the class Min_sphere_of_spheres_d is a data structure that represents the unique sphere ...</div><div class="ttdef"><b>Definition:</b> Min_sphere_of_spheres_d.h:102</div></div>
<div class="ttc" id="astructCGAL_1_1Simple__cartesian_html"><div class="ttname"><a href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian</a></div></div>
</div><!-- fragment --> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Min_circle_2_2min_circle_homogeneous_2_8cpp-example.html#_a3">Min_circle_2/min_circle_homogeneous_2.cpp</a>.</dd>
</dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a693dca04f21bc2c897f489f085a0fbff"><td class="memItemLeft" align="right" valign="top">std::ostream &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Min__circle__2.html#a693dca04f21bc2c897f489f085a0fbff">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classCGAL_1_1Min__circle__2.html">Min_circle_2</a>&lt; Traits &gt; &amp;min_circle)</td></tr>
<tr class="memdesc:a693dca04f21bc2c897f489f085a0fbff"><td class="mdescLeft"> </td><td class="mdescRight">writes <code>min_circle</code> to output stream <code>os</code>.  <br></td></tr>
<tr class="separator:a693dca04f21bc2c897f489f085a0fbff"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8c0e384847bfe95d8f8dc7c5291547c6"><td class="memItemLeft" align="right" valign="top">std::istream &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Min__circle__2.html#a8c0e384847bfe95d8f8dc7c5291547c6">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classCGAL_1_1Min__circle__2.html">Min_circle_2</a>&lt; Traits &gt; min_circle &amp;)</td></tr>
<tr class="memdesc:a8c0e384847bfe95d8f8dc7c5291547c6"><td class="mdescLeft"> </td><td class="mdescRight">reads <code>min_circle</code> from input stream <code>is</code>.  <br></td></tr>
<tr class="separator:a8c0e384847bfe95d8f8dc7c5291547c6"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Types</h2></td></tr>
<tr class="memitem:acaff2d7da19f3c8ca5bf8845253f6039"><td class="memItemLeft" align="right" valign="top"><a id="acaff2d7da19f3c8ca5bf8845253f6039" name="acaff2d7da19f3c8ca5bf8845253f6039"></a>
typedef <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> </td><td class="memItemRight" valign="bottom"><b>Point</b></td></tr>
<tr class="memdesc:acaff2d7da19f3c8ca5bf8845253f6039"><td class="mdescLeft"> </td><td class="mdescRight">typedef to <code>Traits::Point</code>. <br></td></tr>
<tr class="separator:acaff2d7da19f3c8ca5bf8845253f6039"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a48aea3450e5b91924646e784481ff44d"><td class="memItemLeft" align="right" valign="top"><a id="a48aea3450e5b91924646e784481ff44d" name="a48aea3450e5b91924646e784481ff44d"></a>
typedef <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> </td><td class="memItemRight" valign="bottom"><b>Circle</b></td></tr>
<tr class="memdesc:a48aea3450e5b91924646e784481ff44d"><td class="mdescLeft"> </td><td class="mdescRight">typedef to <code>Traits::Circle</code>. <br></td></tr>
<tr class="separator:a48aea3450e5b91924646e784481ff44d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a716c27257a327f9eb570de854ccb57f4"><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Min__circle__2.html#a716c27257a327f9eb570de854ccb57f4">Point_iterator</a></td></tr>
<tr class="memdesc:a716c27257a327f9eb570de854ccb57f4"><td class="mdescLeft"> </td><td class="mdescRight">non-mutable model of the STL concept <em><a class="elRef" href="../Manual/classBidirectionalIterator.html">BidirectionalIterator</a></em> with value type <code>Point</code>.  <br></td></tr>
<tr class="separator:a716c27257a327f9eb570de854ccb57f4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a694816c6d92ee807ea6a3daba1a8f421"><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Min__circle__2.html#a694816c6d92ee807ea6a3daba1a8f421">Support_point_iterator</a></td></tr>
<tr class="memdesc:a694816c6d92ee807ea6a3daba1a8f421"><td class="mdescLeft"> </td><td class="mdescRight">non-mutable model of the STL concept <em><a class="elRef" href="../Manual/classRandomAccessIterator.html">RandomAccessIterator</a></em> with value type <code>Point</code>.  <br></td></tr>
<tr class="separator:a694816c6d92ee807ea6a3daba1a8f421"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Creation</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>A <code><a class="el" href="classCGAL_1_1Min__circle__2.html" title="An object of the class Min_circle_2 is the unique circle of smallest area enclosing a finite (multi)s...">Min_circle_2</a></code> object can be created from an arbitrary point set \( P\) and by specialized construction methods expecting no, one, two or three points as arguments.</p>
<p>The latter methods can be useful for reconstructing \( mc(P)\) from a given support set \( S\) of \( P\). </p>
</td></tr>
<tr class="memitem:a14b72d0065ac73ade159c3ab25855917"><td class="memTemplParams" colspan="2">template&lt;class <a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> &gt; </td></tr>
<tr class="memitem:a14b72d0065ac73ade159c3ab25855917"><td class="memTemplItemLeft" align="right" valign="top"> </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Min__circle__2.html#a14b72d0065ac73ade159c3ab25855917">Min_circle_2</a> (<a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> first, <a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> last, bool randomize, Random &amp;random=CGAL::get_default_random(), const Traits &amp;<a class="el" href="classCGAL_1_1Min__circle__2.html#a6c918bb03abf62031574a645746086ef">traits</a>=Traits())</td></tr>
<tr class="memdesc:a14b72d0065ac73ade159c3ab25855917"><td class="mdescLeft"> </td><td class="mdescRight">initializes <code>min_circle</code> to \( mc(P)\) with \( P\) being the set of points in the range [<code>first</code>,<code>last</code>).  <br></td></tr>
<tr class="separator:a14b72d0065ac73ade159c3ab25855917"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aebee8cf6b4ef8484b0a12f39332bc539"><td class="memItemLeft" align="right" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Min__circle__2.html#aebee8cf6b4ef8484b0a12f39332bc539">Min_circle_2</a> (const Traits &amp;<a class="el" href="classCGAL_1_1Min__circle__2.html#a6c918bb03abf62031574a645746086ef">traits</a>=Traits())</td></tr>
<tr class="memdesc:aebee8cf6b4ef8484b0a12f39332bc539"><td class="mdescLeft"> </td><td class="mdescRight">initializes <code>min_circle</code> to \( mc(\emptyset)\), the empty set.  <br></td></tr>
<tr class="separator:aebee8cf6b4ef8484b0a12f39332bc539"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1725a75ed64d54ef41c7fe3eb59931a5"><td class="memItemLeft" align="right" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Min__circle__2.html#a1725a75ed64d54ef41c7fe3eb59931a5">Min_circle_2</a> (const <a class="el" href="classCGAL_1_1Min__circle__2.html#acaff2d7da19f3c8ca5bf8845253f6039">Point</a> &amp;p, const Traits &amp;<a class="el" href="classCGAL_1_1Min__circle__2.html#a6c918bb03abf62031574a645746086ef">traits</a>=Traits())</td></tr>
<tr class="memdesc:a1725a75ed64d54ef41c7fe3eb59931a5"><td class="mdescLeft"> </td><td class="mdescRight">initializes <code>min_circle</code> to \( mc(\{p\})\), the set \( \{p\}\).  <br></td></tr>
<tr class="separator:a1725a75ed64d54ef41c7fe3eb59931a5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa6e065ed602ef49dcbf064d749f7cd32"><td class="memItemLeft" align="right" valign="top"><a id="aa6e065ed602ef49dcbf064d749f7cd32" name="aa6e065ed602ef49dcbf064d749f7cd32"></a>
 </td><td class="memItemRight" valign="bottom"><b>Min_circle_2</b> (const <a class="el" href="classCGAL_1_1Min__circle__2.html#acaff2d7da19f3c8ca5bf8845253f6039">Point</a> &amp;p1, const <a class="el" href="classCGAL_1_1Min__circle__2.html#acaff2d7da19f3c8ca5bf8845253f6039">Point</a> &amp;p2, const Traits &amp;<a class="el" href="classCGAL_1_1Min__circle__2.html#a6c918bb03abf62031574a645746086ef">traits</a>=Traits())</td></tr>
<tr class="memdesc:aa6e065ed602ef49dcbf064d749f7cd32"><td class="mdescLeft"> </td><td class="mdescRight">initializes <code>min_circle</code> to \( mc(\{p1,p2\})\), the circle with diameter equal to the segment connecting \( p1\) and \( p2\). <br></td></tr>
<tr class="separator:aa6e065ed602ef49dcbf064d749f7cd32"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab68687584c9a3593e2316a26acc57ca5"><td class="memItemLeft" align="right" valign="top"><a id="ab68687584c9a3593e2316a26acc57ca5" name="ab68687584c9a3593e2316a26acc57ca5"></a>
 </td><td class="memItemRight" valign="bottom"><b>Min_circle_2</b> (const <a class="el" href="classCGAL_1_1Min__circle__2.html#acaff2d7da19f3c8ca5bf8845253f6039">Point</a> &amp;p1, const <a class="el" href="classCGAL_1_1Min__circle__2.html#acaff2d7da19f3c8ca5bf8845253f6039">Point</a> &amp;p2, const <a class="el" href="classCGAL_1_1Min__circle__2.html#acaff2d7da19f3c8ca5bf8845253f6039">Point</a> &amp;p3, const Traits &amp;<a class="el" href="classCGAL_1_1Min__circle__2.html#a6c918bb03abf62031574a645746086ef">traits</a>=Traits())</td></tr>
<tr class="memdesc:ab68687584c9a3593e2316a26acc57ca5"><td class="mdescLeft"> </td><td class="mdescRight">initializes <code>min_circle</code> to \( mc(\{p1,p2,p3\})\). <br></td></tr>
<tr class="separator:ab68687584c9a3593e2316a26acc57ca5"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Access Functions</h2></td></tr>
<tr class="memitem:ae833665313f26e701bae246cc6dea68a"><td class="memItemLeft" align="right" valign="top"><a id="ae833665313f26e701bae246cc6dea68a" name="ae833665313f26e701bae246cc6dea68a"></a>
int </td><td class="memItemRight" valign="bottom"><b>number_of_points</b> () const</td></tr>
<tr class="memdesc:ae833665313f26e701bae246cc6dea68a"><td class="mdescLeft"> </td><td class="mdescRight">returns the number of points of <code>min_circle</code>, i.e. \( |P|\). <br></td></tr>
<tr class="separator:ae833665313f26e701bae246cc6dea68a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac87c3d760053509a41be898771111854"><td class="memItemLeft" align="right" valign="top"><a id="ac87c3d760053509a41be898771111854" name="ac87c3d760053509a41be898771111854"></a>
int </td><td class="memItemRight" valign="bottom"><b>number_of_support_points</b> () const</td></tr>
<tr class="memdesc:ac87c3d760053509a41be898771111854"><td class="mdescLeft"> </td><td class="mdescRight">returns the number of support points of <code>min_circle</code>, i.e. \( |S|\). <br></td></tr>
<tr class="separator:ac87c3d760053509a41be898771111854"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ade14badb14c8b404d099f637ff53be87"><td class="memItemLeft" align="right" valign="top"><a id="ade14badb14c8b404d099f637ff53be87" name="ade14badb14c8b404d099f637ff53be87"></a>
<a class="el" href="classCGAL_1_1Min__circle__2.html#a716c27257a327f9eb570de854ccb57f4">Point_iterator</a> </td><td class="memItemRight" valign="bottom"><b>points_begin</b> () const</td></tr>
<tr class="memdesc:ade14badb14c8b404d099f637ff53be87"><td class="mdescLeft"> </td><td class="mdescRight">returns an iterator referring to the first point of <code>min_circle</code>. <br></td></tr>
<tr class="separator:ade14badb14c8b404d099f637ff53be87"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa98f7f868d6c7cacd137bb18cc4ec527"><td class="memItemLeft" align="right" valign="top"><a id="aa98f7f868d6c7cacd137bb18cc4ec527" name="aa98f7f868d6c7cacd137bb18cc4ec527"></a>
<a class="el" href="classCGAL_1_1Min__circle__2.html#a716c27257a327f9eb570de854ccb57f4">Point_iterator</a> </td><td class="memItemRight" valign="bottom"><b>points_end</b> () const</td></tr>
<tr class="memdesc:aa98f7f868d6c7cacd137bb18cc4ec527"><td class="mdescLeft"> </td><td class="mdescRight">returns the corresponding past-the-end iterator. <br></td></tr>
<tr class="separator:aa98f7f868d6c7cacd137bb18cc4ec527"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:acb33d435a72cfcda800b739ba172082d"><td class="memItemLeft" align="right" valign="top"><a id="acb33d435a72cfcda800b739ba172082d" name="acb33d435a72cfcda800b739ba172082d"></a>
<a class="el" href="classCGAL_1_1Min__circle__2.html#a694816c6d92ee807ea6a3daba1a8f421">Support_point_iterator</a> </td><td class="memItemRight" valign="bottom"><b>support_points_begin</b> () const</td></tr>
<tr class="memdesc:acb33d435a72cfcda800b739ba172082d"><td class="mdescLeft"> </td><td class="mdescRight">returns an iterator referring to the first support point of <code>min_circle</code>. <br></td></tr>
<tr class="separator:acb33d435a72cfcda800b739ba172082d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af808f54e70621f0fe201c4b327b5de3b"><td class="memItemLeft" align="right" valign="top"><a id="af808f54e70621f0fe201c4b327b5de3b" name="af808f54e70621f0fe201c4b327b5de3b"></a>
<a class="el" href="classCGAL_1_1Min__circle__2.html#a694816c6d92ee807ea6a3daba1a8f421">Support_point_iterator</a> </td><td class="memItemRight" valign="bottom"><b>support_points_end</b> () const</td></tr>
<tr class="memdesc:af808f54e70621f0fe201c4b327b5de3b"><td class="mdescLeft"> </td><td class="mdescRight">returns the corresponding past-the-end iterator. <br></td></tr>
<tr class="separator:af808f54e70621f0fe201c4b327b5de3b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5e52a11bc13981434a9b0e7c5dc6a1c8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classCGAL_1_1Min__circle__2.html#acaff2d7da19f3c8ca5bf8845253f6039">Point</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Min__circle__2.html#a5e52a11bc13981434a9b0e7c5dc6a1c8">support_point</a> (int i) const</td></tr>
<tr class="memdesc:a5e52a11bc13981434a9b0e7c5dc6a1c8"><td class="mdescLeft"> </td><td class="mdescRight">returns the <code>i</code>-th support point of <code>min_circle</code>.  <br></td></tr>
<tr class="separator:a5e52a11bc13981434a9b0e7c5dc6a1c8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a746c29e29f7288b9a3a2741c9a207c11"><td class="memItemLeft" align="right" valign="top"><a id="a746c29e29f7288b9a3a2741c9a207c11" name="a746c29e29f7288b9a3a2741c9a207c11"></a>
const <a class="el" href="classCGAL_1_1Min__circle__2.html#a48aea3450e5b91924646e784481ff44d">Circle</a> &amp; </td><td class="memItemRight" valign="bottom"><b>circle</b> () const</td></tr>
<tr class="memdesc:a746c29e29f7288b9a3a2741c9a207c11"><td class="mdescLeft"> </td><td class="mdescRight">returns the current circle of <code>min_circle</code>. <br></td></tr>
<tr class="separator:a746c29e29f7288b9a3a2741c9a207c11"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Predicates</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>By definition, an empty <code><a class="el" href="classCGAL_1_1Min__circle__2.html" title="An object of the class Min_circle_2 is the unique circle of smallest area enclosing a finite (multi)s...">Min_circle_2</a></code> has no boundary and no bounded side, i.e. its unbounded side equals the whole space \(
\E^2\). </p>
</td></tr>
<tr class="memitem:a5e222fd1ba182d24bd6c10e0d31b2c75"><td class="memItemLeft" align="right" valign="top"><a id="a5e222fd1ba182d24bd6c10e0d31b2c75" name="a5e222fd1ba182d24bd6c10e0d31b2c75"></a>
<a class="elRef" href="../Kernel_23/group__kernel__enums.html#gaf6030e89dadcc1f45369b0cdc5d9e111">CGAL::Bounded_side</a> </td><td class="memItemRight" valign="bottom"><b>bounded_side</b> (const <a class="el" href="classCGAL_1_1Min__circle__2.html#acaff2d7da19f3c8ca5bf8845253f6039">Point</a> &amp;p) const</td></tr>
<tr class="memdesc:a5e222fd1ba182d24bd6c10e0d31b2c75"><td class="mdescLeft"> </td><td class="mdescRight">returns <code><a class="elRef" href="../Kernel_23/group__kernel__enums.html#ggaf6030e89dadcc1f45369b0cdc5d9e111ad8333d35d4801c08b3a5ae9e94d7cabe">CGAL::ON_BOUNDED_SIDE</a></code>, <code><a class="elRef" href="../Kernel_23/group__kernel__enums.html#ggaf6030e89dadcc1f45369b0cdc5d9e111a060193157c0875fb2e6445a648f3ac1f">CGAL::ON_BOUNDARY</a></code>, or <code><a class="elRef" href="../Kernel_23/group__kernel__enums.html#ggaf6030e89dadcc1f45369b0cdc5d9e111a3a96e6da84164cc8300c9e130be23f71">CGAL::ON_UNBOUNDED_SIDE</a></code> iff <code>p</code> lies properly inside, on the boundary of, or properly outside of <code>min_circle</code>, resp. <br></td></tr>
<tr class="separator:a5e222fd1ba182d24bd6c10e0d31b2c75"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac3c6dadb9c3289c43396f8a439c6257f"><td class="memItemLeft" align="right" valign="top"><a id="ac3c6dadb9c3289c43396f8a439c6257f" name="ac3c6dadb9c3289c43396f8a439c6257f"></a>
bool </td><td class="memItemRight" valign="bottom"><b>has_on_bounded_side</b> (const <a class="el" href="classCGAL_1_1Min__circle__2.html#acaff2d7da19f3c8ca5bf8845253f6039">Point</a> &amp;p) const</td></tr>
<tr class="memdesc:ac3c6dadb9c3289c43396f8a439c6257f"><td class="mdescLeft"> </td><td class="mdescRight">returns <code>true</code>, iff <code>p</code> lies properly inside <code>min_circle</code>. <br></td></tr>
<tr class="separator:ac3c6dadb9c3289c43396f8a439c6257f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a649ea54cd5c4d679eecabe3f2e7d29b2"><td class="memItemLeft" align="right" valign="top"><a id="a649ea54cd5c4d679eecabe3f2e7d29b2" name="a649ea54cd5c4d679eecabe3f2e7d29b2"></a>
bool </td><td class="memItemRight" valign="bottom"><b>has_on_boundary</b> (const <a class="el" href="classCGAL_1_1Min__circle__2.html#acaff2d7da19f3c8ca5bf8845253f6039">Point</a> &amp;p) const</td></tr>
<tr class="memdesc:a649ea54cd5c4d679eecabe3f2e7d29b2"><td class="mdescLeft"> </td><td class="mdescRight">returns <code>true</code>, iff <code>p</code> lies on the boundary of <code>min_circle</code>. <br></td></tr>
<tr class="separator:a649ea54cd5c4d679eecabe3f2e7d29b2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2fc4e34c6e70fffc3489f113c9ccc29c"><td class="memItemLeft" align="right" valign="top"><a id="a2fc4e34c6e70fffc3489f113c9ccc29c" name="a2fc4e34c6e70fffc3489f113c9ccc29c"></a>
bool </td><td class="memItemRight" valign="bottom"><b>has_on_unbounded_side</b> (const <a class="el" href="classCGAL_1_1Min__circle__2.html#acaff2d7da19f3c8ca5bf8845253f6039">Point</a> &amp;p) const</td></tr>
<tr class="memdesc:a2fc4e34c6e70fffc3489f113c9ccc29c"><td class="mdescLeft"> </td><td class="mdescRight">returns <code>true</code>, iff <code>p</code> lies properly outside of <code>min_circle</code>. <br></td></tr>
<tr class="separator:a2fc4e34c6e70fffc3489f113c9ccc29c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6138cc0e8a507e8298a00d8070e2338f"><td class="memItemLeft" align="right" valign="top"><a id="a6138cc0e8a507e8298a00d8070e2338f" name="a6138cc0e8a507e8298a00d8070e2338f"></a>
bool </td><td class="memItemRight" valign="bottom"><b>is_empty</b> () const</td></tr>
<tr class="memdesc:a6138cc0e8a507e8298a00d8070e2338f"><td class="mdescLeft"> </td><td class="mdescRight">returns <code>true</code>, iff <code>min_circle</code> is empty (this implies degeneracy). <br></td></tr>
<tr class="separator:a6138cc0e8a507e8298a00d8070e2338f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7340949b73e772788fab0a5ed2a7e005"><td class="memItemLeft" align="right" valign="top"><a id="a7340949b73e772788fab0a5ed2a7e005" name="a7340949b73e772788fab0a5ed2a7e005"></a>
bool </td><td class="memItemRight" valign="bottom"><b>is_degenerate</b> () const</td></tr>
<tr class="memdesc:a7340949b73e772788fab0a5ed2a7e005"><td class="mdescLeft"> </td><td class="mdescRight">returns <code>true</code>, iff <code>min_circle</code> is degenerate, i.e. if <code>min_circle</code> is empty or equal to a single point, equivalently if the number of support points is less than 2. <br></td></tr>
<tr class="separator:a7340949b73e772788fab0a5ed2a7e005"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Modifiers</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>New points can be added to an existing <code>min_circle</code>, allowing to build \( mc(P)\) incrementally, e.g.</p>
<p>if \( P\) is not known in advance. Compared to the direct creation of \( mc(P)\), this is not much slower, because the construction method is incremental itself. </p>
</td></tr>
<tr class="memitem:a36fb0e4da0884d5c184f9d506c93fbd3"><td class="memItemLeft" align="right" valign="top"><a id="a36fb0e4da0884d5c184f9d506c93fbd3" name="a36fb0e4da0884d5c184f9d506c93fbd3"></a>
void </td><td class="memItemRight" valign="bottom"><b>insert</b> (const <a class="el" href="classCGAL_1_1Min__circle__2.html#acaff2d7da19f3c8ca5bf8845253f6039">Point</a> &amp;p)</td></tr>
<tr class="memdesc:a36fb0e4da0884d5c184f9d506c93fbd3"><td class="mdescLeft"> </td><td class="mdescRight">inserts <code>p</code> into <code>min_circle</code> and recomputes the smallest enclosing circle. <br></td></tr>
<tr class="separator:a36fb0e4da0884d5c184f9d506c93fbd3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a063d28d21dc5a4a222c9fe201eb168cd"><td class="memTemplParams" colspan="2">template&lt;class <a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> &gt; </td></tr>
<tr class="memitem:a063d28d21dc5a4a222c9fe201eb168cd"><td class="memTemplItemLeft" align="right" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Min__circle__2.html#a063d28d21dc5a4a222c9fe201eb168cd">insert</a> (<a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> first, <a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> last)</td></tr>
<tr class="memdesc:a063d28d21dc5a4a222c9fe201eb168cd"><td class="mdescLeft"> </td><td class="mdescRight">inserts the points in the range [<code>first</code>,<code>last</code>) into <code>min_circle</code> and recomputes the smallest enclosing circle by calling <code>insert(p)</code> for each point <code>p</code> in [<code>first</code>,<code>last</code>).  <br></td></tr>
<tr class="separator:a063d28d21dc5a4a222c9fe201eb168cd"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3dd9c86b2ca28f8bd7d9274091d726eb"><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Min__circle__2.html#a3dd9c86b2ca28f8bd7d9274091d726eb">clear</a> ()</td></tr>
<tr class="memdesc:a3dd9c86b2ca28f8bd7d9274091d726eb"><td class="mdescLeft"> </td><td class="mdescRight">deletes all points in <code>min_circle</code> and sets <code>min_circle</code> to the empty set.  <br></td></tr>
<tr class="separator:a3dd9c86b2ca28f8bd7d9274091d726eb"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Validity Check</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>An object <code>min_circle</code> is valid, iff</p>
<ul>
<li>
<code>min_circle</code> contains all points of its defining set \( P\), </li>
<li>
<code>min_circle</code> is the smallest circle spanned by its support set \( S\), and </li>
<li>
\( S\) is minimal, i.e. no support point is redundant. </li>
</ul>
</td></tr>
<tr class="memitem:af773edd312c5194118bf2842ecda170a"><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Min__circle__2.html#af773edd312c5194118bf2842ecda170a">is_valid</a> (bool verbose=false, int level=0) const</td></tr>
<tr class="memdesc:af773edd312c5194118bf2842ecda170a"><td class="mdescLeft"> </td><td class="mdescRight">returns <code>true</code>, iff <code>min_circle</code> is valid.  <br></td></tr>
<tr class="separator:af773edd312c5194118bf2842ecda170a"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Miscellaneous</h2></td></tr>
<tr class="memitem:a6c918bb03abf62031574a645746086ef"><td class="memItemLeft" align="right" valign="top"><a id="a6c918bb03abf62031574a645746086ef" name="a6c918bb03abf62031574a645746086ef"></a>
const Traits &amp; </td><td class="memItemRight" valign="bottom"><b>traits</b> () const</td></tr>
<tr class="memdesc:a6c918bb03abf62031574a645746086ef"><td class="mdescLeft"> </td><td class="mdescRight">returns a const reference to the traits class object. <br></td></tr>
<tr class="separator:a6c918bb03abf62031574a645746086ef"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a716c27257a327f9eb570de854ccb57f4" name="a716c27257a327f9eb570de854ccb57f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a716c27257a327f9eb570de854ccb57f4">◆ </a></span>Point_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> <a class="el" href="classCGAL_1_1Min__circle__2.html">CGAL::Min_circle_2</a>&lt; Traits &gt;::Point_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>non-mutable model of the STL concept <em><a class="elRef" href="../Manual/classBidirectionalIterator.html">BidirectionalIterator</a></em> with value type <code>Point</code>. </p>
<p>Used to access the points of the smallest enclosing circle. </p>

</div>
</div>
<a id="a694816c6d92ee807ea6a3daba1a8f421" name="a694816c6d92ee807ea6a3daba1a8f421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a694816c6d92ee807ea6a3daba1a8f421">◆ </a></span>Support_point_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> <a class="el" href="classCGAL_1_1Min__circle__2.html">CGAL::Min_circle_2</a>&lt; Traits &gt;::Support_point_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>non-mutable model of the STL concept <em><a class="elRef" href="../Manual/classRandomAccessIterator.html">RandomAccessIterator</a></em> with value type <code>Point</code>. </p>
<p>Used to access the support points of the smallest enclosing circle. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a14b72d0065ac73ade159c3ab25855917" name="a14b72d0065ac73ade159c3ab25855917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14b72d0065ac73ade159c3ab25855917">◆ </a></span>Min_circle_2() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<div class="memtemplate">
template&lt;class <a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Min__circle__2.html">CGAL::Min_circle_2</a>&lt; Traits &gt;::Min_circle_2 </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> </td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> </td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>randomize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Random &amp; </td>
          <td class="paramname"><em>random</em> = <code>CGAL::get_default_random()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Traits &amp; </td>
          <td class="paramname"><em>traits</em> = <code>Traits()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>initializes <code>min_circle</code> to \( mc(P)\) with \( P\) being the set of points in the range [<code>first</code>,<code>last</code>). </p>
<p>If <code>randomize</code> is <code>true</code>, a random permutation of \( P\) is computed in advance, using the random numbers generator <code>random</code>. Usually, this will not be necessary, however, the algorithm's efficiency depends on the order in which the points are processed, and a bad order might lead to extremely poor performance (see example below). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a></td><td>must be a model of <code><a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a></code> with <code>Point</code> as value type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebee8cf6b4ef8484b0a12f39332bc539" name="aebee8cf6b4ef8484b0a12f39332bc539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebee8cf6b4ef8484b0a12f39332bc539">◆ </a></span>Min_circle_2() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Min__circle__2.html">CGAL::Min_circle_2</a>&lt; Traits &gt;::Min_circle_2 </td>
          <td>(</td>
          <td class="paramtype">const Traits &amp; </td>
          <td class="paramname"><em>traits</em> = <code>Traits()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>initializes <code>min_circle</code> to \( mc(\emptyset)\), the empty set. </p>
<dl class="section post"><dt>Postcondition</dt><dd><code>min_circle.is_empty()</code> = <code>true</code>. </dd></dl>

</div>
</div>
<a id="a1725a75ed64d54ef41c7fe3eb59931a5" name="a1725a75ed64d54ef41c7fe3eb59931a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1725a75ed64d54ef41c7fe3eb59931a5">◆ </a></span>Min_circle_2() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Min__circle__2.html">CGAL::Min_circle_2</a>&lt; Traits &gt;::Min_circle_2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Min__circle__2.html#acaff2d7da19f3c8ca5bf8845253f6039">Point</a> &amp; </td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Traits &amp; </td>
          <td class="paramname"><em>traits</em> = <code>Traits()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>initializes <code>min_circle</code> to \( mc(\{p\})\), the set \( \{p\}\). </p>
<dl class="section post"><dt>Postcondition</dt><dd><code>min_circle.is_degenerate()</code> = <code>true</code>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3dd9c86b2ca28f8bd7d9274091d726eb" name="a3dd9c86b2ca28f8bd7d9274091d726eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd9c86b2ca28f8bd7d9274091d726eb">◆ </a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCGAL_1_1Min__circle__2.html">CGAL::Min_circle_2</a>&lt; Traits &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>deletes all points in <code>min_circle</code> and sets <code>min_circle</code> to the empty set. </p>
<dl class="section post"><dt>Postcondition</dt><dd><code>min_circle.is_empty()</code> = <code>true</code>. </dd></dl>

</div>
</div>
<a id="a063d28d21dc5a4a222c9fe201eb168cd" name="a063d28d21dc5a4a222c9fe201eb168cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a063d28d21dc5a4a222c9fe201eb168cd">◆ </a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<div class="memtemplate">
template&lt;class <a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCGAL_1_1Min__circle__2.html">CGAL::Min_circle_2</a>&lt; Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> </td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> </td>
          <td class="paramname"><em>last</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>inserts the points in the range [<code>first</code>,<code>last</code>) into <code>min_circle</code> and recomputes the smallest enclosing circle by calling <code>insert(p)</code> for each point <code>p</code> in [<code>first</code>,<code>last</code>). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a></td><td>must be a model of <code><a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a></code> with <code>Point</code> as value type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af773edd312c5194118bf2842ecda170a" name="af773edd312c5194118bf2842ecda170a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af773edd312c5194118bf2842ecda170a">◆ </a></span>is_valid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Min__circle__2.html">CGAL::Min_circle_2</a>&lt; Traits &gt;::is_valid </td>
          <td>(</td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>verbose</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>level</em> = <code>0</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns <code>true</code>, iff <code>min_circle</code> is valid. </p>
<p>If <code>verbose</code> is <code>true</code>, some messages concerning the performed checks are written to standard error stream. The second parameter <code>level</code> is not used, we provide it only for consistency with interfaces of other classes. </p>

</div>
</div>
<a id="a5e52a11bc13981434a9b0e7c5dc6a1c8" name="a5e52a11bc13981434a9b0e7c5dc6a1c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e52a11bc13981434a9b0e7c5dc6a1c8">◆ </a></span>support_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classCGAL_1_1Min__circle__2.html#acaff2d7da19f3c8ca5bf8845253f6039">Point</a> &amp; <a class="el" href="classCGAL_1_1Min__circle__2.html">CGAL::Min_circle_2</a>&lt; Traits &gt;::support_point </td>
          <td>(</td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the <code>i</code>-th support point of <code>min_circle</code>. </p>
<p>Between two modifying operations (see below) any call to <code>min_circle.support_point(i)</code> with the same <code>i</code> returns the same point. </p><dl class="section pre"><dt>Precondition</dt><dd>\( 0 \leq i&lt; \) <code>min_circle.number_of_support_points()</code>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a693dca04f21bc2c897f489f085a0fbff" name="a693dca04f21bc2c897f489f085a0fbff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a693dca04f21bc2c897f489f085a0fbff">◆ </a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp; </td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Min__circle__2.html">Min_circle_2</a>&lt; Traits &gt; &amp; </td>
          <td class="paramname"><em>min_circle</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>writes <code>min_circle</code> to output stream <code>os</code>. </p>
<p>An overload of <code>operator&lt;&lt;</code> must be defined for <code>Point</code> (and for <code><a class="el" href="classCircle.html" title="An object circle of the class Circle is a circle in the two-dimensional Euclidean plane ....">Circle</a></code>, if pretty printing is used). </p>

</div>
</div>
<a id="a8c0e384847bfe95d8f8dc7c5291547c6" name="a8c0e384847bfe95d8f8dc7c5291547c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c0e384847bfe95d8f8dc7c5291547c6">◆ </a></span>operator&gt;&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp; </td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Min__circle__2.html">Min_circle_2</a>&lt; Traits &gt; min_circle &amp; </td>
          <td class="paramname"> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reads <code>min_circle</code> from input stream <code>is</code>. </p>
<p>An overload of <code>operator&gt;&gt;</code> must be defined for <code>Point</code>. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>CGAL</b></li><li class="navelem"><a class="el" href="classCGAL_1_1Min__circle__2.html">Min_circle_2</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"></a> 1.9.6 </li>
  </ul>
</div>
</div>
</body>



</html>
