<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="https://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Kinetic_shape_reconstruction/Kinetic_shape_reconstruction_2kinetic_random_shapes_8cpp-example.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=9">
<meta name="generator" content="Doxygen 1.8.13">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CGAL 5.6 - Kinetic Shape Reconstruction: Kinetic_shape_reconstruction/kinetic_random_shapes.cpp</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css">
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      }
  }
}
);
//]]>
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="">
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt=""></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.6 - Kinetic Shape Reconstruction
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('Kinetic_shape_reconstruction_2kinetic_random_shapes_8cpp-example.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Kinetic_shape_reconstruction/kinetic_random_shapes.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;random&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/random_convex_set_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_with_holes_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Boolean_set_operations_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Kinetic_shape_partitioning_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Kinetic_shape_partitioning_Traits.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_2_algorithms.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/point_generators_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> EPECK = <a name="_a0"></a><a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">CGAL::Exact_predicates_exact_constructions_kernel</a>;</div><div class="line"><span class="keyword">using</span> EPICK = <a name="_a1"></a><a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>  = EPECK;</div><div class="line"><span class="keyword">using</span> FT      = <span class="keyword">typename</span> <a name="a2"></a><a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"><span class="keyword">using</span> Point_2 = <span class="keyword">typename</span> <a name="a3"></a><a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>;</div><div class="line"><span class="keyword">using</span> Point_3 = <span class="keyword">typename</span> <a name="a4"></a><a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ae82b7f4be77dd5b8819ebe419e4ae753">Kernel::Point_3</a>;</div><div class="line"><span class="keyword">using</span> Plane_3 = <span class="keyword">typename</span> <a name="a5"></a><a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ac027cb2dbfb711e19826dc83b957033f">Kernel::Plane_3</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Polygon_2            = CGAL::Polygon_2&lt;Kernel&gt;;</div><div class="line"><span class="keyword">using</span> Polygon_with_holes_2 = CGAL::Polygon_with_holes_2&lt;Kernel&gt;;</div><div class="line"><span class="keyword">using</span> Polygon_3            = std::vector&lt;Point_3&gt;;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Uniform_creator = CGAL::Creator_uniform_2&lt;double, Point_2&gt;;</div><div class="line"><span class="keyword">using</span> Point_generator = CGAL::Random_points_in_square_2&lt;Point_2, Uniform_creator&gt;;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Saver = CGAL::KSR_3::Saver&lt;Kernel&gt;;</div><div class="line"></div><div class="line"><span class="keyword">using</span> IFT      = <span class="keyword">typename</span> EPICK::FT;</div><div class="line"><span class="keyword">using</span> IPoint_3 = <span class="keyword">typename</span> EPICK::Point_3;</div><div class="line"></div><div class="line"><span class="keyword">using</span> IPolygon_3     = std::vector&lt;IPoint_3&gt;;</div><div class="line"><span class="keyword">using</span> IPolygon_3_map = CGAL::Identity_property_map&lt;IPolygon_3&gt;;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Traits = <span class="keyword">typename</span> CGAL::Kinetic_shape_partitioning_traits_3&lt;EPICK, EPECK, std::vector&lt;typename EPICK::Point_3&gt;, CGAL::Identity_property_map&lt;typename EPICK::Point_3&gt; &gt;;</div><div class="line"></div><div class="line"><span class="keyword">using</span> KSP = <a name="_a6"></a><a class="code" href="classCGAL_1_1Kinetic__shape__partitioning__3.html">CGAL::Kinetic_shape_partitioning_3&lt;Traits&gt;</a>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> std::vector&lt;int&gt; box_vertices_to_faces(<span class="keyword">const</span> <span class="keywordtype">int</span> i) {</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> _vertices_to_faces[8][3] = {</div><div class="line">    {0, 2, 4}, {1, 2, 4},</div><div class="line">    {0, 3, 4}, {1, 3, 4},</div><div class="line">    {0, 2, 5}, {1, 2, 5},</div><div class="line">    {0, 3, 5}, {1, 3, 5}</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;int&gt; faces = {</div><div class="line">    _vertices_to_faces[i][0],</div><div class="line">    _vertices_to_faces[i][1],</div><div class="line">    _vertices_to_faces[i][2]</div><div class="line">  };</div><div class="line">  <span class="keywordflow">return</span> faces;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">const</span> std::vector&lt;int&gt; box_edges_to_faces(<span class="keyword">const</span> <span class="keywordtype">int</span> i) {</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> _faces[12][2] = {</div><div class="line">    {0, 4}, {1, 4}, {0, 5},</div><div class="line">    {1, 5}, {2, 4}, {3, 4},</div><div class="line">    {2, 5}, {3, 5}, {0, 2},</div><div class="line">    {0, 3}, {1, 2}, {1, 3}</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;int&gt; faces = {</div><div class="line">    _faces[i][0], _faces[i][1]</div><div class="line">  };</div><div class="line">  <span class="keywordflow">return</span> faces;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">const</span> std::vector&lt;int&gt; box_faces_to_vertices(<span class="keyword">const</span> <span class="keywordtype">int</span> i) {</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> _vertices[6][4] = {</div><div class="line">    {0, 4, 6, 2}, {1, 5, 7, 3},</div><div class="line">    {1, 5, 4, 0}, {3, 7, 6, 2},</div><div class="line">    {1, 0, 2, 3}, {5, 4, 6, 7}</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;int&gt; vertices = {</div><div class="line">    _vertices[i][0], _vertices[i][1],</div><div class="line">    _vertices[i][2], _vertices[i][3]</div><div class="line">  };</div><div class="line">  <span class="keywordflow">return</span> vertices;</div><div class="line">}</div><div class="line"></div><div class="line">std::vector&lt;int&gt; box_faces_to_edges(<span class="keyword">const</span> <span class="keywordtype">int</span> i) {</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> _edges[6][4] = {</div><div class="line">    { 0, 8, 2, 9},  { 1, 10, 3, 11},</div><div class="line">    {10, 6, 8, 4},  {11,  7, 9,  5},</div><div class="line">    { 4, 0, 5, 1},  { 6,  2, 7,  3}</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;int&gt; edges = {</div><div class="line">    _edges[i][0], _edges[i][1], _edges[i][2], _edges[i][3]</div><div class="line">  };</div><div class="line">  <span class="keywordflow">return</span> edges;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> find_next_object_colliding_plane(</div><div class="line">  <span class="keyword">const</span> Point_3&amp; <span class="comment">/* pt_min */</span>, <span class="keyword">const</span> Point_3&amp; <span class="comment">/* pt_max */</span>,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;Point_3&gt;&amp; box_corners,</div><div class="line">  <span class="keyword">const</span> std::vector&lt; std::pair&lt;std::size_t, std::size_t&gt; &gt;&amp; box_edges,</div><div class="line">  <span class="keyword">const</span> Plane_3&amp; plane,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;int&gt;&amp; vertices,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;int&gt;&amp; edges,</div><div class="line">  <span class="keyword">const</span> std::pair&lt;bool, int&gt;&amp; prev_object,</div><div class="line">  std::pair&lt;bool, int&gt;&amp; next_object,</div><div class="line">  Point_3&amp; m) {</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; vertices.size(); ++i) {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> v_i = vertices[i];</div><div class="line">    <span class="keywordflow">if</span> ((prev_object.first &amp;&amp; prev_object.second != v_i) || (!prev_object.first)) {</div><div class="line">      <span class="keyword">const</span> Point_3&amp; v = box_corners[v_i];</div><div class="line">      <span class="keywordflow">if</span> (plane.a() * v.x() + plane.b() * v.y() + plane.c() * v.z() + plane.d() == FT(0)) {</div><div class="line">        next_object = std::make_pair(<span class="keyword">true</span>, v_i);</div><div class="line">        m = v;</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">      }</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; edges.size(); ++i) {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> e_i = edges[i];</div><div class="line">    <span class="keywordflow">if</span> (prev_object.first || (!prev_object.first &amp;&amp; prev_object.second != e_i)) {</div><div class="line">      <span class="keyword">const</span> Point_3&amp; s = box_corners[box_edges[e_i].first];</div><div class="line">      <span class="keyword">const</span> Point_3&amp; t = box_corners[box_edges[e_i].second];</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (</div><div class="line">        (plane.a() * s.x() + plane.b() * s.y() + plane.c() * s.z() + plane.d()) *</div><div class="line">        (plane.a() * t.x() + plane.b() * t.y() + plane.c() * t.z() + plane.d()) &lt; FT(0)) {</div><div class="line"></div><div class="line">        next_object = std::make_pair(<span class="keyword">false</span>, e_i);</div><div class="line"></div><div class="line">        FT x, y, z;</div><div class="line">        <span class="keywordflow">if</span> (e_i &lt;= 3) {</div><div class="line">          x = box_corners[box_edges[e_i].first].x(), z = box_corners[box_edges[e_i].first].z();</div><div class="line">          y = -(plane.a() * x + plane.c() * z + plane.d()) / plane.b();</div><div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (e_i &lt;= 7) {</div><div class="line">          y = box_corners[box_edges[e_i].first].y(), z = box_corners[box_edges[e_i].first].z();</div><div class="line">          x = -(plane.b() * y + plane.c() * z + plane.d()) / plane.a();</div><div class="line">        } <span class="keywordflow">else</span> {</div><div class="line">          x = box_corners[box_edges[e_i].first].x(), y = box_corners[box_edges[e_i].first].y();</div><div class="line">          z = -(plane.a() * x + plane.b() * y + plane.d()) / plane.c();</div><div class="line">        }</div><div class="line">        m = Point_3(x, y, z);</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">      }</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> find_next_object_colliding_plane(</div><div class="line">  <span class="keyword">const</span> Point_3&amp; pt_min, <span class="keyword">const</span> Point_3&amp; pt_max,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;Point_3&gt;&amp; box_corners,</div><div class="line">  <span class="keyword">const</span> std::vector&lt; std::pair&lt;std::size_t, std::size_t&gt; &gt;&amp; box_edges,</div><div class="line">  <span class="keyword">const</span> Plane_3&amp; plane,</div><div class="line">  std::pair&lt;bool, int&gt;&amp; next_object,</div><div class="line">  Point_3&amp; m) {</div><div class="line"></div><div class="line">  std::vector&lt;int&gt; vertices(8, -1), edges(12, -1);</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; vertices.size(); ++i) vertices[i] = <span class="keywordtype">int</span>(i);</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; edges.size(); ++i) edges[i] = <span class="keywordtype">int</span>(i);</div><div class="line">  std::pair&lt;bool, int&gt; prev_object(<span class="keyword">false</span>, -1);</div><div class="line">  find_next_object_colliding_plane(</div><div class="line">    pt_min, pt_max,</div><div class="line">    box_corners, box_edges,</div><div class="line">    plane, vertices, edges,</div><div class="line">    prev_object, next_object, m);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> construct_bounding_polygon_of_support_plane(</div><div class="line">  <span class="keyword">const</span> Point_3&amp; pt_min, <span class="keyword">const</span> Point_3&amp; pt_max,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;Point_3&gt;&amp; box_corners,</div><div class="line">  <span class="keyword">const</span> std::vector&lt; std::pair&lt;std::size_t, std::size_t&gt; &gt;&amp; box_edges,</div><div class="line">  <span class="keyword">const</span> Plane_3&amp; plane,</div><div class="line">  std::list&lt;Point_3&gt;&amp; bounding_polygon,</div><div class="line">  std::vector&lt; std::list&lt;int&gt; &gt;&amp; bounding_faces) {</div><div class="line"></div><div class="line">  bounding_polygon.clear();</div><div class="line">  bounding_faces.clear();</div><div class="line"></div><div class="line">  Point_3 m;</div><div class="line">  std::pair&lt;bool, int&gt; init_object(<span class="keyword">true</span>, -1), prev_object, curr_object;</div><div class="line">  find_next_object_colliding_plane(</div><div class="line">    pt_min, pt_max, box_corners, box_edges, plane, init_object, m);</div><div class="line">  bounding_polygon.push_back(m);</div><div class="line"></div><div class="line">  prev_object = init_object;</div><div class="line">  <span class="keywordtype">int</span> prev_face = -1;</div><div class="line"></div><div class="line">  <span class="keywordflow">do</span> {</div><div class="line">    std::vector&lt;int&gt; adjacent_faces;</div><div class="line">    <span class="keywordflow">if</span> (prev_object.first) {</div><div class="line">      adjacent_faces = box_vertices_to_faces(prev_object.second);</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">      adjacent_faces = box_edges_to_faces(prev_object.second);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> iteration_done = <span class="keyword">false</span>;</div><div class="line">    <span class="keywordtype">int</span> curr_face;</div><div class="line">    <span class="keywordflow">for</span> (std::size_t f = 0; f &lt; adjacent_faces.size(); ++f) {</div><div class="line">      curr_face = adjacent_faces[f];</div><div class="line">      <span class="keywordflow">if</span> (curr_face == prev_face) <span class="keywordflow">continue</span>;</div><div class="line"></div><div class="line">      <span class="keyword">auto</span> vertices = box_faces_to_vertices(curr_face);</div><div class="line">      <span class="keyword">auto</span> edges    = box_faces_to_edges(curr_face);</div><div class="line"></div><div class="line">      iteration_done = find_next_object_colliding_plane(</div><div class="line">        pt_min, pt_max,</div><div class="line">        box_corners, box_edges,</div><div class="line">        plane, vertices, edges,</div><div class="line">        prev_object, curr_object, m);</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (iteration_done) {</div><div class="line">        <span class="keywordflow">if</span> (curr_object != init_object) {</div><div class="line">          bounding_polygon.push_back(m);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (curr_object.first) {</div><div class="line">          std::list&lt;int&gt; faces;</div><div class="line">          <span class="keywordflow">for</span> (std::size_t g = 0; g &lt; adjacent_faces.size(); ++g) {</div><div class="line">            <span class="keywordflow">if</span> (adjacent_faces[g] != prev_face) {</div><div class="line">              faces.push_back(adjacent_faces[g]);</div><div class="line">            }</div><div class="line">          }</div><div class="line">          bounding_faces.push_back(faces);</div><div class="line">        } <span class="keywordflow">else</span> {</div><div class="line">          bounding_faces.push_back(std::list&lt;int&gt;(1, curr_face));</div><div class="line">        }</div><div class="line"></div><div class="line">        prev_object = curr_object;</div><div class="line">        prev_face   = curr_face;</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      }</div><div class="line">    }</div><div class="line">    assert(iteration_done);</div><div class="line">  } <span class="keywordflow">while</span> (curr_object != init_object);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> construct_bounding_polygon_of_support_plane(</div><div class="line">  <span class="keyword">const</span> Point_3&amp; pt_min, <span class="keyword">const</span> Point_3&amp; pt_max,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;Point_3&gt;&amp; box_corners,</div><div class="line">  <span class="keyword">const</span> std::vector&lt; std::pair&lt;std::size_t, std::size_t&gt; &gt;&amp; box_edges,</div><div class="line">  <span class="keyword">const</span> Plane_3&amp; plane,</div><div class="line">  std::list&lt;Point_3&gt;&amp; bounding_polygon) {</div><div class="line"></div><div class="line">  std::vector&lt; std::list&lt;int&gt; &gt; bounding_faces;</div><div class="line">  construct_bounding_polygon_of_support_plane(</div><div class="line">    pt_min, pt_max,</div><div class="line">    box_corners, box_edges,</div><div class="line">    plane,</div><div class="line">    bounding_polygon,</div><div class="line">    bounding_faces);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> create_random_polygons(</div><div class="line">  <span class="keyword">const</span> std::size_t num_polygons,</div><div class="line">  <span class="keyword">const</span> std::size_t num_vertices,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> side_length,</div><div class="line">  std::vector&lt;Polygon_3&gt;&amp; polygons) {</div><div class="line"></div><div class="line">  std::default_random_engine generator(</div><div class="line">    std::chrono::system_clock::now().time_since_epoch().count());</div><div class="line">  std::uniform_real_distribution&lt;double&gt; R(-1.0, 1.0);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> Point_3 pt_min(-FT(1), -FT(1), -FT(1));</div><div class="line">  <span class="keyword">const</span> Point_3 pt_max( FT(1),  FT(1),  FT(1));</div><div class="line">  std::vector&lt;Point_3&gt; box_corners;</div><div class="line">  std::vector&lt; std::pair&lt;std::size_t, std::size_t&gt; &gt; box_edges;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::size_t vertices[8][3] = {</div><div class="line">    {0, 0, 0}, {1, 0, 0},</div><div class="line">    {0, 1, 0}, {1, 1, 0},</div><div class="line">    {0, 0, 1}, {1, 0, 1},</div><div class="line">    {0, 1, 1}, {1, 1, 1}</div><div class="line">  };</div><div class="line">  <span class="keyword">const</span> std::size_t edges[12][2] = {</div><div class="line">    {0, 2}, {1, 3}, {4, 6},</div><div class="line">    {5, 7}, {0, 1}, {2, 3},</div><div class="line">    {4, 5}, {6, 7}, {0, 4},</div><div class="line">    {2, 6}, {1, 5}, {3, 7}</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; 8; ++i) {</div><div class="line">    <span class="keyword">const</span> FT x = (vertices[i][0] == 0 ? pt_min.x() : pt_max.x());</div><div class="line">    <span class="keyword">const</span> FT y = (vertices[i][1] == 0 ? pt_min.y() : pt_max.y());</div><div class="line">    <span class="keyword">const</span> FT z = (vertices[i][2] == 0 ? pt_min.z() : pt_max.z());</div><div class="line">    box_corners.push_back(Point_3(x, y, z));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; 12; ++i) {</div><div class="line">    box_edges.push_back(std::make_pair(edges[i][0], edges[i][1]));</div><div class="line">  }</div><div class="line"></div><div class="line">  polygons.reserve(num_polygons);</div><div class="line">  <span class="keywordflow">while</span> (polygons.size() &lt; num_polygons) {</div><div class="line">    <span class="keyword">const</span> FT x_0 = <span class="keyword">static_cast&lt;</span>FT<span class="keyword">&gt;</span>(R(generator));</div><div class="line">    <span class="keyword">const</span> FT y_0 = <span class="keyword">static_cast&lt;</span>FT<span class="keyword">&gt;</span>(R(generator));</div><div class="line">    <span class="keyword">const</span> FT z_0 = <span class="keyword">static_cast&lt;</span>FT<span class="keyword">&gt;</span>(R(generator));</div><div class="line">    <span class="keyword">const</span> Point_3 center_ref(x_0, y_0, z_0);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> FT a = <span class="keyword">static_cast&lt;</span>FT<span class="keyword">&gt;</span>(R(generator));</div><div class="line">    <span class="keyword">const</span> FT b = <span class="keyword">static_cast&lt;</span>FT<span class="keyword">&gt;</span>(R(generator));</div><div class="line">    <span class="keyword">const</span> FT c = <span class="keyword">static_cast&lt;</span>FT<span class="keyword">&gt;</span>(R(generator));</div><div class="line">    <span class="keyword">const</span> FT d = -(a * x_0 + b * y_0 + c * z_0);</div><div class="line">    <span class="keyword">const</span> Plane_3 plane_ref(a, b, c, d);</div><div class="line"></div><div class="line">    std::list&lt;Point_3&gt;   bp_ref_3d;</div><div class="line">    std::vector&lt;Point_2&gt; bp_ref_2d;</div><div class="line"></div><div class="line">    construct_bounding_polygon_of_support_plane(</div><div class="line">      pt_min, pt_max, box_corners, box_edges, plane_ref, bp_ref_3d);</div><div class="line"></div><div class="line">    bp_ref_2d.reserve(bp_ref_3d.size());</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> it_p = bp_ref_3d.begin(); it_p != bp_ref_3d.end(); ++it_p) {</div><div class="line">      bp_ref_2d.push_back(plane_ref.to_2d(*it_p));</div><div class="line">    }</div><div class="line"></div><div class="line">    Polygon_2 bp_ref(bp_ref_2d.begin(), bp_ref_2d.end());</div><div class="line">    <span class="keywordflow">if</span> (bp_ref.orientation() == <a name="a7"></a><a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga5aa0906f2432d414090dd8723c10f304">CGAL::Orientation::CLOCKWISE</a>) {</div><div class="line">      bp_ref.reverse_orientation();</div><div class="line">    }</div><div class="line"></div><div class="line">    std::vector&lt;Point_2&gt; ch;</div><div class="line">    CGAL::random_convex_set_2(</div><div class="line">      num_vertices, std::back_inserter(ch), Point_generator(side_length));</div><div class="line"></div><div class="line">    std::vector&lt;Point_2&gt; k_pts;</div><div class="line">    <span class="keywordflow">for</span> (std::size_t j = 0; j &lt; ch.size(); ++j) {</div><div class="line">      <span class="keyword">const</span> FT lambda = ch[j].x(), mu = ch[j].y();</div><div class="line">      <span class="keyword">const</span> Point_3 m = center_ref + lambda * plane_ref.base1() + mu * plane_ref.base2();</div><div class="line">      k_pts.push_back(plane_ref.to_2d(m));</div><div class="line">    }</div><div class="line"></div><div class="line">    Polygon_2 k_poly(k_pts.begin(), k_pts.end());</div><div class="line">    <span class="keywordflow">if</span> (k_poly.orientation() == <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga5aa0906f2432d414090dd8723c10f304">CGAL::Orientation::CLOCKWISE</a>) {</div><div class="line">      k_poly.reverse_orientation();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// std::cout &lt;&lt; "OFF" &lt;&lt; std::endl;</span></div><div class="line">    <span class="comment">// std::cout &lt;&lt; "4 1 0" &lt;&lt; std::endl;</span></div><div class="line">    <span class="comment">// for (auto it_p = k_poly.vertices_begin(); it_p != k_poly.vertices_end(); ++it_p) {</span></div><div class="line">    <span class="comment">//   std::cout &lt;&lt; *it_p &lt;&lt; " 0" &lt;&lt; std::endl;</span></div><div class="line">    <span class="comment">// }</span></div><div class="line">    <span class="comment">// std::cout &lt;&lt; "4 0 1 2 3" &lt;&lt; std::endl;</span></div><div class="line"></div><div class="line">    std::list&lt;Polygon_with_holes_2&gt; bp_k_intersection;</div><div class="line">    <a name="a8"></a><a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__intersection__linear__grp.html#gade00253914ac774cce3d2031c07d74fe">CGAL::intersection</a>(bp_ref, k_poly, std::back_inserter(bp_k_intersection));</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (!bp_k_intersection.empty()) {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> it_p = bp_k_intersection.begin(); it_p != bp_k_intersection.end(); ++it_p) {</div><div class="line">        <span class="keyword">const</span> Polygon_2 s_poly = it_p-&gt;outer_boundary();</div><div class="line">        std::vector&lt;Point_3&gt; poly_generated;</div><div class="line">        poly_generated.reserve(s_poly.size());</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it_v = s_poly.vertices_begin(); it_v != s_poly.vertices_end(); ++it_v) {</div><div class="line">          poly_generated.push_back(plane_ref.to_3d(*it_v));</div><div class="line">        }</div><div class="line">        polygons.push_back(poly_generated);</div><div class="line">      }</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  Saver saver;</div><div class="line">  saver.export_polygon_soup_3(</div><div class="line">    polygons, <span class="stringliteral">"rnd-polygons-"</span> +</div><div class="line">    std::to_string(num_polygons) + <span class="stringliteral">"-"</span> + std::to_string(num_vertices));</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keyword">const</span> <span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span>** argv) {</div><div class="line"></div><div class="line">  <span class="comment">// Input.</span></div><div class="line">  <span class="keyword">const</span> std::size_t n = argc &gt; 1 ? std::atoi(argv[1]) : 1; <span class="comment">// number of random polygons</span></div><div class="line">  <span class="keyword">const</span> std::size_t p = argc &gt; 2 ? std::atoi(argv[2]) : 4; <span class="comment">// number of vertices in a polygon</span></div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> d = 1.5; <span class="comment">// side of the square</span></div><div class="line"></div><div class="line">  std::vector&lt;Polygon_3&gt; rnd_polygons;</div><div class="line">  create_random_polygons(n, p, d, rnd_polygons);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"--- INPUT STATS: "</span> &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* input kernel: "</span>                    &lt;&lt; boost::typeindex::type_id&lt;EPICK&gt;().pretty_name()  &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* polygon kernel: "</span>                  &lt;&lt; boost::typeindex::type_id&lt;Kernel&gt;().pretty_name() &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* expected number of polygons: "</span>     &lt;&lt; n                                                 &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* generated number of polygons: "</span>    &lt;&lt; rnd_polygons.size()                               &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* number of vertices in a polygon: "</span> &lt;&lt; p                                                 &lt;&lt; std::endl;</div><div class="line">  <span class="comment">// exit(EXIT_SUCCESS);</span></div><div class="line"></div><div class="line">  IPolygon_3 input_polygon;</div><div class="line">  std::vector&lt;IPolygon_3&gt; input_polygons;</div><div class="line">  input_polygons.reserve(rnd_polygons.size());</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; rnd_polygon : rnd_polygons) {</div><div class="line">    input_polygon.clear();</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; rnd_point : rnd_polygon) {</div><div class="line">      <span class="keyword">const</span> IFT x = <span class="keyword">static_cast&lt;</span>IFT<span class="keyword">&gt;</span>(CGAL::to_double(rnd_point.x()));</div><div class="line">      <span class="keyword">const</span> IFT y = <span class="keyword">static_cast&lt;</span>IFT<span class="keyword">&gt;</span>(CGAL::to_double(rnd_point.y()));</div><div class="line">      <span class="keyword">const</span> IFT z = <span class="keyword">static_cast&lt;</span>IFT<span class="keyword">&gt;</span>(CGAL::to_double(rnd_point.z()));</div><div class="line">      input_polygon.push_back(IPoint_3(x, y, z));</div><div class="line">    }</div><div class="line">    input_polygons.push_back(input_polygon);</div><div class="line">  }</div><div class="line">  assert(input_polygons.size() == rnd_polygons.size());</div><div class="line"></div><div class="line">  <span class="comment">// Algorithm.</span></div><div class="line">  KSP ksp(<span class="keyword">true</span>, <span class="keyword">false</span>);</div><div class="line">  <span class="keyword">const</span> IPolygon_3_map polygon_map;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = (argc &gt; 3 ? std::atoi(argv[3]) : 1);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* input k: "</span> &lt;&lt; k &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> is_ksp_success = ksp.initialize(</div><div class="line">    input_polygons, polygon_map);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (is_ksp_success)</div><div class="line">    ksp.partition(k);</div><div class="line"></div><div class="line">  assert(is_ksp_success);</div><div class="line">  <span class="keyword">const</span> std::string success = is_ksp_success ? <span class="stringliteral">"SUCCESS"</span> : <span class="stringliteral">"FAILED"</span>;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">"3D KINETIC "</span> &lt;&lt; success &lt;&lt; <span class="stringliteral">"!"</span> &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jan 30 2023 14:23:35 for CGAL 5.6 - Kinetic Shape Reconstruction by
    <a href="https://www.doxygen.nl/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>

</html>
