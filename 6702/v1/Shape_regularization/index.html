<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Shape_regularization/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 5.6 - Shape Regularization: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//&amp;lt;![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      }
  }
}
);
//]]&amp;gt;
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.6 - Shape Regularization
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Shape_Regularization"></a>  </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Authors</dt><dd>Dmitry Anisimov, Gennadii Sytov, Simon Giraudot, Jean-Philippe Bauchet, and Florent Lafarge</dd></dl>
<p><a class="anchor" id="fig__regularize_2_overview"></a></p><div class="image">
<object type="image/svg+xml" data="overview.svg">overview.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__regularize_2_overview">Figure 82.1</a> A closed contour before (red) and after (green) regularization.  </div> <br /> 
<h1><a class="anchor" id="Shape_Regularization_Intro"></a>
Introduction</h1>
<p>This CGAL package enables to regularize a set of segments and open or closed contours in 2D and a set of planes in 3D such that all input objects are rotated and aligned with respect to the user-specified conditions. In addition, we provide a global regularization framework that can be adjusted for the user needs and any type of geometric objects. This package can also be used in conjunction with the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgShapeDetection">Shape Detection</a> package.</p>
<h1><a class="anchor" id="QP_Regularization_Segments"></a>
Segments</h1>
<p>Given a set of unordered 2D segments, users can reinforce three types of regularities among these segments:</p><ul>
<li><em>Parallelism</em>: segments, which are detected as near parallel, are made exactly parallel.</li>
<li><em>Orthogonality</em>: segments, which are detected as near orthogonal, are made exactly orthogonal.</li>
<li><em>Collinearity</em>: parallel segments, which are detected as near collinear, are made exactly collinear.</li>
</ul>
<p>A typical use of this algorithm consists of the following steps:</p><ol type="1">
<li>Create an input range with 2D segments;</li>
<li>Define groups of segments, which should be regularized together;</li>
<li>Instantiate models of the concepts <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1NeighborQuery.html" title="A concept that describes the set of methods used by the class QP_regularization to access neighbors o...">NeighborQuery</a></code> and <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html" title="A concept that describes the set of methods used by the class QP_regularization to access various dat...">RegularizationType</a></code> with the proper parameters;</li>
<li>Call the function <code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#ga3cde2421ff91530c13c9e8f1feaeae1c" title="regularizes a set of 2D segments. ">regularize_segments()</a></code>.</li>
</ol>
<p>Once the user has defined an input range with 2D segments, he can either provide them all to the regularization algorithm, which is the default option, or they could be reorganized into groups of contextually similar segments. For example, all segments of the same length could form a group. When regularizing, only segments within the group are taken into account, that is no segment from one group will be oriented and/or aligned towards a segment from another group (see more details <a class="el" href="index.html#QP_Regularization_Segments_Delaunay">here</a>).</p>
<p>To apply the algorithm, the user has to define two models: one of the concept <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1NeighborQuery.html" title="A concept that describes the set of methods used by the class QP_regularization to access neighbors o...">NeighborQuery</a></code> that provides an access to the closest neighbors of a segment; and the other one of the concept <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html" title="A concept that describes the set of methods used by the class QP_regularization to access various dat...">RegularizationType</a></code> that provides one of the available regularities, which should be adjusted.</p>
<p>This CGAL component provides a model of the <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1NeighborQuery.html" title="A concept that describes the set of methods used by the class QP_regularization to access neighbors o...">NeighborQuery</a></code> concept:</p>
<ul>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Delaunay__neighbor__query__2.html" title="A neighbor query based on a Delaunay triangulation, which enables to find the nearest neighbors in a ...">Segments::Delaunay_neighbor_query_2</a></code> - finds local neighbors of each segment by constructing a Delaunay triangulation. See more details <a class="el" href="index.html#QP_Regularization_Segments_Delaunay">here</a>.</li>
</ul>
<p>And two models of the <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html" title="A concept that describes the set of methods used by the class QP_regularization to access various dat...">RegularizationType</a></code> concept:</p>
<ul>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Angle__regularization__2.html" title="An angle-based regularization type for 2D segments that reinforces parallelism and orthogonality rela...">Segments::Angle_regularization_2</a></code> - orients segments to reinforce parallelism and orthogonality among them. See more details <a class="el" href="index.html#QP_Regularization_Segments_Angles">here</a>.</li>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Offset__regularization__2.html" title="An offset-based regularization type for 2D segments that reinforces collinearity relationships. ">Segments::Offset_regularization_2</a></code> - aligns parallel segments to reinforce collinearity among them. See more details <a class="el" href="index.html#QP_Regularization_Segments_Offset">here</a>.</li>
</ul>
<p>The standard way to regularize a set of input segments is to first apply an angle regularization and then an offset regularization, however the algorithm is flexible to handle other scenarios as you will see later.</p>
<dl class="section note"><dt>Note</dt><dd>The core of this algorithm is the <a class="el" href="index.html#QP_Regularization">QP Regularization</a> framework. For more details, please refer to that section.</dd></dl>
<p>The example below shows the most straightforward entry point to the algorithm, where we apply two type of regularities: parallelism and orthogonality, within the group of all input segments. The algorithm is called via the function <code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#ga3cde2421ff91530c13c9e8f1feaeae1c" title="regularizes a set of 2D segments. ">regularize_segments()</a></code>.</p>
<p><a class="anchor" id="fig__regularize_simple_example"></a></p><div class="image">
<object type="image/svg+xml" data="regularize_simple.svg">regularize_simple.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__regularize_simple_example">Figure 82.2</a> A set of 2D segments before (red) and after (green) the angle and offset regularization.  </div> <br /> 
<p><br />
<b>File</b> <a class="el" href="Shape_regularization_2regularize_simple_8cpp-example.html">Shape_regularization/regularize_simple.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="regularize__segments_8h.html">CGAL/Shape_regularization/regularize_segments.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>    = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> Point_2   = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>;</div><div class="line"><span class="keyword">using</span> Segment_2 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#aa6d2526f8d1571f4a38aa8a6d9a02c2b">Kernel::Segment_2</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">  <span class="comment">// Create input segments.</span></div><div class="line">  std::vector&lt;Segment_2&gt; segments = {</div><div class="line">    Segment_2(Point_2(0.2, 0.0), Point_2(1.2, 0.0)),</div><div class="line">    Segment_2(Point_2(1.2, 0.1), Point_2(2.2, 0.1)),</div><div class="line">    Segment_2(Point_2(2.2, 0.0), Point_2(2.0, 2.0)),</div><div class="line">    Segment_2(Point_2(2.0, 2.0), Point_2(1.0, 2.0)),</div><div class="line">    Segment_2(Point_2(1.0, 1.9), Point_2(0.0, 1.9)),</div><div class="line">    Segment_2(Point_2(0.0, 2.0), Point_2(0.2, 0.0))</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="comment">// Regularize all segments: both angles and offsets.</span></div><div class="line">  <a class="code" href="group__PkgShapeRegularizationRefSegments.html#ga3cde2421ff91530c13c9e8f1feaeae1c">CGAL::Shape_regularization::Segments::</a></div><div class="line"><a class="code" href="group__PkgShapeRegularizationRefSegments.html#ga3cde2421ff91530c13c9e8f1feaeae1c">    regularize_segments</a>(segments);</div><div class="line">}</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>As it can be seen from the example, the algorithm does not prioritize any directions like vertical or horizontal but rather returns the optimal regularized configuration of the input segments.</dd></dl>
<h2><a class="anchor" id="QP_Regularization_Segments_Delaunay"></a>
Delaunay Neighbor Query</h2>
<p>This class finds local neighbors of each segment by constructing a Delaunay triangulation, using the class <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2</a></code>, upon the center points of the input segments. The local neighborhood of a segment is thus defined by the corresponding one-ring neighborhood in the triangulation. The Delaunay triangulation can be constructed only for a group of at least two segments.</p>
<p>The Delaunay neighbor query class constructs the Delaunay triangulation from a group of segments, which has to be provided by the user through the <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Delaunay__neighbor__query__2.html#aaffd7eb2871e03b6e0d3cc997b440661" title="inserts a group of segments from input_range and finds their neighbors within the group...">Segments::Delaunay_neighbor_query_2::add_group()</a></code> method, and finds local neighbors of each segment only within the group. If this method is never called, all input segments are treated as a group.</p>
<p>Note that a group can include fewer segments than in the input range. For example, if your input range contains multiple segments, which contextually form three different groups of objects lets say boundaries of three different buildings and you do not want to regularize these buildings with respect to each other, but rather within each building boundary, in that case you should call the <code>add_group</code> method three times. An example of such groups can be seen in <a class="el" href="index.html#Regularize_15_Segments_Figure">this figure</a>, where you can see three groups of contextually similar segments: outer boundary, interior top rhombus and interior bottom rhombus or in the figure below.</p>
<p>In this figure, there are two squares, one external and one internal. On the left, the red segments show the connectivity among all input segments that is a Delaunay triangulation built upon all these segments, while on the right, the green segments show the connectivity only among external square segments and blue segments only among internal square segments.</p>
<p><a class="anchor" id="fig__delaunay_groups"></a></p><div class="image">
<object type="image/svg+xml" data="delaunay_groups.svg">delaunay_groups.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__delaunay_groups">Figure 82.3</a> Delaunay triangulation (red) for all input segments (black, left) and two contextually different groups with green Delaunay for the external segments and blue Delaunay for the internal segments (right).  </div> <br /> 
<h2><a class="anchor" id="QP_Regularization_Segments_Angles"></a>
Angle Regularization</h2>
<p>This class orients 2D segments in order to reinforce parallelism and orthogonality among them. To apply the angle regularization on a set of 2D segments, the user has to:</p><ul>
<li>specify the maximum angle deviation of a segment from its initial orientation that has to be within the interval [0, 90] degrees. If no bound is provided, a bound of 25 degrees will be set as the default value;</li>
<li>add groups of segments, if any, through the <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Angle__regularization__2.html#a973f865ac9b75042b31ec29d88f2b606" title="inserts a group of segments from input_range. ">Segments::Angle_regularization_2::add_group()</a></code> method.</li>
</ul>
<p>After the optimization, each segment is rotated with respect to its midpoint.</p>
<p><a class="anchor" id="fig__regularize_100_segments_angles_example"></a></p><div class="image">
<object type="image/svg+xml" data="regularize_100_segments_angles.svg">regularize_100_segments_angles.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__regularize_100_segments_angles_example">Figure 82.4</a> A generated set of 2D segments before (red) and after (green) the angle regularization.  </div> <br /> 
<p>The following example demonstrates the usage of the shape regularization algorithm for angles on a set of 100 near orthogonal segments generated with the help of <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgGenerators">CGAL Geometric Object Generators</a>. The entire <code>InputRange</code> is provided to the angle regularization class as a group. The maximum angle bound is set to 40 degrees.</p>
<p><br />
<b>File</b> <a class="el" href="Shape_regularization_2regularize_100_segments_angles_8cpp-example.html">Shape_regularization/regularize_100_segments_angles.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include "include/utils.h"</span></div><div class="line"><span class="preprocessor">#include "include/Saver.h"</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="regularize__segments_8h.html">CGAL/Shape_regularization/regularize_segments.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Typedefs.</span></div><div class="line"><span class="keyword">using</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>    = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> FT        = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"><span class="keyword">using</span> Segment_2 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#aa6d2526f8d1571f4a38aa8a6d9a02c2b">Kernel::Segment_2</a>;</div><div class="line"><span class="keyword">using</span> Segments  = std::vector&lt;Segment_2&gt;;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Neighbor_query =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Delaunay__neighbor__query__2.html">CGAL::Shape_regularization::Segments::Delaunay_neighbor_query_2&lt;Kernel, Segments&gt;</a>;</div><div class="line"><span class="keyword">using</span> Angle_regularization =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Angle__regularization__2.html">CGAL::Shape_regularization::Segments::Angle_regularization_2&lt;Kernel, Segments&gt;</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div><div class="line"></div><div class="line">  <span class="comment">// If we want to save the result in a file, we save it in a path.</span></div><div class="line">  std::string path = <span class="stringliteral">""</span>;</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1) path = argv[1];</div><div class="line">  Saver&lt;Kernel&gt; saver;</div><div class="line"></div><div class="line">  <span class="comment">// Initialize 100 near-orthogonal segments.</span></div><div class="line">  std::vector&lt;Segment_2&gt; segments;</div><div class="line">  create_example_angles(segments);</div><div class="line"></div><div class="line">  <span class="comment">// Save input segments.</span></div><div class="line">  <span class="keywordflow">if</span> (path != <span class="stringliteral">""</span>) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = path + <span class="stringliteral">"regularize_100_segments_angles_before"</span>;</div><div class="line">    saver.export_eps_segments(segments, full_path, FT(1));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Angle regularization.</span></div><div class="line">  <span class="keyword">const</span> FT max_angle_2 = FT(40);</div><div class="line"></div><div class="line">  <span class="comment">// Create neigbor query and angle-based regularization model.</span></div><div class="line">  Neighbor_query neighbor_query(segments);</div><div class="line">  Angle_regularization angle_regularization(</div><div class="line">    segments, CGAL::parameters::maximum_angle(max_angle_2));</div><div class="line"></div><div class="line">  <span class="comment">// Regularize.</span></div><div class="line">  <a class="code" href="group__PkgShapeRegularizationRefSegments.html#ga3cde2421ff91530c13c9e8f1feaeae1c">CGAL::Shape_regularization::Segments::regularize_segments</a>(</div><div class="line">    segments, neighbor_query, angle_regularization);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* number of modified segments = "</span> &lt;&lt;</div><div class="line">    angle_regularization.number_of_modified_segments() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save regularized segments.</span></div><div class="line">  <span class="keywordflow">if</span> (path != <span class="stringliteral">""</span>) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = path + <span class="stringliteral">"regularize_100_segments_angles_after"</span>;</div><div class="line">    saver.export_eps_segments(segments, full_path, FT(1));</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="QP_Regularization_Segments_Offset"></a>
Offset Regularization</h2>
<p>This class aligns 2D parallel segments in order to reinforce collinearity among them. To apply the offset regularization on a set of 2D segments, the user has to:</p><ul>
<li>specify the maximum distance between two parallel segments that has to be within the interval [0, +inf). If no bound is provided, a bound of 0.5 unit length will be set as the default value.</li>
<li>add groups of parallel segments through the <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Offset__regularization__2.html#a8e9dbdec86eb77a43911699e59307865" title="inserts a group of segments from input_range. ">Segments::Offset_regularization_2::add_group()</a></code> method. If the user does not have these groups, they can be obtained from <a class="el" href="index.html#QP_Regularization_Segments_Angles">Angle Regularization</a> by orienting original segments or from the utility function <code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#gac72eca9b32b73a3713edffd2da5609f2" title="finds groups of parallel segments in a set of 2D segments. ">Segments::parallel_groups()</a></code>. See more details <a class="el" href="index.html#QP_Regularization_Segments_Groups">here</a>.</li>
</ul>
<p>After the optimization, each segment is translated along its orthogonal direction.</p>
<p>Note that if the input segments within the same group are not exactly parallel, the distance, which is defined as the distance between the midpoint of one segment and the projection of this point onto the supporting line of another segment, is not a good metric to optimize positions of the segments that may lead to deviations in the result from what the user would expect in case of exactly parallel segments. The offset regularization does not internally orient segments to make them exactly parallel. This is what the <a class="el" href="index.html#QP_Regularization_Segments_Angles">Angle Regularization</a> class for. The utility function <code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#gac72eca9b32b73a3713edffd2da5609f2" title="finds groups of parallel segments in a set of 2D segments. ">Segments::parallel_groups()</a></code> does not orient segments either, but only returns groups of near-parallel segments.</p>
<p><a class="anchor" id="fig__regularize_100_segments_offsets_example"></a></p><div class="image">
<object type="image/svg+xml" data="regularize_100_segments_offsets.svg">regularize_100_segments_offsets.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__regularize_100_segments_offsets_example">Figure 82.5</a> A generated set of 2D segments before (red) and after (green) the offset regularization.  </div> <br /> 
<p>The following example demonstrates the usage of the shape regularization algorithm for offsets on a set of 100 parallel segments located within a circle. The function <code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#gac72eca9b32b73a3713edffd2da5609f2" title="finds groups of parallel segments in a set of 2D segments. ">Segments::parallel_groups()</a></code> is used to obtain the groups of parallel segments. The maximum offset bound is set to 0.25 unit length.</p>
<p><a class="anchor" id="QP_Parallel_Groups_Example"></a><br />
<b>File</b> <a class="el" href="Shape_regularization_2regularize_100_segments_offsets_8cpp-example.html">Shape_regularization/regularize_100_segments_offsets.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include "include/utils.h"</span></div><div class="line"><span class="preprocessor">#include "include/Saver.h"</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="regularize__segments_8h.html">CGAL/Shape_regularization/regularize_segments.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Typedefs.</span></div><div class="line"><span class="keyword">using</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>    = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> FT        = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"><span class="keyword">using</span> Segment_2 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#aa6d2526f8d1571f4a38aa8a6d9a02c2b">Kernel::Segment_2</a>;</div><div class="line"><span class="keyword">using</span> Segments  = std::vector&lt;Segment_2&gt;;</div><div class="line"><span class="keyword">using</span> Indices   = std::vector&lt;std::size_t&gt;;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Neighbor_query =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Delaunay__neighbor__query__2.html">CGAL::Shape_regularization::Segments::Delaunay_neighbor_query_2&lt;Kernel, Segments&gt;</a>;</div><div class="line"><span class="keyword">using</span> Offset_regularization =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Offset__regularization__2.html">CGAL::Shape_regularization::Segments::Offset_regularization_2&lt;Kernel, Segments&gt;</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div><div class="line"></div><div class="line">  <span class="comment">// If we want to save the result in a file, we save it in a path.</span></div><div class="line">  std::string path = <span class="stringliteral">""</span>;</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1) path = argv[1];</div><div class="line">  Saver&lt;Kernel&gt; saver;</div><div class="line"></div><div class="line">  <span class="comment">// Initialize 100 segments in a fuzzy circle.</span></div><div class="line">  std::vector&lt;Segment_2&gt; segments;</div><div class="line">  create_example_offsets(segments);</div><div class="line"></div><div class="line">  <span class="comment">// Save input segments.</span></div><div class="line">  <span class="keywordflow">if</span> (path != <span class="stringliteral">""</span>) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = path + <span class="stringliteral">"regularize_100_segments_offsets_before"</span>;</div><div class="line">    saver.export_eps_segments(segments, full_path, FT(100));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Find groups of parallel segments.</span></div><div class="line">  <span class="keyword">const</span> FT max_angle_2 = FT(1);</div><div class="line"></div><div class="line">  std::vector&lt;Indices&gt; pgroups;</div><div class="line">  <a class="code" href="group__PkgShapeRegularizationRefSegments.html#gac72eca9b32b73a3713edffd2da5609f2">CGAL::Shape_regularization::Segments::parallel_groups</a>(</div><div class="line">    segments, std::back_inserter(pgroups),</div><div class="line">    CGAL::parameters::maximum_angle(max_angle_2));</div><div class="line"></div><div class="line">  <span class="comment">// Offset regularization.</span></div><div class="line">  <span class="keyword">const</span> FT max_offset_2 = FT(1) / FT(4);</div><div class="line"></div><div class="line">  <span class="comment">// Create neigbor query and offset-based regularization model.</span></div><div class="line">  Neighbor_query neighbor_query(segments);</div><div class="line">  Offset_regularization offset_regularization(</div><div class="line">    segments, CGAL::parameters::maximum_offset(max_offset_2));</div><div class="line"></div><div class="line">  <span class="comment">// Add each group of parallel segments with at least 2 segments.</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; pgroup : pgroups) {</div><div class="line">    neighbor_query.add_group(pgroup);</div><div class="line">    offset_regularization.add_group(pgroup);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Regularize.</span></div><div class="line">  <a class="code" href="group__PkgShapeRegularizationRefSegments.html#ga3cde2421ff91530c13c9e8f1feaeae1c">CGAL::Shape_regularization::Segments::regularize_segments</a>(</div><div class="line">    segments, neighbor_query, offset_regularization);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* number of modified segments = "</span> &lt;&lt;</div><div class="line">    offset_regularization.number_of_modified_segments() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save regularized segments.</span></div><div class="line">  <span class="keywordflow">if</span> (path != <span class="stringliteral">""</span>) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = path + <span class="stringliteral">"regularize_100_segments_offsets_after"</span>;</div><div class="line">    saver.export_eps_segments(segments, full_path, FT(100));</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="QP_Regularization_Segments_Examples"></a>
Angle + Offset Regularization</h2>
<p>The following examples demonstrate the usage of the shape regularization algorithm for both angles and offsets sequentially on a set of 2D segments.</p>
<p>The first example contains 15 segments. The angle and offset regularizations are performed on these segments sequentially using the maximum bounds of 10 degrees and 0.1 unit length respectively. We also show here how to create and work with contextually similar groups of segments and regularize each group on its own. The defined groups are the outer boundary, top and bottom rhombus. Since the shape regularization algorithm on segments is based on the <a class="el" href="index.html#QP_Regularization">QP Regularization</a> framework, this example also shows how to use that framework directly instead of calling the function <code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#ga3cde2421ff91530c13c9e8f1feaeae1c" title="regularizes a set of 2D segments. ">regularize_segments()</a></code>.</p>
<p><a class="anchor" id="Regularize_15_Segments_Figure"></a><a class="anchor" id="fig__regularize_15_segments_example"></a></p><div class="image">
<object type="image/svg+xml" data="regularize_15_segments.svg">regularize_15_segments.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__regularize_15_segments_example">Figure 82.6</a> A set of 2D segments before (red), after the angle (yellow), and the offset (green) regularization.  </div> <br /> 
<p><br />
<b>File</b> <a class="el" href="Shape_regularization_2regularize_15_segments_8cpp-example.html">Shape_regularization/regularize_15_segments.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include "include/utils.h"</span></div><div class="line"><span class="preprocessor">#include "include/Saver.h"</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Shape__regularization_8h.html">CGAL/Shape_regularization.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Typedefs.</span></div><div class="line"><span class="keyword">using</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>      = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div><div class="line"><span class="keyword">using</span> FT          = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"><span class="keyword">using</span> Segment_2   = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#aa6d2526f8d1571f4a38aa8a6d9a02c2b">Kernel::Segment_2</a>;</div><div class="line"><span class="keyword">using</span> Segments    = std::vector&lt;Segment_2&gt;;</div><div class="line"><span class="keyword">using</span> Indices     = std::vector&lt;std::size_t&gt;;</div><div class="line"><span class="keyword">using</span> Segment_map = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map&lt;Segment_2&gt;</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Neighbor_query =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Delaunay__neighbor__query__2.html">CGAL::Shape_regularization::Segments::Delaunay_neighbor_query_2&lt;Kernel, Segments, Segment_map&gt;</a>;</div><div class="line"><span class="keyword">using</span> Angle_regularization =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Angle__regularization__2.html">CGAL::Shape_regularization::Segments::Angle_regularization_2&lt;Kernel, Segments, Segment_map&gt;</a>;</div><div class="line"><span class="keyword">using</span> Offset_regularization =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Offset__regularization__2.html">CGAL::Shape_regularization::Segments::Offset_regularization_2&lt;Kernel, Segments, Segment_map&gt;</a>;</div><div class="line"><span class="keyword">using</span> Quadratic_program =</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classCGAL_1_1OSQP__quadratic__program__traits.html">CGAL::OSQP_quadratic_program_traits&lt;FT&gt;</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Quadratic_angle_regularizer =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1QP__regularization.html">CGAL::Shape_regularization::QP_regularization</a>&lt;</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>, Segments, Neighbor_query, Angle_regularization, Quadratic_program&gt;;</div><div class="line"><span class="keyword">using</span> Quadratic_offset_regularizer =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1QP__regularization.html">CGAL::Shape_regularization::QP_regularization</a>&lt;</div><div class="line">    Kernel, Segments, Neighbor_query, Offset_regularization, Quadratic_program&gt;;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div><div class="line"></div><div class="line">  <span class="comment">// If we want to save the result in a file, we save it in a path.</span></div><div class="line">  std::string path = <span class="stringliteral">""</span>;</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1) path = argv[1];</div><div class="line">  Saver&lt;Kernel&gt; saver;</div><div class="line"></div><div class="line">  <span class="comment">// Initialize 15 segments.</span></div><div class="line">  std::vector&lt;Segment_2&gt; segments;</div><div class="line">  create_example_15(segments);</div><div class="line"></div><div class="line">  <span class="comment">// We create three groups of segments:</span></div><div class="line">  <span class="comment">// outer, top and bottom rhombuses.</span></div><div class="line">  std::vector&lt;Indices&gt; groups(3);</div><div class="line">  groups[0] = {0, 1, 2, 3, 4, 5, 6}; <span class="comment">// outer</span></div><div class="line">  groups[1] = {7, 8, 9, 10};         <span class="comment">// top rhombus</span></div><div class="line">  groups[2] = {11, 12, 13, 14};      <span class="comment">// bottom rhombus</span></div><div class="line"></div><div class="line">  <span class="comment">// Save input segments.</span></div><div class="line">  <span class="keywordflow">if</span> (path != <span class="stringliteral">""</span>) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = path + <span class="stringliteral">"regularize_15_segments_before"</span>;</div><div class="line">    saver.export_eps_segments(segments, full_path, FT(100));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Angle regularization.</span></div><div class="line">  <span class="keyword">const</span> FT max_angle_2 = FT(10);</div><div class="line"></div><div class="line">  <span class="comment">// Create qp solver, neigbor query, and angle-based regularization model.</span></div><div class="line">  Quadratic_program qp_angles;</div><div class="line">  Neighbor_query neighbor_query(segments);</div><div class="line">  Angle_regularization angle_regularization(</div><div class="line">    segments, CGAL::parameters::maximum_angle(max_angle_2));</div><div class="line"></div><div class="line">  <span class="comment">// Add each group of input segments.</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; group : groups) {</div><div class="line">    neighbor_query.add_group(group);</div><div class="line">    angle_regularization.add_group(group);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Regularize.</span></div><div class="line">  Quadratic_angle_regularizer qp_angle_regularizer(</div><div class="line">    segments, neighbor_query, angle_regularization, qp_angles);</div><div class="line">  qp_angle_regularizer.regularize();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* number of modified segments (angles) = "</span> &lt;&lt;</div><div class="line">    angle_regularization.number_of_modified_segments() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Offset regularization.</span></div><div class="line">  <span class="keyword">const</span> FT max_offset_2 = FT(1) / FT(10);</div><div class="line"></div><div class="line">  <span class="comment">// Get groups of parallel segments after angle regularization.</span></div><div class="line">  std::vector&lt;Indices&gt; pgroups;</div><div class="line">  angle_regularization.parallel_groups(</div><div class="line">    std::back_inserter(pgroups));</div><div class="line"></div><div class="line">  <span class="comment">// Create qp solver and offset-based regularization model.</span></div><div class="line">  Quadratic_program qp_offsets;</div><div class="line">  Offset_regularization offset_regularization(</div><div class="line">    segments, CGAL::parameters::maximum_offset(max_offset_2));</div><div class="line"></div><div class="line">  <span class="comment">// Add each group of parallel segments with at least 2 segments.</span></div><div class="line">  neighbor_query.clear();</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; pgroup : pgroups) {</div><div class="line">    neighbor_query.add_group(pgroup);</div><div class="line">    offset_regularization.add_group(pgroup);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Regularize.</span></div><div class="line">  Quadratic_offset_regularizer qp_offset_regularizer(</div><div class="line">    segments, neighbor_query, offset_regularization, qp_offsets);</div><div class="line">  qp_offset_regularizer.regularize();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* number of modified segments (offsets) = "</span> &lt;&lt;</div><div class="line">    offset_regularization.number_of_modified_segments() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save regularized segments.</span></div><div class="line">  <span class="keywordflow">if</span> (path != <span class="stringliteral">""</span>) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = path + <span class="stringliteral">"regularize_15_segments_after"</span>;</div><div class="line">    saver.export_eps_segments(segments, full_path, FT(100));</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>The second example contains 65 segments, which are constructed from a set of input points. All points are organized into groups such that each group represents an approximate 2D line. Organizing points into such groups can be achieved with the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgShapeDetection">Shape Detection</a> package. We fit a segment to each group of points using the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgPrincipalComponentAnalysisD">Principal Component Analysis</a> package. The angle and offset regularizations are performed on these segments sequentially using the bounds of 80 degrees and 2 unit lengths respectively.</p>
<p><a class="anchor" id="fig__regularize_real_data_2_example"></a></p><div class="image">
<object type="image/svg+xml" data="regularize_real_data_2.svg">regularize_real_data_2.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__regularize_real_data_2_example">Figure 82.7</a> A set of 2D segments before (red), after the angle (yellow), and the offset (green) regularization.  </div> <br /> 
<p><br />
<b>File</b> <a class="el" href="Shape_regularization_2regularize_real_data_2_8cpp-example.html">Shape_regularization/regularize_real_data_2.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include "include/utils.h"</span></div><div class="line"><span class="preprocessor">#include "include/Saver.h"</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Eigen_diagonalize_traits.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/linear_least_squares_fitting_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="regularize__segments_8h.html">CGAL/Shape_regularization/regularize_segments.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Typedefs.</span></div><div class="line"><span class="keyword">using</span> Kernel    = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div><div class="line"><span class="keyword">using</span> FT        = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"><span class="keyword">using</span> Point_2   = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>;</div><div class="line"><span class="keyword">using</span> Segment_2 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#aa6d2526f8d1571f4a38aa8a6d9a02c2b">Kernel::Segment_2</a>;</div><div class="line"><span class="keyword">using</span> Line_2    = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#add6b18567776ee7e80dfdfa44c304772">Kernel::Line_2</a>;</div><div class="line"><span class="keyword">using</span> Points_2  = std::vector&lt;Point_2&gt;;</div><div class="line"><span class="keyword">using</span> Indices   = std::vector&lt;std::size_t&gt;;</div><div class="line"><span class="keyword">using</span> Segments  = std::vector&lt;Segment_2&gt;;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Neighbor_query =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Delaunay__neighbor__query__2.html">CGAL::Shape_regularization::Segments::Delaunay_neighbor_query_2&lt;Kernel, Segments&gt;</a>;</div><div class="line"><span class="keyword">using</span> Angle_regularization =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Angle__regularization__2.html">CGAL::Shape_regularization::Segments::Angle_regularization_2&lt;Kernel, Segments&gt;</a>;</div><div class="line"><span class="keyword">using</span> Offset_regularization =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Offset__regularization__2.html">CGAL::Shape_regularization::Segments::Offset_regularization_2&lt;Kernel, Segments&gt;</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div><div class="line"></div><div class="line">  <span class="comment">// If we want to load a different file, we load it from a path.</span></div><div class="line">  <span class="comment">// Each point comes with the index of the corresponding group.</span></div><div class="line">  <span class="comment">// The file format: x y z i, where i is the group index. The points</span></div><div class="line">  <span class="comment">// are 2D hence z = 0. Each group contains points, which form</span></div><div class="line">  <span class="comment">// an approximate line.</span></div><div class="line">  std::string path = <span class="stringliteral">"data/real_data_2.xyzi"</span>;</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1) path = argv[1];</div><div class="line">  Saver&lt;Kernel&gt; saver;</div><div class="line"></div><div class="line">  <span class="comment">// Initialize input groups with points.</span></div><div class="line">  std::vector&lt;Points_2&gt; groups;</div><div class="line">  initialize_groups(path, groups);</div><div class="line"></div><div class="line">  <span class="comment">// Fit a line to each group of points.</span></div><div class="line">  Line_2 line; Point_2 <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__centroid__grp.html#gacc395064255dfefdb1420309db234210">centroid</a>;</div><div class="line">  std::vector&lt;Line_2&gt; lines;</div><div class="line">  lines.reserve(groups.size());</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; group : groups) {</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Principal_component_analysis.tag:../Principal_component_analysis/" href="../Principal_component_analysis/group__PkgPrincipalComponentAnalysisDLLSF2.html#gaf0d4435db5901ebe10cafd7de7c077f3">CGAL::linear_least_squares_fitting_2</a>(</div><div class="line">      group.begin(), group.end(), line, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__centroid__grp.html#gacc395064255dfefdb1420309db234210">centroid</a>, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Dimension__tag.html">CGAL::Dimension_tag&lt;0&gt;</a>(),</div><div class="line">      Kernel(), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classCGAL_1_1Eigen__diagonalize__traits.html">CGAL::Eigen_diagonalize_traits&lt;FT, 2&gt;</a>());</div><div class="line">    lines.push_back(line);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Cut each line at the ends of the corresponding group.</span></div><div class="line">  std::vector&lt;Segment_2&gt; segments;</div><div class="line">  segments.reserve(lines.size());</div><div class="line">  Point_2 source, target;</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; lines.size(); ++i) {</div><div class="line">    boundary_points_on_line_2(</div><div class="line">      groups[i], lines[i], source, target);</div><div class="line">    segments.push_back(Segment_2(source, target));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Save input segments.</span></div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 2) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = std::string(argv[2]) + <span class="stringliteral">"regularize_real_data_2_before"</span>;</div><div class="line">    saver.export_eps_segments(segments, full_path, FT(3) / FT(2));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Angle regularization.</span></div><div class="line">  <span class="keyword">const</span> FT max_angle_2 = FT(80);</div><div class="line"></div><div class="line">  <span class="comment">// Create neigbor query and angle-based regularization model.</span></div><div class="line">  Neighbor_query neighbor_query(segments);</div><div class="line">  Angle_regularization angle_regularization(</div><div class="line">    segments, CGAL::parameters::maximum_angle(max_angle_2));</div><div class="line"></div><div class="line">  <span class="comment">// Regularize.</span></div><div class="line">  <a class="code" href="group__PkgShapeRegularizationRefSegments.html#ga3cde2421ff91530c13c9e8f1feaeae1c">CGAL::Shape_regularization::Segments::regularize_segments</a>(</div><div class="line">    segments, neighbor_query, angle_regularization);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* number of modified segments (angles) = "</span> &lt;&lt;</div><div class="line">    angle_regularization.number_of_modified_segments() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Offset regularization.</span></div><div class="line">  <span class="keyword">const</span> FT max_offset_2 = FT(2);</div><div class="line"></div><div class="line">  <span class="comment">// Get groups of parallel segments after angle regularization.</span></div><div class="line">  std::vector&lt;Indices&gt; pgroups;</div><div class="line">  angle_regularization.parallel_groups(</div><div class="line">    std::back_inserter(pgroups));</div><div class="line"></div><div class="line">  <span class="comment">// Create offset-based regularization model.</span></div><div class="line">  Offset_regularization offset_regularization(</div><div class="line">    segments, CGAL::parameters::maximum_offset(max_offset_2));</div><div class="line"></div><div class="line">  <span class="comment">// Add each group of parallel segments with at least 2 segments.</span></div><div class="line">  neighbor_query.clear();</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; pgroup : pgroups) {</div><div class="line">    neighbor_query.add_group(pgroup);</div><div class="line">    offset_regularization.add_group(pgroup);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Regularize.</span></div><div class="line">  <a class="code" href="group__PkgShapeRegularizationRefSegments.html#ga3cde2421ff91530c13c9e8f1feaeae1c">CGAL::Shape_regularization::Segments::regularize_segments</a>(</div><div class="line">    segments, neighbor_query, offset_regularization);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* number of modified segments (offsets) = "</span> &lt;&lt;</div><div class="line">    offset_regularization.number_of_modified_segments() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save regularized segments.</span></div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 2) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = std::string(argv[2]) + <span class="stringliteral">"regularize_real_data_2_after"</span>;</div><div class="line">    saver.export_eps_segments(segments, full_path, FT(3) / FT(2));</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="QP_Regularization_Segments_Utils"></a>
Utility Functions</h2>
<p>In addition to the main algorithm, we also provide several utility functions, which are often used in conjunction with the algorithm.</p>
<h3><a class="anchor" id="QP_Regularization_Segments_Groups"></a>
Grouping Segments</h3>
<p>This CGAL component also provides three ways to group segments:</p><ul>
<li><code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#gac72eca9b32b73a3713edffd2da5609f2" title="finds groups of parallel segments in a set of 2D segments. ">Segments::parallel_groups()</a></code> - organizes a set of unordered 2D segments into groups of parallel segments.</li>
<li><code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#ga7fe1c4b39b16dee49ba9c41dc3c0b0f8" title="finds groups of orthogonal segments in a set of 2D segments. ">Segments::orthogonal_groups()</a></code> - organizes a set of unordered 2D segments into groups of orthogonal segments.</li>
<li><code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#ga7ade7f4682f9953fcf36669b2079f4d9" title="finds groups of collinear segments in a set of 2D segments. ">Segments::collinear_groups()</a></code> - organizes a set of unordered 2D segments into groups of collinear segments.</li>
</ul>
<p><a class="anchor" id="fig__parallel_groups"></a></p><div class="image">
<object type="image/svg+xml" data="groups.svg">groups.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__parallel_groups">Figure 82.8</a> Groups of near parallel (left), near orthogonal (center), and near collinear (right) segments. Red, green, blue colors indicate groups within each set of 2D segments.  </div> <br /> 
<p>The function <code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#gac72eca9b32b73a3713edffd2da5609f2" title="finds groups of parallel segments in a set of 2D segments. ">Segments::parallel_groups()</a></code> enables users to form groups of parallel segments. For example, if you know that all your segments are already near parallel to each other within some tolerance error and you do not want to orient them by applying the <a class="el" href="index.html#QP_Regularization_Segments_Angles">Angle Regularization</a> algorithm, but you still need to make them collinear by minimizing the offset among parallel segments using the <a class="el" href="index.html#QP_Regularization_Segments_Offset">Offset Regularization</a> algorithm, you can create the groups of parallel segments by using this function and provide them as input to the offset regularization algorithm as we do it <a class="el" href="index.html#QP_Parallel_Groups_Example">here</a>.</p>
<p>The other two functions serve a similar goal. The one <code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#ga7fe1c4b39b16dee49ba9c41dc3c0b0f8" title="finds groups of orthogonal segments in a set of 2D segments. ">Segments::orthogonal_groups()</a></code> first creates groups of parallel segments and then merges them into groups, where all segments are either parallel or orthogonal to each other. The one <code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#ga7ade7f4682f9953fcf36669b2079f4d9" title="finds groups of collinear segments in a set of 2D segments. ">Segments::collinear_groups()</a></code> first creates groups of parallel segments and then splits each of these groups into groups of collinear segments, if any.</p>
<dl class="section note"><dt>Note</dt><dd>Note that none of these functions applies the regularization of the input segments. They only return groups of indices of segments with similar orientations and/or positions.</dd></dl>
<h3><a class="anchor" id="QP_Regularization_Segments_Simplification"></a>
Simplifying Segments</h3>
<p>After regularizing angles and offsets, simplifying segments with similar properties is a common post-processing task. This CGAL component provides an utility function <code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#ga9312b7fea9ddc4beae7b166ccc4607df" title="substitutes groups of 2D collinear segments by average segments. ">Segments::unique_segments()</a></code> that takes a set of input segments, groups them with respect to the collinearity property, and then returns for each group of collinear segments a segment that best fits this group (see the figure below).</p>
<dl class="section note"><dt>Note</dt><dd>Even if the segments are far away from each other but close with respect to the orthogonal distance between them that is they are almost collinear, they will be merged as the blue segments in the figure.</dd></dl>
<p><a class="anchor" id="fig__unique_segments"></a></p><div class="image">
<object type="image/svg+xml" data="unique_segments.svg">unique_segments.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__unique_segments">Figure 82.9</a> Input segments with multiple collinear segments (left) are simplified into unique segments (right).  </div> <br /> 
<h2><a class="anchor" id="QP_Regularization_Segments_Performance"></a>
Performance</h2>
<p>The performance of the shape regularization algorithm mostly depends on the used QP solver. When using the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classCGAL_1_1OSQP__quadratic__program__traits.html">CGAL::OSQP_quadratic_program_traits</a></code> model, we exploit and efficiently use the sparse nature of the related QP problem that leads to quick performances in practice.</p>
<p>The plot (solid) below shows how the computation time depends on the number of input segments. We first observe that the most challenging step is angle regularization while the offset regularization is much faster. This is an effect of complexity reduction by segmenting the problem into groups for offset regularization. Since each group of parallel segments is much smaller than the original set of input segments, the total computation time is smaller, too. The same idea can be applied to accelerate the angle regularization. Splitting input segments into groups with contextually similar properties from the very beginning will lead to better performance as indicated in the plot (dashed). However, note that not each data set can be meaningfully split into such groups.</p>
<p>To benchmark the algorithm, we used a MacBook Pro 2018 with 2.2 GHz Intel Core i7 processor (6 cores) and 32 GB 2400 MHz DDR4 memory. The installed operating system was OS X 10.15 Catalina. We first create a set of random segments in a square such that all segments are either parallel to the X axis or Y axis. We then slightly perturb all segments by a random angle within the interval [-15, 15] degrees and apply the regularization algorithm 10 times on the same input. The returned time is the average time over all iterations. In the pre-grouped version, we regroup all segments into groups of 10 segments and the regularization algorithm is applied to each group. For example, in case of 50 input segments, we will have 5 input groups. Since the groups are very small, there is no much difference in time between angle and offset regularizations. The results are shown in the figure below.</p>
<p><a class="anchor" id="fig__qp_segments_bench"></a></p><div class="image">
<object type="image/svg+xml" data="qp_segments_bench.svg">qp_segments_bench.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__qp_segments_bench">Figure 82.10</a> Time in seconds to regularize angles (solid red) and offsets (solid green) without regrouping input segments and with the groups of 10 segments for angles (dashed red) and offsets (dashed green).  </div> <br /> 
<h1><a class="anchor" id="Contour_Regularization"></a>
Contours</h1>
<p>Given a set of ordered 2D points connected by segments, which form a contour, closed or open, users can reinforce three types of regularities among consecutive edges of this contour:</p><ul>
<li><em>Parallelism</em>: contour edges, which are detected as near parallel, are made exactly parallel.</li>
<li><em>Orthogonality</em>: contour edges, which are detected as near orthogonal, are made exactly orthogonal.</li>
<li><em>Collinearity</em>: parallel contour edges, which are detected as near collinear, are made exactly collinear.</li>
</ul>
<p>A typical use of this algorithm consists of the following steps:</p><ol type="1">
<li>Specify a type of the contour, open or closed;</li>
<li>Create an instance of the class <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1ContourDirections.html" title="We assume that each contour has one or several principal directions. By implementing a model of this ...">ContourDirections</a></code> with the proper parameters;</li>
<li>Call the function <code><a class="el" href="group__PkgShapeRegularizationRefContours.html#ga7e2f3e7e76c52a3acef42a0d413a17c6" title="regularizes closed contours. ">regularize_closed_contour()</a></code> or <code><a class="el" href="group__PkgShapeRegularizationRefContours.html#gae860b28fa0fde23f6f6540f483b4ecff" title="regularizes open contours. ">regularize_open_contour()</a></code>.</li>
</ol>
<p>We assume that each contour has at least one principal direction that is a reference direction towards which the contour edges are rotated. Given a set of such directions either estimated or user-specified, each edge is made either parallel or orthogonal to these direction(s).</p>
<p>To estimate principal directions of the contour, this component provides three models of the concept <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1ContourDirections.html" title="We assume that each contour has one or several principal directions. By implementing a model of this ...">ContourDirections</a></code>:</p><ul>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1Contours_1_1Longest__direction__2.html" title="Estimates the longest principal direction of the contour. ">Contours::Longest_direction_2</a></code> - sets the longest contour edge as the only principal direction.</li>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1Contours_1_1Multiple__directions__2.html" title="Estimates possibly multiple principal directions of the contour based on the user-specified minimum l...">Contours::Multiple_directions_2</a></code> - tries to estimate multiple principal directions in the contour based on the user-specified parameters (see the figure below).</li>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1Contours_1_1User__defined__directions__2.html" title="Sets multiple user-specified principal directions of the contour. ">Contours::User_defined_directions_2</a></code> - sets the user-specified principal directions as contour directions.</li>
</ul>
<p><a class="anchor" id="fig__multiple_directions"></a></p><div class="image">
<object type="image/svg+xml" data="multiple_directions.svg">multiple_directions.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__multiple_directions">Figure 82.11</a> A closed contour before (red) and after (green) the contour regularization. The found principal directions are marked yellow.  </div> <br /> 
<p>After the directions are set, the algorithm is linear in the number of contour edges. It first goes through each contour edge and orients it towards the best-fit direction. In the second step, all parallel consecutive edges are merged if they are within a user-specified maximum tolerance distance. The distance here is defined as the distance between the midpoint of the first edge and the projection of this point onto the supporting line of the next edge. The position of the merged segment is optimized with respect to its neighbors. In the last steps, all segments are reconnected into a contour as shown in the figure below. Due to the merging step, the number of output edges in the contour is not necessarily the same as the number of input edges.</p>
<p><a class="anchor" id="fig__contours_pipeline"></a></p><div class="image">
<object type="image/svg+xml" data="contours_pipeline.svg">contours_pipeline.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__contours_pipeline">Figure 82.12</a> Steps of the contour regularization algorithm (from left to right): the closed contour before regularization; the disconnected contour with edges rotated towards the found principal directions, here we have only one direction; the optimized edges, blue edges were merged and their positions were optimized; and the final reconnected contour.  </div> <br /> 
<p>If the user wants to rotate each contour edge on its own towards the best-fit direction without reconnecting them after into a closed/open contour, she can either use the <a class="el" href="index.html#QP_Regularization_Segments">Segment Regularization</a> algorithm or she can orient each segment by calling the <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1ContourDirections.html#a07f23b0d134d1dfb32158f485aab15b8" title="orients a given segment with the index query_index towards the best-fit direction of the contour...">ContourDirections::orient()</a></code> method.</p>
<p>The example below shows the most straightforward entry point to the algorithm, where we regularize a simple closed contour. The algorithm is called via the function <code><a class="el" href="group__PkgShapeRegularizationRefContours.html#ga7e2f3e7e76c52a3acef42a0d413a17c6" title="regularizes closed contours. ">regularize_closed_contour()</a></code>.</p>
<p><a class="anchor" id="fig__regularize_contour_example"></a></p><div class="image">
<object type="image/svg+xml" data="regularize_contour.svg">regularize_contour.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__regularize_contour_example">Figure 82.13</a> A closed contour before (red) and after (green) regularization.  </div> <br /> 
<p><br />
<b>File</b> <a class="el" href="Shape_regularization_2regularize_contour_8cpp-example.html">Shape_regularization/regularize_contour.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="regularize__contours_8h.html">CGAL/Shape_regularization/regularize_contours.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> Kernel  = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> Point_2 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">  <span class="comment">// Create input contour.</span></div><div class="line">  <span class="keyword">const</span> std::vector&lt;Point_2&gt; contour = {</div><div class="line">    Point_2(0.00,  0.00),</div><div class="line">    Point_2(0.50, -0.05),</div><div class="line">    Point_2(1.00,  0.00),</div><div class="line">    Point_2(1.05,  0.50),</div><div class="line">    Point_2(1.00,  1.00),</div><div class="line">    Point_2(0.00,  1.00)</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="comment">// Regularize this contour.</span></div><div class="line">  std::vector&lt;Point_2&gt; regularized;</div><div class="line">  <a class="code" href="group__PkgShapeRegularizationRefContours.html#ga7e2f3e7e76c52a3acef42a0d413a17c6">CGAL::Shape_regularization::Contours::</a></div><div class="line"><a class="code" href="group__PkgShapeRegularizationRefContours.html#ga7e2f3e7e76c52a3acef42a0d413a17c6">    regularize_closed_contour</a>(contour, std::back_inserter(regularized));</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Contour_Regularization_Closed"></a>
Closed Contours</h2>
<p>In the example below, we regularize a closed contour. We use multiple directions estimator, which returns only one direction, because the contour is quite rectilinear. In fact, the returned direction in this case coincides with the longest edge direction.</p>
<p><a class="anchor" id="fig__regularize_closed_contour_example"></a></p><div class="image">
<object type="image/svg+xml" data="regularize_closed_contour.svg">regularize_closed_contour.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__regularize_closed_contour_example">Figure 82.14</a> A closed contour before (red) and after (green) the contour regularization.  </div> <br /> 
<p><br />
<b>File</b> <a class="el" href="Shape_regularization_2regularize_closed_contour_8cpp-example.html">Shape_regularization/regularize_closed_contour.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include "include/utils.h"</span></div><div class="line"><span class="preprocessor">#include "include/Saver.h"</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="regularize__contours_8h.html">CGAL/Shape_regularization/regularize_contours.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Typedefs.</span></div><div class="line"><span class="keyword">using</span> Kernel  = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div><div class="line"><span class="keyword">using</span> FT      = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"><span class="keyword">using</span> Point_2 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>;</div><div class="line"><span class="keyword">using</span> Contour = std::vector&lt;Point_2&gt;;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Contour_directions =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Contours_1_1Multiple__directions__2.html">CGAL::Shape_regularization::Contours::Multiple_directions_2&lt;Kernel, Contour&gt;</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div><div class="line"></div><div class="line">  <span class="comment">// If we want to load a different file, we load it from a path.</span></div><div class="line">  std::string path = <span class="stringliteral">"data/contour.polylines"</span>;</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1) path = argv[1];</div><div class="line">  Saver&lt;Kernel&gt; saver;</div><div class="line"></div><div class="line">  <span class="comment">// Set parameters.</span></div><div class="line">  <span class="keyword">const</span> FT min_length_2 = FT(2);</div><div class="line">  <span class="keyword">const</span> FT  max_angle_2 = FT(20);</div><div class="line">  <span class="keyword">const</span> FT max_offset_2 = FT(2);</div><div class="line"></div><div class="line">  <span class="comment">// Initialize contour.</span></div><div class="line">  std::vector&lt;Point_2&gt; contour;</div><div class="line">  initialize_contour(path, contour);</div><div class="line"></div><div class="line">  <span class="comment">// Save input contour.</span></div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 2) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = std::string(argv[2]) + <span class="stringliteral">"regularize_closed_contour_before"</span>;</div><div class="line">    saver.export_eps_closed_contour(contour, full_path, FT(8));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Regularize.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#gae04c8044cf1eee6a84baa5b79ab99fef">is_closed</a> = <span class="keyword">true</span>;</div><div class="line">  Contour_directions directions(</div><div class="line">    contour, is_closed, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL_1_1parameters.html">CGAL::parameters</a>::</div><div class="line">    minimum_length(min_length_2).maximum_angle(max_angle_2));</div><div class="line"></div><div class="line">  std::vector&lt;Point_2&gt; regularized;</div><div class="line">  <a class="code" href="group__PkgShapeRegularizationRefContours.html#ga7e2f3e7e76c52a3acef42a0d413a17c6">CGAL::Shape_regularization::Contours::regularize_closed_contour</a>(</div><div class="line">    contour, directions, std::back_inserter(regularized),</div><div class="line">    CGAL::parameters::maximum_offset(max_offset_2));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* number of directions = "</span> &lt;&lt;</div><div class="line">    directions.number_of_directions() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save regularized contour.</span></div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 2) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = std::string(argv[2]) + <span class="stringliteral">"regularize_closed_contour_after"</span>;</div><div class="line">    saver.export_eps_closed_contour(regularized, full_path, FT(8));</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Contour_Regularization_Open"></a>
Open Contours</h2>
<p>Open contours are contours where the head and tail of the contour are not connected. This case requires a special treatment, but the core of the algorithm is the same. In the example below, we regularize an open contour with respect to its longest edge. This example also shows how to provide a property map to the algorithm in order to give the algorithm access to the coordinates of the contour vertices.</p>
<p><a class="anchor" id="fig__regularize_open_contour_example"></a></p><div class="image">
<object type="image/svg+xml" data="regularize_open_contour.svg">regularize_open_contour.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__regularize_open_contour_example">Figure 82.15</a> An open contour before (red) and after (green) the contour regularization.  </div> <br /> 
<p><br />
<b>File</b> <a class="el" href="Shape_regularization_2regularize_open_contour_8cpp-example.html">Shape_regularization/regularize_open_contour.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include "include/utils.h"</span></div><div class="line"><span class="preprocessor">#include "include/Saver.h"</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="regularize__contours_8h.html">CGAL/Shape_regularization/regularize_contours.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Typedefs.</span></div><div class="line"><span class="keyword">using</span> Kernel  = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div><div class="line"><span class="keyword">using</span> FT      = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"><span class="keyword">using</span> Point_2 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>;</div><div class="line"><span class="keyword">using</span> Contour = std::vector&lt;Point_2&gt;;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Contour_directions =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Contours_1_1Longest__direction__2.html">CGAL::Shape_regularization::Contours::Longest_direction_2&lt;Kernel, Contour&gt;</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div><div class="line"></div><div class="line">  <span class="comment">// If we want to load a different file, we load it from a path.</span></div><div class="line">  std::string path = <span class="stringliteral">"data/contour.polylines"</span>;</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1) path = argv[1];</div><div class="line">  Saver&lt;Kernel&gt; saver;</div><div class="line"></div><div class="line">  <span class="comment">// Set parameters.</span></div><div class="line">  <span class="keyword">const</span> FT max_offset_2 = FT(2);</div><div class="line"></div><div class="line">  <span class="comment">// Initialize contour.</span></div><div class="line">  std::vector&lt;Point_2&gt; contour;</div><div class="line">  initialize_contour(path, contour);</div><div class="line"></div><div class="line">  <span class="comment">// Save input contour.</span></div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 2) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = std::string(argv[2]) + <span class="stringliteral">"regularize_open_contour_before"</span>;</div><div class="line">    saver.export_eps_open_contour(contour, full_path, FT(8));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Regularize.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span> is_closed = <span class="keyword">false</span>;</div><div class="line">  Contour_directions directions(contour, is_closed);</div><div class="line"></div><div class="line">  std::vector&lt;Point_2&gt; regularized;</div><div class="line">  <a class="code" href="group__PkgShapeRegularizationRefContours.html#gae860b28fa0fde23f6f6540f483b4ecff">CGAL::Shape_regularization::Contours::regularize_open_contour</a>(</div><div class="line">    contour, directions, std::back_inserter(regularized),</div><div class="line">    CGAL::parameters::maximum_offset(max_offset_2));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* number of directions = "</span> &lt;&lt;</div><div class="line">    directions.number_of_directions() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save regularized contour.</span></div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 2) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = std::string(argv[2]) + <span class="stringliteral">"regularize_open_contour_after"</span>;</div><div class="line">    saver.export_eps_open_contour(regularized, full_path, FT(8));</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Contour_Regularization_Performance"></a>
Performance</h2>
<p>The contour regularization algorithms, both closed and open, have, in practice, a linear time behavior with respect to the number of contour vertices. In fact, the time is not linear, as you can see in the plot below, due to the second step of merging consecutive collinear edges. For some polygons, the number of such edges is quite high and before merging them into one segment, we collect all of them into a group in order to find the best optimal position to place the final segment that may lead to a slower performance in some cases.</p>
<p>To benchmark the algorithm, we used a MacBook Pro 2018 with 2.2 GHz Intel Core i7 processor (6 cores) and 32 GB 2400 MHz DDR4 memory. The installed operating system was OS X 10.15 Catalina. We first create a rectilinear polygon with the required number of edges. We then slightly perturb all edges by a random angle within the interval [-15, 15] degrees and apply the regularization algorithm 10 times on the same input. The returned time is the average time over all iterations. The results are shown in the figure below.</p>
<p><a class="anchor" id="fig__contours_bench"></a></p><div class="image">
<object type="image/svg+xml" data="contours_bench.svg">contours_bench.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__contours_bench">Figure 82.16</a> Time in seconds to regularize closed (red) and open (green) contours.  </div> <br /> 
<h1><a class="anchor" id="Plane_Regularization"></a>
Planes</h1>
<p>Given a set of 3D planes with their corresponding inlier sets, users can reinforce four types of regularities among these planes using the function <code><a class="el" href="group__PkgShapeRegularizationRefPlanes.html#ga9ace5aafd056ce9ccb348c96e38d361a" title="Hierarchical plane regularization. ">regularize_planes()</a></code>:</p><ul>
<li><em>Parallelism</em>: planes, which are detected as near parallel, are made exactly parallel.</li>
<li><em>Orthogonality</em>: planes, which are detected as near orthogonal, are made exactly orthogonal.</li>
<li><em>Coplanarity</em>: parallel planes, which are detected as near coplanar, are made exactly coplanar.</li>
<li><em>Axis-Symmetry</em>: planes, which are detected as near symmetrical with respect to a user-specified axis, are made exactly symmetrical.</li>
</ul>
<p>The user can choose to regularize only one or several of these four properties. The process is greedy and based on a hierarchical decomposition (coplanar clusters are subgroups of parallel clusters, which are subgroups of axis-symmetric and orthogonal clusters) as described by Verdie et al. in <a class="el" href="citelist.html#CITEREF_cgal:vla-lod-15">[2]</a>.</p>
<p>The following example illustrates how to use the plane regularization function.</p>
<p><br />
<b>File</b> <a class="el" href="Shape_regularization_2regularize_planes_8cpp-example.html">Shape_regularization/regularize_planes.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include "include/utils.h"</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/Efficient__RANSAC_8h.html">CGAL/Shape_detection/Efficient_RANSAC.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="regularize__planes_8h.html">CGAL/Shape_regularization/regularize_planes.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Typedefs.</span></div><div class="line"><span class="keyword">using</span> Kernel   = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div><div class="line"><span class="keyword">using</span> FT       = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"><span class="keyword">using</span> Point_3  = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ae82b7f4be77dd5b8819ebe419e4ae753">Kernel::Point_3</a>;</div><div class="line"><span class="keyword">using</span> Vector_3 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a39fb0222695ae5e7e32f4e570ea28225">Kernel::Vector_3</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Point_with_normal = std::pair&lt;Point_3, Vector_3&gt;;</div><div class="line"><span class="keyword">using</span> Point_map         = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Point_with_normal&gt;</a>;</div><div class="line"><span class="keyword">using</span> Normal_map        = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;Point_with_normal&gt;</a>;</div><div class="line"><span class="keyword">using</span> Pwn_vector        = std::vector&lt;Point_with_normal&gt;;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Traits    = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/structCGAL_1_1Shape__detection_1_1Efficient__RANSAC__traits.html">CGAL::Shape_detection::Efficient_RANSAC_traits&lt;Kernel, Pwn_vector, Point_map, Normal_map&gt;</a>;</div><div class="line"><span class="keyword">using</span> RANSAC    = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Efficient__RANSAC.html">CGAL::Shape_detection::Efficient_RANSAC&lt;Traits&gt;</a>;</div><div class="line"><span class="keyword">using</span> Plane     = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Plane.html">CGAL::Shape_detection::Plane&lt;Traits&gt;</a>;</div><div class="line"><span class="keyword">using</span> Plane_map = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Plane__map.html">CGAL::Shape_detection::Plane_map&lt;Traits&gt;</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div><div class="line"></div><div class="line">  <span class="comment">// If we want to load a different file, we load it from a path.</span></div><div class="line">  std::string path = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/cube.pwn"</span>);</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1) path = argv[1];</div><div class="line"></div><div class="line">  Pwn_vector points;</div><div class="line">  std::ifstream file(path.c_str(), std::ios_base::in);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7d51c854b865a7eb367e21fc43bd37b8">CGAL::IO::set_ascii_mode</a>(file);</div><div class="line">  file.precision(20);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (!file ||</div><div class="line">    !CGAL::IO::read_XYZ(</div><div class="line">      file,</div><div class="line">      std::back_inserter(points),</div><div class="line">      CGAL::parameters::point_map(Point_map()).</div><div class="line">      normal_map(Normal_map()))) {</div><div class="line"></div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read the file cube.pwn!"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line">  file.close();</div><div class="line"></div><div class="line">  <span class="comment">// Call RANSAC shape detection with planes.</span></div><div class="line">  RANSAC efficient_ransac;</div><div class="line">  efficient_ransac.set_input(points);</div><div class="line">  efficient_ransac.add_shape_factory&lt;Plane&gt;();</div><div class="line">  efficient_ransac.detect();</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> planes = efficient_ransac.planes();</div><div class="line"></div><div class="line">  <span class="comment">// Regularize detected planes.</span></div><div class="line">  <a class="code" href="group__PkgShapeRegularizationRefPlanes.html#ga9ace5aafd056ce9ccb348c96e38d361a">CGAL::Shape_regularization::Planes::regularize_planes</a>(</div><div class="line">    planes,</div><div class="line">    points,</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL_1_1parameters.html">CGAL::parameters</a>::</div><div class="line">    plane_map(Plane_map()).</div><div class="line">    point_map(Point_map()).</div><div class="line">    plane_index_map(</div><div class="line">      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Point__to__shape__index__map.html">CGAL::Shape_detection::Point_to_shape_index_map&lt;Traits&gt;</a>(points, planes)).</div><div class="line">    regularize_coplanarity(<span class="keyword">false</span>). <span class="comment">// do not regularize coplanarity</span></div><div class="line">    maximum_angle(FT(10))); <span class="comment">// 10 degrees of tolerance for parallelism / orthogonality</span></div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* all detected planes are regularized"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Please note that this function used to be a part of the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgShapeDetection">Shape Detection</a> package. You can still use the old API of that function, however to avoid parameters ambiguity, we strongly suggest to use the new API with the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/index.html#BGLNamedParameters">Named Parameters</a> mechanism.</dd></dl>
<h1><a class="anchor" id="QP_Regularization"></a>
QP Regularization</h1>
<p>The shape regularization component is a generic framework that is based on the Quadratic Programming (QP) global regularization algorithm <a class="el" href="citelist.html#CITEREF_cgal:bl-kippi-18">[1]</a> by Bauchet et Lafarge. You should refer to this section only if you want to know details on how the shape regularization framework is organized internally or you want to extend that framework by implementing your own regularization types.</p>
<p><a class="el" href="index.html#QP_Regularization_Segments_Angles">Angle Regularization</a> and <a class="el" href="index.html#QP_Regularization_Segments_Offset">Offset Regularization</a> that we presented before are two particular instances of this algorithm. Other instances can be added by the user, as explained <a class="el" href="index.html#QP_Regularization_Implementation">here</a>.</p>
<h2><a class="anchor" id="QP_Regularization_Framework"></a>
Framework</h2>
<p>This framework follows Section 3 from <a class="el" href="citelist.html#CITEREF_cgal:bl-kippi-18">[1]</a>, however the algorithm from that paper was extended and generalized. The idea behind the main algorithm is to minimize the energy</p>
<center> \(U(\boldsymbol{x}) = (1 - \lambda) D(\boldsymbol{x}) + \lambda V(\boldsymbol{x})\),</center><p>where \(\boldsymbol{x} = (x_1, \dots, x_n)\) is a configuration of perturbations operated on \(n\) input items, \(D(\boldsymbol{x})\) and \(V(\boldsymbol{x})\) represent a data term and pairwise potential respectively, and \(\lambda \in [0, 1]\) is a parameter weighting these two terms. By setting up the correct types of \(D(\boldsymbol{x})\) and \(V(\boldsymbol{x})\), the problem can be reformulated into a quadratic optimization problem with \((n + m)\) variables and \(2(n + m)\) linear constraints, where \(m\) is the number of unique pairs formed by connecting an item to one of its closest neighbors. Let us explain how it all works when the input items are segments and we want to regularize their orientations in order to reinforce parallelism and orthogonality among them.</p>
<p>To set up the framework, we first need to find closest neighbors for each segment. These neighbors are provided via the concept <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1NeighborQuery.html" title="A concept that describes the set of methods used by the class QP_regularization to access neighbors o...">NeighborQuery</a></code>. Internally, we create a graph based on these neighbors. Every edge \(\{i, j\}\), where \(i\) is the index of the ith segment and \(j\) is the index of the jth segment is inserted in the graph whenever \(i &lt; j\). This way each pair is inserted only once. The neighbors are found via the <a class="el" href="index.html#QP_Regularization_Segments_Delaunay">Delaunay Neighbor Query</a>.</p>
<p>When we have the graph, we fill in the terms \(D(\boldsymbol{x})\) and \(V(\boldsymbol{x})\) via the concept <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html" title="A concept that describes the set of methods used by the class QP_regularization to access various dat...">RegularizationType</a></code>. First, we obtain a maximum perturbation bound for each segment via the method <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html#a6425688d6368960b0aa5bfd0e6e13541" title="returns the maximum bound on a regularization characteristic (angle-orientation/ distance-offset/etc...">RegularizationType::bound()</a></code>. Since we want to rotate segments, we return here the maximum allowed angle deviation for each segment with respect to its original orientation, lets say 25 degrees.</p>
<p>Next, for every edge \(\{i, j\}\) in the graph, we compute the perturbation difference between two segments \(i\) and \(j\) via the method <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html#ac5bd68e930f080c0b619b3541c5fad9c" title="returns an objective function value between two geometric objects, which are direct neighbors...">RegularizationType::target()</a></code>. For example, that could be a difference of segment orientations with respect to \(90\) or \(180\) degrees. Lets say an angle between two segments is \(85\) degrees then we return \(90 - 85 = 5\) degrees since this is what we should minimize in order to make the two segments orthogonal to each other.</p>
<p>Then we set up the quadratic programming problem that is solved via the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classQuadraticProgramTraits.html">QuadraticProgramTraits</a></code> concept. The returned result is stored as a vector of the length \((n + m)\) with the updated perturbation values, where the first \(n\) values are the values that should be added to the original orientations of the input segments in order to update them and the last \(m\) values are minimized to zeros. The update is achieved via the method <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html#a5fa1b89221a8d2515acff817ceeb6946" title="updates regularization characteristics (angle-orientation/distance-offset/etc.) of the geometric obje...">RegularizationType::update()</a></code>.</p>
<p>Overall, the class <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1QP__regularization.html" title="Shape regularization algorithm based on the quadratic programming global optimization. ">QP_regularization</a></code> is parameterized by:</p><ul>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1NeighborQuery.html" title="A concept that describes the set of methods used by the class QP_regularization to access neighbors o...">NeighborQuery</a></code> that provides the means for accessing local neighbors of an item,</li>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html" title="A concept that describes the set of methods used by the class QP_regularization to access various dat...">RegularizationType</a></code> that determines a regularization type to be applied, and</li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classQuadraticProgramTraits.html">QuadraticProgramTraits</a></code> that is used to solve the corresponding QP problem.</li>
</ul>
<p>Within this generic framework, users can regularize any set of input items provided their own neighbor search, regularization type, and QP solver.</p>
<h2><a class="anchor" id="QP_Regularization_Neighborhood"></a>
Neighborhood</h2>
<p>The concept <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1NeighborQuery.html" title="A concept that describes the set of methods used by the class QP_regularization to access neighbors o...">NeighborQuery</a></code> provides the means for accessing local neighbors of an item. To create a model that respects this concept, the user has to provide an overload of the operator:</p>
<ul>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1NeighborQuery.html#afe9ac86f81427f217a72ee74523e4ade" title="fills in neighbors with indices of all geometric objects, which are direct neighbors of the object wi...">NeighborQuery::operator()()</a></code> that has to fill in a vector with indices of all items, which are neighbors of the query item.</li>
</ul>
<p>For example, given a segment, this operator may return a vector with indices of some other input segments, which are within a certain distance from this segment, however this distance is measured. See above and <a class="el" href="index.html#QP_Regularization_Segments_Delaunay">this section</a> for more details.</p>
<h2><a class="anchor" id="QP_Regularization_Type"></a>
Regularization</h2>
<p>The concept <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html" title="A concept that describes the set of methods used by the class QP_regularization to access various dat...">RegularizationType</a></code> determines a type of regularization to be applied. To create a model that respects this concept, three functions have to be defined:</p>
<ul>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html#ac5bd68e930f080c0b619b3541c5fad9c" title="returns an objective function value between two geometric objects, which are direct neighbors...">RegularizationType::target()</a></code> a function that estimates a type of regularity between two neighbors,</li>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html#a6425688d6368960b0aa5bfd0e6e13541" title="returns the maximum bound on a regularization characteristic (angle-orientation/ distance-offset/etc...">RegularizationType::bound()</a></code> a function that returns a maximum bound on the allowed regularity change, and</li>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html#a5fa1b89221a8d2515acff817ceeb6946" title="updates regularization characteristics (angle-orientation/distance-offset/etc.) of the geometric obje...">RegularizationType::update()</a></code> a function that updates input items with respect to the modified regularities.</li>
</ul>
<p>For example, if we want to regularize segment orientations, that is to make segments parallel and orthogonal to each other, the first function should return an angle perturbation between a query segment and each of its neighbors; the second function should return a maximum angle within which a rotation of the query segment is accepted; and the third function should update original orientations of the input segments. See above and <a class="el" href="index.html#QP_Regularization_Segments_Angles">this section</a> for more details.</p>
<h2><a class="anchor" id="QP_Regularization_Solvers"></a>
Solvers</h2>
<p>In order to solve the associated QP problem of the algorithm above, CGAL provides a wrapper <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classCGAL_1_1OSQP__quadratic__program__traits.html">CGAL::OSQP_quadratic_program_traits</a></code> of the external <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartyOSQP">OSQP solver</a> that is a model of the concept <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classQuadraticProgramTraits.html">QuadraticProgramTraits</a></code>.</p>
<p>Alternatively, the internal CGAL solver from the package <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgQPSolver">Linear and Quadratic Programming Solver</a> can be used, however we do not recommend applying it. The internal quadratic program that has to be solved for shape regularization is sparse. The CGAL version will internally convert this problem into a dense one that takes considerable effort to solve, while the OSQP version takes a special care of the sparse nature of the problem that leads to better performance. Since the class <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1QP__regularization.html" title="Shape regularization algorithm based on the quadratic programming global optimization. ">QP_regularization</a></code> is parameterized by the general concept <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classQuadraticProgramTraits.html">QuadraticProgramTraits</a></code>, the users are also welcome to provide their own version of the solver.</p>
<h2><a class="anchor" id="QP_Regularization_Implementation"></a>
Implementation</h2>
<p>If you want to implement your own regularization approach that follows the same framework, for example to reinforce a different type of regularity than is already provided, you have to implement your own model of the <a class="el" href="index.html#QP_Regularization_Type">RegularizationType</a> concept and possibly a model of the <a class="el" href="index.html#QP_Regularization_Neighborhood">NeighborQuery</a> concept. These concepts are used to parameterize the main <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1QP__regularization.html" title="Shape regularization algorithm based on the quadratic programming global optimization. ">QP_regularization</a></code> algorithm:</p><ol type="1">
<li>Use <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1NeighborQuery.html" title="A concept that describes the set of methods used by the class QP_regularization to access neighbors o...">NeighborQuery</a></code> to find local neighbors of each input item;</li>
<li>Use <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html" title="A concept that describes the set of methods used by the class QP_regularization to access various dat...">RegularizationType</a></code> to estimate current regularities among these neighbors;</li>
<li>Use <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html" title="A concept that describes the set of methods used by the class QP_regularization to access various dat...">RegularizationType</a></code> to set maximum bounds on the allowed regularity changes;</li>
<li>Use <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classQuadraticProgramTraits.html">QuadraticProgramTraits</a></code> to solve the quadratic programming problem;</li>
<li>Use <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html" title="A concept that describes the set of methods used by the class QP_regularization to access various dat...">RegularizationType</a></code> to update input items with respect to the modified regularities.</li>
</ol>
<p>In addition, the user may also want to change a <a class="el" href="index.html#QP_Regularization_Solvers">QP solver</a> if he knows how to optimize it for a specific type of input data. To do that, the user has to implement a model of the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classQuadraticProgramTraits.html">QuadraticProgramTraits</a></code> concept.</p>
<p>An example below shows how to define your own type of the above concepts and how to choose among available solvers.</p>
<p><br />
<b>File</b> <a class="el" href="Shape_regularization_2regularize_framework_8cpp-example.html">Shape_regularization/regularize_framework.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Shape__regularization_8h.html">CGAL/Shape_regularization.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> Kernel = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> FT     = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Custom_object {</div><div class="line">  <span class="keyword">const</span> std::string name;</div><div class="line">  Custom_object(<span class="keyword">const</span> std::string name_) :</div><div class="line">  name(name_) { }</div><div class="line">  <span class="comment">// define your object here</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Custom_neighbor_query_2 {</div><div class="line">  <span class="keywordtype">void</span> operator()(</div><div class="line">    <span class="keyword">const</span> std::size_t query_index, std::vector&lt;std::size_t&gt;&amp; neighbors) {</div><div class="line">    neighbors.clear();</div><div class="line">    <span class="keywordflow">if</span> (query_index == 0) { neighbors.push_back(1); } <span class="comment">// first  object</span></div><div class="line">    <span class="keywordflow">if</span> (query_index == 1) { neighbors.push_back(0); } <span class="comment">// second object</span></div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Custom_regularization_2 {</div><div class="line">  FT bound(<span class="keyword">const</span> std::size_t )<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> FT(5); <span class="comment">// maximum angle change</span></div><div class="line">  }</div><div class="line">  FT target(<span class="keyword">const</span> std::size_t , <span class="keyword">const</span> std::size_t ) {</div><div class="line">    <span class="keywordflow">return</span> FT(0); <span class="comment">// 0 angle change</span></div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> update(<span class="keyword">const</span> std::vector&lt;FT&gt;&amp; ) {</div><div class="line">    <span class="comment">// skip update</span></div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> NT&gt;</div><div class="line"><span class="keyword">class </span>Custom_quadratic_program_traits  {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keywordtype">void</span>  set_P(<span class="keyword">const</span> std::size_t, <span class="keyword">const</span> std::size_t, <span class="keyword">const</span> FT) { }</div><div class="line">  <span class="keywordtype">void</span>  set_q(<span class="keyword">const</span> std::size_t, <span class="keyword">const</span> FT) { }</div><div class="line">  <span class="keywordtype">void</span>  set_r(<span class="keyword">const</span> FT) { }</div><div class="line">  <span class="keywordtype">void</span>  set_A(<span class="keyword">const</span> std::size_t, <span class="keyword">const</span> std::size_t, <span class="keyword">const</span> FT) { }</div><div class="line">  <span class="keywordtype">void</span>  set_l(<span class="keyword">const</span> std::size_t, <span class="keyword">const</span> FT) { }</div><div class="line">  <span class="keywordtype">void</span>  set_u(<span class="keyword">const</span> std::size_t, <span class="keyword">const</span> FT) { }</div><div class="line">  <span class="keywordtype">void</span> resize(<span class="keyword">const</span> std::size_t, <span class="keyword">const</span> std::size_t) { }</div><div class="line"></div><div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> OutputIterator&gt;</div><div class="line">  <span class="keywordtype">bool</span> solve(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classOutputIterator.html">OutputIterator</a> solution) {</div><div class="line"></div><div class="line">    <span class="comment">// 3 = 2 objects + 1 edge between them</span></div><div class="line">    <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; 3; ++i) {</div><div class="line">      *(++solution) = NT(0);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">using</span> Objects = std::vector&lt;Custom_object&gt;;</div><div class="line"><span class="keyword">using</span> Neighbor_query = Custom_neighbor_query_2;</div><div class="line"><span class="keyword">using</span> Regularization_type = Custom_regularization_2;</div><div class="line"><span class="keyword">using</span> Quadratic_program = Custom_quadratic_program_traits&lt;FT&gt;;</div><div class="line"><span class="keyword">using</span> Regularizer = <a class="code" href="classCGAL_1_1Shape__regularization_1_1QP__regularization.html">CGAL::Shape_regularization::QP_regularization</a>&lt;</div><div class="line">  Kernel, Objects, Neighbor_query, Regularization_type, Quadratic_program&gt;;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">  Neighbor_query neighbor_query;</div><div class="line">  Regularization_type regularization_type;</div><div class="line">  Quadratic_program quadratic_program;</div><div class="line"></div><div class="line">  std::vector&lt;Custom_object&gt; objects = {</div><div class="line">    Custom_object(<span class="stringliteral">"first"</span>), Custom_object(<span class="stringliteral">"second"</span>)</div><div class="line">  };</div><div class="line"></div><div class="line">  Regularizer regularizer(</div><div class="line">    objects, neighbor_query, regularization_type, quadratic_program);</div><div class="line">  regularizer.regularize();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* regularized 2 objects"</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Shape_Regularization_History"></a>
History</h1>
<p>The shape regularization algorithm for 2D segments was first implemented by Jean-Philippe Bauchet under the supervision of Florent Lafarge and then generalized by Gennadii Sytov during the Google Summer of Code 2019 under the supervision of Dmitry Anisimov. The contour regularization algorithm was developed and implemented by Dmitry Anisimov and Simon Giraudot. Plane regularization was added by Simon Giraudot based on the prototype version developed by Florent Lafarge.</p>
<h1><a class="anchor" id="Shape_Regularization_Acknowledgements"></a>
Acknowledgments</h1>
<p>We wish to thank Andreas Fabri and Marc Pouget for useful discussions and reviews. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jul 4 2022 13:25:33 for CGAL 5.6 - Shape Regularization by
    <a href="https://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>
</html><html xmlns="http://www.w3.org/1999/xhtml"><body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.6 - Shape Regularization
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Shape_Regularization"></a>  </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Authors</dt><dd>Dmitry Anisimov, Gennadii Sytov, Simon Giraudot, Jean-Philippe Bauchet, and Florent Lafarge</dd></dl>
<p><a class="anchor" id="fig__regularize_2_overview"></a></p><div class="image">
<object type="image/svg+xml" data="overview.svg">overview.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__regularize_2_overview">Figure 82.1</a> A closed contour before (red) and after (green) regularization.  </div> <br /> 
<h1><a class="anchor" id="Shape_Regularization_Intro"></a>
Introduction</h1>
<p>This CGAL package enables to regularize a set of segments and open or closed contours in 2D and a set of planes in 3D such that all input objects are rotated and aligned with respect to the user-specified conditions. In addition, we provide a global regularization framework that can be adjusted for the user needs and any type of geometric objects. This package can also be used in conjunction with the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgShapeDetection">Shape Detection</a> package.</p>
<h1><a class="anchor" id="QP_Regularization_Segments"></a>
Segments</h1>
<p>Given a set of unordered 2D segments, users can reinforce three types of regularities among these segments:</p><ul>
<li><em>Parallelism</em>: segments, which are detected as near parallel, are made exactly parallel.</li>
<li><em>Orthogonality</em>: segments, which are detected as near orthogonal, are made exactly orthogonal.</li>
<li><em>Collinearity</em>: parallel segments, which are detected as near collinear, are made exactly collinear.</li>
</ul>
<p>A typical use of this algorithm consists of the following steps:</p><ol type="1">
<li>Create an input range with 2D segments;</li>
<li>Define groups of segments, which should be regularized together;</li>
<li>Instantiate models of the concepts <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1NeighborQuery.html" title="A concept that describes the set of methods used by the class QP_regularization to access neighbors o...">NeighborQuery</a></code> and <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html" title="A concept that describes the set of methods used by the class QP_regularization to access various dat...">RegularizationType</a></code> with the proper parameters;</li>
<li>Call the function <code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#ga3cde2421ff91530c13c9e8f1feaeae1c" title="regularizes a set of 2D segments. ">regularize_segments()</a></code>.</li>
</ol>
<p>Once the user has defined an input range with 2D segments, he can either provide them all to the regularization algorithm, which is the default option, or they could be reorganized into groups of contextually similar segments. For example, all segments of the same length could form a group. When regularizing, only segments within the group are taken into account, that is no segment from one group will be oriented and/or aligned towards a segment from another group (see more details <a class="el" href="index.html#QP_Regularization_Segments_Delaunay">here</a>).</p>
<p>To apply the algorithm, the user has to define two models: one of the concept <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1NeighborQuery.html" title="A concept that describes the set of methods used by the class QP_regularization to access neighbors o...">NeighborQuery</a></code> that provides an access to the closest neighbors of a segment; and the other one of the concept <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html" title="A concept that describes the set of methods used by the class QP_regularization to access various dat...">RegularizationType</a></code> that provides one of the available regularities, which should be adjusted.</p>
<p>This CGAL component provides a model of the <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1NeighborQuery.html" title="A concept that describes the set of methods used by the class QP_regularization to access neighbors o...">NeighborQuery</a></code> concept:</p>
<ul>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Delaunay__neighbor__query__2.html" title="A neighbor query based on a Delaunay triangulation, which enables to find the nearest neighbors in a ...">Segments::Delaunay_neighbor_query_2</a></code> - finds local neighbors of each segment by constructing a Delaunay triangulation. See more details <a class="el" href="index.html#QP_Regularization_Segments_Delaunay">here</a>.</li>
</ul>
<p>And two models of the <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html" title="A concept that describes the set of methods used by the class QP_regularization to access various dat...">RegularizationType</a></code> concept:</p>
<ul>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Angle__regularization__2.html" title="An angle-based regularization type for 2D segments that reinforces parallelism and orthogonality rela...">Segments::Angle_regularization_2</a></code> - orients segments to reinforce parallelism and orthogonality among them. See more details <a class="el" href="index.html#QP_Regularization_Segments_Angles">here</a>.</li>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Offset__regularization__2.html" title="An offset-based regularization type for 2D segments that reinforces collinearity relationships. ">Segments::Offset_regularization_2</a></code> - aligns parallel segments to reinforce collinearity among them. See more details <a class="el" href="index.html#QP_Regularization_Segments_Offset">here</a>.</li>
</ul>
<p>The standard way to regularize a set of input segments is to first apply an angle regularization and then an offset regularization, however the algorithm is flexible to handle other scenarios as you will see later.</p>
<dl class="section note"><dt>Note</dt><dd>The core of this algorithm is the <a class="el" href="index.html#QP_Regularization">QP Regularization</a> framework. For more details, please refer to that section.</dd></dl>
<p>The example below shows the most straightforward entry point to the algorithm, where we apply two type of regularities: parallelism and orthogonality, within the group of all input segments. The algorithm is called via the function <code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#ga3cde2421ff91530c13c9e8f1feaeae1c" title="regularizes a set of 2D segments. ">regularize_segments()</a></code>.</p>
<p><a class="anchor" id="fig__regularize_simple_example"></a></p><div class="image">
<object type="image/svg+xml" data="regularize_simple.svg">regularize_simple.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__regularize_simple_example">Figure 82.2</a> A set of 2D segments before (red) and after (green) the angle and offset regularization.  </div> <br /> 
<p><br />
<b>File</b> <a class="el" href="Shape_regularization_2regularize_simple_8cpp-example.html">Shape_regularization/regularize_simple.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="regularize__segments_8h.html">CGAL/Shape_regularization/regularize_segments.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>    = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> Point_2   = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>;</div><div class="line"><span class="keyword">using</span> Segment_2 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#aa6d2526f8d1571f4a38aa8a6d9a02c2b">Kernel::Segment_2</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">  <span class="comment">// Create input segments.</span></div><div class="line">  std::vector&lt;Segment_2&gt; segments = {</div><div class="line">    Segment_2(Point_2(0.2, 0.0), Point_2(1.2, 0.0)),</div><div class="line">    Segment_2(Point_2(1.2, 0.1), Point_2(2.2, 0.1)),</div><div class="line">    Segment_2(Point_2(2.2, 0.0), Point_2(2.0, 2.0)),</div><div class="line">    Segment_2(Point_2(2.0, 2.0), Point_2(1.0, 2.0)),</div><div class="line">    Segment_2(Point_2(1.0, 1.9), Point_2(0.0, 1.9)),</div><div class="line">    Segment_2(Point_2(0.0, 2.0), Point_2(0.2, 0.0))</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="comment">// Regularize all segments: both angles and offsets.</span></div><div class="line">  <a class="code" href="group__PkgShapeRegularizationRefSegments.html#ga3cde2421ff91530c13c9e8f1feaeae1c">CGAL::Shape_regularization::Segments::</a></div><div class="line"><a class="code" href="group__PkgShapeRegularizationRefSegments.html#ga3cde2421ff91530c13c9e8f1feaeae1c">    regularize_segments</a>(segments);</div><div class="line">}</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>As it can be seen from the example, the algorithm does not prioritize any directions like vertical or horizontal but rather returns the optimal regularized configuration of the input segments.</dd></dl>
<h2><a class="anchor" id="QP_Regularization_Segments_Delaunay"></a>
Delaunay Neighbor Query</h2>
<p>This class finds local neighbors of each segment by constructing a Delaunay triangulation, using the class <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2</a></code>, upon the center points of the input segments. The local neighborhood of a segment is thus defined by the corresponding one-ring neighborhood in the triangulation. The Delaunay triangulation can be constructed only for a group of at least two segments.</p>
<p>The Delaunay neighbor query class constructs the Delaunay triangulation from a group of segments, which has to be provided by the user through the <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Delaunay__neighbor__query__2.html#aaffd7eb2871e03b6e0d3cc997b440661" title="inserts a group of segments from input_range and finds their neighbors within the group...">Segments::Delaunay_neighbor_query_2::add_group()</a></code> method, and finds local neighbors of each segment only within the group. If this method is never called, all input segments are treated as a group.</p>
<p>Note that a group can include fewer segments than in the input range. For example, if your input range contains multiple segments, which contextually form three different groups of objects lets say boundaries of three different buildings and you do not want to regularize these buildings with respect to each other, but rather within each building boundary, in that case you should call the <code>add_group</code> method three times. An example of such groups can be seen in <a class="el" href="index.html#Regularize_15_Segments_Figure">this figure</a>, where you can see three groups of contextually similar segments: outer boundary, interior top rhombus and interior bottom rhombus or in the figure below.</p>
<p>In this figure, there are two squares, one external and one internal. On the left, the red segments show the connectivity among all input segments that is a Delaunay triangulation built upon all these segments, while on the right, the green segments show the connectivity only among external square segments and blue segments only among internal square segments.</p>
<p><a class="anchor" id="fig__delaunay_groups"></a></p><div class="image">
<object type="image/svg+xml" data="delaunay_groups.svg">delaunay_groups.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__delaunay_groups">Figure 82.3</a> Delaunay triangulation (red) for all input segments (black, left) and two contextually different groups with green Delaunay for the external segments and blue Delaunay for the internal segments (right).  </div> <br /> 
<h2><a class="anchor" id="QP_Regularization_Segments_Angles"></a>
Angle Regularization</h2>
<p>This class orients 2D segments in order to reinforce parallelism and orthogonality among them. To apply the angle regularization on a set of 2D segments, the user has to:</p><ul>
<li>specify the maximum angle deviation of a segment from its initial orientation that has to be within the interval [0, 90] degrees. If no bound is provided, a bound of 25 degrees will be set as the default value;</li>
<li>add groups of segments, if any, through the <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Angle__regularization__2.html#a973f865ac9b75042b31ec29d88f2b606" title="inserts a group of segments from input_range. ">Segments::Angle_regularization_2::add_group()</a></code> method.</li>
</ul>
<p>After the optimization, each segment is rotated with respect to its midpoint.</p>
<p><a class="anchor" id="fig__regularize_100_segments_angles_example"></a></p><div class="image">
<object type="image/svg+xml" data="regularize_100_segments_angles.svg">regularize_100_segments_angles.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__regularize_100_segments_angles_example">Figure 82.4</a> A generated set of 2D segments before (red) and after (green) the angle regularization.  </div> <br /> 
<p>The following example demonstrates the usage of the shape regularization algorithm for angles on a set of 100 near orthogonal segments generated with the help of <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgGenerators">CGAL Geometric Object Generators</a>. The entire <code>InputRange</code> is provided to the angle regularization class as a group. The maximum angle bound is set to 40 degrees.</p>
<p><br />
<b>File</b> <a class="el" href="Shape_regularization_2regularize_100_segments_angles_8cpp-example.html">Shape_regularization/regularize_100_segments_angles.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include "include/utils.h"</span></div><div class="line"><span class="preprocessor">#include "include/Saver.h"</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="regularize__segments_8h.html">CGAL/Shape_regularization/regularize_segments.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Typedefs.</span></div><div class="line"><span class="keyword">using</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>    = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> FT        = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"><span class="keyword">using</span> Segment_2 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#aa6d2526f8d1571f4a38aa8a6d9a02c2b">Kernel::Segment_2</a>;</div><div class="line"><span class="keyword">using</span> Segments  = std::vector&lt;Segment_2&gt;;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Neighbor_query =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Delaunay__neighbor__query__2.html">CGAL::Shape_regularization::Segments::Delaunay_neighbor_query_2&lt;Kernel, Segments&gt;</a>;</div><div class="line"><span class="keyword">using</span> Angle_regularization =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Angle__regularization__2.html">CGAL::Shape_regularization::Segments::Angle_regularization_2&lt;Kernel, Segments&gt;</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div><div class="line"></div><div class="line">  <span class="comment">// If we want to save the result in a file, we save it in a path.</span></div><div class="line">  std::string path = <span class="stringliteral">""</span>;</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1) path = argv[1];</div><div class="line">  Saver&lt;Kernel&gt; saver;</div><div class="line"></div><div class="line">  <span class="comment">// Initialize 100 near-orthogonal segments.</span></div><div class="line">  std::vector&lt;Segment_2&gt; segments;</div><div class="line">  create_example_angles(segments);</div><div class="line"></div><div class="line">  <span class="comment">// Save input segments.</span></div><div class="line">  <span class="keywordflow">if</span> (path != <span class="stringliteral">""</span>) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = path + <span class="stringliteral">"regularize_100_segments_angles_before"</span>;</div><div class="line">    saver.export_eps_segments(segments, full_path, FT(1));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Angle regularization.</span></div><div class="line">  <span class="keyword">const</span> FT max_angle_2 = FT(40);</div><div class="line"></div><div class="line">  <span class="comment">// Create neigbor query and angle-based regularization model.</span></div><div class="line">  Neighbor_query neighbor_query(segments);</div><div class="line">  Angle_regularization angle_regularization(</div><div class="line">    segments, CGAL::parameters::maximum_angle(max_angle_2));</div><div class="line"></div><div class="line">  <span class="comment">// Regularize.</span></div><div class="line">  <a class="code" href="group__PkgShapeRegularizationRefSegments.html#ga3cde2421ff91530c13c9e8f1feaeae1c">CGAL::Shape_regularization::Segments::regularize_segments</a>(</div><div class="line">    segments, neighbor_query, angle_regularization);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* number of modified segments = "</span> &lt;&lt;</div><div class="line">    angle_regularization.number_of_modified_segments() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save regularized segments.</span></div><div class="line">  <span class="keywordflow">if</span> (path != <span class="stringliteral">""</span>) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = path + <span class="stringliteral">"regularize_100_segments_angles_after"</span>;</div><div class="line">    saver.export_eps_segments(segments, full_path, FT(1));</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="QP_Regularization_Segments_Offset"></a>
Offset Regularization</h2>
<p>This class aligns 2D parallel segments in order to reinforce collinearity among them. To apply the offset regularization on a set of 2D segments, the user has to:</p><ul>
<li>specify the maximum distance between two parallel segments that has to be within the interval [0, +inf). If no bound is provided, a bound of 0.5 unit length will be set as the default value.</li>
<li>add groups of parallel segments through the <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Offset__regularization__2.html#a8e9dbdec86eb77a43911699e59307865" title="inserts a group of segments from input_range. ">Segments::Offset_regularization_2::add_group()</a></code> method. If the user does not have these groups, they can be obtained from <a class="el" href="index.html#QP_Regularization_Segments_Angles">Angle Regularization</a> by orienting original segments or from the utility function <code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#gac72eca9b32b73a3713edffd2da5609f2" title="finds groups of parallel segments in a set of 2D segments. ">Segments::parallel_groups()</a></code>. See more details <a class="el" href="index.html#QP_Regularization_Segments_Groups">here</a>.</li>
</ul>
<p>After the optimization, each segment is translated along its orthogonal direction.</p>
<p>Note that if the input segments within the same group are not exactly parallel, the distance, which is defined as the distance between the midpoint of one segment and the projection of this point onto the supporting line of another segment, is not a good metric to optimize positions of the segments that may lead to deviations in the result from what the user would expect in case of exactly parallel segments. The offset regularization does not internally orient segments to make them exactly parallel. This is what the <a class="el" href="index.html#QP_Regularization_Segments_Angles">Angle Regularization</a> class for. The utility function <code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#gac72eca9b32b73a3713edffd2da5609f2" title="finds groups of parallel segments in a set of 2D segments. ">Segments::parallel_groups()</a></code> does not orient segments either, but only returns groups of near-parallel segments.</p>
<p><a class="anchor" id="fig__regularize_100_segments_offsets_example"></a></p><div class="image">
<object type="image/svg+xml" data="regularize_100_segments_offsets.svg">regularize_100_segments_offsets.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__regularize_100_segments_offsets_example">Figure 82.5</a> A generated set of 2D segments before (red) and after (green) the offset regularization.  </div> <br /> 
<p>The following example demonstrates the usage of the shape regularization algorithm for offsets on a set of 100 parallel segments located within a circle. The function <code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#gac72eca9b32b73a3713edffd2da5609f2" title="finds groups of parallel segments in a set of 2D segments. ">Segments::parallel_groups()</a></code> is used to obtain the groups of parallel segments. The maximum offset bound is set to 0.25 unit length.</p>
<p><a class="anchor" id="QP_Parallel_Groups_Example"></a><br />
<b>File</b> <a class="el" href="Shape_regularization_2regularize_100_segments_offsets_8cpp-example.html">Shape_regularization/regularize_100_segments_offsets.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include "include/utils.h"</span></div><div class="line"><span class="preprocessor">#include "include/Saver.h"</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="regularize__segments_8h.html">CGAL/Shape_regularization/regularize_segments.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Typedefs.</span></div><div class="line"><span class="keyword">using</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>    = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> FT        = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"><span class="keyword">using</span> Segment_2 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#aa6d2526f8d1571f4a38aa8a6d9a02c2b">Kernel::Segment_2</a>;</div><div class="line"><span class="keyword">using</span> Segments  = std::vector&lt;Segment_2&gt;;</div><div class="line"><span class="keyword">using</span> Indices   = std::vector&lt;std::size_t&gt;;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Neighbor_query =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Delaunay__neighbor__query__2.html">CGAL::Shape_regularization::Segments::Delaunay_neighbor_query_2&lt;Kernel, Segments&gt;</a>;</div><div class="line"><span class="keyword">using</span> Offset_regularization =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Offset__regularization__2.html">CGAL::Shape_regularization::Segments::Offset_regularization_2&lt;Kernel, Segments&gt;</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div><div class="line"></div><div class="line">  <span class="comment">// If we want to save the result in a file, we save it in a path.</span></div><div class="line">  std::string path = <span class="stringliteral">""</span>;</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1) path = argv[1];</div><div class="line">  Saver&lt;Kernel&gt; saver;</div><div class="line"></div><div class="line">  <span class="comment">// Initialize 100 segments in a fuzzy circle.</span></div><div class="line">  std::vector&lt;Segment_2&gt; segments;</div><div class="line">  create_example_offsets(segments);</div><div class="line"></div><div class="line">  <span class="comment">// Save input segments.</span></div><div class="line">  <span class="keywordflow">if</span> (path != <span class="stringliteral">""</span>) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = path + <span class="stringliteral">"regularize_100_segments_offsets_before"</span>;</div><div class="line">    saver.export_eps_segments(segments, full_path, FT(100));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Find groups of parallel segments.</span></div><div class="line">  <span class="keyword">const</span> FT max_angle_2 = FT(1);</div><div class="line"></div><div class="line">  std::vector&lt;Indices&gt; pgroups;</div><div class="line">  <a class="code" href="group__PkgShapeRegularizationRefSegments.html#gac72eca9b32b73a3713edffd2da5609f2">CGAL::Shape_regularization::Segments::parallel_groups</a>(</div><div class="line">    segments, std::back_inserter(pgroups),</div><div class="line">    CGAL::parameters::maximum_angle(max_angle_2));</div><div class="line"></div><div class="line">  <span class="comment">// Offset regularization.</span></div><div class="line">  <span class="keyword">const</span> FT max_offset_2 = FT(1) / FT(4);</div><div class="line"></div><div class="line">  <span class="comment">// Create neigbor query and offset-based regularization model.</span></div><div class="line">  Neighbor_query neighbor_query(segments);</div><div class="line">  Offset_regularization offset_regularization(</div><div class="line">    segments, CGAL::parameters::maximum_offset(max_offset_2));</div><div class="line"></div><div class="line">  <span class="comment">// Add each group of parallel segments with at least 2 segments.</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; pgroup : pgroups) {</div><div class="line">    neighbor_query.add_group(pgroup);</div><div class="line">    offset_regularization.add_group(pgroup);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Regularize.</span></div><div class="line">  <a class="code" href="group__PkgShapeRegularizationRefSegments.html#ga3cde2421ff91530c13c9e8f1feaeae1c">CGAL::Shape_regularization::Segments::regularize_segments</a>(</div><div class="line">    segments, neighbor_query, offset_regularization);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* number of modified segments = "</span> &lt;&lt;</div><div class="line">    offset_regularization.number_of_modified_segments() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save regularized segments.</span></div><div class="line">  <span class="keywordflow">if</span> (path != <span class="stringliteral">""</span>) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = path + <span class="stringliteral">"regularize_100_segments_offsets_after"</span>;</div><div class="line">    saver.export_eps_segments(segments, full_path, FT(100));</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="QP_Regularization_Segments_Examples"></a>
Angle + Offset Regularization</h2>
<p>The following examples demonstrate the usage of the shape regularization algorithm for both angles and offsets sequentially on a set of 2D segments.</p>
<p>The first example contains 15 segments. The angle and offset regularizations are performed on these segments sequentially using the maximum bounds of 10 degrees and 0.1 unit length respectively. We also show here how to create and work with contextually similar groups of segments and regularize each group on its own. The defined groups are the outer boundary, top and bottom rhombus. Since the shape regularization algorithm on segments is based on the <a class="el" href="index.html#QP_Regularization">QP Regularization</a> framework, this example also shows how to use that framework directly instead of calling the function <code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#ga3cde2421ff91530c13c9e8f1feaeae1c" title="regularizes a set of 2D segments. ">regularize_segments()</a></code>.</p>
<p><a class="anchor" id="Regularize_15_Segments_Figure"></a><a class="anchor" id="fig__regularize_15_segments_example"></a></p><div class="image">
<object type="image/svg+xml" data="regularize_15_segments.svg">regularize_15_segments.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__regularize_15_segments_example">Figure 82.6</a> A set of 2D segments before (red), after the angle (yellow), and the offset (green) regularization.  </div> <br /> 
<p><br />
<b>File</b> <a class="el" href="Shape_regularization_2regularize_15_segments_8cpp-example.html">Shape_regularization/regularize_15_segments.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include "include/utils.h"</span></div><div class="line"><span class="preprocessor">#include "include/Saver.h"</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Shape__regularization_8h.html">CGAL/Shape_regularization.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Typedefs.</span></div><div class="line"><span class="keyword">using</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>      = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div><div class="line"><span class="keyword">using</span> FT          = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"><span class="keyword">using</span> Segment_2   = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#aa6d2526f8d1571f4a38aa8a6d9a02c2b">Kernel::Segment_2</a>;</div><div class="line"><span class="keyword">using</span> Segments    = std::vector&lt;Segment_2&gt;;</div><div class="line"><span class="keyword">using</span> Indices     = std::vector&lt;std::size_t&gt;;</div><div class="line"><span class="keyword">using</span> Segment_map = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map&lt;Segment_2&gt;</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Neighbor_query =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Delaunay__neighbor__query__2.html">CGAL::Shape_regularization::Segments::Delaunay_neighbor_query_2&lt;Kernel, Segments, Segment_map&gt;</a>;</div><div class="line"><span class="keyword">using</span> Angle_regularization =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Angle__regularization__2.html">CGAL::Shape_regularization::Segments::Angle_regularization_2&lt;Kernel, Segments, Segment_map&gt;</a>;</div><div class="line"><span class="keyword">using</span> Offset_regularization =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Offset__regularization__2.html">CGAL::Shape_regularization::Segments::Offset_regularization_2&lt;Kernel, Segments, Segment_map&gt;</a>;</div><div class="line"><span class="keyword">using</span> Quadratic_program =</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classCGAL_1_1OSQP__quadratic__program__traits.html">CGAL::OSQP_quadratic_program_traits&lt;FT&gt;</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Quadratic_angle_regularizer =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1QP__regularization.html">CGAL::Shape_regularization::QP_regularization</a>&lt;</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>, Segments, Neighbor_query, Angle_regularization, Quadratic_program&gt;;</div><div class="line"><span class="keyword">using</span> Quadratic_offset_regularizer =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1QP__regularization.html">CGAL::Shape_regularization::QP_regularization</a>&lt;</div><div class="line">    Kernel, Segments, Neighbor_query, Offset_regularization, Quadratic_program&gt;;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div><div class="line"></div><div class="line">  <span class="comment">// If we want to save the result in a file, we save it in a path.</span></div><div class="line">  std::string path = <span class="stringliteral">""</span>;</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1) path = argv[1];</div><div class="line">  Saver&lt;Kernel&gt; saver;</div><div class="line"></div><div class="line">  <span class="comment">// Initialize 15 segments.</span></div><div class="line">  std::vector&lt;Segment_2&gt; segments;</div><div class="line">  create_example_15(segments);</div><div class="line"></div><div class="line">  <span class="comment">// We create three groups of segments:</span></div><div class="line">  <span class="comment">// outer, top and bottom rhombuses.</span></div><div class="line">  std::vector&lt;Indices&gt; groups(3);</div><div class="line">  groups[0] = {0, 1, 2, 3, 4, 5, 6}; <span class="comment">// outer</span></div><div class="line">  groups[1] = {7, 8, 9, 10};         <span class="comment">// top rhombus</span></div><div class="line">  groups[2] = {11, 12, 13, 14};      <span class="comment">// bottom rhombus</span></div><div class="line"></div><div class="line">  <span class="comment">// Save input segments.</span></div><div class="line">  <span class="keywordflow">if</span> (path != <span class="stringliteral">""</span>) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = path + <span class="stringliteral">"regularize_15_segments_before"</span>;</div><div class="line">    saver.export_eps_segments(segments, full_path, FT(100));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Angle regularization.</span></div><div class="line">  <span class="keyword">const</span> FT max_angle_2 = FT(10);</div><div class="line"></div><div class="line">  <span class="comment">// Create qp solver, neigbor query, and angle-based regularization model.</span></div><div class="line">  Quadratic_program qp_angles;</div><div class="line">  Neighbor_query neighbor_query(segments);</div><div class="line">  Angle_regularization angle_regularization(</div><div class="line">    segments, CGAL::parameters::maximum_angle(max_angle_2));</div><div class="line"></div><div class="line">  <span class="comment">// Add each group of input segments.</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; group : groups) {</div><div class="line">    neighbor_query.add_group(group);</div><div class="line">    angle_regularization.add_group(group);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Regularize.</span></div><div class="line">  Quadratic_angle_regularizer qp_angle_regularizer(</div><div class="line">    segments, neighbor_query, angle_regularization, qp_angles);</div><div class="line">  qp_angle_regularizer.regularize();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* number of modified segments (angles) = "</span> &lt;&lt;</div><div class="line">    angle_regularization.number_of_modified_segments() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Offset regularization.</span></div><div class="line">  <span class="keyword">const</span> FT max_offset_2 = FT(1) / FT(10);</div><div class="line"></div><div class="line">  <span class="comment">// Get groups of parallel segments after angle regularization.</span></div><div class="line">  std::vector&lt;Indices&gt; pgroups;</div><div class="line">  angle_regularization.parallel_groups(</div><div class="line">    std::back_inserter(pgroups));</div><div class="line"></div><div class="line">  <span class="comment">// Create qp solver and offset-based regularization model.</span></div><div class="line">  Quadratic_program qp_offsets;</div><div class="line">  Offset_regularization offset_regularization(</div><div class="line">    segments, CGAL::parameters::maximum_offset(max_offset_2));</div><div class="line"></div><div class="line">  <span class="comment">// Add each group of parallel segments with at least 2 segments.</span></div><div class="line">  neighbor_query.clear();</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; pgroup : pgroups) {</div><div class="line">    neighbor_query.add_group(pgroup);</div><div class="line">    offset_regularization.add_group(pgroup);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Regularize.</span></div><div class="line">  Quadratic_offset_regularizer qp_offset_regularizer(</div><div class="line">    segments, neighbor_query, offset_regularization, qp_offsets);</div><div class="line">  qp_offset_regularizer.regularize();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* number of modified segments (offsets) = "</span> &lt;&lt;</div><div class="line">    offset_regularization.number_of_modified_segments() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save regularized segments.</span></div><div class="line">  <span class="keywordflow">if</span> (path != <span class="stringliteral">""</span>) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = path + <span class="stringliteral">"regularize_15_segments_after"</span>;</div><div class="line">    saver.export_eps_segments(segments, full_path, FT(100));</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>The second example contains 65 segments, which are constructed from a set of input points. All points are organized into groups such that each group represents an approximate 2D line. Organizing points into such groups can be achieved with the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgShapeDetection">Shape Detection</a> package. We fit a segment to each group of points using the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgPrincipalComponentAnalysisD">Principal Component Analysis</a> package. The angle and offset regularizations are performed on these segments sequentially using the bounds of 80 degrees and 2 unit lengths respectively.</p>
<p><a class="anchor" id="fig__regularize_real_data_2_example"></a></p><div class="image">
<object type="image/svg+xml" data="regularize_real_data_2.svg">regularize_real_data_2.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__regularize_real_data_2_example">Figure 82.7</a> A set of 2D segments before (red), after the angle (yellow), and the offset (green) regularization.  </div> <br /> 
<p><br />
<b>File</b> <a class="el" href="Shape_regularization_2regularize_real_data_2_8cpp-example.html">Shape_regularization/regularize_real_data_2.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include "include/utils.h"</span></div><div class="line"><span class="preprocessor">#include "include/Saver.h"</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Eigen_diagonalize_traits.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/linear_least_squares_fitting_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="regularize__segments_8h.html">CGAL/Shape_regularization/regularize_segments.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Typedefs.</span></div><div class="line"><span class="keyword">using</span> Kernel    = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div><div class="line"><span class="keyword">using</span> FT        = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"><span class="keyword">using</span> Point_2   = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>;</div><div class="line"><span class="keyword">using</span> Segment_2 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#aa6d2526f8d1571f4a38aa8a6d9a02c2b">Kernel::Segment_2</a>;</div><div class="line"><span class="keyword">using</span> Line_2    = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#add6b18567776ee7e80dfdfa44c304772">Kernel::Line_2</a>;</div><div class="line"><span class="keyword">using</span> Points_2  = std::vector&lt;Point_2&gt;;</div><div class="line"><span class="keyword">using</span> Indices   = std::vector&lt;std::size_t&gt;;</div><div class="line"><span class="keyword">using</span> Segments  = std::vector&lt;Segment_2&gt;;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Neighbor_query =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Delaunay__neighbor__query__2.html">CGAL::Shape_regularization::Segments::Delaunay_neighbor_query_2&lt;Kernel, Segments&gt;</a>;</div><div class="line"><span class="keyword">using</span> Angle_regularization =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Angle__regularization__2.html">CGAL::Shape_regularization::Segments::Angle_regularization_2&lt;Kernel, Segments&gt;</a>;</div><div class="line"><span class="keyword">using</span> Offset_regularization =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Offset__regularization__2.html">CGAL::Shape_regularization::Segments::Offset_regularization_2&lt;Kernel, Segments&gt;</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div><div class="line"></div><div class="line">  <span class="comment">// If we want to load a different file, we load it from a path.</span></div><div class="line">  <span class="comment">// Each point comes with the index of the corresponding group.</span></div><div class="line">  <span class="comment">// The file format: x y z i, where i is the group index. The points</span></div><div class="line">  <span class="comment">// are 2D hence z = 0. Each group contains points, which form</span></div><div class="line">  <span class="comment">// an approximate line.</span></div><div class="line">  std::string path = <span class="stringliteral">"data/real_data_2.xyzi"</span>;</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1) path = argv[1];</div><div class="line">  Saver&lt;Kernel&gt; saver;</div><div class="line"></div><div class="line">  <span class="comment">// Initialize input groups with points.</span></div><div class="line">  std::vector&lt;Points_2&gt; groups;</div><div class="line">  initialize_groups(path, groups);</div><div class="line"></div><div class="line">  <span class="comment">// Fit a line to each group of points.</span></div><div class="line">  Line_2 line; Point_2 <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__centroid__grp.html#gacc395064255dfefdb1420309db234210">centroid</a>;</div><div class="line">  std::vector&lt;Line_2&gt; lines;</div><div class="line">  lines.reserve(groups.size());</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; group : groups) {</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Principal_component_analysis.tag:../Principal_component_analysis/" href="../Principal_component_analysis/group__PkgPrincipalComponentAnalysisDLLSF2.html#gaf0d4435db5901ebe10cafd7de7c077f3">CGAL::linear_least_squares_fitting_2</a>(</div><div class="line">      group.begin(), group.end(), line, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__centroid__grp.html#gacc395064255dfefdb1420309db234210">centroid</a>, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Dimension__tag.html">CGAL::Dimension_tag&lt;0&gt;</a>(),</div><div class="line">      Kernel(), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classCGAL_1_1Eigen__diagonalize__traits.html">CGAL::Eigen_diagonalize_traits&lt;FT, 2&gt;</a>());</div><div class="line">    lines.push_back(line);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Cut each line at the ends of the corresponding group.</span></div><div class="line">  std::vector&lt;Segment_2&gt; segments;</div><div class="line">  segments.reserve(lines.size());</div><div class="line">  Point_2 source, target;</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; lines.size(); ++i) {</div><div class="line">    boundary_points_on_line_2(</div><div class="line">      groups[i], lines[i], source, target);</div><div class="line">    segments.push_back(Segment_2(source, target));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Save input segments.</span></div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 2) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = std::string(argv[2]) + <span class="stringliteral">"regularize_real_data_2_before"</span>;</div><div class="line">    saver.export_eps_segments(segments, full_path, FT(3) / FT(2));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Angle regularization.</span></div><div class="line">  <span class="keyword">const</span> FT max_angle_2 = FT(80);</div><div class="line"></div><div class="line">  <span class="comment">// Create neigbor query and angle-based regularization model.</span></div><div class="line">  Neighbor_query neighbor_query(segments);</div><div class="line">  Angle_regularization angle_regularization(</div><div class="line">    segments, CGAL::parameters::maximum_angle(max_angle_2));</div><div class="line"></div><div class="line">  <span class="comment">// Regularize.</span></div><div class="line">  <a class="code" href="group__PkgShapeRegularizationRefSegments.html#ga3cde2421ff91530c13c9e8f1feaeae1c">CGAL::Shape_regularization::Segments::regularize_segments</a>(</div><div class="line">    segments, neighbor_query, angle_regularization);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* number of modified segments (angles) = "</span> &lt;&lt;</div><div class="line">    angle_regularization.number_of_modified_segments() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Offset regularization.</span></div><div class="line">  <span class="keyword">const</span> FT max_offset_2 = FT(2);</div><div class="line"></div><div class="line">  <span class="comment">// Get groups of parallel segments after angle regularization.</span></div><div class="line">  std::vector&lt;Indices&gt; pgroups;</div><div class="line">  angle_regularization.parallel_groups(</div><div class="line">    std::back_inserter(pgroups));</div><div class="line"></div><div class="line">  <span class="comment">// Create offset-based regularization model.</span></div><div class="line">  Offset_regularization offset_regularization(</div><div class="line">    segments, CGAL::parameters::maximum_offset(max_offset_2));</div><div class="line"></div><div class="line">  <span class="comment">// Add each group of parallel segments with at least 2 segments.</span></div><div class="line">  neighbor_query.clear();</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; pgroup : pgroups) {</div><div class="line">    neighbor_query.add_group(pgroup);</div><div class="line">    offset_regularization.add_group(pgroup);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Regularize.</span></div><div class="line">  <a class="code" href="group__PkgShapeRegularizationRefSegments.html#ga3cde2421ff91530c13c9e8f1feaeae1c">CGAL::Shape_regularization::Segments::regularize_segments</a>(</div><div class="line">    segments, neighbor_query, offset_regularization);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* number of modified segments (offsets) = "</span> &lt;&lt;</div><div class="line">    offset_regularization.number_of_modified_segments() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save regularized segments.</span></div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 2) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = std::string(argv[2]) + <span class="stringliteral">"regularize_real_data_2_after"</span>;</div><div class="line">    saver.export_eps_segments(segments, full_path, FT(3) / FT(2));</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="QP_Regularization_Segments_Utils"></a>
Utility Functions</h2>
<p>In addition to the main algorithm, we also provide several utility functions, which are often used in conjunction with the algorithm.</p>
<h3><a class="anchor" id="QP_Regularization_Segments_Groups"></a>
Grouping Segments</h3>
<p>This CGAL component also provides three ways to group segments:</p><ul>
<li><code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#gac72eca9b32b73a3713edffd2da5609f2" title="finds groups of parallel segments in a set of 2D segments. ">Segments::parallel_groups()</a></code> - organizes a set of unordered 2D segments into groups of parallel segments.</li>
<li><code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#ga7fe1c4b39b16dee49ba9c41dc3c0b0f8" title="finds groups of orthogonal segments in a set of 2D segments. ">Segments::orthogonal_groups()</a></code> - organizes a set of unordered 2D segments into groups of orthogonal segments.</li>
<li><code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#ga7ade7f4682f9953fcf36669b2079f4d9" title="finds groups of collinear segments in a set of 2D segments. ">Segments::collinear_groups()</a></code> - organizes a set of unordered 2D segments into groups of collinear segments.</li>
</ul>
<p><a class="anchor" id="fig__parallel_groups"></a></p><div class="image">
<object type="image/svg+xml" data="groups.svg">groups.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__parallel_groups">Figure 82.8</a> Groups of near parallel (left), near orthogonal (center), and near collinear (right) segments. Red, green, blue colors indicate groups within each set of 2D segments.  </div> <br /> 
<p>The function <code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#gac72eca9b32b73a3713edffd2da5609f2" title="finds groups of parallel segments in a set of 2D segments. ">Segments::parallel_groups()</a></code> enables users to form groups of parallel segments. For example, if you know that all your segments are already near parallel to each other within some tolerance error and you do not want to orient them by applying the <a class="el" href="index.html#QP_Regularization_Segments_Angles">Angle Regularization</a> algorithm, but you still need to make them collinear by minimizing the offset among parallel segments using the <a class="el" href="index.html#QP_Regularization_Segments_Offset">Offset Regularization</a> algorithm, you can create the groups of parallel segments by using this function and provide them as input to the offset regularization algorithm as we do it <a class="el" href="index.html#QP_Parallel_Groups_Example">here</a>.</p>
<p>The other two functions serve a similar goal. The one <code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#ga7fe1c4b39b16dee49ba9c41dc3c0b0f8" title="finds groups of orthogonal segments in a set of 2D segments. ">Segments::orthogonal_groups()</a></code> first creates groups of parallel segments and then merges them into groups, where all segments are either parallel or orthogonal to each other. The one <code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#ga7ade7f4682f9953fcf36669b2079f4d9" title="finds groups of collinear segments in a set of 2D segments. ">Segments::collinear_groups()</a></code> first creates groups of parallel segments and then splits each of these groups into groups of collinear segments, if any.</p>
<dl class="section note"><dt>Note</dt><dd>Note that none of these functions applies the regularization of the input segments. They only return groups of indices of segments with similar orientations and/or positions.</dd></dl>
<h3><a class="anchor" id="QP_Regularization_Segments_Simplification"></a>
Simplifying Segments</h3>
<p>After regularizing angles and offsets, simplifying segments with similar properties is a common post-processing task. This CGAL component provides an utility function <code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#ga9312b7fea9ddc4beae7b166ccc4607df" title="substitutes groups of 2D collinear segments by average segments. ">Segments::unique_segments()</a></code> that takes a set of input segments, groups them with respect to the collinearity property, and then returns for each group of collinear segments a segment that best fits this group (see the figure below).</p>
<dl class="section note"><dt>Note</dt><dd>Even if the segments are far away from each other but close with respect to the orthogonal distance between them that is they are almost collinear, they will be merged as the blue segments in the figure.</dd></dl>
<p><a class="anchor" id="fig__unique_segments"></a></p><div class="image">
<object type="image/svg+xml" data="unique_segments.svg">unique_segments.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__unique_segments">Figure 82.9</a> Input segments with multiple collinear segments (left) are simplified into unique segments (right).  </div> <br /> 
<h2><a class="anchor" id="QP_Regularization_Segments_Performance"></a>
Performance</h2>
<p>The performance of the shape regularization algorithm mostly depends on the used QP solver. When using the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classCGAL_1_1OSQP__quadratic__program__traits.html">CGAL::OSQP_quadratic_program_traits</a></code> model, we exploit and efficiently use the sparse nature of the related QP problem that leads to quick performances in practice.</p>
<p>The plot (solid) below shows how the computation time depends on the number of input segments. We first observe that the most challenging step is angle regularization while the offset regularization is much faster. This is an effect of complexity reduction by segmenting the problem into groups for offset regularization. Since each group of parallel segments is much smaller than the original set of input segments, the total computation time is smaller, too. The same idea can be applied to accelerate the angle regularization. Splitting input segments into groups with contextually similar properties from the very beginning will lead to better performance as indicated in the plot (dashed). However, note that not each data set can be meaningfully split into such groups.</p>
<p>To benchmark the algorithm, we used a MacBook Pro 2018 with 2.2 GHz Intel Core i7 processor (6 cores) and 32 GB 2400 MHz DDR4 memory. The installed operating system was OS X 10.15 Catalina. We first create a set of random segments in a square such that all segments are either parallel to the X axis or Y axis. We then slightly perturb all segments by a random angle within the interval [-15, 15] degrees and apply the regularization algorithm 10 times on the same input. The returned time is the average time over all iterations. In the pre-grouped version, we regroup all segments into groups of 10 segments and the regularization algorithm is applied to each group. For example, in case of 50 input segments, we will have 5 input groups. Since the groups are very small, there is no much difference in time between angle and offset regularizations. The results are shown in the figure below.</p>
<p><a class="anchor" id="fig__qp_segments_bench"></a></p><div class="image">
<object type="image/svg+xml" data="qp_segments_bench.svg">qp_segments_bench.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__qp_segments_bench">Figure 82.10</a> Time in seconds to regularize angles (solid red) and offsets (solid green) without regrouping input segments and with the groups of 10 segments for angles (dashed red) and offsets (dashed green).  </div> <br /> 
<h1><a class="anchor" id="Contour_Regularization"></a>
Contours</h1>
<p>Given a set of ordered 2D points connected by segments, which form a contour, closed or open, users can reinforce three types of regularities among consecutive edges of this contour:</p><ul>
<li><em>Parallelism</em>: contour edges, which are detected as near parallel, are made exactly parallel.</li>
<li><em>Orthogonality</em>: contour edges, which are detected as near orthogonal, are made exactly orthogonal.</li>
<li><em>Collinearity</em>: parallel contour edges, which are detected as near collinear, are made exactly collinear.</li>
</ul>
<p>A typical use of this algorithm consists of the following steps:</p><ol type="1">
<li>Specify a type of the contour, open or closed;</li>
<li>Create an instance of the class <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1ContourDirections.html" title="We assume that each contour has one or several principal directions. By implementing a model of this ...">ContourDirections</a></code> with the proper parameters;</li>
<li>Call the function <code><a class="el" href="group__PkgShapeRegularizationRefContours.html#ga7e2f3e7e76c52a3acef42a0d413a17c6" title="regularizes closed contours. ">regularize_closed_contour()</a></code> or <code><a class="el" href="group__PkgShapeRegularizationRefContours.html#gae860b28fa0fde23f6f6540f483b4ecff" title="regularizes open contours. ">regularize_open_contour()</a></code>.</li>
</ol>
<p>We assume that each contour has at least one principal direction that is a reference direction towards which the contour edges are rotated. Given a set of such directions either estimated or user-specified, each edge is made either parallel or orthogonal to these direction(s).</p>
<p>To estimate principal directions of the contour, this component provides three models of the concept <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1ContourDirections.html" title="We assume that each contour has one or several principal directions. By implementing a model of this ...">ContourDirections</a></code>:</p><ul>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1Contours_1_1Longest__direction__2.html" title="Estimates the longest principal direction of the contour. ">Contours::Longest_direction_2</a></code> - sets the longest contour edge as the only principal direction.</li>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1Contours_1_1Multiple__directions__2.html" title="Estimates possibly multiple principal directions of the contour based on the user-specified minimum l...">Contours::Multiple_directions_2</a></code> - tries to estimate multiple principal directions in the contour based on the user-specified parameters (see the figure below).</li>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1Contours_1_1User__defined__directions__2.html" title="Sets multiple user-specified principal directions of the contour. ">Contours::User_defined_directions_2</a></code> - sets the user-specified principal directions as contour directions.</li>
</ul>
<p><a class="anchor" id="fig__multiple_directions"></a></p><div class="image">
<object type="image/svg+xml" data="multiple_directions.svg">multiple_directions.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__multiple_directions">Figure 82.11</a> A closed contour before (red) and after (green) the contour regularization. The found principal directions are marked yellow.  </div> <br /> 
<p>After the directions are set, the algorithm is linear in the number of contour edges. It first goes through each contour edge and orients it towards the best-fit direction. In the second step, all parallel consecutive edges are merged if they are within a user-specified maximum tolerance distance. The distance here is defined as the distance between the midpoint of the first edge and the projection of this point onto the supporting line of the next edge. The position of the merged segment is optimized with respect to its neighbors. In the last steps, all segments are reconnected into a contour as shown in the figure below. Due to the merging step, the number of output edges in the contour is not necessarily the same as the number of input edges.</p>
<p><a class="anchor" id="fig__contours_pipeline"></a></p><div class="image">
<object type="image/svg+xml" data="contours_pipeline.svg">contours_pipeline.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__contours_pipeline">Figure 82.12</a> Steps of the contour regularization algorithm (from left to right): the closed contour before regularization; the disconnected contour with edges rotated towards the found principal directions, here we have only one direction; the optimized edges, blue edges were merged and their positions were optimized; and the final reconnected contour.  </div> <br /> 
<p>If the user wants to rotate each contour edge on its own towards the best-fit direction without reconnecting them after into a closed/open contour, she can either use the <a class="el" href="index.html#QP_Regularization_Segments">Segment Regularization</a> algorithm or she can orient each segment by calling the <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1ContourDirections.html#a07f23b0d134d1dfb32158f485aab15b8" title="orients a given segment with the index query_index towards the best-fit direction of the contour...">ContourDirections::orient()</a></code> method.</p>
<p>The example below shows the most straightforward entry point to the algorithm, where we regularize a simple closed contour. The algorithm is called via the function <code><a class="el" href="group__PkgShapeRegularizationRefContours.html#ga7e2f3e7e76c52a3acef42a0d413a17c6" title="regularizes closed contours. ">regularize_closed_contour()</a></code>.</p>
<p><a class="anchor" id="fig__regularize_contour_example"></a></p><div class="image">
<object type="image/svg+xml" data="regularize_contour.svg">regularize_contour.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__regularize_contour_example">Figure 82.13</a> A closed contour before (red) and after (green) regularization.  </div> <br /> 
<p><br />
<b>File</b> <a class="el" href="Shape_regularization_2regularize_contour_8cpp-example.html">Shape_regularization/regularize_contour.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="regularize__contours_8h.html">CGAL/Shape_regularization/regularize_contours.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> Kernel  = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> Point_2 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">  <span class="comment">// Create input contour.</span></div><div class="line">  <span class="keyword">const</span> std::vector&lt;Point_2&gt; contour = {</div><div class="line">    Point_2(0.00,  0.00),</div><div class="line">    Point_2(0.50, -0.05),</div><div class="line">    Point_2(1.00,  0.00),</div><div class="line">    Point_2(1.05,  0.50),</div><div class="line">    Point_2(1.00,  1.00),</div><div class="line">    Point_2(0.00,  1.00)</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="comment">// Regularize this contour.</span></div><div class="line">  std::vector&lt;Point_2&gt; regularized;</div><div class="line">  <a class="code" href="group__PkgShapeRegularizationRefContours.html#ga7e2f3e7e76c52a3acef42a0d413a17c6">CGAL::Shape_regularization::Contours::</a></div><div class="line"><a class="code" href="group__PkgShapeRegularizationRefContours.html#ga7e2f3e7e76c52a3acef42a0d413a17c6">    regularize_closed_contour</a>(contour, std::back_inserter(regularized));</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Contour_Regularization_Closed"></a>
Closed Contours</h2>
<p>In the example below, we regularize a closed contour. We use multiple directions estimator, which returns only one direction, because the contour is quite rectilinear. In fact, the returned direction in this case coincides with the longest edge direction.</p>
<p><a class="anchor" id="fig__regularize_closed_contour_example"></a></p><div class="image">
<object type="image/svg+xml" data="regularize_closed_contour.svg">regularize_closed_contour.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__regularize_closed_contour_example">Figure 82.14</a> A closed contour before (red) and after (green) the contour regularization.  </div> <br /> 
<p><br />
<b>File</b> <a class="el" href="Shape_regularization_2regularize_closed_contour_8cpp-example.html">Shape_regularization/regularize_closed_contour.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include "include/utils.h"</span></div><div class="line"><span class="preprocessor">#include "include/Saver.h"</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="regularize__contours_8h.html">CGAL/Shape_regularization/regularize_contours.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Typedefs.</span></div><div class="line"><span class="keyword">using</span> Kernel  = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div><div class="line"><span class="keyword">using</span> FT      = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"><span class="keyword">using</span> Point_2 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>;</div><div class="line"><span class="keyword">using</span> Contour = std::vector&lt;Point_2&gt;;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Contour_directions =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Contours_1_1Multiple__directions__2.html">CGAL::Shape_regularization::Contours::Multiple_directions_2&lt;Kernel, Contour&gt;</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div><div class="line"></div><div class="line">  <span class="comment">// If we want to load a different file, we load it from a path.</span></div><div class="line">  std::string path = <span class="stringliteral">"data/contour.polylines"</span>;</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1) path = argv[1];</div><div class="line">  Saver&lt;Kernel&gt; saver;</div><div class="line"></div><div class="line">  <span class="comment">// Set parameters.</span></div><div class="line">  <span class="keyword">const</span> FT min_length_2 = FT(2);</div><div class="line">  <span class="keyword">const</span> FT  max_angle_2 = FT(20);</div><div class="line">  <span class="keyword">const</span> FT max_offset_2 = FT(2);</div><div class="line"></div><div class="line">  <span class="comment">// Initialize contour.</span></div><div class="line">  std::vector&lt;Point_2&gt; contour;</div><div class="line">  initialize_contour(path, contour);</div><div class="line"></div><div class="line">  <span class="comment">// Save input contour.</span></div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 2) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = std::string(argv[2]) + <span class="stringliteral">"regularize_closed_contour_before"</span>;</div><div class="line">    saver.export_eps_closed_contour(contour, full_path, FT(8));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Regularize.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#gae04c8044cf1eee6a84baa5b79ab99fef">is_closed</a> = <span class="keyword">true</span>;</div><div class="line">  Contour_directions directions(</div><div class="line">    contour, is_closed, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL_1_1parameters.html">CGAL::parameters</a>::</div><div class="line">    minimum_length(min_length_2).maximum_angle(max_angle_2));</div><div class="line"></div><div class="line">  std::vector&lt;Point_2&gt; regularized;</div><div class="line">  <a class="code" href="group__PkgShapeRegularizationRefContours.html#ga7e2f3e7e76c52a3acef42a0d413a17c6">CGAL::Shape_regularization::Contours::regularize_closed_contour</a>(</div><div class="line">    contour, directions, std::back_inserter(regularized),</div><div class="line">    CGAL::parameters::maximum_offset(max_offset_2));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* number of directions = "</span> &lt;&lt;</div><div class="line">    directions.number_of_directions() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save regularized contour.</span></div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 2) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = std::string(argv[2]) + <span class="stringliteral">"regularize_closed_contour_after"</span>;</div><div class="line">    saver.export_eps_closed_contour(regularized, full_path, FT(8));</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Contour_Regularization_Open"></a>
Open Contours</h2>
<p>Open contours are contours where the head and tail of the contour are not connected. This case requires a special treatment, but the core of the algorithm is the same. In the example below, we regularize an open contour with respect to its longest edge. This example also shows how to provide a property map to the algorithm in order to give the algorithm access to the coordinates of the contour vertices.</p>
<p><a class="anchor" id="fig__regularize_open_contour_example"></a></p><div class="image">
<object type="image/svg+xml" data="regularize_open_contour.svg">regularize_open_contour.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__regularize_open_contour_example">Figure 82.15</a> An open contour before (red) and after (green) the contour regularization.  </div> <br /> 
<p><br />
<b>File</b> <a class="el" href="Shape_regularization_2regularize_open_contour_8cpp-example.html">Shape_regularization/regularize_open_contour.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include "include/utils.h"</span></div><div class="line"><span class="preprocessor">#include "include/Saver.h"</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="regularize__contours_8h.html">CGAL/Shape_regularization/regularize_contours.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Typedefs.</span></div><div class="line"><span class="keyword">using</span> Kernel  = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div><div class="line"><span class="keyword">using</span> FT      = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"><span class="keyword">using</span> Point_2 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>;</div><div class="line"><span class="keyword">using</span> Contour = std::vector&lt;Point_2&gt;;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Contour_directions =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Contours_1_1Longest__direction__2.html">CGAL::Shape_regularization::Contours::Longest_direction_2&lt;Kernel, Contour&gt;</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div><div class="line"></div><div class="line">  <span class="comment">// If we want to load a different file, we load it from a path.</span></div><div class="line">  std::string path = <span class="stringliteral">"data/contour.polylines"</span>;</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1) path = argv[1];</div><div class="line">  Saver&lt;Kernel&gt; saver;</div><div class="line"></div><div class="line">  <span class="comment">// Set parameters.</span></div><div class="line">  <span class="keyword">const</span> FT max_offset_2 = FT(2);</div><div class="line"></div><div class="line">  <span class="comment">// Initialize contour.</span></div><div class="line">  std::vector&lt;Point_2&gt; contour;</div><div class="line">  initialize_contour(path, contour);</div><div class="line"></div><div class="line">  <span class="comment">// Save input contour.</span></div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 2) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = std::string(argv[2]) + <span class="stringliteral">"regularize_open_contour_before"</span>;</div><div class="line">    saver.export_eps_open_contour(contour, full_path, FT(8));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Regularize.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span> is_closed = <span class="keyword">false</span>;</div><div class="line">  Contour_directions directions(contour, is_closed);</div><div class="line"></div><div class="line">  std::vector&lt;Point_2&gt; regularized;</div><div class="line">  <a class="code" href="group__PkgShapeRegularizationRefContours.html#gae860b28fa0fde23f6f6540f483b4ecff">CGAL::Shape_regularization::Contours::regularize_open_contour</a>(</div><div class="line">    contour, directions, std::back_inserter(regularized),</div><div class="line">    CGAL::parameters::maximum_offset(max_offset_2));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* number of directions = "</span> &lt;&lt;</div><div class="line">    directions.number_of_directions() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save regularized contour.</span></div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 2) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = std::string(argv[2]) + <span class="stringliteral">"regularize_open_contour_after"</span>;</div><div class="line">    saver.export_eps_open_contour(regularized, full_path, FT(8));</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Contour_Regularization_Performance"></a>
Performance</h2>
<p>The contour regularization algorithms, both closed and open, have, in practice, a linear time behavior with respect to the number of contour vertices. In fact, the time is not linear, as you can see in the plot below, due to the second step of merging consecutive collinear edges. For some polygons, the number of such edges is quite high and before merging them into one segment, we collect all of them into a group in order to find the best optimal position to place the final segment that may lead to a slower performance in some cases.</p>
<p>To benchmark the algorithm, we used a MacBook Pro 2018 with 2.2 GHz Intel Core i7 processor (6 cores) and 32 GB 2400 MHz DDR4 memory. The installed operating system was OS X 10.15 Catalina. We first create a rectilinear polygon with the required number of edges. We then slightly perturb all edges by a random angle within the interval [-15, 15] degrees and apply the regularization algorithm 10 times on the same input. The returned time is the average time over all iterations. The results are shown in the figure below.</p>
<p><a class="anchor" id="fig__contours_bench"></a></p><div class="image">
<object type="image/svg+xml" data="contours_bench.svg">contours_bench.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__contours_bench">Figure 82.16</a> Time in seconds to regularize closed (red) and open (green) contours.  </div> <br /> 
<h1><a class="anchor" id="Plane_Regularization"></a>
Planes</h1>
<p>Given a set of 3D planes with their corresponding inlier sets, users can reinforce four types of regularities among these planes using the function <code><a class="el" href="group__PkgShapeRegularizationRefPlanes.html#ga9ace5aafd056ce9ccb348c96e38d361a" title="Hierarchical plane regularization. ">regularize_planes()</a></code>:</p><ul>
<li><em>Parallelism</em>: planes, which are detected as near parallel, are made exactly parallel.</li>
<li><em>Orthogonality</em>: planes, which are detected as near orthogonal, are made exactly orthogonal.</li>
<li><em>Coplanarity</em>: parallel planes, which are detected as near coplanar, are made exactly coplanar.</li>
<li><em>Axis-Symmetry</em>: planes, which are detected as near symmetrical with respect to a user-specified axis, are made exactly symmetrical.</li>
</ul>
<p>The user can choose to regularize only one or several of these four properties. The process is greedy and based on a hierarchical decomposition (coplanar clusters are subgroups of parallel clusters, which are subgroups of axis-symmetric and orthogonal clusters) as described by Verdie et al. in <a class="el" href="citelist.html#CITEREF_cgal:vla-lod-15">[2]</a>.</p>
<p>The following example illustrates how to use the plane regularization function.</p>
<p><br />
<b>File</b> <a class="el" href="Shape_regularization_2regularize_planes_8cpp-example.html">Shape_regularization/regularize_planes.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include "include/utils.h"</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/Efficient__RANSAC_8h.html">CGAL/Shape_detection/Efficient_RANSAC.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="regularize__planes_8h.html">CGAL/Shape_regularization/regularize_planes.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Typedefs.</span></div><div class="line"><span class="keyword">using</span> Kernel   = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div><div class="line"><span class="keyword">using</span> FT       = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"><span class="keyword">using</span> Point_3  = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ae82b7f4be77dd5b8819ebe419e4ae753">Kernel::Point_3</a>;</div><div class="line"><span class="keyword">using</span> Vector_3 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a39fb0222695ae5e7e32f4e570ea28225">Kernel::Vector_3</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Point_with_normal = std::pair&lt;Point_3, Vector_3&gt;;</div><div class="line"><span class="keyword">using</span> Point_map         = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Point_with_normal&gt;</a>;</div><div class="line"><span class="keyword">using</span> Normal_map        = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;Point_with_normal&gt;</a>;</div><div class="line"><span class="keyword">using</span> Pwn_vector        = std::vector&lt;Point_with_normal&gt;;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Traits    = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/structCGAL_1_1Shape__detection_1_1Efficient__RANSAC__traits.html">CGAL::Shape_detection::Efficient_RANSAC_traits&lt;Kernel, Pwn_vector, Point_map, Normal_map&gt;</a>;</div><div class="line"><span class="keyword">using</span> RANSAC    = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Efficient__RANSAC.html">CGAL::Shape_detection::Efficient_RANSAC&lt;Traits&gt;</a>;</div><div class="line"><span class="keyword">using</span> Plane     = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Plane.html">CGAL::Shape_detection::Plane&lt;Traits&gt;</a>;</div><div class="line"><span class="keyword">using</span> Plane_map = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Plane__map.html">CGAL::Shape_detection::Plane_map&lt;Traits&gt;</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div><div class="line"></div><div class="line">  <span class="comment">// If we want to load a different file, we load it from a path.</span></div><div class="line">  std::string path = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/cube.pwn"</span>);</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1) path = argv[1];</div><div class="line"></div><div class="line">  Pwn_vector points;</div><div class="line">  std::ifstream file(path.c_str(), std::ios_base::in);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7d51c854b865a7eb367e21fc43bd37b8">CGAL::IO::set_ascii_mode</a>(file);</div><div class="line">  file.precision(20);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (!file ||</div><div class="line">    !CGAL::IO::read_XYZ(</div><div class="line">      file,</div><div class="line">      std::back_inserter(points),</div><div class="line">      CGAL::parameters::point_map(Point_map()).</div><div class="line">      normal_map(Normal_map()))) {</div><div class="line"></div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read the file cube.pwn!"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line">  file.close();</div><div class="line"></div><div class="line">  <span class="comment">// Call RANSAC shape detection with planes.</span></div><div class="line">  RANSAC efficient_ransac;</div><div class="line">  efficient_ransac.set_input(points);</div><div class="line">  efficient_ransac.add_shape_factory&lt;Plane&gt;();</div><div class="line">  efficient_ransac.detect();</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> planes = efficient_ransac.planes();</div><div class="line"></div><div class="line">  <span class="comment">// Regularize detected planes.</span></div><div class="line">  <a class="code" href="group__PkgShapeRegularizationRefPlanes.html#ga9ace5aafd056ce9ccb348c96e38d361a">CGAL::Shape_regularization::Planes::regularize_planes</a>(</div><div class="line">    planes,</div><div class="line">    points,</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL_1_1parameters.html">CGAL::parameters</a>::</div><div class="line">    plane_map(Plane_map()).</div><div class="line">    point_map(Point_map()).</div><div class="line">    plane_index_map(</div><div class="line">      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Point__to__shape__index__map.html">CGAL::Shape_detection::Point_to_shape_index_map&lt;Traits&gt;</a>(points, planes)).</div><div class="line">    regularize_coplanarity(<span class="keyword">false</span>). <span class="comment">// do not regularize coplanarity</span></div><div class="line">    maximum_angle(FT(10))); <span class="comment">// 10 degrees of tolerance for parallelism / orthogonality</span></div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* all detected planes are regularized"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Please note that this function used to be a part of the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgShapeDetection">Shape Detection</a> package. You can still use the old API of that function, however to avoid parameters ambiguity, we strongly suggest to use the new API with the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/index.html#BGLNamedParameters">Named Parameters</a> mechanism.</dd></dl>
<h1><a class="anchor" id="QP_Regularization"></a>
QP Regularization</h1>
<p>The shape regularization component is a generic framework that is based on the Quadratic Programming (QP) global regularization algorithm <a class="el" href="citelist.html#CITEREF_cgal:bl-kippi-18">[1]</a> by Bauchet et Lafarge. You should refer to this section only if you want to know details on how the shape regularization framework is organized internally or you want to extend that framework by implementing your own regularization types.</p>
<p><a class="el" href="index.html#QP_Regularization_Segments_Angles">Angle Regularization</a> and <a class="el" href="index.html#QP_Regularization_Segments_Offset">Offset Regularization</a> that we presented before are two particular instances of this algorithm. Other instances can be added by the user, as explained <a class="el" href="index.html#QP_Regularization_Implementation">here</a>.</p>
<h2><a class="anchor" id="QP_Regularization_Framework"></a>
Framework</h2>
<p>This framework follows Section 3 from <a class="el" href="citelist.html#CITEREF_cgal:bl-kippi-18">[1]</a>, however the algorithm from that paper was extended and generalized. The idea behind the main algorithm is to minimize the energy</p>
<center> \(U(\boldsymbol{x}) = (1 - \lambda) D(\boldsymbol{x}) + \lambda V(\boldsymbol{x})\),</center><p>where \(\boldsymbol{x} = (x_1, \dots, x_n)\) is a configuration of perturbations operated on \(n\) input items, \(D(\boldsymbol{x})\) and \(V(\boldsymbol{x})\) represent a data term and pairwise potential respectively, and \(\lambda \in [0, 1]\) is a parameter weighting these two terms. By setting up the correct types of \(D(\boldsymbol{x})\) and \(V(\boldsymbol{x})\), the problem can be reformulated into a quadratic optimization problem with \((n + m)\) variables and \(2(n + m)\) linear constraints, where \(m\) is the number of unique pairs formed by connecting an item to one of its closest neighbors. Let us explain how it all works when the input items are segments and we want to regularize their orientations in order to reinforce parallelism and orthogonality among them.</p>
<p>To set up the framework, we first need to find closest neighbors for each segment. These neighbors are provided via the concept <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1NeighborQuery.html" title="A concept that describes the set of methods used by the class QP_regularization to access neighbors o...">NeighborQuery</a></code>. Internally, we create a graph based on these neighbors. Every edge \(\{i, j\}\), where \(i\) is the index of the ith segment and \(j\) is the index of the jth segment is inserted in the graph whenever \(i &lt; j\). This way each pair is inserted only once. The neighbors are found via the <a class="el" href="index.html#QP_Regularization_Segments_Delaunay">Delaunay Neighbor Query</a>.</p>
<p>When we have the graph, we fill in the terms \(D(\boldsymbol{x})\) and \(V(\boldsymbol{x})\) via the concept <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html" title="A concept that describes the set of methods used by the class QP_regularization to access various dat...">RegularizationType</a></code>. First, we obtain a maximum perturbation bound for each segment via the method <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html#a6425688d6368960b0aa5bfd0e6e13541" title="returns the maximum bound on a regularization characteristic (angle-orientation/ distance-offset/etc...">RegularizationType::bound()</a></code>. Since we want to rotate segments, we return here the maximum allowed angle deviation for each segment with respect to its original orientation, lets say 25 degrees.</p>
<p>Next, for every edge \(\{i, j\}\) in the graph, we compute the perturbation difference between two segments \(i\) and \(j\) via the method <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html#ac5bd68e930f080c0b619b3541c5fad9c" title="returns an objective function value between two geometric objects, which are direct neighbors...">RegularizationType::target()</a></code>. For example, that could be a difference of segment orientations with respect to \(90\) or \(180\) degrees. Lets say an angle between two segments is \(85\) degrees then we return \(90 - 85 = 5\) degrees since this is what we should minimize in order to make the two segments orthogonal to each other.</p>
<p>Then we set up the quadratic programming problem that is solved via the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classQuadraticProgramTraits.html">QuadraticProgramTraits</a></code> concept. The returned result is stored as a vector of the length \((n + m)\) with the updated perturbation values, where the first \(n\) values are the values that should be added to the original orientations of the input segments in order to update them and the last \(m\) values are minimized to zeros. The update is achieved via the method <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html#a5fa1b89221a8d2515acff817ceeb6946" title="updates regularization characteristics (angle-orientation/distance-offset/etc.) of the geometric obje...">RegularizationType::update()</a></code>.</p>
<p>Overall, the class <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1QP__regularization.html" title="Shape regularization algorithm based on the quadratic programming global optimization. ">QP_regularization</a></code> is parameterized by:</p><ul>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1NeighborQuery.html" title="A concept that describes the set of methods used by the class QP_regularization to access neighbors o...">NeighborQuery</a></code> that provides the means for accessing local neighbors of an item,</li>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html" title="A concept that describes the set of methods used by the class QP_regularization to access various dat...">RegularizationType</a></code> that determines a regularization type to be applied, and</li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classQuadraticProgramTraits.html">QuadraticProgramTraits</a></code> that is used to solve the corresponding QP problem.</li>
</ul>
<p>Within this generic framework, users can regularize any set of input items provided their own neighbor search, regularization type, and QP solver.</p>
<h2><a class="anchor" id="QP_Regularization_Neighborhood"></a>
Neighborhood</h2>
<p>The concept <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1NeighborQuery.html" title="A concept that describes the set of methods used by the class QP_regularization to access neighbors o...">NeighborQuery</a></code> provides the means for accessing local neighbors of an item. To create a model that respects this concept, the user has to provide an overload of the operator:</p>
<ul>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1NeighborQuery.html#afe9ac86f81427f217a72ee74523e4ade" title="fills in neighbors with indices of all geometric objects, which are direct neighbors of the object wi...">NeighborQuery::operator()()</a></code> that has to fill in a vector with indices of all items, which are neighbors of the query item.</li>
</ul>
<p>For example, given a segment, this operator may return a vector with indices of some other input segments, which are within a certain distance from this segment, however this distance is measured. See above and <a class="el" href="index.html#QP_Regularization_Segments_Delaunay">this section</a> for more details.</p>
<h2><a class="anchor" id="QP_Regularization_Type"></a>
Regularization</h2>
<p>The concept <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html" title="A concept that describes the set of methods used by the class QP_regularization to access various dat...">RegularizationType</a></code> determines a type of regularization to be applied. To create a model that respects this concept, three functions have to be defined:</p>
<ul>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html#ac5bd68e930f080c0b619b3541c5fad9c" title="returns an objective function value between two geometric objects, which are direct neighbors...">RegularizationType::target()</a></code> a function that estimates a type of regularity between two neighbors,</li>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html#a6425688d6368960b0aa5bfd0e6e13541" title="returns the maximum bound on a regularization characteristic (angle-orientation/ distance-offset/etc...">RegularizationType::bound()</a></code> a function that returns a maximum bound on the allowed regularity change, and</li>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html#a5fa1b89221a8d2515acff817ceeb6946" title="updates regularization characteristics (angle-orientation/distance-offset/etc.) of the geometric obje...">RegularizationType::update()</a></code> a function that updates input items with respect to the modified regularities.</li>
</ul>
<p>For example, if we want to regularize segment orientations, that is to make segments parallel and orthogonal to each other, the first function should return an angle perturbation between a query segment and each of its neighbors; the second function should return a maximum angle within which a rotation of the query segment is accepted; and the third function should update original orientations of the input segments. See above and <a class="el" href="index.html#QP_Regularization_Segments_Angles">this section</a> for more details.</p>
<h2><a class="anchor" id="QP_Regularization_Solvers"></a>
Solvers</h2>
<p>In order to solve the associated QP problem of the algorithm above, CGAL provides a wrapper <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classCGAL_1_1OSQP__quadratic__program__traits.html">CGAL::OSQP_quadratic_program_traits</a></code> of the external <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartyOSQP">OSQP solver</a> that is a model of the concept <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classQuadraticProgramTraits.html">QuadraticProgramTraits</a></code>.</p>
<p>Alternatively, the internal CGAL solver from the package <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgQPSolver">Linear and Quadratic Programming Solver</a> can be used, however we do not recommend applying it. The internal quadratic program that has to be solved for shape regularization is sparse. The CGAL version will internally convert this problem into a dense one that takes considerable effort to solve, while the OSQP version takes a special care of the sparse nature of the problem that leads to better performance. Since the class <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1QP__regularization.html" title="Shape regularization algorithm based on the quadratic programming global optimization. ">QP_regularization</a></code> is parameterized by the general concept <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classQuadraticProgramTraits.html">QuadraticProgramTraits</a></code>, the users are also welcome to provide their own version of the solver.</p>
<h2><a class="anchor" id="QP_Regularization_Implementation"></a>
Implementation</h2>
<p>If you want to implement your own regularization approach that follows the same framework, for example to reinforce a different type of regularity than is already provided, you have to implement your own model of the <a class="el" href="index.html#QP_Regularization_Type">RegularizationType</a> concept and possibly a model of the <a class="el" href="index.html#QP_Regularization_Neighborhood">NeighborQuery</a> concept. These concepts are used to parameterize the main <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1QP__regularization.html" title="Shape regularization algorithm based on the quadratic programming global optimization. ">QP_regularization</a></code> algorithm:</p><ol type="1">
<li>Use <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1NeighborQuery.html" title="A concept that describes the set of methods used by the class QP_regularization to access neighbors o...">NeighborQuery</a></code> to find local neighbors of each input item;</li>
<li>Use <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html" title="A concept that describes the set of methods used by the class QP_regularization to access various dat...">RegularizationType</a></code> to estimate current regularities among these neighbors;</li>
<li>Use <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html" title="A concept that describes the set of methods used by the class QP_regularization to access various dat...">RegularizationType</a></code> to set maximum bounds on the allowed regularity changes;</li>
<li>Use <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classQuadraticProgramTraits.html">QuadraticProgramTraits</a></code> to solve the quadratic programming problem;</li>
<li>Use <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html" title="A concept that describes the set of methods used by the class QP_regularization to access various dat...">RegularizationType</a></code> to update input items with respect to the modified regularities.</li>
</ol>
<p>In addition, the user may also want to change a <a class="el" href="index.html#QP_Regularization_Solvers">QP solver</a> if he knows how to optimize it for a specific type of input data. To do that, the user has to implement a model of the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classQuadraticProgramTraits.html">QuadraticProgramTraits</a></code> concept.</p>
<p>An example below shows how to define your own type of the above concepts and how to choose among available solvers.</p>
<p><br />
<b>File</b> <a class="el" href="Shape_regularization_2regularize_framework_8cpp-example.html">Shape_regularization/regularize_framework.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Shape__regularization_8h.html">CGAL/Shape_regularization.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> Kernel = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> FT     = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Custom_object {</div><div class="line">  <span class="keyword">const</span> std::string name;</div><div class="line">  Custom_object(<span class="keyword">const</span> std::string name_) :</div><div class="line">  name(name_) { }</div><div class="line">  <span class="comment">// define your object here</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Custom_neighbor_query_2 {</div><div class="line">  <span class="keywordtype">void</span> operator()(</div><div class="line">    <span class="keyword">const</span> std::size_t query_index, std::vector&lt;std::size_t&gt;&amp; neighbors) {</div><div class="line">    neighbors.clear();</div><div class="line">    <span class="keywordflow">if</span> (query_index == 0) { neighbors.push_back(1); } <span class="comment">// first  object</span></div><div class="line">    <span class="keywordflow">if</span> (query_index == 1) { neighbors.push_back(0); } <span class="comment">// second object</span></div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Custom_regularization_2 {</div><div class="line">  FT bound(<span class="keyword">const</span> std::size_t )<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> FT(5); <span class="comment">// maximum angle change</span></div><div class="line">  }</div><div class="line">  FT target(<span class="keyword">const</span> std::size_t , <span class="keyword">const</span> std::size_t ) {</div><div class="line">    <span class="keywordflow">return</span> FT(0); <span class="comment">// 0 angle change</span></div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> update(<span class="keyword">const</span> std::vector&lt;FT&gt;&amp; ) {</div><div class="line">    <span class="comment">// skip update</span></div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> NT&gt;</div><div class="line"><span class="keyword">class </span>Custom_quadratic_program_traits  {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keywordtype">void</span>  set_P(<span class="keyword">const</span> std::size_t, <span class="keyword">const</span> std::size_t, <span class="keyword">const</span> FT) { }</div><div class="line">  <span class="keywordtype">void</span>  set_q(<span class="keyword">const</span> std::size_t, <span class="keyword">const</span> FT) { }</div><div class="line">  <span class="keywordtype">void</span>  set_r(<span class="keyword">const</span> FT) { }</div><div class="line">  <span class="keywordtype">void</span>  set_A(<span class="keyword">const</span> std::size_t, <span class="keyword">const</span> std::size_t, <span class="keyword">const</span> FT) { }</div><div class="line">  <span class="keywordtype">void</span>  set_l(<span class="keyword">const</span> std::size_t, <span class="keyword">const</span> FT) { }</div><div class="line">  <span class="keywordtype">void</span>  set_u(<span class="keyword">const</span> std::size_t, <span class="keyword">const</span> FT) { }</div><div class="line">  <span class="keywordtype">void</span> resize(<span class="keyword">const</span> std::size_t, <span class="keyword">const</span> std::size_t) { }</div><div class="line"></div><div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> OutputIterator&gt;</div><div class="line">  <span class="keywordtype">bool</span> solve(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classOutputIterator.html">OutputIterator</a> solution) {</div><div class="line"></div><div class="line">    <span class="comment">// 3 = 2 objects + 1 edge between them</span></div><div class="line">    <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; 3; ++i) {</div><div class="line">      *(++solution) = NT(0);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">using</span> Objects = std::vector&lt;Custom_object&gt;;</div><div class="line"><span class="keyword">using</span> Neighbor_query = Custom_neighbor_query_2;</div><div class="line"><span class="keyword">using</span> Regularization_type = Custom_regularization_2;</div><div class="line"><span class="keyword">using</span> Quadratic_program = Custom_quadratic_program_traits&lt;FT&gt;;</div><div class="line"><span class="keyword">using</span> Regularizer = <a class="code" href="classCGAL_1_1Shape__regularization_1_1QP__regularization.html">CGAL::Shape_regularization::QP_regularization</a>&lt;</div><div class="line">  Kernel, Objects, Neighbor_query, Regularization_type, Quadratic_program&gt;;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">  Neighbor_query neighbor_query;</div><div class="line">  Regularization_type regularization_type;</div><div class="line">  Quadratic_program quadratic_program;</div><div class="line"></div><div class="line">  std::vector&lt;Custom_object&gt; objects = {</div><div class="line">    Custom_object(<span class="stringliteral">"first"</span>), Custom_object(<span class="stringliteral">"second"</span>)</div><div class="line">  };</div><div class="line"></div><div class="line">  Regularizer regularizer(</div><div class="line">    objects, neighbor_query, regularization_type, quadratic_program);</div><div class="line">  regularizer.regularize();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* regularized 2 objects"</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Shape_Regularization_History"></a>
History</h1>
<p>The shape regularization algorithm for 2D segments was first implemented by Jean-Philippe Bauchet under the supervision of Florent Lafarge and then generalized by Gennadii Sytov during the Google Summer of Code 2019 under the supervision of Dmitry Anisimov. The contour regularization algorithm was developed and implemented by Dmitry Anisimov and Simon Giraudot. Plane regularization was added by Simon Giraudot based on the prototype version developed by Florent Lafarge.</p>
<h1><a class="anchor" id="Shape_Regularization_Acknowledgements"></a>
Acknowledgments</h1>
<p>We wish to thank Andreas Fabri and Marc Pouget for useful discussions and reviews. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jul 4 2022 13:25:33 for CGAL 5.6 - Shape Regularization by
    <a href="https://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>
</html>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.6 - Shape Regularization
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Shape_Regularization"></a>  </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Authors</dt><dd>Dmitry Anisimov, Gennadii Sytov, Simon Giraudot, Jean-Philippe Bauchet, and Florent Lafarge</dd></dl>
<p><a class="anchor" id="fig__regularize_2_overview"></a></p><div class="image">
<object type="image/svg+xml" data="overview.svg">overview.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__regularize_2_overview">Figure 82.1</a> A closed contour before (red) and after (green) regularization.  </div> <br /> 
<h1><a class="anchor" id="Shape_Regularization_Intro"></a>
Introduction</h1>
<p>This CGAL package enables to regularize a set of segments and open or closed contours in 2D and a set of planes in 3D such that all input objects are rotated and aligned with respect to the user-specified conditions. In addition, we provide a global regularization framework that can be adjusted for the user needs and any type of geometric objects. This package can also be used in conjunction with the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgShapeDetection">Shape Detection</a> package.</p>
<h1><a class="anchor" id="QP_Regularization_Segments"></a>
Segments</h1>
<p>Given a set of unordered 2D segments, users can reinforce three types of regularities among these segments:</p><ul>
<li><em>Parallelism</em>: segments, which are detected as near parallel, are made exactly parallel.</li>
<li><em>Orthogonality</em>: segments, which are detected as near orthogonal, are made exactly orthogonal.</li>
<li><em>Collinearity</em>: parallel segments, which are detected as near collinear, are made exactly collinear.</li>
</ul>
<p>A typical use of this algorithm consists of the following steps:</p><ol type="1">
<li>Create an input range with 2D segments;</li>
<li>Define groups of segments, which should be regularized together;</li>
<li>Instantiate models of the concepts <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1NeighborQuery.html" title="A concept that describes the set of methods used by the class QP_regularization to access neighbors o...">NeighborQuery</a></code> and <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html" title="A concept that describes the set of methods used by the class QP_regularization to access various dat...">RegularizationType</a></code> with the proper parameters;</li>
<li>Call the function <code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#ga3cde2421ff91530c13c9e8f1feaeae1c" title="regularizes a set of 2D segments. ">regularize_segments()</a></code>.</li>
</ol>
<p>Once the user has defined an input range with 2D segments, he can either provide them all to the regularization algorithm, which is the default option, or they could be reorganized into groups of contextually similar segments. For example, all segments of the same length could form a group. When regularizing, only segments within the group are taken into account, that is no segment from one group will be oriented and/or aligned towards a segment from another group (see more details <a class="el" href="index.html#QP_Regularization_Segments_Delaunay">here</a>).</p>
<p>To apply the algorithm, the user has to define two models: one of the concept <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1NeighborQuery.html" title="A concept that describes the set of methods used by the class QP_regularization to access neighbors o...">NeighborQuery</a></code> that provides an access to the closest neighbors of a segment; and the other one of the concept <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html" title="A concept that describes the set of methods used by the class QP_regularization to access various dat...">RegularizationType</a></code> that provides one of the available regularities, which should be adjusted.</p>
<p>This CGAL component provides a model of the <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1NeighborQuery.html" title="A concept that describes the set of methods used by the class QP_regularization to access neighbors o...">NeighborQuery</a></code> concept:</p>
<ul>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Delaunay__neighbor__query__2.html" title="A neighbor query based on a Delaunay triangulation, which enables to find the nearest neighbors in a ...">Segments::Delaunay_neighbor_query_2</a></code> - finds local neighbors of each segment by constructing a Delaunay triangulation. See more details <a class="el" href="index.html#QP_Regularization_Segments_Delaunay">here</a>.</li>
</ul>
<p>And two models of the <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html" title="A concept that describes the set of methods used by the class QP_regularization to access various dat...">RegularizationType</a></code> concept:</p>
<ul>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Angle__regularization__2.html" title="An angle-based regularization type for 2D segments that reinforces parallelism and orthogonality rela...">Segments::Angle_regularization_2</a></code> - orients segments to reinforce parallelism and orthogonality among them. See more details <a class="el" href="index.html#QP_Regularization_Segments_Angles">here</a>.</li>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Offset__regularization__2.html" title="An offset-based regularization type for 2D segments that reinforces collinearity relationships. ">Segments::Offset_regularization_2</a></code> - aligns parallel segments to reinforce collinearity among them. See more details <a class="el" href="index.html#QP_Regularization_Segments_Offset">here</a>.</li>
</ul>
<p>The standard way to regularize a set of input segments is to first apply an angle regularization and then an offset regularization, however the algorithm is flexible to handle other scenarios as you will see later.</p>
<dl class="section note"><dt>Note</dt><dd>The core of this algorithm is the <a class="el" href="index.html#QP_Regularization">QP Regularization</a> framework. For more details, please refer to that section.</dd></dl>
<p>The example below shows the most straightforward entry point to the algorithm, where we apply two type of regularities: parallelism and orthogonality, within the group of all input segments. The algorithm is called via the function <code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#ga3cde2421ff91530c13c9e8f1feaeae1c" title="regularizes a set of 2D segments. ">regularize_segments()</a></code>.</p>
<p><a class="anchor" id="fig__regularize_simple_example"></a></p><div class="image">
<object type="image/svg+xml" data="regularize_simple.svg">regularize_simple.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__regularize_simple_example">Figure 82.2</a> A set of 2D segments before (red) and after (green) the angle and offset regularization.  </div> <br /> 
<p><br />
<b>File</b> <a class="el" href="Shape_regularization_2regularize_simple_8cpp-example.html">Shape_regularization/regularize_simple.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="regularize__segments_8h.html">CGAL/Shape_regularization/regularize_segments.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>    = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> Point_2   = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>;</div><div class="line"><span class="keyword">using</span> Segment_2 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#aa6d2526f8d1571f4a38aa8a6d9a02c2b">Kernel::Segment_2</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">  <span class="comment">// Create input segments.</span></div><div class="line">  std::vector&lt;Segment_2&gt; segments = {</div><div class="line">    Segment_2(Point_2(0.2, 0.0), Point_2(1.2, 0.0)),</div><div class="line">    Segment_2(Point_2(1.2, 0.1), Point_2(2.2, 0.1)),</div><div class="line">    Segment_2(Point_2(2.2, 0.0), Point_2(2.0, 2.0)),</div><div class="line">    Segment_2(Point_2(2.0, 2.0), Point_2(1.0, 2.0)),</div><div class="line">    Segment_2(Point_2(1.0, 1.9), Point_2(0.0, 1.9)),</div><div class="line">    Segment_2(Point_2(0.0, 2.0), Point_2(0.2, 0.0))</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="comment">// Regularize all segments: both angles and offsets.</span></div><div class="line">  <a class="code" href="group__PkgShapeRegularizationRefSegments.html#ga3cde2421ff91530c13c9e8f1feaeae1c">CGAL::Shape_regularization::Segments::</a></div><div class="line"><a class="code" href="group__PkgShapeRegularizationRefSegments.html#ga3cde2421ff91530c13c9e8f1feaeae1c">    regularize_segments</a>(segments);</div><div class="line">}</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>As it can be seen from the example, the algorithm does not prioritize any directions like vertical or horizontal but rather returns the optimal regularized configuration of the input segments.</dd></dl>
<h2><a class="anchor" id="QP_Regularization_Segments_Delaunay"></a>
Delaunay Neighbor Query</h2>
<p>This class finds local neighbors of each segment by constructing a Delaunay triangulation, using the class <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2</a></code>, upon the center points of the input segments. The local neighborhood of a segment is thus defined by the corresponding one-ring neighborhood in the triangulation. The Delaunay triangulation can be constructed only for a group of at least two segments.</p>
<p>The Delaunay neighbor query class constructs the Delaunay triangulation from a group of segments, which has to be provided by the user through the <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Delaunay__neighbor__query__2.html#aaffd7eb2871e03b6e0d3cc997b440661" title="inserts a group of segments from input_range and finds their neighbors within the group...">Segments::Delaunay_neighbor_query_2::add_group()</a></code> method, and finds local neighbors of each segment only within the group. If this method is never called, all input segments are treated as a group.</p>
<p>Note that a group can include fewer segments than in the input range. For example, if your input range contains multiple segments, which contextually form three different groups of objects lets say boundaries of three different buildings and you do not want to regularize these buildings with respect to each other, but rather within each building boundary, in that case you should call the <code>add_group</code> method three times. An example of such groups can be seen in <a class="el" href="index.html#Regularize_15_Segments_Figure">this figure</a>, where you can see three groups of contextually similar segments: outer boundary, interior top rhombus and interior bottom rhombus or in the figure below.</p>
<p>In this figure, there are two squares, one external and one internal. On the left, the red segments show the connectivity among all input segments that is a Delaunay triangulation built upon all these segments, while on the right, the green segments show the connectivity only among external square segments and blue segments only among internal square segments.</p>
<p><a class="anchor" id="fig__delaunay_groups"></a></p><div class="image">
<object type="image/svg+xml" data="delaunay_groups.svg">delaunay_groups.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__delaunay_groups">Figure 82.3</a> Delaunay triangulation (red) for all input segments (black, left) and two contextually different groups with green Delaunay for the external segments and blue Delaunay for the internal segments (right).  </div> <br /> 
<h2><a class="anchor" id="QP_Regularization_Segments_Angles"></a>
Angle Regularization</h2>
<p>This class orients 2D segments in order to reinforce parallelism and orthogonality among them. To apply the angle regularization on a set of 2D segments, the user has to:</p><ul>
<li>specify the maximum angle deviation of a segment from its initial orientation that has to be within the interval [0, 90] degrees. If no bound is provided, a bound of 25 degrees will be set as the default value;</li>
<li>add groups of segments, if any, through the <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Angle__regularization__2.html#a973f865ac9b75042b31ec29d88f2b606" title="inserts a group of segments from input_range. ">Segments::Angle_regularization_2::add_group()</a></code> method.</li>
</ul>
<p>After the optimization, each segment is rotated with respect to its midpoint.</p>
<p><a class="anchor" id="fig__regularize_100_segments_angles_example"></a></p><div class="image">
<object type="image/svg+xml" data="regularize_100_segments_angles.svg">regularize_100_segments_angles.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__regularize_100_segments_angles_example">Figure 82.4</a> A generated set of 2D segments before (red) and after (green) the angle regularization.  </div> <br /> 
<p>The following example demonstrates the usage of the shape regularization algorithm for angles on a set of 100 near orthogonal segments generated with the help of <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgGenerators">CGAL Geometric Object Generators</a>. The entire <code>InputRange</code> is provided to the angle regularization class as a group. The maximum angle bound is set to 40 degrees.</p>
<p><br />
<b>File</b> <a class="el" href="Shape_regularization_2regularize_100_segments_angles_8cpp-example.html">Shape_regularization/regularize_100_segments_angles.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include "include/utils.h"</span></div><div class="line"><span class="preprocessor">#include "include/Saver.h"</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="regularize__segments_8h.html">CGAL/Shape_regularization/regularize_segments.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Typedefs.</span></div><div class="line"><span class="keyword">using</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>    = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> FT        = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"><span class="keyword">using</span> Segment_2 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#aa6d2526f8d1571f4a38aa8a6d9a02c2b">Kernel::Segment_2</a>;</div><div class="line"><span class="keyword">using</span> Segments  = std::vector&lt;Segment_2&gt;;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Neighbor_query =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Delaunay__neighbor__query__2.html">CGAL::Shape_regularization::Segments::Delaunay_neighbor_query_2&lt;Kernel, Segments&gt;</a>;</div><div class="line"><span class="keyword">using</span> Angle_regularization =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Angle__regularization__2.html">CGAL::Shape_regularization::Segments::Angle_regularization_2&lt;Kernel, Segments&gt;</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div><div class="line"></div><div class="line">  <span class="comment">// If we want to save the result in a file, we save it in a path.</span></div><div class="line">  std::string path = <span class="stringliteral">""</span>;</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1) path = argv[1];</div><div class="line">  Saver&lt;Kernel&gt; saver;</div><div class="line"></div><div class="line">  <span class="comment">// Initialize 100 near-orthogonal segments.</span></div><div class="line">  std::vector&lt;Segment_2&gt; segments;</div><div class="line">  create_example_angles(segments);</div><div class="line"></div><div class="line">  <span class="comment">// Save input segments.</span></div><div class="line">  <span class="keywordflow">if</span> (path != <span class="stringliteral">""</span>) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = path + <span class="stringliteral">"regularize_100_segments_angles_before"</span>;</div><div class="line">    saver.export_eps_segments(segments, full_path, FT(1));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Angle regularization.</span></div><div class="line">  <span class="keyword">const</span> FT max_angle_2 = FT(40);</div><div class="line"></div><div class="line">  <span class="comment">// Create neigbor query and angle-based regularization model.</span></div><div class="line">  Neighbor_query neighbor_query(segments);</div><div class="line">  Angle_regularization angle_regularization(</div><div class="line">    segments, CGAL::parameters::maximum_angle(max_angle_2));</div><div class="line"></div><div class="line">  <span class="comment">// Regularize.</span></div><div class="line">  <a class="code" href="group__PkgShapeRegularizationRefSegments.html#ga3cde2421ff91530c13c9e8f1feaeae1c">CGAL::Shape_regularization::Segments::regularize_segments</a>(</div><div class="line">    segments, neighbor_query, angle_regularization);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* number of modified segments = "</span> &lt;&lt;</div><div class="line">    angle_regularization.number_of_modified_segments() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save regularized segments.</span></div><div class="line">  <span class="keywordflow">if</span> (path != <span class="stringliteral">""</span>) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = path + <span class="stringliteral">"regularize_100_segments_angles_after"</span>;</div><div class="line">    saver.export_eps_segments(segments, full_path, FT(1));</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="QP_Regularization_Segments_Offset"></a>
Offset Regularization</h2>
<p>This class aligns 2D parallel segments in order to reinforce collinearity among them. To apply the offset regularization on a set of 2D segments, the user has to:</p><ul>
<li>specify the maximum distance between two parallel segments that has to be within the interval [0, +inf). If no bound is provided, a bound of 0.5 unit length will be set as the default value.</li>
<li>add groups of parallel segments through the <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Offset__regularization__2.html#a8e9dbdec86eb77a43911699e59307865" title="inserts a group of segments from input_range. ">Segments::Offset_regularization_2::add_group()</a></code> method. If the user does not have these groups, they can be obtained from <a class="el" href="index.html#QP_Regularization_Segments_Angles">Angle Regularization</a> by orienting original segments or from the utility function <code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#gac72eca9b32b73a3713edffd2da5609f2" title="finds groups of parallel segments in a set of 2D segments. ">Segments::parallel_groups()</a></code>. See more details <a class="el" href="index.html#QP_Regularization_Segments_Groups">here</a>.</li>
</ul>
<p>After the optimization, each segment is translated along its orthogonal direction.</p>
<p>Note that if the input segments within the same group are not exactly parallel, the distance, which is defined as the distance between the midpoint of one segment and the projection of this point onto the supporting line of another segment, is not a good metric to optimize positions of the segments that may lead to deviations in the result from what the user would expect in case of exactly parallel segments. The offset regularization does not internally orient segments to make them exactly parallel. This is what the <a class="el" href="index.html#QP_Regularization_Segments_Angles">Angle Regularization</a> class for. The utility function <code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#gac72eca9b32b73a3713edffd2da5609f2" title="finds groups of parallel segments in a set of 2D segments. ">Segments::parallel_groups()</a></code> does not orient segments either, but only returns groups of near-parallel segments.</p>
<p><a class="anchor" id="fig__regularize_100_segments_offsets_example"></a></p><div class="image">
<object type="image/svg+xml" data="regularize_100_segments_offsets.svg">regularize_100_segments_offsets.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__regularize_100_segments_offsets_example">Figure 82.5</a> A generated set of 2D segments before (red) and after (green) the offset regularization.  </div> <br /> 
<p>The following example demonstrates the usage of the shape regularization algorithm for offsets on a set of 100 parallel segments located within a circle. The function <code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#gac72eca9b32b73a3713edffd2da5609f2" title="finds groups of parallel segments in a set of 2D segments. ">Segments::parallel_groups()</a></code> is used to obtain the groups of parallel segments. The maximum offset bound is set to 0.25 unit length.</p>
<p><a class="anchor" id="QP_Parallel_Groups_Example"></a><br />
<b>File</b> <a class="el" href="Shape_regularization_2regularize_100_segments_offsets_8cpp-example.html">Shape_regularization/regularize_100_segments_offsets.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include "include/utils.h"</span></div><div class="line"><span class="preprocessor">#include "include/Saver.h"</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="regularize__segments_8h.html">CGAL/Shape_regularization/regularize_segments.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Typedefs.</span></div><div class="line"><span class="keyword">using</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>    = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> FT        = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"><span class="keyword">using</span> Segment_2 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#aa6d2526f8d1571f4a38aa8a6d9a02c2b">Kernel::Segment_2</a>;</div><div class="line"><span class="keyword">using</span> Segments  = std::vector&lt;Segment_2&gt;;</div><div class="line"><span class="keyword">using</span> Indices   = std::vector&lt;std::size_t&gt;;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Neighbor_query =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Delaunay__neighbor__query__2.html">CGAL::Shape_regularization::Segments::Delaunay_neighbor_query_2&lt;Kernel, Segments&gt;</a>;</div><div class="line"><span class="keyword">using</span> Offset_regularization =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Offset__regularization__2.html">CGAL::Shape_regularization::Segments::Offset_regularization_2&lt;Kernel, Segments&gt;</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div><div class="line"></div><div class="line">  <span class="comment">// If we want to save the result in a file, we save it in a path.</span></div><div class="line">  std::string path = <span class="stringliteral">""</span>;</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1) path = argv[1];</div><div class="line">  Saver&lt;Kernel&gt; saver;</div><div class="line"></div><div class="line">  <span class="comment">// Initialize 100 segments in a fuzzy circle.</span></div><div class="line">  std::vector&lt;Segment_2&gt; segments;</div><div class="line">  create_example_offsets(segments);</div><div class="line"></div><div class="line">  <span class="comment">// Save input segments.</span></div><div class="line">  <span class="keywordflow">if</span> (path != <span class="stringliteral">""</span>) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = path + <span class="stringliteral">"regularize_100_segments_offsets_before"</span>;</div><div class="line">    saver.export_eps_segments(segments, full_path, FT(100));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Find groups of parallel segments.</span></div><div class="line">  <span class="keyword">const</span> FT max_angle_2 = FT(1);</div><div class="line"></div><div class="line">  std::vector&lt;Indices&gt; pgroups;</div><div class="line">  <a class="code" href="group__PkgShapeRegularizationRefSegments.html#gac72eca9b32b73a3713edffd2da5609f2">CGAL::Shape_regularization::Segments::parallel_groups</a>(</div><div class="line">    segments, std::back_inserter(pgroups),</div><div class="line">    CGAL::parameters::maximum_angle(max_angle_2));</div><div class="line"></div><div class="line">  <span class="comment">// Offset regularization.</span></div><div class="line">  <span class="keyword">const</span> FT max_offset_2 = FT(1) / FT(4);</div><div class="line"></div><div class="line">  <span class="comment">// Create neigbor query and offset-based regularization model.</span></div><div class="line">  Neighbor_query neighbor_query(segments);</div><div class="line">  Offset_regularization offset_regularization(</div><div class="line">    segments, CGAL::parameters::maximum_offset(max_offset_2));</div><div class="line"></div><div class="line">  <span class="comment">// Add each group of parallel segments with at least 2 segments.</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; pgroup : pgroups) {</div><div class="line">    neighbor_query.add_group(pgroup);</div><div class="line">    offset_regularization.add_group(pgroup);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Regularize.</span></div><div class="line">  <a class="code" href="group__PkgShapeRegularizationRefSegments.html#ga3cde2421ff91530c13c9e8f1feaeae1c">CGAL::Shape_regularization::Segments::regularize_segments</a>(</div><div class="line">    segments, neighbor_query, offset_regularization);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* number of modified segments = "</span> &lt;&lt;</div><div class="line">    offset_regularization.number_of_modified_segments() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save regularized segments.</span></div><div class="line">  <span class="keywordflow">if</span> (path != <span class="stringliteral">""</span>) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = path + <span class="stringliteral">"regularize_100_segments_offsets_after"</span>;</div><div class="line">    saver.export_eps_segments(segments, full_path, FT(100));</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="QP_Regularization_Segments_Examples"></a>
Angle + Offset Regularization</h2>
<p>The following examples demonstrate the usage of the shape regularization algorithm for both angles and offsets sequentially on a set of 2D segments.</p>
<p>The first example contains 15 segments. The angle and offset regularizations are performed on these segments sequentially using the maximum bounds of 10 degrees and 0.1 unit length respectively. We also show here how to create and work with contextually similar groups of segments and regularize each group on its own. The defined groups are the outer boundary, top and bottom rhombus. Since the shape regularization algorithm on segments is based on the <a class="el" href="index.html#QP_Regularization">QP Regularization</a> framework, this example also shows how to use that framework directly instead of calling the function <code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#ga3cde2421ff91530c13c9e8f1feaeae1c" title="regularizes a set of 2D segments. ">regularize_segments()</a></code>.</p>
<p><a class="anchor" id="Regularize_15_Segments_Figure"></a><a class="anchor" id="fig__regularize_15_segments_example"></a></p><div class="image">
<object type="image/svg+xml" data="regularize_15_segments.svg">regularize_15_segments.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__regularize_15_segments_example">Figure 82.6</a> A set of 2D segments before (red), after the angle (yellow), and the offset (green) regularization.  </div> <br /> 
<p><br />
<b>File</b> <a class="el" href="Shape_regularization_2regularize_15_segments_8cpp-example.html">Shape_regularization/regularize_15_segments.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include "include/utils.h"</span></div><div class="line"><span class="preprocessor">#include "include/Saver.h"</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Shape__regularization_8h.html">CGAL/Shape_regularization.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Typedefs.</span></div><div class="line"><span class="keyword">using</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>      = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div><div class="line"><span class="keyword">using</span> FT          = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"><span class="keyword">using</span> Segment_2   = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#aa6d2526f8d1571f4a38aa8a6d9a02c2b">Kernel::Segment_2</a>;</div><div class="line"><span class="keyword">using</span> Segments    = std::vector&lt;Segment_2&gt;;</div><div class="line"><span class="keyword">using</span> Indices     = std::vector&lt;std::size_t&gt;;</div><div class="line"><span class="keyword">using</span> Segment_map = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map&lt;Segment_2&gt;</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Neighbor_query =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Delaunay__neighbor__query__2.html">CGAL::Shape_regularization::Segments::Delaunay_neighbor_query_2&lt;Kernel, Segments, Segment_map&gt;</a>;</div><div class="line"><span class="keyword">using</span> Angle_regularization =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Angle__regularization__2.html">CGAL::Shape_regularization::Segments::Angle_regularization_2&lt;Kernel, Segments, Segment_map&gt;</a>;</div><div class="line"><span class="keyword">using</span> Offset_regularization =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Offset__regularization__2.html">CGAL::Shape_regularization::Segments::Offset_regularization_2&lt;Kernel, Segments, Segment_map&gt;</a>;</div><div class="line"><span class="keyword">using</span> Quadratic_program =</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classCGAL_1_1OSQP__quadratic__program__traits.html">CGAL::OSQP_quadratic_program_traits&lt;FT&gt;</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Quadratic_angle_regularizer =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1QP__regularization.html">CGAL::Shape_regularization::QP_regularization</a>&lt;</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>, Segments, Neighbor_query, Angle_regularization, Quadratic_program&gt;;</div><div class="line"><span class="keyword">using</span> Quadratic_offset_regularizer =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1QP__regularization.html">CGAL::Shape_regularization::QP_regularization</a>&lt;</div><div class="line">    Kernel, Segments, Neighbor_query, Offset_regularization, Quadratic_program&gt;;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div><div class="line"></div><div class="line">  <span class="comment">// If we want to save the result in a file, we save it in a path.</span></div><div class="line">  std::string path = <span class="stringliteral">""</span>;</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1) path = argv[1];</div><div class="line">  Saver&lt;Kernel&gt; saver;</div><div class="line"></div><div class="line">  <span class="comment">// Initialize 15 segments.</span></div><div class="line">  std::vector&lt;Segment_2&gt; segments;</div><div class="line">  create_example_15(segments);</div><div class="line"></div><div class="line">  <span class="comment">// We create three groups of segments:</span></div><div class="line">  <span class="comment">// outer, top and bottom rhombuses.</span></div><div class="line">  std::vector&lt;Indices&gt; groups(3);</div><div class="line">  groups[0] = {0, 1, 2, 3, 4, 5, 6}; <span class="comment">// outer</span></div><div class="line">  groups[1] = {7, 8, 9, 10};         <span class="comment">// top rhombus</span></div><div class="line">  groups[2] = {11, 12, 13, 14};      <span class="comment">// bottom rhombus</span></div><div class="line"></div><div class="line">  <span class="comment">// Save input segments.</span></div><div class="line">  <span class="keywordflow">if</span> (path != <span class="stringliteral">""</span>) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = path + <span class="stringliteral">"regularize_15_segments_before"</span>;</div><div class="line">    saver.export_eps_segments(segments, full_path, FT(100));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Angle regularization.</span></div><div class="line">  <span class="keyword">const</span> FT max_angle_2 = FT(10);</div><div class="line"></div><div class="line">  <span class="comment">// Create qp solver, neigbor query, and angle-based regularization model.</span></div><div class="line">  Quadratic_program qp_angles;</div><div class="line">  Neighbor_query neighbor_query(segments);</div><div class="line">  Angle_regularization angle_regularization(</div><div class="line">    segments, CGAL::parameters::maximum_angle(max_angle_2));</div><div class="line"></div><div class="line">  <span class="comment">// Add each group of input segments.</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; group : groups) {</div><div class="line">    neighbor_query.add_group(group);</div><div class="line">    angle_regularization.add_group(group);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Regularize.</span></div><div class="line">  Quadratic_angle_regularizer qp_angle_regularizer(</div><div class="line">    segments, neighbor_query, angle_regularization, qp_angles);</div><div class="line">  qp_angle_regularizer.regularize();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* number of modified segments (angles) = "</span> &lt;&lt;</div><div class="line">    angle_regularization.number_of_modified_segments() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Offset regularization.</span></div><div class="line">  <span class="keyword">const</span> FT max_offset_2 = FT(1) / FT(10);</div><div class="line"></div><div class="line">  <span class="comment">// Get groups of parallel segments after angle regularization.</span></div><div class="line">  std::vector&lt;Indices&gt; pgroups;</div><div class="line">  angle_regularization.parallel_groups(</div><div class="line">    std::back_inserter(pgroups));</div><div class="line"></div><div class="line">  <span class="comment">// Create qp solver and offset-based regularization model.</span></div><div class="line">  Quadratic_program qp_offsets;</div><div class="line">  Offset_regularization offset_regularization(</div><div class="line">    segments, CGAL::parameters::maximum_offset(max_offset_2));</div><div class="line"></div><div class="line">  <span class="comment">// Add each group of parallel segments with at least 2 segments.</span></div><div class="line">  neighbor_query.clear();</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; pgroup : pgroups) {</div><div class="line">    neighbor_query.add_group(pgroup);</div><div class="line">    offset_regularization.add_group(pgroup);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Regularize.</span></div><div class="line">  Quadratic_offset_regularizer qp_offset_regularizer(</div><div class="line">    segments, neighbor_query, offset_regularization, qp_offsets);</div><div class="line">  qp_offset_regularizer.regularize();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* number of modified segments (offsets) = "</span> &lt;&lt;</div><div class="line">    offset_regularization.number_of_modified_segments() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save regularized segments.</span></div><div class="line">  <span class="keywordflow">if</span> (path != <span class="stringliteral">""</span>) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = path + <span class="stringliteral">"regularize_15_segments_after"</span>;</div><div class="line">    saver.export_eps_segments(segments, full_path, FT(100));</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>The second example contains 65 segments, which are constructed from a set of input points. All points are organized into groups such that each group represents an approximate 2D line. Organizing points into such groups can be achieved with the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgShapeDetection">Shape Detection</a> package. We fit a segment to each group of points using the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgPrincipalComponentAnalysisD">Principal Component Analysis</a> package. The angle and offset regularizations are performed on these segments sequentially using the bounds of 80 degrees and 2 unit lengths respectively.</p>
<p><a class="anchor" id="fig__regularize_real_data_2_example"></a></p><div class="image">
<object type="image/svg+xml" data="regularize_real_data_2.svg">regularize_real_data_2.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__regularize_real_data_2_example">Figure 82.7</a> A set of 2D segments before (red), after the angle (yellow), and the offset (green) regularization.  </div> <br /> 
<p><br />
<b>File</b> <a class="el" href="Shape_regularization_2regularize_real_data_2_8cpp-example.html">Shape_regularization/regularize_real_data_2.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include "include/utils.h"</span></div><div class="line"><span class="preprocessor">#include "include/Saver.h"</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Eigen_diagonalize_traits.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/linear_least_squares_fitting_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="regularize__segments_8h.html">CGAL/Shape_regularization/regularize_segments.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Typedefs.</span></div><div class="line"><span class="keyword">using</span> Kernel    = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div><div class="line"><span class="keyword">using</span> FT        = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"><span class="keyword">using</span> Point_2   = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>;</div><div class="line"><span class="keyword">using</span> Segment_2 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#aa6d2526f8d1571f4a38aa8a6d9a02c2b">Kernel::Segment_2</a>;</div><div class="line"><span class="keyword">using</span> Line_2    = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#add6b18567776ee7e80dfdfa44c304772">Kernel::Line_2</a>;</div><div class="line"><span class="keyword">using</span> Points_2  = std::vector&lt;Point_2&gt;;</div><div class="line"><span class="keyword">using</span> Indices   = std::vector&lt;std::size_t&gt;;</div><div class="line"><span class="keyword">using</span> Segments  = std::vector&lt;Segment_2&gt;;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Neighbor_query =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Delaunay__neighbor__query__2.html">CGAL::Shape_regularization::Segments::Delaunay_neighbor_query_2&lt;Kernel, Segments&gt;</a>;</div><div class="line"><span class="keyword">using</span> Angle_regularization =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Angle__regularization__2.html">CGAL::Shape_regularization::Segments::Angle_regularization_2&lt;Kernel, Segments&gt;</a>;</div><div class="line"><span class="keyword">using</span> Offset_regularization =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Offset__regularization__2.html">CGAL::Shape_regularization::Segments::Offset_regularization_2&lt;Kernel, Segments&gt;</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div><div class="line"></div><div class="line">  <span class="comment">// If we want to load a different file, we load it from a path.</span></div><div class="line">  <span class="comment">// Each point comes with the index of the corresponding group.</span></div><div class="line">  <span class="comment">// The file format: x y z i, where i is the group index. The points</span></div><div class="line">  <span class="comment">// are 2D hence z = 0. Each group contains points, which form</span></div><div class="line">  <span class="comment">// an approximate line.</span></div><div class="line">  std::string path = <span class="stringliteral">"data/real_data_2.xyzi"</span>;</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1) path = argv[1];</div><div class="line">  Saver&lt;Kernel&gt; saver;</div><div class="line"></div><div class="line">  <span class="comment">// Initialize input groups with points.</span></div><div class="line">  std::vector&lt;Points_2&gt; groups;</div><div class="line">  initialize_groups(path, groups);</div><div class="line"></div><div class="line">  <span class="comment">// Fit a line to each group of points.</span></div><div class="line">  Line_2 line; Point_2 <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__centroid__grp.html#gacc395064255dfefdb1420309db234210">centroid</a>;</div><div class="line">  std::vector&lt;Line_2&gt; lines;</div><div class="line">  lines.reserve(groups.size());</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; group : groups) {</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Principal_component_analysis.tag:../Principal_component_analysis/" href="../Principal_component_analysis/group__PkgPrincipalComponentAnalysisDLLSF2.html#gaf0d4435db5901ebe10cafd7de7c077f3">CGAL::linear_least_squares_fitting_2</a>(</div><div class="line">      group.begin(), group.end(), line, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__centroid__grp.html#gacc395064255dfefdb1420309db234210">centroid</a>, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Dimension__tag.html">CGAL::Dimension_tag&lt;0&gt;</a>(),</div><div class="line">      Kernel(), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classCGAL_1_1Eigen__diagonalize__traits.html">CGAL::Eigen_diagonalize_traits&lt;FT, 2&gt;</a>());</div><div class="line">    lines.push_back(line);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Cut each line at the ends of the corresponding group.</span></div><div class="line">  std::vector&lt;Segment_2&gt; segments;</div><div class="line">  segments.reserve(lines.size());</div><div class="line">  Point_2 source, target;</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; lines.size(); ++i) {</div><div class="line">    boundary_points_on_line_2(</div><div class="line">      groups[i], lines[i], source, target);</div><div class="line">    segments.push_back(Segment_2(source, target));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Save input segments.</span></div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 2) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = std::string(argv[2]) + <span class="stringliteral">"regularize_real_data_2_before"</span>;</div><div class="line">    saver.export_eps_segments(segments, full_path, FT(3) / FT(2));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Angle regularization.</span></div><div class="line">  <span class="keyword">const</span> FT max_angle_2 = FT(80);</div><div class="line"></div><div class="line">  <span class="comment">// Create neigbor query and angle-based regularization model.</span></div><div class="line">  Neighbor_query neighbor_query(segments);</div><div class="line">  Angle_regularization angle_regularization(</div><div class="line">    segments, CGAL::parameters::maximum_angle(max_angle_2));</div><div class="line"></div><div class="line">  <span class="comment">// Regularize.</span></div><div class="line">  <a class="code" href="group__PkgShapeRegularizationRefSegments.html#ga3cde2421ff91530c13c9e8f1feaeae1c">CGAL::Shape_regularization::Segments::regularize_segments</a>(</div><div class="line">    segments, neighbor_query, angle_regularization);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* number of modified segments (angles) = "</span> &lt;&lt;</div><div class="line">    angle_regularization.number_of_modified_segments() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Offset regularization.</span></div><div class="line">  <span class="keyword">const</span> FT max_offset_2 = FT(2);</div><div class="line"></div><div class="line">  <span class="comment">// Get groups of parallel segments after angle regularization.</span></div><div class="line">  std::vector&lt;Indices&gt; pgroups;</div><div class="line">  angle_regularization.parallel_groups(</div><div class="line">    std::back_inserter(pgroups));</div><div class="line"></div><div class="line">  <span class="comment">// Create offset-based regularization model.</span></div><div class="line">  Offset_regularization offset_regularization(</div><div class="line">    segments, CGAL::parameters::maximum_offset(max_offset_2));</div><div class="line"></div><div class="line">  <span class="comment">// Add each group of parallel segments with at least 2 segments.</span></div><div class="line">  neighbor_query.clear();</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; pgroup : pgroups) {</div><div class="line">    neighbor_query.add_group(pgroup);</div><div class="line">    offset_regularization.add_group(pgroup);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Regularize.</span></div><div class="line">  <a class="code" href="group__PkgShapeRegularizationRefSegments.html#ga3cde2421ff91530c13c9e8f1feaeae1c">CGAL::Shape_regularization::Segments::regularize_segments</a>(</div><div class="line">    segments, neighbor_query, offset_regularization);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* number of modified segments (offsets) = "</span> &lt;&lt;</div><div class="line">    offset_regularization.number_of_modified_segments() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save regularized segments.</span></div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 2) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = std::string(argv[2]) + <span class="stringliteral">"regularize_real_data_2_after"</span>;</div><div class="line">    saver.export_eps_segments(segments, full_path, FT(3) / FT(2));</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="QP_Regularization_Segments_Utils"></a>
Utility Functions</h2>
<p>In addition to the main algorithm, we also provide several utility functions, which are often used in conjunction with the algorithm.</p>
<h3><a class="anchor" id="QP_Regularization_Segments_Groups"></a>
Grouping Segments</h3>
<p>This CGAL component also provides three ways to group segments:</p><ul>
<li><code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#gac72eca9b32b73a3713edffd2da5609f2" title="finds groups of parallel segments in a set of 2D segments. ">Segments::parallel_groups()</a></code> - organizes a set of unordered 2D segments into groups of parallel segments.</li>
<li><code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#ga7fe1c4b39b16dee49ba9c41dc3c0b0f8" title="finds groups of orthogonal segments in a set of 2D segments. ">Segments::orthogonal_groups()</a></code> - organizes a set of unordered 2D segments into groups of orthogonal segments.</li>
<li><code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#ga7ade7f4682f9953fcf36669b2079f4d9" title="finds groups of collinear segments in a set of 2D segments. ">Segments::collinear_groups()</a></code> - organizes a set of unordered 2D segments into groups of collinear segments.</li>
</ul>
<p><a class="anchor" id="fig__parallel_groups"></a></p><div class="image">
<object type="image/svg+xml" data="groups.svg">groups.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__parallel_groups">Figure 82.8</a> Groups of near parallel (left), near orthogonal (center), and near collinear (right) segments. Red, green, blue colors indicate groups within each set of 2D segments.  </div> <br /> 
<p>The function <code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#gac72eca9b32b73a3713edffd2da5609f2" title="finds groups of parallel segments in a set of 2D segments. ">Segments::parallel_groups()</a></code> enables users to form groups of parallel segments. For example, if you know that all your segments are already near parallel to each other within some tolerance error and you do not want to orient them by applying the <a class="el" href="index.html#QP_Regularization_Segments_Angles">Angle Regularization</a> algorithm, but you still need to make them collinear by minimizing the offset among parallel segments using the <a class="el" href="index.html#QP_Regularization_Segments_Offset">Offset Regularization</a> algorithm, you can create the groups of parallel segments by using this function and provide them as input to the offset regularization algorithm as we do it <a class="el" href="index.html#QP_Parallel_Groups_Example">here</a>.</p>
<p>The other two functions serve a similar goal. The one <code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#ga7fe1c4b39b16dee49ba9c41dc3c0b0f8" title="finds groups of orthogonal segments in a set of 2D segments. ">Segments::orthogonal_groups()</a></code> first creates groups of parallel segments and then merges them into groups, where all segments are either parallel or orthogonal to each other. The one <code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#ga7ade7f4682f9953fcf36669b2079f4d9" title="finds groups of collinear segments in a set of 2D segments. ">Segments::collinear_groups()</a></code> first creates groups of parallel segments and then splits each of these groups into groups of collinear segments, if any.</p>
<dl class="section note"><dt>Note</dt><dd>Note that none of these functions applies the regularization of the input segments. They only return groups of indices of segments with similar orientations and/or positions.</dd></dl>
<h3><a class="anchor" id="QP_Regularization_Segments_Simplification"></a>
Simplifying Segments</h3>
<p>After regularizing angles and offsets, simplifying segments with similar properties is a common post-processing task. This CGAL component provides an utility function <code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#ga9312b7fea9ddc4beae7b166ccc4607df" title="substitutes groups of 2D collinear segments by average segments. ">Segments::unique_segments()</a></code> that takes a set of input segments, groups them with respect to the collinearity property, and then returns for each group of collinear segments a segment that best fits this group (see the figure below).</p>
<dl class="section note"><dt>Note</dt><dd>Even if the segments are far away from each other but close with respect to the orthogonal distance between them that is they are almost collinear, they will be merged as the blue segments in the figure.</dd></dl>
<p><a class="anchor" id="fig__unique_segments"></a></p><div class="image">
<object type="image/svg+xml" data="unique_segments.svg">unique_segments.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__unique_segments">Figure 82.9</a> Input segments with multiple collinear segments (left) are simplified into unique segments (right).  </div> <br /> 
<h2><a class="anchor" id="QP_Regularization_Segments_Performance"></a>
Performance</h2>
<p>The performance of the shape regularization algorithm mostly depends on the used QP solver. When using the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classCGAL_1_1OSQP__quadratic__program__traits.html">CGAL::OSQP_quadratic_program_traits</a></code> model, we exploit and efficiently use the sparse nature of the related QP problem that leads to quick performances in practice.</p>
<p>The plot (solid) below shows how the computation time depends on the number of input segments. We first observe that the most challenging step is angle regularization while the offset regularization is much faster. This is an effect of complexity reduction by segmenting the problem into groups for offset regularization. Since each group of parallel segments is much smaller than the original set of input segments, the total computation time is smaller, too. The same idea can be applied to accelerate the angle regularization. Splitting input segments into groups with contextually similar properties from the very beginning will lead to better performance as indicated in the plot (dashed). However, note that not each data set can be meaningfully split into such groups.</p>
<p>To benchmark the algorithm, we used a MacBook Pro 2018 with 2.2 GHz Intel Core i7 processor (6 cores) and 32 GB 2400 MHz DDR4 memory. The installed operating system was OS X 10.15 Catalina. We first create a set of random segments in a square such that all segments are either parallel to the X axis or Y axis. We then slightly perturb all segments by a random angle within the interval [-15, 15] degrees and apply the regularization algorithm 10 times on the same input. The returned time is the average time over all iterations. In the pre-grouped version, we regroup all segments into groups of 10 segments and the regularization algorithm is applied to each group. For example, in case of 50 input segments, we will have 5 input groups. Since the groups are very small, there is no much difference in time between angle and offset regularizations. The results are shown in the figure below.</p>
<p><a class="anchor" id="fig__qp_segments_bench"></a></p><div class="image">
<object type="image/svg+xml" data="qp_segments_bench.svg">qp_segments_bench.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__qp_segments_bench">Figure 82.10</a> Time in seconds to regularize angles (solid red) and offsets (solid green) without regrouping input segments and with the groups of 10 segments for angles (dashed red) and offsets (dashed green).  </div> <br /> 
<h1><a class="anchor" id="Contour_Regularization"></a>
Contours</h1>
<p>Given a set of ordered 2D points connected by segments, which form a contour, closed or open, users can reinforce three types of regularities among consecutive edges of this contour:</p><ul>
<li><em>Parallelism</em>: contour edges, which are detected as near parallel, are made exactly parallel.</li>
<li><em>Orthogonality</em>: contour edges, which are detected as near orthogonal, are made exactly orthogonal.</li>
<li><em>Collinearity</em>: parallel contour edges, which are detected as near collinear, are made exactly collinear.</li>
</ul>
<p>A typical use of this algorithm consists of the following steps:</p><ol type="1">
<li>Specify a type of the contour, open or closed;</li>
<li>Create an instance of the class <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1ContourDirections.html" title="We assume that each contour has one or several principal directions. By implementing a model of this ...">ContourDirections</a></code> with the proper parameters;</li>
<li>Call the function <code><a class="el" href="group__PkgShapeRegularizationRefContours.html#ga7e2f3e7e76c52a3acef42a0d413a17c6" title="regularizes closed contours. ">regularize_closed_contour()</a></code> or <code><a class="el" href="group__PkgShapeRegularizationRefContours.html#gae860b28fa0fde23f6f6540f483b4ecff" title="regularizes open contours. ">regularize_open_contour()</a></code>.</li>
</ol>
<p>We assume that each contour has at least one principal direction that is a reference direction towards which the contour edges are rotated. Given a set of such directions either estimated or user-specified, each edge is made either parallel or orthogonal to these direction(s).</p>
<p>To estimate principal directions of the contour, this component provides three models of the concept <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1ContourDirections.html" title="We assume that each contour has one or several principal directions. By implementing a model of this ...">ContourDirections</a></code>:</p><ul>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1Contours_1_1Longest__direction__2.html" title="Estimates the longest principal direction of the contour. ">Contours::Longest_direction_2</a></code> - sets the longest contour edge as the only principal direction.</li>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1Contours_1_1Multiple__directions__2.html" title="Estimates possibly multiple principal directions of the contour based on the user-specified minimum l...">Contours::Multiple_directions_2</a></code> - tries to estimate multiple principal directions in the contour based on the user-specified parameters (see the figure below).</li>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1Contours_1_1User__defined__directions__2.html" title="Sets multiple user-specified principal directions of the contour. ">Contours::User_defined_directions_2</a></code> - sets the user-specified principal directions as contour directions.</li>
</ul>
<p><a class="anchor" id="fig__multiple_directions"></a></p><div class="image">
<object type="image/svg+xml" data="multiple_directions.svg">multiple_directions.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__multiple_directions">Figure 82.11</a> A closed contour before (red) and after (green) the contour regularization. The found principal directions are marked yellow.  </div> <br /> 
<p>After the directions are set, the algorithm is linear in the number of contour edges. It first goes through each contour edge and orients it towards the best-fit direction. In the second step, all parallel consecutive edges are merged if they are within a user-specified maximum tolerance distance. The distance here is defined as the distance between the midpoint of the first edge and the projection of this point onto the supporting line of the next edge. The position of the merged segment is optimized with respect to its neighbors. In the last steps, all segments are reconnected into a contour as shown in the figure below. Due to the merging step, the number of output edges in the contour is not necessarily the same as the number of input edges.</p>
<p><a class="anchor" id="fig__contours_pipeline"></a></p><div class="image">
<object type="image/svg+xml" data="contours_pipeline.svg">contours_pipeline.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__contours_pipeline">Figure 82.12</a> Steps of the contour regularization algorithm (from left to right): the closed contour before regularization; the disconnected contour with edges rotated towards the found principal directions, here we have only one direction; the optimized edges, blue edges were merged and their positions were optimized; and the final reconnected contour.  </div> <br /> 
<p>If the user wants to rotate each contour edge on its own towards the best-fit direction without reconnecting them after into a closed/open contour, she can either use the <a class="el" href="index.html#QP_Regularization_Segments">Segment Regularization</a> algorithm or she can orient each segment by calling the <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1ContourDirections.html#a07f23b0d134d1dfb32158f485aab15b8" title="orients a given segment with the index query_index towards the best-fit direction of the contour...">ContourDirections::orient()</a></code> method.</p>
<p>The example below shows the most straightforward entry point to the algorithm, where we regularize a simple closed contour. The algorithm is called via the function <code><a class="el" href="group__PkgShapeRegularizationRefContours.html#ga7e2f3e7e76c52a3acef42a0d413a17c6" title="regularizes closed contours. ">regularize_closed_contour()</a></code>.</p>
<p><a class="anchor" id="fig__regularize_contour_example"></a></p><div class="image">
<object type="image/svg+xml" data="regularize_contour.svg">regularize_contour.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__regularize_contour_example">Figure 82.13</a> A closed contour before (red) and after (green) regularization.  </div> <br /> 
<p><br />
<b>File</b> <a class="el" href="Shape_regularization_2regularize_contour_8cpp-example.html">Shape_regularization/regularize_contour.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="regularize__contours_8h.html">CGAL/Shape_regularization/regularize_contours.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> Kernel  = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> Point_2 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">  <span class="comment">// Create input contour.</span></div><div class="line">  <span class="keyword">const</span> std::vector&lt;Point_2&gt; contour = {</div><div class="line">    Point_2(0.00,  0.00),</div><div class="line">    Point_2(0.50, -0.05),</div><div class="line">    Point_2(1.00,  0.00),</div><div class="line">    Point_2(1.05,  0.50),</div><div class="line">    Point_2(1.00,  1.00),</div><div class="line">    Point_2(0.00,  1.00)</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="comment">// Regularize this contour.</span></div><div class="line">  std::vector&lt;Point_2&gt; regularized;</div><div class="line">  <a class="code" href="group__PkgShapeRegularizationRefContours.html#ga7e2f3e7e76c52a3acef42a0d413a17c6">CGAL::Shape_regularization::Contours::</a></div><div class="line"><a class="code" href="group__PkgShapeRegularizationRefContours.html#ga7e2f3e7e76c52a3acef42a0d413a17c6">    regularize_closed_contour</a>(contour, std::back_inserter(regularized));</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Contour_Regularization_Closed"></a>
Closed Contours</h2>
<p>In the example below, we regularize a closed contour. We use multiple directions estimator, which returns only one direction, because the contour is quite rectilinear. In fact, the returned direction in this case coincides with the longest edge direction.</p>
<p><a class="anchor" id="fig__regularize_closed_contour_example"></a></p><div class="image">
<object type="image/svg+xml" data="regularize_closed_contour.svg">regularize_closed_contour.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__regularize_closed_contour_example">Figure 82.14</a> A closed contour before (red) and after (green) the contour regularization.  </div> <br /> 
<p><br />
<b>File</b> <a class="el" href="Shape_regularization_2regularize_closed_contour_8cpp-example.html">Shape_regularization/regularize_closed_contour.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include "include/utils.h"</span></div><div class="line"><span class="preprocessor">#include "include/Saver.h"</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="regularize__contours_8h.html">CGAL/Shape_regularization/regularize_contours.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Typedefs.</span></div><div class="line"><span class="keyword">using</span> Kernel  = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div><div class="line"><span class="keyword">using</span> FT      = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"><span class="keyword">using</span> Point_2 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>;</div><div class="line"><span class="keyword">using</span> Contour = std::vector&lt;Point_2&gt;;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Contour_directions =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Contours_1_1Multiple__directions__2.html">CGAL::Shape_regularization::Contours::Multiple_directions_2&lt;Kernel, Contour&gt;</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div><div class="line"></div><div class="line">  <span class="comment">// If we want to load a different file, we load it from a path.</span></div><div class="line">  std::string path = <span class="stringliteral">"data/contour.polylines"</span>;</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1) path = argv[1];</div><div class="line">  Saver&lt;Kernel&gt; saver;</div><div class="line"></div><div class="line">  <span class="comment">// Set parameters.</span></div><div class="line">  <span class="keyword">const</span> FT min_length_2 = FT(2);</div><div class="line">  <span class="keyword">const</span> FT  max_angle_2 = FT(20);</div><div class="line">  <span class="keyword">const</span> FT max_offset_2 = FT(2);</div><div class="line"></div><div class="line">  <span class="comment">// Initialize contour.</span></div><div class="line">  std::vector&lt;Point_2&gt; contour;</div><div class="line">  initialize_contour(path, contour);</div><div class="line"></div><div class="line">  <span class="comment">// Save input contour.</span></div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 2) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = std::string(argv[2]) + <span class="stringliteral">"regularize_closed_contour_before"</span>;</div><div class="line">    saver.export_eps_closed_contour(contour, full_path, FT(8));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Regularize.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#gae04c8044cf1eee6a84baa5b79ab99fef">is_closed</a> = <span class="keyword">true</span>;</div><div class="line">  Contour_directions directions(</div><div class="line">    contour, is_closed, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL_1_1parameters.html">CGAL::parameters</a>::</div><div class="line">    minimum_length(min_length_2).maximum_angle(max_angle_2));</div><div class="line"></div><div class="line">  std::vector&lt;Point_2&gt; regularized;</div><div class="line">  <a class="code" href="group__PkgShapeRegularizationRefContours.html#ga7e2f3e7e76c52a3acef42a0d413a17c6">CGAL::Shape_regularization::Contours::regularize_closed_contour</a>(</div><div class="line">    contour, directions, std::back_inserter(regularized),</div><div class="line">    CGAL::parameters::maximum_offset(max_offset_2));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* number of directions = "</span> &lt;&lt;</div><div class="line">    directions.number_of_directions() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save regularized contour.</span></div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 2) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = std::string(argv[2]) + <span class="stringliteral">"regularize_closed_contour_after"</span>;</div><div class="line">    saver.export_eps_closed_contour(regularized, full_path, FT(8));</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Contour_Regularization_Open"></a>
Open Contours</h2>
<p>Open contours are contours where the head and tail of the contour are not connected. This case requires a special treatment, but the core of the algorithm is the same. In the example below, we regularize an open contour with respect to its longest edge. This example also shows how to provide a property map to the algorithm in order to give the algorithm access to the coordinates of the contour vertices.</p>
<p><a class="anchor" id="fig__regularize_open_contour_example"></a></p><div class="image">
<object type="image/svg+xml" data="regularize_open_contour.svg">regularize_open_contour.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__regularize_open_contour_example">Figure 82.15</a> An open contour before (red) and after (green) the contour regularization.  </div> <br /> 
<p><br />
<b>File</b> <a class="el" href="Shape_regularization_2regularize_open_contour_8cpp-example.html">Shape_regularization/regularize_open_contour.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include "include/utils.h"</span></div><div class="line"><span class="preprocessor">#include "include/Saver.h"</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="regularize__contours_8h.html">CGAL/Shape_regularization/regularize_contours.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Typedefs.</span></div><div class="line"><span class="keyword">using</span> Kernel  = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div><div class="line"><span class="keyword">using</span> FT      = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"><span class="keyword">using</span> Point_2 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>;</div><div class="line"><span class="keyword">using</span> Contour = std::vector&lt;Point_2&gt;;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Contour_directions =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Contours_1_1Longest__direction__2.html">CGAL::Shape_regularization::Contours::Longest_direction_2&lt;Kernel, Contour&gt;</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div><div class="line"></div><div class="line">  <span class="comment">// If we want to load a different file, we load it from a path.</span></div><div class="line">  std::string path = <span class="stringliteral">"data/contour.polylines"</span>;</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1) path = argv[1];</div><div class="line">  Saver&lt;Kernel&gt; saver;</div><div class="line"></div><div class="line">  <span class="comment">// Set parameters.</span></div><div class="line">  <span class="keyword">const</span> FT max_offset_2 = FT(2);</div><div class="line"></div><div class="line">  <span class="comment">// Initialize contour.</span></div><div class="line">  std::vector&lt;Point_2&gt; contour;</div><div class="line">  initialize_contour(path, contour);</div><div class="line"></div><div class="line">  <span class="comment">// Save input contour.</span></div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 2) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = std::string(argv[2]) + <span class="stringliteral">"regularize_open_contour_before"</span>;</div><div class="line">    saver.export_eps_open_contour(contour, full_path, FT(8));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Regularize.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span> is_closed = <span class="keyword">false</span>;</div><div class="line">  Contour_directions directions(contour, is_closed);</div><div class="line"></div><div class="line">  std::vector&lt;Point_2&gt; regularized;</div><div class="line">  <a class="code" href="group__PkgShapeRegularizationRefContours.html#gae860b28fa0fde23f6f6540f483b4ecff">CGAL::Shape_regularization::Contours::regularize_open_contour</a>(</div><div class="line">    contour, directions, std::back_inserter(regularized),</div><div class="line">    CGAL::parameters::maximum_offset(max_offset_2));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* number of directions = "</span> &lt;&lt;</div><div class="line">    directions.number_of_directions() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save regularized contour.</span></div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 2) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = std::string(argv[2]) + <span class="stringliteral">"regularize_open_contour_after"</span>;</div><div class="line">    saver.export_eps_open_contour(regularized, full_path, FT(8));</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Contour_Regularization_Performance"></a>
Performance</h2>
<p>The contour regularization algorithms, both closed and open, have, in practice, a linear time behavior with respect to the number of contour vertices. In fact, the time is not linear, as you can see in the plot below, due to the second step of merging consecutive collinear edges. For some polygons, the number of such edges is quite high and before merging them into one segment, we collect all of them into a group in order to find the best optimal position to place the final segment that may lead to a slower performance in some cases.</p>
<p>To benchmark the algorithm, we used a MacBook Pro 2018 with 2.2 GHz Intel Core i7 processor (6 cores) and 32 GB 2400 MHz DDR4 memory. The installed operating system was OS X 10.15 Catalina. We first create a rectilinear polygon with the required number of edges. We then slightly perturb all edges by a random angle within the interval [-15, 15] degrees and apply the regularization algorithm 10 times on the same input. The returned time is the average time over all iterations. The results are shown in the figure below.</p>
<p><a class="anchor" id="fig__contours_bench"></a></p><div class="image">
<object type="image/svg+xml" data="contours_bench.svg">contours_bench.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__contours_bench">Figure 82.16</a> Time in seconds to regularize closed (red) and open (green) contours.  </div> <br /> 
<h1><a class="anchor" id="Plane_Regularization"></a>
Planes</h1>
<p>Given a set of 3D planes with their corresponding inlier sets, users can reinforce four types of regularities among these planes using the function <code><a class="el" href="group__PkgShapeRegularizationRefPlanes.html#ga9ace5aafd056ce9ccb348c96e38d361a" title="Hierarchical plane regularization. ">regularize_planes()</a></code>:</p><ul>
<li><em>Parallelism</em>: planes, which are detected as near parallel, are made exactly parallel.</li>
<li><em>Orthogonality</em>: planes, which are detected as near orthogonal, are made exactly orthogonal.</li>
<li><em>Coplanarity</em>: parallel planes, which are detected as near coplanar, are made exactly coplanar.</li>
<li><em>Axis-Symmetry</em>: planes, which are detected as near symmetrical with respect to a user-specified axis, are made exactly symmetrical.</li>
</ul>
<p>The user can choose to regularize only one or several of these four properties. The process is greedy and based on a hierarchical decomposition (coplanar clusters are subgroups of parallel clusters, which are subgroups of axis-symmetric and orthogonal clusters) as described by Verdie et al. in <a class="el" href="citelist.html#CITEREF_cgal:vla-lod-15">[2]</a>.</p>
<p>The following example illustrates how to use the plane regularization function.</p>
<p><br />
<b>File</b> <a class="el" href="Shape_regularization_2regularize_planes_8cpp-example.html">Shape_regularization/regularize_planes.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include "include/utils.h"</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/Efficient__RANSAC_8h.html">CGAL/Shape_detection/Efficient_RANSAC.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="regularize__planes_8h.html">CGAL/Shape_regularization/regularize_planes.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Typedefs.</span></div><div class="line"><span class="keyword">using</span> Kernel   = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div><div class="line"><span class="keyword">using</span> FT       = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"><span class="keyword">using</span> Point_3  = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ae82b7f4be77dd5b8819ebe419e4ae753">Kernel::Point_3</a>;</div><div class="line"><span class="keyword">using</span> Vector_3 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a39fb0222695ae5e7e32f4e570ea28225">Kernel::Vector_3</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Point_with_normal = std::pair&lt;Point_3, Vector_3&gt;;</div><div class="line"><span class="keyword">using</span> Point_map         = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Point_with_normal&gt;</a>;</div><div class="line"><span class="keyword">using</span> Normal_map        = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;Point_with_normal&gt;</a>;</div><div class="line"><span class="keyword">using</span> Pwn_vector        = std::vector&lt;Point_with_normal&gt;;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Traits    = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/structCGAL_1_1Shape__detection_1_1Efficient__RANSAC__traits.html">CGAL::Shape_detection::Efficient_RANSAC_traits&lt;Kernel, Pwn_vector, Point_map, Normal_map&gt;</a>;</div><div class="line"><span class="keyword">using</span> RANSAC    = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Efficient__RANSAC.html">CGAL::Shape_detection::Efficient_RANSAC&lt;Traits&gt;</a>;</div><div class="line"><span class="keyword">using</span> Plane     = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Plane.html">CGAL::Shape_detection::Plane&lt;Traits&gt;</a>;</div><div class="line"><span class="keyword">using</span> Plane_map = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Plane__map.html">CGAL::Shape_detection::Plane_map&lt;Traits&gt;</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div><div class="line"></div><div class="line">  <span class="comment">// If we want to load a different file, we load it from a path.</span></div><div class="line">  std::string path = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/cube.pwn"</span>);</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1) path = argv[1];</div><div class="line"></div><div class="line">  Pwn_vector points;</div><div class="line">  std::ifstream file(path.c_str(), std::ios_base::in);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7d51c854b865a7eb367e21fc43bd37b8">CGAL::IO::set_ascii_mode</a>(file);</div><div class="line">  file.precision(20);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (!file ||</div><div class="line">    !CGAL::IO::read_XYZ(</div><div class="line">      file,</div><div class="line">      std::back_inserter(points),</div><div class="line">      CGAL::parameters::point_map(Point_map()).</div><div class="line">      normal_map(Normal_map()))) {</div><div class="line"></div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read the file cube.pwn!"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line">  file.close();</div><div class="line"></div><div class="line">  <span class="comment">// Call RANSAC shape detection with planes.</span></div><div class="line">  RANSAC efficient_ransac;</div><div class="line">  efficient_ransac.set_input(points);</div><div class="line">  efficient_ransac.add_shape_factory&lt;Plane&gt;();</div><div class="line">  efficient_ransac.detect();</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> planes = efficient_ransac.planes();</div><div class="line"></div><div class="line">  <span class="comment">// Regularize detected planes.</span></div><div class="line">  <a class="code" href="group__PkgShapeRegularizationRefPlanes.html#ga9ace5aafd056ce9ccb348c96e38d361a">CGAL::Shape_regularization::Planes::regularize_planes</a>(</div><div class="line">    planes,</div><div class="line">    points,</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL_1_1parameters.html">CGAL::parameters</a>::</div><div class="line">    plane_map(Plane_map()).</div><div class="line">    point_map(Point_map()).</div><div class="line">    plane_index_map(</div><div class="line">      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Point__to__shape__index__map.html">CGAL::Shape_detection::Point_to_shape_index_map&lt;Traits&gt;</a>(points, planes)).</div><div class="line">    regularize_coplanarity(<span class="keyword">false</span>). <span class="comment">// do not regularize coplanarity</span></div><div class="line">    maximum_angle(FT(10))); <span class="comment">// 10 degrees of tolerance for parallelism / orthogonality</span></div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* all detected planes are regularized"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Please note that this function used to be a part of the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgShapeDetection">Shape Detection</a> package. You can still use the old API of that function, however to avoid parameters ambiguity, we strongly suggest to use the new API with the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/index.html#BGLNamedParameters">Named Parameters</a> mechanism.</dd></dl>
<h1><a class="anchor" id="QP_Regularization"></a>
QP Regularization</h1>
<p>The shape regularization component is a generic framework that is based on the Quadratic Programming (QP) global regularization algorithm <a class="el" href="citelist.html#CITEREF_cgal:bl-kippi-18">[1]</a> by Bauchet et Lafarge. You should refer to this section only if you want to know details on how the shape regularization framework is organized internally or you want to extend that framework by implementing your own regularization types.</p>
<p><a class="el" href="index.html#QP_Regularization_Segments_Angles">Angle Regularization</a> and <a class="el" href="index.html#QP_Regularization_Segments_Offset">Offset Regularization</a> that we presented before are two particular instances of this algorithm. Other instances can be added by the user, as explained <a class="el" href="index.html#QP_Regularization_Implementation">here</a>.</p>
<h2><a class="anchor" id="QP_Regularization_Framework"></a>
Framework</h2>
<p>This framework follows Section 3 from <a class="el" href="citelist.html#CITEREF_cgal:bl-kippi-18">[1]</a>, however the algorithm from that paper was extended and generalized. The idea behind the main algorithm is to minimize the energy</p>
<center> \(U(\boldsymbol{x}) = (1 - \lambda) D(\boldsymbol{x}) + \lambda V(\boldsymbol{x})\),</center><p>where \(\boldsymbol{x} = (x_1, \dots, x_n)\) is a configuration of perturbations operated on \(n\) input items, \(D(\boldsymbol{x})\) and \(V(\boldsymbol{x})\) represent a data term and pairwise potential respectively, and \(\lambda \in [0, 1]\) is a parameter weighting these two terms. By setting up the correct types of \(D(\boldsymbol{x})\) and \(V(\boldsymbol{x})\), the problem can be reformulated into a quadratic optimization problem with \((n + m)\) variables and \(2(n + m)\) linear constraints, where \(m\) is the number of unique pairs formed by connecting an item to one of its closest neighbors. Let us explain how it all works when the input items are segments and we want to regularize their orientations in order to reinforce parallelism and orthogonality among them.</p>
<p>To set up the framework, we first need to find closest neighbors for each segment. These neighbors are provided via the concept <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1NeighborQuery.html" title="A concept that describes the set of methods used by the class QP_regularization to access neighbors o...">NeighborQuery</a></code>. Internally, we create a graph based on these neighbors. Every edge \(\{i, j\}\), where \(i\) is the index of the ith segment and \(j\) is the index of the jth segment is inserted in the graph whenever \(i &lt; j\). This way each pair is inserted only once. The neighbors are found via the <a class="el" href="index.html#QP_Regularization_Segments_Delaunay">Delaunay Neighbor Query</a>.</p>
<p>When we have the graph, we fill in the terms \(D(\boldsymbol{x})\) and \(V(\boldsymbol{x})\) via the concept <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html" title="A concept that describes the set of methods used by the class QP_regularization to access various dat...">RegularizationType</a></code>. First, we obtain a maximum perturbation bound for each segment via the method <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html#a6425688d6368960b0aa5bfd0e6e13541" title="returns the maximum bound on a regularization characteristic (angle-orientation/ distance-offset/etc...">RegularizationType::bound()</a></code>. Since we want to rotate segments, we return here the maximum allowed angle deviation for each segment with respect to its original orientation, lets say 25 degrees.</p>
<p>Next, for every edge \(\{i, j\}\) in the graph, we compute the perturbation difference between two segments \(i\) and \(j\) via the method <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html#ac5bd68e930f080c0b619b3541c5fad9c" title="returns an objective function value between two geometric objects, which are direct neighbors...">RegularizationType::target()</a></code>. For example, that could be a difference of segment orientations with respect to \(90\) or \(180\) degrees. Lets say an angle between two segments is \(85\) degrees then we return \(90 - 85 = 5\) degrees since this is what we should minimize in order to make the two segments orthogonal to each other.</p>
<p>Then we set up the quadratic programming problem that is solved via the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classQuadraticProgramTraits.html">QuadraticProgramTraits</a></code> concept. The returned result is stored as a vector of the length \((n + m)\) with the updated perturbation values, where the first \(n\) values are the values that should be added to the original orientations of the input segments in order to update them and the last \(m\) values are minimized to zeros. The update is achieved via the method <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html#a5fa1b89221a8d2515acff817ceeb6946" title="updates regularization characteristics (angle-orientation/distance-offset/etc.) of the geometric obje...">RegularizationType::update()</a></code>.</p>
<p>Overall, the class <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1QP__regularization.html" title="Shape regularization algorithm based on the quadratic programming global optimization. ">QP_regularization</a></code> is parameterized by:</p><ul>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1NeighborQuery.html" title="A concept that describes the set of methods used by the class QP_regularization to access neighbors o...">NeighborQuery</a></code> that provides the means for accessing local neighbors of an item,</li>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html" title="A concept that describes the set of methods used by the class QP_regularization to access various dat...">RegularizationType</a></code> that determines a regularization type to be applied, and</li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classQuadraticProgramTraits.html">QuadraticProgramTraits</a></code> that is used to solve the corresponding QP problem.</li>
</ul>
<p>Within this generic framework, users can regularize any set of input items provided their own neighbor search, regularization type, and QP solver.</p>
<h2><a class="anchor" id="QP_Regularization_Neighborhood"></a>
Neighborhood</h2>
<p>The concept <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1NeighborQuery.html" title="A concept that describes the set of methods used by the class QP_regularization to access neighbors o...">NeighborQuery</a></code> provides the means for accessing local neighbors of an item. To create a model that respects this concept, the user has to provide an overload of the operator:</p>
<ul>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1NeighborQuery.html#afe9ac86f81427f217a72ee74523e4ade" title="fills in neighbors with indices of all geometric objects, which are direct neighbors of the object wi...">NeighborQuery::operator()()</a></code> that has to fill in a vector with indices of all items, which are neighbors of the query item.</li>
</ul>
<p>For example, given a segment, this operator may return a vector with indices of some other input segments, which are within a certain distance from this segment, however this distance is measured. See above and <a class="el" href="index.html#QP_Regularization_Segments_Delaunay">this section</a> for more details.</p>
<h2><a class="anchor" id="QP_Regularization_Type"></a>
Regularization</h2>
<p>The concept <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html" title="A concept that describes the set of methods used by the class QP_regularization to access various dat...">RegularizationType</a></code> determines a type of regularization to be applied. To create a model that respects this concept, three functions have to be defined:</p>
<ul>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html#ac5bd68e930f080c0b619b3541c5fad9c" title="returns an objective function value between two geometric objects, which are direct neighbors...">RegularizationType::target()</a></code> a function that estimates a type of regularity between two neighbors,</li>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html#a6425688d6368960b0aa5bfd0e6e13541" title="returns the maximum bound on a regularization characteristic (angle-orientation/ distance-offset/etc...">RegularizationType::bound()</a></code> a function that returns a maximum bound on the allowed regularity change, and</li>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html#a5fa1b89221a8d2515acff817ceeb6946" title="updates regularization characteristics (angle-orientation/distance-offset/etc.) of the geometric obje...">RegularizationType::update()</a></code> a function that updates input items with respect to the modified regularities.</li>
</ul>
<p>For example, if we want to regularize segment orientations, that is to make segments parallel and orthogonal to each other, the first function should return an angle perturbation between a query segment and each of its neighbors; the second function should return a maximum angle within which a rotation of the query segment is accepted; and the third function should update original orientations of the input segments. See above and <a class="el" href="index.html#QP_Regularization_Segments_Angles">this section</a> for more details.</p>
<h2><a class="anchor" id="QP_Regularization_Solvers"></a>
Solvers</h2>
<p>In order to solve the associated QP problem of the algorithm above, CGAL provides a wrapper <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classCGAL_1_1OSQP__quadratic__program__traits.html">CGAL::OSQP_quadratic_program_traits</a></code> of the external <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartyOSQP">OSQP solver</a> that is a model of the concept <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classQuadraticProgramTraits.html">QuadraticProgramTraits</a></code>.</p>
<p>Alternatively, the internal CGAL solver from the package <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgQPSolver">Linear and Quadratic Programming Solver</a> can be used, however we do not recommend applying it. The internal quadratic program that has to be solved for shape regularization is sparse. The CGAL version will internally convert this problem into a dense one that takes considerable effort to solve, while the OSQP version takes a special care of the sparse nature of the problem that leads to better performance. Since the class <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1QP__regularization.html" title="Shape regularization algorithm based on the quadratic programming global optimization. ">QP_regularization</a></code> is parameterized by the general concept <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classQuadraticProgramTraits.html">QuadraticProgramTraits</a></code>, the users are also welcome to provide their own version of the solver.</p>
<h2><a class="anchor" id="QP_Regularization_Implementation"></a>
Implementation</h2>
<p>If you want to implement your own regularization approach that follows the same framework, for example to reinforce a different type of regularity than is already provided, you have to implement your own model of the <a class="el" href="index.html#QP_Regularization_Type">RegularizationType</a> concept and possibly a model of the <a class="el" href="index.html#QP_Regularization_Neighborhood">NeighborQuery</a> concept. These concepts are used to parameterize the main <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1QP__regularization.html" title="Shape regularization algorithm based on the quadratic programming global optimization. ">QP_regularization</a></code> algorithm:</p><ol type="1">
<li>Use <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1NeighborQuery.html" title="A concept that describes the set of methods used by the class QP_regularization to access neighbors o...">NeighborQuery</a></code> to find local neighbors of each input item;</li>
<li>Use <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html" title="A concept that describes the set of methods used by the class QP_regularization to access various dat...">RegularizationType</a></code> to estimate current regularities among these neighbors;</li>
<li>Use <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html" title="A concept that describes the set of methods used by the class QP_regularization to access various dat...">RegularizationType</a></code> to set maximum bounds on the allowed regularity changes;</li>
<li>Use <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classQuadraticProgramTraits.html">QuadraticProgramTraits</a></code> to solve the quadratic programming problem;</li>
<li>Use <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html" title="A concept that describes the set of methods used by the class QP_regularization to access various dat...">RegularizationType</a></code> to update input items with respect to the modified regularities.</li>
</ol>
<p>In addition, the user may also want to change a <a class="el" href="index.html#QP_Regularization_Solvers">QP solver</a> if he knows how to optimize it for a specific type of input data. To do that, the user has to implement a model of the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classQuadraticProgramTraits.html">QuadraticProgramTraits</a></code> concept.</p>
<p>An example below shows how to define your own type of the above concepts and how to choose among available solvers.</p>
<p><br />
<b>File</b> <a class="el" href="Shape_regularization_2regularize_framework_8cpp-example.html">Shape_regularization/regularize_framework.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Shape__regularization_8h.html">CGAL/Shape_regularization.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> Kernel = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> FT     = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Custom_object {</div><div class="line">  <span class="keyword">const</span> std::string name;</div><div class="line">  Custom_object(<span class="keyword">const</span> std::string name_) :</div><div class="line">  name(name_) { }</div><div class="line">  <span class="comment">// define your object here</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Custom_neighbor_query_2 {</div><div class="line">  <span class="keywordtype">void</span> operator()(</div><div class="line">    <span class="keyword">const</span> std::size_t query_index, std::vector&lt;std::size_t&gt;&amp; neighbors) {</div><div class="line">    neighbors.clear();</div><div class="line">    <span class="keywordflow">if</span> (query_index == 0) { neighbors.push_back(1); } <span class="comment">// first  object</span></div><div class="line">    <span class="keywordflow">if</span> (query_index == 1) { neighbors.push_back(0); } <span class="comment">// second object</span></div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Custom_regularization_2 {</div><div class="line">  FT bound(<span class="keyword">const</span> std::size_t )<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> FT(5); <span class="comment">// maximum angle change</span></div><div class="line">  }</div><div class="line">  FT target(<span class="keyword">const</span> std::size_t , <span class="keyword">const</span> std::size_t ) {</div><div class="line">    <span class="keywordflow">return</span> FT(0); <span class="comment">// 0 angle change</span></div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> update(<span class="keyword">const</span> std::vector&lt;FT&gt;&amp; ) {</div><div class="line">    <span class="comment">// skip update</span></div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> NT&gt;</div><div class="line"><span class="keyword">class </span>Custom_quadratic_program_traits  {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keywordtype">void</span>  set_P(<span class="keyword">const</span> std::size_t, <span class="keyword">const</span> std::size_t, <span class="keyword">const</span> FT) { }</div><div class="line">  <span class="keywordtype">void</span>  set_q(<span class="keyword">const</span> std::size_t, <span class="keyword">const</span> FT) { }</div><div class="line">  <span class="keywordtype">void</span>  set_r(<span class="keyword">const</span> FT) { }</div><div class="line">  <span class="keywordtype">void</span>  set_A(<span class="keyword">const</span> std::size_t, <span class="keyword">const</span> std::size_t, <span class="keyword">const</span> FT) { }</div><div class="line">  <span class="keywordtype">void</span>  set_l(<span class="keyword">const</span> std::size_t, <span class="keyword">const</span> FT) { }</div><div class="line">  <span class="keywordtype">void</span>  set_u(<span class="keyword">const</span> std::size_t, <span class="keyword">const</span> FT) { }</div><div class="line">  <span class="keywordtype">void</span> resize(<span class="keyword">const</span> std::size_t, <span class="keyword">const</span> std::size_t) { }</div><div class="line"></div><div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> OutputIterator&gt;</div><div class="line">  <span class="keywordtype">bool</span> solve(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classOutputIterator.html">OutputIterator</a> solution) {</div><div class="line"></div><div class="line">    <span class="comment">// 3 = 2 objects + 1 edge between them</span></div><div class="line">    <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; 3; ++i) {</div><div class="line">      *(++solution) = NT(0);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">using</span> Objects = std::vector&lt;Custom_object&gt;;</div><div class="line"><span class="keyword">using</span> Neighbor_query = Custom_neighbor_query_2;</div><div class="line"><span class="keyword">using</span> Regularization_type = Custom_regularization_2;</div><div class="line"><span class="keyword">using</span> Quadratic_program = Custom_quadratic_program_traits&lt;FT&gt;;</div><div class="line"><span class="keyword">using</span> Regularizer = <a class="code" href="classCGAL_1_1Shape__regularization_1_1QP__regularization.html">CGAL::Shape_regularization::QP_regularization</a>&lt;</div><div class="line">  Kernel, Objects, Neighbor_query, Regularization_type, Quadratic_program&gt;;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">  Neighbor_query neighbor_query;</div><div class="line">  Regularization_type regularization_type;</div><div class="line">  Quadratic_program quadratic_program;</div><div class="line"></div><div class="line">  std::vector&lt;Custom_object&gt; objects = {</div><div class="line">    Custom_object(<span class="stringliteral">"first"</span>), Custom_object(<span class="stringliteral">"second"</span>)</div><div class="line">  };</div><div class="line"></div><div class="line">  Regularizer regularizer(</div><div class="line">    objects, neighbor_query, regularization_type, quadratic_program);</div><div class="line">  regularizer.regularize();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* regularized 2 objects"</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Shape_Regularization_History"></a>
History</h1>
<p>The shape regularization algorithm for 2D segments was first implemented by Jean-Philippe Bauchet under the supervision of Florent Lafarge and then generalized by Gennadii Sytov during the Google Summer of Code 2019 under the supervision of Dmitry Anisimov. The contour regularization algorithm was developed and implemented by Dmitry Anisimov and Simon Giraudot. Plane regularization was added by Simon Giraudot based on the prototype version developed by Florent Lafarge.</p>
<h1><a class="anchor" id="Shape_Regularization_Acknowledgements"></a>
Acknowledgments</h1>
<p>We wish to thank Andreas Fabri and Marc Pouget for useful discussions and reviews. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jul 4 2022 13:25:33 for CGAL 5.6 - Shape Regularization by
    <a href="https://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>
</html><html xmlns="http://www.w3.org/1999/xhtml"><body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.6 - Shape Regularization
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Shape_Regularization"></a>  </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Authors</dt><dd>Dmitry Anisimov, Gennadii Sytov, Simon Giraudot, Jean-Philippe Bauchet, and Florent Lafarge</dd></dl>
<p><a class="anchor" id="fig__regularize_2_overview"></a></p><div class="image">
<object type="image/svg+xml" data="overview.svg">overview.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__regularize_2_overview">Figure 82.1</a> A closed contour before (red) and after (green) regularization.  </div> <br /> 
<h1><a class="anchor" id="Shape_Regularization_Intro"></a>
Introduction</h1>
<p>This CGAL package enables to regularize a set of segments and open or closed contours in 2D and a set of planes in 3D such that all input objects are rotated and aligned with respect to the user-specified conditions. In addition, we provide a global regularization framework that can be adjusted for the user needs and any type of geometric objects. This package can also be used in conjunction with the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgShapeDetection">Shape Detection</a> package.</p>
<h1><a class="anchor" id="QP_Regularization_Segments"></a>
Segments</h1>
<p>Given a set of unordered 2D segments, users can reinforce three types of regularities among these segments:</p><ul>
<li><em>Parallelism</em>: segments, which are detected as near parallel, are made exactly parallel.</li>
<li><em>Orthogonality</em>: segments, which are detected as near orthogonal, are made exactly orthogonal.</li>
<li><em>Collinearity</em>: parallel segments, which are detected as near collinear, are made exactly collinear.</li>
</ul>
<p>A typical use of this algorithm consists of the following steps:</p><ol type="1">
<li>Create an input range with 2D segments;</li>
<li>Define groups of segments, which should be regularized together;</li>
<li>Instantiate models of the concepts <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1NeighborQuery.html" title="A concept that describes the set of methods used by the class QP_regularization to access neighbors o...">NeighborQuery</a></code> and <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html" title="A concept that describes the set of methods used by the class QP_regularization to access various dat...">RegularizationType</a></code> with the proper parameters;</li>
<li>Call the function <code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#ga3cde2421ff91530c13c9e8f1feaeae1c" title="regularizes a set of 2D segments. ">regularize_segments()</a></code>.</li>
</ol>
<p>Once the user has defined an input range with 2D segments, he can either provide them all to the regularization algorithm, which is the default option, or they could be reorganized into groups of contextually similar segments. For example, all segments of the same length could form a group. When regularizing, only segments within the group are taken into account, that is no segment from one group will be oriented and/or aligned towards a segment from another group (see more details <a class="el" href="index.html#QP_Regularization_Segments_Delaunay">here</a>).</p>
<p>To apply the algorithm, the user has to define two models: one of the concept <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1NeighborQuery.html" title="A concept that describes the set of methods used by the class QP_regularization to access neighbors o...">NeighborQuery</a></code> that provides an access to the closest neighbors of a segment; and the other one of the concept <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html" title="A concept that describes the set of methods used by the class QP_regularization to access various dat...">RegularizationType</a></code> that provides one of the available regularities, which should be adjusted.</p>
<p>This CGAL component provides a model of the <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1NeighborQuery.html" title="A concept that describes the set of methods used by the class QP_regularization to access neighbors o...">NeighborQuery</a></code> concept:</p>
<ul>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Delaunay__neighbor__query__2.html" title="A neighbor query based on a Delaunay triangulation, which enables to find the nearest neighbors in a ...">Segments::Delaunay_neighbor_query_2</a></code> - finds local neighbors of each segment by constructing a Delaunay triangulation. See more details <a class="el" href="index.html#QP_Regularization_Segments_Delaunay">here</a>.</li>
</ul>
<p>And two models of the <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html" title="A concept that describes the set of methods used by the class QP_regularization to access various dat...">RegularizationType</a></code> concept:</p>
<ul>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Angle__regularization__2.html" title="An angle-based regularization type for 2D segments that reinforces parallelism and orthogonality rela...">Segments::Angle_regularization_2</a></code> - orients segments to reinforce parallelism and orthogonality among them. See more details <a class="el" href="index.html#QP_Regularization_Segments_Angles">here</a>.</li>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Offset__regularization__2.html" title="An offset-based regularization type for 2D segments that reinforces collinearity relationships. ">Segments::Offset_regularization_2</a></code> - aligns parallel segments to reinforce collinearity among them. See more details <a class="el" href="index.html#QP_Regularization_Segments_Offset">here</a>.</li>
</ul>
<p>The standard way to regularize a set of input segments is to first apply an angle regularization and then an offset regularization, however the algorithm is flexible to handle other scenarios as you will see later.</p>
<dl class="section note"><dt>Note</dt><dd>The core of this algorithm is the <a class="el" href="index.html#QP_Regularization">QP Regularization</a> framework. For more details, please refer to that section.</dd></dl>
<p>The example below shows the most straightforward entry point to the algorithm, where we apply two type of regularities: parallelism and orthogonality, within the group of all input segments. The algorithm is called via the function <code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#ga3cde2421ff91530c13c9e8f1feaeae1c" title="regularizes a set of 2D segments. ">regularize_segments()</a></code>.</p>
<p><a class="anchor" id="fig__regularize_simple_example"></a></p><div class="image">
<object type="image/svg+xml" data="regularize_simple.svg">regularize_simple.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__regularize_simple_example">Figure 82.2</a> A set of 2D segments before (red) and after (green) the angle and offset regularization.  </div> <br /> 
<p><br />
<b>File</b> <a class="el" href="Shape_regularization_2regularize_simple_8cpp-example.html">Shape_regularization/regularize_simple.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="regularize__segments_8h.html">CGAL/Shape_regularization/regularize_segments.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>    = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> Point_2   = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>;</div><div class="line"><span class="keyword">using</span> Segment_2 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#aa6d2526f8d1571f4a38aa8a6d9a02c2b">Kernel::Segment_2</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">  <span class="comment">// Create input segments.</span></div><div class="line">  std::vector&lt;Segment_2&gt; segments = {</div><div class="line">    Segment_2(Point_2(0.2, 0.0), Point_2(1.2, 0.0)),</div><div class="line">    Segment_2(Point_2(1.2, 0.1), Point_2(2.2, 0.1)),</div><div class="line">    Segment_2(Point_2(2.2, 0.0), Point_2(2.0, 2.0)),</div><div class="line">    Segment_2(Point_2(2.0, 2.0), Point_2(1.0, 2.0)),</div><div class="line">    Segment_2(Point_2(1.0, 1.9), Point_2(0.0, 1.9)),</div><div class="line">    Segment_2(Point_2(0.0, 2.0), Point_2(0.2, 0.0))</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="comment">// Regularize all segments: both angles and offsets.</span></div><div class="line">  <a class="code" href="group__PkgShapeRegularizationRefSegments.html#ga3cde2421ff91530c13c9e8f1feaeae1c">CGAL::Shape_regularization::Segments::</a></div><div class="line"><a class="code" href="group__PkgShapeRegularizationRefSegments.html#ga3cde2421ff91530c13c9e8f1feaeae1c">    regularize_segments</a>(segments);</div><div class="line">}</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>As it can be seen from the example, the algorithm does not prioritize any directions like vertical or horizontal but rather returns the optimal regularized configuration of the input segments.</dd></dl>
<h2><a class="anchor" id="QP_Regularization_Segments_Delaunay"></a>
Delaunay Neighbor Query</h2>
<p>This class finds local neighbors of each segment by constructing a Delaunay triangulation, using the class <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2</a></code>, upon the center points of the input segments. The local neighborhood of a segment is thus defined by the corresponding one-ring neighborhood in the triangulation. The Delaunay triangulation can be constructed only for a group of at least two segments.</p>
<p>The Delaunay neighbor query class constructs the Delaunay triangulation from a group of segments, which has to be provided by the user through the <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Delaunay__neighbor__query__2.html#aaffd7eb2871e03b6e0d3cc997b440661" title="inserts a group of segments from input_range and finds their neighbors within the group...">Segments::Delaunay_neighbor_query_2::add_group()</a></code> method, and finds local neighbors of each segment only within the group. If this method is never called, all input segments are treated as a group.</p>
<p>Note that a group can include fewer segments than in the input range. For example, if your input range contains multiple segments, which contextually form three different groups of objects lets say boundaries of three different buildings and you do not want to regularize these buildings with respect to each other, but rather within each building boundary, in that case you should call the <code>add_group</code> method three times. An example of such groups can be seen in <a class="el" href="index.html#Regularize_15_Segments_Figure">this figure</a>, where you can see three groups of contextually similar segments: outer boundary, interior top rhombus and interior bottom rhombus or in the figure below.</p>
<p>In this figure, there are two squares, one external and one internal. On the left, the red segments show the connectivity among all input segments that is a Delaunay triangulation built upon all these segments, while on the right, the green segments show the connectivity only among external square segments and blue segments only among internal square segments.</p>
<p><a class="anchor" id="fig__delaunay_groups"></a></p><div class="image">
<object type="image/svg+xml" data="delaunay_groups.svg">delaunay_groups.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__delaunay_groups">Figure 82.3</a> Delaunay triangulation (red) for all input segments (black, left) and two contextually different groups with green Delaunay for the external segments and blue Delaunay for the internal segments (right).  </div> <br /> 
<h2><a class="anchor" id="QP_Regularization_Segments_Angles"></a>
Angle Regularization</h2>
<p>This class orients 2D segments in order to reinforce parallelism and orthogonality among them. To apply the angle regularization on a set of 2D segments, the user has to:</p><ul>
<li>specify the maximum angle deviation of a segment from its initial orientation that has to be within the interval [0, 90] degrees. If no bound is provided, a bound of 25 degrees will be set as the default value;</li>
<li>add groups of segments, if any, through the <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Angle__regularization__2.html#a973f865ac9b75042b31ec29d88f2b606" title="inserts a group of segments from input_range. ">Segments::Angle_regularization_2::add_group()</a></code> method.</li>
</ul>
<p>After the optimization, each segment is rotated with respect to its midpoint.</p>
<p><a class="anchor" id="fig__regularize_100_segments_angles_example"></a></p><div class="image">
<object type="image/svg+xml" data="regularize_100_segments_angles.svg">regularize_100_segments_angles.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__regularize_100_segments_angles_example">Figure 82.4</a> A generated set of 2D segments before (red) and after (green) the angle regularization.  </div> <br /> 
<p>The following example demonstrates the usage of the shape regularization algorithm for angles on a set of 100 near orthogonal segments generated with the help of <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgGenerators">CGAL Geometric Object Generators</a>. The entire <code>InputRange</code> is provided to the angle regularization class as a group. The maximum angle bound is set to 40 degrees.</p>
<p><br />
<b>File</b> <a class="el" href="Shape_regularization_2regularize_100_segments_angles_8cpp-example.html">Shape_regularization/regularize_100_segments_angles.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include "include/utils.h"</span></div><div class="line"><span class="preprocessor">#include "include/Saver.h"</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="regularize__segments_8h.html">CGAL/Shape_regularization/regularize_segments.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Typedefs.</span></div><div class="line"><span class="keyword">using</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>    = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> FT        = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"><span class="keyword">using</span> Segment_2 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#aa6d2526f8d1571f4a38aa8a6d9a02c2b">Kernel::Segment_2</a>;</div><div class="line"><span class="keyword">using</span> Segments  = std::vector&lt;Segment_2&gt;;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Neighbor_query =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Delaunay__neighbor__query__2.html">CGAL::Shape_regularization::Segments::Delaunay_neighbor_query_2&lt;Kernel, Segments&gt;</a>;</div><div class="line"><span class="keyword">using</span> Angle_regularization =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Angle__regularization__2.html">CGAL::Shape_regularization::Segments::Angle_regularization_2&lt;Kernel, Segments&gt;</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div><div class="line"></div><div class="line">  <span class="comment">// If we want to save the result in a file, we save it in a path.</span></div><div class="line">  std::string path = <span class="stringliteral">""</span>;</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1) path = argv[1];</div><div class="line">  Saver&lt;Kernel&gt; saver;</div><div class="line"></div><div class="line">  <span class="comment">// Initialize 100 near-orthogonal segments.</span></div><div class="line">  std::vector&lt;Segment_2&gt; segments;</div><div class="line">  create_example_angles(segments);</div><div class="line"></div><div class="line">  <span class="comment">// Save input segments.</span></div><div class="line">  <span class="keywordflow">if</span> (path != <span class="stringliteral">""</span>) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = path + <span class="stringliteral">"regularize_100_segments_angles_before"</span>;</div><div class="line">    saver.export_eps_segments(segments, full_path, FT(1));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Angle regularization.</span></div><div class="line">  <span class="keyword">const</span> FT max_angle_2 = FT(40);</div><div class="line"></div><div class="line">  <span class="comment">// Create neigbor query and angle-based regularization model.</span></div><div class="line">  Neighbor_query neighbor_query(segments);</div><div class="line">  Angle_regularization angle_regularization(</div><div class="line">    segments, CGAL::parameters::maximum_angle(max_angle_2));</div><div class="line"></div><div class="line">  <span class="comment">// Regularize.</span></div><div class="line">  <a class="code" href="group__PkgShapeRegularizationRefSegments.html#ga3cde2421ff91530c13c9e8f1feaeae1c">CGAL::Shape_regularization::Segments::regularize_segments</a>(</div><div class="line">    segments, neighbor_query, angle_regularization);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* number of modified segments = "</span> &lt;&lt;</div><div class="line">    angle_regularization.number_of_modified_segments() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save regularized segments.</span></div><div class="line">  <span class="keywordflow">if</span> (path != <span class="stringliteral">""</span>) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = path + <span class="stringliteral">"regularize_100_segments_angles_after"</span>;</div><div class="line">    saver.export_eps_segments(segments, full_path, FT(1));</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="QP_Regularization_Segments_Offset"></a>
Offset Regularization</h2>
<p>This class aligns 2D parallel segments in order to reinforce collinearity among them. To apply the offset regularization on a set of 2D segments, the user has to:</p><ul>
<li>specify the maximum distance between two parallel segments that has to be within the interval [0, +inf). If no bound is provided, a bound of 0.5 unit length will be set as the default value.</li>
<li>add groups of parallel segments through the <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Offset__regularization__2.html#a8e9dbdec86eb77a43911699e59307865" title="inserts a group of segments from input_range. ">Segments::Offset_regularization_2::add_group()</a></code> method. If the user does not have these groups, they can be obtained from <a class="el" href="index.html#QP_Regularization_Segments_Angles">Angle Regularization</a> by orienting original segments or from the utility function <code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#gac72eca9b32b73a3713edffd2da5609f2" title="finds groups of parallel segments in a set of 2D segments. ">Segments::parallel_groups()</a></code>. See more details <a class="el" href="index.html#QP_Regularization_Segments_Groups">here</a>.</li>
</ul>
<p>After the optimization, each segment is translated along its orthogonal direction.</p>
<p>Note that if the input segments within the same group are not exactly parallel, the distance, which is defined as the distance between the midpoint of one segment and the projection of this point onto the supporting line of another segment, is not a good metric to optimize positions of the segments that may lead to deviations in the result from what the user would expect in case of exactly parallel segments. The offset regularization does not internally orient segments to make them exactly parallel. This is what the <a class="el" href="index.html#QP_Regularization_Segments_Angles">Angle Regularization</a> class for. The utility function <code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#gac72eca9b32b73a3713edffd2da5609f2" title="finds groups of parallel segments in a set of 2D segments. ">Segments::parallel_groups()</a></code> does not orient segments either, but only returns groups of near-parallel segments.</p>
<p><a class="anchor" id="fig__regularize_100_segments_offsets_example"></a></p><div class="image">
<object type="image/svg+xml" data="regularize_100_segments_offsets.svg">regularize_100_segments_offsets.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__regularize_100_segments_offsets_example">Figure 82.5</a> A generated set of 2D segments before (red) and after (green) the offset regularization.  </div> <br /> 
<p>The following example demonstrates the usage of the shape regularization algorithm for offsets on a set of 100 parallel segments located within a circle. The function <code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#gac72eca9b32b73a3713edffd2da5609f2" title="finds groups of parallel segments in a set of 2D segments. ">Segments::parallel_groups()</a></code> is used to obtain the groups of parallel segments. The maximum offset bound is set to 0.25 unit length.</p>
<p><a class="anchor" id="QP_Parallel_Groups_Example"></a><br />
<b>File</b> <a class="el" href="Shape_regularization_2regularize_100_segments_offsets_8cpp-example.html">Shape_regularization/regularize_100_segments_offsets.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include "include/utils.h"</span></div><div class="line"><span class="preprocessor">#include "include/Saver.h"</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="regularize__segments_8h.html">CGAL/Shape_regularization/regularize_segments.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Typedefs.</span></div><div class="line"><span class="keyword">using</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>    = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> FT        = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"><span class="keyword">using</span> Segment_2 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#aa6d2526f8d1571f4a38aa8a6d9a02c2b">Kernel::Segment_2</a>;</div><div class="line"><span class="keyword">using</span> Segments  = std::vector&lt;Segment_2&gt;;</div><div class="line"><span class="keyword">using</span> Indices   = std::vector&lt;std::size_t&gt;;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Neighbor_query =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Delaunay__neighbor__query__2.html">CGAL::Shape_regularization::Segments::Delaunay_neighbor_query_2&lt;Kernel, Segments&gt;</a>;</div><div class="line"><span class="keyword">using</span> Offset_regularization =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Offset__regularization__2.html">CGAL::Shape_regularization::Segments::Offset_regularization_2&lt;Kernel, Segments&gt;</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div><div class="line"></div><div class="line">  <span class="comment">// If we want to save the result in a file, we save it in a path.</span></div><div class="line">  std::string path = <span class="stringliteral">""</span>;</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1) path = argv[1];</div><div class="line">  Saver&lt;Kernel&gt; saver;</div><div class="line"></div><div class="line">  <span class="comment">// Initialize 100 segments in a fuzzy circle.</span></div><div class="line">  std::vector&lt;Segment_2&gt; segments;</div><div class="line">  create_example_offsets(segments);</div><div class="line"></div><div class="line">  <span class="comment">// Save input segments.</span></div><div class="line">  <span class="keywordflow">if</span> (path != <span class="stringliteral">""</span>) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = path + <span class="stringliteral">"regularize_100_segments_offsets_before"</span>;</div><div class="line">    saver.export_eps_segments(segments, full_path, FT(100));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Find groups of parallel segments.</span></div><div class="line">  <span class="keyword">const</span> FT max_angle_2 = FT(1);</div><div class="line"></div><div class="line">  std::vector&lt;Indices&gt; pgroups;</div><div class="line">  <a class="code" href="group__PkgShapeRegularizationRefSegments.html#gac72eca9b32b73a3713edffd2da5609f2">CGAL::Shape_regularization::Segments::parallel_groups</a>(</div><div class="line">    segments, std::back_inserter(pgroups),</div><div class="line">    CGAL::parameters::maximum_angle(max_angle_2));</div><div class="line"></div><div class="line">  <span class="comment">// Offset regularization.</span></div><div class="line">  <span class="keyword">const</span> FT max_offset_2 = FT(1) / FT(4);</div><div class="line"></div><div class="line">  <span class="comment">// Create neigbor query and offset-based regularization model.</span></div><div class="line">  Neighbor_query neighbor_query(segments);</div><div class="line">  Offset_regularization offset_regularization(</div><div class="line">    segments, CGAL::parameters::maximum_offset(max_offset_2));</div><div class="line"></div><div class="line">  <span class="comment">// Add each group of parallel segments with at least 2 segments.</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; pgroup : pgroups) {</div><div class="line">    neighbor_query.add_group(pgroup);</div><div class="line">    offset_regularization.add_group(pgroup);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Regularize.</span></div><div class="line">  <a class="code" href="group__PkgShapeRegularizationRefSegments.html#ga3cde2421ff91530c13c9e8f1feaeae1c">CGAL::Shape_regularization::Segments::regularize_segments</a>(</div><div class="line">    segments, neighbor_query, offset_regularization);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* number of modified segments = "</span> &lt;&lt;</div><div class="line">    offset_regularization.number_of_modified_segments() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save regularized segments.</span></div><div class="line">  <span class="keywordflow">if</span> (path != <span class="stringliteral">""</span>) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = path + <span class="stringliteral">"regularize_100_segments_offsets_after"</span>;</div><div class="line">    saver.export_eps_segments(segments, full_path, FT(100));</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="QP_Regularization_Segments_Examples"></a>
Angle + Offset Regularization</h2>
<p>The following examples demonstrate the usage of the shape regularization algorithm for both angles and offsets sequentially on a set of 2D segments.</p>
<p>The first example contains 15 segments. The angle and offset regularizations are performed on these segments sequentially using the maximum bounds of 10 degrees and 0.1 unit length respectively. We also show here how to create and work with contextually similar groups of segments and regularize each group on its own. The defined groups are the outer boundary, top and bottom rhombus. Since the shape regularization algorithm on segments is based on the <a class="el" href="index.html#QP_Regularization">QP Regularization</a> framework, this example also shows how to use that framework directly instead of calling the function <code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#ga3cde2421ff91530c13c9e8f1feaeae1c" title="regularizes a set of 2D segments. ">regularize_segments()</a></code>.</p>
<p><a class="anchor" id="Regularize_15_Segments_Figure"></a><a class="anchor" id="fig__regularize_15_segments_example"></a></p><div class="image">
<object type="image/svg+xml" data="regularize_15_segments.svg">regularize_15_segments.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__regularize_15_segments_example">Figure 82.6</a> A set of 2D segments before (red), after the angle (yellow), and the offset (green) regularization.  </div> <br /> 
<p><br />
<b>File</b> <a class="el" href="Shape_regularization_2regularize_15_segments_8cpp-example.html">Shape_regularization/regularize_15_segments.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include "include/utils.h"</span></div><div class="line"><span class="preprocessor">#include "include/Saver.h"</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Shape__regularization_8h.html">CGAL/Shape_regularization.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Typedefs.</span></div><div class="line"><span class="keyword">using</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>      = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div><div class="line"><span class="keyword">using</span> FT          = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"><span class="keyword">using</span> Segment_2   = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#aa6d2526f8d1571f4a38aa8a6d9a02c2b">Kernel::Segment_2</a>;</div><div class="line"><span class="keyword">using</span> Segments    = std::vector&lt;Segment_2&gt;;</div><div class="line"><span class="keyword">using</span> Indices     = std::vector&lt;std::size_t&gt;;</div><div class="line"><span class="keyword">using</span> Segment_map = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map&lt;Segment_2&gt;</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Neighbor_query =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Delaunay__neighbor__query__2.html">CGAL::Shape_regularization::Segments::Delaunay_neighbor_query_2&lt;Kernel, Segments, Segment_map&gt;</a>;</div><div class="line"><span class="keyword">using</span> Angle_regularization =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Angle__regularization__2.html">CGAL::Shape_regularization::Segments::Angle_regularization_2&lt;Kernel, Segments, Segment_map&gt;</a>;</div><div class="line"><span class="keyword">using</span> Offset_regularization =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Offset__regularization__2.html">CGAL::Shape_regularization::Segments::Offset_regularization_2&lt;Kernel, Segments, Segment_map&gt;</a>;</div><div class="line"><span class="keyword">using</span> Quadratic_program =</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classCGAL_1_1OSQP__quadratic__program__traits.html">CGAL::OSQP_quadratic_program_traits&lt;FT&gt;</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Quadratic_angle_regularizer =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1QP__regularization.html">CGAL::Shape_regularization::QP_regularization</a>&lt;</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>, Segments, Neighbor_query, Angle_regularization, Quadratic_program&gt;;</div><div class="line"><span class="keyword">using</span> Quadratic_offset_regularizer =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1QP__regularization.html">CGAL::Shape_regularization::QP_regularization</a>&lt;</div><div class="line">    Kernel, Segments, Neighbor_query, Offset_regularization, Quadratic_program&gt;;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div><div class="line"></div><div class="line">  <span class="comment">// If we want to save the result in a file, we save it in a path.</span></div><div class="line">  std::string path = <span class="stringliteral">""</span>;</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1) path = argv[1];</div><div class="line">  Saver&lt;Kernel&gt; saver;</div><div class="line"></div><div class="line">  <span class="comment">// Initialize 15 segments.</span></div><div class="line">  std::vector&lt;Segment_2&gt; segments;</div><div class="line">  create_example_15(segments);</div><div class="line"></div><div class="line">  <span class="comment">// We create three groups of segments:</span></div><div class="line">  <span class="comment">// outer, top and bottom rhombuses.</span></div><div class="line">  std::vector&lt;Indices&gt; groups(3);</div><div class="line">  groups[0] = {0, 1, 2, 3, 4, 5, 6}; <span class="comment">// outer</span></div><div class="line">  groups[1] = {7, 8, 9, 10};         <span class="comment">// top rhombus</span></div><div class="line">  groups[2] = {11, 12, 13, 14};      <span class="comment">// bottom rhombus</span></div><div class="line"></div><div class="line">  <span class="comment">// Save input segments.</span></div><div class="line">  <span class="keywordflow">if</span> (path != <span class="stringliteral">""</span>) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = path + <span class="stringliteral">"regularize_15_segments_before"</span>;</div><div class="line">    saver.export_eps_segments(segments, full_path, FT(100));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Angle regularization.</span></div><div class="line">  <span class="keyword">const</span> FT max_angle_2 = FT(10);</div><div class="line"></div><div class="line">  <span class="comment">// Create qp solver, neigbor query, and angle-based regularization model.</span></div><div class="line">  Quadratic_program qp_angles;</div><div class="line">  Neighbor_query neighbor_query(segments);</div><div class="line">  Angle_regularization angle_regularization(</div><div class="line">    segments, CGAL::parameters::maximum_angle(max_angle_2));</div><div class="line"></div><div class="line">  <span class="comment">// Add each group of input segments.</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; group : groups) {</div><div class="line">    neighbor_query.add_group(group);</div><div class="line">    angle_regularization.add_group(group);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Regularize.</span></div><div class="line">  Quadratic_angle_regularizer qp_angle_regularizer(</div><div class="line">    segments, neighbor_query, angle_regularization, qp_angles);</div><div class="line">  qp_angle_regularizer.regularize();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* number of modified segments (angles) = "</span> &lt;&lt;</div><div class="line">    angle_regularization.number_of_modified_segments() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Offset regularization.</span></div><div class="line">  <span class="keyword">const</span> FT max_offset_2 = FT(1) / FT(10);</div><div class="line"></div><div class="line">  <span class="comment">// Get groups of parallel segments after angle regularization.</span></div><div class="line">  std::vector&lt;Indices&gt; pgroups;</div><div class="line">  angle_regularization.parallel_groups(</div><div class="line">    std::back_inserter(pgroups));</div><div class="line"></div><div class="line">  <span class="comment">// Create qp solver and offset-based regularization model.</span></div><div class="line">  Quadratic_program qp_offsets;</div><div class="line">  Offset_regularization offset_regularization(</div><div class="line">    segments, CGAL::parameters::maximum_offset(max_offset_2));</div><div class="line"></div><div class="line">  <span class="comment">// Add each group of parallel segments with at least 2 segments.</span></div><div class="line">  neighbor_query.clear();</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; pgroup : pgroups) {</div><div class="line">    neighbor_query.add_group(pgroup);</div><div class="line">    offset_regularization.add_group(pgroup);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Regularize.</span></div><div class="line">  Quadratic_offset_regularizer qp_offset_regularizer(</div><div class="line">    segments, neighbor_query, offset_regularization, qp_offsets);</div><div class="line">  qp_offset_regularizer.regularize();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* number of modified segments (offsets) = "</span> &lt;&lt;</div><div class="line">    offset_regularization.number_of_modified_segments() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save regularized segments.</span></div><div class="line">  <span class="keywordflow">if</span> (path != <span class="stringliteral">""</span>) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = path + <span class="stringliteral">"regularize_15_segments_after"</span>;</div><div class="line">    saver.export_eps_segments(segments, full_path, FT(100));</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>The second example contains 65 segments, which are constructed from a set of input points. All points are organized into groups such that each group represents an approximate 2D line. Organizing points into such groups can be achieved with the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgShapeDetection">Shape Detection</a> package. We fit a segment to each group of points using the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgPrincipalComponentAnalysisD">Principal Component Analysis</a> package. The angle and offset regularizations are performed on these segments sequentially using the bounds of 80 degrees and 2 unit lengths respectively.</p>
<p><a class="anchor" id="fig__regularize_real_data_2_example"></a></p><div class="image">
<object type="image/svg+xml" data="regularize_real_data_2.svg">regularize_real_data_2.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__regularize_real_data_2_example">Figure 82.7</a> A set of 2D segments before (red), after the angle (yellow), and the offset (green) regularization.  </div> <br /> 
<p><br />
<b>File</b> <a class="el" href="Shape_regularization_2regularize_real_data_2_8cpp-example.html">Shape_regularization/regularize_real_data_2.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include "include/utils.h"</span></div><div class="line"><span class="preprocessor">#include "include/Saver.h"</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Eigen_diagonalize_traits.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/linear_least_squares_fitting_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="regularize__segments_8h.html">CGAL/Shape_regularization/regularize_segments.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Typedefs.</span></div><div class="line"><span class="keyword">using</span> Kernel    = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div><div class="line"><span class="keyword">using</span> FT        = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"><span class="keyword">using</span> Point_2   = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>;</div><div class="line"><span class="keyword">using</span> Segment_2 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#aa6d2526f8d1571f4a38aa8a6d9a02c2b">Kernel::Segment_2</a>;</div><div class="line"><span class="keyword">using</span> Line_2    = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#add6b18567776ee7e80dfdfa44c304772">Kernel::Line_2</a>;</div><div class="line"><span class="keyword">using</span> Points_2  = std::vector&lt;Point_2&gt;;</div><div class="line"><span class="keyword">using</span> Indices   = std::vector&lt;std::size_t&gt;;</div><div class="line"><span class="keyword">using</span> Segments  = std::vector&lt;Segment_2&gt;;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Neighbor_query =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Delaunay__neighbor__query__2.html">CGAL::Shape_regularization::Segments::Delaunay_neighbor_query_2&lt;Kernel, Segments&gt;</a>;</div><div class="line"><span class="keyword">using</span> Angle_regularization =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Angle__regularization__2.html">CGAL::Shape_regularization::Segments::Angle_regularization_2&lt;Kernel, Segments&gt;</a>;</div><div class="line"><span class="keyword">using</span> Offset_regularization =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Segments_1_1Offset__regularization__2.html">CGAL::Shape_regularization::Segments::Offset_regularization_2&lt;Kernel, Segments&gt;</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div><div class="line"></div><div class="line">  <span class="comment">// If we want to load a different file, we load it from a path.</span></div><div class="line">  <span class="comment">// Each point comes with the index of the corresponding group.</span></div><div class="line">  <span class="comment">// The file format: x y z i, where i is the group index. The points</span></div><div class="line">  <span class="comment">// are 2D hence z = 0. Each group contains points, which form</span></div><div class="line">  <span class="comment">// an approximate line.</span></div><div class="line">  std::string path = <span class="stringliteral">"data/real_data_2.xyzi"</span>;</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1) path = argv[1];</div><div class="line">  Saver&lt;Kernel&gt; saver;</div><div class="line"></div><div class="line">  <span class="comment">// Initialize input groups with points.</span></div><div class="line">  std::vector&lt;Points_2&gt; groups;</div><div class="line">  initialize_groups(path, groups);</div><div class="line"></div><div class="line">  <span class="comment">// Fit a line to each group of points.</span></div><div class="line">  Line_2 line; Point_2 <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__centroid__grp.html#gacc395064255dfefdb1420309db234210">centroid</a>;</div><div class="line">  std::vector&lt;Line_2&gt; lines;</div><div class="line">  lines.reserve(groups.size());</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; group : groups) {</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Principal_component_analysis.tag:../Principal_component_analysis/" href="../Principal_component_analysis/group__PkgPrincipalComponentAnalysisDLLSF2.html#gaf0d4435db5901ebe10cafd7de7c077f3">CGAL::linear_least_squares_fitting_2</a>(</div><div class="line">      group.begin(), group.end(), line, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__centroid__grp.html#gacc395064255dfefdb1420309db234210">centroid</a>, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Dimension__tag.html">CGAL::Dimension_tag&lt;0&gt;</a>(),</div><div class="line">      Kernel(), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classCGAL_1_1Eigen__diagonalize__traits.html">CGAL::Eigen_diagonalize_traits&lt;FT, 2&gt;</a>());</div><div class="line">    lines.push_back(line);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Cut each line at the ends of the corresponding group.</span></div><div class="line">  std::vector&lt;Segment_2&gt; segments;</div><div class="line">  segments.reserve(lines.size());</div><div class="line">  Point_2 source, target;</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; lines.size(); ++i) {</div><div class="line">    boundary_points_on_line_2(</div><div class="line">      groups[i], lines[i], source, target);</div><div class="line">    segments.push_back(Segment_2(source, target));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Save input segments.</span></div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 2) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = std::string(argv[2]) + <span class="stringliteral">"regularize_real_data_2_before"</span>;</div><div class="line">    saver.export_eps_segments(segments, full_path, FT(3) / FT(2));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Angle regularization.</span></div><div class="line">  <span class="keyword">const</span> FT max_angle_2 = FT(80);</div><div class="line"></div><div class="line">  <span class="comment">// Create neigbor query and angle-based regularization model.</span></div><div class="line">  Neighbor_query neighbor_query(segments);</div><div class="line">  Angle_regularization angle_regularization(</div><div class="line">    segments, CGAL::parameters::maximum_angle(max_angle_2));</div><div class="line"></div><div class="line">  <span class="comment">// Regularize.</span></div><div class="line">  <a class="code" href="group__PkgShapeRegularizationRefSegments.html#ga3cde2421ff91530c13c9e8f1feaeae1c">CGAL::Shape_regularization::Segments::regularize_segments</a>(</div><div class="line">    segments, neighbor_query, angle_regularization);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* number of modified segments (angles) = "</span> &lt;&lt;</div><div class="line">    angle_regularization.number_of_modified_segments() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Offset regularization.</span></div><div class="line">  <span class="keyword">const</span> FT max_offset_2 = FT(2);</div><div class="line"></div><div class="line">  <span class="comment">// Get groups of parallel segments after angle regularization.</span></div><div class="line">  std::vector&lt;Indices&gt; pgroups;</div><div class="line">  angle_regularization.parallel_groups(</div><div class="line">    std::back_inserter(pgroups));</div><div class="line"></div><div class="line">  <span class="comment">// Create offset-based regularization model.</span></div><div class="line">  Offset_regularization offset_regularization(</div><div class="line">    segments, CGAL::parameters::maximum_offset(max_offset_2));</div><div class="line"></div><div class="line">  <span class="comment">// Add each group of parallel segments with at least 2 segments.</span></div><div class="line">  neighbor_query.clear();</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; pgroup : pgroups) {</div><div class="line">    neighbor_query.add_group(pgroup);</div><div class="line">    offset_regularization.add_group(pgroup);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Regularize.</span></div><div class="line">  <a class="code" href="group__PkgShapeRegularizationRefSegments.html#ga3cde2421ff91530c13c9e8f1feaeae1c">CGAL::Shape_regularization::Segments::regularize_segments</a>(</div><div class="line">    segments, neighbor_query, offset_regularization);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* number of modified segments (offsets) = "</span> &lt;&lt;</div><div class="line">    offset_regularization.number_of_modified_segments() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save regularized segments.</span></div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 2) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = std::string(argv[2]) + <span class="stringliteral">"regularize_real_data_2_after"</span>;</div><div class="line">    saver.export_eps_segments(segments, full_path, FT(3) / FT(2));</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="QP_Regularization_Segments_Utils"></a>
Utility Functions</h2>
<p>In addition to the main algorithm, we also provide several utility functions, which are often used in conjunction with the algorithm.</p>
<h3><a class="anchor" id="QP_Regularization_Segments_Groups"></a>
Grouping Segments</h3>
<p>This CGAL component also provides three ways to group segments:</p><ul>
<li><code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#gac72eca9b32b73a3713edffd2da5609f2" title="finds groups of parallel segments in a set of 2D segments. ">Segments::parallel_groups()</a></code> - organizes a set of unordered 2D segments into groups of parallel segments.</li>
<li><code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#ga7fe1c4b39b16dee49ba9c41dc3c0b0f8" title="finds groups of orthogonal segments in a set of 2D segments. ">Segments::orthogonal_groups()</a></code> - organizes a set of unordered 2D segments into groups of orthogonal segments.</li>
<li><code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#ga7ade7f4682f9953fcf36669b2079f4d9" title="finds groups of collinear segments in a set of 2D segments. ">Segments::collinear_groups()</a></code> - organizes a set of unordered 2D segments into groups of collinear segments.</li>
</ul>
<p><a class="anchor" id="fig__parallel_groups"></a></p><div class="image">
<object type="image/svg+xml" data="groups.svg">groups.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__parallel_groups">Figure 82.8</a> Groups of near parallel (left), near orthogonal (center), and near collinear (right) segments. Red, green, blue colors indicate groups within each set of 2D segments.  </div> <br /> 
<p>The function <code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#gac72eca9b32b73a3713edffd2da5609f2" title="finds groups of parallel segments in a set of 2D segments. ">Segments::parallel_groups()</a></code> enables users to form groups of parallel segments. For example, if you know that all your segments are already near parallel to each other within some tolerance error and you do not want to orient them by applying the <a class="el" href="index.html#QP_Regularization_Segments_Angles">Angle Regularization</a> algorithm, but you still need to make them collinear by minimizing the offset among parallel segments using the <a class="el" href="index.html#QP_Regularization_Segments_Offset">Offset Regularization</a> algorithm, you can create the groups of parallel segments by using this function and provide them as input to the offset regularization algorithm as we do it <a class="el" href="index.html#QP_Parallel_Groups_Example">here</a>.</p>
<p>The other two functions serve a similar goal. The one <code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#ga7fe1c4b39b16dee49ba9c41dc3c0b0f8" title="finds groups of orthogonal segments in a set of 2D segments. ">Segments::orthogonal_groups()</a></code> first creates groups of parallel segments and then merges them into groups, where all segments are either parallel or orthogonal to each other. The one <code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#ga7ade7f4682f9953fcf36669b2079f4d9" title="finds groups of collinear segments in a set of 2D segments. ">Segments::collinear_groups()</a></code> first creates groups of parallel segments and then splits each of these groups into groups of collinear segments, if any.</p>
<dl class="section note"><dt>Note</dt><dd>Note that none of these functions applies the regularization of the input segments. They only return groups of indices of segments with similar orientations and/or positions.</dd></dl>
<h3><a class="anchor" id="QP_Regularization_Segments_Simplification"></a>
Simplifying Segments</h3>
<p>After regularizing angles and offsets, simplifying segments with similar properties is a common post-processing task. This CGAL component provides an utility function <code><a class="el" href="group__PkgShapeRegularizationRefSegments.html#ga9312b7fea9ddc4beae7b166ccc4607df" title="substitutes groups of 2D collinear segments by average segments. ">Segments::unique_segments()</a></code> that takes a set of input segments, groups them with respect to the collinearity property, and then returns for each group of collinear segments a segment that best fits this group (see the figure below).</p>
<dl class="section note"><dt>Note</dt><dd>Even if the segments are far away from each other but close with respect to the orthogonal distance between them that is they are almost collinear, they will be merged as the blue segments in the figure.</dd></dl>
<p><a class="anchor" id="fig__unique_segments"></a></p><div class="image">
<object type="image/svg+xml" data="unique_segments.svg">unique_segments.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__unique_segments">Figure 82.9</a> Input segments with multiple collinear segments (left) are simplified into unique segments (right).  </div> <br /> 
<h2><a class="anchor" id="QP_Regularization_Segments_Performance"></a>
Performance</h2>
<p>The performance of the shape regularization algorithm mostly depends on the used QP solver. When using the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classCGAL_1_1OSQP__quadratic__program__traits.html">CGAL::OSQP_quadratic_program_traits</a></code> model, we exploit and efficiently use the sparse nature of the related QP problem that leads to quick performances in practice.</p>
<p>The plot (solid) below shows how the computation time depends on the number of input segments. We first observe that the most challenging step is angle regularization while the offset regularization is much faster. This is an effect of complexity reduction by segmenting the problem into groups for offset regularization. Since each group of parallel segments is much smaller than the original set of input segments, the total computation time is smaller, too. The same idea can be applied to accelerate the angle regularization. Splitting input segments into groups with contextually similar properties from the very beginning will lead to better performance as indicated in the plot (dashed). However, note that not each data set can be meaningfully split into such groups.</p>
<p>To benchmark the algorithm, we used a MacBook Pro 2018 with 2.2 GHz Intel Core i7 processor (6 cores) and 32 GB 2400 MHz DDR4 memory. The installed operating system was OS X 10.15 Catalina. We first create a set of random segments in a square such that all segments are either parallel to the X axis or Y axis. We then slightly perturb all segments by a random angle within the interval [-15, 15] degrees and apply the regularization algorithm 10 times on the same input. The returned time is the average time over all iterations. In the pre-grouped version, we regroup all segments into groups of 10 segments and the regularization algorithm is applied to each group. For example, in case of 50 input segments, we will have 5 input groups. Since the groups are very small, there is no much difference in time between angle and offset regularizations. The results are shown in the figure below.</p>
<p><a class="anchor" id="fig__qp_segments_bench"></a></p><div class="image">
<object type="image/svg+xml" data="qp_segments_bench.svg">qp_segments_bench.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__qp_segments_bench">Figure 82.10</a> Time in seconds to regularize angles (solid red) and offsets (solid green) without regrouping input segments and with the groups of 10 segments for angles (dashed red) and offsets (dashed green).  </div> <br /> 
<h1><a class="anchor" id="Contour_Regularization"></a>
Contours</h1>
<p>Given a set of ordered 2D points connected by segments, which form a contour, closed or open, users can reinforce three types of regularities among consecutive edges of this contour:</p><ul>
<li><em>Parallelism</em>: contour edges, which are detected as near parallel, are made exactly parallel.</li>
<li><em>Orthogonality</em>: contour edges, which are detected as near orthogonal, are made exactly orthogonal.</li>
<li><em>Collinearity</em>: parallel contour edges, which are detected as near collinear, are made exactly collinear.</li>
</ul>
<p>A typical use of this algorithm consists of the following steps:</p><ol type="1">
<li>Specify a type of the contour, open or closed;</li>
<li>Create an instance of the class <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1ContourDirections.html" title="We assume that each contour has one or several principal directions. By implementing a model of this ...">ContourDirections</a></code> with the proper parameters;</li>
<li>Call the function <code><a class="el" href="group__PkgShapeRegularizationRefContours.html#ga7e2f3e7e76c52a3acef42a0d413a17c6" title="regularizes closed contours. ">regularize_closed_contour()</a></code> or <code><a class="el" href="group__PkgShapeRegularizationRefContours.html#gae860b28fa0fde23f6f6540f483b4ecff" title="regularizes open contours. ">regularize_open_contour()</a></code>.</li>
</ol>
<p>We assume that each contour has at least one principal direction that is a reference direction towards which the contour edges are rotated. Given a set of such directions either estimated or user-specified, each edge is made either parallel or orthogonal to these direction(s).</p>
<p>To estimate principal directions of the contour, this component provides three models of the concept <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1ContourDirections.html" title="We assume that each contour has one or several principal directions. By implementing a model of this ...">ContourDirections</a></code>:</p><ul>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1Contours_1_1Longest__direction__2.html" title="Estimates the longest principal direction of the contour. ">Contours::Longest_direction_2</a></code> - sets the longest contour edge as the only principal direction.</li>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1Contours_1_1Multiple__directions__2.html" title="Estimates possibly multiple principal directions of the contour based on the user-specified minimum l...">Contours::Multiple_directions_2</a></code> - tries to estimate multiple principal directions in the contour based on the user-specified parameters (see the figure below).</li>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1Contours_1_1User__defined__directions__2.html" title="Sets multiple user-specified principal directions of the contour. ">Contours::User_defined_directions_2</a></code> - sets the user-specified principal directions as contour directions.</li>
</ul>
<p><a class="anchor" id="fig__multiple_directions"></a></p><div class="image">
<object type="image/svg+xml" data="multiple_directions.svg">multiple_directions.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__multiple_directions">Figure 82.11</a> A closed contour before (red) and after (green) the contour regularization. The found principal directions are marked yellow.  </div> <br /> 
<p>After the directions are set, the algorithm is linear in the number of contour edges. It first goes through each contour edge and orients it towards the best-fit direction. In the second step, all parallel consecutive edges are merged if they are within a user-specified maximum tolerance distance. The distance here is defined as the distance between the midpoint of the first edge and the projection of this point onto the supporting line of the next edge. The position of the merged segment is optimized with respect to its neighbors. In the last steps, all segments are reconnected into a contour as shown in the figure below. Due to the merging step, the number of output edges in the contour is not necessarily the same as the number of input edges.</p>
<p><a class="anchor" id="fig__contours_pipeline"></a></p><div class="image">
<object type="image/svg+xml" data="contours_pipeline.svg">contours_pipeline.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__contours_pipeline">Figure 82.12</a> Steps of the contour regularization algorithm (from left to right): the closed contour before regularization; the disconnected contour with edges rotated towards the found principal directions, here we have only one direction; the optimized edges, blue edges were merged and their positions were optimized; and the final reconnected contour.  </div> <br /> 
<p>If the user wants to rotate each contour edge on its own towards the best-fit direction without reconnecting them after into a closed/open contour, she can either use the <a class="el" href="index.html#QP_Regularization_Segments">Segment Regularization</a> algorithm or she can orient each segment by calling the <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1ContourDirections.html#a07f23b0d134d1dfb32158f485aab15b8" title="orients a given segment with the index query_index towards the best-fit direction of the contour...">ContourDirections::orient()</a></code> method.</p>
<p>The example below shows the most straightforward entry point to the algorithm, where we regularize a simple closed contour. The algorithm is called via the function <code><a class="el" href="group__PkgShapeRegularizationRefContours.html#ga7e2f3e7e76c52a3acef42a0d413a17c6" title="regularizes closed contours. ">regularize_closed_contour()</a></code>.</p>
<p><a class="anchor" id="fig__regularize_contour_example"></a></p><div class="image">
<object type="image/svg+xml" data="regularize_contour.svg">regularize_contour.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__regularize_contour_example">Figure 82.13</a> A closed contour before (red) and after (green) regularization.  </div> <br /> 
<p><br />
<b>File</b> <a class="el" href="Shape_regularization_2regularize_contour_8cpp-example.html">Shape_regularization/regularize_contour.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="regularize__contours_8h.html">CGAL/Shape_regularization/regularize_contours.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> Kernel  = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> Point_2 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">  <span class="comment">// Create input contour.</span></div><div class="line">  <span class="keyword">const</span> std::vector&lt;Point_2&gt; contour = {</div><div class="line">    Point_2(0.00,  0.00),</div><div class="line">    Point_2(0.50, -0.05),</div><div class="line">    Point_2(1.00,  0.00),</div><div class="line">    Point_2(1.05,  0.50),</div><div class="line">    Point_2(1.00,  1.00),</div><div class="line">    Point_2(0.00,  1.00)</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="comment">// Regularize this contour.</span></div><div class="line">  std::vector&lt;Point_2&gt; regularized;</div><div class="line">  <a class="code" href="group__PkgShapeRegularizationRefContours.html#ga7e2f3e7e76c52a3acef42a0d413a17c6">CGAL::Shape_regularization::Contours::</a></div><div class="line"><a class="code" href="group__PkgShapeRegularizationRefContours.html#ga7e2f3e7e76c52a3acef42a0d413a17c6">    regularize_closed_contour</a>(contour, std::back_inserter(regularized));</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Contour_Regularization_Closed"></a>
Closed Contours</h2>
<p>In the example below, we regularize a closed contour. We use multiple directions estimator, which returns only one direction, because the contour is quite rectilinear. In fact, the returned direction in this case coincides with the longest edge direction.</p>
<p><a class="anchor" id="fig__regularize_closed_contour_example"></a></p><div class="image">
<object type="image/svg+xml" data="regularize_closed_contour.svg">regularize_closed_contour.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__regularize_closed_contour_example">Figure 82.14</a> A closed contour before (red) and after (green) the contour regularization.  </div> <br /> 
<p><br />
<b>File</b> <a class="el" href="Shape_regularization_2regularize_closed_contour_8cpp-example.html">Shape_regularization/regularize_closed_contour.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include "include/utils.h"</span></div><div class="line"><span class="preprocessor">#include "include/Saver.h"</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="regularize__contours_8h.html">CGAL/Shape_regularization/regularize_contours.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Typedefs.</span></div><div class="line"><span class="keyword">using</span> Kernel  = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div><div class="line"><span class="keyword">using</span> FT      = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"><span class="keyword">using</span> Point_2 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>;</div><div class="line"><span class="keyword">using</span> Contour = std::vector&lt;Point_2&gt;;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Contour_directions =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Contours_1_1Multiple__directions__2.html">CGAL::Shape_regularization::Contours::Multiple_directions_2&lt;Kernel, Contour&gt;</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div><div class="line"></div><div class="line">  <span class="comment">// If we want to load a different file, we load it from a path.</span></div><div class="line">  std::string path = <span class="stringliteral">"data/contour.polylines"</span>;</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1) path = argv[1];</div><div class="line">  Saver&lt;Kernel&gt; saver;</div><div class="line"></div><div class="line">  <span class="comment">// Set parameters.</span></div><div class="line">  <span class="keyword">const</span> FT min_length_2 = FT(2);</div><div class="line">  <span class="keyword">const</span> FT  max_angle_2 = FT(20);</div><div class="line">  <span class="keyword">const</span> FT max_offset_2 = FT(2);</div><div class="line"></div><div class="line">  <span class="comment">// Initialize contour.</span></div><div class="line">  std::vector&lt;Point_2&gt; contour;</div><div class="line">  initialize_contour(path, contour);</div><div class="line"></div><div class="line">  <span class="comment">// Save input contour.</span></div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 2) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = std::string(argv[2]) + <span class="stringliteral">"regularize_closed_contour_before"</span>;</div><div class="line">    saver.export_eps_closed_contour(contour, full_path, FT(8));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Regularize.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#gae04c8044cf1eee6a84baa5b79ab99fef">is_closed</a> = <span class="keyword">true</span>;</div><div class="line">  Contour_directions directions(</div><div class="line">    contour, is_closed, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL_1_1parameters.html">CGAL::parameters</a>::</div><div class="line">    minimum_length(min_length_2).maximum_angle(max_angle_2));</div><div class="line"></div><div class="line">  std::vector&lt;Point_2&gt; regularized;</div><div class="line">  <a class="code" href="group__PkgShapeRegularizationRefContours.html#ga7e2f3e7e76c52a3acef42a0d413a17c6">CGAL::Shape_regularization::Contours::regularize_closed_contour</a>(</div><div class="line">    contour, directions, std::back_inserter(regularized),</div><div class="line">    CGAL::parameters::maximum_offset(max_offset_2));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* number of directions = "</span> &lt;&lt;</div><div class="line">    directions.number_of_directions() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save regularized contour.</span></div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 2) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = std::string(argv[2]) + <span class="stringliteral">"regularize_closed_contour_after"</span>;</div><div class="line">    saver.export_eps_closed_contour(regularized, full_path, FT(8));</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Contour_Regularization_Open"></a>
Open Contours</h2>
<p>Open contours are contours where the head and tail of the contour are not connected. This case requires a special treatment, but the core of the algorithm is the same. In the example below, we regularize an open contour with respect to its longest edge. This example also shows how to provide a property map to the algorithm in order to give the algorithm access to the coordinates of the contour vertices.</p>
<p><a class="anchor" id="fig__regularize_open_contour_example"></a></p><div class="image">
<object type="image/svg+xml" data="regularize_open_contour.svg">regularize_open_contour.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__regularize_open_contour_example">Figure 82.15</a> An open contour before (red) and after (green) the contour regularization.  </div> <br /> 
<p><br />
<b>File</b> <a class="el" href="Shape_regularization_2regularize_open_contour_8cpp-example.html">Shape_regularization/regularize_open_contour.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include "include/utils.h"</span></div><div class="line"><span class="preprocessor">#include "include/Saver.h"</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="regularize__contours_8h.html">CGAL/Shape_regularization/regularize_contours.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Typedefs.</span></div><div class="line"><span class="keyword">using</span> Kernel  = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div><div class="line"><span class="keyword">using</span> FT      = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"><span class="keyword">using</span> Point_2 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>;</div><div class="line"><span class="keyword">using</span> Contour = std::vector&lt;Point_2&gt;;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Contour_directions =</div><div class="line">  <a class="code" href="classCGAL_1_1Shape__regularization_1_1Contours_1_1Longest__direction__2.html">CGAL::Shape_regularization::Contours::Longest_direction_2&lt;Kernel, Contour&gt;</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div><div class="line"></div><div class="line">  <span class="comment">// If we want to load a different file, we load it from a path.</span></div><div class="line">  std::string path = <span class="stringliteral">"data/contour.polylines"</span>;</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1) path = argv[1];</div><div class="line">  Saver&lt;Kernel&gt; saver;</div><div class="line"></div><div class="line">  <span class="comment">// Set parameters.</span></div><div class="line">  <span class="keyword">const</span> FT max_offset_2 = FT(2);</div><div class="line"></div><div class="line">  <span class="comment">// Initialize contour.</span></div><div class="line">  std::vector&lt;Point_2&gt; contour;</div><div class="line">  initialize_contour(path, contour);</div><div class="line"></div><div class="line">  <span class="comment">// Save input contour.</span></div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 2) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = std::string(argv[2]) + <span class="stringliteral">"regularize_open_contour_before"</span>;</div><div class="line">    saver.export_eps_open_contour(contour, full_path, FT(8));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Regularize.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span> is_closed = <span class="keyword">false</span>;</div><div class="line">  Contour_directions directions(contour, is_closed);</div><div class="line"></div><div class="line">  std::vector&lt;Point_2&gt; regularized;</div><div class="line">  <a class="code" href="group__PkgShapeRegularizationRefContours.html#gae860b28fa0fde23f6f6540f483b4ecff">CGAL::Shape_regularization::Contours::regularize_open_contour</a>(</div><div class="line">    contour, directions, std::back_inserter(regularized),</div><div class="line">    CGAL::parameters::maximum_offset(max_offset_2));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* number of directions = "</span> &lt;&lt;</div><div class="line">    directions.number_of_directions() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save regularized contour.</span></div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 2) {</div><div class="line">    <span class="keyword">const</span> std::string full_path = std::string(argv[2]) + <span class="stringliteral">"regularize_open_contour_after"</span>;</div><div class="line">    saver.export_eps_open_contour(regularized, full_path, FT(8));</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Contour_Regularization_Performance"></a>
Performance</h2>
<p>The contour regularization algorithms, both closed and open, have, in practice, a linear time behavior with respect to the number of contour vertices. In fact, the time is not linear, as you can see in the plot below, due to the second step of merging consecutive collinear edges. For some polygons, the number of such edges is quite high and before merging them into one segment, we collect all of them into a group in order to find the best optimal position to place the final segment that may lead to a slower performance in some cases.</p>
<p>To benchmark the algorithm, we used a MacBook Pro 2018 with 2.2 GHz Intel Core i7 processor (6 cores) and 32 GB 2400 MHz DDR4 memory. The installed operating system was OS X 10.15 Catalina. We first create a rectilinear polygon with the required number of edges. We then slightly perturb all edges by a random angle within the interval [-15, 15] degrees and apply the regularization algorithm 10 times on the same input. The returned time is the average time over all iterations. The results are shown in the figure below.</p>
<p><a class="anchor" id="fig__contours_bench"></a></p><div class="image">
<object type="image/svg+xml" data="contours_bench.svg">contours_bench.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__contours_bench">Figure 82.16</a> Time in seconds to regularize closed (red) and open (green) contours.  </div> <br /> 
<h1><a class="anchor" id="Plane_Regularization"></a>
Planes</h1>
<p>Given a set of 3D planes with their corresponding inlier sets, users can reinforce four types of regularities among these planes using the function <code><a class="el" href="group__PkgShapeRegularizationRefPlanes.html#ga9ace5aafd056ce9ccb348c96e38d361a" title="Hierarchical plane regularization. ">regularize_planes()</a></code>:</p><ul>
<li><em>Parallelism</em>: planes, which are detected as near parallel, are made exactly parallel.</li>
<li><em>Orthogonality</em>: planes, which are detected as near orthogonal, are made exactly orthogonal.</li>
<li><em>Coplanarity</em>: parallel planes, which are detected as near coplanar, are made exactly coplanar.</li>
<li><em>Axis-Symmetry</em>: planes, which are detected as near symmetrical with respect to a user-specified axis, are made exactly symmetrical.</li>
</ul>
<p>The user can choose to regularize only one or several of these four properties. The process is greedy and based on a hierarchical decomposition (coplanar clusters are subgroups of parallel clusters, which are subgroups of axis-symmetric and orthogonal clusters) as described by Verdie et al. in <a class="el" href="citelist.html#CITEREF_cgal:vla-lod-15">[2]</a>.</p>
<p>The following example illustrates how to use the plane regularization function.</p>
<p><br />
<b>File</b> <a class="el" href="Shape_regularization_2regularize_planes_8cpp-example.html">Shape_regularization/regularize_planes.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include "include/utils.h"</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/Efficient__RANSAC_8h.html">CGAL/Shape_detection/Efficient_RANSAC.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="regularize__planes_8h.html">CGAL/Shape_regularization/regularize_planes.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Typedefs.</span></div><div class="line"><span class="keyword">using</span> Kernel   = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div><div class="line"><span class="keyword">using</span> FT       = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"><span class="keyword">using</span> Point_3  = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ae82b7f4be77dd5b8819ebe419e4ae753">Kernel::Point_3</a>;</div><div class="line"><span class="keyword">using</span> Vector_3 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a39fb0222695ae5e7e32f4e570ea28225">Kernel::Vector_3</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Point_with_normal = std::pair&lt;Point_3, Vector_3&gt;;</div><div class="line"><span class="keyword">using</span> Point_map         = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Point_with_normal&gt;</a>;</div><div class="line"><span class="keyword">using</span> Normal_map        = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;Point_with_normal&gt;</a>;</div><div class="line"><span class="keyword">using</span> Pwn_vector        = std::vector&lt;Point_with_normal&gt;;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Traits    = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/structCGAL_1_1Shape__detection_1_1Efficient__RANSAC__traits.html">CGAL::Shape_detection::Efficient_RANSAC_traits&lt;Kernel, Pwn_vector, Point_map, Normal_map&gt;</a>;</div><div class="line"><span class="keyword">using</span> RANSAC    = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Efficient__RANSAC.html">CGAL::Shape_detection::Efficient_RANSAC&lt;Traits&gt;</a>;</div><div class="line"><span class="keyword">using</span> Plane     = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Plane.html">CGAL::Shape_detection::Plane&lt;Traits&gt;</a>;</div><div class="line"><span class="keyword">using</span> Plane_map = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Plane__map.html">CGAL::Shape_detection::Plane_map&lt;Traits&gt;</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div><div class="line"></div><div class="line">  <span class="comment">// If we want to load a different file, we load it from a path.</span></div><div class="line">  std::string path = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/cube.pwn"</span>);</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1) path = argv[1];</div><div class="line"></div><div class="line">  Pwn_vector points;</div><div class="line">  std::ifstream file(path.c_str(), std::ios_base::in);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7d51c854b865a7eb367e21fc43bd37b8">CGAL::IO::set_ascii_mode</a>(file);</div><div class="line">  file.precision(20);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (!file ||</div><div class="line">    !CGAL::IO::read_XYZ(</div><div class="line">      file,</div><div class="line">      std::back_inserter(points),</div><div class="line">      CGAL::parameters::point_map(Point_map()).</div><div class="line">      normal_map(Normal_map()))) {</div><div class="line"></div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read the file cube.pwn!"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line">  file.close();</div><div class="line"></div><div class="line">  <span class="comment">// Call RANSAC shape detection with planes.</span></div><div class="line">  RANSAC efficient_ransac;</div><div class="line">  efficient_ransac.set_input(points);</div><div class="line">  efficient_ransac.add_shape_factory&lt;Plane&gt;();</div><div class="line">  efficient_ransac.detect();</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> planes = efficient_ransac.planes();</div><div class="line"></div><div class="line">  <span class="comment">// Regularize detected planes.</span></div><div class="line">  <a class="code" href="group__PkgShapeRegularizationRefPlanes.html#ga9ace5aafd056ce9ccb348c96e38d361a">CGAL::Shape_regularization::Planes::regularize_planes</a>(</div><div class="line">    planes,</div><div class="line">    points,</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL_1_1parameters.html">CGAL::parameters</a>::</div><div class="line">    plane_map(Plane_map()).</div><div class="line">    point_map(Point_map()).</div><div class="line">    plane_index_map(</div><div class="line">      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Point__to__shape__index__map.html">CGAL::Shape_detection::Point_to_shape_index_map&lt;Traits&gt;</a>(points, planes)).</div><div class="line">    regularize_coplanarity(<span class="keyword">false</span>). <span class="comment">// do not regularize coplanarity</span></div><div class="line">    maximum_angle(FT(10))); <span class="comment">// 10 degrees of tolerance for parallelism / orthogonality</span></div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* all detected planes are regularized"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Please note that this function used to be a part of the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgShapeDetection">Shape Detection</a> package. You can still use the old API of that function, however to avoid parameters ambiguity, we strongly suggest to use the new API with the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/index.html#BGLNamedParameters">Named Parameters</a> mechanism.</dd></dl>
<h1><a class="anchor" id="QP_Regularization"></a>
QP Regularization</h1>
<p>The shape regularization component is a generic framework that is based on the Quadratic Programming (QP) global regularization algorithm <a class="el" href="citelist.html#CITEREF_cgal:bl-kippi-18">[1]</a> by Bauchet et Lafarge. You should refer to this section only if you want to know details on how the shape regularization framework is organized internally or you want to extend that framework by implementing your own regularization types.</p>
<p><a class="el" href="index.html#QP_Regularization_Segments_Angles">Angle Regularization</a> and <a class="el" href="index.html#QP_Regularization_Segments_Offset">Offset Regularization</a> that we presented before are two particular instances of this algorithm. Other instances can be added by the user, as explained <a class="el" href="index.html#QP_Regularization_Implementation">here</a>.</p>
<h2><a class="anchor" id="QP_Regularization_Framework"></a>
Framework</h2>
<p>This framework follows Section 3 from <a class="el" href="citelist.html#CITEREF_cgal:bl-kippi-18">[1]</a>, however the algorithm from that paper was extended and generalized. The idea behind the main algorithm is to minimize the energy</p>
<center> \(U(\boldsymbol{x}) = (1 - \lambda) D(\boldsymbol{x}) + \lambda V(\boldsymbol{x})\),</center><p>where \(\boldsymbol{x} = (x_1, \dots, x_n)\) is a configuration of perturbations operated on \(n\) input items, \(D(\boldsymbol{x})\) and \(V(\boldsymbol{x})\) represent a data term and pairwise potential respectively, and \(\lambda \in [0, 1]\) is a parameter weighting these two terms. By setting up the correct types of \(D(\boldsymbol{x})\) and \(V(\boldsymbol{x})\), the problem can be reformulated into a quadratic optimization problem with \((n + m)\) variables and \(2(n + m)\) linear constraints, where \(m\) is the number of unique pairs formed by connecting an item to one of its closest neighbors. Let us explain how it all works when the input items are segments and we want to regularize their orientations in order to reinforce parallelism and orthogonality among them.</p>
<p>To set up the framework, we first need to find closest neighbors for each segment. These neighbors are provided via the concept <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1NeighborQuery.html" title="A concept that describes the set of methods used by the class QP_regularization to access neighbors o...">NeighborQuery</a></code>. Internally, we create a graph based on these neighbors. Every edge \(\{i, j\}\), where \(i\) is the index of the ith segment and \(j\) is the index of the jth segment is inserted in the graph whenever \(i &lt; j\). This way each pair is inserted only once. The neighbors are found via the <a class="el" href="index.html#QP_Regularization_Segments_Delaunay">Delaunay Neighbor Query</a>.</p>
<p>When we have the graph, we fill in the terms \(D(\boldsymbol{x})\) and \(V(\boldsymbol{x})\) via the concept <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html" title="A concept that describes the set of methods used by the class QP_regularization to access various dat...">RegularizationType</a></code>. First, we obtain a maximum perturbation bound for each segment via the method <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html#a6425688d6368960b0aa5bfd0e6e13541" title="returns the maximum bound on a regularization characteristic (angle-orientation/ distance-offset/etc...">RegularizationType::bound()</a></code>. Since we want to rotate segments, we return here the maximum allowed angle deviation for each segment with respect to its original orientation, lets say 25 degrees.</p>
<p>Next, for every edge \(\{i, j\}\) in the graph, we compute the perturbation difference between two segments \(i\) and \(j\) via the method <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html#ac5bd68e930f080c0b619b3541c5fad9c" title="returns an objective function value between two geometric objects, which are direct neighbors...">RegularizationType::target()</a></code>. For example, that could be a difference of segment orientations with respect to \(90\) or \(180\) degrees. Lets say an angle between two segments is \(85\) degrees then we return \(90 - 85 = 5\) degrees since this is what we should minimize in order to make the two segments orthogonal to each other.</p>
<p>Then we set up the quadratic programming problem that is solved via the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classQuadraticProgramTraits.html">QuadraticProgramTraits</a></code> concept. The returned result is stored as a vector of the length \((n + m)\) with the updated perturbation values, where the first \(n\) values are the values that should be added to the original orientations of the input segments in order to update them and the last \(m\) values are minimized to zeros. The update is achieved via the method <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html#a5fa1b89221a8d2515acff817ceeb6946" title="updates regularization characteristics (angle-orientation/distance-offset/etc.) of the geometric obje...">RegularizationType::update()</a></code>.</p>
<p>Overall, the class <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1QP__regularization.html" title="Shape regularization algorithm based on the quadratic programming global optimization. ">QP_regularization</a></code> is parameterized by:</p><ul>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1NeighborQuery.html" title="A concept that describes the set of methods used by the class QP_regularization to access neighbors o...">NeighborQuery</a></code> that provides the means for accessing local neighbors of an item,</li>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html" title="A concept that describes the set of methods used by the class QP_regularization to access various dat...">RegularizationType</a></code> that determines a regularization type to be applied, and</li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classQuadraticProgramTraits.html">QuadraticProgramTraits</a></code> that is used to solve the corresponding QP problem.</li>
</ul>
<p>Within this generic framework, users can regularize any set of input items provided their own neighbor search, regularization type, and QP solver.</p>
<h2><a class="anchor" id="QP_Regularization_Neighborhood"></a>
Neighborhood</h2>
<p>The concept <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1NeighborQuery.html" title="A concept that describes the set of methods used by the class QP_regularization to access neighbors o...">NeighborQuery</a></code> provides the means for accessing local neighbors of an item. To create a model that respects this concept, the user has to provide an overload of the operator:</p>
<ul>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1NeighborQuery.html#afe9ac86f81427f217a72ee74523e4ade" title="fills in neighbors with indices of all geometric objects, which are direct neighbors of the object wi...">NeighborQuery::operator()()</a></code> that has to fill in a vector with indices of all items, which are neighbors of the query item.</li>
</ul>
<p>For example, given a segment, this operator may return a vector with indices of some other input segments, which are within a certain distance from this segment, however this distance is measured. See above and <a class="el" href="index.html#QP_Regularization_Segments_Delaunay">this section</a> for more details.</p>
<h2><a class="anchor" id="QP_Regularization_Type"></a>
Regularization</h2>
<p>The concept <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html" title="A concept that describes the set of methods used by the class QP_regularization to access various dat...">RegularizationType</a></code> determines a type of regularization to be applied. To create a model that respects this concept, three functions have to be defined:</p>
<ul>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html#ac5bd68e930f080c0b619b3541c5fad9c" title="returns an objective function value between two geometric objects, which are direct neighbors...">RegularizationType::target()</a></code> a function that estimates a type of regularity between two neighbors,</li>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html#a6425688d6368960b0aa5bfd0e6e13541" title="returns the maximum bound on a regularization characteristic (angle-orientation/ distance-offset/etc...">RegularizationType::bound()</a></code> a function that returns a maximum bound on the allowed regularity change, and</li>
<li><code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html#a5fa1b89221a8d2515acff817ceeb6946" title="updates regularization characteristics (angle-orientation/distance-offset/etc.) of the geometric obje...">RegularizationType::update()</a></code> a function that updates input items with respect to the modified regularities.</li>
</ul>
<p>For example, if we want to regularize segment orientations, that is to make segments parallel and orthogonal to each other, the first function should return an angle perturbation between a query segment and each of its neighbors; the second function should return a maximum angle within which a rotation of the query segment is accepted; and the third function should update original orientations of the input segments. See above and <a class="el" href="index.html#QP_Regularization_Segments_Angles">this section</a> for more details.</p>
<h2><a class="anchor" id="QP_Regularization_Solvers"></a>
Solvers</h2>
<p>In order to solve the associated QP problem of the algorithm above, CGAL provides a wrapper <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classCGAL_1_1OSQP__quadratic__program__traits.html">CGAL::OSQP_quadratic_program_traits</a></code> of the external <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartyOSQP">OSQP solver</a> that is a model of the concept <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classQuadraticProgramTraits.html">QuadraticProgramTraits</a></code>.</p>
<p>Alternatively, the internal CGAL solver from the package <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgQPSolver">Linear and Quadratic Programming Solver</a> can be used, however we do not recommend applying it. The internal quadratic program that has to be solved for shape regularization is sparse. The CGAL version will internally convert this problem into a dense one that takes considerable effort to solve, while the OSQP version takes a special care of the sparse nature of the problem that leads to better performance. Since the class <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1QP__regularization.html" title="Shape regularization algorithm based on the quadratic programming global optimization. ">QP_regularization</a></code> is parameterized by the general concept <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classQuadraticProgramTraits.html">QuadraticProgramTraits</a></code>, the users are also welcome to provide their own version of the solver.</p>
<h2><a class="anchor" id="QP_Regularization_Implementation"></a>
Implementation</h2>
<p>If you want to implement your own regularization approach that follows the same framework, for example to reinforce a different type of regularity than is already provided, you have to implement your own model of the <a class="el" href="index.html#QP_Regularization_Type">RegularizationType</a> concept and possibly a model of the <a class="el" href="index.html#QP_Regularization_Neighborhood">NeighborQuery</a> concept. These concepts are used to parameterize the main <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1QP__regularization.html" title="Shape regularization algorithm based on the quadratic programming global optimization. ">QP_regularization</a></code> algorithm:</p><ol type="1">
<li>Use <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1NeighborQuery.html" title="A concept that describes the set of methods used by the class QP_regularization to access neighbors o...">NeighborQuery</a></code> to find local neighbors of each input item;</li>
<li>Use <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html" title="A concept that describes the set of methods used by the class QP_regularization to access various dat...">RegularizationType</a></code> to estimate current regularities among these neighbors;</li>
<li>Use <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html" title="A concept that describes the set of methods used by the class QP_regularization to access various dat...">RegularizationType</a></code> to set maximum bounds on the allowed regularity changes;</li>
<li>Use <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classQuadraticProgramTraits.html">QuadraticProgramTraits</a></code> to solve the quadratic programming problem;</li>
<li>Use <code><a class="el" href="classCGAL_1_1Shape__regularization_1_1RegularizationType.html" title="A concept that describes the set of methods used by the class QP_regularization to access various dat...">RegularizationType</a></code> to update input items with respect to the modified regularities.</li>
</ol>
<p>In addition, the user may also want to change a <a class="el" href="index.html#QP_Regularization_Solvers">QP solver</a> if he knows how to optimize it for a specific type of input data. To do that, the user has to implement a model of the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classQuadraticProgramTraits.html">QuadraticProgramTraits</a></code> concept.</p>
<p>An example below shows how to define your own type of the above concepts and how to choose among available solvers.</p>
<p><br />
<b>File</b> <a class="el" href="Shape_regularization_2regularize_framework_8cpp-example.html">Shape_regularization/regularize_framework.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Shape__regularization_8h.html">CGAL/Shape_regularization.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> Kernel = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> FT     = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Custom_object {</div><div class="line">  <span class="keyword">const</span> std::string name;</div><div class="line">  Custom_object(<span class="keyword">const</span> std::string name_) :</div><div class="line">  name(name_) { }</div><div class="line">  <span class="comment">// define your object here</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Custom_neighbor_query_2 {</div><div class="line">  <span class="keywordtype">void</span> operator()(</div><div class="line">    <span class="keyword">const</span> std::size_t query_index, std::vector&lt;std::size_t&gt;&amp; neighbors) {</div><div class="line">    neighbors.clear();</div><div class="line">    <span class="keywordflow">if</span> (query_index == 0) { neighbors.push_back(1); } <span class="comment">// first  object</span></div><div class="line">    <span class="keywordflow">if</span> (query_index == 1) { neighbors.push_back(0); } <span class="comment">// second object</span></div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Custom_regularization_2 {</div><div class="line">  FT bound(<span class="keyword">const</span> std::size_t )<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> FT(5); <span class="comment">// maximum angle change</span></div><div class="line">  }</div><div class="line">  FT target(<span class="keyword">const</span> std::size_t , <span class="keyword">const</span> std::size_t ) {</div><div class="line">    <span class="keywordflow">return</span> FT(0); <span class="comment">// 0 angle change</span></div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> update(<span class="keyword">const</span> std::vector&lt;FT&gt;&amp; ) {</div><div class="line">    <span class="comment">// skip update</span></div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> NT&gt;</div><div class="line"><span class="keyword">class </span>Custom_quadratic_program_traits  {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keywordtype">void</span>  set_P(<span class="keyword">const</span> std::size_t, <span class="keyword">const</span> std::size_t, <span class="keyword">const</span> FT) { }</div><div class="line">  <span class="keywordtype">void</span>  set_q(<span class="keyword">const</span> std::size_t, <span class="keyword">const</span> FT) { }</div><div class="line">  <span class="keywordtype">void</span>  set_r(<span class="keyword">const</span> FT) { }</div><div class="line">  <span class="keywordtype">void</span>  set_A(<span class="keyword">const</span> std::size_t, <span class="keyword">const</span> std::size_t, <span class="keyword">const</span> FT) { }</div><div class="line">  <span class="keywordtype">void</span>  set_l(<span class="keyword">const</span> std::size_t, <span class="keyword">const</span> FT) { }</div><div class="line">  <span class="keywordtype">void</span>  set_u(<span class="keyword">const</span> std::size_t, <span class="keyword">const</span> FT) { }</div><div class="line">  <span class="keywordtype">void</span> resize(<span class="keyword">const</span> std::size_t, <span class="keyword">const</span> std::size_t) { }</div><div class="line"></div><div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> OutputIterator&gt;</div><div class="line">  <span class="keywordtype">bool</span> solve(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classOutputIterator.html">OutputIterator</a> solution) {</div><div class="line"></div><div class="line">    <span class="comment">// 3 = 2 objects + 1 edge between them</span></div><div class="line">    <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; 3; ++i) {</div><div class="line">      *(++solution) = NT(0);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">using</span> Objects = std::vector&lt;Custom_object&gt;;</div><div class="line"><span class="keyword">using</span> Neighbor_query = Custom_neighbor_query_2;</div><div class="line"><span class="keyword">using</span> Regularization_type = Custom_regularization_2;</div><div class="line"><span class="keyword">using</span> Quadratic_program = Custom_quadratic_program_traits&lt;FT&gt;;</div><div class="line"><span class="keyword">using</span> Regularizer = <a class="code" href="classCGAL_1_1Shape__regularization_1_1QP__regularization.html">CGAL::Shape_regularization::QP_regularization</a>&lt;</div><div class="line">  Kernel, Objects, Neighbor_query, Regularization_type, Quadratic_program&gt;;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">  Neighbor_query neighbor_query;</div><div class="line">  Regularization_type regularization_type;</div><div class="line">  Quadratic_program quadratic_program;</div><div class="line"></div><div class="line">  std::vector&lt;Custom_object&gt; objects = {</div><div class="line">    Custom_object(<span class="stringliteral">"first"</span>), Custom_object(<span class="stringliteral">"second"</span>)</div><div class="line">  };</div><div class="line"></div><div class="line">  Regularizer regularizer(</div><div class="line">    objects, neighbor_query, regularization_type, quadratic_program);</div><div class="line">  regularizer.regularize();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* regularized 2 objects"</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Shape_Regularization_History"></a>
History</h1>
<p>The shape regularization algorithm for 2D segments was first implemented by Jean-Philippe Bauchet under the supervision of Florent Lafarge and then generalized by Gennadii Sytov during the Google Summer of Code 2019 under the supervision of Dmitry Anisimov. The contour regularization algorithm was developed and implemented by Dmitry Anisimov and Simon Giraudot. Plane regularization was added by Simon Giraudot based on the prototype version developed by Florent Lafarge.</p>
<h1><a class="anchor" id="Shape_Regularization_Acknowledgements"></a>
Acknowledgments</h1>
<p>We wish to thank Andreas Fabri and Marc Pouget for useful discussions and reviews. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jul 4 2022 13:25:33 for CGAL 5.6 - Shape Regularization by
    <a href="https://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>
</html>

</html>
