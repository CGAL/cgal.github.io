<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Manual/tuto_reconstruction.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 5.6 - Manual: Surface Reconstruction from Point Clouds</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//&amp;lt;![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      }
  }
}
);
//]]&amp;gt;
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
          <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
          <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt="" /></a>
          </span>
        </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.6 - Manual
   </div>
  </td>
  <!-- We disable the search box because we have added it in the
  back-nav for stylistic reasons. -->
  <!-- <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td> -->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tuto_reconstruction.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Surface Reconstruction from Point Clouds </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> </p><div id="autotoc" class="toc"></div> 
<dl class="section author"><dt>Author</dt><dd>Simon Giraudot</dd></dl>
<p>Surface reconstruction from point clouds is a core topic in geometry processing <a class="el" href="citelist.html#CITEREF_cgal:btsag-asosr-16">[3]</a>. It is an ill-posed problem: there is an infinite number of surfaces that approximate a single point cloud and a point cloud does not define a surface in itself. Thus additional assumptions and constraints must be defined by the user and reconstruction can be achieved in many different ways. This tutorial provides guidance on how to use the different algorithms of CGAL to effectively perform surface reconstruction.</p>
<h1><a class="anchor" id="TutorialsReconstruction_algorithms"></a>
Which algorithm should I use?</h1>
<p>CGAL offers three different algorithms for surface reconstruction:</p>
<ul>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Poisson_surface_reconstruction_3.tag:../Poisson_surface_reconstruction_3/" href="../Poisson_surface_reconstruction_3/index.html#Chapter_Poisson_Surface_Reconstruction">Poisson Surface Reconstruction</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Advancing_front_surface_reconstruction.tag:../Advancing_front_surface_reconstruction/" href="../Advancing_front_surface_reconstruction/index.html#Chapter_Advancing_Front_Surface_Reconstruction">Advancing Front Surface Reconstruction</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Scale_space_reconstruction_3.tag:../Scale_space_reconstruction_3/" href="../Scale_space_reconstruction_3/index.html#Chapter_Scale_space_reconstruction">Scale Space Surface Reconstruction</a></li>
</ul>
<p>Because reconstruction is an ill-posed problem, it must be regularized via prior knowledge. Differences in prior lead to different algorithms, and choosing one or the other of these methods is dependent on these priors. For example, Poisson always generates closed shapes (bounding a volume) and requires normals but does not interpolate input points (the output surface does not pass exactly through the input points). The following table lists different properties of the input and output to help the user choose the method best suited to each problem:</p>
<center> <table class="doxtable">
<tr>
<th></th><th align="center">Poisson </th><th align="center">Advancing front </th><th align="center">Scale space  </th></tr>
<tr>
<td>Are normals required? </td><td align="center">Yes </td><td align="center">No </td><td align="center">No </td></tr>
<tr>
<td>Is noise handled? </td><td align="center">Yes </td><td align="center">By preprocessing </td><td align="center">Yes </td></tr>
<tr>
<td>Is variable sampling handled? </td><td align="center">Yes </td><td align="center">Yes </td><td align="center">By preprocessing </td></tr>
<tr>
<td>Are input points exactly on the surface? </td><td align="center">No </td><td align="center">Yes </td><td align="center">Yes </td></tr>
<tr>
<td>Is the output always closed? </td><td align="center">Yes </td><td align="center">No </td><td align="center">No </td></tr>
<tr>
<td>Is the output always smooth? </td><td align="center">Yes </td><td align="center">No </td><td align="center">No </td></tr>
<tr>
<td>Is the output always manifold? </td><td align="center">Yes </td><td align="center">Yes </td><td align="center">Optional </td></tr>
<tr>
<td>Is the output always orientable? </td><td align="center">Yes </td><td align="center">Yes </td><td align="center">Optional </td></tr>
</table>
</center><p><a class="anchor" id="fig__TutorialsReconstructionFigComparisons"></a></p><div class="image">
<img src="compare_reconstructions.png" alt="compare_reconstructions.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_reconstruction.html#fig__TutorialsReconstructionFigComparisons">Figure 0.1</a> Comparison of reconstruction methods applied to the same input (full shape and close-up). From left to right: original point cloud; Poisson; advancing front; scale space.  </div> <br /> 
<p>More information on these different methods can be found on their respective manual pages and in Section <a class="el" href="tuto_reconstruction.html#TutorialsReconstruction_reconstruction">Reconstruction</a>.</p>
<h1><a class="anchor" id="TutorialsReconstruction_overview"></a>
Pipeline Overview</h1>
<p>This tutorial aims at providing a more comprehensive view of the possibilities offered by CGAL for dealing with point clouds, for surface reconstruction purposes. The following diagram shows an overview (not exhaustive) of common reconstruction steps using CGAL tools.</p>
<p><a class="anchor" id="fig__TutorialsReconstructionFigPipeline"></a></p><div class="image">
<object type="image/svg+xml" data="reconstruction.svg">reconstruction.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_reconstruction.html#fig__TutorialsReconstructionFigPipeline">Figure 0.2</a> Pipeline Overview  </div> <br /> 
<p>We now review some of these steps in more detail.</p>
<h1><a class="anchor" id="TutorialsReconstruction_input"></a>
Reading Input</h1>
<p>The reconstruction algorithms in CGAL take a range of iterators on a container as input and use property maps to access the points (and the normals when they are required). Points are typically stored in plain text format (denoted as 'XYZ' format) where each point is separated by a newline character and each coordinate separated by a white space. Other formats available are 'OFF', 'PLY' and 'LAS'. CGAL provides functions to read such formats:</p>
<ul>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/group__PkgPointSet3IOXYZ.html#gaa21dccecfcfb73b70fd47607dfe6cbc0">read_XYZ()</a></code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/group__PkgPolyhedronIOFunc.html#gaccd9d4d15af1376dbc166eb501f28980">read_OFF()</a></code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga3b898d61ab5682756b25c425a8d8ec97">read_PLY()</a></code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3IOPly.html#gad9785e7191ba94d81fac841798aa1ddb">read_PLY_with_properties()</a></code> to read additional PLY properties</li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/group__PkgPointSet3IOLAS.html#ga87dc5f0f0d96c5a75286f5996e414aaf">read_LAS()</a></code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3IOLas.html#ga5187fc18430a5e3c811f75da57a057ad">read_LAS_with_properties()</a></code> to read additional LAS properties</li>
</ul>
<p>CGAL also provides a dedicated container <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3</a></code> to handle point sets with additional properties such as normal vectors. In this case, property maps are easily handled as shown in the following sections. This structure also handles the stream operator to read point sets in any of the formats previously described. Using this method yields substantially shorter code, as can be seen on the following example:</p>
<div class="fragment"><div class="line"></div><div class="line">  Point_set points;</div><div class="line"></div><div class="line">  std::string fname = argc==1?<a class="code" href="namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/kitten.xyz"</span>) : argv[1];</div><div class="line">  <span class="keywordflow">if</span> (argc &lt; 2)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Usage: "</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">" [input.xyz/off/ply/las]"</span> &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt;<span class="stringliteral">"Running "</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">" data/kitten.xyz -1\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::ifstream stream (fname, std::ios_base::binary);</div><div class="line">  <span class="keywordflow">if</span> (!stream)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  stream &gt;&gt; points;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Read "</span> &lt;&lt; points.size () &lt;&lt; <span class="stringliteral">" point(s)"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">if</span> (points.empty())</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line"></div></div><!-- fragment --> <h1><a class="anchor" id="TutorialsReconstruction_preprocessing"></a>
Preprocessing</h1>
<p>Because reconstruction algorithms have some specific requirements that point clouds do not always meet, some preprocessing might be necessary to yield the best results.</p>
<p>Note that this <em>preprocessing</em> step is optional: when the input point cloud has no imperfections, reconstruction can be applied to it without any preprocessing.</p>
<p><a class="anchor" id="fig__TutorialsReconstructionFigPreprocessing"></a></p><div class="image">
<img src="reconstruction_preproc.png" alt="reconstruction_preproc.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_reconstruction.html#fig__TutorialsReconstructionFigPreprocessing">Figure 0.3</a> Comparison of advancing front reconstruction output using different preprocessing on the same input. The smooth point cloud was generated using <em>jet smoothing</em>; the simplified point cloud was generated using <em>grid simplification</em>.  </div> <br /> 
<h2><a class="anchor" id="TutorialsReconstruction_preprocessing_outliers"></a>
Outlier removal</h2>
<p>Some acquisition techniques generate points which are far away from the surface. These points, commonly referred to as "outliers", have no relevance for reconstruction. Using the CGAL reconstruction algorithms on outlier-ridden point clouds produce overly distorted output, it is therefore strongly advised to filter these outliers <em>before</em> performing reconstruction.</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="keyword">typename</span> Point_set::iterator rout_it = CGAL::remove_outliers&lt;CGAL::Sequential_tag&gt;</div><div class="line">    (points,</div><div class="line">     24, <span class="comment">// Number of neighbors considered for evaluation</span></div><div class="line">     points.parameters().threshold_percent (5.0)); <span class="comment">// Percentage of points to remove</span></div><div class="line">  points.remove(rout_it, points.end());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; points.number_of_removed_points()</div><div class="line">            &lt;&lt; <span class="stringliteral">" point(s) are outliers."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Applying point set processing algorithm to a CGAL::Point_set_3</span></div><div class="line">  <span class="comment">// object does not erase the points from memory but place them in</span></div><div class="line">  <span class="comment">// the garbage of the object: memory can be freeed by the user.</span></div><div class="line">  points.collect_garbage();</div><div class="line"></div></div><!-- fragment --> <h2><a class="anchor" id="TutorialsReconstruction_preprocessing_simplification"></a>
Simplification</h2>
<p>Some laser scanners generate points with widely variable sampling. Typically, lines of scan are very densely sampled but the gap between two lines of scan is much larger, leading to an overly massive point cloud with large variations of sampling density. This type of input point cloud might generate imperfect output using algorithms which, in general, only handle small variations of sampling density.</p>
<p>CGAL provides several simplification algorithms. In addition to reducing the size of the input point cloud and therefore decreasing computation time, some of them can help making the input more uniform. This is the case of the function <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga7757ef9b3900e42fde26f5a0ac56e20f">grid_simplify_point_set()</a></code> which defines a grid of a user-specified size and keeps one point per occupied cell.</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="comment">// Compute average spacing using neighborhood of 6 points</span></div><div class="line">  <span class="keywordtype">double</span> spacing = CGAL::compute_average_spacing&lt;CGAL::Sequential_tag&gt; (points, 6);</div><div class="line"></div><div class="line">  <span class="comment">// Simplify using a grid of size 2 * average spacing</span></div><div class="line">  <span class="keyword">typename</span> Point_set::iterator gsim_it = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga7757ef9b3900e42fde26f5a0ac56e20f">CGAL::grid_simplify_point_set</a> (points, 2. * spacing);</div><div class="line">  points.remove(gsim_it, points.end());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; points.number_of_removed_points()</div><div class="line">            &lt;&lt; <span class="stringliteral">" point(s) removed after simplification."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  points.collect_garbage();</div><div class="line"></div></div><!-- fragment --><h2><a class="anchor" id="TutorialsReconstruction_preprocessing_smoothing"></a>
Smoothing</h2>
<p>Although reconstructions via 'Poisson' or 'Scale space' handle noise internally, one may want to get tighter control over the smoothing step. For example, a slightly noisy point cloud can benefit from some reliable smoothing algorithms and be reconstructed via 'Advancing front' which provides relevant properties (oriented mesh with boundaries).</p>
<p>Two functions are provided to smooth a noisy point cloud with a good approximation (i.e. without degrading curvature, for example):</p>
<ul>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga96a3738be3b2b9bd1587af78ae10e67a">jet_smooth_point_set()</a></code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga01192a227578fee0c5676ba6a5e88931">bilateral_smooth_point_set()</a></code></li>
</ul>
<p>These functions directly modify the container:</p>
<div class="fragment"><div class="line"></div><div class="line">  CGAL::jet_smooth_point_set&lt;CGAL::Sequential_tag&gt; (points, 24);</div><div class="line"></div></div><!-- fragment --><h2><a class="anchor" id="TutorialsReconstruction_preprocessing_normal"></a>
Normal Estimation and Orientation</h2>
<p><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Poisson_surface_reconstruction_3.tag:../Poisson_surface_reconstruction_3/" href="../Poisson_surface_reconstruction_3/index.html#Chapter_Poisson_Surface_Reconstruction">Poisson Surface Reconstruction</a> requires points with oriented normal vectors. To apply the algorithm to a raw point cloud, normals must be estimated first, for example with one of these two functions:</p>
<ul>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga721aeb7af4b2d31e08e75bc5d53303cf">pca_estimate_normals()</a></code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga078e25209373cab0e1f3524202489771">jet_estimate_normals()</a></code></li>
</ul>
<p>PCA is faster but jet is more accurate in the presence of high curvatures. These function only estimates the <em>direction</em> of the normals, not their orientation (the orientation of the vectors might not be locally consistent). To properly orient the normals, the following functions can be used:</p>
<ul>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga17c3c558c3799b65bd23fba971a82a5c">mst_orient_normals()</a></code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#gafc3627234666e1fb458e9387e9d5f3c6">scanline_orient_normals()</a></code></li>
</ul>
<p>The first one uses a <em>minimum spanning tree</em> to consistently propagate the orientation of normals in an increasingly large neighborhood. In the case of data with many sharp features and occlusions (which are common in airborne LIDAR data, for example), the second algorithm may produce better results: it takes advantage of point clouds which are ordered into scanlines to estimate the line of sight of each point and thus to orient normals accordingly.</p>
<p>Notice that these can also be used directly on input normals if their orientation is not consistent.</p>
<div class="fragment"><div class="line"></div><div class="line">    CGAL::jet_estimate_normals&lt;CGAL::Sequential_tag&gt;</div><div class="line">      (points, 24); <span class="comment">// Use 24 neighbors</span></div><div class="line"></div><div class="line">    <span class="comment">// Orientation of normals, returns iterator to first unoriented point</span></div><div class="line">    <span class="keyword">typename</span> Point_set::iterator unoriented_points_begin =</div><div class="line">      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga17c3c558c3799b65bd23fba971a82a5c">CGAL::mst_orient_normals</a>(points, 24); <span class="comment">// Use 24 neighbors</span></div><div class="line"></div><div class="line">    points.remove (unoriented_points_begin, points.end());</div><div class="line"></div></div><!-- fragment --> <h1><a class="anchor" id="TutorialsReconstruction_reconstruction"></a>
Reconstruction</h1>
<h2><a class="anchor" id="TutorialsReconstruction_reconstruction_poisson"></a>
Poisson</h2>
<p>Poisson reconstruction consists in computing an implicit function whose gradient matches the input normal vector field: this indicator function has opposite signs inside and outside of the inferred shape (hence the need for closed shapes). This method thus requires normals and produces smooth closed surfaces. It is not appropriate if the surface is expected to interpolate the input points. On the contrary, it performs well if the aim is to approximate a noisy point cloud with a smooth surface.</p>
<div class="fragment"><div class="line"></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point_3&gt;</a> output_mesh;</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Poisson_surface_reconstruction_3.tag:../Poisson_surface_reconstruction_3/" href="../Poisson_surface_reconstruction_3/group__PkgPoissonSurfaceReconstruction3Ref.html#ga2470854cf03552ecee02f11c17024ddf">CGAL::poisson_surface_reconstruction_delaunay</a></div><div class="line">      (points.begin(), points.end(),</div><div class="line">       points.point_map(), points.normal_map(),</div><div class="line">       output_mesh, spacing);</div><div class="line"></div></div><!-- fragment --> <h2><a class="anchor" id="TutorialsReconstruction_reconstruction_advancing"></a>
Advancing Front</h2>
<p>Advancing front is a Delaunay-based approach which interpolates a subset of the input points. It generates triples of point indices which describe the triangular facets of the reconstruction: it uses a priority queue to sequentially pick the Delaunay facet the most likely to be part of the surface, based on a size criterion (to favor the small facets) and an angle criterion (to favor smoothness). Its main virtue is to generate oriented manifold surfaces with boundaries: contrary to Poisson, it does not require normals and is not bound to reconstruct closed shapes. However, it requires preprocessing if the point cloud is noisy.</p>
<p>The <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Advancing_front_surface_reconstruction.tag:../Advancing_front_surface_reconstruction/" href="../Advancing_front_surface_reconstruction/index.html#Chapter_Advancing_Front_Surface_Reconstruction">Advancing Front</a> package provides several ways of constructing the function. Here is a simple example:</p>
<div class="fragment"><div class="line"></div><div class="line">    <span class="keyword">typedef</span> std::array&lt;std::size_t, 3&gt; Facet; <span class="comment">// Triple of indices</span></div><div class="line"></div><div class="line">    std::vector&lt;Facet&gt; facets;</div><div class="line"></div><div class="line">    <span class="comment">// The function is called using directly the points raw iterators</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Advancing_front_surface_reconstruction.tag:../Advancing_front_surface_reconstruction/" href="../Advancing_front_surface_reconstruction/group__PkgAdvancingFrontSurfaceReconstructionRef.html#gaa2b1f41291920247fd5c6ef7c09f70a4">CGAL::advancing_front_surface_reconstruction</a>(points.points().begin(),</div><div class="line">                                                 points.points().end(),</div><div class="line">                                                 std::back_inserter(facets));</div><div class="line">    std::cout &lt;&lt; facets.size ()</div><div class="line">              &lt;&lt; <span class="stringliteral">" facet(s) generated by reconstruction."</span> &lt;&lt; std::endl;</div><div class="line"></div></div><!-- fragment --> <h2><a class="anchor" id="TutorialsReconstruction_reconstruction_scale_space"></a>
Scale Space</h2>
<p>Scale space reconstruction aims at producing a surface which interpolates the input points (interpolant) while offering some robustness to noise. More specifically, it first applies several times a smoothing filter (such as Jet Smoothing) to the input point set to produce a scale space; then, the smoothest scale is meshed (using for example the Advancing Front mesher); finally, the resulting connectivity between smoothed points is propagated to the original raw input point set. This method is the right choice if the input point cloud is noisy but the user still wants the surface to pass exactly through the points.</p>
<div class="fragment"><div class="line"></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Scale_space_reconstruction_3.tag:../Scale_space_reconstruction_3/" href="../Scale_space_reconstruction_3/classCGAL_1_1Scale__space__surface__reconstruction__3.html">CGAL::Scale_space_surface_reconstruction_3&lt;Kernel&gt;</a> reconstruct</div><div class="line">      (points.points().begin(), points.points().end());</div><div class="line"></div><div class="line">    <span class="comment">// Smooth using 4 iterations of Jet Smoothing</span></div><div class="line">    reconstruct.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Scale_space_reconstruction_3.tag:../Scale_space_reconstruction_3/" href="../Scale_space_reconstruction_3/classCGAL_1_1Scale__space__surface__reconstruction__3.html#acf5262fc2bb55fe76d85f2e541a5b6ab">increase_scale</a> (4, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Scale_space_reconstruction_3.tag:../Scale_space_reconstruction_3/" href="../Scale_space_reconstruction_3/classCGAL_1_1Scale__space__reconstruction__3_1_1Jet__smoother.html">CGAL::Scale_space_reconstruction_3::Jet_smoother&lt;Kernel&gt;</a>());</div><div class="line">    <span class="comment">// Mesh with the Advancing Front mesher with a maximum facet length of 0.5</span></div><div class="line">    reconstruct.reconstruct_surface (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Scale_space_reconstruction_3.tag:../Scale_space_reconstruction_3/" href="../Scale_space_reconstruction_3/classCGAL_1_1Scale__space__reconstruction__3_1_1Advancing__front__mesher.html">CGAL::Scale_space_reconstruction_3::Advancing_front_mesher&lt;Kernel&gt;</a>(0.5));</div><div class="line"></div></div><!-- fragment --> <h1><a class="anchor" id="TutorialsReconstruction_postprocessing"></a>
Output and Postprocessing</h1>
<p>Each of these methods produce a triangle mesh stored in different ways. If this output mesh is hampered by defects such as holes or self-intersections, CGAL provide several algorithms to post-process it (hole filling, remeshing, etc.) in the package <a class="el" href="packages.html#PkgPolygonMeshProcessing">Polygon Mesh Processing</a>.</p>
<p>We do not discuss these functions here as there are many postprocessing possibilities whose relevance strongly depends on the user's expectations on the output mesh.</p>
<p>The mesh (postprocessed or not) can easily be saved in the PLY format (here, using the binary variant):</p>
<div class="fragment"><div class="line"></div><div class="line">    std::ofstream f (<span class="stringliteral">"out_poisson.ply"</span>, std::ios_base::binary);</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (f);</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a>(f, output_mesh);</div><div class="line">    f.close ();</div><div class="line"></div></div><!-- fragment --><p> A polygon soup can also be saved in the OFF format by iterating on the points and faces:</p>
<div class="fragment"><div class="line"></div><div class="line">    std::ofstream f (<span class="stringliteral">"out_sp.off"</span>);</div><div class="line">    f &lt;&lt; <span class="stringliteral">"OFF"</span> &lt;&lt; std::endl &lt;&lt; points.size () &lt;&lt; <span class="stringliteral">" "</span></div><div class="line">      &lt;&lt; reconstruct.number_of_facets() &lt;&lt; <span class="stringliteral">" 0"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">for</span> (Point_set::Index idx : points)</div><div class="line">      f &lt;&lt; points.point (idx) &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; facet : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL.html#a266177f3e138c748f9906f7abb76320b">CGAL::make_range</a> (reconstruct.facets_begin(), reconstruct.facets_end()))</div><div class="line">      f &lt;&lt; <span class="stringliteral">"3 "</span>&lt;&lt; facet &lt;&lt; std::endl;</div><div class="line">    f.close ();</div><div class="line"></div></div><!-- fragment --><p> Finally, if the polygon soup can be converted into a polygon mesh, it can also be saved directly in the OFF format using the stream operator:</p>
<div class="fragment"><div class="line"></div><div class="line">    <span class="comment">// copy points for random access</span></div><div class="line">    std::vector&lt;Point_3&gt; vertices;</div><div class="line">    vertices.reserve (points.size());</div><div class="line">    std::copy (points.points().begin(), points.points().end(), std::back_inserter (vertices));</div><div class="line"></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point_3&gt;</a> output_mesh;</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__repairing__grp.html#ga2ba9722ec8472a1455107ffce7145e46">CGAL::Polygon_mesh_processing::polygon_soup_to_polygon_mesh</a> (vertices, facets, output_mesh);</div><div class="line">    std::ofstream f (<span class="stringliteral">"out_af.off"</span>);</div><div class="line">    f &lt;&lt; output_mesh;</div><div class="line">    f.close ();</div><div class="line"></div></div><!-- fragment --> <h1><a class="anchor" id="TutorialsReconstruction_recap"></a>
Full Code Example</h1>
<p>All the code snippets used in this tutorial can be assembled to create a full algorithm pipeline (provided the correct <em>includes</em> are used). We give a full code example which achieves all the steps described in this tutorial. The reconstruction method can be selected by the user at runtime with the second argument.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3/IO.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/remove_outliers.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/grid_simplify_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/jet_smooth_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/jet_estimate_normals.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/mst_orient_normals.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/poisson_surface_reconstruction.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Advancing_front_surface_reconstruction.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Scale_space_surface_reconstruction_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Scale_space_reconstruction_3/Jet_smoother.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Scale_space_reconstruction_3/Advancing_front_mesher.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/polygon_soup_to_polygon_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point_3;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector_3;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Sphere__3.html">Kernel::Sphere_3</a> Sphere_3;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3&lt;Point_3, Vector_3&gt;</a> Point_set;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line"></div><div class="line">  Point_set points;</div><div class="line"></div><div class="line">  std::string fname = argc==1?<a class="code" href="namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/kitten.xyz"</span>) : argv[1];</div><div class="line">  <span class="keywordflow">if</span> (argc &lt; 2)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Usage: "</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">" [input.xyz/off/ply/las]"</span> &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt;<span class="stringliteral">"Running "</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">" data/kitten.xyz -1\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::ifstream stream (fname, std::ios_base::binary);</div><div class="line">  <span class="keywordflow">if</span> (!stream)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  stream &gt;&gt; points;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Read "</span> &lt;&lt; points.size () &lt;&lt; <span class="stringliteral">" point(s)"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">if</span> (points.empty())</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">typename</span> Point_set::iterator rout_it = CGAL::remove_outliers&lt;CGAL::Sequential_tag&gt;</div><div class="line">    (points,</div><div class="line">     24, <span class="comment">// Number of neighbors considered for evaluation</span></div><div class="line">     points.parameters().threshold_percent (5.0)); <span class="comment">// Percentage of points to remove</span></div><div class="line">  points.remove(rout_it, points.end());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; points.number_of_removed_points()</div><div class="line">            &lt;&lt; <span class="stringliteral">" point(s) are outliers."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Applying point set processing algorithm to a CGAL::Point_set_3</span></div><div class="line">  <span class="comment">// object does not erase the points from memory but place them in</span></div><div class="line">  <span class="comment">// the garbage of the object: memory can be freeed by the user.</span></div><div class="line">  points.collect_garbage();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Compute average spacing using neighborhood of 6 points</span></div><div class="line">  <span class="keywordtype">double</span> spacing = CGAL::compute_average_spacing&lt;CGAL::Sequential_tag&gt; (points, 6);</div><div class="line"></div><div class="line">  <span class="comment">// Simplify using a grid of size 2 * average spacing</span></div><div class="line">  <span class="keyword">typename</span> Point_set::iterator gsim_it = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga7757ef9b3900e42fde26f5a0ac56e20f">CGAL::grid_simplify_point_set</a> (points, 2. * spacing);</div><div class="line">  points.remove(gsim_it, points.end());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; points.number_of_removed_points()</div><div class="line">            &lt;&lt; <span class="stringliteral">" point(s) removed after simplification."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  points.collect_garbage();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  CGAL::jet_smooth_point_set&lt;CGAL::Sequential_tag&gt; (points, 24);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> reconstruction_choice</div><div class="line">    = argc==1? -1 : (argc &lt; 3 ? 0 : atoi(argv[2]));</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (reconstruction_choice == 0 || reconstruction_choice==-1) <span class="comment">// Poisson</span></div><div class="line">  {</div><div class="line"></div><div class="line">    CGAL::jet_estimate_normals&lt;CGAL::Sequential_tag&gt;</div><div class="line">      (points, 24); <span class="comment">// Use 24 neighbors</span></div><div class="line"></div><div class="line">    <span class="comment">// Orientation of normals, returns iterator to first unoriented point</span></div><div class="line">    <span class="keyword">typename</span> Point_set::iterator unoriented_points_begin =</div><div class="line">      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga17c3c558c3799b65bd23fba971a82a5c">CGAL::mst_orient_normals</a>(points, 24); <span class="comment">// Use 24 neighbors</span></div><div class="line"></div><div class="line">    points.remove (unoriented_points_begin, points.end());</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point_3&gt;</a> output_mesh;</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Poisson_surface_reconstruction_3.tag:../Poisson_surface_reconstruction_3/" href="../Poisson_surface_reconstruction_3/group__PkgPoissonSurfaceReconstruction3Ref.html#ga2470854cf03552ecee02f11c17024ddf">CGAL::poisson_surface_reconstruction_delaunay</a></div><div class="line">      (points.begin(), points.end(),</div><div class="line">       points.point_map(), points.normal_map(),</div><div class="line">       output_mesh, spacing);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    std::ofstream f (<span class="stringliteral">"out_poisson.ply"</span>, std::ios_base::binary);</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (f);</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a>(f, output_mesh);</div><div class="line">    f.close ();</div><div class="line"></div><div class="line">  }</div><div class="line">  <span class="keywordflow">if</span> (reconstruction_choice == 1 || reconstruction_choice==-1) <span class="comment">// Advancing front</span></div><div class="line">  {</div><div class="line"></div><div class="line">    <span class="keyword">typedef</span> std::array&lt;std::size_t, 3&gt; Facet; <span class="comment">// Triple of indices</span></div><div class="line"></div><div class="line">    std::vector&lt;Facet&gt; facets;</div><div class="line"></div><div class="line">    <span class="comment">// The function is called using directly the points raw iterators</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Advancing_front_surface_reconstruction.tag:../Advancing_front_surface_reconstruction/" href="../Advancing_front_surface_reconstruction/group__PkgAdvancingFrontSurfaceReconstructionRef.html#gaa2b1f41291920247fd5c6ef7c09f70a4">CGAL::advancing_front_surface_reconstruction</a>(points.points().begin(),</div><div class="line">                                                 points.points().end(),</div><div class="line">                                                 std::back_inserter(facets));</div><div class="line">    std::cout &lt;&lt; facets.size ()</div><div class="line">              &lt;&lt; <span class="stringliteral">" facet(s) generated by reconstruction."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// copy points for random access</span></div><div class="line">    std::vector&lt;Point_3&gt; vertices;</div><div class="line">    vertices.reserve (points.size());</div><div class="line">    std::copy (points.points().begin(), points.points().end(), std::back_inserter (vertices));</div><div class="line"></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point_3&gt;</a> output_mesh;</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__repairing__grp.html#ga2ba9722ec8472a1455107ffce7145e46">CGAL::Polygon_mesh_processing::polygon_soup_to_polygon_mesh</a> (vertices, facets, output_mesh);</div><div class="line">    std::ofstream f (<span class="stringliteral">"out_af.off"</span>);</div><div class="line">    f &lt;&lt; output_mesh;</div><div class="line">    f.close ();</div><div class="line"></div><div class="line">  }</div><div class="line">  <span class="keywordflow">if</span> (reconstruction_choice == 2 || reconstruction_choice==-1) <span class="comment">// Scale space</span></div><div class="line">  {</div><div class="line"></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Scale_space_reconstruction_3.tag:../Scale_space_reconstruction_3/" href="../Scale_space_reconstruction_3/classCGAL_1_1Scale__space__surface__reconstruction__3.html">CGAL::Scale_space_surface_reconstruction_3&lt;Kernel&gt;</a> reconstruct</div><div class="line">      (points.points().begin(), points.points().end());</div><div class="line"></div><div class="line">    <span class="comment">// Smooth using 4 iterations of Jet Smoothing</span></div><div class="line">    reconstruct.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Scale_space_reconstruction_3.tag:../Scale_space_reconstruction_3/" href="../Scale_space_reconstruction_3/classCGAL_1_1Scale__space__surface__reconstruction__3.html#acf5262fc2bb55fe76d85f2e541a5b6ab">increase_scale</a> (4, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Scale_space_reconstruction_3.tag:../Scale_space_reconstruction_3/" href="../Scale_space_reconstruction_3/classCGAL_1_1Scale__space__reconstruction__3_1_1Jet__smoother.html">CGAL::Scale_space_reconstruction_3::Jet_smoother&lt;Kernel&gt;</a>());</div><div class="line">    <span class="comment">// Mesh with the Advancing Front mesher with a maximum facet length of 0.5</span></div><div class="line">    reconstruct.reconstruct_surface (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Scale_space_reconstruction_3.tag:../Scale_space_reconstruction_3/" href="../Scale_space_reconstruction_3/classCGAL_1_1Scale__space__reconstruction__3_1_1Advancing__front__mesher.html">CGAL::Scale_space_reconstruction_3::Advancing_front_mesher&lt;Kernel&gt;</a>(0.5));</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    std::ofstream f (<span class="stringliteral">"out_sp.off"</span>);</div><div class="line">    f &lt;&lt; <span class="stringliteral">"OFF"</span> &lt;&lt; std::endl &lt;&lt; points.size () &lt;&lt; <span class="stringliteral">" "</span></div><div class="line">      &lt;&lt; reconstruct.number_of_facets() &lt;&lt; <span class="stringliteral">" 0"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">for</span> (Point_set::Index idx : points)</div><div class="line">      f &lt;&lt; points.point (idx) &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; facet : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL.html#a266177f3e138c748f9906f7abb76320b">CGAL::make_range</a> (reconstruct.facets_begin(), reconstruct.facets_end()))</div><div class="line">      f &lt;&lt; <span class="stringliteral">"3 "</span>&lt;&lt; facet &lt;&lt; std::endl;</div><div class="line">    f.close ();</div><div class="line"></div><div class="line">  }</div><div class="line">  <span class="keywordflow">else</span> <span class="comment">// Handle error</span></div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: invalid reconstruction id: "</span> &lt;&lt; reconstruction_choice &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="TutorialsReconstruction_pipeline"></a>
Full Pipeline Images</h1>
<p>The following figure an example of a full reconstruction pipeline applied to a bear statue (courtesy <em>EPFL Computer Graphics and Geometry Laboratory</em> <a class="el" href="citelist.html#CITEREF_cgal:e-esmr">[5]</a>). Two mesh processing algorithms (hole filling and isotropic remeshing) are also applied (refer to the chapter <a class="el" href="packages.html#PkgPolygonMeshProcessing">Polygon Mesh Processing</a> for more information).</p>
<p><a class="anchor" id="fig__TutorialsReconstructionFigFull"></a></p><div class="image">
<img src="reconstruction_pipeline.png" alt="reconstruction_pipeline.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_reconstruction.html#fig__TutorialsReconstructionFigFull">Figure 0.4</a> Full reconstruction pipeline (with close-ups).  </div> <br />  
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Aug 9 2022 14:27:18 for CGAL 5.6 - Manual by
    <a href="https://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>
</html><html xmlns="http://www.w3.org/1999/xhtml"><body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
          <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
          <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt="" /></a>
          </span>
        </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.6 - Manual
   </div>
  </td>
  <!-- We disable the search box because we have added it in the
  back-nav for stylistic reasons. -->
  <!-- <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td> -->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tuto_reconstruction.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Surface Reconstruction from Point Clouds </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> </p><div id="autotoc" class="toc"></div> 
<dl class="section author"><dt>Author</dt><dd>Simon Giraudot</dd></dl>
<p>Surface reconstruction from point clouds is a core topic in geometry processing <a class="el" href="citelist.html#CITEREF_cgal:btsag-asosr-16">[3]</a>. It is an ill-posed problem: there is an infinite number of surfaces that approximate a single point cloud and a point cloud does not define a surface in itself. Thus additional assumptions and constraints must be defined by the user and reconstruction can be achieved in many different ways. This tutorial provides guidance on how to use the different algorithms of CGAL to effectively perform surface reconstruction.</p>
<h1><a class="anchor" id="TutorialsReconstruction_algorithms"></a>
Which algorithm should I use?</h1>
<p>CGAL offers three different algorithms for surface reconstruction:</p>
<ul>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Poisson_surface_reconstruction_3.tag:../Poisson_surface_reconstruction_3/" href="../Poisson_surface_reconstruction_3/index.html#Chapter_Poisson_Surface_Reconstruction">Poisson Surface Reconstruction</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Advancing_front_surface_reconstruction.tag:../Advancing_front_surface_reconstruction/" href="../Advancing_front_surface_reconstruction/index.html#Chapter_Advancing_Front_Surface_Reconstruction">Advancing Front Surface Reconstruction</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Scale_space_reconstruction_3.tag:../Scale_space_reconstruction_3/" href="../Scale_space_reconstruction_3/index.html#Chapter_Scale_space_reconstruction">Scale Space Surface Reconstruction</a></li>
</ul>
<p>Because reconstruction is an ill-posed problem, it must be regularized via prior knowledge. Differences in prior lead to different algorithms, and choosing one or the other of these methods is dependent on these priors. For example, Poisson always generates closed shapes (bounding a volume) and requires normals but does not interpolate input points (the output surface does not pass exactly through the input points). The following table lists different properties of the input and output to help the user choose the method best suited to each problem:</p>
<center> <table class="doxtable">
<tr>
<th></th><th align="center">Poisson </th><th align="center">Advancing front </th><th align="center">Scale space  </th></tr>
<tr>
<td>Are normals required? </td><td align="center">Yes </td><td align="center">No </td><td align="center">No </td></tr>
<tr>
<td>Is noise handled? </td><td align="center">Yes </td><td align="center">By preprocessing </td><td align="center">Yes </td></tr>
<tr>
<td>Is variable sampling handled? </td><td align="center">Yes </td><td align="center">Yes </td><td align="center">By preprocessing </td></tr>
<tr>
<td>Are input points exactly on the surface? </td><td align="center">No </td><td align="center">Yes </td><td align="center">Yes </td></tr>
<tr>
<td>Is the output always closed? </td><td align="center">Yes </td><td align="center">No </td><td align="center">No </td></tr>
<tr>
<td>Is the output always smooth? </td><td align="center">Yes </td><td align="center">No </td><td align="center">No </td></tr>
<tr>
<td>Is the output always manifold? </td><td align="center">Yes </td><td align="center">Yes </td><td align="center">Optional </td></tr>
<tr>
<td>Is the output always orientable? </td><td align="center">Yes </td><td align="center">Yes </td><td align="center">Optional </td></tr>
</table>
</center><p><a class="anchor" id="fig__TutorialsReconstructionFigComparisons"></a></p><div class="image">
<img src="compare_reconstructions.png" alt="compare_reconstructions.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_reconstruction.html#fig__TutorialsReconstructionFigComparisons">Figure 0.1</a> Comparison of reconstruction methods applied to the same input (full shape and close-up). From left to right: original point cloud; Poisson; advancing front; scale space.  </div> <br /> 
<p>More information on these different methods can be found on their respective manual pages and in Section <a class="el" href="tuto_reconstruction.html#TutorialsReconstruction_reconstruction">Reconstruction</a>.</p>
<h1><a class="anchor" id="TutorialsReconstruction_overview"></a>
Pipeline Overview</h1>
<p>This tutorial aims at providing a more comprehensive view of the possibilities offered by CGAL for dealing with point clouds, for surface reconstruction purposes. The following diagram shows an overview (not exhaustive) of common reconstruction steps using CGAL tools.</p>
<p><a class="anchor" id="fig__TutorialsReconstructionFigPipeline"></a></p><div class="image">
<object type="image/svg+xml" data="reconstruction.svg">reconstruction.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_reconstruction.html#fig__TutorialsReconstructionFigPipeline">Figure 0.2</a> Pipeline Overview  </div> <br /> 
<p>We now review some of these steps in more detail.</p>
<h1><a class="anchor" id="TutorialsReconstruction_input"></a>
Reading Input</h1>
<p>The reconstruction algorithms in CGAL take a range of iterators on a container as input and use property maps to access the points (and the normals when they are required). Points are typically stored in plain text format (denoted as 'XYZ' format) where each point is separated by a newline character and each coordinate separated by a white space. Other formats available are 'OFF', 'PLY' and 'LAS'. CGAL provides functions to read such formats:</p>
<ul>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/group__PkgPointSet3IOXYZ.html#gaa21dccecfcfb73b70fd47607dfe6cbc0">read_XYZ()</a></code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/group__PkgPolyhedronIOFunc.html#gaccd9d4d15af1376dbc166eb501f28980">read_OFF()</a></code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga3b898d61ab5682756b25c425a8d8ec97">read_PLY()</a></code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3IOPly.html#gad9785e7191ba94d81fac841798aa1ddb">read_PLY_with_properties()</a></code> to read additional PLY properties</li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/group__PkgPointSet3IOLAS.html#ga87dc5f0f0d96c5a75286f5996e414aaf">read_LAS()</a></code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3IOLas.html#ga5187fc18430a5e3c811f75da57a057ad">read_LAS_with_properties()</a></code> to read additional LAS properties</li>
</ul>
<p>CGAL also provides a dedicated container <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3</a></code> to handle point sets with additional properties such as normal vectors. In this case, property maps are easily handled as shown in the following sections. This structure also handles the stream operator to read point sets in any of the formats previously described. Using this method yields substantially shorter code, as can be seen on the following example:</p>
<div class="fragment"><div class="line"></div><div class="line">  Point_set points;</div><div class="line"></div><div class="line">  std::string fname = argc==1?<a class="code" href="namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/kitten.xyz"</span>) : argv[1];</div><div class="line">  <span class="keywordflow">if</span> (argc &lt; 2)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Usage: "</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">" [input.xyz/off/ply/las]"</span> &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt;<span class="stringliteral">"Running "</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">" data/kitten.xyz -1\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::ifstream stream (fname, std::ios_base::binary);</div><div class="line">  <span class="keywordflow">if</span> (!stream)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  stream &gt;&gt; points;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Read "</span> &lt;&lt; points.size () &lt;&lt; <span class="stringliteral">" point(s)"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">if</span> (points.empty())</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line"></div></div><!-- fragment --> <h1><a class="anchor" id="TutorialsReconstruction_preprocessing"></a>
Preprocessing</h1>
<p>Because reconstruction algorithms have some specific requirements that point clouds do not always meet, some preprocessing might be necessary to yield the best results.</p>
<p>Note that this <em>preprocessing</em> step is optional: when the input point cloud has no imperfections, reconstruction can be applied to it without any preprocessing.</p>
<p><a class="anchor" id="fig__TutorialsReconstructionFigPreprocessing"></a></p><div class="image">
<img src="reconstruction_preproc.png" alt="reconstruction_preproc.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_reconstruction.html#fig__TutorialsReconstructionFigPreprocessing">Figure 0.3</a> Comparison of advancing front reconstruction output using different preprocessing on the same input. The smooth point cloud was generated using <em>jet smoothing</em>; the simplified point cloud was generated using <em>grid simplification</em>.  </div> <br /> 
<h2><a class="anchor" id="TutorialsReconstruction_preprocessing_outliers"></a>
Outlier removal</h2>
<p>Some acquisition techniques generate points which are far away from the surface. These points, commonly referred to as "outliers", have no relevance for reconstruction. Using the CGAL reconstruction algorithms on outlier-ridden point clouds produce overly distorted output, it is therefore strongly advised to filter these outliers <em>before</em> performing reconstruction.</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="keyword">typename</span> Point_set::iterator rout_it = CGAL::remove_outliers&lt;CGAL::Sequential_tag&gt;</div><div class="line">    (points,</div><div class="line">     24, <span class="comment">// Number of neighbors considered for evaluation</span></div><div class="line">     points.parameters().threshold_percent (5.0)); <span class="comment">// Percentage of points to remove</span></div><div class="line">  points.remove(rout_it, points.end());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; points.number_of_removed_points()</div><div class="line">            &lt;&lt; <span class="stringliteral">" point(s) are outliers."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Applying point set processing algorithm to a CGAL::Point_set_3</span></div><div class="line">  <span class="comment">// object does not erase the points from memory but place them in</span></div><div class="line">  <span class="comment">// the garbage of the object: memory can be freeed by the user.</span></div><div class="line">  points.collect_garbage();</div><div class="line"></div></div><!-- fragment --> <h2><a class="anchor" id="TutorialsReconstruction_preprocessing_simplification"></a>
Simplification</h2>
<p>Some laser scanners generate points with widely variable sampling. Typically, lines of scan are very densely sampled but the gap between two lines of scan is much larger, leading to an overly massive point cloud with large variations of sampling density. This type of input point cloud might generate imperfect output using algorithms which, in general, only handle small variations of sampling density.</p>
<p>CGAL provides several simplification algorithms. In addition to reducing the size of the input point cloud and therefore decreasing computation time, some of them can help making the input more uniform. This is the case of the function <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga7757ef9b3900e42fde26f5a0ac56e20f">grid_simplify_point_set()</a></code> which defines a grid of a user-specified size and keeps one point per occupied cell.</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="comment">// Compute average spacing using neighborhood of 6 points</span></div><div class="line">  <span class="keywordtype">double</span> spacing = CGAL::compute_average_spacing&lt;CGAL::Sequential_tag&gt; (points, 6);</div><div class="line"></div><div class="line">  <span class="comment">// Simplify using a grid of size 2 * average spacing</span></div><div class="line">  <span class="keyword">typename</span> Point_set::iterator gsim_it = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga7757ef9b3900e42fde26f5a0ac56e20f">CGAL::grid_simplify_point_set</a> (points, 2. * spacing);</div><div class="line">  points.remove(gsim_it, points.end());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; points.number_of_removed_points()</div><div class="line">            &lt;&lt; <span class="stringliteral">" point(s) removed after simplification."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  points.collect_garbage();</div><div class="line"></div></div><!-- fragment --><h2><a class="anchor" id="TutorialsReconstruction_preprocessing_smoothing"></a>
Smoothing</h2>
<p>Although reconstructions via 'Poisson' or 'Scale space' handle noise internally, one may want to get tighter control over the smoothing step. For example, a slightly noisy point cloud can benefit from some reliable smoothing algorithms and be reconstructed via 'Advancing front' which provides relevant properties (oriented mesh with boundaries).</p>
<p>Two functions are provided to smooth a noisy point cloud with a good approximation (i.e. without degrading curvature, for example):</p>
<ul>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga96a3738be3b2b9bd1587af78ae10e67a">jet_smooth_point_set()</a></code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga01192a227578fee0c5676ba6a5e88931">bilateral_smooth_point_set()</a></code></li>
</ul>
<p>These functions directly modify the container:</p>
<div class="fragment"><div class="line"></div><div class="line">  CGAL::jet_smooth_point_set&lt;CGAL::Sequential_tag&gt; (points, 24);</div><div class="line"></div></div><!-- fragment --><h2><a class="anchor" id="TutorialsReconstruction_preprocessing_normal"></a>
Normal Estimation and Orientation</h2>
<p><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Poisson_surface_reconstruction_3.tag:../Poisson_surface_reconstruction_3/" href="../Poisson_surface_reconstruction_3/index.html#Chapter_Poisson_Surface_Reconstruction">Poisson Surface Reconstruction</a> requires points with oriented normal vectors. To apply the algorithm to a raw point cloud, normals must be estimated first, for example with one of these two functions:</p>
<ul>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga721aeb7af4b2d31e08e75bc5d53303cf">pca_estimate_normals()</a></code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga078e25209373cab0e1f3524202489771">jet_estimate_normals()</a></code></li>
</ul>
<p>PCA is faster but jet is more accurate in the presence of high curvatures. These function only estimates the <em>direction</em> of the normals, not their orientation (the orientation of the vectors might not be locally consistent). To properly orient the normals, the following functions can be used:</p>
<ul>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga17c3c558c3799b65bd23fba971a82a5c">mst_orient_normals()</a></code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#gafc3627234666e1fb458e9387e9d5f3c6">scanline_orient_normals()</a></code></li>
</ul>
<p>The first one uses a <em>minimum spanning tree</em> to consistently propagate the orientation of normals in an increasingly large neighborhood. In the case of data with many sharp features and occlusions (which are common in airborne LIDAR data, for example), the second algorithm may produce better results: it takes advantage of point clouds which are ordered into scanlines to estimate the line of sight of each point and thus to orient normals accordingly.</p>
<p>Notice that these can also be used directly on input normals if their orientation is not consistent.</p>
<div class="fragment"><div class="line"></div><div class="line">    CGAL::jet_estimate_normals&lt;CGAL::Sequential_tag&gt;</div><div class="line">      (points, 24); <span class="comment">// Use 24 neighbors</span></div><div class="line"></div><div class="line">    <span class="comment">// Orientation of normals, returns iterator to first unoriented point</span></div><div class="line">    <span class="keyword">typename</span> Point_set::iterator unoriented_points_begin =</div><div class="line">      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga17c3c558c3799b65bd23fba971a82a5c">CGAL::mst_orient_normals</a>(points, 24); <span class="comment">// Use 24 neighbors</span></div><div class="line"></div><div class="line">    points.remove (unoriented_points_begin, points.end());</div><div class="line"></div></div><!-- fragment --> <h1><a class="anchor" id="TutorialsReconstruction_reconstruction"></a>
Reconstruction</h1>
<h2><a class="anchor" id="TutorialsReconstruction_reconstruction_poisson"></a>
Poisson</h2>
<p>Poisson reconstruction consists in computing an implicit function whose gradient matches the input normal vector field: this indicator function has opposite signs inside and outside of the inferred shape (hence the need for closed shapes). This method thus requires normals and produces smooth closed surfaces. It is not appropriate if the surface is expected to interpolate the input points. On the contrary, it performs well if the aim is to approximate a noisy point cloud with a smooth surface.</p>
<div class="fragment"><div class="line"></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point_3&gt;</a> output_mesh;</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Poisson_surface_reconstruction_3.tag:../Poisson_surface_reconstruction_3/" href="../Poisson_surface_reconstruction_3/group__PkgPoissonSurfaceReconstruction3Ref.html#ga2470854cf03552ecee02f11c17024ddf">CGAL::poisson_surface_reconstruction_delaunay</a></div><div class="line">      (points.begin(), points.end(),</div><div class="line">       points.point_map(), points.normal_map(),</div><div class="line">       output_mesh, spacing);</div><div class="line"></div></div><!-- fragment --> <h2><a class="anchor" id="TutorialsReconstruction_reconstruction_advancing"></a>
Advancing Front</h2>
<p>Advancing front is a Delaunay-based approach which interpolates a subset of the input points. It generates triples of point indices which describe the triangular facets of the reconstruction: it uses a priority queue to sequentially pick the Delaunay facet the most likely to be part of the surface, based on a size criterion (to favor the small facets) and an angle criterion (to favor smoothness). Its main virtue is to generate oriented manifold surfaces with boundaries: contrary to Poisson, it does not require normals and is not bound to reconstruct closed shapes. However, it requires preprocessing if the point cloud is noisy.</p>
<p>The <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Advancing_front_surface_reconstruction.tag:../Advancing_front_surface_reconstruction/" href="../Advancing_front_surface_reconstruction/index.html#Chapter_Advancing_Front_Surface_Reconstruction">Advancing Front</a> package provides several ways of constructing the function. Here is a simple example:</p>
<div class="fragment"><div class="line"></div><div class="line">    <span class="keyword">typedef</span> std::array&lt;std::size_t, 3&gt; Facet; <span class="comment">// Triple of indices</span></div><div class="line"></div><div class="line">    std::vector&lt;Facet&gt; facets;</div><div class="line"></div><div class="line">    <span class="comment">// The function is called using directly the points raw iterators</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Advancing_front_surface_reconstruction.tag:../Advancing_front_surface_reconstruction/" href="../Advancing_front_surface_reconstruction/group__PkgAdvancingFrontSurfaceReconstructionRef.html#gaa2b1f41291920247fd5c6ef7c09f70a4">CGAL::advancing_front_surface_reconstruction</a>(points.points().begin(),</div><div class="line">                                                 points.points().end(),</div><div class="line">                                                 std::back_inserter(facets));</div><div class="line">    std::cout &lt;&lt; facets.size ()</div><div class="line">              &lt;&lt; <span class="stringliteral">" facet(s) generated by reconstruction."</span> &lt;&lt; std::endl;</div><div class="line"></div></div><!-- fragment --> <h2><a class="anchor" id="TutorialsReconstruction_reconstruction_scale_space"></a>
Scale Space</h2>
<p>Scale space reconstruction aims at producing a surface which interpolates the input points (interpolant) while offering some robustness to noise. More specifically, it first applies several times a smoothing filter (such as Jet Smoothing) to the input point set to produce a scale space; then, the smoothest scale is meshed (using for example the Advancing Front mesher); finally, the resulting connectivity between smoothed points is propagated to the original raw input point set. This method is the right choice if the input point cloud is noisy but the user still wants the surface to pass exactly through the points.</p>
<div class="fragment"><div class="line"></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Scale_space_reconstruction_3.tag:../Scale_space_reconstruction_3/" href="../Scale_space_reconstruction_3/classCGAL_1_1Scale__space__surface__reconstruction__3.html">CGAL::Scale_space_surface_reconstruction_3&lt;Kernel&gt;</a> reconstruct</div><div class="line">      (points.points().begin(), points.points().end());</div><div class="line"></div><div class="line">    <span class="comment">// Smooth using 4 iterations of Jet Smoothing</span></div><div class="line">    reconstruct.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Scale_space_reconstruction_3.tag:../Scale_space_reconstruction_3/" href="../Scale_space_reconstruction_3/classCGAL_1_1Scale__space__surface__reconstruction__3.html#acf5262fc2bb55fe76d85f2e541a5b6ab">increase_scale</a> (4, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Scale_space_reconstruction_3.tag:../Scale_space_reconstruction_3/" href="../Scale_space_reconstruction_3/classCGAL_1_1Scale__space__reconstruction__3_1_1Jet__smoother.html">CGAL::Scale_space_reconstruction_3::Jet_smoother&lt;Kernel&gt;</a>());</div><div class="line">    <span class="comment">// Mesh with the Advancing Front mesher with a maximum facet length of 0.5</span></div><div class="line">    reconstruct.reconstruct_surface (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Scale_space_reconstruction_3.tag:../Scale_space_reconstruction_3/" href="../Scale_space_reconstruction_3/classCGAL_1_1Scale__space__reconstruction__3_1_1Advancing__front__mesher.html">CGAL::Scale_space_reconstruction_3::Advancing_front_mesher&lt;Kernel&gt;</a>(0.5));</div><div class="line"></div></div><!-- fragment --> <h1><a class="anchor" id="TutorialsReconstruction_postprocessing"></a>
Output and Postprocessing</h1>
<p>Each of these methods produce a triangle mesh stored in different ways. If this output mesh is hampered by defects such as holes or self-intersections, CGAL provide several algorithms to post-process it (hole filling, remeshing, etc.) in the package <a class="el" href="packages.html#PkgPolygonMeshProcessing">Polygon Mesh Processing</a>.</p>
<p>We do not discuss these functions here as there are many postprocessing possibilities whose relevance strongly depends on the user's expectations on the output mesh.</p>
<p>The mesh (postprocessed or not) can easily be saved in the PLY format (here, using the binary variant):</p>
<div class="fragment"><div class="line"></div><div class="line">    std::ofstream f (<span class="stringliteral">"out_poisson.ply"</span>, std::ios_base::binary);</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (f);</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a>(f, output_mesh);</div><div class="line">    f.close ();</div><div class="line"></div></div><!-- fragment --><p> A polygon soup can also be saved in the OFF format by iterating on the points and faces:</p>
<div class="fragment"><div class="line"></div><div class="line">    std::ofstream f (<span class="stringliteral">"out_sp.off"</span>);</div><div class="line">    f &lt;&lt; <span class="stringliteral">"OFF"</span> &lt;&lt; std::endl &lt;&lt; points.size () &lt;&lt; <span class="stringliteral">" "</span></div><div class="line">      &lt;&lt; reconstruct.number_of_facets() &lt;&lt; <span class="stringliteral">" 0"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">for</span> (Point_set::Index idx : points)</div><div class="line">      f &lt;&lt; points.point (idx) &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; facet : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL.html#a266177f3e138c748f9906f7abb76320b">CGAL::make_range</a> (reconstruct.facets_begin(), reconstruct.facets_end()))</div><div class="line">      f &lt;&lt; <span class="stringliteral">"3 "</span>&lt;&lt; facet &lt;&lt; std::endl;</div><div class="line">    f.close ();</div><div class="line"></div></div><!-- fragment --><p> Finally, if the polygon soup can be converted into a polygon mesh, it can also be saved directly in the OFF format using the stream operator:</p>
<div class="fragment"><div class="line"></div><div class="line">    <span class="comment">// copy points for random access</span></div><div class="line">    std::vector&lt;Point_3&gt; vertices;</div><div class="line">    vertices.reserve (points.size());</div><div class="line">    std::copy (points.points().begin(), points.points().end(), std::back_inserter (vertices));</div><div class="line"></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point_3&gt;</a> output_mesh;</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__repairing__grp.html#ga2ba9722ec8472a1455107ffce7145e46">CGAL::Polygon_mesh_processing::polygon_soup_to_polygon_mesh</a> (vertices, facets, output_mesh);</div><div class="line">    std::ofstream f (<span class="stringliteral">"out_af.off"</span>);</div><div class="line">    f &lt;&lt; output_mesh;</div><div class="line">    f.close ();</div><div class="line"></div></div><!-- fragment --> <h1><a class="anchor" id="TutorialsReconstruction_recap"></a>
Full Code Example</h1>
<p>All the code snippets used in this tutorial can be assembled to create a full algorithm pipeline (provided the correct <em>includes</em> are used). We give a full code example which achieves all the steps described in this tutorial. The reconstruction method can be selected by the user at runtime with the second argument.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3/IO.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/remove_outliers.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/grid_simplify_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/jet_smooth_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/jet_estimate_normals.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/mst_orient_normals.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/poisson_surface_reconstruction.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Advancing_front_surface_reconstruction.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Scale_space_surface_reconstruction_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Scale_space_reconstruction_3/Jet_smoother.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Scale_space_reconstruction_3/Advancing_front_mesher.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/polygon_soup_to_polygon_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point_3;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector_3;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Sphere__3.html">Kernel::Sphere_3</a> Sphere_3;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3&lt;Point_3, Vector_3&gt;</a> Point_set;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line"></div><div class="line">  Point_set points;</div><div class="line"></div><div class="line">  std::string fname = argc==1?<a class="code" href="namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/kitten.xyz"</span>) : argv[1];</div><div class="line">  <span class="keywordflow">if</span> (argc &lt; 2)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Usage: "</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">" [input.xyz/off/ply/las]"</span> &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt;<span class="stringliteral">"Running "</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">" data/kitten.xyz -1\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::ifstream stream (fname, std::ios_base::binary);</div><div class="line">  <span class="keywordflow">if</span> (!stream)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  stream &gt;&gt; points;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Read "</span> &lt;&lt; points.size () &lt;&lt; <span class="stringliteral">" point(s)"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">if</span> (points.empty())</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">typename</span> Point_set::iterator rout_it = CGAL::remove_outliers&lt;CGAL::Sequential_tag&gt;</div><div class="line">    (points,</div><div class="line">     24, <span class="comment">// Number of neighbors considered for evaluation</span></div><div class="line">     points.parameters().threshold_percent (5.0)); <span class="comment">// Percentage of points to remove</span></div><div class="line">  points.remove(rout_it, points.end());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; points.number_of_removed_points()</div><div class="line">            &lt;&lt; <span class="stringliteral">" point(s) are outliers."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Applying point set processing algorithm to a CGAL::Point_set_3</span></div><div class="line">  <span class="comment">// object does not erase the points from memory but place them in</span></div><div class="line">  <span class="comment">// the garbage of the object: memory can be freeed by the user.</span></div><div class="line">  points.collect_garbage();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Compute average spacing using neighborhood of 6 points</span></div><div class="line">  <span class="keywordtype">double</span> spacing = CGAL::compute_average_spacing&lt;CGAL::Sequential_tag&gt; (points, 6);</div><div class="line"></div><div class="line">  <span class="comment">// Simplify using a grid of size 2 * average spacing</span></div><div class="line">  <span class="keyword">typename</span> Point_set::iterator gsim_it = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga7757ef9b3900e42fde26f5a0ac56e20f">CGAL::grid_simplify_point_set</a> (points, 2. * spacing);</div><div class="line">  points.remove(gsim_it, points.end());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; points.number_of_removed_points()</div><div class="line">            &lt;&lt; <span class="stringliteral">" point(s) removed after simplification."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  points.collect_garbage();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  CGAL::jet_smooth_point_set&lt;CGAL::Sequential_tag&gt; (points, 24);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> reconstruction_choice</div><div class="line">    = argc==1? -1 : (argc &lt; 3 ? 0 : atoi(argv[2]));</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (reconstruction_choice == 0 || reconstruction_choice==-1) <span class="comment">// Poisson</span></div><div class="line">  {</div><div class="line"></div><div class="line">    CGAL::jet_estimate_normals&lt;CGAL::Sequential_tag&gt;</div><div class="line">      (points, 24); <span class="comment">// Use 24 neighbors</span></div><div class="line"></div><div class="line">    <span class="comment">// Orientation of normals, returns iterator to first unoriented point</span></div><div class="line">    <span class="keyword">typename</span> Point_set::iterator unoriented_points_begin =</div><div class="line">      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga17c3c558c3799b65bd23fba971a82a5c">CGAL::mst_orient_normals</a>(points, 24); <span class="comment">// Use 24 neighbors</span></div><div class="line"></div><div class="line">    points.remove (unoriented_points_begin, points.end());</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point_3&gt;</a> output_mesh;</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Poisson_surface_reconstruction_3.tag:../Poisson_surface_reconstruction_3/" href="../Poisson_surface_reconstruction_3/group__PkgPoissonSurfaceReconstruction3Ref.html#ga2470854cf03552ecee02f11c17024ddf">CGAL::poisson_surface_reconstruction_delaunay</a></div><div class="line">      (points.begin(), points.end(),</div><div class="line">       points.point_map(), points.normal_map(),</div><div class="line">       output_mesh, spacing);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    std::ofstream f (<span class="stringliteral">"out_poisson.ply"</span>, std::ios_base::binary);</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (f);</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a>(f, output_mesh);</div><div class="line">    f.close ();</div><div class="line"></div><div class="line">  }</div><div class="line">  <span class="keywordflow">if</span> (reconstruction_choice == 1 || reconstruction_choice==-1) <span class="comment">// Advancing front</span></div><div class="line">  {</div><div class="line"></div><div class="line">    <span class="keyword">typedef</span> std::array&lt;std::size_t, 3&gt; Facet; <span class="comment">// Triple of indices</span></div><div class="line"></div><div class="line">    std::vector&lt;Facet&gt; facets;</div><div class="line"></div><div class="line">    <span class="comment">// The function is called using directly the points raw iterators</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Advancing_front_surface_reconstruction.tag:../Advancing_front_surface_reconstruction/" href="../Advancing_front_surface_reconstruction/group__PkgAdvancingFrontSurfaceReconstructionRef.html#gaa2b1f41291920247fd5c6ef7c09f70a4">CGAL::advancing_front_surface_reconstruction</a>(points.points().begin(),</div><div class="line">                                                 points.points().end(),</div><div class="line">                                                 std::back_inserter(facets));</div><div class="line">    std::cout &lt;&lt; facets.size ()</div><div class="line">              &lt;&lt; <span class="stringliteral">" facet(s) generated by reconstruction."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// copy points for random access</span></div><div class="line">    std::vector&lt;Point_3&gt; vertices;</div><div class="line">    vertices.reserve (points.size());</div><div class="line">    std::copy (points.points().begin(), points.points().end(), std::back_inserter (vertices));</div><div class="line"></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point_3&gt;</a> output_mesh;</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__repairing__grp.html#ga2ba9722ec8472a1455107ffce7145e46">CGAL::Polygon_mesh_processing::polygon_soup_to_polygon_mesh</a> (vertices, facets, output_mesh);</div><div class="line">    std::ofstream f (<span class="stringliteral">"out_af.off"</span>);</div><div class="line">    f &lt;&lt; output_mesh;</div><div class="line">    f.close ();</div><div class="line"></div><div class="line">  }</div><div class="line">  <span class="keywordflow">if</span> (reconstruction_choice == 2 || reconstruction_choice==-1) <span class="comment">// Scale space</span></div><div class="line">  {</div><div class="line"></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Scale_space_reconstruction_3.tag:../Scale_space_reconstruction_3/" href="../Scale_space_reconstruction_3/classCGAL_1_1Scale__space__surface__reconstruction__3.html">CGAL::Scale_space_surface_reconstruction_3&lt;Kernel&gt;</a> reconstruct</div><div class="line">      (points.points().begin(), points.points().end());</div><div class="line"></div><div class="line">    <span class="comment">// Smooth using 4 iterations of Jet Smoothing</span></div><div class="line">    reconstruct.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Scale_space_reconstruction_3.tag:../Scale_space_reconstruction_3/" href="../Scale_space_reconstruction_3/classCGAL_1_1Scale__space__surface__reconstruction__3.html#acf5262fc2bb55fe76d85f2e541a5b6ab">increase_scale</a> (4, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Scale_space_reconstruction_3.tag:../Scale_space_reconstruction_3/" href="../Scale_space_reconstruction_3/classCGAL_1_1Scale__space__reconstruction__3_1_1Jet__smoother.html">CGAL::Scale_space_reconstruction_3::Jet_smoother&lt;Kernel&gt;</a>());</div><div class="line">    <span class="comment">// Mesh with the Advancing Front mesher with a maximum facet length of 0.5</span></div><div class="line">    reconstruct.reconstruct_surface (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Scale_space_reconstruction_3.tag:../Scale_space_reconstruction_3/" href="../Scale_space_reconstruction_3/classCGAL_1_1Scale__space__reconstruction__3_1_1Advancing__front__mesher.html">CGAL::Scale_space_reconstruction_3::Advancing_front_mesher&lt;Kernel&gt;</a>(0.5));</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    std::ofstream f (<span class="stringliteral">"out_sp.off"</span>);</div><div class="line">    f &lt;&lt; <span class="stringliteral">"OFF"</span> &lt;&lt; std::endl &lt;&lt; points.size () &lt;&lt; <span class="stringliteral">" "</span></div><div class="line">      &lt;&lt; reconstruct.number_of_facets() &lt;&lt; <span class="stringliteral">" 0"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">for</span> (Point_set::Index idx : points)</div><div class="line">      f &lt;&lt; points.point (idx) &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; facet : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL.html#a266177f3e138c748f9906f7abb76320b">CGAL::make_range</a> (reconstruct.facets_begin(), reconstruct.facets_end()))</div><div class="line">      f &lt;&lt; <span class="stringliteral">"3 "</span>&lt;&lt; facet &lt;&lt; std::endl;</div><div class="line">    f.close ();</div><div class="line"></div><div class="line">  }</div><div class="line">  <span class="keywordflow">else</span> <span class="comment">// Handle error</span></div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: invalid reconstruction id: "</span> &lt;&lt; reconstruction_choice &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="TutorialsReconstruction_pipeline"></a>
Full Pipeline Images</h1>
<p>The following figure an example of a full reconstruction pipeline applied to a bear statue (courtesy <em>EPFL Computer Graphics and Geometry Laboratory</em> <a class="el" href="citelist.html#CITEREF_cgal:e-esmr">[5]</a>). Two mesh processing algorithms (hole filling and isotropic remeshing) are also applied (refer to the chapter <a class="el" href="packages.html#PkgPolygonMeshProcessing">Polygon Mesh Processing</a> for more information).</p>
<p><a class="anchor" id="fig__TutorialsReconstructionFigFull"></a></p><div class="image">
<img src="reconstruction_pipeline.png" alt="reconstruction_pipeline.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_reconstruction.html#fig__TutorialsReconstructionFigFull">Figure 0.4</a> Full reconstruction pipeline (with close-ups).  </div> <br />  
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Aug 9 2022 14:27:18 for CGAL 5.6 - Manual by
    <a href="https://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>
</html>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
          <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
          <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt="" /></a>
          </span>
        </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.6 - Manual
   </div>
  </td>
  <!-- We disable the search box because we have added it in the
  back-nav for stylistic reasons. -->
  <!-- <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td> -->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tuto_reconstruction.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Surface Reconstruction from Point Clouds </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> </p><div id="autotoc" class="toc"></div> 
<dl class="section author"><dt>Author</dt><dd>Simon Giraudot</dd></dl>
<p>Surface reconstruction from point clouds is a core topic in geometry processing <a class="el" href="citelist.html#CITEREF_cgal:btsag-asosr-16">[3]</a>. It is an ill-posed problem: there is an infinite number of surfaces that approximate a single point cloud and a point cloud does not define a surface in itself. Thus additional assumptions and constraints must be defined by the user and reconstruction can be achieved in many different ways. This tutorial provides guidance on how to use the different algorithms of CGAL to effectively perform surface reconstruction.</p>
<h1><a class="anchor" id="TutorialsReconstruction_algorithms"></a>
Which algorithm should I use?</h1>
<p>CGAL offers three different algorithms for surface reconstruction:</p>
<ul>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Poisson_surface_reconstruction_3.tag:../Poisson_surface_reconstruction_3/" href="../Poisson_surface_reconstruction_3/index.html#Chapter_Poisson_Surface_Reconstruction">Poisson Surface Reconstruction</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Advancing_front_surface_reconstruction.tag:../Advancing_front_surface_reconstruction/" href="../Advancing_front_surface_reconstruction/index.html#Chapter_Advancing_Front_Surface_Reconstruction">Advancing Front Surface Reconstruction</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Scale_space_reconstruction_3.tag:../Scale_space_reconstruction_3/" href="../Scale_space_reconstruction_3/index.html#Chapter_Scale_space_reconstruction">Scale Space Surface Reconstruction</a></li>
</ul>
<p>Because reconstruction is an ill-posed problem, it must be regularized via prior knowledge. Differences in prior lead to different algorithms, and choosing one or the other of these methods is dependent on these priors. For example, Poisson always generates closed shapes (bounding a volume) and requires normals but does not interpolate input points (the output surface does not pass exactly through the input points). The following table lists different properties of the input and output to help the user choose the method best suited to each problem:</p>
<center> <table class="doxtable">
<tr>
<th></th><th align="center">Poisson </th><th align="center">Advancing front </th><th align="center">Scale space  </th></tr>
<tr>
<td>Are normals required? </td><td align="center">Yes </td><td align="center">No </td><td align="center">No </td></tr>
<tr>
<td>Is noise handled? </td><td align="center">Yes </td><td align="center">By preprocessing </td><td align="center">Yes </td></tr>
<tr>
<td>Is variable sampling handled? </td><td align="center">Yes </td><td align="center">Yes </td><td align="center">By preprocessing </td></tr>
<tr>
<td>Are input points exactly on the surface? </td><td align="center">No </td><td align="center">Yes </td><td align="center">Yes </td></tr>
<tr>
<td>Is the output always closed? </td><td align="center">Yes </td><td align="center">No </td><td align="center">No </td></tr>
<tr>
<td>Is the output always smooth? </td><td align="center">Yes </td><td align="center">No </td><td align="center">No </td></tr>
<tr>
<td>Is the output always manifold? </td><td align="center">Yes </td><td align="center">Yes </td><td align="center">Optional </td></tr>
<tr>
<td>Is the output always orientable? </td><td align="center">Yes </td><td align="center">Yes </td><td align="center">Optional </td></tr>
</table>
</center><p><a class="anchor" id="fig__TutorialsReconstructionFigComparisons"></a></p><div class="image">
<img src="compare_reconstructions.png" alt="compare_reconstructions.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_reconstruction.html#fig__TutorialsReconstructionFigComparisons">Figure 0.1</a> Comparison of reconstruction methods applied to the same input (full shape and close-up). From left to right: original point cloud; Poisson; advancing front; scale space.  </div> <br /> 
<p>More information on these different methods can be found on their respective manual pages and in Section <a class="el" href="tuto_reconstruction.html#TutorialsReconstruction_reconstruction">Reconstruction</a>.</p>
<h1><a class="anchor" id="TutorialsReconstruction_overview"></a>
Pipeline Overview</h1>
<p>This tutorial aims at providing a more comprehensive view of the possibilities offered by CGAL for dealing with point clouds, for surface reconstruction purposes. The following diagram shows an overview (not exhaustive) of common reconstruction steps using CGAL tools.</p>
<p><a class="anchor" id="fig__TutorialsReconstructionFigPipeline"></a></p><div class="image">
<object type="image/svg+xml" data="reconstruction.svg">reconstruction.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_reconstruction.html#fig__TutorialsReconstructionFigPipeline">Figure 0.2</a> Pipeline Overview  </div> <br /> 
<p>We now review some of these steps in more detail.</p>
<h1><a class="anchor" id="TutorialsReconstruction_input"></a>
Reading Input</h1>
<p>The reconstruction algorithms in CGAL take a range of iterators on a container as input and use property maps to access the points (and the normals when they are required). Points are typically stored in plain text format (denoted as 'XYZ' format) where each point is separated by a newline character and each coordinate separated by a white space. Other formats available are 'OFF', 'PLY' and 'LAS'. CGAL provides functions to read such formats:</p>
<ul>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/group__PkgPointSet3IOXYZ.html#gaa21dccecfcfb73b70fd47607dfe6cbc0">read_XYZ()</a></code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/group__PkgPolyhedronIOFunc.html#gaccd9d4d15af1376dbc166eb501f28980">read_OFF()</a></code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga3b898d61ab5682756b25c425a8d8ec97">read_PLY()</a></code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3IOPly.html#gad9785e7191ba94d81fac841798aa1ddb">read_PLY_with_properties()</a></code> to read additional PLY properties</li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/group__PkgPointSet3IOLAS.html#ga87dc5f0f0d96c5a75286f5996e414aaf">read_LAS()</a></code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3IOLas.html#ga5187fc18430a5e3c811f75da57a057ad">read_LAS_with_properties()</a></code> to read additional LAS properties</li>
</ul>
<p>CGAL also provides a dedicated container <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3</a></code> to handle point sets with additional properties such as normal vectors. In this case, property maps are easily handled as shown in the following sections. This structure also handles the stream operator to read point sets in any of the formats previously described. Using this method yields substantially shorter code, as can be seen on the following example:</p>
<div class="fragment"><div class="line"></div><div class="line">  Point_set points;</div><div class="line"></div><div class="line">  std::string fname = argc==1?<a class="code" href="namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/kitten.xyz"</span>) : argv[1];</div><div class="line">  <span class="keywordflow">if</span> (argc &lt; 2)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Usage: "</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">" [input.xyz/off/ply/las]"</span> &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt;<span class="stringliteral">"Running "</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">" data/kitten.xyz -1\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::ifstream stream (fname, std::ios_base::binary);</div><div class="line">  <span class="keywordflow">if</span> (!stream)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  stream &gt;&gt; points;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Read "</span> &lt;&lt; points.size () &lt;&lt; <span class="stringliteral">" point(s)"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">if</span> (points.empty())</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line"></div></div><!-- fragment --> <h1><a class="anchor" id="TutorialsReconstruction_preprocessing"></a>
Preprocessing</h1>
<p>Because reconstruction algorithms have some specific requirements that point clouds do not always meet, some preprocessing might be necessary to yield the best results.</p>
<p>Note that this <em>preprocessing</em> step is optional: when the input point cloud has no imperfections, reconstruction can be applied to it without any preprocessing.</p>
<p><a class="anchor" id="fig__TutorialsReconstructionFigPreprocessing"></a></p><div class="image">
<img src="reconstruction_preproc.png" alt="reconstruction_preproc.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_reconstruction.html#fig__TutorialsReconstructionFigPreprocessing">Figure 0.3</a> Comparison of advancing front reconstruction output using different preprocessing on the same input. The smooth point cloud was generated using <em>jet smoothing</em>; the simplified point cloud was generated using <em>grid simplification</em>.  </div> <br /> 
<h2><a class="anchor" id="TutorialsReconstruction_preprocessing_outliers"></a>
Outlier removal</h2>
<p>Some acquisition techniques generate points which are far away from the surface. These points, commonly referred to as "outliers", have no relevance for reconstruction. Using the CGAL reconstruction algorithms on outlier-ridden point clouds produce overly distorted output, it is therefore strongly advised to filter these outliers <em>before</em> performing reconstruction.</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="keyword">typename</span> Point_set::iterator rout_it = CGAL::remove_outliers&lt;CGAL::Sequential_tag&gt;</div><div class="line">    (points,</div><div class="line">     24, <span class="comment">// Number of neighbors considered for evaluation</span></div><div class="line">     points.parameters().threshold_percent (5.0)); <span class="comment">// Percentage of points to remove</span></div><div class="line">  points.remove(rout_it, points.end());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; points.number_of_removed_points()</div><div class="line">            &lt;&lt; <span class="stringliteral">" point(s) are outliers."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Applying point set processing algorithm to a CGAL::Point_set_3</span></div><div class="line">  <span class="comment">// object does not erase the points from memory but place them in</span></div><div class="line">  <span class="comment">// the garbage of the object: memory can be freeed by the user.</span></div><div class="line">  points.collect_garbage();</div><div class="line"></div></div><!-- fragment --> <h2><a class="anchor" id="TutorialsReconstruction_preprocessing_simplification"></a>
Simplification</h2>
<p>Some laser scanners generate points with widely variable sampling. Typically, lines of scan are very densely sampled but the gap between two lines of scan is much larger, leading to an overly massive point cloud with large variations of sampling density. This type of input point cloud might generate imperfect output using algorithms which, in general, only handle small variations of sampling density.</p>
<p>CGAL provides several simplification algorithms. In addition to reducing the size of the input point cloud and therefore decreasing computation time, some of them can help making the input more uniform. This is the case of the function <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga7757ef9b3900e42fde26f5a0ac56e20f">grid_simplify_point_set()</a></code> which defines a grid of a user-specified size and keeps one point per occupied cell.</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="comment">// Compute average spacing using neighborhood of 6 points</span></div><div class="line">  <span class="keywordtype">double</span> spacing = CGAL::compute_average_spacing&lt;CGAL::Sequential_tag&gt; (points, 6);</div><div class="line"></div><div class="line">  <span class="comment">// Simplify using a grid of size 2 * average spacing</span></div><div class="line">  <span class="keyword">typename</span> Point_set::iterator gsim_it = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga7757ef9b3900e42fde26f5a0ac56e20f">CGAL::grid_simplify_point_set</a> (points, 2. * spacing);</div><div class="line">  points.remove(gsim_it, points.end());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; points.number_of_removed_points()</div><div class="line">            &lt;&lt; <span class="stringliteral">" point(s) removed after simplification."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  points.collect_garbage();</div><div class="line"></div></div><!-- fragment --><h2><a class="anchor" id="TutorialsReconstruction_preprocessing_smoothing"></a>
Smoothing</h2>
<p>Although reconstructions via 'Poisson' or 'Scale space' handle noise internally, one may want to get tighter control over the smoothing step. For example, a slightly noisy point cloud can benefit from some reliable smoothing algorithms and be reconstructed via 'Advancing front' which provides relevant properties (oriented mesh with boundaries).</p>
<p>Two functions are provided to smooth a noisy point cloud with a good approximation (i.e. without degrading curvature, for example):</p>
<ul>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga96a3738be3b2b9bd1587af78ae10e67a">jet_smooth_point_set()</a></code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga01192a227578fee0c5676ba6a5e88931">bilateral_smooth_point_set()</a></code></li>
</ul>
<p>These functions directly modify the container:</p>
<div class="fragment"><div class="line"></div><div class="line">  CGAL::jet_smooth_point_set&lt;CGAL::Sequential_tag&gt; (points, 24);</div><div class="line"></div></div><!-- fragment --><h2><a class="anchor" id="TutorialsReconstruction_preprocessing_normal"></a>
Normal Estimation and Orientation</h2>
<p><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Poisson_surface_reconstruction_3.tag:../Poisson_surface_reconstruction_3/" href="../Poisson_surface_reconstruction_3/index.html#Chapter_Poisson_Surface_Reconstruction">Poisson Surface Reconstruction</a> requires points with oriented normal vectors. To apply the algorithm to a raw point cloud, normals must be estimated first, for example with one of these two functions:</p>
<ul>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga721aeb7af4b2d31e08e75bc5d53303cf">pca_estimate_normals()</a></code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga078e25209373cab0e1f3524202489771">jet_estimate_normals()</a></code></li>
</ul>
<p>PCA is faster but jet is more accurate in the presence of high curvatures. These function only estimates the <em>direction</em> of the normals, not their orientation (the orientation of the vectors might not be locally consistent). To properly orient the normals, the following functions can be used:</p>
<ul>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga17c3c558c3799b65bd23fba971a82a5c">mst_orient_normals()</a></code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#gafc3627234666e1fb458e9387e9d5f3c6">scanline_orient_normals()</a></code></li>
</ul>
<p>The first one uses a <em>minimum spanning tree</em> to consistently propagate the orientation of normals in an increasingly large neighborhood. In the case of data with many sharp features and occlusions (which are common in airborne LIDAR data, for example), the second algorithm may produce better results: it takes advantage of point clouds which are ordered into scanlines to estimate the line of sight of each point and thus to orient normals accordingly.</p>
<p>Notice that these can also be used directly on input normals if their orientation is not consistent.</p>
<div class="fragment"><div class="line"></div><div class="line">    CGAL::jet_estimate_normals&lt;CGAL::Sequential_tag&gt;</div><div class="line">      (points, 24); <span class="comment">// Use 24 neighbors</span></div><div class="line"></div><div class="line">    <span class="comment">// Orientation of normals, returns iterator to first unoriented point</span></div><div class="line">    <span class="keyword">typename</span> Point_set::iterator unoriented_points_begin =</div><div class="line">      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga17c3c558c3799b65bd23fba971a82a5c">CGAL::mst_orient_normals</a>(points, 24); <span class="comment">// Use 24 neighbors</span></div><div class="line"></div><div class="line">    points.remove (unoriented_points_begin, points.end());</div><div class="line"></div></div><!-- fragment --> <h1><a class="anchor" id="TutorialsReconstruction_reconstruction"></a>
Reconstruction</h1>
<h2><a class="anchor" id="TutorialsReconstruction_reconstruction_poisson"></a>
Poisson</h2>
<p>Poisson reconstruction consists in computing an implicit function whose gradient matches the input normal vector field: this indicator function has opposite signs inside and outside of the inferred shape (hence the need for closed shapes). This method thus requires normals and produces smooth closed surfaces. It is not appropriate if the surface is expected to interpolate the input points. On the contrary, it performs well if the aim is to approximate a noisy point cloud with a smooth surface.</p>
<div class="fragment"><div class="line"></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point_3&gt;</a> output_mesh;</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Poisson_surface_reconstruction_3.tag:../Poisson_surface_reconstruction_3/" href="../Poisson_surface_reconstruction_3/group__PkgPoissonSurfaceReconstruction3Ref.html#ga2470854cf03552ecee02f11c17024ddf">CGAL::poisson_surface_reconstruction_delaunay</a></div><div class="line">      (points.begin(), points.end(),</div><div class="line">       points.point_map(), points.normal_map(),</div><div class="line">       output_mesh, spacing);</div><div class="line"></div></div><!-- fragment --> <h2><a class="anchor" id="TutorialsReconstruction_reconstruction_advancing"></a>
Advancing Front</h2>
<p>Advancing front is a Delaunay-based approach which interpolates a subset of the input points. It generates triples of point indices which describe the triangular facets of the reconstruction: it uses a priority queue to sequentially pick the Delaunay facet the most likely to be part of the surface, based on a size criterion (to favor the small facets) and an angle criterion (to favor smoothness). Its main virtue is to generate oriented manifold surfaces with boundaries: contrary to Poisson, it does not require normals and is not bound to reconstruct closed shapes. However, it requires preprocessing if the point cloud is noisy.</p>
<p>The <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Advancing_front_surface_reconstruction.tag:../Advancing_front_surface_reconstruction/" href="../Advancing_front_surface_reconstruction/index.html#Chapter_Advancing_Front_Surface_Reconstruction">Advancing Front</a> package provides several ways of constructing the function. Here is a simple example:</p>
<div class="fragment"><div class="line"></div><div class="line">    <span class="keyword">typedef</span> std::array&lt;std::size_t, 3&gt; Facet; <span class="comment">// Triple of indices</span></div><div class="line"></div><div class="line">    std::vector&lt;Facet&gt; facets;</div><div class="line"></div><div class="line">    <span class="comment">// The function is called using directly the points raw iterators</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Advancing_front_surface_reconstruction.tag:../Advancing_front_surface_reconstruction/" href="../Advancing_front_surface_reconstruction/group__PkgAdvancingFrontSurfaceReconstructionRef.html#gaa2b1f41291920247fd5c6ef7c09f70a4">CGAL::advancing_front_surface_reconstruction</a>(points.points().begin(),</div><div class="line">                                                 points.points().end(),</div><div class="line">                                                 std::back_inserter(facets));</div><div class="line">    std::cout &lt;&lt; facets.size ()</div><div class="line">              &lt;&lt; <span class="stringliteral">" facet(s) generated by reconstruction."</span> &lt;&lt; std::endl;</div><div class="line"></div></div><!-- fragment --> <h2><a class="anchor" id="TutorialsReconstruction_reconstruction_scale_space"></a>
Scale Space</h2>
<p>Scale space reconstruction aims at producing a surface which interpolates the input points (interpolant) while offering some robustness to noise. More specifically, it first applies several times a smoothing filter (such as Jet Smoothing) to the input point set to produce a scale space; then, the smoothest scale is meshed (using for example the Advancing Front mesher); finally, the resulting connectivity between smoothed points is propagated to the original raw input point set. This method is the right choice if the input point cloud is noisy but the user still wants the surface to pass exactly through the points.</p>
<div class="fragment"><div class="line"></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Scale_space_reconstruction_3.tag:../Scale_space_reconstruction_3/" href="../Scale_space_reconstruction_3/classCGAL_1_1Scale__space__surface__reconstruction__3.html">CGAL::Scale_space_surface_reconstruction_3&lt;Kernel&gt;</a> reconstruct</div><div class="line">      (points.points().begin(), points.points().end());</div><div class="line"></div><div class="line">    <span class="comment">// Smooth using 4 iterations of Jet Smoothing</span></div><div class="line">    reconstruct.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Scale_space_reconstruction_3.tag:../Scale_space_reconstruction_3/" href="../Scale_space_reconstruction_3/classCGAL_1_1Scale__space__surface__reconstruction__3.html#acf5262fc2bb55fe76d85f2e541a5b6ab">increase_scale</a> (4, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Scale_space_reconstruction_3.tag:../Scale_space_reconstruction_3/" href="../Scale_space_reconstruction_3/classCGAL_1_1Scale__space__reconstruction__3_1_1Jet__smoother.html">CGAL::Scale_space_reconstruction_3::Jet_smoother&lt;Kernel&gt;</a>());</div><div class="line">    <span class="comment">// Mesh with the Advancing Front mesher with a maximum facet length of 0.5</span></div><div class="line">    reconstruct.reconstruct_surface (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Scale_space_reconstruction_3.tag:../Scale_space_reconstruction_3/" href="../Scale_space_reconstruction_3/classCGAL_1_1Scale__space__reconstruction__3_1_1Advancing__front__mesher.html">CGAL::Scale_space_reconstruction_3::Advancing_front_mesher&lt;Kernel&gt;</a>(0.5));</div><div class="line"></div></div><!-- fragment --> <h1><a class="anchor" id="TutorialsReconstruction_postprocessing"></a>
Output and Postprocessing</h1>
<p>Each of these methods produce a triangle mesh stored in different ways. If this output mesh is hampered by defects such as holes or self-intersections, CGAL provide several algorithms to post-process it (hole filling, remeshing, etc.) in the package <a class="el" href="packages.html#PkgPolygonMeshProcessing">Polygon Mesh Processing</a>.</p>
<p>We do not discuss these functions here as there are many postprocessing possibilities whose relevance strongly depends on the user's expectations on the output mesh.</p>
<p>The mesh (postprocessed or not) can easily be saved in the PLY format (here, using the binary variant):</p>
<div class="fragment"><div class="line"></div><div class="line">    std::ofstream f (<span class="stringliteral">"out_poisson.ply"</span>, std::ios_base::binary);</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (f);</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a>(f, output_mesh);</div><div class="line">    f.close ();</div><div class="line"></div></div><!-- fragment --><p> A polygon soup can also be saved in the OFF format by iterating on the points and faces:</p>
<div class="fragment"><div class="line"></div><div class="line">    std::ofstream f (<span class="stringliteral">"out_sp.off"</span>);</div><div class="line">    f &lt;&lt; <span class="stringliteral">"OFF"</span> &lt;&lt; std::endl &lt;&lt; points.size () &lt;&lt; <span class="stringliteral">" "</span></div><div class="line">      &lt;&lt; reconstruct.number_of_facets() &lt;&lt; <span class="stringliteral">" 0"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">for</span> (Point_set::Index idx : points)</div><div class="line">      f &lt;&lt; points.point (idx) &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; facet : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL.html#a266177f3e138c748f9906f7abb76320b">CGAL::make_range</a> (reconstruct.facets_begin(), reconstruct.facets_end()))</div><div class="line">      f &lt;&lt; <span class="stringliteral">"3 "</span>&lt;&lt; facet &lt;&lt; std::endl;</div><div class="line">    f.close ();</div><div class="line"></div></div><!-- fragment --><p> Finally, if the polygon soup can be converted into a polygon mesh, it can also be saved directly in the OFF format using the stream operator:</p>
<div class="fragment"><div class="line"></div><div class="line">    <span class="comment">// copy points for random access</span></div><div class="line">    std::vector&lt;Point_3&gt; vertices;</div><div class="line">    vertices.reserve (points.size());</div><div class="line">    std::copy (points.points().begin(), points.points().end(), std::back_inserter (vertices));</div><div class="line"></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point_3&gt;</a> output_mesh;</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__repairing__grp.html#ga2ba9722ec8472a1455107ffce7145e46">CGAL::Polygon_mesh_processing::polygon_soup_to_polygon_mesh</a> (vertices, facets, output_mesh);</div><div class="line">    std::ofstream f (<span class="stringliteral">"out_af.off"</span>);</div><div class="line">    f &lt;&lt; output_mesh;</div><div class="line">    f.close ();</div><div class="line"></div></div><!-- fragment --> <h1><a class="anchor" id="TutorialsReconstruction_recap"></a>
Full Code Example</h1>
<p>All the code snippets used in this tutorial can be assembled to create a full algorithm pipeline (provided the correct <em>includes</em> are used). We give a full code example which achieves all the steps described in this tutorial. The reconstruction method can be selected by the user at runtime with the second argument.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3/IO.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/remove_outliers.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/grid_simplify_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/jet_smooth_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/jet_estimate_normals.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/mst_orient_normals.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/poisson_surface_reconstruction.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Advancing_front_surface_reconstruction.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Scale_space_surface_reconstruction_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Scale_space_reconstruction_3/Jet_smoother.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Scale_space_reconstruction_3/Advancing_front_mesher.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/polygon_soup_to_polygon_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point_3;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector_3;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Sphere__3.html">Kernel::Sphere_3</a> Sphere_3;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3&lt;Point_3, Vector_3&gt;</a> Point_set;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line"></div><div class="line">  Point_set points;</div><div class="line"></div><div class="line">  std::string fname = argc==1?<a class="code" href="namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/kitten.xyz"</span>) : argv[1];</div><div class="line">  <span class="keywordflow">if</span> (argc &lt; 2)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Usage: "</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">" [input.xyz/off/ply/las]"</span> &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt;<span class="stringliteral">"Running "</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">" data/kitten.xyz -1\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::ifstream stream (fname, std::ios_base::binary);</div><div class="line">  <span class="keywordflow">if</span> (!stream)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  stream &gt;&gt; points;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Read "</span> &lt;&lt; points.size () &lt;&lt; <span class="stringliteral">" point(s)"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">if</span> (points.empty())</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">typename</span> Point_set::iterator rout_it = CGAL::remove_outliers&lt;CGAL::Sequential_tag&gt;</div><div class="line">    (points,</div><div class="line">     24, <span class="comment">// Number of neighbors considered for evaluation</span></div><div class="line">     points.parameters().threshold_percent (5.0)); <span class="comment">// Percentage of points to remove</span></div><div class="line">  points.remove(rout_it, points.end());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; points.number_of_removed_points()</div><div class="line">            &lt;&lt; <span class="stringliteral">" point(s) are outliers."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Applying point set processing algorithm to a CGAL::Point_set_3</span></div><div class="line">  <span class="comment">// object does not erase the points from memory but place them in</span></div><div class="line">  <span class="comment">// the garbage of the object: memory can be freeed by the user.</span></div><div class="line">  points.collect_garbage();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Compute average spacing using neighborhood of 6 points</span></div><div class="line">  <span class="keywordtype">double</span> spacing = CGAL::compute_average_spacing&lt;CGAL::Sequential_tag&gt; (points, 6);</div><div class="line"></div><div class="line">  <span class="comment">// Simplify using a grid of size 2 * average spacing</span></div><div class="line">  <span class="keyword">typename</span> Point_set::iterator gsim_it = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga7757ef9b3900e42fde26f5a0ac56e20f">CGAL::grid_simplify_point_set</a> (points, 2. * spacing);</div><div class="line">  points.remove(gsim_it, points.end());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; points.number_of_removed_points()</div><div class="line">            &lt;&lt; <span class="stringliteral">" point(s) removed after simplification."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  points.collect_garbage();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  CGAL::jet_smooth_point_set&lt;CGAL::Sequential_tag&gt; (points, 24);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> reconstruction_choice</div><div class="line">    = argc==1? -1 : (argc &lt; 3 ? 0 : atoi(argv[2]));</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (reconstruction_choice == 0 || reconstruction_choice==-1) <span class="comment">// Poisson</span></div><div class="line">  {</div><div class="line"></div><div class="line">    CGAL::jet_estimate_normals&lt;CGAL::Sequential_tag&gt;</div><div class="line">      (points, 24); <span class="comment">// Use 24 neighbors</span></div><div class="line"></div><div class="line">    <span class="comment">// Orientation of normals, returns iterator to first unoriented point</span></div><div class="line">    <span class="keyword">typename</span> Point_set::iterator unoriented_points_begin =</div><div class="line">      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga17c3c558c3799b65bd23fba971a82a5c">CGAL::mst_orient_normals</a>(points, 24); <span class="comment">// Use 24 neighbors</span></div><div class="line"></div><div class="line">    points.remove (unoriented_points_begin, points.end());</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point_3&gt;</a> output_mesh;</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Poisson_surface_reconstruction_3.tag:../Poisson_surface_reconstruction_3/" href="../Poisson_surface_reconstruction_3/group__PkgPoissonSurfaceReconstruction3Ref.html#ga2470854cf03552ecee02f11c17024ddf">CGAL::poisson_surface_reconstruction_delaunay</a></div><div class="line">      (points.begin(), points.end(),</div><div class="line">       points.point_map(), points.normal_map(),</div><div class="line">       output_mesh, spacing);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    std::ofstream f (<span class="stringliteral">"out_poisson.ply"</span>, std::ios_base::binary);</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (f);</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a>(f, output_mesh);</div><div class="line">    f.close ();</div><div class="line"></div><div class="line">  }</div><div class="line">  <span class="keywordflow">if</span> (reconstruction_choice == 1 || reconstruction_choice==-1) <span class="comment">// Advancing front</span></div><div class="line">  {</div><div class="line"></div><div class="line">    <span class="keyword">typedef</span> std::array&lt;std::size_t, 3&gt; Facet; <span class="comment">// Triple of indices</span></div><div class="line"></div><div class="line">    std::vector&lt;Facet&gt; facets;</div><div class="line"></div><div class="line">    <span class="comment">// The function is called using directly the points raw iterators</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Advancing_front_surface_reconstruction.tag:../Advancing_front_surface_reconstruction/" href="../Advancing_front_surface_reconstruction/group__PkgAdvancingFrontSurfaceReconstructionRef.html#gaa2b1f41291920247fd5c6ef7c09f70a4">CGAL::advancing_front_surface_reconstruction</a>(points.points().begin(),</div><div class="line">                                                 points.points().end(),</div><div class="line">                                                 std::back_inserter(facets));</div><div class="line">    std::cout &lt;&lt; facets.size ()</div><div class="line">              &lt;&lt; <span class="stringliteral">" facet(s) generated by reconstruction."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// copy points for random access</span></div><div class="line">    std::vector&lt;Point_3&gt; vertices;</div><div class="line">    vertices.reserve (points.size());</div><div class="line">    std::copy (points.points().begin(), points.points().end(), std::back_inserter (vertices));</div><div class="line"></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point_3&gt;</a> output_mesh;</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__repairing__grp.html#ga2ba9722ec8472a1455107ffce7145e46">CGAL::Polygon_mesh_processing::polygon_soup_to_polygon_mesh</a> (vertices, facets, output_mesh);</div><div class="line">    std::ofstream f (<span class="stringliteral">"out_af.off"</span>);</div><div class="line">    f &lt;&lt; output_mesh;</div><div class="line">    f.close ();</div><div class="line"></div><div class="line">  }</div><div class="line">  <span class="keywordflow">if</span> (reconstruction_choice == 2 || reconstruction_choice==-1) <span class="comment">// Scale space</span></div><div class="line">  {</div><div class="line"></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Scale_space_reconstruction_3.tag:../Scale_space_reconstruction_3/" href="../Scale_space_reconstruction_3/classCGAL_1_1Scale__space__surface__reconstruction__3.html">CGAL::Scale_space_surface_reconstruction_3&lt;Kernel&gt;</a> reconstruct</div><div class="line">      (points.points().begin(), points.points().end());</div><div class="line"></div><div class="line">    <span class="comment">// Smooth using 4 iterations of Jet Smoothing</span></div><div class="line">    reconstruct.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Scale_space_reconstruction_3.tag:../Scale_space_reconstruction_3/" href="../Scale_space_reconstruction_3/classCGAL_1_1Scale__space__surface__reconstruction__3.html#acf5262fc2bb55fe76d85f2e541a5b6ab">increase_scale</a> (4, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Scale_space_reconstruction_3.tag:../Scale_space_reconstruction_3/" href="../Scale_space_reconstruction_3/classCGAL_1_1Scale__space__reconstruction__3_1_1Jet__smoother.html">CGAL::Scale_space_reconstruction_3::Jet_smoother&lt;Kernel&gt;</a>());</div><div class="line">    <span class="comment">// Mesh with the Advancing Front mesher with a maximum facet length of 0.5</span></div><div class="line">    reconstruct.reconstruct_surface (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Scale_space_reconstruction_3.tag:../Scale_space_reconstruction_3/" href="../Scale_space_reconstruction_3/classCGAL_1_1Scale__space__reconstruction__3_1_1Advancing__front__mesher.html">CGAL::Scale_space_reconstruction_3::Advancing_front_mesher&lt;Kernel&gt;</a>(0.5));</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    std::ofstream f (<span class="stringliteral">"out_sp.off"</span>);</div><div class="line">    f &lt;&lt; <span class="stringliteral">"OFF"</span> &lt;&lt; std::endl &lt;&lt; points.size () &lt;&lt; <span class="stringliteral">" "</span></div><div class="line">      &lt;&lt; reconstruct.number_of_facets() &lt;&lt; <span class="stringliteral">" 0"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">for</span> (Point_set::Index idx : points)</div><div class="line">      f &lt;&lt; points.point (idx) &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; facet : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL.html#a266177f3e138c748f9906f7abb76320b">CGAL::make_range</a> (reconstruct.facets_begin(), reconstruct.facets_end()))</div><div class="line">      f &lt;&lt; <span class="stringliteral">"3 "</span>&lt;&lt; facet &lt;&lt; std::endl;</div><div class="line">    f.close ();</div><div class="line"></div><div class="line">  }</div><div class="line">  <span class="keywordflow">else</span> <span class="comment">// Handle error</span></div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: invalid reconstruction id: "</span> &lt;&lt; reconstruction_choice &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="TutorialsReconstruction_pipeline"></a>
Full Pipeline Images</h1>
<p>The following figure an example of a full reconstruction pipeline applied to a bear statue (courtesy <em>EPFL Computer Graphics and Geometry Laboratory</em> <a class="el" href="citelist.html#CITEREF_cgal:e-esmr">[5]</a>). Two mesh processing algorithms (hole filling and isotropic remeshing) are also applied (refer to the chapter <a class="el" href="packages.html#PkgPolygonMeshProcessing">Polygon Mesh Processing</a> for more information).</p>
<p><a class="anchor" id="fig__TutorialsReconstructionFigFull"></a></p><div class="image">
<img src="reconstruction_pipeline.png" alt="reconstruction_pipeline.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_reconstruction.html#fig__TutorialsReconstructionFigFull">Figure 0.4</a> Full reconstruction pipeline (with close-ups).  </div> <br />  
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Aug 9 2022 14:27:18 for CGAL 5.6 - Manual by
    <a href="https://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>
</html><html xmlns="http://www.w3.org/1999/xhtml"><body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
          <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
          <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt="" /></a>
          </span>
        </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.6 - Manual
   </div>
  </td>
  <!-- We disable the search box because we have added it in the
  back-nav for stylistic reasons. -->
  <!-- <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td> -->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tuto_reconstruction.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Surface Reconstruction from Point Clouds </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> </p><div id="autotoc" class="toc"></div> 
<dl class="section author"><dt>Author</dt><dd>Simon Giraudot</dd></dl>
<p>Surface reconstruction from point clouds is a core topic in geometry processing <a class="el" href="citelist.html#CITEREF_cgal:btsag-asosr-16">[3]</a>. It is an ill-posed problem: there is an infinite number of surfaces that approximate a single point cloud and a point cloud does not define a surface in itself. Thus additional assumptions and constraints must be defined by the user and reconstruction can be achieved in many different ways. This tutorial provides guidance on how to use the different algorithms of CGAL to effectively perform surface reconstruction.</p>
<h1><a class="anchor" id="TutorialsReconstruction_algorithms"></a>
Which algorithm should I use?</h1>
<p>CGAL offers three different algorithms for surface reconstruction:</p>
<ul>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Poisson_surface_reconstruction_3.tag:../Poisson_surface_reconstruction_3/" href="../Poisson_surface_reconstruction_3/index.html#Chapter_Poisson_Surface_Reconstruction">Poisson Surface Reconstruction</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Advancing_front_surface_reconstruction.tag:../Advancing_front_surface_reconstruction/" href="../Advancing_front_surface_reconstruction/index.html#Chapter_Advancing_Front_Surface_Reconstruction">Advancing Front Surface Reconstruction</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Scale_space_reconstruction_3.tag:../Scale_space_reconstruction_3/" href="../Scale_space_reconstruction_3/index.html#Chapter_Scale_space_reconstruction">Scale Space Surface Reconstruction</a></li>
</ul>
<p>Because reconstruction is an ill-posed problem, it must be regularized via prior knowledge. Differences in prior lead to different algorithms, and choosing one or the other of these methods is dependent on these priors. For example, Poisson always generates closed shapes (bounding a volume) and requires normals but does not interpolate input points (the output surface does not pass exactly through the input points). The following table lists different properties of the input and output to help the user choose the method best suited to each problem:</p>
<center> <table class="doxtable">
<tr>
<th></th><th align="center">Poisson </th><th align="center">Advancing front </th><th align="center">Scale space  </th></tr>
<tr>
<td>Are normals required? </td><td align="center">Yes </td><td align="center">No </td><td align="center">No </td></tr>
<tr>
<td>Is noise handled? </td><td align="center">Yes </td><td align="center">By preprocessing </td><td align="center">Yes </td></tr>
<tr>
<td>Is variable sampling handled? </td><td align="center">Yes </td><td align="center">Yes </td><td align="center">By preprocessing </td></tr>
<tr>
<td>Are input points exactly on the surface? </td><td align="center">No </td><td align="center">Yes </td><td align="center">Yes </td></tr>
<tr>
<td>Is the output always closed? </td><td align="center">Yes </td><td align="center">No </td><td align="center">No </td></tr>
<tr>
<td>Is the output always smooth? </td><td align="center">Yes </td><td align="center">No </td><td align="center">No </td></tr>
<tr>
<td>Is the output always manifold? </td><td align="center">Yes </td><td align="center">Yes </td><td align="center">Optional </td></tr>
<tr>
<td>Is the output always orientable? </td><td align="center">Yes </td><td align="center">Yes </td><td align="center">Optional </td></tr>
</table>
</center><p><a class="anchor" id="fig__TutorialsReconstructionFigComparisons"></a></p><div class="image">
<img src="compare_reconstructions.png" alt="compare_reconstructions.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_reconstruction.html#fig__TutorialsReconstructionFigComparisons">Figure 0.1</a> Comparison of reconstruction methods applied to the same input (full shape and close-up). From left to right: original point cloud; Poisson; advancing front; scale space.  </div> <br /> 
<p>More information on these different methods can be found on their respective manual pages and in Section <a class="el" href="tuto_reconstruction.html#TutorialsReconstruction_reconstruction">Reconstruction</a>.</p>
<h1><a class="anchor" id="TutorialsReconstruction_overview"></a>
Pipeline Overview</h1>
<p>This tutorial aims at providing a more comprehensive view of the possibilities offered by CGAL for dealing with point clouds, for surface reconstruction purposes. The following diagram shows an overview (not exhaustive) of common reconstruction steps using CGAL tools.</p>
<p><a class="anchor" id="fig__TutorialsReconstructionFigPipeline"></a></p><div class="image">
<object type="image/svg+xml" data="reconstruction.svg">reconstruction.svg</object>
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_reconstruction.html#fig__TutorialsReconstructionFigPipeline">Figure 0.2</a> Pipeline Overview  </div> <br /> 
<p>We now review some of these steps in more detail.</p>
<h1><a class="anchor" id="TutorialsReconstruction_input"></a>
Reading Input</h1>
<p>The reconstruction algorithms in CGAL take a range of iterators on a container as input and use property maps to access the points (and the normals when they are required). Points are typically stored in plain text format (denoted as 'XYZ' format) where each point is separated by a newline character and each coordinate separated by a white space. Other formats available are 'OFF', 'PLY' and 'LAS'. CGAL provides functions to read such formats:</p>
<ul>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/group__PkgPointSet3IOXYZ.html#gaa21dccecfcfb73b70fd47607dfe6cbc0">read_XYZ()</a></code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/group__PkgPolyhedronIOFunc.html#gaccd9d4d15af1376dbc166eb501f28980">read_OFF()</a></code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga3b898d61ab5682756b25c425a8d8ec97">read_PLY()</a></code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3IOPly.html#gad9785e7191ba94d81fac841798aa1ddb">read_PLY_with_properties()</a></code> to read additional PLY properties</li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/group__PkgPointSet3IOLAS.html#ga87dc5f0f0d96c5a75286f5996e414aaf">read_LAS()</a></code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3IOLas.html#ga5187fc18430a5e3c811f75da57a057ad">read_LAS_with_properties()</a></code> to read additional LAS properties</li>
</ul>
<p>CGAL also provides a dedicated container <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3</a></code> to handle point sets with additional properties such as normal vectors. In this case, property maps are easily handled as shown in the following sections. This structure also handles the stream operator to read point sets in any of the formats previously described. Using this method yields substantially shorter code, as can be seen on the following example:</p>
<div class="fragment"><div class="line"></div><div class="line">  Point_set points;</div><div class="line"></div><div class="line">  std::string fname = argc==1?<a class="code" href="namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/kitten.xyz"</span>) : argv[1];</div><div class="line">  <span class="keywordflow">if</span> (argc &lt; 2)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Usage: "</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">" [input.xyz/off/ply/las]"</span> &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt;<span class="stringliteral">"Running "</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">" data/kitten.xyz -1\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::ifstream stream (fname, std::ios_base::binary);</div><div class="line">  <span class="keywordflow">if</span> (!stream)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  stream &gt;&gt; points;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Read "</span> &lt;&lt; points.size () &lt;&lt; <span class="stringliteral">" point(s)"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">if</span> (points.empty())</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line"></div></div><!-- fragment --> <h1><a class="anchor" id="TutorialsReconstruction_preprocessing"></a>
Preprocessing</h1>
<p>Because reconstruction algorithms have some specific requirements that point clouds do not always meet, some preprocessing might be necessary to yield the best results.</p>
<p>Note that this <em>preprocessing</em> step is optional: when the input point cloud has no imperfections, reconstruction can be applied to it without any preprocessing.</p>
<p><a class="anchor" id="fig__TutorialsReconstructionFigPreprocessing"></a></p><div class="image">
<img src="reconstruction_preproc.png" alt="reconstruction_preproc.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_reconstruction.html#fig__TutorialsReconstructionFigPreprocessing">Figure 0.3</a> Comparison of advancing front reconstruction output using different preprocessing on the same input. The smooth point cloud was generated using <em>jet smoothing</em>; the simplified point cloud was generated using <em>grid simplification</em>.  </div> <br /> 
<h2><a class="anchor" id="TutorialsReconstruction_preprocessing_outliers"></a>
Outlier removal</h2>
<p>Some acquisition techniques generate points which are far away from the surface. These points, commonly referred to as "outliers", have no relevance for reconstruction. Using the CGAL reconstruction algorithms on outlier-ridden point clouds produce overly distorted output, it is therefore strongly advised to filter these outliers <em>before</em> performing reconstruction.</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="keyword">typename</span> Point_set::iterator rout_it = CGAL::remove_outliers&lt;CGAL::Sequential_tag&gt;</div><div class="line">    (points,</div><div class="line">     24, <span class="comment">// Number of neighbors considered for evaluation</span></div><div class="line">     points.parameters().threshold_percent (5.0)); <span class="comment">// Percentage of points to remove</span></div><div class="line">  points.remove(rout_it, points.end());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; points.number_of_removed_points()</div><div class="line">            &lt;&lt; <span class="stringliteral">" point(s) are outliers."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Applying point set processing algorithm to a CGAL::Point_set_3</span></div><div class="line">  <span class="comment">// object does not erase the points from memory but place them in</span></div><div class="line">  <span class="comment">// the garbage of the object: memory can be freeed by the user.</span></div><div class="line">  points.collect_garbage();</div><div class="line"></div></div><!-- fragment --> <h2><a class="anchor" id="TutorialsReconstruction_preprocessing_simplification"></a>
Simplification</h2>
<p>Some laser scanners generate points with widely variable sampling. Typically, lines of scan are very densely sampled but the gap between two lines of scan is much larger, leading to an overly massive point cloud with large variations of sampling density. This type of input point cloud might generate imperfect output using algorithms which, in general, only handle small variations of sampling density.</p>
<p>CGAL provides several simplification algorithms. In addition to reducing the size of the input point cloud and therefore decreasing computation time, some of them can help making the input more uniform. This is the case of the function <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga7757ef9b3900e42fde26f5a0ac56e20f">grid_simplify_point_set()</a></code> which defines a grid of a user-specified size and keeps one point per occupied cell.</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="comment">// Compute average spacing using neighborhood of 6 points</span></div><div class="line">  <span class="keywordtype">double</span> spacing = CGAL::compute_average_spacing&lt;CGAL::Sequential_tag&gt; (points, 6);</div><div class="line"></div><div class="line">  <span class="comment">// Simplify using a grid of size 2 * average spacing</span></div><div class="line">  <span class="keyword">typename</span> Point_set::iterator gsim_it = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga7757ef9b3900e42fde26f5a0ac56e20f">CGAL::grid_simplify_point_set</a> (points, 2. * spacing);</div><div class="line">  points.remove(gsim_it, points.end());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; points.number_of_removed_points()</div><div class="line">            &lt;&lt; <span class="stringliteral">" point(s) removed after simplification."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  points.collect_garbage();</div><div class="line"></div></div><!-- fragment --><h2><a class="anchor" id="TutorialsReconstruction_preprocessing_smoothing"></a>
Smoothing</h2>
<p>Although reconstructions via 'Poisson' or 'Scale space' handle noise internally, one may want to get tighter control over the smoothing step. For example, a slightly noisy point cloud can benefit from some reliable smoothing algorithms and be reconstructed via 'Advancing front' which provides relevant properties (oriented mesh with boundaries).</p>
<p>Two functions are provided to smooth a noisy point cloud with a good approximation (i.e. without degrading curvature, for example):</p>
<ul>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga96a3738be3b2b9bd1587af78ae10e67a">jet_smooth_point_set()</a></code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga01192a227578fee0c5676ba6a5e88931">bilateral_smooth_point_set()</a></code></li>
</ul>
<p>These functions directly modify the container:</p>
<div class="fragment"><div class="line"></div><div class="line">  CGAL::jet_smooth_point_set&lt;CGAL::Sequential_tag&gt; (points, 24);</div><div class="line"></div></div><!-- fragment --><h2><a class="anchor" id="TutorialsReconstruction_preprocessing_normal"></a>
Normal Estimation and Orientation</h2>
<p><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Poisson_surface_reconstruction_3.tag:../Poisson_surface_reconstruction_3/" href="../Poisson_surface_reconstruction_3/index.html#Chapter_Poisson_Surface_Reconstruction">Poisson Surface Reconstruction</a> requires points with oriented normal vectors. To apply the algorithm to a raw point cloud, normals must be estimated first, for example with one of these two functions:</p>
<ul>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga721aeb7af4b2d31e08e75bc5d53303cf">pca_estimate_normals()</a></code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga078e25209373cab0e1f3524202489771">jet_estimate_normals()</a></code></li>
</ul>
<p>PCA is faster but jet is more accurate in the presence of high curvatures. These function only estimates the <em>direction</em> of the normals, not their orientation (the orientation of the vectors might not be locally consistent). To properly orient the normals, the following functions can be used:</p>
<ul>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga17c3c558c3799b65bd23fba971a82a5c">mst_orient_normals()</a></code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#gafc3627234666e1fb458e9387e9d5f3c6">scanline_orient_normals()</a></code></li>
</ul>
<p>The first one uses a <em>minimum spanning tree</em> to consistently propagate the orientation of normals in an increasingly large neighborhood. In the case of data with many sharp features and occlusions (which are common in airborne LIDAR data, for example), the second algorithm may produce better results: it takes advantage of point clouds which are ordered into scanlines to estimate the line of sight of each point and thus to orient normals accordingly.</p>
<p>Notice that these can also be used directly on input normals if their orientation is not consistent.</p>
<div class="fragment"><div class="line"></div><div class="line">    CGAL::jet_estimate_normals&lt;CGAL::Sequential_tag&gt;</div><div class="line">      (points, 24); <span class="comment">// Use 24 neighbors</span></div><div class="line"></div><div class="line">    <span class="comment">// Orientation of normals, returns iterator to first unoriented point</span></div><div class="line">    <span class="keyword">typename</span> Point_set::iterator unoriented_points_begin =</div><div class="line">      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga17c3c558c3799b65bd23fba971a82a5c">CGAL::mst_orient_normals</a>(points, 24); <span class="comment">// Use 24 neighbors</span></div><div class="line"></div><div class="line">    points.remove (unoriented_points_begin, points.end());</div><div class="line"></div></div><!-- fragment --> <h1><a class="anchor" id="TutorialsReconstruction_reconstruction"></a>
Reconstruction</h1>
<h2><a class="anchor" id="TutorialsReconstruction_reconstruction_poisson"></a>
Poisson</h2>
<p>Poisson reconstruction consists in computing an implicit function whose gradient matches the input normal vector field: this indicator function has opposite signs inside and outside of the inferred shape (hence the need for closed shapes). This method thus requires normals and produces smooth closed surfaces. It is not appropriate if the surface is expected to interpolate the input points. On the contrary, it performs well if the aim is to approximate a noisy point cloud with a smooth surface.</p>
<div class="fragment"><div class="line"></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point_3&gt;</a> output_mesh;</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Poisson_surface_reconstruction_3.tag:../Poisson_surface_reconstruction_3/" href="../Poisson_surface_reconstruction_3/group__PkgPoissonSurfaceReconstruction3Ref.html#ga2470854cf03552ecee02f11c17024ddf">CGAL::poisson_surface_reconstruction_delaunay</a></div><div class="line">      (points.begin(), points.end(),</div><div class="line">       points.point_map(), points.normal_map(),</div><div class="line">       output_mesh, spacing);</div><div class="line"></div></div><!-- fragment --> <h2><a class="anchor" id="TutorialsReconstruction_reconstruction_advancing"></a>
Advancing Front</h2>
<p>Advancing front is a Delaunay-based approach which interpolates a subset of the input points. It generates triples of point indices which describe the triangular facets of the reconstruction: it uses a priority queue to sequentially pick the Delaunay facet the most likely to be part of the surface, based on a size criterion (to favor the small facets) and an angle criterion (to favor smoothness). Its main virtue is to generate oriented manifold surfaces with boundaries: contrary to Poisson, it does not require normals and is not bound to reconstruct closed shapes. However, it requires preprocessing if the point cloud is noisy.</p>
<p>The <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Advancing_front_surface_reconstruction.tag:../Advancing_front_surface_reconstruction/" href="../Advancing_front_surface_reconstruction/index.html#Chapter_Advancing_Front_Surface_Reconstruction">Advancing Front</a> package provides several ways of constructing the function. Here is a simple example:</p>
<div class="fragment"><div class="line"></div><div class="line">    <span class="keyword">typedef</span> std::array&lt;std::size_t, 3&gt; Facet; <span class="comment">// Triple of indices</span></div><div class="line"></div><div class="line">    std::vector&lt;Facet&gt; facets;</div><div class="line"></div><div class="line">    <span class="comment">// The function is called using directly the points raw iterators</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Advancing_front_surface_reconstruction.tag:../Advancing_front_surface_reconstruction/" href="../Advancing_front_surface_reconstruction/group__PkgAdvancingFrontSurfaceReconstructionRef.html#gaa2b1f41291920247fd5c6ef7c09f70a4">CGAL::advancing_front_surface_reconstruction</a>(points.points().begin(),</div><div class="line">                                                 points.points().end(),</div><div class="line">                                                 std::back_inserter(facets));</div><div class="line">    std::cout &lt;&lt; facets.size ()</div><div class="line">              &lt;&lt; <span class="stringliteral">" facet(s) generated by reconstruction."</span> &lt;&lt; std::endl;</div><div class="line"></div></div><!-- fragment --> <h2><a class="anchor" id="TutorialsReconstruction_reconstruction_scale_space"></a>
Scale Space</h2>
<p>Scale space reconstruction aims at producing a surface which interpolates the input points (interpolant) while offering some robustness to noise. More specifically, it first applies several times a smoothing filter (such as Jet Smoothing) to the input point set to produce a scale space; then, the smoothest scale is meshed (using for example the Advancing Front mesher); finally, the resulting connectivity between smoothed points is propagated to the original raw input point set. This method is the right choice if the input point cloud is noisy but the user still wants the surface to pass exactly through the points.</p>
<div class="fragment"><div class="line"></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Scale_space_reconstruction_3.tag:../Scale_space_reconstruction_3/" href="../Scale_space_reconstruction_3/classCGAL_1_1Scale__space__surface__reconstruction__3.html">CGAL::Scale_space_surface_reconstruction_3&lt;Kernel&gt;</a> reconstruct</div><div class="line">      (points.points().begin(), points.points().end());</div><div class="line"></div><div class="line">    <span class="comment">// Smooth using 4 iterations of Jet Smoothing</span></div><div class="line">    reconstruct.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Scale_space_reconstruction_3.tag:../Scale_space_reconstruction_3/" href="../Scale_space_reconstruction_3/classCGAL_1_1Scale__space__surface__reconstruction__3.html#acf5262fc2bb55fe76d85f2e541a5b6ab">increase_scale</a> (4, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Scale_space_reconstruction_3.tag:../Scale_space_reconstruction_3/" href="../Scale_space_reconstruction_3/classCGAL_1_1Scale__space__reconstruction__3_1_1Jet__smoother.html">CGAL::Scale_space_reconstruction_3::Jet_smoother&lt;Kernel&gt;</a>());</div><div class="line">    <span class="comment">// Mesh with the Advancing Front mesher with a maximum facet length of 0.5</span></div><div class="line">    reconstruct.reconstruct_surface (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Scale_space_reconstruction_3.tag:../Scale_space_reconstruction_3/" href="../Scale_space_reconstruction_3/classCGAL_1_1Scale__space__reconstruction__3_1_1Advancing__front__mesher.html">CGAL::Scale_space_reconstruction_3::Advancing_front_mesher&lt;Kernel&gt;</a>(0.5));</div><div class="line"></div></div><!-- fragment --> <h1><a class="anchor" id="TutorialsReconstruction_postprocessing"></a>
Output and Postprocessing</h1>
<p>Each of these methods produce a triangle mesh stored in different ways. If this output mesh is hampered by defects such as holes or self-intersections, CGAL provide several algorithms to post-process it (hole filling, remeshing, etc.) in the package <a class="el" href="packages.html#PkgPolygonMeshProcessing">Polygon Mesh Processing</a>.</p>
<p>We do not discuss these functions here as there are many postprocessing possibilities whose relevance strongly depends on the user's expectations on the output mesh.</p>
<p>The mesh (postprocessed or not) can easily be saved in the PLY format (here, using the binary variant):</p>
<div class="fragment"><div class="line"></div><div class="line">    std::ofstream f (<span class="stringliteral">"out_poisson.ply"</span>, std::ios_base::binary);</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (f);</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a>(f, output_mesh);</div><div class="line">    f.close ();</div><div class="line"></div></div><!-- fragment --><p> A polygon soup can also be saved in the OFF format by iterating on the points and faces:</p>
<div class="fragment"><div class="line"></div><div class="line">    std::ofstream f (<span class="stringliteral">"out_sp.off"</span>);</div><div class="line">    f &lt;&lt; <span class="stringliteral">"OFF"</span> &lt;&lt; std::endl &lt;&lt; points.size () &lt;&lt; <span class="stringliteral">" "</span></div><div class="line">      &lt;&lt; reconstruct.number_of_facets() &lt;&lt; <span class="stringliteral">" 0"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">for</span> (Point_set::Index idx : points)</div><div class="line">      f &lt;&lt; points.point (idx) &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; facet : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL.html#a266177f3e138c748f9906f7abb76320b">CGAL::make_range</a> (reconstruct.facets_begin(), reconstruct.facets_end()))</div><div class="line">      f &lt;&lt; <span class="stringliteral">"3 "</span>&lt;&lt; facet &lt;&lt; std::endl;</div><div class="line">    f.close ();</div><div class="line"></div></div><!-- fragment --><p> Finally, if the polygon soup can be converted into a polygon mesh, it can also be saved directly in the OFF format using the stream operator:</p>
<div class="fragment"><div class="line"></div><div class="line">    <span class="comment">// copy points for random access</span></div><div class="line">    std::vector&lt;Point_3&gt; vertices;</div><div class="line">    vertices.reserve (points.size());</div><div class="line">    std::copy (points.points().begin(), points.points().end(), std::back_inserter (vertices));</div><div class="line"></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point_3&gt;</a> output_mesh;</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__repairing__grp.html#ga2ba9722ec8472a1455107ffce7145e46">CGAL::Polygon_mesh_processing::polygon_soup_to_polygon_mesh</a> (vertices, facets, output_mesh);</div><div class="line">    std::ofstream f (<span class="stringliteral">"out_af.off"</span>);</div><div class="line">    f &lt;&lt; output_mesh;</div><div class="line">    f.close ();</div><div class="line"></div></div><!-- fragment --> <h1><a class="anchor" id="TutorialsReconstruction_recap"></a>
Full Code Example</h1>
<p>All the code snippets used in this tutorial can be assembled to create a full algorithm pipeline (provided the correct <em>includes</em> are used). We give a full code example which achieves all the steps described in this tutorial. The reconstruction method can be selected by the user at runtime with the second argument.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3/IO.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/remove_outliers.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/grid_simplify_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/jet_smooth_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/jet_estimate_normals.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/mst_orient_normals.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/poisson_surface_reconstruction.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Advancing_front_surface_reconstruction.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Scale_space_surface_reconstruction_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Scale_space_reconstruction_3/Jet_smoother.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Scale_space_reconstruction_3/Advancing_front_mesher.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/polygon_soup_to_polygon_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point_3;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector_3;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Sphere__3.html">Kernel::Sphere_3</a> Sphere_3;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3&lt;Point_3, Vector_3&gt;</a> Point_set;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line"></div><div class="line">  Point_set points;</div><div class="line"></div><div class="line">  std::string fname = argc==1?<a class="code" href="namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/kitten.xyz"</span>) : argv[1];</div><div class="line">  <span class="keywordflow">if</span> (argc &lt; 2)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Usage: "</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">" [input.xyz/off/ply/las]"</span> &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt;<span class="stringliteral">"Running "</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">" data/kitten.xyz -1\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::ifstream stream (fname, std::ios_base::binary);</div><div class="line">  <span class="keywordflow">if</span> (!stream)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  stream &gt;&gt; points;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Read "</span> &lt;&lt; points.size () &lt;&lt; <span class="stringliteral">" point(s)"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">if</span> (points.empty())</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">typename</span> Point_set::iterator rout_it = CGAL::remove_outliers&lt;CGAL::Sequential_tag&gt;</div><div class="line">    (points,</div><div class="line">     24, <span class="comment">// Number of neighbors considered for evaluation</span></div><div class="line">     points.parameters().threshold_percent (5.0)); <span class="comment">// Percentage of points to remove</span></div><div class="line">  points.remove(rout_it, points.end());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; points.number_of_removed_points()</div><div class="line">            &lt;&lt; <span class="stringliteral">" point(s) are outliers."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Applying point set processing algorithm to a CGAL::Point_set_3</span></div><div class="line">  <span class="comment">// object does not erase the points from memory but place them in</span></div><div class="line">  <span class="comment">// the garbage of the object: memory can be freeed by the user.</span></div><div class="line">  points.collect_garbage();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Compute average spacing using neighborhood of 6 points</span></div><div class="line">  <span class="keywordtype">double</span> spacing = CGAL::compute_average_spacing&lt;CGAL::Sequential_tag&gt; (points, 6);</div><div class="line"></div><div class="line">  <span class="comment">// Simplify using a grid of size 2 * average spacing</span></div><div class="line">  <span class="keyword">typename</span> Point_set::iterator gsim_it = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga7757ef9b3900e42fde26f5a0ac56e20f">CGAL::grid_simplify_point_set</a> (points, 2. * spacing);</div><div class="line">  points.remove(gsim_it, points.end());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; points.number_of_removed_points()</div><div class="line">            &lt;&lt; <span class="stringliteral">" point(s) removed after simplification."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  points.collect_garbage();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  CGAL::jet_smooth_point_set&lt;CGAL::Sequential_tag&gt; (points, 24);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> reconstruction_choice</div><div class="line">    = argc==1? -1 : (argc &lt; 3 ? 0 : atoi(argv[2]));</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (reconstruction_choice == 0 || reconstruction_choice==-1) <span class="comment">// Poisson</span></div><div class="line">  {</div><div class="line"></div><div class="line">    CGAL::jet_estimate_normals&lt;CGAL::Sequential_tag&gt;</div><div class="line">      (points, 24); <span class="comment">// Use 24 neighbors</span></div><div class="line"></div><div class="line">    <span class="comment">// Orientation of normals, returns iterator to first unoriented point</span></div><div class="line">    <span class="keyword">typename</span> Point_set::iterator unoriented_points_begin =</div><div class="line">      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga17c3c558c3799b65bd23fba971a82a5c">CGAL::mst_orient_normals</a>(points, 24); <span class="comment">// Use 24 neighbors</span></div><div class="line"></div><div class="line">    points.remove (unoriented_points_begin, points.end());</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point_3&gt;</a> output_mesh;</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Poisson_surface_reconstruction_3.tag:../Poisson_surface_reconstruction_3/" href="../Poisson_surface_reconstruction_3/group__PkgPoissonSurfaceReconstruction3Ref.html#ga2470854cf03552ecee02f11c17024ddf">CGAL::poisson_surface_reconstruction_delaunay</a></div><div class="line">      (points.begin(), points.end(),</div><div class="line">       points.point_map(), points.normal_map(),</div><div class="line">       output_mesh, spacing);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    std::ofstream f (<span class="stringliteral">"out_poisson.ply"</span>, std::ios_base::binary);</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (f);</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a>(f, output_mesh);</div><div class="line">    f.close ();</div><div class="line"></div><div class="line">  }</div><div class="line">  <span class="keywordflow">if</span> (reconstruction_choice == 1 || reconstruction_choice==-1) <span class="comment">// Advancing front</span></div><div class="line">  {</div><div class="line"></div><div class="line">    <span class="keyword">typedef</span> std::array&lt;std::size_t, 3&gt; Facet; <span class="comment">// Triple of indices</span></div><div class="line"></div><div class="line">    std::vector&lt;Facet&gt; facets;</div><div class="line"></div><div class="line">    <span class="comment">// The function is called using directly the points raw iterators</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Advancing_front_surface_reconstruction.tag:../Advancing_front_surface_reconstruction/" href="../Advancing_front_surface_reconstruction/group__PkgAdvancingFrontSurfaceReconstructionRef.html#gaa2b1f41291920247fd5c6ef7c09f70a4">CGAL::advancing_front_surface_reconstruction</a>(points.points().begin(),</div><div class="line">                                                 points.points().end(),</div><div class="line">                                                 std::back_inserter(facets));</div><div class="line">    std::cout &lt;&lt; facets.size ()</div><div class="line">              &lt;&lt; <span class="stringliteral">" facet(s) generated by reconstruction."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// copy points for random access</span></div><div class="line">    std::vector&lt;Point_3&gt; vertices;</div><div class="line">    vertices.reserve (points.size());</div><div class="line">    std::copy (points.points().begin(), points.points().end(), std::back_inserter (vertices));</div><div class="line"></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point_3&gt;</a> output_mesh;</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__repairing__grp.html#ga2ba9722ec8472a1455107ffce7145e46">CGAL::Polygon_mesh_processing::polygon_soup_to_polygon_mesh</a> (vertices, facets, output_mesh);</div><div class="line">    std::ofstream f (<span class="stringliteral">"out_af.off"</span>);</div><div class="line">    f &lt;&lt; output_mesh;</div><div class="line">    f.close ();</div><div class="line"></div><div class="line">  }</div><div class="line">  <span class="keywordflow">if</span> (reconstruction_choice == 2 || reconstruction_choice==-1) <span class="comment">// Scale space</span></div><div class="line">  {</div><div class="line"></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Scale_space_reconstruction_3.tag:../Scale_space_reconstruction_3/" href="../Scale_space_reconstruction_3/classCGAL_1_1Scale__space__surface__reconstruction__3.html">CGAL::Scale_space_surface_reconstruction_3&lt;Kernel&gt;</a> reconstruct</div><div class="line">      (points.points().begin(), points.points().end());</div><div class="line"></div><div class="line">    <span class="comment">// Smooth using 4 iterations of Jet Smoothing</span></div><div class="line">    reconstruct.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Scale_space_reconstruction_3.tag:../Scale_space_reconstruction_3/" href="../Scale_space_reconstruction_3/classCGAL_1_1Scale__space__surface__reconstruction__3.html#acf5262fc2bb55fe76d85f2e541a5b6ab">increase_scale</a> (4, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Scale_space_reconstruction_3.tag:../Scale_space_reconstruction_3/" href="../Scale_space_reconstruction_3/classCGAL_1_1Scale__space__reconstruction__3_1_1Jet__smoother.html">CGAL::Scale_space_reconstruction_3::Jet_smoother&lt;Kernel&gt;</a>());</div><div class="line">    <span class="comment">// Mesh with the Advancing Front mesher with a maximum facet length of 0.5</span></div><div class="line">    reconstruct.reconstruct_surface (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Scale_space_reconstruction_3.tag:../Scale_space_reconstruction_3/" href="../Scale_space_reconstruction_3/classCGAL_1_1Scale__space__reconstruction__3_1_1Advancing__front__mesher.html">CGAL::Scale_space_reconstruction_3::Advancing_front_mesher&lt;Kernel&gt;</a>(0.5));</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    std::ofstream f (<span class="stringliteral">"out_sp.off"</span>);</div><div class="line">    f &lt;&lt; <span class="stringliteral">"OFF"</span> &lt;&lt; std::endl &lt;&lt; points.size () &lt;&lt; <span class="stringliteral">" "</span></div><div class="line">      &lt;&lt; reconstruct.number_of_facets() &lt;&lt; <span class="stringliteral">" 0"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">for</span> (Point_set::Index idx : points)</div><div class="line">      f &lt;&lt; points.point (idx) &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; facet : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL.html#a266177f3e138c748f9906f7abb76320b">CGAL::make_range</a> (reconstruct.facets_begin(), reconstruct.facets_end()))</div><div class="line">      f &lt;&lt; <span class="stringliteral">"3 "</span>&lt;&lt; facet &lt;&lt; std::endl;</div><div class="line">    f.close ();</div><div class="line"></div><div class="line">  }</div><div class="line">  <span class="keywordflow">else</span> <span class="comment">// Handle error</span></div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: invalid reconstruction id: "</span> &lt;&lt; reconstruction_choice &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="TutorialsReconstruction_pipeline"></a>
Full Pipeline Images</h1>
<p>The following figure an example of a full reconstruction pipeline applied to a bear statue (courtesy <em>EPFL Computer Graphics and Geometry Laboratory</em> <a class="el" href="citelist.html#CITEREF_cgal:e-esmr">[5]</a>). Two mesh processing algorithms (hole filling and isotropic remeshing) are also applied (refer to the chapter <a class="el" href="packages.html#PkgPolygonMeshProcessing">Polygon Mesh Processing</a> for more information).</p>
<p><a class="anchor" id="fig__TutorialsReconstructionFigFull"></a></p><div class="image">
<img src="reconstruction_pipeline.png" alt="reconstruction_pipeline.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_reconstruction.html#fig__TutorialsReconstructionFigFull">Figure 0.4</a> Full reconstruction pipeline (with close-ups).  </div> <br />  
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Aug 9 2022 14:27:18 for CGAL 5.6 - Manual by
    <a href="https://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>
</html>

</html>
