<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Isosurfacing_3/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 5.6 - 3D Isosurfacing: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//&amp;lt;![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      }
  }
}
);
//]]&amp;gt;
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.6 - 3D Isosurfacing
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Isosurfacing3"></a>  </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Author</dt><dd>Julian Stahl and Daniel Zint</dd></dl>
<p><a class="anchor" id="fig__isosurfacing_bunny_offset"></a></p><center> <div class="image">
<img src="bunny_offset.gif" style="max-width:50%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__isosurfacing_bunny_offset">Figure 60.1</a> Different isovalues of a bunny.  </div> <br /> 
<h1><a class="anchor" id="secmyintroduction"></a>
Introduction</h1>
<p>This package provides methods to compute a surface mesh representing an isosurface of a 3-dimensional scalar field. An isosurface is defined as the surface on which the value of this field is equal to a given constant, i.e. the isovalue. Depending on the isosurfacing method and the input data structure, the result is either a triangular, quadrilateral, or higher order polygonal indexed face set.</p>
<h1><a class="anchor" id="secmyalgorithms"></a>
Algorithms</h1>
<p>There are multiple algorithms to extract isosurfaces. This package contains Marching Cubes, topologically correct Marching Cubes, and Dual Contouring.</p>
<h2><a class="anchor" id="subsecmc"></a>
Marching Cubes (MC)</h2>
<p>MC processes all cells of the input domain individually. Each cell corner gets a sign (+/-) to indicate if it is above or below the isovalue. A new vertex is created on every cell edge where the sign changes, i.e. the isosurface is intersected. The vertex position is computed via linear interpolation of the scalar values of the incident corners. Depending on the configuration of signs at the corners the resulting vertices are connected to form triangles within the cell.</p>
<p>MC can process any input data structure that consists of hexahedral cells. In case of a conforming grid, MC produces a triangle mesh that is manifold in most scenarios. If the mesh is manifold and the isosurface does not intersect the domain boundaries, the mesh is also watertight. Compared to other approaches the algorithm often generates more and many thin triangles with acute angles. MC does not preserve sharp features of the input data.</p>
<p><a class="anchor" id="fig__isosurfacing_mc_cases"></a></p><center> <div class="image">
<img src="mc_cases.png" style="max-width:70%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__isosurfacing_mc_cases">Figure 60.2</a> Some example cases of Marching Cubes.  </div> <br /> 
<h2><a class="anchor" id="subsectmc"></a>
Topologically correct Marching Cubes (TMC)</h2>
<p>This algorithm is an extension to MC and provides additional guarantees for the output. It generates a mesh that is homeomorphic to the trilinear interpolant of the input function inside each cube. This means that the mesh can accurately represent small complex features. For example a tunnel of the isosurface within a single cell can be topologically resolved. Furthermore, the mesh is guaranteed to be manifold and watertight, as long as the isosurface does not intersect the domain boundaries.</p>
<p>This algorithm is based on the following paper:</p>
<p>Roberto Grosso: Construction of Topologically Correct and Manifold Isosurfaces. Computer Graphics Forum 35(5):187-196 - August 2016</p>
<h2><a class="anchor" id="subsecdc"></a>
Dual Contouring (DC)</h2>
<p>DC creates one vertex in every cell that is intersected by the isosurface. Next, a face is created for each edge that intersects the isosurface, by connecting the vertices of the incident cells. For a uniform hexahedral grid, this results in a quadrilateral mesh.</p>
<p>The classical DC method requires the gradient of the scalar field. The provided domain therefore has to implement the concept <code><a class="el" href="classIsosurfacingDomainWithGradient.html" title="The concept IsosurfacingDomainWithGradient describes the set of requirements to be fulfilled by any c...">IsosurfacingDomainWithGradient</a></code>. All default domain implementations do this but assume the gradient to be zero if it is not provided as an additional parameter. Thus, for using the classical DC, the gradient has to be defined by the user. Alternatively, there are also some default gradient functions implemented, such as <code>Finite_difference_gradient</code> and <code>Explicit_cartesian_grid_gradient</code>.</p>
<p>Different versions of DC compute the vertex positions differently. Therefore, the vertex positioning is configurable with an optional parameter passed to the function. Some of them do not require the gradient and therefore even work with the zero gradient.</p>
<p>Dual Contouring works on any domain but does not guarantee a manifold or watertight mesh. It creates less faces than Marching Cubes. Another advantage of DC over MC is the ability to represent sharp edges.</p>
<p><a class="anchor" id="fig__isosurfacing_iwp_dc"></a></p><center> <div class="image">
<img src="iwp_dc.png" style="max-width:40%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__isosurfacing_iwp_dc">Figure 60.3</a> Isosurface of the IWP function generated by Dual Contouring.  </div> <br /> 
<h2><a class="anchor" id="subseccomparison"></a>
Comparison</h2>
<table class="doxtable">
<tr>
<th>Algorithm </th><th>Domains </th><th>Faces </th><th>Manifold </th><th>Watertight* </th><th>Topologically correct  </th></tr>
<tr>
<td>MC </td><td>Hexahedral </td><td>Triangles </td><td>no </td><td>no </td><td>no </td></tr>
<tr>
<td>TMC </td><td>Hexahedral </td><td>Triangles </td><td>yes </td><td>yes </td><td>yes </td></tr>
<tr>
<td>DC </td><td>All </td><td>Polygons </td><td>no </td><td>no </td><td>no </td></tr>
</table>
<p>(* assuming the isosurface does not leave the given bounding box of the domain)</p>
<p><a class="anchor" id="fig__isosurfacing_compare_mc_dc"></a></p><center> <div class="image">
<img src="cube_mc_dc.png" style="max-width:70%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__isosurfacing_compare_mc_dc">Figure 60.4</a> Comparison between a cube generated by Dual Contouring (left) and Marching Cubes (right).  </div> <br /> 
<h1><a class="anchor" id="secmyinterface"></a>
Interface</h1>
<p>Each algorithm is represented by a single functions. The function signature is the same for all algorithms:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Concurrency_tag = Sequential_tag, <span class="keyword">class</span> Domain_, <span class="keyword">class</span> Po<span class="keywordtype">int</span>Range, <span class="keyword">class</span> PolygonRange&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="group__PkgIsosurfacing3Ref.html#gad259ce0aaba83f7bc168ba49047c08b6">marching_cubes</a>(<span class="keyword">const</span> Domain_&amp; domain, <span class="keyword">const</span> <span class="keyword">typename</span> Domain_::FT iso_value,</div><div class="line">                    PointRange&amp; points, PolygonRange&amp; polygons);</div></div><!-- fragment --><p>The input is provided in the form of a <code>domain</code> (see <a class="el" href="index.html#secmydomains">Domains</a>).</p>
<p>The <code>iso_value</code> parameter describes the grid value the isosurface should represent.</p>
<p>The output is in the form of an indexed face set that is written to the two collections <code>points</code> and <code>polygons</code>. The vertex positions are stored as <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__3.html">Point_3</a></code> in <code>points</code>. Each face in <code>polygons</code> is a list of indices pointing into the <code>points</code> collection. Depending on the algorithm, the indexed face set may either store a polygon soup or a topological mesh.</p>
<p>Algorithms can run sequentially on one CPU core or in parallel. The Concurrency_tag is used to specify how the algorithm is executed and is either <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Sequential__tag.html">Sequential_tag</a> or <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__tag.html">Parallel_tag</a>. To enable parallelism, <a class="el" href="namespaceCGAL.html">CGAL</a> needs to be linked with the Intel TBB library. If the parallel version is not availible the sequential version will always be used as a fallback.</p>
<h1><a class="anchor" id="secmydomains"></a>
Domains</h1>
<p>A domain is an object that provides functions to access the input data, its geometry, topology, and optionally its gradient. There are some predefined domain classes that wrap the input data and provide a generalized interface for the algorithm. Users can also define new domains by implementing the <code>Isosurfacing_domain</code> or <code><a class="el" href="classIsosurfacingDomainWithGradient.html" title="The concept IsosurfacingDomainWithGradient describes the set of requirements to be fulfilled by any c...">IsosurfacingDomainWithGradient</a></code> concept.</p>
<h2><a class="anchor" id="mysubsecimplicitdomain"></a>
Implicit cartesian grid domain</h2>
<p>The <code>Implicit_cartesian_grid_domain</code> represents the input function in an implicit form without storing any values. It takes a functor or lambda that computes the value of the function from the position of a vertex as parameter. Additionally, the bounding box and spacing between grid points have to be specified.</p>
<h2><a class="anchor" id="mysubseccartesiandomain"></a>
Explicit cartesian grid domain</h2>
<p>The <code>Explicit_cartesian_grid_domain</code> only takes a <code><a class="el" href="classCGAL_1_1Cartesian__grid__3.html">Cartesian_grid_3</a></code> as parameter. It represents a uniform grid of values that are either computed by the user or read from an <code>Image_3</code>. The constructor of <code><a class="el" href="classCGAL_1_1Cartesian__grid__3.html">Cartesian_grid_3</a></code> needs the number of grid points in each dimension and the bounding box. The values are read and written with <code>value(x, y, z)</code> where x, y, and z are the coordinates of a grid point. Alternatively, all required data can be copied from an <code>Image_3</code>.</p>
<h1><a class="anchor" id="secmybenchmarks"></a>
Performance</h1>
<p><a class="anchor" id="fig__isosurfacing_perf_iwp_mc"></a></p><center> <div class="image">
<object type="image/svg+xml" data="perf_threads_iwp_mc.svg" style="max-width:70%;"></object>
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__isosurfacing_perf_iwp_mc">Figure 60.5</a> <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Scaling.html">Scaling</a> of Marching Cubes with more threads.  </div> <br /> 
<h1><a class="anchor" id="secmyexamples"></a>
Examples</h1>
<h2><a class="anchor" id="myExampleImplicit_domain"></a>
Implicit sphere</h2>
<p>The following example shows the usage of the Marching Cubes algorithm to extract an isosurface. The domain is an <code>Implicit_domain</code> that describes a sphere by the distance to its origin as an implicit function.</p>
<p><br />
<b>File</b> <a class="el" href="Isosurfacing_3_2marching_cubes_implicit_sphere_8cpp-example.html">Isosurfacing_3/marching_cubes_implicit_sphere.cpp</a> </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Bbox_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Implicit_cartesian_grid_domain.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Marching_cubes_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/OFF.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;std::vector&lt;std::size_t&gt;&gt; Polygon_range;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="keyword">const</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html">CGAL::Bbox_3</a> bbox{-1, -1, -1, 1, 1, 1};</div><div class="line">    <span class="keyword">const</span> Vector spacing(0.04f, 0.04f, 0.04f);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> sphere_function = [&amp;](<span class="keyword">const</span> Point&amp; p) { <span class="keywordflow">return</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">std::sqrt</a>(p.x() * p.x() + p.y() * p.y() + p.z() * p.z()); };</div><div class="line"></div><div class="line">    <span class="comment">// create a domain with bounding box [-1, 1]^3 and grid spacing 0.02</span></div><div class="line">    <span class="keyword">auto</span> domain = CGAL::Isosurfacing::create_implicit_cartesian_grid_domain&lt;Kernel&gt;(bbox, spacing, sphere_function);</div><div class="line"></div><div class="line">    <span class="comment">// prepare collections for the result</span></div><div class="line">    Point_range points;</div><div class="line">    Polygon_range polygons;</div><div class="line"></div><div class="line">    <span class="comment">// execute marching cubes with an isovalue of 0.8</span></div><div class="line">    <a class="code" href="group__PkgIsosurfacing3Ref.html#gad259ce0aaba83f7bc168ba49047c08b6">CGAL::Isosurfacing::marching_cubes</a>(domain, 0.8f, points, polygons);</div><div class="line"></div><div class="line">    <span class="comment">// save the result in the OFF format</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result.off"</span>, points, polygons);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="myExampleAll_cube"></a>
Cartesian_grid_3 cube comparison</h2>
<p>The following example compares all provided algorithms to extract an isosurface. The domain is an <code>Cartesian_grid_domain</code> that describes a cube by storing the manhattan distance to its origin in a <code><a class="el" href="classCGAL_1_1Cartesian__grid__3.html">Cartesian_grid_3</a></code>.</p>
<p><br />
<b>File</b> <a class="el" href="Isosurfacing_3_2all_cartesian_cube_8cpp-example.html">Isosurfacing_3/all_cartesian_cube.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian_grid_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Dual_contouring_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Explicit_cartesian_grid_domain.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Marching_cubes_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/OFF.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Cartesian__grid__3.html">CGAL::Cartesian_grid_3&lt;Kernel&gt;</a> Grid;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;std::vector&lt;std::size_t&gt;&gt; Polygon_range;</div><div class="line"></div><div class="line">FT <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gaf3d75d272a29458960987a8f248ec636">sign</a>(FT value) {</div><div class="line">    <span class="keywordflow">return</span> (value &gt; 0) - (value &lt; 0);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// create a cartesian grid with 100^3 grid points and the bounding box [-1, 1]^3</span></div><div class="line">    <span class="keyword">const</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html">CGAL::Bbox_3</a> bbox(-1, -1, -1, 1, 1, 1);</div><div class="line">    std::shared_ptr&lt;Grid&gt; grid = std::make_shared&lt;Grid&gt;(7, 7, 7, bbox);</div><div class="line"></div><div class="line">    <span class="comment">// calculate the value at all grid points</span></div><div class="line">    <span class="keywordflow">for</span> (std::size_t x = 0; x &lt; grid-&gt;xdim(); x++) {</div><div class="line">        <span class="keywordflow">for</span> (std::size_t y = 0; y &lt; grid-&gt;ydim(); y++) {</div><div class="line">            <span class="keywordflow">for</span> (std::size_t z = 0; z &lt; grid-&gt;zdim(); z++) {</div><div class="line"></div><div class="line">                <span class="keyword">const</span> FT pos_x = x * grid-&gt;get_spacing()[0] + bbox.xmin();</div><div class="line">                <span class="keyword">const</span> FT pos_y = y * grid-&gt;get_spacing()[1] + bbox.ymin();</div><div class="line">                <span class="keyword">const</span> FT pos_z = z * grid-&gt;get_spacing()[2] + bbox.zmin();</div><div class="line"></div><div class="line">                <span class="comment">// manhattan distance to the origin</span></div><div class="line">                grid-&gt;value(x, y, z) = std::max({<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(pos_x), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(pos_y), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(pos_z)});</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> cube_gradient = [](<span class="keyword">const</span> Point&amp; p) {</div><div class="line">        <span class="comment">// the normal depends on the side of the cube</span></div><div class="line">        <span class="keyword">const</span> FT max_value = std::max({<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.x()), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.y()), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.z())});</div><div class="line"></div><div class="line">        Vector g(0, 0, 0);</div><div class="line">        <span class="keywordflow">if</span> (max_value == <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.x())) {</div><div class="line">            g += Vector(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gaf3d75d272a29458960987a8f248ec636">sign</a>(p.x()), 0, 0);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> (max_value == <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.y())) {</div><div class="line">            g += Vector(0, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gaf3d75d272a29458960987a8f248ec636">sign</a>(p.y()), 0);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> (max_value == <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.z())) {</div><div class="line">            g += Vector(0, 0, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gaf3d75d272a29458960987a8f248ec636">sign</a>(p.z()));</div><div class="line">        }</div><div class="line">        <span class="keyword">const</span> FT length_sq = g.squared_length();</div><div class="line">        <span class="keywordflow">if</span> (length_sq &gt; 0.00001) {</div><div class="line">            g /= CGAL::approximate_sqrt(length_sq);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> g;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// create a domain from the grid</span></div><div class="line">    <span class="keyword">auto</span> domain = CGAL::Isosurfacing::create_explicit_cartesian_grid_domain&lt;Kernel&gt;(grid, cube_gradient);</div><div class="line"></div><div class="line">    <span class="comment">// prepare collections for the results</span></div><div class="line">    Point_range points_mc, points_dc;</div><div class="line">    Polygon_range polygons_mc, polygons_dc;</div><div class="line"></div><div class="line">    <span class="comment">// execute topologically correct marching cubes and dual contouring with an isovalue of 0.8</span></div><div class="line">    <a class="code" href="group__PkgIsosurfacing3Ref.html#gad259ce0aaba83f7bc168ba49047c08b6">CGAL::Isosurfacing::marching_cubes</a>(domain, 0.88, points_mc, polygons_mc);</div><div class="line">    <a class="code" href="group__PkgIsosurfacing3Ref.html#gad4b618b5b6e5f914022485c979094b7a">CGAL::Isosurfacing::dual_contouring</a>(domain, 0.88, points_dc, polygons_dc);</div><div class="line"></div><div class="line">    <span class="comment">// save the results in the OFF format</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result_mc.off"</span>, points_mc, polygons_mc);</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result_dc.off"</span>, points_dc, polygons_dc);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="myExampleImage"></a>
Image_3</h2>
<p>The following example shows how to load data from an <code>Image_3</code>.</p>
<p><br />
<b>File</b> <a class="el" href="Isosurfacing_3_2marching_cubes_inrimage_8cpp-example.html">Isosurfacing_3/marching_cubes_inrimage.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian_grid_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Explicit_cartesian_grid_domain.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Marching_cubes_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/OFF.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Cartesian__grid__3.html">CGAL::Cartesian_grid_3&lt;Kernel&gt;</a> Grid;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;std::vector&lt;std::size_t&gt;&gt; Polygon_range;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string fname = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"images/skull_2.9.inr"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// load the image</span></div><div class="line">    CGAL::Image_3 image;</div><div class="line">    <span class="keywordflow">if</span> (!image.read(fname)) {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">"Error: Cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// convert it to a cartesian grid</span></div><div class="line">    std::shared_ptr&lt;Grid&gt; grid = std::make_shared&lt;Grid&gt;(image);</div><div class="line"></div><div class="line">    <span class="comment">// create a domain from the grid</span></div><div class="line">    <span class="keyword">auto</span> domain = CGAL::Isosurfacing::create_explicit_cartesian_grid_domain&lt;Kernel&gt;(grid);</div><div class="line"></div><div class="line">    <span class="comment">// prepare collections for the result</span></div><div class="line">    Point_range points;</div><div class="line">    Polygon_range polygons;</div><div class="line"></div><div class="line">    <span class="comment">// execute marching cubes with an isovalue of 2.9</span></div><div class="line">    <a class="code" href="group__PkgIsosurfacing3Ref.html#gad259ce0aaba83f7bc168ba49047c08b6">CGAL::Isosurfacing::marching_cubes</a>(domain, 2.9, points, polygons);</div><div class="line"></div><div class="line">    <span class="comment">// save the result in the OFF format</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result.off"</span>, points, polygons);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="myExampleMeshOffset"></a>
Offset mesh</h2>
<p>The following example shows how to compute an offset mesh. The original mesh is passed to an <code>AABB_tree</code> to allow fast distance queries. With the use of <code>Side_of_triangle_mesh</code> the sign of the distance function is flipped inside the mesh.</p>
<p><br />
<b>File</b> <a class="el" href="Isosurfacing_3_2dual_contouring_mesh_offset_8cpp-example.html">Isosurfacing_3/dual_contouring_mesh_offset.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/AABB_face_graph_triangle_primitive.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/AABB_traits.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/AABB_tree.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Bbox_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Dual_contouring_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Implicit_cartesian_grid_domain.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Side_of_triangle_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/OFF.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> CGAL::Surface_mesh&lt;Point&gt; Mesh;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> CGAL::AABB_face_graph_triangle_primitive&lt;Mesh&gt; Primitive;</div><div class="line"><span class="keyword">typedef</span> CGAL::AABB_traits&lt;Kernel, Primitive&gt; Traits;</div><div class="line"><span class="keyword">typedef</span> CGAL::AABB_tree&lt;Traits&gt; Tree;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;std::vector&lt;std::size_t&gt;&gt; Polygon_range;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="keyword">const</span> std::string input_name = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/cross.off"</span>);</div><div class="line">    <span class="keyword">const</span> Vector grid_spacing(0.1, 0.1, 0.1);</div><div class="line">    <span class="keyword">const</span> FT offset_value = 0.2;</div><div class="line"></div><div class="line">    Mesh mesh_input;</div><div class="line">    <span class="keywordflow">if</span> (!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga7396bef8d41fe287d52d19ddbb83a3e4">CGAL::IO::read_OFF</a>(input_name, mesh_input)) {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">"Could not read mesh"</span> &lt;&lt; std::endl;</div><div class="line">        exit(-1);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// compute bounding box</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html">CGAL::Bbox_3</a> aabb_grid = CGAL::Polygon_mesh_processing::bbox(mesh_input);</div><div class="line">    Vector aabb_increase_vec = Vector(offset_value + 0.01, offset_value + 0.01, offset_value + 0.01);</div><div class="line">    aabb_grid += (Point(aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a3f5e323700e1509624a02d151237cc4c">xmax</a>(), aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a9d06f61bd89faa841e011ff53edf745f">ymax</a>(), aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a98def8b9515f31ded759d781969ddaf6">zmax</a>()) + aabb_increase_vec).bbox();</div><div class="line">    aabb_grid += (Point(aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#aab574470a2591f187553ca1166e682e1">xmin</a>(), aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a2088e16a1f0a20e011e5b94c2e9c222a">ymin</a>(), aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a6c55430abc7fda54571cf1075c7f2f8b">zmin</a>()) - aabb_increase_vec).bbox();</div><div class="line"></div><div class="line">    <span class="comment">// construct AABB tree</span></div><div class="line">    Tree tree(mesh_input.faces_begin(), mesh_input.faces_end(), mesh_input);</div><div class="line"></div><div class="line">    CGAL::Side_of_triangle_mesh&lt;Mesh, CGAL::GetGeomTraits&lt;Mesh&gt;::type&gt; sotm(mesh_input);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">auto</span> mesh_distance = [&amp;tree](<span class="keyword">const</span> Point&amp; p) {</div><div class="line">        <span class="keyword">const</span> Point&amp; x = tree.closest_point(p);</div><div class="line">        <span class="keywordflow">return</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">std::sqrt</a>((p - x).squared_length());</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> mesh_normal = [&amp;tree](<span class="keyword">const</span> Point&amp; p) {</div><div class="line">        <span class="keyword">const</span> Point&amp; x = tree.closest_point(p);</div><div class="line">        <span class="keyword">const</span> Vector n = p - x;</div><div class="line">        <span class="keywordflow">return</span> n / <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">std::sqrt</a>(n.squared_length());</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// create a domain with bounding box [-1, 1]^3 and grid spacing 0.02</span></div><div class="line">    <span class="keyword">auto</span> domain = CGAL::Isosurfacing::create_implicit_cartesian_grid_domain&lt;Kernel&gt;(aabb_grid, grid_spacing,</div><div class="line">                                                                                    mesh_distance, mesh_normal);</div><div class="line"></div><div class="line">    Point_range points;</div><div class="line">    Polygon_range polygons;</div><div class="line"></div><div class="line">    <a class="code" href="group__PkgIsosurfacing3Ref.html#gad4b618b5b6e5f914022485c979094b7a">CGAL::Isosurfacing::dual_contouring</a>(domain, offset_value, points, polygons);</div><div class="line"></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result.off"</span>, points, polygons);</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Nov 18 2022 12:07:25 for CGAL 5.6 - 3D Isosurfacing by
    <a href="https://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>
</html><html xmlns="http://www.w3.org/1999/xhtml"><body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.6 - 3D Isosurfacing
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Isosurfacing3"></a>  </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Author</dt><dd>Julian Stahl and Daniel Zint</dd></dl>
<p><a class="anchor" id="fig__isosurfacing_bunny_offset"></a></p><center> <div class="image">
<img src="bunny_offset.gif" style="max-width:50%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__isosurfacing_bunny_offset">Figure 60.1</a> Different isovalues of a bunny.  </div> <br /> 
<h1><a class="anchor" id="secmyintroduction"></a>
Introduction</h1>
<p>This package provides methods to compute a surface mesh representing an isosurface of a 3-dimensional scalar field. An isosurface is defined as the surface on which the value of this field is equal to a given constant, i.e. the isovalue. Depending on the isosurfacing method and the input data structure, the result is either a triangular, quadrilateral, or higher order polygonal indexed face set.</p>
<h1><a class="anchor" id="secmyalgorithms"></a>
Algorithms</h1>
<p>There are multiple algorithms to extract isosurfaces. This package contains Marching Cubes, topologically correct Marching Cubes, and Dual Contouring.</p>
<h2><a class="anchor" id="subsecmc"></a>
Marching Cubes (MC)</h2>
<p>MC processes all cells of the input domain individually. Each cell corner gets a sign (+/-) to indicate if it is above or below the isovalue. A new vertex is created on every cell edge where the sign changes, i.e. the isosurface is intersected. The vertex position is computed via linear interpolation of the scalar values of the incident corners. Depending on the configuration of signs at the corners the resulting vertices are connected to form triangles within the cell.</p>
<p>MC can process any input data structure that consists of hexahedral cells. In case of a conforming grid, MC produces a triangle mesh that is manifold in most scenarios. If the mesh is manifold and the isosurface does not intersect the domain boundaries, the mesh is also watertight. Compared to other approaches the algorithm often generates more and many thin triangles with acute angles. MC does not preserve sharp features of the input data.</p>
<p><a class="anchor" id="fig__isosurfacing_mc_cases"></a></p><center> <div class="image">
<img src="mc_cases.png" style="max-width:70%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__isosurfacing_mc_cases">Figure 60.2</a> Some example cases of Marching Cubes.  </div> <br /> 
<h2><a class="anchor" id="subsectmc"></a>
Topologically correct Marching Cubes (TMC)</h2>
<p>This algorithm is an extension to MC and provides additional guarantees for the output. It generates a mesh that is homeomorphic to the trilinear interpolant of the input function inside each cube. This means that the mesh can accurately represent small complex features. For example a tunnel of the isosurface within a single cell can be topologically resolved. Furthermore, the mesh is guaranteed to be manifold and watertight, as long as the isosurface does not intersect the domain boundaries.</p>
<p>This algorithm is based on the following paper:</p>
<p>Roberto Grosso: Construction of Topologically Correct and Manifold Isosurfaces. Computer Graphics Forum 35(5):187-196 - August 2016</p>
<h2><a class="anchor" id="subsecdc"></a>
Dual Contouring (DC)</h2>
<p>DC creates one vertex in every cell that is intersected by the isosurface. Next, a face is created for each edge that intersects the isosurface, by connecting the vertices of the incident cells. For a uniform hexahedral grid, this results in a quadrilateral mesh.</p>
<p>The classical DC method requires the gradient of the scalar field. The provided domain therefore has to implement the concept <code><a class="el" href="classIsosurfacingDomainWithGradient.html" title="The concept IsosurfacingDomainWithGradient describes the set of requirements to be fulfilled by any c...">IsosurfacingDomainWithGradient</a></code>. All default domain implementations do this but assume the gradient to be zero if it is not provided as an additional parameter. Thus, for using the classical DC, the gradient has to be defined by the user. Alternatively, there are also some default gradient functions implemented, such as <code>Finite_difference_gradient</code> and <code>Explicit_cartesian_grid_gradient</code>.</p>
<p>Different versions of DC compute the vertex positions differently. Therefore, the vertex positioning is configurable with an optional parameter passed to the function. Some of them do not require the gradient and therefore even work with the zero gradient.</p>
<p>Dual Contouring works on any domain but does not guarantee a manifold or watertight mesh. It creates less faces than Marching Cubes. Another advantage of DC over MC is the ability to represent sharp edges.</p>
<p><a class="anchor" id="fig__isosurfacing_iwp_dc"></a></p><center> <div class="image">
<img src="iwp_dc.png" style="max-width:40%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__isosurfacing_iwp_dc">Figure 60.3</a> Isosurface of the IWP function generated by Dual Contouring.  </div> <br /> 
<h2><a class="anchor" id="subseccomparison"></a>
Comparison</h2>
<table class="doxtable">
<tr>
<th>Algorithm </th><th>Domains </th><th>Faces </th><th>Manifold </th><th>Watertight* </th><th>Topologically correct  </th></tr>
<tr>
<td>MC </td><td>Hexahedral </td><td>Triangles </td><td>no </td><td>no </td><td>no </td></tr>
<tr>
<td>TMC </td><td>Hexahedral </td><td>Triangles </td><td>yes </td><td>yes </td><td>yes </td></tr>
<tr>
<td>DC </td><td>All </td><td>Polygons </td><td>no </td><td>no </td><td>no </td></tr>
</table>
<p>(* assuming the isosurface does not leave the given bounding box of the domain)</p>
<p><a class="anchor" id="fig__isosurfacing_compare_mc_dc"></a></p><center> <div class="image">
<img src="cube_mc_dc.png" style="max-width:70%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__isosurfacing_compare_mc_dc">Figure 60.4</a> Comparison between a cube generated by Dual Contouring (left) and Marching Cubes (right).  </div> <br /> 
<h1><a class="anchor" id="secmyinterface"></a>
Interface</h1>
<p>Each algorithm is represented by a single functions. The function signature is the same for all algorithms:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Concurrency_tag = Sequential_tag, <span class="keyword">class</span> Domain_, <span class="keyword">class</span> Po<span class="keywordtype">int</span>Range, <span class="keyword">class</span> PolygonRange&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="group__PkgIsosurfacing3Ref.html#gad259ce0aaba83f7bc168ba49047c08b6">marching_cubes</a>(<span class="keyword">const</span> Domain_&amp; domain, <span class="keyword">const</span> <span class="keyword">typename</span> Domain_::FT iso_value,</div><div class="line">                    PointRange&amp; points, PolygonRange&amp; polygons);</div></div><!-- fragment --><p>The input is provided in the form of a <code>domain</code> (see <a class="el" href="index.html#secmydomains">Domains</a>).</p>
<p>The <code>iso_value</code> parameter describes the grid value the isosurface should represent.</p>
<p>The output is in the form of an indexed face set that is written to the two collections <code>points</code> and <code>polygons</code>. The vertex positions are stored as <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__3.html">Point_3</a></code> in <code>points</code>. Each face in <code>polygons</code> is a list of indices pointing into the <code>points</code> collection. Depending on the algorithm, the indexed face set may either store a polygon soup or a topological mesh.</p>
<p>Algorithms can run sequentially on one CPU core or in parallel. The Concurrency_tag is used to specify how the algorithm is executed and is either <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Sequential__tag.html">Sequential_tag</a> or <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__tag.html">Parallel_tag</a>. To enable parallelism, <a class="el" href="namespaceCGAL.html">CGAL</a> needs to be linked with the Intel TBB library. If the parallel version is not availible the sequential version will always be used as a fallback.</p>
<h1><a class="anchor" id="secmydomains"></a>
Domains</h1>
<p>A domain is an object that provides functions to access the input data, its geometry, topology, and optionally its gradient. There are some predefined domain classes that wrap the input data and provide a generalized interface for the algorithm. Users can also define new domains by implementing the <code>Isosurfacing_domain</code> or <code><a class="el" href="classIsosurfacingDomainWithGradient.html" title="The concept IsosurfacingDomainWithGradient describes the set of requirements to be fulfilled by any c...">IsosurfacingDomainWithGradient</a></code> concept.</p>
<h2><a class="anchor" id="mysubsecimplicitdomain"></a>
Implicit cartesian grid domain</h2>
<p>The <code>Implicit_cartesian_grid_domain</code> represents the input function in an implicit form without storing any values. It takes a functor or lambda that computes the value of the function from the position of a vertex as parameter. Additionally, the bounding box and spacing between grid points have to be specified.</p>
<h2><a class="anchor" id="mysubseccartesiandomain"></a>
Explicit cartesian grid domain</h2>
<p>The <code>Explicit_cartesian_grid_domain</code> only takes a <code><a class="el" href="classCGAL_1_1Cartesian__grid__3.html">Cartesian_grid_3</a></code> as parameter. It represents a uniform grid of values that are either computed by the user or read from an <code>Image_3</code>. The constructor of <code><a class="el" href="classCGAL_1_1Cartesian__grid__3.html">Cartesian_grid_3</a></code> needs the number of grid points in each dimension and the bounding box. The values are read and written with <code>value(x, y, z)</code> where x, y, and z are the coordinates of a grid point. Alternatively, all required data can be copied from an <code>Image_3</code>.</p>
<h1><a class="anchor" id="secmybenchmarks"></a>
Performance</h1>
<p><a class="anchor" id="fig__isosurfacing_perf_iwp_mc"></a></p><center> <div class="image">
<object type="image/svg+xml" data="perf_threads_iwp_mc.svg" style="max-width:70%;"></object>
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__isosurfacing_perf_iwp_mc">Figure 60.5</a> <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Scaling.html">Scaling</a> of Marching Cubes with more threads.  </div> <br /> 
<h1><a class="anchor" id="secmyexamples"></a>
Examples</h1>
<h2><a class="anchor" id="myExampleImplicit_domain"></a>
Implicit sphere</h2>
<p>The following example shows the usage of the Marching Cubes algorithm to extract an isosurface. The domain is an <code>Implicit_domain</code> that describes a sphere by the distance to its origin as an implicit function.</p>
<p><br />
<b>File</b> <a class="el" href="Isosurfacing_3_2marching_cubes_implicit_sphere_8cpp-example.html">Isosurfacing_3/marching_cubes_implicit_sphere.cpp</a> </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Bbox_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Implicit_cartesian_grid_domain.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Marching_cubes_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/OFF.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;std::vector&lt;std::size_t&gt;&gt; Polygon_range;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="keyword">const</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html">CGAL::Bbox_3</a> bbox{-1, -1, -1, 1, 1, 1};</div><div class="line">    <span class="keyword">const</span> Vector spacing(0.04f, 0.04f, 0.04f);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> sphere_function = [&amp;](<span class="keyword">const</span> Point&amp; p) { <span class="keywordflow">return</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">std::sqrt</a>(p.x() * p.x() + p.y() * p.y() + p.z() * p.z()); };</div><div class="line"></div><div class="line">    <span class="comment">// create a domain with bounding box [-1, 1]^3 and grid spacing 0.02</span></div><div class="line">    <span class="keyword">auto</span> domain = CGAL::Isosurfacing::create_implicit_cartesian_grid_domain&lt;Kernel&gt;(bbox, spacing, sphere_function);</div><div class="line"></div><div class="line">    <span class="comment">// prepare collections for the result</span></div><div class="line">    Point_range points;</div><div class="line">    Polygon_range polygons;</div><div class="line"></div><div class="line">    <span class="comment">// execute marching cubes with an isovalue of 0.8</span></div><div class="line">    <a class="code" href="group__PkgIsosurfacing3Ref.html#gad259ce0aaba83f7bc168ba49047c08b6">CGAL::Isosurfacing::marching_cubes</a>(domain, 0.8f, points, polygons);</div><div class="line"></div><div class="line">    <span class="comment">// save the result in the OFF format</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result.off"</span>, points, polygons);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="myExampleAll_cube"></a>
Cartesian_grid_3 cube comparison</h2>
<p>The following example compares all provided algorithms to extract an isosurface. The domain is an <code>Cartesian_grid_domain</code> that describes a cube by storing the manhattan distance to its origin in a <code><a class="el" href="classCGAL_1_1Cartesian__grid__3.html">Cartesian_grid_3</a></code>.</p>
<p><br />
<b>File</b> <a class="el" href="Isosurfacing_3_2all_cartesian_cube_8cpp-example.html">Isosurfacing_3/all_cartesian_cube.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian_grid_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Dual_contouring_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Explicit_cartesian_grid_domain.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Marching_cubes_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/OFF.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Cartesian__grid__3.html">CGAL::Cartesian_grid_3&lt;Kernel&gt;</a> Grid;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;std::vector&lt;std::size_t&gt;&gt; Polygon_range;</div><div class="line"></div><div class="line">FT <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gaf3d75d272a29458960987a8f248ec636">sign</a>(FT value) {</div><div class="line">    <span class="keywordflow">return</span> (value &gt; 0) - (value &lt; 0);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// create a cartesian grid with 100^3 grid points and the bounding box [-1, 1]^3</span></div><div class="line">    <span class="keyword">const</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html">CGAL::Bbox_3</a> bbox(-1, -1, -1, 1, 1, 1);</div><div class="line">    std::shared_ptr&lt;Grid&gt; grid = std::make_shared&lt;Grid&gt;(7, 7, 7, bbox);</div><div class="line"></div><div class="line">    <span class="comment">// calculate the value at all grid points</span></div><div class="line">    <span class="keywordflow">for</span> (std::size_t x = 0; x &lt; grid-&gt;xdim(); x++) {</div><div class="line">        <span class="keywordflow">for</span> (std::size_t y = 0; y &lt; grid-&gt;ydim(); y++) {</div><div class="line">            <span class="keywordflow">for</span> (std::size_t z = 0; z &lt; grid-&gt;zdim(); z++) {</div><div class="line"></div><div class="line">                <span class="keyword">const</span> FT pos_x = x * grid-&gt;get_spacing()[0] + bbox.xmin();</div><div class="line">                <span class="keyword">const</span> FT pos_y = y * grid-&gt;get_spacing()[1] + bbox.ymin();</div><div class="line">                <span class="keyword">const</span> FT pos_z = z * grid-&gt;get_spacing()[2] + bbox.zmin();</div><div class="line"></div><div class="line">                <span class="comment">// manhattan distance to the origin</span></div><div class="line">                grid-&gt;value(x, y, z) = std::max({<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(pos_x), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(pos_y), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(pos_z)});</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> cube_gradient = [](<span class="keyword">const</span> Point&amp; p) {</div><div class="line">        <span class="comment">// the normal depends on the side of the cube</span></div><div class="line">        <span class="keyword">const</span> FT max_value = std::max({<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.x()), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.y()), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.z())});</div><div class="line"></div><div class="line">        Vector g(0, 0, 0);</div><div class="line">        <span class="keywordflow">if</span> (max_value == <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.x())) {</div><div class="line">            g += Vector(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gaf3d75d272a29458960987a8f248ec636">sign</a>(p.x()), 0, 0);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> (max_value == <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.y())) {</div><div class="line">            g += Vector(0, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gaf3d75d272a29458960987a8f248ec636">sign</a>(p.y()), 0);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> (max_value == <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.z())) {</div><div class="line">            g += Vector(0, 0, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gaf3d75d272a29458960987a8f248ec636">sign</a>(p.z()));</div><div class="line">        }</div><div class="line">        <span class="keyword">const</span> FT length_sq = g.squared_length();</div><div class="line">        <span class="keywordflow">if</span> (length_sq &gt; 0.00001) {</div><div class="line">            g /= CGAL::approximate_sqrt(length_sq);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> g;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// create a domain from the grid</span></div><div class="line">    <span class="keyword">auto</span> domain = CGAL::Isosurfacing::create_explicit_cartesian_grid_domain&lt;Kernel&gt;(grid, cube_gradient);</div><div class="line"></div><div class="line">    <span class="comment">// prepare collections for the results</span></div><div class="line">    Point_range points_mc, points_dc;</div><div class="line">    Polygon_range polygons_mc, polygons_dc;</div><div class="line"></div><div class="line">    <span class="comment">// execute topologically correct marching cubes and dual contouring with an isovalue of 0.8</span></div><div class="line">    <a class="code" href="group__PkgIsosurfacing3Ref.html#gad259ce0aaba83f7bc168ba49047c08b6">CGAL::Isosurfacing::marching_cubes</a>(domain, 0.88, points_mc, polygons_mc);</div><div class="line">    <a class="code" href="group__PkgIsosurfacing3Ref.html#gad4b618b5b6e5f914022485c979094b7a">CGAL::Isosurfacing::dual_contouring</a>(domain, 0.88, points_dc, polygons_dc);</div><div class="line"></div><div class="line">    <span class="comment">// save the results in the OFF format</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result_mc.off"</span>, points_mc, polygons_mc);</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result_dc.off"</span>, points_dc, polygons_dc);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="myExampleImage"></a>
Image_3</h2>
<p>The following example shows how to load data from an <code>Image_3</code>.</p>
<p><br />
<b>File</b> <a class="el" href="Isosurfacing_3_2marching_cubes_inrimage_8cpp-example.html">Isosurfacing_3/marching_cubes_inrimage.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian_grid_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Explicit_cartesian_grid_domain.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Marching_cubes_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/OFF.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Cartesian__grid__3.html">CGAL::Cartesian_grid_3&lt;Kernel&gt;</a> Grid;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;std::vector&lt;std::size_t&gt;&gt; Polygon_range;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string fname = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"images/skull_2.9.inr"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// load the image</span></div><div class="line">    CGAL::Image_3 image;</div><div class="line">    <span class="keywordflow">if</span> (!image.read(fname)) {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">"Error: Cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// convert it to a cartesian grid</span></div><div class="line">    std::shared_ptr&lt;Grid&gt; grid = std::make_shared&lt;Grid&gt;(image);</div><div class="line"></div><div class="line">    <span class="comment">// create a domain from the grid</span></div><div class="line">    <span class="keyword">auto</span> domain = CGAL::Isosurfacing::create_explicit_cartesian_grid_domain&lt;Kernel&gt;(grid);</div><div class="line"></div><div class="line">    <span class="comment">// prepare collections for the result</span></div><div class="line">    Point_range points;</div><div class="line">    Polygon_range polygons;</div><div class="line"></div><div class="line">    <span class="comment">// execute marching cubes with an isovalue of 2.9</span></div><div class="line">    <a class="code" href="group__PkgIsosurfacing3Ref.html#gad259ce0aaba83f7bc168ba49047c08b6">CGAL::Isosurfacing::marching_cubes</a>(domain, 2.9, points, polygons);</div><div class="line"></div><div class="line">    <span class="comment">// save the result in the OFF format</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result.off"</span>, points, polygons);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="myExampleMeshOffset"></a>
Offset mesh</h2>
<p>The following example shows how to compute an offset mesh. The original mesh is passed to an <code>AABB_tree</code> to allow fast distance queries. With the use of <code>Side_of_triangle_mesh</code> the sign of the distance function is flipped inside the mesh.</p>
<p><br />
<b>File</b> <a class="el" href="Isosurfacing_3_2dual_contouring_mesh_offset_8cpp-example.html">Isosurfacing_3/dual_contouring_mesh_offset.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/AABB_face_graph_triangle_primitive.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/AABB_traits.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/AABB_tree.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Bbox_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Dual_contouring_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Implicit_cartesian_grid_domain.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Side_of_triangle_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/OFF.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> CGAL::Surface_mesh&lt;Point&gt; Mesh;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> CGAL::AABB_face_graph_triangle_primitive&lt;Mesh&gt; Primitive;</div><div class="line"><span class="keyword">typedef</span> CGAL::AABB_traits&lt;Kernel, Primitive&gt; Traits;</div><div class="line"><span class="keyword">typedef</span> CGAL::AABB_tree&lt;Traits&gt; Tree;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;std::vector&lt;std::size_t&gt;&gt; Polygon_range;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="keyword">const</span> std::string input_name = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/cross.off"</span>);</div><div class="line">    <span class="keyword">const</span> Vector grid_spacing(0.1, 0.1, 0.1);</div><div class="line">    <span class="keyword">const</span> FT offset_value = 0.2;</div><div class="line"></div><div class="line">    Mesh mesh_input;</div><div class="line">    <span class="keywordflow">if</span> (!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga7396bef8d41fe287d52d19ddbb83a3e4">CGAL::IO::read_OFF</a>(input_name, mesh_input)) {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">"Could not read mesh"</span> &lt;&lt; std::endl;</div><div class="line">        exit(-1);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// compute bounding box</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html">CGAL::Bbox_3</a> aabb_grid = CGAL::Polygon_mesh_processing::bbox(mesh_input);</div><div class="line">    Vector aabb_increase_vec = Vector(offset_value + 0.01, offset_value + 0.01, offset_value + 0.01);</div><div class="line">    aabb_grid += (Point(aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a3f5e323700e1509624a02d151237cc4c">xmax</a>(), aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a9d06f61bd89faa841e011ff53edf745f">ymax</a>(), aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a98def8b9515f31ded759d781969ddaf6">zmax</a>()) + aabb_increase_vec).bbox();</div><div class="line">    aabb_grid += (Point(aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#aab574470a2591f187553ca1166e682e1">xmin</a>(), aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a2088e16a1f0a20e011e5b94c2e9c222a">ymin</a>(), aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a6c55430abc7fda54571cf1075c7f2f8b">zmin</a>()) - aabb_increase_vec).bbox();</div><div class="line"></div><div class="line">    <span class="comment">// construct AABB tree</span></div><div class="line">    Tree tree(mesh_input.faces_begin(), mesh_input.faces_end(), mesh_input);</div><div class="line"></div><div class="line">    CGAL::Side_of_triangle_mesh&lt;Mesh, CGAL::GetGeomTraits&lt;Mesh&gt;::type&gt; sotm(mesh_input);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">auto</span> mesh_distance = [&amp;tree](<span class="keyword">const</span> Point&amp; p) {</div><div class="line">        <span class="keyword">const</span> Point&amp; x = tree.closest_point(p);</div><div class="line">        <span class="keywordflow">return</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">std::sqrt</a>((p - x).squared_length());</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> mesh_normal = [&amp;tree](<span class="keyword">const</span> Point&amp; p) {</div><div class="line">        <span class="keyword">const</span> Point&amp; x = tree.closest_point(p);</div><div class="line">        <span class="keyword">const</span> Vector n = p - x;</div><div class="line">        <span class="keywordflow">return</span> n / <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">std::sqrt</a>(n.squared_length());</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// create a domain with bounding box [-1, 1]^3 and grid spacing 0.02</span></div><div class="line">    <span class="keyword">auto</span> domain = CGAL::Isosurfacing::create_implicit_cartesian_grid_domain&lt;Kernel&gt;(aabb_grid, grid_spacing,</div><div class="line">                                                                                    mesh_distance, mesh_normal);</div><div class="line"></div><div class="line">    Point_range points;</div><div class="line">    Polygon_range polygons;</div><div class="line"></div><div class="line">    <a class="code" href="group__PkgIsosurfacing3Ref.html#gad4b618b5b6e5f914022485c979094b7a">CGAL::Isosurfacing::dual_contouring</a>(domain, offset_value, points, polygons);</div><div class="line"></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result.off"</span>, points, polygons);</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Nov 18 2022 12:07:25 for CGAL 5.6 - 3D Isosurfacing by
    <a href="https://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>
</html>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.6 - 3D Isosurfacing
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Isosurfacing3"></a>  </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Author</dt><dd>Julian Stahl and Daniel Zint</dd></dl>
<p><a class="anchor" id="fig__isosurfacing_bunny_offset"></a></p><center> <div class="image">
<img src="bunny_offset.gif" style="max-width:50%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__isosurfacing_bunny_offset">Figure 60.1</a> Different isovalues of a bunny.  </div> <br /> 
<h1><a class="anchor" id="secmyintroduction"></a>
Introduction</h1>
<p>This package provides methods to compute a surface mesh representing an isosurface of a 3-dimensional scalar field. An isosurface is defined as the surface on which the value of this field is equal to a given constant, i.e. the isovalue. Depending on the isosurfacing method and the input data structure, the result is either a triangular, quadrilateral, or higher order polygonal indexed face set.</p>
<h1><a class="anchor" id="secmyalgorithms"></a>
Algorithms</h1>
<p>There are multiple algorithms to extract isosurfaces. This package contains Marching Cubes, topologically correct Marching Cubes, and Dual Contouring.</p>
<h2><a class="anchor" id="subsecmc"></a>
Marching Cubes (MC)</h2>
<p>MC processes all cells of the input domain individually. Each cell corner gets a sign (+/-) to indicate if it is above or below the isovalue. A new vertex is created on every cell edge where the sign changes, i.e. the isosurface is intersected. The vertex position is computed via linear interpolation of the scalar values of the incident corners. Depending on the configuration of signs at the corners the resulting vertices are connected to form triangles within the cell.</p>
<p>MC can process any input data structure that consists of hexahedral cells. In case of a conforming grid, MC produces a triangle mesh that is manifold in most scenarios. If the mesh is manifold and the isosurface does not intersect the domain boundaries, the mesh is also watertight. Compared to other approaches the algorithm often generates more and many thin triangles with acute angles. MC does not preserve sharp features of the input data.</p>
<p><a class="anchor" id="fig__isosurfacing_mc_cases"></a></p><center> <div class="image">
<img src="mc_cases.png" style="max-width:70%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__isosurfacing_mc_cases">Figure 60.2</a> Some example cases of Marching Cubes.  </div> <br /> 
<h2><a class="anchor" id="subsectmc"></a>
Topologically correct Marching Cubes (TMC)</h2>
<p>This algorithm is an extension to MC and provides additional guarantees for the output. It generates a mesh that is homeomorphic to the trilinear interpolant of the input function inside each cube. This means that the mesh can accurately represent small complex features. For example a tunnel of the isosurface within a single cell can be topologically resolved. Furthermore, the mesh is guaranteed to be manifold and watertight, as long as the isosurface does not intersect the domain boundaries.</p>
<p>This algorithm is based on the following paper:</p>
<p>Roberto Grosso: Construction of Topologically Correct and Manifold Isosurfaces. Computer Graphics Forum 35(5):187-196 - August 2016</p>
<h2><a class="anchor" id="subsecdc"></a>
Dual Contouring (DC)</h2>
<p>DC creates one vertex in every cell that is intersected by the isosurface. Next, a face is created for each edge that intersects the isosurface, by connecting the vertices of the incident cells. For a uniform hexahedral grid, this results in a quadrilateral mesh.</p>
<p>The classical DC method requires the gradient of the scalar field. The provided domain therefore has to implement the concept <code><a class="el" href="classIsosurfacingDomainWithGradient.html" title="The concept IsosurfacingDomainWithGradient describes the set of requirements to be fulfilled by any c...">IsosurfacingDomainWithGradient</a></code>. All default domain implementations do this but assume the gradient to be zero if it is not provided as an additional parameter. Thus, for using the classical DC, the gradient has to be defined by the user. Alternatively, there are also some default gradient functions implemented, such as <code>Finite_difference_gradient</code> and <code>Explicit_cartesian_grid_gradient</code>.</p>
<p>Different versions of DC compute the vertex positions differently. Therefore, the vertex positioning is configurable with an optional parameter passed to the function. Some of them do not require the gradient and therefore even work with the zero gradient.</p>
<p>Dual Contouring works on any domain but does not guarantee a manifold or watertight mesh. It creates less faces than Marching Cubes. Another advantage of DC over MC is the ability to represent sharp edges.</p>
<p><a class="anchor" id="fig__isosurfacing_iwp_dc"></a></p><center> <div class="image">
<img src="iwp_dc.png" style="max-width:40%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__isosurfacing_iwp_dc">Figure 60.3</a> Isosurface of the IWP function generated by Dual Contouring.  </div> <br /> 
<h2><a class="anchor" id="subseccomparison"></a>
Comparison</h2>
<table class="doxtable">
<tr>
<th>Algorithm </th><th>Domains </th><th>Faces </th><th>Manifold </th><th>Watertight* </th><th>Topologically correct  </th></tr>
<tr>
<td>MC </td><td>Hexahedral </td><td>Triangles </td><td>no </td><td>no </td><td>no </td></tr>
<tr>
<td>TMC </td><td>Hexahedral </td><td>Triangles </td><td>yes </td><td>yes </td><td>yes </td></tr>
<tr>
<td>DC </td><td>All </td><td>Polygons </td><td>no </td><td>no </td><td>no </td></tr>
</table>
<p>(* assuming the isosurface does not leave the given bounding box of the domain)</p>
<p><a class="anchor" id="fig__isosurfacing_compare_mc_dc"></a></p><center> <div class="image">
<img src="cube_mc_dc.png" style="max-width:70%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__isosurfacing_compare_mc_dc">Figure 60.4</a> Comparison between a cube generated by Dual Contouring (left) and Marching Cubes (right).  </div> <br /> 
<h1><a class="anchor" id="secmyinterface"></a>
Interface</h1>
<p>Each algorithm is represented by a single functions. The function signature is the same for all algorithms:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Concurrency_tag = Sequential_tag, <span class="keyword">class</span> Domain_, <span class="keyword">class</span> Po<span class="keywordtype">int</span>Range, <span class="keyword">class</span> PolygonRange&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="group__PkgIsosurfacing3Ref.html#gad259ce0aaba83f7bc168ba49047c08b6">marching_cubes</a>(<span class="keyword">const</span> Domain_&amp; domain, <span class="keyword">const</span> <span class="keyword">typename</span> Domain_::FT iso_value,</div><div class="line">                    PointRange&amp; points, PolygonRange&amp; polygons);</div></div><!-- fragment --><p>The input is provided in the form of a <code>domain</code> (see <a class="el" href="index.html#secmydomains">Domains</a>).</p>
<p>The <code>iso_value</code> parameter describes the grid value the isosurface should represent.</p>
<p>The output is in the form of an indexed face set that is written to the two collections <code>points</code> and <code>polygons</code>. The vertex positions are stored as <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__3.html">Point_3</a></code> in <code>points</code>. Each face in <code>polygons</code> is a list of indices pointing into the <code>points</code> collection. Depending on the algorithm, the indexed face set may either store a polygon soup or a topological mesh.</p>
<p>Algorithms can run sequentially on one CPU core or in parallel. The Concurrency_tag is used to specify how the algorithm is executed and is either <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Sequential__tag.html">Sequential_tag</a> or <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__tag.html">Parallel_tag</a>. To enable parallelism, <a class="el" href="namespaceCGAL.html">CGAL</a> needs to be linked with the Intel TBB library. If the parallel version is not availible the sequential version will always be used as a fallback.</p>
<h1><a class="anchor" id="secmydomains"></a>
Domains</h1>
<p>A domain is an object that provides functions to access the input data, its geometry, topology, and optionally its gradient. There are some predefined domain classes that wrap the input data and provide a generalized interface for the algorithm. Users can also define new domains by implementing the <code>Isosurfacing_domain</code> or <code><a class="el" href="classIsosurfacingDomainWithGradient.html" title="The concept IsosurfacingDomainWithGradient describes the set of requirements to be fulfilled by any c...">IsosurfacingDomainWithGradient</a></code> concept.</p>
<h2><a class="anchor" id="mysubsecimplicitdomain"></a>
Implicit cartesian grid domain</h2>
<p>The <code>Implicit_cartesian_grid_domain</code> represents the input function in an implicit form without storing any values. It takes a functor or lambda that computes the value of the function from the position of a vertex as parameter. Additionally, the bounding box and spacing between grid points have to be specified.</p>
<h2><a class="anchor" id="mysubseccartesiandomain"></a>
Explicit cartesian grid domain</h2>
<p>The <code>Explicit_cartesian_grid_domain</code> only takes a <code><a class="el" href="classCGAL_1_1Cartesian__grid__3.html">Cartesian_grid_3</a></code> as parameter. It represents a uniform grid of values that are either computed by the user or read from an <code>Image_3</code>. The constructor of <code><a class="el" href="classCGAL_1_1Cartesian__grid__3.html">Cartesian_grid_3</a></code> needs the number of grid points in each dimension and the bounding box. The values are read and written with <code>value(x, y, z)</code> where x, y, and z are the coordinates of a grid point. Alternatively, all required data can be copied from an <code>Image_3</code>.</p>
<h1><a class="anchor" id="secmybenchmarks"></a>
Performance</h1>
<p><a class="anchor" id="fig__isosurfacing_perf_iwp_mc"></a></p><center> <div class="image">
<object type="image/svg+xml" data="perf_threads_iwp_mc.svg" style="max-width:70%;"></object>
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__isosurfacing_perf_iwp_mc">Figure 60.5</a> <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Scaling.html">Scaling</a> of Marching Cubes with more threads.  </div> <br /> 
<h1><a class="anchor" id="secmyexamples"></a>
Examples</h1>
<h2><a class="anchor" id="myExampleImplicit_domain"></a>
Implicit sphere</h2>
<p>The following example shows the usage of the Marching Cubes algorithm to extract an isosurface. The domain is an <code>Implicit_domain</code> that describes a sphere by the distance to its origin as an implicit function.</p>
<p><br />
<b>File</b> <a class="el" href="Isosurfacing_3_2marching_cubes_implicit_sphere_8cpp-example.html">Isosurfacing_3/marching_cubes_implicit_sphere.cpp</a> </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Bbox_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Implicit_cartesian_grid_domain.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Marching_cubes_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/OFF.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;std::vector&lt;std::size_t&gt;&gt; Polygon_range;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="keyword">const</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html">CGAL::Bbox_3</a> bbox{-1, -1, -1, 1, 1, 1};</div><div class="line">    <span class="keyword">const</span> Vector spacing(0.04f, 0.04f, 0.04f);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> sphere_function = [&amp;](<span class="keyword">const</span> Point&amp; p) { <span class="keywordflow">return</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">std::sqrt</a>(p.x() * p.x() + p.y() * p.y() + p.z() * p.z()); };</div><div class="line"></div><div class="line">    <span class="comment">// create a domain with bounding box [-1, 1]^3 and grid spacing 0.02</span></div><div class="line">    <span class="keyword">auto</span> domain = CGAL::Isosurfacing::create_implicit_cartesian_grid_domain&lt;Kernel&gt;(bbox, spacing, sphere_function);</div><div class="line"></div><div class="line">    <span class="comment">// prepare collections for the result</span></div><div class="line">    Point_range points;</div><div class="line">    Polygon_range polygons;</div><div class="line"></div><div class="line">    <span class="comment">// execute marching cubes with an isovalue of 0.8</span></div><div class="line">    <a class="code" href="group__PkgIsosurfacing3Ref.html#gad259ce0aaba83f7bc168ba49047c08b6">CGAL::Isosurfacing::marching_cubes</a>(domain, 0.8f, points, polygons);</div><div class="line"></div><div class="line">    <span class="comment">// save the result in the OFF format</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result.off"</span>, points, polygons);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="myExampleAll_cube"></a>
Cartesian_grid_3 cube comparison</h2>
<p>The following example compares all provided algorithms to extract an isosurface. The domain is an <code>Cartesian_grid_domain</code> that describes a cube by storing the manhattan distance to its origin in a <code><a class="el" href="classCGAL_1_1Cartesian__grid__3.html">Cartesian_grid_3</a></code>.</p>
<p><br />
<b>File</b> <a class="el" href="Isosurfacing_3_2all_cartesian_cube_8cpp-example.html">Isosurfacing_3/all_cartesian_cube.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian_grid_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Dual_contouring_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Explicit_cartesian_grid_domain.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Marching_cubes_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/OFF.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Cartesian__grid__3.html">CGAL::Cartesian_grid_3&lt;Kernel&gt;</a> Grid;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;std::vector&lt;std::size_t&gt;&gt; Polygon_range;</div><div class="line"></div><div class="line">FT <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gaf3d75d272a29458960987a8f248ec636">sign</a>(FT value) {</div><div class="line">    <span class="keywordflow">return</span> (value &gt; 0) - (value &lt; 0);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// create a cartesian grid with 100^3 grid points and the bounding box [-1, 1]^3</span></div><div class="line">    <span class="keyword">const</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html">CGAL::Bbox_3</a> bbox(-1, -1, -1, 1, 1, 1);</div><div class="line">    std::shared_ptr&lt;Grid&gt; grid = std::make_shared&lt;Grid&gt;(7, 7, 7, bbox);</div><div class="line"></div><div class="line">    <span class="comment">// calculate the value at all grid points</span></div><div class="line">    <span class="keywordflow">for</span> (std::size_t x = 0; x &lt; grid-&gt;xdim(); x++) {</div><div class="line">        <span class="keywordflow">for</span> (std::size_t y = 0; y &lt; grid-&gt;ydim(); y++) {</div><div class="line">            <span class="keywordflow">for</span> (std::size_t z = 0; z &lt; grid-&gt;zdim(); z++) {</div><div class="line"></div><div class="line">                <span class="keyword">const</span> FT pos_x = x * grid-&gt;get_spacing()[0] + bbox.xmin();</div><div class="line">                <span class="keyword">const</span> FT pos_y = y * grid-&gt;get_spacing()[1] + bbox.ymin();</div><div class="line">                <span class="keyword">const</span> FT pos_z = z * grid-&gt;get_spacing()[2] + bbox.zmin();</div><div class="line"></div><div class="line">                <span class="comment">// manhattan distance to the origin</span></div><div class="line">                grid-&gt;value(x, y, z) = std::max({<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(pos_x), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(pos_y), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(pos_z)});</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> cube_gradient = [](<span class="keyword">const</span> Point&amp; p) {</div><div class="line">        <span class="comment">// the normal depends on the side of the cube</span></div><div class="line">        <span class="keyword">const</span> FT max_value = std::max({<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.x()), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.y()), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.z())});</div><div class="line"></div><div class="line">        Vector g(0, 0, 0);</div><div class="line">        <span class="keywordflow">if</span> (max_value == <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.x())) {</div><div class="line">            g += Vector(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gaf3d75d272a29458960987a8f248ec636">sign</a>(p.x()), 0, 0);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> (max_value == <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.y())) {</div><div class="line">            g += Vector(0, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gaf3d75d272a29458960987a8f248ec636">sign</a>(p.y()), 0);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> (max_value == <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.z())) {</div><div class="line">            g += Vector(0, 0, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gaf3d75d272a29458960987a8f248ec636">sign</a>(p.z()));</div><div class="line">        }</div><div class="line">        <span class="keyword">const</span> FT length_sq = g.squared_length();</div><div class="line">        <span class="keywordflow">if</span> (length_sq &gt; 0.00001) {</div><div class="line">            g /= CGAL::approximate_sqrt(length_sq);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> g;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// create a domain from the grid</span></div><div class="line">    <span class="keyword">auto</span> domain = CGAL::Isosurfacing::create_explicit_cartesian_grid_domain&lt;Kernel&gt;(grid, cube_gradient);</div><div class="line"></div><div class="line">    <span class="comment">// prepare collections for the results</span></div><div class="line">    Point_range points_mc, points_dc;</div><div class="line">    Polygon_range polygons_mc, polygons_dc;</div><div class="line"></div><div class="line">    <span class="comment">// execute topologically correct marching cubes and dual contouring with an isovalue of 0.8</span></div><div class="line">    <a class="code" href="group__PkgIsosurfacing3Ref.html#gad259ce0aaba83f7bc168ba49047c08b6">CGAL::Isosurfacing::marching_cubes</a>(domain, 0.88, points_mc, polygons_mc);</div><div class="line">    <a class="code" href="group__PkgIsosurfacing3Ref.html#gad4b618b5b6e5f914022485c979094b7a">CGAL::Isosurfacing::dual_contouring</a>(domain, 0.88, points_dc, polygons_dc);</div><div class="line"></div><div class="line">    <span class="comment">// save the results in the OFF format</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result_mc.off"</span>, points_mc, polygons_mc);</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result_dc.off"</span>, points_dc, polygons_dc);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="myExampleImage"></a>
Image_3</h2>
<p>The following example shows how to load data from an <code>Image_3</code>.</p>
<p><br />
<b>File</b> <a class="el" href="Isosurfacing_3_2marching_cubes_inrimage_8cpp-example.html">Isosurfacing_3/marching_cubes_inrimage.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian_grid_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Explicit_cartesian_grid_domain.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Marching_cubes_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/OFF.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Cartesian__grid__3.html">CGAL::Cartesian_grid_3&lt;Kernel&gt;</a> Grid;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;std::vector&lt;std::size_t&gt;&gt; Polygon_range;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string fname = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"images/skull_2.9.inr"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// load the image</span></div><div class="line">    CGAL::Image_3 image;</div><div class="line">    <span class="keywordflow">if</span> (!image.read(fname)) {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">"Error: Cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// convert it to a cartesian grid</span></div><div class="line">    std::shared_ptr&lt;Grid&gt; grid = std::make_shared&lt;Grid&gt;(image);</div><div class="line"></div><div class="line">    <span class="comment">// create a domain from the grid</span></div><div class="line">    <span class="keyword">auto</span> domain = CGAL::Isosurfacing::create_explicit_cartesian_grid_domain&lt;Kernel&gt;(grid);</div><div class="line"></div><div class="line">    <span class="comment">// prepare collections for the result</span></div><div class="line">    Point_range points;</div><div class="line">    Polygon_range polygons;</div><div class="line"></div><div class="line">    <span class="comment">// execute marching cubes with an isovalue of 2.9</span></div><div class="line">    <a class="code" href="group__PkgIsosurfacing3Ref.html#gad259ce0aaba83f7bc168ba49047c08b6">CGAL::Isosurfacing::marching_cubes</a>(domain, 2.9, points, polygons);</div><div class="line"></div><div class="line">    <span class="comment">// save the result in the OFF format</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result.off"</span>, points, polygons);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="myExampleMeshOffset"></a>
Offset mesh</h2>
<p>The following example shows how to compute an offset mesh. The original mesh is passed to an <code>AABB_tree</code> to allow fast distance queries. With the use of <code>Side_of_triangle_mesh</code> the sign of the distance function is flipped inside the mesh.</p>
<p><br />
<b>File</b> <a class="el" href="Isosurfacing_3_2dual_contouring_mesh_offset_8cpp-example.html">Isosurfacing_3/dual_contouring_mesh_offset.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/AABB_face_graph_triangle_primitive.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/AABB_traits.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/AABB_tree.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Bbox_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Dual_contouring_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Implicit_cartesian_grid_domain.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Side_of_triangle_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/OFF.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> CGAL::Surface_mesh&lt;Point&gt; Mesh;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> CGAL::AABB_face_graph_triangle_primitive&lt;Mesh&gt; Primitive;</div><div class="line"><span class="keyword">typedef</span> CGAL::AABB_traits&lt;Kernel, Primitive&gt; Traits;</div><div class="line"><span class="keyword">typedef</span> CGAL::AABB_tree&lt;Traits&gt; Tree;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;std::vector&lt;std::size_t&gt;&gt; Polygon_range;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="keyword">const</span> std::string input_name = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/cross.off"</span>);</div><div class="line">    <span class="keyword">const</span> Vector grid_spacing(0.1, 0.1, 0.1);</div><div class="line">    <span class="keyword">const</span> FT offset_value = 0.2;</div><div class="line"></div><div class="line">    Mesh mesh_input;</div><div class="line">    <span class="keywordflow">if</span> (!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga7396bef8d41fe287d52d19ddbb83a3e4">CGAL::IO::read_OFF</a>(input_name, mesh_input)) {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">"Could not read mesh"</span> &lt;&lt; std::endl;</div><div class="line">        exit(-1);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// compute bounding box</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html">CGAL::Bbox_3</a> aabb_grid = CGAL::Polygon_mesh_processing::bbox(mesh_input);</div><div class="line">    Vector aabb_increase_vec = Vector(offset_value + 0.01, offset_value + 0.01, offset_value + 0.01);</div><div class="line">    aabb_grid += (Point(aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a3f5e323700e1509624a02d151237cc4c">xmax</a>(), aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a9d06f61bd89faa841e011ff53edf745f">ymax</a>(), aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a98def8b9515f31ded759d781969ddaf6">zmax</a>()) + aabb_increase_vec).bbox();</div><div class="line">    aabb_grid += (Point(aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#aab574470a2591f187553ca1166e682e1">xmin</a>(), aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a2088e16a1f0a20e011e5b94c2e9c222a">ymin</a>(), aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a6c55430abc7fda54571cf1075c7f2f8b">zmin</a>()) - aabb_increase_vec).bbox();</div><div class="line"></div><div class="line">    <span class="comment">// construct AABB tree</span></div><div class="line">    Tree tree(mesh_input.faces_begin(), mesh_input.faces_end(), mesh_input);</div><div class="line"></div><div class="line">    CGAL::Side_of_triangle_mesh&lt;Mesh, CGAL::GetGeomTraits&lt;Mesh&gt;::type&gt; sotm(mesh_input);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">auto</span> mesh_distance = [&amp;tree](<span class="keyword">const</span> Point&amp; p) {</div><div class="line">        <span class="keyword">const</span> Point&amp; x = tree.closest_point(p);</div><div class="line">        <span class="keywordflow">return</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">std::sqrt</a>((p - x).squared_length());</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> mesh_normal = [&amp;tree](<span class="keyword">const</span> Point&amp; p) {</div><div class="line">        <span class="keyword">const</span> Point&amp; x = tree.closest_point(p);</div><div class="line">        <span class="keyword">const</span> Vector n = p - x;</div><div class="line">        <span class="keywordflow">return</span> n / <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">std::sqrt</a>(n.squared_length());</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// create a domain with bounding box [-1, 1]^3 and grid spacing 0.02</span></div><div class="line">    <span class="keyword">auto</span> domain = CGAL::Isosurfacing::create_implicit_cartesian_grid_domain&lt;Kernel&gt;(aabb_grid, grid_spacing,</div><div class="line">                                                                                    mesh_distance, mesh_normal);</div><div class="line"></div><div class="line">    Point_range points;</div><div class="line">    Polygon_range polygons;</div><div class="line"></div><div class="line">    <a class="code" href="group__PkgIsosurfacing3Ref.html#gad4b618b5b6e5f914022485c979094b7a">CGAL::Isosurfacing::dual_contouring</a>(domain, offset_value, points, polygons);</div><div class="line"></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result.off"</span>, points, polygons);</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Nov 18 2022 12:07:25 for CGAL 5.6 - 3D Isosurfacing by
    <a href="https://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>
</html><html xmlns="http://www.w3.org/1999/xhtml"><body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.6 - 3D Isosurfacing
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Isosurfacing3"></a>  </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Author</dt><dd>Julian Stahl and Daniel Zint</dd></dl>
<p><a class="anchor" id="fig__isosurfacing_bunny_offset"></a></p><center> <div class="image">
<img src="bunny_offset.gif" style="max-width:50%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__isosurfacing_bunny_offset">Figure 60.1</a> Different isovalues of a bunny.  </div> <br /> 
<h1><a class="anchor" id="secmyintroduction"></a>
Introduction</h1>
<p>This package provides methods to compute a surface mesh representing an isosurface of a 3-dimensional scalar field. An isosurface is defined as the surface on which the value of this field is equal to a given constant, i.e. the isovalue. Depending on the isosurfacing method and the input data structure, the result is either a triangular, quadrilateral, or higher order polygonal indexed face set.</p>
<h1><a class="anchor" id="secmyalgorithms"></a>
Algorithms</h1>
<p>There are multiple algorithms to extract isosurfaces. This package contains Marching Cubes, topologically correct Marching Cubes, and Dual Contouring.</p>
<h2><a class="anchor" id="subsecmc"></a>
Marching Cubes (MC)</h2>
<p>MC processes all cells of the input domain individually. Each cell corner gets a sign (+/-) to indicate if it is above or below the isovalue. A new vertex is created on every cell edge where the sign changes, i.e. the isosurface is intersected. The vertex position is computed via linear interpolation of the scalar values of the incident corners. Depending on the configuration of signs at the corners the resulting vertices are connected to form triangles within the cell.</p>
<p>MC can process any input data structure that consists of hexahedral cells. In case of a conforming grid, MC produces a triangle mesh that is manifold in most scenarios. If the mesh is manifold and the isosurface does not intersect the domain boundaries, the mesh is also watertight. Compared to other approaches the algorithm often generates more and many thin triangles with acute angles. MC does not preserve sharp features of the input data.</p>
<p><a class="anchor" id="fig__isosurfacing_mc_cases"></a></p><center> <div class="image">
<img src="mc_cases.png" style="max-width:70%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__isosurfacing_mc_cases">Figure 60.2</a> Some example cases of Marching Cubes.  </div> <br /> 
<h2><a class="anchor" id="subsectmc"></a>
Topologically correct Marching Cubes (TMC)</h2>
<p>This algorithm is an extension to MC and provides additional guarantees for the output. It generates a mesh that is homeomorphic to the trilinear interpolant of the input function inside each cube. This means that the mesh can accurately represent small complex features. For example a tunnel of the isosurface within a single cell can be topologically resolved. Furthermore, the mesh is guaranteed to be manifold and watertight, as long as the isosurface does not intersect the domain boundaries.</p>
<p>This algorithm is based on the following paper:</p>
<p>Roberto Grosso: Construction of Topologically Correct and Manifold Isosurfaces. Computer Graphics Forum 35(5):187-196 - August 2016</p>
<h2><a class="anchor" id="subsecdc"></a>
Dual Contouring (DC)</h2>
<p>DC creates one vertex in every cell that is intersected by the isosurface. Next, a face is created for each edge that intersects the isosurface, by connecting the vertices of the incident cells. For a uniform hexahedral grid, this results in a quadrilateral mesh.</p>
<p>The classical DC method requires the gradient of the scalar field. The provided domain therefore has to implement the concept <code><a class="el" href="classIsosurfacingDomainWithGradient.html" title="The concept IsosurfacingDomainWithGradient describes the set of requirements to be fulfilled by any c...">IsosurfacingDomainWithGradient</a></code>. All default domain implementations do this but assume the gradient to be zero if it is not provided as an additional parameter. Thus, for using the classical DC, the gradient has to be defined by the user. Alternatively, there are also some default gradient functions implemented, such as <code>Finite_difference_gradient</code> and <code>Explicit_cartesian_grid_gradient</code>.</p>
<p>Different versions of DC compute the vertex positions differently. Therefore, the vertex positioning is configurable with an optional parameter passed to the function. Some of them do not require the gradient and therefore even work with the zero gradient.</p>
<p>Dual Contouring works on any domain but does not guarantee a manifold or watertight mesh. It creates less faces than Marching Cubes. Another advantage of DC over MC is the ability to represent sharp edges.</p>
<p><a class="anchor" id="fig__isosurfacing_iwp_dc"></a></p><center> <div class="image">
<img src="iwp_dc.png" style="max-width:40%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__isosurfacing_iwp_dc">Figure 60.3</a> Isosurface of the IWP function generated by Dual Contouring.  </div> <br /> 
<h2><a class="anchor" id="subseccomparison"></a>
Comparison</h2>
<table class="doxtable">
<tr>
<th>Algorithm </th><th>Domains </th><th>Faces </th><th>Manifold </th><th>Watertight* </th><th>Topologically correct  </th></tr>
<tr>
<td>MC </td><td>Hexahedral </td><td>Triangles </td><td>no </td><td>no </td><td>no </td></tr>
<tr>
<td>TMC </td><td>Hexahedral </td><td>Triangles </td><td>yes </td><td>yes </td><td>yes </td></tr>
<tr>
<td>DC </td><td>All </td><td>Polygons </td><td>no </td><td>no </td><td>no </td></tr>
</table>
<p>(* assuming the isosurface does not leave the given bounding box of the domain)</p>
<p><a class="anchor" id="fig__isosurfacing_compare_mc_dc"></a></p><center> <div class="image">
<img src="cube_mc_dc.png" style="max-width:70%;" />
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__isosurfacing_compare_mc_dc">Figure 60.4</a> Comparison between a cube generated by Dual Contouring (left) and Marching Cubes (right).  </div> <br /> 
<h1><a class="anchor" id="secmyinterface"></a>
Interface</h1>
<p>Each algorithm is represented by a single functions. The function signature is the same for all algorithms:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Concurrency_tag = Sequential_tag, <span class="keyword">class</span> Domain_, <span class="keyword">class</span> Po<span class="keywordtype">int</span>Range, <span class="keyword">class</span> PolygonRange&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="group__PkgIsosurfacing3Ref.html#gad259ce0aaba83f7bc168ba49047c08b6">marching_cubes</a>(<span class="keyword">const</span> Domain_&amp; domain, <span class="keyword">const</span> <span class="keyword">typename</span> Domain_::FT iso_value,</div><div class="line">                    PointRange&amp; points, PolygonRange&amp; polygons);</div></div><!-- fragment --><p>The input is provided in the form of a <code>domain</code> (see <a class="el" href="index.html#secmydomains">Domains</a>).</p>
<p>The <code>iso_value</code> parameter describes the grid value the isosurface should represent.</p>
<p>The output is in the form of an indexed face set that is written to the two collections <code>points</code> and <code>polygons</code>. The vertex positions are stored as <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__3.html">Point_3</a></code> in <code>points</code>. Each face in <code>polygons</code> is a list of indices pointing into the <code>points</code> collection. Depending on the algorithm, the indexed face set may either store a polygon soup or a topological mesh.</p>
<p>Algorithms can run sequentially on one CPU core or in parallel. The Concurrency_tag is used to specify how the algorithm is executed and is either <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Sequential__tag.html">Sequential_tag</a> or <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__tag.html">Parallel_tag</a>. To enable parallelism, <a class="el" href="namespaceCGAL.html">CGAL</a> needs to be linked with the Intel TBB library. If the parallel version is not availible the sequential version will always be used as a fallback.</p>
<h1><a class="anchor" id="secmydomains"></a>
Domains</h1>
<p>A domain is an object that provides functions to access the input data, its geometry, topology, and optionally its gradient. There are some predefined domain classes that wrap the input data and provide a generalized interface for the algorithm. Users can also define new domains by implementing the <code>Isosurfacing_domain</code> or <code><a class="el" href="classIsosurfacingDomainWithGradient.html" title="The concept IsosurfacingDomainWithGradient describes the set of requirements to be fulfilled by any c...">IsosurfacingDomainWithGradient</a></code> concept.</p>
<h2><a class="anchor" id="mysubsecimplicitdomain"></a>
Implicit cartesian grid domain</h2>
<p>The <code>Implicit_cartesian_grid_domain</code> represents the input function in an implicit form without storing any values. It takes a functor or lambda that computes the value of the function from the position of a vertex as parameter. Additionally, the bounding box and spacing between grid points have to be specified.</p>
<h2><a class="anchor" id="mysubseccartesiandomain"></a>
Explicit cartesian grid domain</h2>
<p>The <code>Explicit_cartesian_grid_domain</code> only takes a <code><a class="el" href="classCGAL_1_1Cartesian__grid__3.html">Cartesian_grid_3</a></code> as parameter. It represents a uniform grid of values that are either computed by the user or read from an <code>Image_3</code>. The constructor of <code><a class="el" href="classCGAL_1_1Cartesian__grid__3.html">Cartesian_grid_3</a></code> needs the number of grid points in each dimension and the bounding box. The values are read and written with <code>value(x, y, z)</code> where x, y, and z are the coordinates of a grid point. Alternatively, all required data can be copied from an <code>Image_3</code>.</p>
<h1><a class="anchor" id="secmybenchmarks"></a>
Performance</h1>
<p><a class="anchor" id="fig__isosurfacing_perf_iwp_mc"></a></p><center> <div class="image">
<object type="image/svg+xml" data="perf_threads_iwp_mc.svg" style="max-width:70%;"></object>
</div>
 </center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__isosurfacing_perf_iwp_mc">Figure 60.5</a> <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Scaling.html">Scaling</a> of Marching Cubes with more threads.  </div> <br /> 
<h1><a class="anchor" id="secmyexamples"></a>
Examples</h1>
<h2><a class="anchor" id="myExampleImplicit_domain"></a>
Implicit sphere</h2>
<p>The following example shows the usage of the Marching Cubes algorithm to extract an isosurface. The domain is an <code>Implicit_domain</code> that describes a sphere by the distance to its origin as an implicit function.</p>
<p><br />
<b>File</b> <a class="el" href="Isosurfacing_3_2marching_cubes_implicit_sphere_8cpp-example.html">Isosurfacing_3/marching_cubes_implicit_sphere.cpp</a> </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Bbox_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Implicit_cartesian_grid_domain.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Marching_cubes_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/OFF.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;std::vector&lt;std::size_t&gt;&gt; Polygon_range;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="keyword">const</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html">CGAL::Bbox_3</a> bbox{-1, -1, -1, 1, 1, 1};</div><div class="line">    <span class="keyword">const</span> Vector spacing(0.04f, 0.04f, 0.04f);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> sphere_function = [&amp;](<span class="keyword">const</span> Point&amp; p) { <span class="keywordflow">return</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">std::sqrt</a>(p.x() * p.x() + p.y() * p.y() + p.z() * p.z()); };</div><div class="line"></div><div class="line">    <span class="comment">// create a domain with bounding box [-1, 1]^3 and grid spacing 0.02</span></div><div class="line">    <span class="keyword">auto</span> domain = CGAL::Isosurfacing::create_implicit_cartesian_grid_domain&lt;Kernel&gt;(bbox, spacing, sphere_function);</div><div class="line"></div><div class="line">    <span class="comment">// prepare collections for the result</span></div><div class="line">    Point_range points;</div><div class="line">    Polygon_range polygons;</div><div class="line"></div><div class="line">    <span class="comment">// execute marching cubes with an isovalue of 0.8</span></div><div class="line">    <a class="code" href="group__PkgIsosurfacing3Ref.html#gad259ce0aaba83f7bc168ba49047c08b6">CGAL::Isosurfacing::marching_cubes</a>(domain, 0.8f, points, polygons);</div><div class="line"></div><div class="line">    <span class="comment">// save the result in the OFF format</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result.off"</span>, points, polygons);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="myExampleAll_cube"></a>
Cartesian_grid_3 cube comparison</h2>
<p>The following example compares all provided algorithms to extract an isosurface. The domain is an <code>Cartesian_grid_domain</code> that describes a cube by storing the manhattan distance to its origin in a <code><a class="el" href="classCGAL_1_1Cartesian__grid__3.html">Cartesian_grid_3</a></code>.</p>
<p><br />
<b>File</b> <a class="el" href="Isosurfacing_3_2all_cartesian_cube_8cpp-example.html">Isosurfacing_3/all_cartesian_cube.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian_grid_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Dual_contouring_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Explicit_cartesian_grid_domain.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Marching_cubes_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/OFF.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Cartesian__grid__3.html">CGAL::Cartesian_grid_3&lt;Kernel&gt;</a> Grid;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;std::vector&lt;std::size_t&gt;&gt; Polygon_range;</div><div class="line"></div><div class="line">FT <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gaf3d75d272a29458960987a8f248ec636">sign</a>(FT value) {</div><div class="line">    <span class="keywordflow">return</span> (value &gt; 0) - (value &lt; 0);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="comment">// create a cartesian grid with 100^3 grid points and the bounding box [-1, 1]^3</span></div><div class="line">    <span class="keyword">const</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html">CGAL::Bbox_3</a> bbox(-1, -1, -1, 1, 1, 1);</div><div class="line">    std::shared_ptr&lt;Grid&gt; grid = std::make_shared&lt;Grid&gt;(7, 7, 7, bbox);</div><div class="line"></div><div class="line">    <span class="comment">// calculate the value at all grid points</span></div><div class="line">    <span class="keywordflow">for</span> (std::size_t x = 0; x &lt; grid-&gt;xdim(); x++) {</div><div class="line">        <span class="keywordflow">for</span> (std::size_t y = 0; y &lt; grid-&gt;ydim(); y++) {</div><div class="line">            <span class="keywordflow">for</span> (std::size_t z = 0; z &lt; grid-&gt;zdim(); z++) {</div><div class="line"></div><div class="line">                <span class="keyword">const</span> FT pos_x = x * grid-&gt;get_spacing()[0] + bbox.xmin();</div><div class="line">                <span class="keyword">const</span> FT pos_y = y * grid-&gt;get_spacing()[1] + bbox.ymin();</div><div class="line">                <span class="keyword">const</span> FT pos_z = z * grid-&gt;get_spacing()[2] + bbox.zmin();</div><div class="line"></div><div class="line">                <span class="comment">// manhattan distance to the origin</span></div><div class="line">                grid-&gt;value(x, y, z) = std::max({<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(pos_x), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(pos_y), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(pos_z)});</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> cube_gradient = [](<span class="keyword">const</span> Point&amp; p) {</div><div class="line">        <span class="comment">// the normal depends on the side of the cube</span></div><div class="line">        <span class="keyword">const</span> FT max_value = std::max({<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.x()), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.y()), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.z())});</div><div class="line"></div><div class="line">        Vector g(0, 0, 0);</div><div class="line">        <span class="keywordflow">if</span> (max_value == <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.x())) {</div><div class="line">            g += Vector(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gaf3d75d272a29458960987a8f248ec636">sign</a>(p.x()), 0, 0);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> (max_value == <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.y())) {</div><div class="line">            g += Vector(0, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gaf3d75d272a29458960987a8f248ec636">sign</a>(p.y()), 0);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> (max_value == <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">std::abs</a>(p.z())) {</div><div class="line">            g += Vector(0, 0, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gaf3d75d272a29458960987a8f248ec636">sign</a>(p.z()));</div><div class="line">        }</div><div class="line">        <span class="keyword">const</span> FT length_sq = g.squared_length();</div><div class="line">        <span class="keywordflow">if</span> (length_sq &gt; 0.00001) {</div><div class="line">            g /= CGAL::approximate_sqrt(length_sq);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> g;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// create a domain from the grid</span></div><div class="line">    <span class="keyword">auto</span> domain = CGAL::Isosurfacing::create_explicit_cartesian_grid_domain&lt;Kernel&gt;(grid, cube_gradient);</div><div class="line"></div><div class="line">    <span class="comment">// prepare collections for the results</span></div><div class="line">    Point_range points_mc, points_dc;</div><div class="line">    Polygon_range polygons_mc, polygons_dc;</div><div class="line"></div><div class="line">    <span class="comment">// execute topologically correct marching cubes and dual contouring with an isovalue of 0.8</span></div><div class="line">    <a class="code" href="group__PkgIsosurfacing3Ref.html#gad259ce0aaba83f7bc168ba49047c08b6">CGAL::Isosurfacing::marching_cubes</a>(domain, 0.88, points_mc, polygons_mc);</div><div class="line">    <a class="code" href="group__PkgIsosurfacing3Ref.html#gad4b618b5b6e5f914022485c979094b7a">CGAL::Isosurfacing::dual_contouring</a>(domain, 0.88, points_dc, polygons_dc);</div><div class="line"></div><div class="line">    <span class="comment">// save the results in the OFF format</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result_mc.off"</span>, points_mc, polygons_mc);</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result_dc.off"</span>, points_dc, polygons_dc);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="myExampleImage"></a>
Image_3</h2>
<p>The following example shows how to load data from an <code>Image_3</code>.</p>
<p><br />
<b>File</b> <a class="el" href="Isosurfacing_3_2marching_cubes_inrimage_8cpp-example.html">Isosurfacing_3/marching_cubes_inrimage.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian_grid_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Explicit_cartesian_grid_domain.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Marching_cubes_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/OFF.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Cartesian__grid__3.html">CGAL::Cartesian_grid_3&lt;Kernel&gt;</a> Grid;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;std::vector&lt;std::size_t&gt;&gt; Polygon_range;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string fname = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"images/skull_2.9.inr"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// load the image</span></div><div class="line">    CGAL::Image_3 image;</div><div class="line">    <span class="keywordflow">if</span> (!image.read(fname)) {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">"Error: Cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// convert it to a cartesian grid</span></div><div class="line">    std::shared_ptr&lt;Grid&gt; grid = std::make_shared&lt;Grid&gt;(image);</div><div class="line"></div><div class="line">    <span class="comment">// create a domain from the grid</span></div><div class="line">    <span class="keyword">auto</span> domain = CGAL::Isosurfacing::create_explicit_cartesian_grid_domain&lt;Kernel&gt;(grid);</div><div class="line"></div><div class="line">    <span class="comment">// prepare collections for the result</span></div><div class="line">    Point_range points;</div><div class="line">    Polygon_range polygons;</div><div class="line"></div><div class="line">    <span class="comment">// execute marching cubes with an isovalue of 2.9</span></div><div class="line">    <a class="code" href="group__PkgIsosurfacing3Ref.html#gad259ce0aaba83f7bc168ba49047c08b6">CGAL::Isosurfacing::marching_cubes</a>(domain, 2.9, points, polygons);</div><div class="line"></div><div class="line">    <span class="comment">// save the result in the OFF format</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result.off"</span>, points, polygons);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="myExampleMeshOffset"></a>
Offset mesh</h2>
<p>The following example shows how to compute an offset mesh. The original mesh is passed to an <code>AABB_tree</code> to allow fast distance queries. With the use of <code>Side_of_triangle_mesh</code> the sign of the distance function is flipped inside the mesh.</p>
<p><br />
<b>File</b> <a class="el" href="Isosurfacing_3_2dual_contouring_mesh_offset_8cpp-example.html">Isosurfacing_3/dual_contouring_mesh_offset.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/AABB_face_graph_triangle_primitive.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/AABB_traits.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/AABB_tree.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Bbox_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Dual_contouring_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Implicit_cartesian_grid_domain.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Side_of_triangle_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/IO/OFF.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> CGAL::Surface_mesh&lt;Point&gt; Mesh;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> CGAL::AABB_face_graph_triangle_primitive&lt;Mesh&gt; Primitive;</div><div class="line"><span class="keyword">typedef</span> CGAL::AABB_traits&lt;Kernel, Primitive&gt; Traits;</div><div class="line"><span class="keyword">typedef</span> CGAL::AABB_tree&lt;Traits&gt; Tree;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point&gt; Point_range;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;std::vector&lt;std::size_t&gt;&gt; Polygon_range;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="keyword">const</span> std::string input_name = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/cross.off"</span>);</div><div class="line">    <span class="keyword">const</span> Vector grid_spacing(0.1, 0.1, 0.1);</div><div class="line">    <span class="keyword">const</span> FT offset_value = 0.2;</div><div class="line"></div><div class="line">    Mesh mesh_input;</div><div class="line">    <span class="keywordflow">if</span> (!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga7396bef8d41fe287d52d19ddbb83a3e4">CGAL::IO::read_OFF</a>(input_name, mesh_input)) {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">"Could not read mesh"</span> &lt;&lt; std::endl;</div><div class="line">        exit(-1);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// compute bounding box</span></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html">CGAL::Bbox_3</a> aabb_grid = CGAL::Polygon_mesh_processing::bbox(mesh_input);</div><div class="line">    Vector aabb_increase_vec = Vector(offset_value + 0.01, offset_value + 0.01, offset_value + 0.01);</div><div class="line">    aabb_grid += (Point(aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a3f5e323700e1509624a02d151237cc4c">xmax</a>(), aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a9d06f61bd89faa841e011ff53edf745f">ymax</a>(), aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a98def8b9515f31ded759d781969ddaf6">zmax</a>()) + aabb_increase_vec).bbox();</div><div class="line">    aabb_grid += (Point(aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#aab574470a2591f187553ca1166e682e1">xmin</a>(), aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a2088e16a1f0a20e011e5b94c2e9c222a">ymin</a>(), aabb_grid.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a6c55430abc7fda54571cf1075c7f2f8b">zmin</a>()) - aabb_increase_vec).bbox();</div><div class="line"></div><div class="line">    <span class="comment">// construct AABB tree</span></div><div class="line">    Tree tree(mesh_input.faces_begin(), mesh_input.faces_end(), mesh_input);</div><div class="line"></div><div class="line">    CGAL::Side_of_triangle_mesh&lt;Mesh, CGAL::GetGeomTraits&lt;Mesh&gt;::type&gt; sotm(mesh_input);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">auto</span> mesh_distance = [&amp;tree](<span class="keyword">const</span> Point&amp; p) {</div><div class="line">        <span class="keyword">const</span> Point&amp; x = tree.closest_point(p);</div><div class="line">        <span class="keywordflow">return</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">std::sqrt</a>((p - x).squared_length());</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> mesh_normal = [&amp;tree](<span class="keyword">const</span> Point&amp; p) {</div><div class="line">        <span class="keyword">const</span> Point&amp; x = tree.closest_point(p);</div><div class="line">        <span class="keyword">const</span> Vector n = p - x;</div><div class="line">        <span class="keywordflow">return</span> n / <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">std::sqrt</a>(n.squared_length());</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// create a domain with bounding box [-1, 1]^3 and grid spacing 0.02</span></div><div class="line">    <span class="keyword">auto</span> domain = CGAL::Isosurfacing::create_implicit_cartesian_grid_domain&lt;Kernel&gt;(aabb_grid, grid_spacing,</div><div class="line">                                                                                    mesh_distance, mesh_normal);</div><div class="line"></div><div class="line">    Point_range points;</div><div class="line">    Polygon_range polygons;</div><div class="line"></div><div class="line">    <a class="code" href="group__PkgIsosurfacing3Ref.html#gad4b618b5b6e5f914022485c979094b7a">CGAL::Isosurfacing::dual_contouring</a>(domain, offset_value, points, polygons);</div><div class="line"></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsOFF.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result.off"</span>, points, polygons);</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Nov 18 2022 12:07:25 for CGAL 5.6 - 3D Isosurfacing by
    <a href="https://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>
</html>

</html>
