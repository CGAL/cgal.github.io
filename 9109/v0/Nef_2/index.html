<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Nef_2/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=11">
<meta name="generator" content="Doxygen 1.9.6">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CGAL 6.2 - 2D Boolean Operations on Nef Polygons: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/doxygen.css" rel="stylesheet" type="text/css">
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      },
      equationNumbers: { autoNumber: "AMS" }
  }
}
);
MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
  var PARSE = MathJax.InputJax.TeX.Parse,
      TEXT = PARSE.prototype.InternalText;
  PARSE.Augment({
    InternalText: function (text,def) {
      text = text.replace(/\\/g,"");
      return TEXT.call(this,text,def);
    }
  });
});
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
      <span class="left">
         <span id="MSearchSelect" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()">Â 
        </span>
        <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
      </span>
      <span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.svg" alt=""></a>
      </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CGAL 6.2 - 2D Boolean Operations on Nef Polygons
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search/",'.html');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">User Manual </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_2D_Boolean_Operations_on_Nef_Polygons"></a><a class="anchor" id="chapnef2"></a></p> <div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Author</dt><dd>Michael Seel</dd></dl>
<h1><a class="anchor" id="Nef_2Introduction"></a>
Introduction</h1>
<p>When working with polygonal and polyhedral sets, the mathematical model determines the kind of point set that can be represented. Nef polyhedra are the most general rectilinear polyhedral model.</p>
<p>Topological simpler models that are contained in the domain of Nef polyhedra are: </p><ul>
<li>
<em>convex polytopes</em> normally defined as the convex hull of a nonempty finite set of points. Convex polytopes are compact closed and manifold sets. </li>
<li>
<em>elementary polyhedra</em> normally defined as the union of a finite number of convex polytopes. </li>
<li>
<em>polyhedral sets</em> normally defined as the intersection of a finite number of closed halfspaces. Such sets are closed and convex but need not to be compact. </li>
<li>
<em>linear polyhedra</em> normally defined as the set of all points belonging to the simplices of a <em>simplicial complex</em>. </li>
</ul>
<p>A planar <em>Nef polyhedron</em> is any set that can be obtained from a finite set of open halfspaces by set complement and set intersection operations. Due to the fact that all other binary set operations like union, difference and symmetric difference can be reduced to intersection and complement calculations, Nef polyhedra are also closed under those operations. Apart from the set complement operation there are more topological unary set operations that are closed in the domain of Nef polyhedra. Given a Nef polyhedron one can determine its interior, its boundary, and its closure, and also composed operations like regularization (defined to be the closure of the interior or a point set).</p>
<p><a class="anchor" id="fig__nefexamples"></a> </p><div class="image">
<img src="halfplane.png" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__nefexamples">Figure 18.1</a> Two Nef polyhedra in the plane. A closed halfspace on the left and a complex polyhedron on the right. Note that the points on the squared boundary are at infinity. </p> </div> <p> <br>
</p>
<h1><a class="anchor" id="Nef_2Construction"></a>
Construction and Composition</h1>
<p>Following the above definition, the data type <code><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html" title="An instance of data type Nef_polyhedron_2&lt;T&gt; is a subset of the plane that is the result of forming c...">Nef_polyhedron_2</a>&lt;T&gt;</code> allows construction of elementary Nef polyhedra and the binary and unary composition by the mentioned set operations.</p>
<p>In the following examples skip the typedefs at the beginning at first and take the types <code>Point</code> and <code>Line</code> to be models of the standard two-dimensional CGAL kernel (<code><a class="elRef" href="../Kernel_23/classCGAL_1_1Point__2.html">Point_2</a>&lt;K&gt;</code> and <code><a class="elRef" href="../Kernel_23/classCGAL_1_1Line__2.html">Line_2</a>&lt;K&gt;</code>). Their user interface is thus defined in the corresponding reference pages.</p>
<p><br>
<b>File</b> <a class="el" href="Nef_2_2nef_2_construction_8cpp-example.html">Nef_2/nef_2_construction.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" href="../Number_types/Exact__rational_8h.html">CGAL/Exact_rational.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Extended_cartesian.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Nef_polyhedron_2.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Manual/classunspecified__type.html">CGAL::Exact_rational</a> FT;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classCGAL_1_1Extended__cartesian.html">CGAL::Extended_cartesian&lt;FT&gt;</a> Extended_kernel;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2&lt;Extended_kernel&gt;</a> Nef_polyhedron;</div>
<div class="line"><span class="keyword">typedef</span> Nef_polyhedron::Point Point;</div>
<div class="line"><span class="keyword">typedef</span> Nef_polyhedron::Line  Line;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line"> </div>
<div class="line">  Nef_polyhedron N1(Nef_polyhedron::COMPLETE);</div>
<div class="line"> </div>
<div class="line">  Line l(2.1,4.8,2.0); <span class="comment">// l : 2.1x + 4.8y + 2 = 0</span></div>
<div class="line">  Nef_polyhedron N2(l,Nef_polyhedron::INCLUDED);</div>
<div class="line">  Nef_polyhedron N3 = N2.complement();</div>
<div class="line">  assert(N1 == N2.join(N3));</div>
<div class="line"> </div>
<div class="line">  Point p1(0.1,0.), p2(10.8,10.25), p3(-20.18,15.14);</div>
<div class="line">  Point triangle[3] = { p1, p2, p3 };</div>
<div class="line">  Nef_polyhedron N4(triangle, triangle+3);</div>
<div class="line">  Nef_polyhedron N5 = N2.intersection(N4);</div>
<div class="line">  assert(N5 &lt;= N2 &amp;&amp; N5 &lt;= N4);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aExact__rational_8h_html"><div class="ttname"><a href="../Number_types/Exact__rational_8h.html">Exact_rational.h</a></div></div>
<div class="ttc" id="aclassCGAL_1_1Extended__cartesian_html"><div class="ttname"><a href="classCGAL_1_1Extended__cartesian.html">CGAL::Extended_cartesian</a></div><div class="ttdoc">The class Extended_cartesian serves as a traits class for the class Nef_polyhedron_2&lt;T&gt;.</div><div class="ttdef"><b>Definition:</b> Extended_cartesian.h:22</div></div>
<div class="ttc" id="aclassCGAL_1_1Nef__polyhedron__2_html"><div class="ttname"><a href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2</a></div><div class="ttdoc">An instance of data type Nef_polyhedron_2&lt;T&gt; is a subset of the plane that is the result of forming c...</div><div class="ttdef"><b>Definition:</b> Nef_polyhedron_2.h:92</div></div>
<div class="ttc" id="aclassunspecified__type_html"><div class="ttname"><a href="../Manual/classunspecified__type.html">unspecified_type</a></div></div>
</div><!-- fragment --><p>Planar halfspaces (as used in the definition) are modeled by oriented lines. In the previous example <code>N1</code> is the Nef polyhedron representing the full plane, <code>N2</code> is the closed halfspace left of the oriented line with equation \( 2x + 4y + 2 = 0\) including the line, <code>N3</code> is the complement of <code>N2</code> and therefore it must hold that \( N2 \cup N3 = N1\).</p>
<p>Additionally one can construct Nef polyhedra from iterator ranges that hold simple polygonal chains. In the example <code>N4</code> is the triangle spanned by the vertices \( (0,0)\), \( (10,10)\), \( (-20,15)\). Note that the construction from a simple polygonal chain has several cases and preconditions that are described in the reference manual page of <code><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html" title="An instance of data type Nef_polyhedron_2&lt;T&gt; is a subset of the plane that is the result of forming c...">Nef_polyhedron_2</a>&lt;T&gt;</code>. The <code>operator&lt;=</code> in the last assertion is a subset-or-equal comparison of two polyhedra.</p>
<p>Nef polyhedra have input and output operators that allows one to output them via streams and read them from streams. Graphical output is currently possible. For an elaborate example see the demo programs in the directory <code>demo/Nef_2</code>.</p>
<h1><a class="anchor" id="Nef_2Exploration"></a>
Exploration</h1>
<p>By recursively composing binary and unary operations one can end with a very complex rectilinear structure. To explore that structure there is a data type <code><a class="el" href="classCGAL_1_1Nef__polyhedron__2_1_1Explorer.html" title="a decorator to examine the underlying plane map.">Nef_polyhedron_2::Explorer</a></code> that allows read-only exploration of the rectilinear structure. To understand its usability we need more knowledge about the representation of Nef polyhedra.</p>
<p>The rectilinear structure underlying a Nef polyhedron is stored in a selective plane map. Plane map here means a straightline embedded bidirected graph with face objects such that each point in the plane can be uniquely assigned to an object (vertex, edge, face) of the planar subdivision defined by the graph. Selective means that each object (vertex, edge, face) has a Boolean value associated with it to indicate set inclusion or exclusion.</p>
<p>The plane map is defined by the interface data type <code><a class="el" href="classCGAL_1_1Nef__polyhedron__2_1_1Topological__explorer.html" title="An instance D of the data type Topological_explorer is a decorator for interfacing the topological st...">Nef_polyhedron_2::Topological_explorer</a></code>. Embedding the vertices by standard affine points does not suffice to model the unboundedness of halfspaces and ray-like structures. Therefore the planar subdivision is bounded symbolically by an axis-parallel square box of infimaximal size centered at the origin of our coordinate system. All structures extending to infinity are pruned by the box. Lines and rays have symbolic endpoints on the box. Faces are circularly closed. Infimaximal here means that its geometric extend is always large enough (but finite for our intuition). Assume you approach the box with an affine point, then this point is always inside the box. The same holds for straight lines; they always intersect the box. There are more accurate notions of "large enough", but the previous propositions are enough at this point. Due to the fact that the infimaximal box is included in the plane map, the vertices and edges are partitioned with respect to this box.</p>
<p>Vertices inside the box are called standard vertices and they are embedded by affine points of type <code>Explorer::Point</code>. Vertices on the box are called non-standard vertices and they get their embedding where a ray intersects the box (their embedding is defined by an object of type <code>Explorer::Ray</code>). By their straightline embedding, edges represent either segments, rays, lines, or box segments depending on the character of their source and target vertices.</p>
<p>During exploration, box objects can be tracked down by the interface of <code><a class="el" href="classCGAL_1_1Nef__polyhedron__2_1_1Explorer.html" title="a decorator to examine the underlying plane map.">Nef_polyhedron_2::Explorer</a></code> that is derived from <code><a class="el" href="classCGAL_1_1Nef__polyhedron__2_1_1Topological__explorer.html" title="An instance D of the data type Topological_explorer is a decorator for interfacing the topological st...">Nef_polyhedron_2::Topological_explorer</a></code> and adds just the box exploration functionality to the interface of the latter. In the following code fragment we iterate over all vertices of a Nef polyhedron and check whether their embedding is an affine point or a point on the infimaximal frame.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> Nef_polyhedron::Explorer Explorer;</div>
<div class="line">Explorer E = N4.explorer();</div>
<div class="line">Explorer::Vertex_const_iterator v;</div>
<div class="line"><span class="keywordflow">for</span> (v = E.vertices_begin(); v != E.vertices_end(); ++v)</div>
<div class="line">  <span class="keywordflow">if</span> ( E.is_standard(v) )</div>
<div class="line">    Explorer::Point p = E.point(v) <span class="comment">// affine embedding of v</span></div>
<div class="line">  <span class="keywordflow">else</span> <span class="comment">/* non-standard */</span></div>
<div class="line">    Explorer::Ray r = E.ray(v) <span class="comment">// extended embedding of v</span></div>
</div><!-- fragment --><p>Note that box edges only serve as boundary edges (combinatorically) to close the faces that extend to infinity (geometrically). Their status can be queried by the following operation:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> Nef_polyhedron::Explorer Explorer;</div>
<div class="line">Explorer E = N4.explorer();</div>
<div class="line">Explorer::Halfedge_const_iterator e;</div>
<div class="line"><span class="keywordflow">for</span> (e = E.halfedges_begin(); e != E.halfedges_end(); ++e)</div>
<div class="line">  <span class="keywordflow">if</span> ( E.is_frame_edge(e) ) <span class="comment">// e is part of square box.</span></div>
</div><!-- fragment --><p>Let's have a look at a full example where we explore four different Nef polyhedra, namely the complete plane, a halfplane, a triangle, and a triangle with two triangular holes.</p>
<p><br>
<b>File</b> <a class="el" href="Nef_2_2nef_2_exploration_8cpp-example.html">Nef_2/nef_2_exploration.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" href="../Number_types/Exact__integer_8h.html">CGAL/Exact_integer.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Filtered_extended_homogeneous.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Nef_polyhedron_2.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Manual/classunspecified__type.html">CGAL::Exact_integer</a> RT;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classCGAL_1_1Filtered__extended__homogeneous.html">CGAL::Filtered_extended_homogeneous&lt;RT&gt;</a> Extended_kernel;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2&lt;Extended_kernel&gt;</a> Nef_polyhedron;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> Nef_polyhedron::Point Point;  <span class="comment">// a standard point</span></div>
<div class="line"><span class="keyword">typedef</span> Nef_polyhedron::Line  Line;</div>
<div class="line"><span class="keyword">typedef</span> Nef_polyhedron::Explorer Explorer;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> Explorer::Face_const_iterator Face_const_iterator;</div>
<div class="line"><span class="keyword">typedef</span> Explorer::Hole_const_iterator Hole_const_iterator;</div>
<div class="line"><span class="keyword">typedef</span> Explorer::Halfedge_around_face_const_circulator Halfedge_around_face_const_circulator;</div>
<div class="line"><span class="keyword">typedef</span> Explorer::Vertex_const_handle Vertex_const_handle;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> explore(std::string s, <span class="keyword">const</span> Nef_polyhedron&amp;  poly)</div>
<div class="line">{</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Explore: "</span> &lt;&lt; s &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  Explorer explorer = poly.<a class="code hl_function" href="classCGAL_1_1Nef__polyhedron__2.html#a067bf42f1a6b9b13a6fcc45baa30299b">explorer</a>();</div>
<div class="line">  <span class="keywordtype">int</span> i = 0;</div>
<div class="line">  <span class="keywordflow">for</span>(Face_const_iterator fit = explorer.faces_begin(); fit != explorer.faces_end(); ++fit, i++){</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">"\nFace "</span> &lt;&lt; i &lt;&lt; std::endl</div>
<div class="line">              &lt;&lt; ( explorer.mark(fit)? <span class="stringliteral">"* is"</span> : <span class="stringliteral">"* is not"</span>) &lt;&lt; <span class="stringliteral">" marked"</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// explore the outer face cycle if it exists</span></div>
<div class="line">    Halfedge_around_face_const_circulator hafc = explorer.<a class="code hl_function" href="classCGAL_1_1Nef__polyhedron__2_1_1Topological__explorer.html#aecb68b9f586e1c6cd28aab92eee16118">face_cycle</a>(fit);</div>
<div class="line">    <span class="keywordflow">if</span>(hafc == Halfedge_around_face_const_circulator()){</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">"* has no outer face cycle"</span> &lt;&lt; std::endl;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">"* outer face cycle:\n"</span>;</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">"  - halfedges around the face: "</span>;</div>
<div class="line">      Halfedge_around_face_const_circulator done(hafc);</div>
<div class="line">      <span class="keywordflow">do</span> {</div>
<div class="line">        <span class="keywordtype">char</span> c = (explorer.is_frame_edge(hafc))?<span class="charliteral">'f'</span>:<span class="charliteral">'e'</span>;</div>
<div class="line">        std::cout &lt;&lt; c;</div>
<div class="line">        ++hafc;</div>
<div class="line">      }<span class="keywordflow">while</span> (hafc != done);</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">" ( f = frame edge, e = ordinary edge)"</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">"  - vertices around the face:\n"</span>;</div>
<div class="line">      <span class="keywordflow">do</span> {</div>
<div class="line">        Vertex_const_handle vh = explorer.target(hafc);</div>
<div class="line">        <span class="keywordflow">if</span> (explorer.is_standard(vh)){</div>
<div class="line">          std::cout &lt;&lt; <span class="stringliteral">"      "</span> &lt;&lt; explorer.point(vh) &lt;&lt; std::endl;</div>
<div class="line">        }<span class="keywordflow">else</span>{</div>
<div class="line">          std::cout &lt;&lt; <span class="stringliteral">"      "</span> &lt;&lt; explorer.ray(vh) &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">        ++hafc;</div>
<div class="line">      }<span class="keywordflow">while</span> (hafc != done);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// explore the holes if the face has holes</span></div>
<div class="line">    Hole_const_iterator hit = explorer.holes_begin(fit), end = explorer.holes_end(fit);</div>
<div class="line">    <span class="keywordflow">if</span>(hit == end){</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">"* has no hole"</span> &lt;&lt; std::endl;</div>
<div class="line">    }<span class="keywordflow">else</span>{</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">"* has holes"</span> &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">for</span>(; hit != end; hit++){</div>
<div class="line">        Halfedge_around_face_const_circulator hafc(hit), done(hit);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">"  - halfedges around the hole: "</span>;</div>
<div class="line">        <span class="keywordflow">do</span> {</div>
<div class="line">          <span class="keywordtype">char</span> c = (explorer.is_frame_edge(hafc))?<span class="charliteral">'f'</span>:<span class="charliteral">'e'</span>;</div>
<div class="line">          std::cout &lt;&lt; c;</div>
<div class="line">          ++hafc;</div>
<div class="line">        }<span class="keywordflow">while</span> (hafc != done);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">" ( f = frame edge, e = ordinary edge)"</span> &lt;&lt; std::endl;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"done\n"</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_functionRef" href="../Stream_support/group__PkgStreamSupportRef.html#ga2cbb865dd83eedd780f4a452635b1d28">CGAL::IO::set_pretty_mode</a>(std::cout);</div>
<div class="line">  Nef_polyhedron N0(Nef_polyhedron::COMPLETE);</div>
<div class="line">  explore(<span class="stringliteral">"complete"</span>, N0);</div>
<div class="line"> </div>
<div class="line">  Line l(0,1,-2); <span class="comment">// l : 0x + y - 2 = 0</span></div>
<div class="line">  Nef_polyhedron N1(l,Nef_polyhedron::INCLUDED);</div>
<div class="line">  explore(<span class="stringliteral">"line"</span>, N1);</div>
<div class="line"> </div>
<div class="line">  Point p1(1,1), p2(10,1), p3(10,10);</div>
<div class="line">  Point triangle[3] = { p1, p2, p3 };</div>
<div class="line">  Nef_polyhedron N2(triangle, triangle+3);</div>
<div class="line">  explore(<span class="stringliteral">"triangle"</span>, N2);</div>
<div class="line"> </div>
<div class="line">  {</div>
<div class="line">    Point p1(4,2), p2(6,2), p3(6,4);</div>
<div class="line">    Point triangle[3] = { p1, p2, p3 };</div>
<div class="line">    Nef_polyhedron N3(triangle, triangle+3);</div>
<div class="line">    N2 -= N3;</div>
<div class="line">  }</div>
<div class="line">  {</div>
<div class="line">    Point p1(7,2), p2(9,2), p3(9,6);</div>
<div class="line">    Point triangle[3] = { p1, p2, p3 };</div>
<div class="line">    Nef_polyhedron N3(triangle, triangle+3);</div>
<div class="line">    N2 -= N3;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  explore(<span class="stringliteral">"triangle with two triangular holes"</span>, N2);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aExact__integer_8h_html"><div class="ttname"><a href="../Number_types/Exact__integer_8h.html">Exact_integer.h</a></div></div>
<div class="ttc" id="aclassCGAL_1_1Filtered__extended__homogeneous_html"><div class="ttname"><a href="classCGAL_1_1Filtered__extended__homogeneous.html">CGAL::Filtered_extended_homogeneous</a></div><div class="ttdoc">The class Filtered_extended_homogeneous serves as a traits class for the class Nef_polyhedron_2&lt;T&gt;.</div><div class="ttdef"><b>Definition:</b> Filtered_extended_homogeneous.h:20</div></div>
<div class="ttc" id="aclassCGAL_1_1Nef__polyhedron__2_1_1Topological__explorer_html_aecb68b9f586e1c6cd28aab92eee16118"><div class="ttname"><a href="classCGAL_1_1Nef__polyhedron__2_1_1Topological__explorer.html#aecb68b9f586e1c6cd28aab92eee16118">CGAL::Nef_polyhedron_2::Topological_explorer::face_cycle</a></div><div class="ttdeci">Halfedge_around_face_const_circulator face_cycle(Face_const_handle f)</div><div class="ttdoc">returns a circulator for the outer face cycle of f.</div></div>
<div class="ttc" id="aclassCGAL_1_1Nef__polyhedron__2_html_a067bf42f1a6b9b13a6fcc45baa30299b"><div class="ttname"><a href="classCGAL_1_1Nef__polyhedron__2.html#a067bf42f1a6b9b13a6fcc45baa30299b">CGAL::Nef_polyhedron_2::explorer</a></div><div class="ttdeci">Explorer explorer()</div><div class="ttdoc">returns a decorator object that allows read-only access of the underlying plane map.</div></div>
<div class="ttc" id="agroup__PkgStreamSupportRef_html_ga2cbb865dd83eedd780f4a452635b1d28"><div class="ttname"><a href="../Stream_support/group__PkgStreamSupportRef.html#ga2cbb865dd83eedd780f4a452635b1d28">CGAL::IO::set_pretty_mode</a></div><div class="ttdeci">Mode set_pretty_mode(std::ios &amp;s)</div></div>
</div><!-- fragment --><p>Let's start with the Nef polyhedron that consists of the complete 2D plane. This plane is "bounded" by the infimaximal frame with vertices at infinity, and the Nef polyhedron <code>N0</code> has two faces. Face <code>f0</code> is outside of the infimaximal frame without an outer boundary and the infimaximal frame as hole. Face <code>f1</code> is inside the infimaximal frame which is its outer boundary.</p>
<p>With the function <code><a class="el" href="classCGAL_1_1Nef__polyhedron__2_1_1Topological__explorer.html#ac24cb67996cd68ff7caef3e39037b4de" title="returns the mark of v.">Nef_polyhedron_2::Topological_explorer::mark()</a></code> we can check whether a face is part of <code>N0</code>.</p>
<p>With the function <code><a class="el" href="classCGAL_1_1Nef__polyhedron__2_1_1Explorer.html#a458086c5948d8a192b805ecdfd0712e2" title="returns true iff e is part of the infinimaximal frame.">Nef_polyhedron_2::Explorer::is_frame_edge()</a></code> we can distinguish between "standard" edges and infimaximal frame edges. For <code>N0</code> they are all infimaximal.</p>
<p>With the function <code><a class="el" href="classCGAL_1_1Nef__polyhedron__2_1_1Explorer.html#ae9e9ce49f9aed3a634c0adca2fc25268" title="returns true iff v's position is a standard point.">Nef_polyhedron_2::Explorer::is_standard()</a></code> we can distinguish between vertices that are on or inside the infimaximal frame. For <code>N0</code> they are all non standard, and they are at infinity in the direction you get with <code><a class="el" href="classCGAL_1_1Nef__polyhedron__2_1_1Explorer.html#a0f76bb79a851ef64a69406c2fc8b54db" title="returns the ray defining the non-standard point on the frame.">Nef_polyhedron_2::Explorer::ray()</a></code>.</p>
<p><a class="anchor" id="fig__nef_exploration_complete"></a> </p><div class="image">
<object type="image/svg+xml" data="exploration_complete.svg" style="pointer-events: none;"></object>
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__nef_exploration_complete">Figure 18.2</a> The full plane. </p> </div> <p> <br>
</p>
<p>The Nef polyhedron <code>N1</code> consists of a halfplane. It has three faces, namely <code>f0</code> outside and the other two faces inside of the infimaximal frame. Face <code>f1</code> is marked and the two others are not. The hole of <code>f0</code> has six infimaximal edges. The faces <code>f1</code> and <code>f2</code> have three infimaximal and one standard edge, the one between them. All vertices are non-standard. The source of the rays of <code>v4</code> and <code>v5</code> sits on the line and they are directed to the left and to the right.</p>
<p><a class="anchor" id="fig__nef_exploration_half_plane"></a> </p><div class="image">
<object type="image/svg+xml" data="exploration_half_plane.svg" style="pointer-events: none;"></object>
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__nef_exploration_half_plane">Figure 18.3</a> A halfplane. </p> </div> <p> <br>
</p>
<p>The Nef polyhedron <code>N2</code> consists of a triangle. It has three faces, namely <code>f0</code> outside and the other two faces inside of the infimaximal frame. As always <code>f0</code> has no outer boundary but only one hole, namely the infimaximal frame. Face <code>f1</code> has the infimaximal frame as outer boundary, and the triangle as hole, and it is not marked. The outer boundary edges are all frame edges with rays at the vertices <code>v0</code>, <code>v1</code>, <code>v2</code>, and <code>v3</code>. The hole edges are all standard edges with points at the vertices <code>v4</code>, <code>v5</code>, and <code>v6</code>. Face <code>f2</code> is the only marked face, with the triangle as outer boundary and without a hole.</p>
<p><a class="anchor" id="fig__nef_exploration_triangle"></a> </p><div class="image">
<object type="image/svg+xml" data="exploration_triangle.svg" style="pointer-events: none;"></object>
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__nef_exploration_triangle">Figure 18.4</a> A triangle. </p> </div> <p> <br>
</p>
<p>When we subtract two small triangles from <code>N2</code>, the situation is similar to what we described above. Face <code>f2</code> has now two holes, and there are two more faces, <code>f3</code> and <code>f4</code>, which are not marked and with only outer boundaries.</p>
<p><a class="anchor" id="fig__nef_exploration_triangle_with_holes"></a> </p><div class="image">
<object type="image/svg+xml" data="exploration_triangle_with_holes.svg" style="pointer-events: none;"></object>
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__nef_exploration_triangle_with_holes">Figure 18.5</a> A triangle with holes. </p> </div> <p> <br>
</p>
<p>As we can see in the figure below not only faces are marked as being part of the Nef polyhedron, but edges and vertices as well. Just as it is possible to have half open intervals in math, with the endpoint not being part of an interval, the triangle has an edge from <code>v5</code> to <code>v6</code> that is not part of the Nef polyhedron. The same holds for the vertices <code>v8</code>, <code>v9</code>, and <code>v16</code>.</p>
<p>Faces may have isolated points. If the face is marked, a vertex like <code>v9</code> forms a 0-dimensional hole. If the face is not marked, a vertex like <code>v7</code> forms a connected component of what is marked in the Nef polyhedron.</p>
<p>Finally, note that the boundary of a hole is not always at the same time the outer boundary of another face. Face <code>f1</code> has three holes, namely the one with the vertices <code>v4-v8-v6-v5</code>, the one with the vertices <code>v10-11-v12-v11</code>, and the one with the vertices <code>13-17-15-16-15-14</code>.</p>
<p><a class="anchor" id="fig__nef_exploration_isolated"></a> </p><div class="image">
<object type="image/svg+xml" data="exploration_isolated.svg" style="pointer-events: none;"></object>
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__nef_exploration_isolated">Figure 18.6</a> A triangle with holes. </p> </div> <p> <br>
</p>
<h1><a class="anchor" id="Nef_2Traits"></a>
Traits Classes</h1>
<p>Now finally we clarify what the template parameter of class <code><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html" title="An instance of data type Nef_polyhedron_2&lt;T&gt; is a subset of the plane that is the result of forming c...">Nef_polyhedron_2</a>&lt;T&gt;</code> actually models. <code>T</code> carries the implementation of a so-called extended geometric kernel.</p>
<p>Currently there are three kernel models: <code><a class="el" href="classCGAL_1_1Extended__cartesian.html" title="The class Extended_cartesian serves as a traits class for the class Nef_polyhedron_2&lt;T&gt;.">Extended_cartesian</a>&lt;FT&gt;</code>, <code><a class="el" href="classCGAL_1_1Extended__homogeneous.html" title="The class Extended_homogeneous serves as a traits class for the class Nef_polyhedron_2&lt;T&gt;.">Extended_homogeneous</a>&lt;RT&gt;</code>, and <code><a class="el" href="classCGAL_1_1Filtered__extended__homogeneous.html" title="The class Filtered_extended_homogeneous serves as a traits class for the class Nef_polyhedron_2&lt;T&gt;.">Filtered_extended_homogeneous</a>&lt;RT&gt;</code>. The latter is the most optimized one. The former two are simpler versions corresponding to the simple planar affine kernels. Actually, it holds that (type equality in pseudo-code notation):</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2&lt; CGAL::Extended_cartesian&lt;FT&gt;</a> &gt;::Point == <a class="code hl_structRef" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;FT&gt;::Point_2</a></div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2&lt; CGAL::Extended_homogeneous&lt;RT&gt;</a> &gt;::Point == <a class="code hl_structRef" href="../Kernel_23/structCGAL_1_1Homogeneous.html">CGAL::Homogeneous&lt;RT&gt;::Point_2</a></div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2&lt; CGAL::Filtered_extended_homogeneous&lt;RT&gt;</a> &gt;::Point == <a class="code hl_structRef" href="../Kernel_23/structCGAL_1_1Homogeneous.html">CGAL::Homogeneous&lt;RT&gt;::Point_2</a></div>
<div class="ttc" id="astructCGAL_1_1Cartesian_html"><div class="ttname"><a href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian</a></div></div>
<div class="ttc" id="astructCGAL_1_1Homogeneous_html"><div class="ttname"><a href="../Kernel_23/structCGAL_1_1Homogeneous.html">CGAL::Homogeneous</a></div></div>
</div><!-- fragment --><p>Similar equations hold for the types <code>Line</code> and <code>Direction</code> in the local scope of <code><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html" title="An instance of data type Nef_polyhedron_2&lt;T&gt; is a subset of the plane that is the result of forming c...">Nef_polyhedron_2</a></code>.</p>
<p>For its notions and requirements see the description of the concept <code><a class="el" href="classExtendedKernelTraits__2.html" title="ExtendedKernelTraits_2 is a kernel concept providing extended geometryIt is called extended geometry ...">ExtendedKernelTraits_2</a></code> in the reference manual.</p>
<h1><a class="anchor" id="Nef_2Implementation"></a>
Implementation</h1>
<p>The underlying set operations are realized by an efficient and complete algorithm for the overlay of two plane maps. The algorithm is efficient in the sense that its running time is bounded by the size of the inputs plus the size of the output times a logarithmic factor. The algorithm is complete in the sense that it can handle all inputs and requires no general position assumption. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"></a> 1.9.6 </li>
  </ul>
</div>
</div>
</body>


</html>
