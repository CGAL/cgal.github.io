<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Manual/Tutorial_Triangulation_2.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=11">
<meta name="generator" content="Doxygen 1.9.6">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CGAL 6.1 - Manual: 2D Triangulations</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<link href="navtree.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      },
      equationNumbers: { autoNumber: "AMS" }
  }
}
);
MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
  var PARSE = MathJax.InputJax.TeX.Parse,
      TEXT = PARSE.prototype.InternalText;
  PARSE.Augment({
    InternalText: function (text,def) {
      text = text.replace(/\\/g,"");
      return TEXT.call(this,text,def);
    }
  });
});
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
          <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()">Â </span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""></a>
          </span>
        </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CGAL 6.1 - Manual
   </div>
  </td>
  <!-- We disable the search box because we have added it in the
  back-nav for stylistic reasons. -->
  <!-- <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td> -->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('Tutorial_Triangulation_2.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">2D Triangulations </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"> <div id="autotoc" class="toc"></div> <dl class="section author"><dt>Author</dt><dd>Andreas Fabri</dd></dl>
<p>A 2D triangulation is a decomposition of the 2D plane in vertices and triangular faces.</p>
<p>In the first section we will walk you through the API of a class representing a Delaunay triangulation which operates on a set of points, followed by a section covering the API of a class representing a constrained Delaunay triangulation which operates on a set of points and segments.</p>
<p>Note that this tutorial is not about computational geometry, so we assume you are familiar with Delaunay triangulation with and without constraints.</p>
<h1><a class="anchor" id="Tutorial_Delaunay_2"></a>
Delaunay Triangulation</h1>
<p>In the example code of this section we use a class template <code><a class="elRef" href="../Triangulation_2/classCGAL_1_1Delaunay__triangulation__2.html">Delaunay_triangulation_2</a></code> together with a <em>kernel</em> which provides types for points, segments or triangles, as well as <em>predicates</em>, for example the incircle test needed for the empty circle property of this type of triangulations.</p>
<p>So we start with some <code>#include</code> and some <code>using</code> statements to define types.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Delauanay_triangulation_2.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/draw_triangulation_2.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span><a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a> = <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div>
<div class="line"><span class="keyword">using </span>Point = Delaunay::Point;</div>
<div class="line"><span class="keyword">using </span>Delaunay = <a class="code hl_classRef" href="../Triangulation_2/classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2&lt;Kernel&gt;</a>;</div>
<div class="ttc" id="aclassCGAL_1_1Delaunay__triangulation__2_html"><div class="ttname"><a href="../Triangulation_2/classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2</a></div></div>
<div class="ttc" id="aclassCGAL_1_1Exact__predicates__inexact__constructions__kernel_html"><div class="ttname"><a href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a></div></div>
<div class="ttc" id="anamespaceKernel_html"><div class="ttname"><a href="../Kernel_23/namespaceKernel.html">Kernel</a></div></div>
</div><!-- fragment --><p>When we insert a set of points in the triangulation, it generates a set of finite vertices corresponding to the points, and the decomposition of the convex hull of the points in finite triangular faces. Additionally, the triangulation generates infinite faces, which are incident to the edges of the convex hull and which have as third vertex a single infinite vertex. When we draw the triangulation we only draw finite vertices and faces.</p>
<div class="fragment"><div class="line">  std ::array&lt;Point, 4&gt; points = {Point(0, 0), Point(2, 0), Point(0, 2), Point(2, 2)};</div>
<div class="line">  Delaunay dt;</div>
<div class="line">  dt.insert(points.begin(), points.end());</div>
<div class="line">  <span class="keyword">auto</span> vh = dt.insert(Point(1, 1));</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_functionRef" href="../Polygon/group__PkgDrawPolygon2.html#ga56a8df4559b043b885be909514e6069f">CGAL::draw</a>(dt);</div>
<div class="ttc" id="agroup__PkgDrawPolygon2_html_ga56a8df4559b043b885be909514e6069f"><div class="ttname"><a href="../Polygon/group__PkgDrawPolygon2.html#ga56a8df4559b043b885be909514e6069f">CGAL::draw</a></div><div class="ttdeci">void draw(const P &amp;p, const GSOptions &amp;gso)</div></div>
</div><!-- fragment --><p>FIGURE</p>
<p>We inserted a range of points from a <code>std::array</code> but the insert functions can take any range type, e.g., a <code>std::vector</code> or <code>std::list</code>. When we insert an individual point we obtained a <em>vertex handle</em> <code>vh</code>. A handle is a pointer to a vertex object, and no surprise when we write <code>v-&gt;point()</code> into <code>std::cout</code> we will see <code>1 1</code> on the console.</p>
<p>Just like the standard containers, the triangulation provides iterators to enumerate its elements, that is either all or only the finite vertices and faces. When we iterate over all elements we often have to check whether they are finite. It makes no sense to access the point of the infinite vertex, or to compute the area of an infinite face.</p>
<div class="fragment"><div class="line">  std::cout &lt;&lt; vh-&gt;point() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keyword">auto</span> it dt.all_vertices_begin(); it != dt.all_vertices_end(); ++it)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span>(dt.is_infinite(it))</div>
<div class="line">      <span class="keywordflow">continue</span>;</div>
<div class="line">    std::cout &lt;&lt; it-&gt;point() &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keyword">auto</span> it dt.finite_vertices_begin(); it != dt.finite_vertices_end(); ++it)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; it-&gt;point() &lt;&lt; std::endl;</div>
<div class="line">  }</div>
</div><!-- fragment --><p>We next see how to navigate between vertices and faces. For vertex <code>vh</code> we can obtain one incident face calling <code>vh-&gt;face()</code>. We next enumerate the faces incident to vertex handle <code>vh</code>. As there is no natural begin and end of incident faces the function call <code>dt.incident_faces(vh)</code> returns a <em>circulator</em>. Just like an iterator you can increment and dereference a circulator. While for an iterator you test for being past-the-end, for a circulator you test if you are again where you started using a <code>do</code>-loop.</p>
<p>While a vertex can have an arbitrary number of incident faces, a face has always three incident vertices, which we access in the nested <code>for</code>-loop.</p>
<div class="fragment"><div class="line">  <span class="keyword">auto</span> fh = vh-&gt;face();</div>
<div class="line">  <span class="keyword">auto</span> fc = dt.incident_faces(vh), done(fc);</div>
<div class="line">  <span class="keywordflow">do</span> {</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i){</div>
<div class="line">      <span class="keywordflow">if</span>(vh == fc-&gt;vertex(i))</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">"vh has index "</span> &lt;&lt; i  <span class="stringliteral">" in the face"</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">  }<span class="keywordflow">while</span>(++fc != done);</div>
</div><!-- fragment --><p>The call <code>dt.incident_vertices()</code> returns a circulator over the one-ring of a vertex. If you pass it a vertex on the convex hull, the infinite vertex is in the one-ring. If you pass it the infinite vertex, you will circulate over the vertices of the convex hull.</p>
<p>Let's return to our vertex <code>vh</code> and its incident face <code>fh</code> and determine the index of <code>vh</code> in <code>fh</code>. The index is either 0, 1, or 2, in counterclockwise order. The triangulation class has static functions <code>cw()</code> and <code>ccw()</code> for computing the index of the clockwise and counterclockwise neighbor vertex.</p>
<div class="fragment"><div class="line">  <span class="keywordtype">int</span> ind =  fh-&gt;index(vh);</div>
<div class="line">  <span class="keyword">auto</span> cwv = fh-&gt;vertex(Delaunay::cw(ind));</div>
<div class="line">  <span class="keyword">auto</span> ccwv = fh-&gt;vertex(Delaunay::ccw(ind));</div>
</div><!-- fragment --><p>With the <code>neighbor()</code> function we can obtain the face opposite to <code>vh</code>. And symmetrically, we now obtain the index of <code>fh</code> in <code>nh</code>, and finally the vertex opposite to <code>fh</code>.</p>
<div class="fragment"><div class="line">  <span class="keyword">auto</span> nh = fh-&gt;neighbor(ind);</div>
<div class="line">  <span class="keywordtype">int</span> nind = nh-&gt;index(fh);</div>
<div class="line">  <span class="keyword">auto</span> nvh = nh-&gt;vertex(nind);</div>
</div><!-- fragment --><p>FIGURE</p>
<p>We saw a lot of <code>auto</code> instead of real types. Depending on your programming style you may like them or you may prefer writing some more <code>using</code> statemenmts.</p>
<div class="fragment"><div class="line"><span class="keyword">using </span>Vertex_handle = Delaunay::Vertex_handle;</div>
<div class="line"><span class="keyword">using </span>Face_handle = Delaunay::Face_handle;</div>
</div><!-- fragment --><p>and then use them like this, so that when reading the code it is absolutely clear of what type a variable is.</p>
<div class="fragment"><div class="line">  {</div>
<div class="line">    Face_handle nh = fh-&gt;neighbor(ind);</div>
<div class="line">    <span class="keywordtype">int</span> nind = nh-&gt;index(fh);</div>
<div class="line">    Vertex_handle nvh = nh-&gt;vertex(nind);</div>
<div class="line">  }</div>
</div><!-- fragment --><p>In a triangulation we also have <em>edges</em>. However, they are just a <code>std::pair</code> and hold a face handle and an index. No surprise that the index is the one of the vertex opposite to the edge. The <code>mirror()</code> function, which for an edge returns the edge seen from the other side, is there for convenience. Note that an edge and its mirror edge are not equal.</p>
<div class="fragment"><div class="line">  Delaunay::Edge e(fh, ind);</div>
<div class="line">  Delaunay::Edge me =dt.mirror_edge(e);</div>
<div class="line">  assert(me.first.vertex(me.second) == nvh);</div>
</div><!-- fragment --><p>The triangulation offers iterators to enumerate all edges, and circulators to enumerate the edges incident to a vertex.</p>
<p>We will next turn to <em>point location</em>, that is given a 2D point <code>p</code> we want to determine where in the triangulation it is. The function returns a face handle we store in <code>fh</code>. The point may be on a vertex of <code>fh</code>, on an edge of <code>fh</code>, inside <code>fh</code> in case it is a finite face, or it may be outside the convex hull. The function writes this information in the non-const parameter <code>lt</code> of type <code>Locate_type</code>. And it additionally writes into the non-const parameter <code>li</code>, the locate index, the index of the vertex or edge in face <code>fh</code> , in case <code>lt</code> is <code>Delaunay::VERTEX</code> or <code>Delaunay::EDGE</code>. If <code>lt</code> is <code>Delaunay::FACE</code> or <code>Delaunay::OUTSIDE_CONVEX_HULL</code> the locate index has no meaning.</p>
<div class="fragment"><div class="line">  fh = dt.locate(Point(1, 1));</div>
</div><!-- fragment --><p>The function <code>Delaunay::locate()</code> has another optional parameter, namely a face from where to start the point location. Let's explain how point location works to understand why the hint is important. Without the hint the algorithm starts at an arbitrary vertex, and traverses faces in the direction of the query point. So when you have query points which have some spatial coherence you better pass the result of a previous point location query as hint where to start for the current one. You might have a look at the function <code><a class="elRef" href="../Spatial_sorting/group__PkgSpatialSortingFunctions.html#ga9da67204747ac19dff65f9c9ff2fca9e">hilbert_sort()</a></code> to learn more about what we mean with spatial coherence.</p>
<p>Concerning the traversal of a triangulation we finish with the <em>line face circulator</em>. This circulator enables to traverse all faces that are intersected by a line defined by two points <code>p0</code> and <code>p1</code>, and is obtained by the call <code>dt.line_walk(p0,p1)</code>. The traversal starts where <code>p0</code> is located. It is a circulator as the traversal wraps around where the line intersects the convex hull. Note that the points, and even the line may be outside of the convex hull. We refer to the Reference Manual for explaining in detail which faces are traversed in case the line passes through a vertex. Again a hint can be given for the point location of the first point. You may think that the <code>line_walk()</code> function gets used to get from <code>p0</code> to <code>p1</code>, but that is not the case. Instead a "zigag" walk is performed that makes less geometric tests.</p>
<div class="fragment"><div class="line">  <span class="keyword">auto</span> lfc = dt.line_walk(Point(0.5, 0.5), Point(1.5, 0.5)), lfcdone(lfc);</div>
<div class="line">  <span class="keywordflow">do</span>{</div>
<div class="line">    <span class="keywordflow">if</span>(! dt.is_infinite(lfc))</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">"."</span> ;</div>
<div class="line">  }<span class="keywordflow">while</span>(lfc != lfcdone);</div>
<div class="line">  std::cout &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>We invite you to have a look at the examples in the User Manual which show how to enrich vertices and faces with information, how to operate on 3D points when the triangulation is 2.5D and represents a terrain, and more.</p>
<h1><a class="anchor" id="Tutorial_Constrained_Delaunay_2"></a>
Constrained Delaunay Triangulation</h1>
<p>Only jump into this section if you are familiar with iterators, circulators, the notion of <code>Edge</code>, locate type and locate index explained in the previous section.</p>
<p>In case the input is not just points but also segments in the plane, a constrained triangulation has edges that do not cross constraints. A constraint may be a single edge or split into several edges in case constraints intersect or in case an input pout lies on a constraint.</p>
<p>In this section we first explain the API of the class template <code><a class="elRef" href="../Triangulation_2/classCGAL_1_1Constrained__Delaunay__triangulation__2.html">Constrained_Delaunay_triangulation_2</a></code>, and then <code><a class="elRef" href="../Triangulation_2/classCGAL_1_1Constrained__triangulation__plus__2.html">Constrained_triangulation_plus_2</a></code>, admittedly a strange name. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"></a> 1.9.6 </li>
  </ul>
</div>
</div>
</body>

</html>
