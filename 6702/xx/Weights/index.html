<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Weights/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 5.6 - Weights: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//&lt;![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      }
  }
}
);
//]]&gt;
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.6 - Weights
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Weights"></a>  </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Author</dt><dd>Dmitry Anisimov</dd></dl>
<h1><a class="anchor" id="Weights_Intro"></a>
Introduction</h1>
<p>Many geometric algorithms rely on the intermediate computation of scalars, so-called <em>weights</em>, which are then used for solving different linear systems or to favor one result over another, also known as <em>weighting</em>. This package provides a simple and unified interface to different types of weights.</p>
<p>A typical example of a geometric algorithm that requires weights is the <em>Laplace smoothing</em> of a triangle mesh:</p>
<p>\(v_i \leftarrow v_i + h \lambda\Delta v_i\),</p>
<p>where \(v_i\) is the position of the mesh vertex \(i\), \(h\) is a sufficiently small time step, \(\lambda\) is the scalar diffusion coefficient, and \(\Delta v_i\) is the discrete average of the <em>Laplace-Beltrami operator</em> at vertex \(v_i\) computed using the <em>cotangent weights</em>:</p>
<p>\(\Delta v_i = w_i\sum_{v_j \in N_1(v_i)} w_{ij} (v_j - v_i)\),</p>
<p>where \(w_i = \frac{1}{2A_i}\) and \(w_{ij} = \cot\beta_{ij} + \cot\gamma_{ij}\) and \(A_i\) is a <em>local averaging domain</em>.</p>
<p>Here, the weights \(w_{ij}\) can be computed using the <a class="el" href="group__PkgWeightsRefCotangentWeights.html">cotangent weight</a> and the local averaging domain can be computed using the <a class="el" href="group__PkgWeightsRefMixedVoronoiRegionWeights.html">mixed Voronoi region weight</a>. The algorithm above smooths the mesh geometry, resulting in a higher quality version of the original mesh. The full example of the discretized <em>Laplacian</em> for all vertices of a triangle mesh can be found <a class="el" href="index.html#Weights_Examples_WeightedLaplacian">here</a>.</p>
<p>There are many other scenarios where the weights from this package are used. In particular, the following CGAL packages make use of weights described in this package: <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgBarycentricCoordinates2">2D Generalized Barycentric Coordinates</a>, <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgPolygonMeshProcessing">Polygon Mesh Processing</a>, <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceMeshDeformation">Triangulated Surface Mesh Deformation</a>, <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceMeshParameterization">Triangulated Surface Mesh Parameterization</a>, <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceMeshSkeletonization">Triangulated Surface Mesh Skeletonization</a>, and <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgHeatMethod">The Heat Method</a>.</p>
<h1><a class="anchor" id="Weights_Groups"></a>
Weights</h1>
<p>We call <em>analytic weights</em> all weights which can be computed with a simple analytic expression. All weights from this package can be computed analytically. However, for better navigation through all available weights and their applications, we distinguish three typical groups of weights:</p>
<ul>
<li><a class="el" href="group__PkgWeightsRefAnalytic.html">Analytic Weights</a> include all basic weights which can be computed for a query point with respect to its local neighbors in 2D or 3D, however these neighbors are defined. Usually, the configuration is a query point and three other points. These weights return one unique value per query point.</li>
<li><a class="el" href="group__PkgWeightsRefBarycentric.html">Barycentric Weights</a> include all weights which can be computed for a query point with respect to the vertices of a planar polygon. These weights return \(n\) values per query point, where \(n\) is the number of polygon vertices. Barycentric weights are also used for computing <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgBarycentricCoordinates2">2D barycentric coordinates</a>.</li>
<li><a class="el" href="group__PkgWeightsRefRegions.html">Weighting Regions</a> include all weights which are used to balance other weights but are rarely used on their own. Sometimes, such weights are also referred to as <em>local averaging regions</em>. These weights are usually lengths, areas, and volumes of 2D and 3D objects.</li>
</ul>
<h1><a class="anchor" id="Weights_Implementation"></a>
Implementation</h1>
<p>All weight functions have a simple and unified interface. In particular, all analytic weight functions usually take a query point and three other points in 2D or 3D and return a unique scalar. They all have the same signature and are parameterized by a traits class that must be a model of <code><a class="el" href="classAnalyticWeightTraits__2.html" title="A concept that describes the set of requirements of classes used in the computation of analytic weigh...">AnalyticWeightTraits_2</a></code> for 2D computations or <code><a class="el" href="classAnalyticWeightTraits__3.html" title="A concept that describes the set of requirements of classes used in the computation of analytic weigh...">AnalyticWeightTraits_3</a></code> for 3D computations.</p>
<p>The barycentric weight functions are parameterized by a traits class of the concept <code><a class="el" href="classAnalyticWeightTraits__2.html" title="A concept that describes the set of requirements of classes used in the computation of analytic weigh...">AnalyticWeightTraits_2</a></code> and they are all models of the concept <code><a class="el" href="classBarycentricWeights__2.html" title="A concept that describes the set of methods required in all classes used in the computation of 2D gen...">BarycentricWeights_2</a></code>. They take an input polygon and a query point and compute the weights at this point with respect to all vertices of the polygon. The computed weights are then returned in a container providing the corresponding output iterator. These weight functions also provide a <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgPropertyMap">property map</a> mechanism for mapping a user type of the polygon vertex to <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__2.html">CGAL::Point_2</a></code>.</p>
<p>All weighting regions have the same signature and are parameterized by a traits class of the concept <code><a class="el" href="classAnalyticWeightTraits__2.html" title="A concept that describes the set of requirements of classes used in the computation of analytic weigh...">AnalyticWeightTraits_2</a></code> or <code><a class="el" href="classAnalyticWeightTraits__3.html" title="A concept that describes the set of requirements of classes used in the computation of analytic weigh...">AnalyticWeightTraits_3</a></code>. The returned weight is a unique scalar.</p>
<p>The <code>traits</code> parameter can be omitted for all functions and classes if it can be deduced from the input point type using <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Kernel__traits.html">CGAL::Kernel_traits</a></code>.</p>
<p>Several weights in this package have different implementations. One reason to have it is explained in section about <a class="el" href="index.html#Weights_Implementation_Coplanarity">Coplanarity</a>. Another reason is that the same weights are named and computed differently in different communities. If one searches for these weights, one needs to know all their alternative names which is problematic. We provide the most common names and implementations of these weights.</p>
<h2><a class="anchor" id="Weights_Implementation_Coplanarity"></a>
Coplanarity</h2>
<p>When computing weights for a query point \(q\) with respect to its neighbors \(p_0\), \(p_1\), and \(p_2\), the local configuration is a quadrilateral [ \(p_0\), \(p_1\), \(p_2\), \(q\)] or two connected triangles [ \(q\), \(p_0\), \(p_1\)] and [ \(q\), \(p_1\), \(p_2\)]. When working in 3D, these triangles are not necessarily coplanar, in other words, they do not belong to the same common plane.</p>
<p>Certain weights in this package support only coplanar configurations, while other weights support both. The weights which support non-coplanar configurations, provide the corresponding overloads with 3D points, while other weights accept only 2D point types. For example, <a class="el" href="group__PkgWeightsRefCotangentWeights.html">cotangent weights</a> support both coplanar and non-coplanar configurations, while <a class="el" href="group__PkgWeightsRefDiscreteHarmonicWeights.html">discrete harmonic weights</a> support only coplanar configurations.</p>
<h2><a class="anchor" id="Weights_Implementation_Edge_Cases"></a>
Edge Cases</h2>
<p>None of the weights in this package are defined for query points which belong to</p>
<ul>
<li><em>end segments</em> so-called <em>edges</em>, for example [ \(p_0\), \(p_1\)] or [ \(p_1\), \(p_2\)] or any polygon edge and to</li>
<li><em>end points</em> so-called <em>corners</em>, for example \(p_0\), \(p_1\), or \(p_2\) or any polygon corner.</li>
</ul>
<p>For example, if \(q\) = \(p_0\) or \(q \in [p_0, p_1]\), a weight may be undefined due to invalid operations such as division by zero.</p>
<p>Several weights also require additional conditions to be satisfied. Consult the reference manual for more details.</p>
<h1><a class="anchor" id="Weights_Examples"></a>
Examples</h1>
<p>In this section, you can find a few examples of how and when the provided weights can be used.</p>
<h2><a class="anchor" id="Weights_Examples_First"></a>
The First Example</h2>
<p>This trivial example shows how to compute several analytic weights and weighting regions. Other weights have the same interface so they can be computed analogously.</p>
<p><br />
<b>File</b> <a class="el" href="Weights_2weights_8cpp-example.html">Weights/weights.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Weights_8h.html">CGAL/Weights.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Typedefs.</span></div><div class="line"><span class="keyword">using</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>  = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> FT      = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"><span class="keyword">using</span> Point_2 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>;</div><div class="line"><span class="keyword">using</span> Point_3 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ae82b7f4be77dd5b8819ebe419e4ae753">Kernel::Point_3</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">  <span class="comment">// 2D configuration.</span></div><div class="line">  <span class="keyword">const</span> Point_2 t2(-1,  0); <span class="comment">// p0</span></div><div class="line">  <span class="keyword">const</span> Point_2 r2( 0, -1); <span class="comment">// p1</span></div><div class="line">  <span class="keyword">const</span> Point_2 p2( 1,  0); <span class="comment">// p2</span></div><div class="line">  <span class="keyword">const</span> Point_2 q2( 0,  0); <span class="comment">// query</span></div><div class="line"></div><div class="line">  <span class="comment">// 3D configuration.</span></div><div class="line">  <span class="keyword">const</span> Point_3 t3(-1,  0, 1); <span class="comment">// p0</span></div><div class="line">  <span class="keyword">const</span> Point_3 r3( 0, -1, 1); <span class="comment">// p1</span></div><div class="line">  <span class="keyword">const</span> Point_3 p3( 1,  0, 1); <span class="comment">// p2</span></div><div class="line">  <span class="keyword">const</span> Point_3 q3( 0,  0, 1); <span class="comment">// query</span></div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"2D/3D tangent weight: "</span>;</div><div class="line">  std::cout &lt;&lt; <a class="code" href="group__PkgWeightsRefTangentWeights.html#ga993a91b3c985aa7679263cf75ddfc6df">CGAL::Weights::tangent_weight</a>(t2, r2, p2, q2) &lt;&lt; <span class="stringliteral">"/"</span>;</div><div class="line">  std::cout &lt;&lt; <a class="code" href="group__PkgWeightsRefTangentWeights.html#ga993a91b3c985aa7679263cf75ddfc6df">CGAL::Weights::tangent_weight</a>(t3, r3, p3, q3) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"2D/3D Shepard weight: "</span>;</div><div class="line">  std::cout &lt;&lt; <a class="code" href="group__PkgWeightsRefShepardWeights.html#ga26ba6ba90c57ff35e393d4689a1945cb">CGAL::Weights::shepard_weight</a>(r2, q2, 2.0) &lt;&lt; <span class="stringliteral">"/"</span>;</div><div class="line">  std::cout &lt;&lt; <a class="code" href="group__PkgWeightsRefShepardWeights.html#ga26ba6ba90c57ff35e393d4689a1945cb">CGAL::Weights::shepard_weight</a>(r3, q3, 2.0) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"2D/3D barycentric area: "</span>;</div><div class="line">  std::cout &lt;&lt; <a class="code" href="group__PkgWeightsRefBarycentricRegionWeights.html#ga7f06738d912a04f46a201d4f4c7057f4">CGAL::Weights::barycentric_area</a>(p2, q2, r2) &lt;&lt; <span class="stringliteral">"/"</span>;</div><div class="line">  std::cout &lt;&lt; <a class="code" href="group__PkgWeightsRefBarycentricRegionWeights.html#ga7f06738d912a04f46a201d4f4c7057f4">CGAL::Weights::barycentric_area</a>(p3, q3, r3) &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Weights_Examples_CoordinatesOneQuery"></a>
Computing 2D Coordinates for One Query Point</h2>
<p>This example shows how to compute barycentric weights and barycentric coordinates, which are normalized barycentric weights, for a query point with respect to a polygon in 2D. Since we have only one query point, we use a free function to show the simplified interface. For multiple query points though, calling a free function is not efficient (see the following example for more details). The used type of barycentric weights is <code><a class="el" href="classCGAL_1_1Weights_1_1Discrete__harmonic__weights__2.html" title="2D discrete harmonic weights for polygons. ">Discrete_harmonic_weights_2</a></code>.</p>
<p><br />
<b>File</b> <a class="el" href="Weights_2coordinates_one_query_8cpp-example.html">Weights/coordinates_one_query.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Weights/discrete_harmonic_weights.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Typedefs.</span></div><div class="line"><span class="keyword">using</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>  = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> FT      = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"><span class="keyword">using</span> Point_2 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">  <span class="comment">// Create a polygon and a query point.</span></div><div class="line">  <span class="keyword">const</span> std::vector&lt;Point_2&gt; polygon =</div><div class="line">    { Point_2(0, 0), Point_2(1, 0), Point_2(1, 1), Point_2(0, 1) };</div><div class="line">  <span class="keyword">const</span> Point_2 query(0.5, 0.5);</div><div class="line"></div><div class="line">  <span class="comment">// Allocate memory for weights and coordinates.</span></div><div class="line">  std::vector&lt;FT&gt; weights;</div><div class="line">  weights.reserve(polygon.size());</div><div class="line">  std::vector&lt;FT&gt; coordinates;</div><div class="line">  coordinates.reserve(polygon.size());</div><div class="line"></div><div class="line">  <span class="comment">// Compute barycentric weights.</span></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Barycentric_coordinates_2.tag:../Barycentric_coordinates_2/" href="../Barycentric_coordinates_2/group__PkgBarycentricCoordinates2RefFunctions.html#gafa8833d919e532373b01c9ca09d9a0d8">CGAL::Weights::discrete_harmonic_weights_2</a>(polygon, query, std::back_inserter(weights));</div><div class="line">  assert(weights.size() == polygon.size());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"2D weights: "</span>;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> FT weight : weights) {</div><div class="line">    std::cout &lt;&lt; weight &lt;&lt; <span class="stringliteral">" "</span>;</div><div class="line">  }</div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Normalize weights in order to get barycentric coordinates.</span></div><div class="line">  FT sum = 0.0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> FT weight : weights) {</div><div class="line">    sum += weight;</div><div class="line">  }</div><div class="line">  assert(sum != 0.0);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> FT weight : weights) {</div><div class="line">    coordinates.push_back(weight / sum);</div><div class="line">  }</div><div class="line">  assert(coordinates.size() == weights.size());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"2D coordinates: "</span>;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> FT coordinate : coordinates) {</div><div class="line">    std::cout &lt;&lt; coordinate &lt;&lt; <span class="stringliteral">" "</span>;</div><div class="line">  }</div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Weights_Examples_CoordinatesMultipleQueries"></a>
Computing 2D Coordinates for Multiple Query Points</h2>
<p>This example shows how to compute barycentric weights and barycentric coordinates, which are normalized barycentric weights, for a set of query points with respect to a polygon in 2D. Since we have multiple query points, we first create a class and then use it to compute the weights. Using a class for multiple query points is preferred, because in that case, the memory required for computing weights is allocated only once, while when using a free function as in the previous example, it is allocated for each query point. The used type of barycentric weights is <code><a class="el" href="classCGAL_1_1Weights_1_1Wachspress__weights__2.html" title="2D Wachspress weights for polygons. ">Wachspress_weights_2</a></code>.</p>
<p><br />
<b>File</b> <a class="el" href="Weights_2coordinates_multiple_queries_8cpp-example.html">Weights/coordinates_multiple_queries.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/point_generators_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Weights/wachspress_weights.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Typedefs.</span></div><div class="line"><span class="keyword">using</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>  = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> FT      = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"><span class="keyword">using</span> Point_2 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> PointRange = std::vector&lt;Point_2&gt;;</div><div class="line"><span class="keyword">using</span> Creator    = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Creator__uniform__2.html">CGAL::Creator_uniform_2&lt;FT, Point_2&gt;</a>;</div><div class="line"><span class="keyword">using</span> Generator  = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Generator.tag:../Generator/" href="../Generator/classCGAL_1_1Random__points__in__square__2.html">CGAL::Random_points_in_square_2&lt;Point_2, Creator&gt;</a>;</div><div class="line"><span class="keyword">using</span> Wachspress = <a class="code" href="classCGAL_1_1Weights_1_1Wachspress__weights__2.html">CGAL::Weights::Wachspress_weights_2&lt;PointRange, Kernel&gt;</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">  <span class="comment">// Choose how many query points we want to generate.</span></div><div class="line">  <span class="keyword">const</span> std::size_t num_queries = 10;</div><div class="line"></div><div class="line">  <span class="comment">// Create a polygon.</span></div><div class="line">  <span class="keyword">const</span> std::vector&lt;Point_2&gt; polygon =</div><div class="line">    { Point_2(0, 0), Point_2(1, 0), Point_2(1, 1), Point_2(0, 1) };</div><div class="line"></div><div class="line">  <span class="comment">// Generate a set of query points.</span></div><div class="line">  std::vector&lt;Point_2&gt; queries;</div><div class="line">  queries.reserve(num_queries);</div><div class="line">  Generator generator(1.0);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__STLAlgos.html#gacb8df77d1d07b9cfff3fdd2f5d9c4fda">std::copy_n</a>(generator, num_queries, std::back_inserter(queries));</div><div class="line">  assert(queries.size() == num_queries);</div><div class="line"></div><div class="line">  <span class="comment">// Allocate memory for weights and coordinates.</span></div><div class="line">  std::vector&lt;FT&gt; weights;</div><div class="line">  weights.reserve(num_queries * polygon.size());</div><div class="line">  std::vector&lt;FT&gt; coordinates;</div><div class="line">  coordinates.reserve(num_queries * polygon.size());</div><div class="line"></div><div class="line">  <span class="comment">// Compute barycentric weights.</span></div><div class="line">  Wachspress wachspress(polygon);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> Point_2&amp; query : queries) {</div><div class="line">    wachspress(query, std::back_inserter(weights));</div><div class="line">  }</div><div class="line">  assert(weights.size() == num_queries * polygon.size());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"2D weights: "</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; weights.size(); i += polygon.size()) {</div><div class="line">    <span class="keywordflow">for</span> (std::size_t j = 0; j &lt; polygon.size(); ++j) {</div><div class="line">      std::cout &lt;&lt; weights[i + j] &lt;&lt; <span class="stringliteral">" "</span>;</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Normalize weights in order to get barycentric coordinates.</span></div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; weights.size(); i += polygon.size()) {</div><div class="line">    FT sum = 0.0;</div><div class="line">    <span class="keywordflow">for</span> (std::size_t j = 0; j &lt; polygon.size(); ++j) {</div><div class="line">      sum += weights[i + j];</div><div class="line">    }</div><div class="line">    assert(sum != 0.0);</div><div class="line">    <span class="keywordflow">for</span> (std::size_t j = 0; j &lt; polygon.size(); ++j) {</div><div class="line">      coordinates.push_back(weights[i + j] / sum);</div><div class="line">    }</div><div class="line">  }</div><div class="line">  assert(coordinates.size() == weights.size());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"2D coordinates: "</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; coordinates.size(); i += polygon.size()) {</div><div class="line">    <span class="keywordflow">for</span> (std::size_t j = 0; j &lt; polygon.size(); ++j) {</div><div class="line">      std::cout &lt;&lt; coordinates[i + j] &lt;&lt; <span class="stringliteral">" "</span>;</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Weights_Examples_CustomTraits"></a>
Weights with Custom Traits</h2>
<p>As you could see from the reference manual, it is possible to provide your own traits class with basic geometric objects, constructions, and predicates to the weight functions. All weights in this CGAL component are models of the <code><a class="el" href="classAnalyticWeightTraits__2.html" title="A concept that describes the set of requirements of classes used in the computation of analytic weigh...">AnalyticWeightTraits_2</a></code> and <code><a class="el" href="classAnalyticWeightTraits__3.html" title="A concept that describes the set of requirements of classes used in the computation of analytic weigh...">AnalyticWeightTraits_3</a></code> concepts. However, many weights do not require all objects from these concepts. This example shows that the inverse distance weight, for instance, requires only the squared distance object which is specified in the custom traits class.</p>
<p><br />
<b>File</b> <a class="el" href="Weights_2custom_traits_8cpp-example.html">Weights/custom_traits.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Weights/inverse_distance_weights.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Typedefs.</span></div><div class="line"><span class="keyword">using</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>  = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> Point_2 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>;</div><div class="line"><span class="keyword">using</span> Point_3 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ae82b7f4be77dd5b8819ebe419e4ae753">Kernel::Point_3</a>;</div><div class="line"></div><div class="line"><span class="comment">// Custom traits class that has only two objects.</span></div><div class="line"><span class="keyword">struct </span>Custom_traits {</div><div class="line">  <span class="keyword">using</span> FT = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line">  <span class="keyword">using</span> Point_2 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>;</div><div class="line">  <span class="keyword">using</span> Point_3 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ae82b7f4be77dd5b8819ebe419e4ae753">Kernel::Point_3</a>;</div><div class="line"></div><div class="line">  decltype(<span class="keyword">auto</span>) compute_squared_distance_2_object()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ab0cf8fb8b03a457251af5cd558f8e9b3">Kernel::Compute_squared_distance_2</a>();</div><div class="line">  }</div><div class="line">  decltype(<span class="keyword">auto</span>) compute_squared_distance_3_object()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a0f2d1a3b455d293e04658d60ba4e9440">Kernel::Compute_squared_distance_3</a>();</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">  <span class="comment">// 2D configuration.</span></div><div class="line">  <span class="keyword">const</span> Point_2 p2(0, 0);</div><div class="line">  <span class="keyword">const</span> Point_2 q2(0, 1);</div><div class="line"></div><div class="line">  <span class="comment">// 3D configuration.</span></div><div class="line">  <span class="keyword">const</span> Point_3 p3(0, 0, 1);</div><div class="line">  <span class="keyword">const</span> Point_3 q3(0, 1, 1);</div><div class="line"></div><div class="line">  <span class="comment">// Create custom traits.</span></div><div class="line">  <span class="keyword">const</span> Custom_traits ctraits;</div><div class="line"></div><div class="line">  <span class="comment">// Compute weights.</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"2D/3D weight: "</span>;</div><div class="line">  std::cout &lt;&lt; <a class="code" href="group__PkgWeightsRefInverseDistanceWeights.html#ga93205330d2f2420e5ef57f5ccce4a084">CGAL::Weights::inverse_distance_weight</a>(p2, q2, ctraits) &lt;&lt; <span class="stringliteral">"/"</span>;</div><div class="line">  std::cout &lt;&lt; <a class="code" href="group__PkgWeightsRefInverseDistanceWeights.html#ga93205330d2f2420e5ef57f5ccce4a084">CGAL::Weights::inverse_distance_weight</a>(p3, q3, ctraits) &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Weights_Examples_WeightedLaplacian"></a>
Constructing Weighted Laplacian</h2>
<p>A typical example of using weights is discretizing <em>Poisson</em> and <em>Laplace equations</em> which play an important role in various geometry processing applications such as, for example, <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceMeshDeformation">Surface Mesh Deformation</a> and <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceMeshParameterization">Surface Mesh Parameterization</a> (see also <a class="el" href="index.html#Weights_Intro">Introduction</a> for more details). This example shows how to write the <em>discretized Laplacian</em> for all vertices of the given triangle mesh in matrix notation. We use the standard cotangent discretization weighted by the areas of the mixed Voronoi cells around each mesh vertex.</p>
<p><br />
<b>File</b> <a class="el" href="Weights_2weighted_laplacian_8cpp-example.html">Weights/weighted_laplacian.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Eigen_solver_traits.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Eigen_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Weights_8h.html">CGAL/Weights.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Typedefs.</span></div><div class="line"><span class="keyword">using</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>  = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> FT      = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"><span class="keyword">using</span> Point_3 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ae82b7f4be77dd5b8819ebe419e4ae753">Kernel::Point_3</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Solver_traits = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classCGAL_1_1Eigen__solver__traits.html">CGAL::Eigen_solver_traits</a>&lt;</div><div class="line">  Eigen::SparseLU&lt;CGAL::Eigen_sparse_matrix&lt;FT&gt;::EigenType&gt; &gt;;</div><div class="line"><span class="keyword">using</span> Matrix = Solver_traits::Matrix;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Mesh = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point_3&gt;</a>;</div><div class="line"><span class="keyword">using</span> VD   = boost::graph_traits&lt;Mesh&gt;::vertex_descriptor;</div><div class="line"><span class="keyword">using</span> HD   = boost::graph_traits&lt;Mesh&gt;::halfedge_descriptor;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Po<span class="keywordtype">int</span>Map&gt;</div><div class="line">FT get_w_ij(<span class="keyword">const</span> Mesh&amp; mesh, <span class="keyword">const</span> HD he, <span class="keyword">const</span> PointMap pmap) {</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> v0 = target(he, mesh);</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> v1 = source(he, mesh);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; q  = <span class="keyword">get</span>(pmap, v0); <span class="comment">// query</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; p1 = <span class="keyword">get</span>(pmap, v1); <span class="comment">// neighbor j</span></div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#ga63695419c5ce7f68949ff2fb4f42d733">is_border_edge</a>(he, mesh)) {</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> he_cw = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gad0a8110cb95f76bac65649bfe58c650b">opposite</a>(next(he, mesh), mesh);</div><div class="line">    <span class="keyword">auto</span> v2 = source(he_cw, mesh);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#ga63695419c5ce7f68949ff2fb4f42d733">is_border_edge</a>(he_cw, mesh)) {</div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> he_ccw = prev(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gad0a8110cb95f76bac65649bfe58c650b">opposite</a>(he, mesh), mesh);</div><div class="line">      v2 = source(he_ccw, mesh);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span>&amp; p2 = <span class="keyword">get</span>(pmap, v2); <span class="comment">// neighbor jp</span></div><div class="line">      <span class="keywordflow">return</span> CGAL::Weights::cotangent(p1, p2, q);</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span>&amp; p0 = <span class="keyword">get</span>(pmap, v2); <span class="comment">// neighbor jm</span></div><div class="line">      <span class="keywordflow">return</span> CGAL::Weights::cotangent(q, p0, p1);</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> he_cw = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gad0a8110cb95f76bac65649bfe58c650b">opposite</a>(next(he, mesh), mesh);</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> v2 = source(he_cw, mesh);</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> he_ccw = prev(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gad0a8110cb95f76bac65649bfe58c650b">opposite</a>(he, mesh), mesh);</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> v3 = source(he_ccw, mesh);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; p0 = <span class="keyword">get</span>(pmap, v2); <span class="comment">// neighbor jm</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; p2 = <span class="keyword">get</span>(pmap, v3); <span class="comment">// neighbor jp</span></div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="group__PkgWeightsRefCotangentWeights.html#ga3066242d371af7324f0288778bff54a9">CGAL::Weights::cotangent_weight</a>(p0, p1, p2, q) / 2.0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Po<span class="keywordtype">int</span>Map&gt;</div><div class="line">FT get_w_i(<span class="keyword">const</span> Mesh&amp; mesh, <span class="keyword">const</span> VD v_i, <span class="keyword">const</span> PointMap pmap) {</div><div class="line"></div><div class="line">  FT A_i = 0.0;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> v0 = v_i;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> init = halfedge(v_i, mesh);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; he : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLIterators.html#ga2be4fd4d24b1e48e00a92f90f0f2923c">halfedges_around_target</a>(init, mesh)) {</div><div class="line">    assert(v0 == target(he, mesh));</div><div class="line">    <span class="keywordflow">if</span> (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#gad93e429ad24efeaddeb836c437e719ab">is_border</a>(he, mesh)) { <span class="keywordflow">continue</span>; }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> v1 = source(he, mesh);</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> v2 = target(next(he, mesh), mesh);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; p = <span class="keyword">get</span>(pmap, v0);</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; q = <span class="keyword">get</span>(pmap, v1);</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; r = <span class="keyword">get</span>(pmap, v2);</div><div class="line">    A_i += <a class="code" href="group__PkgWeightsRefMixedVoronoiRegionWeights.html#ga2c72cfdf25b34a465f816e13ba6d879c">CGAL::Weights::mixed_voronoi_area</a>(p, q, r);</div><div class="line">  }</div><div class="line">  assert(A_i != 0.0);</div><div class="line">  <span class="keywordflow">return</span> 1.0 / (2.0 * A_i);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> set_laplacian_matrix(<span class="keyword">const</span> Mesh&amp; mesh, Matrix&amp; L) {</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> pmap = <span class="keyword">get</span>(CGAL::vertex_point, mesh); <span class="comment">// vertex to point map</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> imap = <span class="keyword">get</span>(CGAL::vertex_index, mesh); <span class="comment">// vertex to index map</span></div><div class="line"></div><div class="line">  <span class="comment">// Precompute Voronoi areas.</span></div><div class="line">  std::map&lt;std::size_t, FT&gt; w_i;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v_i : vertices(mesh)) {</div><div class="line">    w_i[<span class="keyword">get</span>(imap, v_i)] = get_w_i(mesh, v_i, pmap);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Fill the matrix.</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; he : halfedges(mesh)) {</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> vi = source(he, mesh);</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> vj = target(he, mesh);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::size_t i = <span class="keyword">get</span>(imap, vi);</div><div class="line">    <span class="keyword">const</span> std::size_t j = <span class="keyword">get</span>(imap, vj);</div><div class="line">    <span class="keywordflow">if</span> (i &gt; j) { <span class="keywordflow">continue</span>; }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> FT w_ij = w_i[j] * get_w_ij(mesh, he, pmap);</div><div class="line">    L.set_coef(i, j,  w_ij, <span class="keyword">true</span>);</div><div class="line">    L.set_coef(j, i,  w_ij, <span class="keyword">true</span>);</div><div class="line">    L.add_coef(i, i, -w_ij);</div><div class="line">    L.add_coef(j, j, -w_ij);</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">  <span class="comment">// Create mesh.</span></div><div class="line">  Mesh mesh;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> v0 = mesh.add_vertex(Point_3(0, 2, 0));</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> v1 = mesh.add_vertex(Point_3(2, 2, 0));</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> v2 = mesh.add_vertex(Point_3(0, 0, 0));</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> v3 = mesh.add_vertex(Point_3(2, 0, 0));</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> v4 = mesh.add_vertex(Point_3(1, 1, 1));</div><div class="line">  mesh.add_face(v0, v2, v4);</div><div class="line">  mesh.add_face(v2, v3, v4);</div><div class="line">  mesh.add_face(v3, v1, v4);</div><div class="line">  mesh.add_face(v1, v0, v4);</div><div class="line">  mesh.add_face(v2, v3, v1);</div><div class="line">  mesh.add_face(v1, v0, v2);</div><div class="line">  assert(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#ga11883d231eec1b58f37efe4acedd9588">CGAL::is_triangle_mesh</a>(mesh));</div><div class="line"></div><div class="line">  <span class="comment">// Set discretized Laplacian.</span></div><div class="line">  <span class="keyword">const</span> std::size_t n = 5; <span class="comment">// we have 5 vertices</span></div><div class="line">  Matrix L(n, n);</div><div class="line">  set_laplacian_matrix(mesh, L);</div><div class="line">  std::cout &lt;&lt; std::fixed; std::cout &lt;&lt; std::showpos;</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; n; ++i) {</div><div class="line">    <span class="keywordflow">for</span> (std::size_t j = 0; j &lt; n; ++j) {</div><div class="line">      std::cout &lt;&lt; L.get_coef(i, j) &lt;&lt; <span class="stringliteral">" "</span>;</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Weights_Examples_Convergence"></a>
Convergence</h2>
<p>This little example shows how to use the family of weights which includes multiple types of weights in one function. In particular, we show how, by changing an input parameter, we converge from the <code><a class="el" href="classCGAL_1_1Weights_1_1Wachspress__weights__2.html" title="2D Wachspress weights for polygons. ">Wachspress_weights_2</a></code> to the <code><a class="el" href="classCGAL_1_1Weights_1_1Mean__value__weights__2.html" title="2D mean value weights for polygons. ">Mean_value_weights_2</a></code>.</p>
<p><br />
<b>File</b> <a class="el" href="Weights_2convergence_8cpp-example.html">Weights/convergence.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Weights/authalic_weights.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Weights/three_point_family_weights.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Typedefs.</span></div><div class="line"><span class="keyword">using</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>  = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> FT      = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"><span class="keyword">using</span> Point_2 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  std::cout &lt;&lt; std::fixed;</div><div class="line"></div><div class="line">  <span class="comment">// 3D configuration.</span></div><div class="line">  <span class="keyword">const</span> Point_2 p0(0, 1);</div><div class="line">  <span class="keyword">const</span> Point_2 p1(2, 0);</div><div class="line">  <span class="keyword">const</span> Point_2 p2(7, 1);</div><div class="line">  <span class="keyword">const</span> Point_2 q0(3, 1);</div><div class="line"></div><div class="line">  <span class="comment">// Choose a type of the weight:</span></div><div class="line">  <span class="comment">// e.g. 0 - Wachspress (WP) weight; 1 - mean value (MV);</span></div><div class="line">  <span class="keyword">const</span> FT wp = 0.0;</div><div class="line">  <span class="keyword">const</span> FT mv = 1.0;</div><div class="line"></div><div class="line">  <span class="comment">// Compute WP and MV weights.</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"3D Wachspress (WP, q0): "</span>;</div><div class="line">  std::cout &lt;&lt; <a class="code" href="group__PkgWeightsRefThreePointFamilyWeights.html#ga92a8e30bdece87c1f9b615e01250ee57">CGAL::Weights::three_point_family_weight</a>(p0, p1, p2, q0, wp) &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"3D mean value (MV, q0): "</span>;</div><div class="line">  std::cout &lt;&lt; <a class="code" href="group__PkgWeightsRefThreePointFamilyWeights.html#ga92a8e30bdece87c1f9b615e01250ee57">CGAL::Weights::three_point_family_weight</a>(p0, p1, p2, q0, mv) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Converge WP towards MV.</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Converge WP to MV on q0: "</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keyword">const</span> FT step = 0.1;</div><div class="line">  <span class="keywordflow">for</span> (FT x = 0.0; x &lt;= 1.0; x += step) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"3D x: "</span>;</div><div class="line">    std::cout &lt;&lt; <a class="code" href="group__PkgWeightsRefThreePointFamilyWeights.html#ga92a8e30bdece87c1f9b615e01250ee57">CGAL::Weights::three_point_family_weight</a>(p0, p1, p2, q0, x) &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Weights_History"></a>
History</h1>
<p>This package is a part of the weights unification effort inside CGAL that has been carried out by Dmitry Anisimov in 2020.</p>
<h1><a class="anchor" id="Weights_Acknowledgements"></a>
Acknowledgments</h1>
<p>We wish to thank Guillaume Damiand, Andreas Fabri, and Mael Rouxel-Labbé for useful discussions and reviews. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jun 27 2022 09:17:13 for CGAL 5.6 - Weights by
    <a href="https://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>
</html>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.6 - Weights
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Weights"></a>  </p><div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Author</dt><dd>Dmitry Anisimov</dd></dl>
<h1><a class="anchor" id="Weights_Intro"></a>
Introduction</h1>
<p>Many geometric algorithms rely on the intermediate computation of scalars, so-called <em>weights</em>, which are then used for solving different linear systems or to favor one result over another, also known as <em>weighting</em>. This package provides a simple and unified interface to different types of weights.</p>
<p>A typical example of a geometric algorithm that requires weights is the <em>Laplace smoothing</em> of a triangle mesh:</p>
<p>\(v_i \leftarrow v_i + h \lambda\Delta v_i\),</p>
<p>where \(v_i\) is the position of the mesh vertex \(i\), \(h\) is a sufficiently small time step, \(\lambda\) is the scalar diffusion coefficient, and \(\Delta v_i\) is the discrete average of the <em>Laplace-Beltrami operator</em> at vertex \(v_i\) computed using the <em>cotangent weights</em>:</p>
<p>\(\Delta v_i = w_i\sum_{v_j \in N_1(v_i)} w_{ij} (v_j - v_i)\),</p>
<p>where \(w_i = \frac{1}{2A_i}\) and \(w_{ij} = \cot\beta_{ij} + \cot\gamma_{ij}\) and \(A_i\) is a <em>local averaging domain</em>.</p>
<p>Here, the weights \(w_{ij}\) can be computed using the <a class="el" href="group__PkgWeightsRefCotangentWeights.html">cotangent weight</a> and the local averaging domain can be computed using the <a class="el" href="group__PkgWeightsRefMixedVoronoiRegionWeights.html">mixed Voronoi region weight</a>. The algorithm above smooths the mesh geometry, resulting in a higher quality version of the original mesh. The full example of the discretized <em>Laplacian</em> for all vertices of a triangle mesh can be found <a class="el" href="index.html#Weights_Examples_WeightedLaplacian">here</a>.</p>
<p>There are many other scenarios where the weights from this package are used. In particular, the following CGAL packages make use of weights described in this package: <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgBarycentricCoordinates2">2D Generalized Barycentric Coordinates</a>, <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgPolygonMeshProcessing">Polygon Mesh Processing</a>, <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceMeshDeformation">Triangulated Surface Mesh Deformation</a>, <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceMeshParameterization">Triangulated Surface Mesh Parameterization</a>, <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceMeshSkeletonization">Triangulated Surface Mesh Skeletonization</a>, and <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgHeatMethod">The Heat Method</a>.</p>
<h1><a class="anchor" id="Weights_Groups"></a>
Weights</h1>
<p>We call <em>analytic weights</em> all weights which can be computed with a simple analytic expression. All weights from this package can be computed analytically. However, for better navigation through all available weights and their applications, we distinguish three typical groups of weights:</p>
<ul>
<li><a class="el" href="group__PkgWeightsRefAnalytic.html">Analytic Weights</a> include all basic weights which can be computed for a query point with respect to its local neighbors in 2D or 3D, however these neighbors are defined. Usually, the configuration is a query point and three other points. These weights return one unique value per query point.</li>
<li><a class="el" href="group__PkgWeightsRefBarycentric.html">Barycentric Weights</a> include all weights which can be computed for a query point with respect to the vertices of a planar polygon. These weights return \(n\) values per query point, where \(n\) is the number of polygon vertices. Barycentric weights are also used for computing <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgBarycentricCoordinates2">2D barycentric coordinates</a>.</li>
<li><a class="el" href="group__PkgWeightsRefRegions.html">Weighting Regions</a> include all weights which are used to balance other weights but are rarely used on their own. Sometimes, such weights are also referred to as <em>local averaging regions</em>. These weights are usually lengths, areas, and volumes of 2D and 3D objects.</li>
</ul>
<h1><a class="anchor" id="Weights_Implementation"></a>
Implementation</h1>
<p>All weight functions have a simple and unified interface. In particular, all analytic weight functions usually take a query point and three other points in 2D or 3D and return a unique scalar. They all have the same signature and are parameterized by a traits class that must be a model of <code><a class="el" href="classAnalyticWeightTraits__2.html" title="A concept that describes the set of requirements of classes used in the computation of analytic weigh...">AnalyticWeightTraits_2</a></code> for 2D computations or <code><a class="el" href="classAnalyticWeightTraits__3.html" title="A concept that describes the set of requirements of classes used in the computation of analytic weigh...">AnalyticWeightTraits_3</a></code> for 3D computations.</p>
<p>The barycentric weight functions are parameterized by a traits class of the concept <code><a class="el" href="classAnalyticWeightTraits__2.html" title="A concept that describes the set of requirements of classes used in the computation of analytic weigh...">AnalyticWeightTraits_2</a></code> and they are all models of the concept <code><a class="el" href="classBarycentricWeights__2.html" title="A concept that describes the set of methods required in all classes used in the computation of 2D gen...">BarycentricWeights_2</a></code>. They take an input polygon and a query point and compute the weights at this point with respect to all vertices of the polygon. The computed weights are then returned in a container providing the corresponding output iterator. These weight functions also provide a <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgPropertyMap">property map</a> mechanism for mapping a user type of the polygon vertex to <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__2.html">CGAL::Point_2</a></code>.</p>
<p>All weighting regions have the same signature and are parameterized by a traits class of the concept <code><a class="el" href="classAnalyticWeightTraits__2.html" title="A concept that describes the set of requirements of classes used in the computation of analytic weigh...">AnalyticWeightTraits_2</a></code> or <code><a class="el" href="classAnalyticWeightTraits__3.html" title="A concept that describes the set of requirements of classes used in the computation of analytic weigh...">AnalyticWeightTraits_3</a></code>. The returned weight is a unique scalar.</p>
<p>The <code>traits</code> parameter can be omitted for all functions and classes if it can be deduced from the input point type using <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Kernel__traits.html">CGAL::Kernel_traits</a></code>.</p>
<p>Several weights in this package have different implementations. One reason to have it is explained in section about <a class="el" href="index.html#Weights_Implementation_Coplanarity">Coplanarity</a>. Another reason is that the same weights are named and computed differently in different communities. If one searches for these weights, one needs to know all their alternative names which is problematic. We provide the most common names and implementations of these weights.</p>
<h2><a class="anchor" id="Weights_Implementation_Coplanarity"></a>
Coplanarity</h2>
<p>When computing weights for a query point \(q\) with respect to its neighbors \(p_0\), \(p_1\), and \(p_2\), the local configuration is a quadrilateral [ \(p_0\), \(p_1\), \(p_2\), \(q\)] or two connected triangles [ \(q\), \(p_0\), \(p_1\)] and [ \(q\), \(p_1\), \(p_2\)]. When working in 3D, these triangles are not necessarily coplanar, in other words, they do not belong to the same common plane.</p>
<p>Certain weights in this package support only coplanar configurations, while other weights support both. The weights which support non-coplanar configurations, provide the corresponding overloads with 3D points, while other weights accept only 2D point types. For example, <a class="el" href="group__PkgWeightsRefCotangentWeights.html">cotangent weights</a> support both coplanar and non-coplanar configurations, while <a class="el" href="group__PkgWeightsRefDiscreteHarmonicWeights.html">discrete harmonic weights</a> support only coplanar configurations.</p>
<h2><a class="anchor" id="Weights_Implementation_Edge_Cases"></a>
Edge Cases</h2>
<p>None of the weights in this package are defined for query points which belong to</p>
<ul>
<li><em>end segments</em> so-called <em>edges</em>, for example [ \(p_0\), \(p_1\)] or [ \(p_1\), \(p_2\)] or any polygon edge and to</li>
<li><em>end points</em> so-called <em>corners</em>, for example \(p_0\), \(p_1\), or \(p_2\) or any polygon corner.</li>
</ul>
<p>For example, if \(q\) = \(p_0\) or \(q \in [p_0, p_1]\), a weight may be undefined due to invalid operations such as division by zero.</p>
<p>Several weights also require additional conditions to be satisfied. Consult the reference manual for more details.</p>
<h1><a class="anchor" id="Weights_Examples"></a>
Examples</h1>
<p>In this section, you can find a few examples of how and when the provided weights can be used.</p>
<h2><a class="anchor" id="Weights_Examples_First"></a>
The First Example</h2>
<p>This trivial example shows how to compute several analytic weights and weighting regions. Other weights have the same interface so they can be computed analogously.</p>
<p><br />
<b>File</b> <a class="el" href="Weights_2weights_8cpp-example.html">Weights/weights.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Weights_8h.html">CGAL/Weights.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Typedefs.</span></div><div class="line"><span class="keyword">using</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>  = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> FT      = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"><span class="keyword">using</span> Point_2 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>;</div><div class="line"><span class="keyword">using</span> Point_3 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ae82b7f4be77dd5b8819ebe419e4ae753">Kernel::Point_3</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">  <span class="comment">// 2D configuration.</span></div><div class="line">  <span class="keyword">const</span> Point_2 t2(-1,  0); <span class="comment">// p0</span></div><div class="line">  <span class="keyword">const</span> Point_2 r2( 0, -1); <span class="comment">// p1</span></div><div class="line">  <span class="keyword">const</span> Point_2 p2( 1,  0); <span class="comment">// p2</span></div><div class="line">  <span class="keyword">const</span> Point_2 q2( 0,  0); <span class="comment">// query</span></div><div class="line"></div><div class="line">  <span class="comment">// 3D configuration.</span></div><div class="line">  <span class="keyword">const</span> Point_3 t3(-1,  0, 1); <span class="comment">// p0</span></div><div class="line">  <span class="keyword">const</span> Point_3 r3( 0, -1, 1); <span class="comment">// p1</span></div><div class="line">  <span class="keyword">const</span> Point_3 p3( 1,  0, 1); <span class="comment">// p2</span></div><div class="line">  <span class="keyword">const</span> Point_3 q3( 0,  0, 1); <span class="comment">// query</span></div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"2D/3D tangent weight: "</span>;</div><div class="line">  std::cout &lt;&lt; <a class="code" href="group__PkgWeightsRefTangentWeights.html#ga993a91b3c985aa7679263cf75ddfc6df">CGAL::Weights::tangent_weight</a>(t2, r2, p2, q2) &lt;&lt; <span class="stringliteral">"/"</span>;</div><div class="line">  std::cout &lt;&lt; <a class="code" href="group__PkgWeightsRefTangentWeights.html#ga993a91b3c985aa7679263cf75ddfc6df">CGAL::Weights::tangent_weight</a>(t3, r3, p3, q3) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"2D/3D Shepard weight: "</span>;</div><div class="line">  std::cout &lt;&lt; <a class="code" href="group__PkgWeightsRefShepardWeights.html#ga26ba6ba90c57ff35e393d4689a1945cb">CGAL::Weights::shepard_weight</a>(r2, q2, 2.0) &lt;&lt; <span class="stringliteral">"/"</span>;</div><div class="line">  std::cout &lt;&lt; <a class="code" href="group__PkgWeightsRefShepardWeights.html#ga26ba6ba90c57ff35e393d4689a1945cb">CGAL::Weights::shepard_weight</a>(r3, q3, 2.0) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"2D/3D barycentric area: "</span>;</div><div class="line">  std::cout &lt;&lt; <a class="code" href="group__PkgWeightsRefBarycentricRegionWeights.html#ga7f06738d912a04f46a201d4f4c7057f4">CGAL::Weights::barycentric_area</a>(p2, q2, r2) &lt;&lt; <span class="stringliteral">"/"</span>;</div><div class="line">  std::cout &lt;&lt; <a class="code" href="group__PkgWeightsRefBarycentricRegionWeights.html#ga7f06738d912a04f46a201d4f4c7057f4">CGAL::Weights::barycentric_area</a>(p3, q3, r3) &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Weights_Examples_CoordinatesOneQuery"></a>
Computing 2D Coordinates for One Query Point</h2>
<p>This example shows how to compute barycentric weights and barycentric coordinates, which are normalized barycentric weights, for a query point with respect to a polygon in 2D. Since we have only one query point, we use a free function to show the simplified interface. For multiple query points though, calling a free function is not efficient (see the following example for more details). The used type of barycentric weights is <code><a class="el" href="classCGAL_1_1Weights_1_1Discrete__harmonic__weights__2.html" title="2D discrete harmonic weights for polygons. ">Discrete_harmonic_weights_2</a></code>.</p>
<p><br />
<b>File</b> <a class="el" href="Weights_2coordinates_one_query_8cpp-example.html">Weights/coordinates_one_query.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Weights/discrete_harmonic_weights.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Typedefs.</span></div><div class="line"><span class="keyword">using</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>  = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> FT      = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"><span class="keyword">using</span> Point_2 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">  <span class="comment">// Create a polygon and a query point.</span></div><div class="line">  <span class="keyword">const</span> std::vector&lt;Point_2&gt; polygon =</div><div class="line">    { Point_2(0, 0), Point_2(1, 0), Point_2(1, 1), Point_2(0, 1) };</div><div class="line">  <span class="keyword">const</span> Point_2 query(0.5, 0.5);</div><div class="line"></div><div class="line">  <span class="comment">// Allocate memory for weights and coordinates.</span></div><div class="line">  std::vector&lt;FT&gt; weights;</div><div class="line">  weights.reserve(polygon.size());</div><div class="line">  std::vector&lt;FT&gt; coordinates;</div><div class="line">  coordinates.reserve(polygon.size());</div><div class="line"></div><div class="line">  <span class="comment">// Compute barycentric weights.</span></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Barycentric_coordinates_2.tag:../Barycentric_coordinates_2/" href="../Barycentric_coordinates_2/group__PkgBarycentricCoordinates2RefFunctions.html#gafa8833d919e532373b01c9ca09d9a0d8">CGAL::Weights::discrete_harmonic_weights_2</a>(polygon, query, std::back_inserter(weights));</div><div class="line">  assert(weights.size() == polygon.size());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"2D weights: "</span>;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> FT weight : weights) {</div><div class="line">    std::cout &lt;&lt; weight &lt;&lt; <span class="stringliteral">" "</span>;</div><div class="line">  }</div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Normalize weights in order to get barycentric coordinates.</span></div><div class="line">  FT sum = 0.0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> FT weight : weights) {</div><div class="line">    sum += weight;</div><div class="line">  }</div><div class="line">  assert(sum != 0.0);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> FT weight : weights) {</div><div class="line">    coordinates.push_back(weight / sum);</div><div class="line">  }</div><div class="line">  assert(coordinates.size() == weights.size());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"2D coordinates: "</span>;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> FT coordinate : coordinates) {</div><div class="line">    std::cout &lt;&lt; coordinate &lt;&lt; <span class="stringliteral">" "</span>;</div><div class="line">  }</div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Weights_Examples_CoordinatesMultipleQueries"></a>
Computing 2D Coordinates for Multiple Query Points</h2>
<p>This example shows how to compute barycentric weights and barycentric coordinates, which are normalized barycentric weights, for a set of query points with respect to a polygon in 2D. Since we have multiple query points, we first create a class and then use it to compute the weights. Using a class for multiple query points is preferred, because in that case, the memory required for computing weights is allocated only once, while when using a free function as in the previous example, it is allocated for each query point. The used type of barycentric weights is <code><a class="el" href="classCGAL_1_1Weights_1_1Wachspress__weights__2.html" title="2D Wachspress weights for polygons. ">Wachspress_weights_2</a></code>.</p>
<p><br />
<b>File</b> <a class="el" href="Weights_2coordinates_multiple_queries_8cpp-example.html">Weights/coordinates_multiple_queries.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/point_generators_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Weights/wachspress_weights.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Typedefs.</span></div><div class="line"><span class="keyword">using</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>  = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> FT      = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"><span class="keyword">using</span> Point_2 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> PointRange = std::vector&lt;Point_2&gt;;</div><div class="line"><span class="keyword">using</span> Creator    = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Creator__uniform__2.html">CGAL::Creator_uniform_2&lt;FT, Point_2&gt;</a>;</div><div class="line"><span class="keyword">using</span> Generator  = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Generator.tag:../Generator/" href="../Generator/classCGAL_1_1Random__points__in__square__2.html">CGAL::Random_points_in_square_2&lt;Point_2, Creator&gt;</a>;</div><div class="line"><span class="keyword">using</span> Wachspress = <a class="code" href="classCGAL_1_1Weights_1_1Wachspress__weights__2.html">CGAL::Weights::Wachspress_weights_2&lt;PointRange, Kernel&gt;</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">  <span class="comment">// Choose how many query points we want to generate.</span></div><div class="line">  <span class="keyword">const</span> std::size_t num_queries = 10;</div><div class="line"></div><div class="line">  <span class="comment">// Create a polygon.</span></div><div class="line">  <span class="keyword">const</span> std::vector&lt;Point_2&gt; polygon =</div><div class="line">    { Point_2(0, 0), Point_2(1, 0), Point_2(1, 1), Point_2(0, 1) };</div><div class="line"></div><div class="line">  <span class="comment">// Generate a set of query points.</span></div><div class="line">  std::vector&lt;Point_2&gt; queries;</div><div class="line">  queries.reserve(num_queries);</div><div class="line">  Generator generator(1.0);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__STLAlgos.html#gacb8df77d1d07b9cfff3fdd2f5d9c4fda">std::copy_n</a>(generator, num_queries, std::back_inserter(queries));</div><div class="line">  assert(queries.size() == num_queries);</div><div class="line"></div><div class="line">  <span class="comment">// Allocate memory for weights and coordinates.</span></div><div class="line">  std::vector&lt;FT&gt; weights;</div><div class="line">  weights.reserve(num_queries * polygon.size());</div><div class="line">  std::vector&lt;FT&gt; coordinates;</div><div class="line">  coordinates.reserve(num_queries * polygon.size());</div><div class="line"></div><div class="line">  <span class="comment">// Compute barycentric weights.</span></div><div class="line">  Wachspress wachspress(polygon);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> Point_2&amp; query : queries) {</div><div class="line">    wachspress(query, std::back_inserter(weights));</div><div class="line">  }</div><div class="line">  assert(weights.size() == num_queries * polygon.size());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"2D weights: "</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; weights.size(); i += polygon.size()) {</div><div class="line">    <span class="keywordflow">for</span> (std::size_t j = 0; j &lt; polygon.size(); ++j) {</div><div class="line">      std::cout &lt;&lt; weights[i + j] &lt;&lt; <span class="stringliteral">" "</span>;</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Normalize weights in order to get barycentric coordinates.</span></div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; weights.size(); i += polygon.size()) {</div><div class="line">    FT sum = 0.0;</div><div class="line">    <span class="keywordflow">for</span> (std::size_t j = 0; j &lt; polygon.size(); ++j) {</div><div class="line">      sum += weights[i + j];</div><div class="line">    }</div><div class="line">    assert(sum != 0.0);</div><div class="line">    <span class="keywordflow">for</span> (std::size_t j = 0; j &lt; polygon.size(); ++j) {</div><div class="line">      coordinates.push_back(weights[i + j] / sum);</div><div class="line">    }</div><div class="line">  }</div><div class="line">  assert(coordinates.size() == weights.size());</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"2D coordinates: "</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; coordinates.size(); i += polygon.size()) {</div><div class="line">    <span class="keywordflow">for</span> (std::size_t j = 0; j &lt; polygon.size(); ++j) {</div><div class="line">      std::cout &lt;&lt; coordinates[i + j] &lt;&lt; <span class="stringliteral">" "</span>;</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Weights_Examples_CustomTraits"></a>
Weights with Custom Traits</h2>
<p>As you could see from the reference manual, it is possible to provide your own traits class with basic geometric objects, constructions, and predicates to the weight functions. All weights in this CGAL component are models of the <code><a class="el" href="classAnalyticWeightTraits__2.html" title="A concept that describes the set of requirements of classes used in the computation of analytic weigh...">AnalyticWeightTraits_2</a></code> and <code><a class="el" href="classAnalyticWeightTraits__3.html" title="A concept that describes the set of requirements of classes used in the computation of analytic weigh...">AnalyticWeightTraits_3</a></code> concepts. However, many weights do not require all objects from these concepts. This example shows that the inverse distance weight, for instance, requires only the squared distance object which is specified in the custom traits class.</p>
<p><br />
<b>File</b> <a class="el" href="Weights_2custom_traits_8cpp-example.html">Weights/custom_traits.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Weights/inverse_distance_weights.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Typedefs.</span></div><div class="line"><span class="keyword">using</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>  = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> Point_2 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>;</div><div class="line"><span class="keyword">using</span> Point_3 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ae82b7f4be77dd5b8819ebe419e4ae753">Kernel::Point_3</a>;</div><div class="line"></div><div class="line"><span class="comment">// Custom traits class that has only two objects.</span></div><div class="line"><span class="keyword">struct </span>Custom_traits {</div><div class="line">  <span class="keyword">using</span> FT = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line">  <span class="keyword">using</span> Point_2 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>;</div><div class="line">  <span class="keyword">using</span> Point_3 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ae82b7f4be77dd5b8819ebe419e4ae753">Kernel::Point_3</a>;</div><div class="line"></div><div class="line">  decltype(<span class="keyword">auto</span>) compute_squared_distance_2_object()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ab0cf8fb8b03a457251af5cd558f8e9b3">Kernel::Compute_squared_distance_2</a>();</div><div class="line">  }</div><div class="line">  decltype(<span class="keyword">auto</span>) compute_squared_distance_3_object()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a0f2d1a3b455d293e04658d60ba4e9440">Kernel::Compute_squared_distance_3</a>();</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">  <span class="comment">// 2D configuration.</span></div><div class="line">  <span class="keyword">const</span> Point_2 p2(0, 0);</div><div class="line">  <span class="keyword">const</span> Point_2 q2(0, 1);</div><div class="line"></div><div class="line">  <span class="comment">// 3D configuration.</span></div><div class="line">  <span class="keyword">const</span> Point_3 p3(0, 0, 1);</div><div class="line">  <span class="keyword">const</span> Point_3 q3(0, 1, 1);</div><div class="line"></div><div class="line">  <span class="comment">// Create custom traits.</span></div><div class="line">  <span class="keyword">const</span> Custom_traits ctraits;</div><div class="line"></div><div class="line">  <span class="comment">// Compute weights.</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"2D/3D weight: "</span>;</div><div class="line">  std::cout &lt;&lt; <a class="code" href="group__PkgWeightsRefInverseDistanceWeights.html#ga93205330d2f2420e5ef57f5ccce4a084">CGAL::Weights::inverse_distance_weight</a>(p2, q2, ctraits) &lt;&lt; <span class="stringliteral">"/"</span>;</div><div class="line">  std::cout &lt;&lt; <a class="code" href="group__PkgWeightsRefInverseDistanceWeights.html#ga93205330d2f2420e5ef57f5ccce4a084">CGAL::Weights::inverse_distance_weight</a>(p3, q3, ctraits) &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Weights_Examples_WeightedLaplacian"></a>
Constructing Weighted Laplacian</h2>
<p>A typical example of using weights is discretizing <em>Poisson</em> and <em>Laplace equations</em> which play an important role in various geometry processing applications such as, for example, <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceMeshDeformation">Surface Mesh Deformation</a> and <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceMeshParameterization">Surface Mesh Parameterization</a> (see also <a class="el" href="index.html#Weights_Intro">Introduction</a> for more details). This example shows how to write the <em>discretized Laplacian</em> for all vertices of the given triangle mesh in matrix notation. We use the standard cotangent discretization weighted by the areas of the mixed Voronoi cells around each mesh vertex.</p>
<p><br />
<b>File</b> <a class="el" href="Weights_2weighted_laplacian_8cpp-example.html">Weights/weighted_laplacian.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Eigen_solver_traits.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Eigen_matrix.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Weights_8h.html">CGAL/Weights.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Typedefs.</span></div><div class="line"><span class="keyword">using</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>  = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> FT      = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"><span class="keyword">using</span> Point_3 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ae82b7f4be77dd5b8819ebe419e4ae753">Kernel::Point_3</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Solver_traits = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Solver_interface.tag:../Solver_interface/" href="../Solver_interface/classCGAL_1_1Eigen__solver__traits.html">CGAL::Eigen_solver_traits</a>&lt;</div><div class="line">  Eigen::SparseLU&lt;CGAL::Eigen_sparse_matrix&lt;FT&gt;::EigenType&gt; &gt;;</div><div class="line"><span class="keyword">using</span> Matrix = Solver_traits::Matrix;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Mesh = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point_3&gt;</a>;</div><div class="line"><span class="keyword">using</span> VD   = boost::graph_traits&lt;Mesh&gt;::vertex_descriptor;</div><div class="line"><span class="keyword">using</span> HD   = boost::graph_traits&lt;Mesh&gt;::halfedge_descriptor;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Po<span class="keywordtype">int</span>Map&gt;</div><div class="line">FT get_w_ij(<span class="keyword">const</span> Mesh&amp; mesh, <span class="keyword">const</span> HD he, <span class="keyword">const</span> PointMap pmap) {</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> v0 = target(he, mesh);</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> v1 = source(he, mesh);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; q  = <span class="keyword">get</span>(pmap, v0); <span class="comment">// query</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; p1 = <span class="keyword">get</span>(pmap, v1); <span class="comment">// neighbor j</span></div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#ga63695419c5ce7f68949ff2fb4f42d733">is_border_edge</a>(he, mesh)) {</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> he_cw = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gad0a8110cb95f76bac65649bfe58c650b">opposite</a>(next(he, mesh), mesh);</div><div class="line">    <span class="keyword">auto</span> v2 = source(he_cw, mesh);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#ga63695419c5ce7f68949ff2fb4f42d733">is_border_edge</a>(he_cw, mesh)) {</div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> he_ccw = prev(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gad0a8110cb95f76bac65649bfe58c650b">opposite</a>(he, mesh), mesh);</div><div class="line">      v2 = source(he_ccw, mesh);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span>&amp; p2 = <span class="keyword">get</span>(pmap, v2); <span class="comment">// neighbor jp</span></div><div class="line">      <span class="keywordflow">return</span> CGAL::Weights::cotangent(p1, p2, q);</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span>&amp; p0 = <span class="keyword">get</span>(pmap, v2); <span class="comment">// neighbor jm</span></div><div class="line">      <span class="keywordflow">return</span> CGAL::Weights::cotangent(q, p0, p1);</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> he_cw = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gad0a8110cb95f76bac65649bfe58c650b">opposite</a>(next(he, mesh), mesh);</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> v2 = source(he_cw, mesh);</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> he_ccw = prev(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gad0a8110cb95f76bac65649bfe58c650b">opposite</a>(he, mesh), mesh);</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> v3 = source(he_ccw, mesh);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; p0 = <span class="keyword">get</span>(pmap, v2); <span class="comment">// neighbor jm</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; p2 = <span class="keyword">get</span>(pmap, v3); <span class="comment">// neighbor jp</span></div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="group__PkgWeightsRefCotangentWeights.html#ga3066242d371af7324f0288778bff54a9">CGAL::Weights::cotangent_weight</a>(p0, p1, p2, q) / 2.0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Po<span class="keywordtype">int</span>Map&gt;</div><div class="line">FT get_w_i(<span class="keyword">const</span> Mesh&amp; mesh, <span class="keyword">const</span> VD v_i, <span class="keyword">const</span> PointMap pmap) {</div><div class="line"></div><div class="line">  FT A_i = 0.0;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> v0 = v_i;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> init = halfedge(v_i, mesh);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; he : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLIterators.html#ga2be4fd4d24b1e48e00a92f90f0f2923c">halfedges_around_target</a>(init, mesh)) {</div><div class="line">    assert(v0 == target(he, mesh));</div><div class="line">    <span class="keywordflow">if</span> (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#gad93e429ad24efeaddeb836c437e719ab">is_border</a>(he, mesh)) { <span class="keywordflow">continue</span>; }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> v1 = source(he, mesh);</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> v2 = target(next(he, mesh), mesh);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; p = <span class="keyword">get</span>(pmap, v0);</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; q = <span class="keyword">get</span>(pmap, v1);</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; r = <span class="keyword">get</span>(pmap, v2);</div><div class="line">    A_i += <a class="code" href="group__PkgWeightsRefMixedVoronoiRegionWeights.html#ga2c72cfdf25b34a465f816e13ba6d879c">CGAL::Weights::mixed_voronoi_area</a>(p, q, r);</div><div class="line">  }</div><div class="line">  assert(A_i != 0.0);</div><div class="line">  <span class="keywordflow">return</span> 1.0 / (2.0 * A_i);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> set_laplacian_matrix(<span class="keyword">const</span> Mesh&amp; mesh, Matrix&amp; L) {</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> pmap = <span class="keyword">get</span>(CGAL::vertex_point, mesh); <span class="comment">// vertex to point map</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> imap = <span class="keyword">get</span>(CGAL::vertex_index, mesh); <span class="comment">// vertex to index map</span></div><div class="line"></div><div class="line">  <span class="comment">// Precompute Voronoi areas.</span></div><div class="line">  std::map&lt;std::size_t, FT&gt; w_i;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v_i : vertices(mesh)) {</div><div class="line">    w_i[<span class="keyword">get</span>(imap, v_i)] = get_w_i(mesh, v_i, pmap);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Fill the matrix.</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; he : halfedges(mesh)) {</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> vi = source(he, mesh);</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> vj = target(he, mesh);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::size_t i = <span class="keyword">get</span>(imap, vi);</div><div class="line">    <span class="keyword">const</span> std::size_t j = <span class="keyword">get</span>(imap, vj);</div><div class="line">    <span class="keywordflow">if</span> (i &gt; j) { <span class="keywordflow">continue</span>; }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> FT w_ij = w_i[j] * get_w_ij(mesh, he, pmap);</div><div class="line">    L.set_coef(i, j,  w_ij, <span class="keyword">true</span>);</div><div class="line">    L.set_coef(j, i,  w_ij, <span class="keyword">true</span>);</div><div class="line">    L.add_coef(i, i, -w_ij);</div><div class="line">    L.add_coef(j, j, -w_ij);</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">  <span class="comment">// Create mesh.</span></div><div class="line">  Mesh mesh;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> v0 = mesh.add_vertex(Point_3(0, 2, 0));</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> v1 = mesh.add_vertex(Point_3(2, 2, 0));</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> v2 = mesh.add_vertex(Point_3(0, 0, 0));</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> v3 = mesh.add_vertex(Point_3(2, 0, 0));</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> v4 = mesh.add_vertex(Point_3(1, 1, 1));</div><div class="line">  mesh.add_face(v0, v2, v4);</div><div class="line">  mesh.add_face(v2, v3, v4);</div><div class="line">  mesh.add_face(v3, v1, v4);</div><div class="line">  mesh.add_face(v1, v0, v4);</div><div class="line">  mesh.add_face(v2, v3, v1);</div><div class="line">  mesh.add_face(v1, v0, v2);</div><div class="line">  assert(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#ga11883d231eec1b58f37efe4acedd9588">CGAL::is_triangle_mesh</a>(mesh));</div><div class="line"></div><div class="line">  <span class="comment">// Set discretized Laplacian.</span></div><div class="line">  <span class="keyword">const</span> std::size_t n = 5; <span class="comment">// we have 5 vertices</span></div><div class="line">  Matrix L(n, n);</div><div class="line">  set_laplacian_matrix(mesh, L);</div><div class="line">  std::cout &lt;&lt; std::fixed; std::cout &lt;&lt; std::showpos;</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; n; ++i) {</div><div class="line">    <span class="keywordflow">for</span> (std::size_t j = 0; j &lt; n; ++j) {</div><div class="line">      std::cout &lt;&lt; L.get_coef(i, j) &lt;&lt; <span class="stringliteral">" "</span>;</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Weights_Examples_Convergence"></a>
Convergence</h2>
<p>This little example shows how to use the family of weights which includes multiple types of weights in one function. In particular, we show how, by changing an input parameter, we converge from the <code><a class="el" href="classCGAL_1_1Weights_1_1Wachspress__weights__2.html" title="2D Wachspress weights for polygons. ">Wachspress_weights_2</a></code> to the <code><a class="el" href="classCGAL_1_1Weights_1_1Mean__value__weights__2.html" title="2D mean value weights for polygons. ">Mean_value_weights_2</a></code>.</p>
<p><br />
<b>File</b> <a class="el" href="Weights_2convergence_8cpp-example.html">Weights/convergence.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Weights/authalic_weights.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Weights/three_point_family_weights.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Typedefs.</span></div><div class="line"><span class="keyword">using</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>  = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> FT      = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"><span class="keyword">using</span> Point_2 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  std::cout &lt;&lt; std::fixed;</div><div class="line"></div><div class="line">  <span class="comment">// 3D configuration.</span></div><div class="line">  <span class="keyword">const</span> Point_2 p0(0, 1);</div><div class="line">  <span class="keyword">const</span> Point_2 p1(2, 0);</div><div class="line">  <span class="keyword">const</span> Point_2 p2(7, 1);</div><div class="line">  <span class="keyword">const</span> Point_2 q0(3, 1);</div><div class="line"></div><div class="line">  <span class="comment">// Choose a type of the weight:</span></div><div class="line">  <span class="comment">// e.g. 0 - Wachspress (WP) weight; 1 - mean value (MV);</span></div><div class="line">  <span class="keyword">const</span> FT wp = 0.0;</div><div class="line">  <span class="keyword">const</span> FT mv = 1.0;</div><div class="line"></div><div class="line">  <span class="comment">// Compute WP and MV weights.</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"3D Wachspress (WP, q0): "</span>;</div><div class="line">  std::cout &lt;&lt; <a class="code" href="group__PkgWeightsRefThreePointFamilyWeights.html#ga92a8e30bdece87c1f9b615e01250ee57">CGAL::Weights::three_point_family_weight</a>(p0, p1, p2, q0, wp) &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"3D mean value (MV, q0): "</span>;</div><div class="line">  std::cout &lt;&lt; <a class="code" href="group__PkgWeightsRefThreePointFamilyWeights.html#ga92a8e30bdece87c1f9b615e01250ee57">CGAL::Weights::three_point_family_weight</a>(p0, p1, p2, q0, mv) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Converge WP towards MV.</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Converge WP to MV on q0: "</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keyword">const</span> FT step = 0.1;</div><div class="line">  <span class="keywordflow">for</span> (FT x = 0.0; x &lt;= 1.0; x += step) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"3D x: "</span>;</div><div class="line">    std::cout &lt;&lt; <a class="code" href="group__PkgWeightsRefThreePointFamilyWeights.html#ga92a8e30bdece87c1f9b615e01250ee57">CGAL::Weights::three_point_family_weight</a>(p0, p1, p2, q0, x) &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Weights_History"></a>
History</h1>
<p>This package is a part of the weights unification effort inside CGAL that has been carried out by Dmitry Anisimov in 2020.</p>
<h1><a class="anchor" id="Weights_Acknowledgements"></a>
Acknowledgments</h1>
<p>We wish to thank Guillaume Damiand, Andreas Fabri, and Mael Rouxel-Labbé for useful discussions and reviews. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jun 27 2022 09:17:13 for CGAL 5.6 - Weights by
    <a href="https://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>
</html>

</html>
