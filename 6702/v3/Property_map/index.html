<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="https://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Property_map/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 5.6 - CGAL and Boost Property Maps: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//&lt;![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      }
  }
}
);
//]]&gt;
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.6 - CGAL and Boost Property Maps
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_CGAL_and_Boost_Property_Maps"></a> <a class="anchor" id="chapterProperty_map"></a>  </p><div id="autotoc" class="toc"></div> 
<dl class="section author"><dt>Authors</dt><dd>Andreas Fabri and Laurent Saboret</dd></dl>
<h1><a class="anchor" id="Property_mapA"></a>
A Short Introduction to the Boost Property Maps Library</h1>
<p>The Boost Property Map Library consists mainly of interface specifications in the form of concepts. These interface specifications are intended for use by implementors of generic libraries in communicating requirements on template parameters to their users. In particular, the Boost Property Map concepts define a general purpose interface for mapping key objects to corresponding value objects, thereby hiding the details of how the mapping is implemented from algorithms. The implementation of types fulfilling the property map interface is up to the client of the algorithm to provide.</p>
<p>The Boost Property Map Library also contains a few adaptors that convert commonly used data-structures that implement a mapping operation, such as builtin arrays (pointers), iterators, and std::map, to have the property map interface.</p>
<p>Free functions <code>get</code> and <code>put</code> allow getting and putting information through a property map. The data themselves may be stored in the element, or they may be stored in an external data structure, or they may be computed on the fly. This is an "implementation detail" of the particular property map.<br />
</p>
<p>Property maps in the Boost manuals: <a href="https://www.boost.org/libs/property_map/doc/property_map.html"><code>https://www.boost.org/libs/property_map/doc/property_map.html</code></a></p>
<h1><a class="anchor" id="Property_mapCGAL"></a>
CGAL and Boost Property Maps</h1>
<p>Some algorithms in CGAL take as input parameters iterator ranges and property maps to access information attached to elements of the sequence.</p>
<p>For example, the algorithms of chapters <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/index.html#Chapter_Point_Set_Processing">Point Set Processing</a> and <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Poisson_surface_reconstruction_3.tag:../Poisson_surface_reconstruction_3/" href="../Poisson_surface_reconstruction_3/index.html#Chapter_Poisson_Surface_Reconstruction">Poisson Surface Reconstruction</a> take as input parameters iterator ranges and property maps to access each point's position and normal. Position and normal might be represented in various ways, e.g., as a class derived from the CGAL point class, or as a <code>std::pair&lt;<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__3.html">Point_3</a>&lt;K&gt;, <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Vector__3.html">Vector_3</a>&lt;K&gt; &gt;</code>, or as a <code>boost::tuple&lt;..,<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__3.html">Point_3</a>&lt;K&gt;, ..., <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Vector__3.html">Vector_3</a>&lt;K&gt; &gt;</code>.</p>
<p>This component provides property maps to support these cases:</p>
<ul>
<li><code><a class="el" href="structCGAL_1_1Identity__property__map.html" title="A LvaluePropertyMap property map mapping a key to itself (by reference). ">Identity_property_map</a>&lt;T&gt;</code></li>
<li><code><a class="el" href="structCGAL_1_1First__of__pair__property__map.html" title="Property map that accesses the first item of a std::pair. ">First_of_pair_property_map</a>&lt;Pair&gt;</code> and <code><a class="el" href="structCGAL_1_1Second__of__pair__property__map.html" title="Property map that accesses the second item of a std::pair. ">Second_of_pair_property_map</a>&lt;Pair&gt;</code></li>
<li><code><a class="el" href="structCGAL_1_1Nth__of__tuple__property__map.html" title="Property map that accesses the Nth item of a boost::tuple or a std::tuple. ">Nth_of_tuple_property_map</a>&lt;N, Tuple&gt;</code></li>
<li><code><a class="el" href="structCGAL_1_1Dereference__property__map.html" title="Property map that converts a T* pointer (or in general an iterator over T elements) to the T object...">Dereference_property_map</a>&lt;T&gt;</code></li>
</ul>
<h2><a class="anchor" id="Property_mapExamplewithIdentity"></a>
Example with Identity_property_map</h2>
<p>The following example reads a point set and removes 5% of the points. It uses <code><a class="el" href="structCGAL_1_1Identity__property__map.html" title="A LvaluePropertyMap property map mapping a key to itself (by reference). ">Identity_property_map</a>&lt;<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__3.html">Point_3</a>&gt;</code> as position property map. <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2remove_outliers_example_8cpp-example.html">Point_set_processing_3/remove_outliers_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/compute_average_spacing.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/remove_outliers.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname = (argc&gt;1)?argv[1]:<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/oni.pwn"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Reads a point set file in points[].</span></div><div class="line">  <span class="comment">// The Identity_property_map property map can be omitted here as it is the default value.</span></div><div class="line">  std::vector&lt;Point&gt; points;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname, std::back_inserter(points),</div><div class="line">                            CGAL::parameters::point_map(<a class="code" href="structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map&lt;Point&gt;</a>())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Removes outliers using erase-remove idiom.</span></div><div class="line">  <span class="comment">// The Identity_property_map property map can be omitted here as it is the default value.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_neighbors = 24; <span class="comment">// considers 24 nearest neighbor points</span></div><div class="line"></div><div class="line">  <span class="comment">// Estimate scale of the point set with average spacing</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> average_spacing = CGAL::compute_average_spacing&lt;CGAL::Sequential_tag&gt;(points, nb_neighbors);</div><div class="line"></div><div class="line">  <span class="comment">// FIRST OPTION //</span></div><div class="line">  <span class="comment">// I don't know the ratio of outliers present in the point set</span></div><div class="line">  std::vector&lt;Point&gt;::iterator first_to_remove</div><div class="line">    = CGAL::remove_outliers&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (points,</div><div class="line">     nb_neighbors,</div><div class="line">     CGAL::parameters::threshold_percent (100.). <span class="comment">// No limit on the number of outliers to remove</span></div><div class="line">     threshold_distance (2. * average_spacing)); <span class="comment">// Point with distance above 2*average_spacing are considered outliers</span></div><div class="line"></div><div class="line">  std::cerr &lt;&lt; (100. * std::distance(first_to_remove, points.end()) / static_cast&lt;double&gt;(points.size()))</div><div class="line">            &lt;&lt; <span class="stringliteral">"% of the points are considered outliers when using a distance threshold of "</span></div><div class="line">            &lt;&lt; 2. * average_spacing &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// SECOND OPTION //</span></div><div class="line">  <span class="comment">// I know the ratio of outliers present in the point set</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> removed_percentage = 5.0; <span class="comment">// percentage of points to remove</span></div><div class="line"></div><div class="line">  points.erase(CGAL::remove_outliers&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">               (points,</div><div class="line">                nb_neighbors,</div><div class="line">                CGAL::parameters::threshold_percent(removed_percentage). <span class="comment">// Minimum percentage to remove</span></div><div class="line">                threshold_distance(0.)), <span class="comment">// No distance threshold (can be omitted)</span></div><div class="line">               points.end());</div><div class="line"></div><div class="line">  <span class="comment">// Optional: after erase(), use Scott Meyer's "swap trick" to trim excess capacity</span></div><div class="line">  std::vector&lt;Point&gt;(points).swap(points);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Property_mapExamplewithPairs"></a>
Example with Pairs</h2>
<p>The following example reads a point set from an input file and writes it to a file, both in the xyz format. Position and normal are stored in pairs and accessed through property maps. <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2read_write_xyz_point_set_example_8cpp-example.html">Point_set_processing_3/read_write_xyz_point_set_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_xyz_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_xyz_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span> <span class="comment">// defines std::pair</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"></div><div class="line"><span class="comment">// Point with normal vector stored as a std::pair.</span></div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Point, Vector&gt; Pwn;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/oni.pwn"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Reads a .xyz point set file in points[].</span></div><div class="line">  <span class="comment">// Note: read_points() requires an output iterator</span></div><div class="line">  <span class="comment">// over points and as well as property maps to access each</span></div><div class="line">  <span class="comment">// point position and normal.</span></div><div class="line">  std::vector&lt;Pwn&gt; points;</div><div class="line">  <span class="keywordflow">if</span>(!CGAL::IO::read_XYZ(fname,</div><div class="line">                         std::back_inserter(points),</div><div class="line">                         CGAL::parameters::point_map(<a class="code" href="structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Pwn&gt;</a>())</div><div class="line">                                          .normal_map(<a class="code" href="structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;Pwn&gt;</a>())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Saves point set.</span></div><div class="line">  <span class="comment">// Note: write_XYZ() requires property maps to access each</span></div><div class="line">  <span class="comment">// point position and normal.</span></div><div class="line">  <span class="keywordflow">if</span>(!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3IOXyz.html#ga1991ab8d312de62ddd907f81890ed039">CGAL::IO::write_XYZ</a>(<span class="stringliteral">"oni_copy.xyz"</span>, points,</div><div class="line">                          CGAL::parameters::point_map(<a class="code" href="structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Pwn&gt;</a>())</div><div class="line">                                           .normal_map(<a class="code" href="structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;Pwn&gt;</a>())</div><div class="line">                                           .stream_precision(17)))</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Property_mapExamplewithTuples"></a>
Example with Tuples</h2>
<p>The following example reads a point set in the <code>xyz</code> format and computes the average spacing. Index, position and color are stored in a tuple and accessed through property maps. <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2average_spacing_example_8cpp-example.html">Point_set_processing_3/average_spacing_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/compute_average_spacing.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/tuple/tuple.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"></div><div class="line"><span class="comment">// Data type := index, followed by the point, followed by three integers that</span></div><div class="line"><span class="comment">// define the Red Green Blue color of the point.</span></div><div class="line"><span class="keyword">typedef</span> boost::tuple&lt;int, Point, int, int, int&gt; IndexedPointWithColorTuple;</div><div class="line"></div><div class="line"><span class="comment">// Concurrency</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a> Concurrency_tag;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname = (argc&gt;1)?argv[1]:<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/sphere_20k.xyz"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Reads a file in points.</span></div><div class="line">  <span class="comment">// As the point is the second element of the tuple (that is with index 1)</span></div><div class="line">  <span class="comment">// we use a property map that accesses the 1st element of the tuple.</span></div><div class="line"></div><div class="line">  std::vector&lt;IndexedPointWithColorTuple&gt; points;</div><div class="line">  <span class="keywordflow">if</span> (!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname, std::back_inserter(points),</div><div class="line">                             CGAL::parameters::point_map(<a class="code" href="structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;1, IndexedPointWithColorTuple&gt;</a>())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Initialize index and RGB color fields in tuple.</span></div><div class="line">  <span class="comment">// As the index and RGB color are respectively the first and third-fifth elements</span></div><div class="line">  <span class="comment">// of the tuple we use a get function from the property map that accesses the 0</span></div><div class="line">  <span class="comment">// and 2-4th elements of the tuple.</span></div><div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; points.size(); i++)</div><div class="line">  {</div><div class="line">    points[i].get&lt;0&gt;() = i; <span class="comment">// set index value of tuple to i</span></div><div class="line"></div><div class="line">    points[i].get&lt;2&gt;() = 0; <span class="comment">// set RGB color to black</span></div><div class="line">    points[i].get&lt;3&gt;() = 0;</div><div class="line">    points[i].get&lt;4&gt;() = 0;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Computes average spacing.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nb_neighbors = 6; <span class="comment">// 1 ring</span></div><div class="line">  FT average_spacing = CGAL::compute_average_spacing&lt;Concurrency_tag&gt;(</div><div class="line">                         points, nb_neighbors,</div><div class="line">                         CGAL::parameters::point_map(<a class="code" href="structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;1,IndexedPointWithColorTuple&gt;</a>()));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Average spacing: "</span> &lt;&lt; average_spacing &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h1><a class="anchor" id="Property_mapCustom"></a>
Writing Custom Property Maps</h1>
<p>Property maps are especially useful when using predefined data structures that are not part of the CGAL library: algorithms written with property maps can be called on these data structures provided the user writes the required property maps, without the need to create deep copies of potentially large data into CGAL formats.</p>
<p>The following example shows how to write a readable point map and a read-write normal map to run CGAL normal estimation and orientation algorithm on raw <code>double</code> arrays: <br />
<b>File</b> <a class="el" href="Property_map_2custom_property_map_8cpp-example.html">Property_map/custom_property_map.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/point_generators_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/jet_estimate_normals.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/mst_orient_normals.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> Kernel = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div><div class="line"><span class="keyword">using</span> Point_3 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ae82b7f4be77dd5b8819ebe419e4ae753">Kernel::Point_3</a>;</div><div class="line"><span class="keyword">using</span> Vector_3 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a39fb0222695ae5e7e32f4e570ea28225">Kernel::Vector_3</a>;</div><div class="line"><span class="keyword">using</span> Generator = CGAL::Random_points_on_sphere_3&lt;Point_3&gt;;</div><div class="line"></div><div class="line"><span class="comment">// Example of readable property map to get CGAL::Point_3 objects from</span></div><div class="line"><span class="comment">// 3 coordinate arrays</span></div><div class="line"><span class="keyword">struct </span>Custom_point_map</div><div class="line">{</div><div class="line">  <span class="keyword">using</span> key_type = std::size_t; <span class="comment">// The iterator's value type is an index</span></div><div class="line">  <span class="keyword">using</span> value_type = Point_3;   <span class="comment">// The object manipulated by the algorithm is a Point_3</span></div><div class="line">  <span class="keyword">using</span> reference = Point_3;    <span class="comment">// The object does not exist in memory, so there's no reference</span></div><div class="line">  <span class="keyword">using</span> category = boost::readable_property_map_tag; <span class="comment">// The property map is only used for reading</span></div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> *x, *y, *z;</div><div class="line"></div><div class="line">  Custom_point_map (<span class="keywordtype">double</span>* x = <span class="keyword">nullptr</span>, <span class="keywordtype">double</span>* y = <span class="keyword">nullptr</span>, <span class="keywordtype">double</span>* z = <span class="keyword">nullptr</span>)</div><div class="line">    : x(x), y(y), z(z) { }</div><div class="line"></div><div class="line">  <span class="comment">// The get() function returns the object expected by the algorithm (here, Point_3)</span></div><div class="line">  <span class="keyword">friend</span> Point_3 <span class="keyword">get</span> (<span class="keyword">const</span> Custom_point_map&amp; map, std::size_t idx)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">return</span> Point_3 (map.x[idx], map.y[idx], map.z[idx]);</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Example of read-write property map to get CGAL::Vector_3 objects from</span></div><div class="line"><span class="comment">// a buffer array and put CGAL::Vector_3 values in this buffer</span></div><div class="line"><span class="keyword">struct </span>Custom_normal_map</div><div class="line">{</div><div class="line">  <span class="keyword">using</span> key_type = std::size_t; <span class="comment">// The iterator's value type is an index</span></div><div class="line">  <span class="keyword">using</span> value_type = Vector_3;  <span class="comment">// The object manipulated by the algorithm is a Vector_3</span></div><div class="line">  <span class="keyword">using</span> reference = Vector_3;   <span class="comment">// The object does not exist in memory, so there's no reference</span></div><div class="line">  <span class="keyword">using</span> category = boost::read_write_property_map_tag; <span class="comment">// The property map is used both</span></div><div class="line">                                                       <span class="comment">// for reading and writing data</span></div><div class="line">  <span class="keywordtype">double</span> *buffer;</div><div class="line"></div><div class="line">  Custom_normal_map (<span class="keywordtype">double</span>* buffer = <span class="keyword">nullptr</span>)</div><div class="line">    : buffer (buffer) { }</div><div class="line"></div><div class="line">  <span class="comment">// The get() function returns the object expected by the algorithm (here, Vector_3)</span></div><div class="line">  <span class="keyword">friend</span> Vector_3 <span class="keyword">get</span> (<span class="keyword">const</span> Custom_normal_map&amp; map, std::size_t idx)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">return</span> Vector_3 (map.buffer[idx * 3    ],</div><div class="line">                     map.buffer[idx * 3 + 1],</div><div class="line">                     map.buffer[idx * 3 + 2]);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// The put() function updated the user's data structure from the</span></div><div class="line">  <span class="comment">// object handled by the algorithm (here Vector_3)</span></div><div class="line">  <span class="keyword">friend</span> <span class="keywordtype">void</span> put (<span class="keyword">const</span> Custom_normal_map&amp; map, std::size_t idx, <span class="keyword">const</span> Vector_3&amp; vector_3)</div><div class="line">  {</div><div class="line">    map.buffer[idx * 3    ] = vector_3.x();</div><div class="line">    map.buffer[idx * 3 + 1] = vector_3.y();</div><div class="line">    map.buffer[idx * 3 + 2] = vector_3.z();</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  constexpr std::size_t nb_points = 1000;</div><div class="line"></div><div class="line">  <span class="comment">// in this example, points are stored as separate coordinate arrays</span></div><div class="line">  <span class="keywordtype">double</span> x[nb_points];</div><div class="line">  <span class="keywordtype">double</span> y[nb_points];</div><div class="line">  <span class="keywordtype">double</span> z[nb_points];</div><div class="line"></div><div class="line">  <span class="comment">// generate random points</span></div><div class="line">  Generator generator;</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; nb_points; ++ i)</div><div class="line">  {</div><div class="line">    Point_3 p = *(generator ++ );</div><div class="line">    x[i] = p.x();</div><div class="line">    y[i] = p.y();</div><div class="line">    z[i] = p.z();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// normals are stored as a contiguous double array</span></div><div class="line">  <span class="keywordtype">double</span> normals[3 *nb_points];</div><div class="line"></div><div class="line">  <span class="comment">// we use a vector of indices to access arrays</span></div><div class="line">  std::vector&lt;std::size_t&gt; indices;</div><div class="line">  indices.reserve (nb_points);</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; nb_points; ++ i)</div><div class="line">    indices.push_back(i);</div><div class="line"></div><div class="line">  <span class="comment">// estimate and orient normals using directly user's data structure</span></div><div class="line">  <span class="comment">// instead of creating deep copies using Point_3 and Vector_3</span></div><div class="line">  CGAL::jet_estimate_normals&lt;CGAL::Sequential_tag&gt;</div><div class="line">    (indices, 12,</div><div class="line">     CGAL::parameters::point_map (Custom_point_map(x,y,z)).</div><div class="line">     normal_map (Custom_normal_map(normals)));</div><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Algorithms.html#ga17c3c558c3799b65bd23fba971a82a5c">CGAL::mst_orient_normals</a></div><div class="line">    (indices, 12,</div><div class="line">     CGAL::parameters::point_map (Custom_point_map(x,y,z)).</div><div class="line">     normal_map (Custom_normal_map(normals)));</div><div class="line"></div><div class="line">  <span class="comment">// Display first 10 points+normals</span></div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; 10; ++ i)</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Point("</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">") = "</span> &lt;&lt; x[i] &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; y[i] &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; z[i]</div><div class="line">              &lt;&lt; <span class="stringliteral">"\tNormal("</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">") = "</span></div><div class="line">              &lt;&lt; normals[3*i] &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; normals[3*i+1] &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; normals[3*i+2] &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Dec 22 2022 12:49:19 for CGAL 5.6 - CGAL and Boost Property Maps by
    <a href="https://www.doxygen.nl/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>

</html>
