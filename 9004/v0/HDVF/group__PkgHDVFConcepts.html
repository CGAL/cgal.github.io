<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/HDVF/group__PkgHDVFConcepts.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=11">
<meta name="generator" content="Doxygen 1.9.6">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CGAL 6.2 - Homological Discrete Vector Fields: Concepts</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/doxygen.css" rel="stylesheet" type="text/css">
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      },
      equationNumbers: { autoNumber: "AMS" }
  }
}
);
MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
  var PARSE = MathJax.InputJax.TeX.Parse,
      TEXT = PARSE.prototype.InternalText;
  PARSE.Augment({
    InternalText: function (text,def) {
      text = text.replace(/\\/g,"");
      return TEXT.call(this,text,def);
    }
  });
});
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
      <span class="left">
         <span id="MSearchSelect" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"> 
        </span>
        <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
      </span>
      <span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.svg" alt=""></a>
      </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CGAL 6.2 - Homological Discrete Vector Fields
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search/",'.html');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__PkgHDVFConcepts.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle"><div class="title">Concepts<div class="ingroups"><a class="el" href="group__PkgHDVFRef.html">Homological Discrete Vector Fields Reference</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader"> </h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractChainComplex.html">AbstractChainComplex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">The concept <code><a class="el" href="classAbstractChainComplex.html" title="The concept AbstractChainComplex describes the requirements for (topological) chain complexes associa...">AbstractChainComplex</a></code> describes the requirements for (topological) chain complexes associated to abstract complexes used in the concept <code><a class="el" href="classHDVF.html" title="The concept HDVF describes the requirements for Homological Discrete Vector Fields (HDVF for short) ,...">HDVF</a></code>.  <a href="classAbstractChainComplex.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept</td><td class="memItemRight" valign="bottom"><a class="el" href="classFiltration.html">Filtration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">The concept <code><a class="el" href="classFiltration.html" title="The concept Filtration describes the requirements for persistent filtrations associated to persistent...">Filtration</a></code> describes the requirements for persistent filtrations associated to persistent homology computation.  <a href="classFiltration.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometricChainComplex.html">GeometricChainComplex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">The concept <code><a class="el" href="classGeometricChainComplex.html" title="The concept GeometricChainComplex refines the concept AbstractChainComplex and describes the requirem...">GeometricChainComplex</a></code> refines the concept <code><a class="el" href="classAbstractChainComplex.html" title="The concept AbstractChainComplex describes the requirements for (topological) chain complexes associa...">AbstractChainComplex</a></code> and describes the requirements for (topological) chain complexes associated to geometric complexes used in the concept <code><a class="el" href="classHDVF.html" title="The concept HDVF describes the requirements for Homological Discrete Vector Fields (HDVF for short) ,...">HDVF</a></code>. It adds to <code><a class="el" href="classAbstractChainComplex.html" title="The concept AbstractChainComplex describes the requirements for (topological) chain complexes associa...">AbstractChainComplex</a></code> methods to get vertex coordinates.  <a href="classGeometricChainComplex.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept</td><td class="memItemRight" valign="bottom"><a class="el" href="classHDVF.html">HDVF</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">The concept <code><a class="el" href="classHDVF.html" title="The concept HDVF describes the requirements for Homological Discrete Vector Fields (HDVF for short) ,...">HDVF</a></code> describes the requirements for Homological Discrete <a class="elRef" href="../Kernel_d/classVector.html">Vector</a> Fields (HDVF for short) , a theory of computational homology unifying discrete Morse theory and effective homology. HDVFs were introduced by Aldo Gonzalez-Lorenzo in his PhD (see [AGL,2017], [AGL,2016]).  <a href="classHDVF.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept</td><td class="memItemRight" valign="bottom"><a class="el" href="classHDVFTraits.html">HDVFTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">The concept <code><a class="el" href="classHDVFTraits.html" title="The concept HDVFTraits describes the requirements for geometric traits classes used in this package.">HDVFTraits</a></code> describes the requirements for geometric traits classes used in this package.  <a href="classHDVFTraits.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseChain.html">SparseChain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">The concept <code><a class="el" href="classSparseChain.html" title="The concept SparseChain describes the requirements for sparse vectors (called sparse chains in homolo...">SparseChain</a></code> describes the requirements for sparse vectors (called <em>sparse chains</em> in homology) optimized for topological computations. More precisely, <code><a class="el" href="classSparseChain.html" title="The concept SparseChain describes the requirements for sparse vectors (called sparse chains in homolo...">SparseChain</a></code> provides all the operations on chains required by the <code><a class="el" href="classSparseMatrix.html" title="The concept SparseMatrix describes the requirements for sparse matrices optimized for topological com...">SparseMatrix</a></code> concept.  <a href="classSparseChain.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html">SparseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">The concept <code><a class="el" href="classSparseMatrix.html" title="The concept SparseMatrix describes the requirements for sparse matrices optimized for topological com...">SparseMatrix</a></code> describes the requirements for sparse matrices optimized for topological computations. Traditionally, sparse matrices data structures encode non zero coefficients of (sparse) matrices in order to optimize either matrices memory footprint, or linear algebra operations (which usually comes to optimize iterators over non zero coefficients and access to coefficients). However, topological operations require slightly different features:  <a href="classSparseMatrix.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga8024df64118f79bc6cfe6dc8cd8470bc"><td class="memItemLeft" align="right" valign="top"><a id="ga8024df64118f79bc6cfe6dc8cd8470bc" name="ga8024df64118f79bc6cfe6dc8cd8470bc"></a>
class <a class="el" href="classAbstractChainComplex.html">AbstractChainComplex</a> </td><td class="memItemRight" valign="bottom"><b>dimension</b> ()</td></tr>
<tr class="memdesc:ga8024df64118f79bc6cfe6dc8cd8470bc"><td class="mdescLeft"> </td><td class="mdescRight">Returns the dimension of the complex, that is, the largest dimension of cells. <br></td></tr>
<tr class="separator:ga8024df64118f79bc6cfe6dc8cd8470bc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gae20bc21f98d59b73d3fa0be8f860b0b2"><td class="memItemLeft" align="right" valign="top">size_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__PkgHDVFConcepts.html#gae20bc21f98d59b73d3fa0be8f860b0b2">number_of_cells</a> (int q)</td></tr>
<tr class="memdesc:gae20bc21f98d59b73d3fa0be8f860b0b2"><td class="mdescLeft"> </td><td class="mdescRight">Returns the number of cells of dimension <code>q</code>.  <br></td></tr>
<tr class="separator:gae20bc21f98d59b73d3fa0be8f860b0b2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaa385be99546b52eb5e18a474fd19a5f5"><td class="memItemLeft" align="right" valign="top">const vector&lt; <a class="el" href="classCGAL_1_1OSM_1_1Sparse__matrix.html">Column_matrix</a> &gt; &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__PkgHDVFConcepts.html#gaa385be99546b52eb5e18a474fd19a5f5">boundary_matrices</a> () const</td></tr>
<tr class="memdesc:gaa385be99546b52eb5e18a474fd19a5f5"><td class="mdescLeft"> </td><td class="mdescRight">Returns all boundary matrices.  <br></td></tr>
<tr class="separator:gaa385be99546b52eb5e18a474fd19a5f5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga3a24527a4f74a6a0d042ebe5fa6ac7cf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classCGAL_1_1OSM_1_1Sparse__matrix.html">Column_matrix</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__PkgHDVFConcepts.html#ga3a24527a4f74a6a0d042ebe5fa6ac7cf">boundary_matrix</a> (int q) const</td></tr>
<tr class="memdesc:ga3a24527a4f74a6a0d042ebe5fa6ac7cf"><td class="mdescLeft"> </td><td class="mdescRight">Returns the boundary matrix of dimension <code>q</code> (ie. the matrix of \(\partial_q\)).  <br></td></tr>
<tr class="separator:ga3a24527a4f74a6a0d042ebe5fa6ac7cf"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gadf5d4a420e488675a634571bc1829880"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1OSM_1_1Sparse__chain.html">Column_chain</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="group__PkgHDVFConcepts.html#gadf5d4a420e488675a634571bc1829880">d</a> (size_t id_cell, int q)</td></tr>
<tr class="memdesc:gadf5d4a420e488675a634571bc1829880"><td class="mdescLeft"> </td><td class="mdescRight">Returns the boundary of the cell of index <code>id_cell</code> in dimension <code>q</code>.  <br></td></tr>
<tr class="separator:gadf5d4a420e488675a634571bc1829880"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga826ba425c9c48d1036c6edab3689d864"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1OSM_1_1Sparse__chain.html">Row_chain</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="group__PkgHDVFConcepts.html#ga826ba425c9c48d1036c6edab3689d864">cod</a> (size_t id_cell, int q)</td></tr>
<tr class="memdesc:ga826ba425c9c48d1036c6edab3689d864"><td class="mdescLeft"> </td><td class="mdescRight">Returns the co-boundary of the cell of index <code>id_cell</code> in dimension <code>q</code>.  <br></td></tr>
<tr class="separator:ga826ba425c9c48d1036c6edab3689d864"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga4b631f9e40a826a781732d04939315f1"><td class="memItemLeft" align="right" valign="top"><a id="ga4b631f9e40a826a781732d04939315f1" name="ga4b631f9e40a826a781732d04939315f1"></a>
std::vector&lt; size_t &gt; </td><td class="memItemRight" valign="bottom"><b>bottom_faces</b> (size_t id_cell, int q) const</td></tr>
<tr class="memdesc:ga4b631f9e40a826a781732d04939315f1"><td class="mdescLeft"> </td><td class="mdescRight">Returns the vertices of a given cell (that is, the indices of its faces of dimension 0). <br></td></tr>
<tr class="separator:ga4b631f9e40a826a781732d04939315f1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaa7086db2ebf40649236730213d4f2b22"><td class="memTemplParams" colspan="2">template&lt;typename CoefficientR , int StorageF&gt; </td></tr>
<tr class="memitem:gaa7086db2ebf40649236730213d4f2b22"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1OSM_1_1Sparse__chain.html">Column_chain</a> </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgHDVFConcepts.html#gaa7086db2ebf40649236730213d4f2b22">cofaces_chain</a> (<a class="el" href="classSparseChain.html">SparseChain</a>&lt; CoefficientR, StorageF &gt; chain, int q) const</td></tr>
<tr class="memdesc:gaa7086db2ebf40649236730213d4f2b22"><td class="mdescLeft"> </td><td class="mdescRight">Returns the cofaces of a given chain in dimension <code>q</code>.  <br></td></tr>
<tr class="separator:gaa7086db2ebf40649236730213d4f2b22"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaa385be99546b52eb5e18a474fd19a5f5" name="gaa385be99546b52eb5e18a474fd19a5f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa385be99546b52eb5e18a474fd19a5f5">◆ </a></span>boundary_matrices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const vector&lt; <a class="el" href="classCGAL_1_1OSM_1_1Sparse__matrix.html">Column_matrix</a> &gt; &amp; boundary_matrices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;Concepts/AbstractChainComplex.h&gt;</code></p>

<p>Returns all boundary matrices. </p>
<p>The function returns constant reference to a vector of column-major sparse matrices. The <code>q</code>-th element of this vector is the matrix of \(\partial_q\), which gives the boundary of cells of dimension <code>q</code>(as a linear combination of <code>q</code>-1 cells). </p>

</div>
</div>
<a id="ga3a24527a4f74a6a0d042ebe5fa6ac7cf" name="ga3a24527a4f74a6a0d042ebe5fa6ac7cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a24527a4f74a6a0d042ebe5fa6ac7cf">◆ </a></span>boundary_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classCGAL_1_1OSM_1_1Sparse__matrix.html">Column_matrix</a> &amp; boundary_matrix </td>
          <td>(</td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;Concepts/AbstractChainComplex.h&gt;</code></p>

<p>Returns the boundary matrix of dimension <code>q</code> (ie. the matrix of \(\partial_q\)). </p>
<p>The function returns a column-major sparse matrices. </p>

</div>
</div>
<a id="ga826ba425c9c48d1036c6edab3689d864" name="ga826ba425c9c48d1036c6edab3689d864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga826ba425c9c48d1036c6edab3689d864">◆ </a></span>cod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1OSM_1_1Sparse__chain.html">Row_chain</a> cod </td>
          <td>(</td>
          <td class="paramtype">size_t </td>
          <td class="paramname"><em>id_cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>q</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;Concepts/AbstractChainComplex.h&gt;</code></p>

<p>Returns the co-boundary of the cell of index <code>id_cell</code> in dimension <code>q</code>. </p>
<p>This boundary is a finite linear combination of cells of dimension <code>q+1</code>. It is encoded as a row-major chain (which maps each cell with a non-zero coefficient to this coefficient). This co-boundary is thus the <code>id_cell</code>-th row of the boundary matrix in dimension <code>q</code>+1. </p>

</div>
</div>
<a id="gaa7086db2ebf40649236730213d4f2b22" name="gaa7086db2ebf40649236730213d4f2b22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7086db2ebf40649236730213d4f2b22">◆ </a></span>cofaces_chain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoefficientR , int StorageF&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1OSM_1_1Sparse__chain.html">Column_chain</a> cofaces_chain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparseChain.html">SparseChain</a>&lt; CoefficientR, StorageF &gt; </td>
          <td class="paramname"><em>chain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>q</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;Concepts/AbstractChainComplex.h&gt;</code></p>

<p>Returns the cofaces of a given chain in dimension <code>q</code>. </p>
<p>The resulting chain, whatever the storage format of the input, is column-major, lies in dimension <code>q</code>+1 and is null if this dimension exceeds the dimension of the complex.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CoefficientR</td><td><code>CoefficientRing</code> of the chain. </td></tr>
    <tr><td class="paramname">StorageF</td><td><code>StorageFormat</code> of the chain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadf5d4a420e488675a634571bc1829880" name="gadf5d4a420e488675a634571bc1829880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf5d4a420e488675a634571bc1829880">◆ </a></span>d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1OSM_1_1Sparse__chain.html">Column_chain</a> d </td>
          <td>(</td>
          <td class="paramtype">size_t </td>
          <td class="paramname"><em>id_cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>q</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;Concepts/AbstractChainComplex.h&gt;</code></p>

<p>Returns the boundary of the cell of index <code>id_cell</code> in dimension <code>q</code>. </p>
<p>This boundary is a finite linear combination of cells of dimension <code>q-1</code>. It is encoded as a column-major chain (which maps each cell with a non-zero coefficient to this coefficient). This boundary is thus the <code>id_cell</code>-th column of the boundary matrix in dimension <code>q</code>. </p>

</div>
</div>
<a id="gae20bc21f98d59b73d3fa0be8f860b0b2" name="gae20bc21f98d59b73d3fa0be8f860b0b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae20bc21f98d59b73d3fa0be8f860b0b2">◆ </a></span>number_of_cells()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t number_of_cells </td>
          <td>(</td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;Concepts/AbstractChainComplex.h&gt;</code></p>

<p>Returns the number of cells of dimension <code>q</code>. </p>
<p>If <code>q</code> is negative of larger than the dimension of the complex, returns 0. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"></a> 1.9.6 </li>
  </ul>
</div>
</div>
</body>


</html>
