<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Arrangement_on_surface_2/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 5.4 - 2D Arrangements: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//&amp;lt;![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      }
  }
}
);
//]]&amp;gt;
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.4 - 2D Arrangements
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_2D_Arrangements"></a><a class="anchor" id="chapterArrangement_on_surface_2"></a> </p><div id="autotoc" class="toc"></div> 
<dl class="section author"><dt>Authors</dt><dd>Ron Wein, Eric Berberich, Efi Fogel, Dan Halperin, Michael Hemmer, Oren Salzman, and Baruch Zukerman</dd></dl>
<h1><a class="anchor" id="aos_sec-intro"></a>
Introduction</h1>
<p>Geometric arrangements, or arrangements for short, are subdivisions of some space induced by geometric objects. <a class="el" href="index.html#fig__aos_fig-simple_arr">Figure 34.1</a> shows an arrangement of two curves \(c_1\) and \(c_2\) in the plane. It has three faces—two bounded faces \(f_1\) and \(f_2\) (filled with diagonal-stripe patterns) and an unbounded face. The arrangement has seven vertices—four represent the endpoints of \(c_1\) and \(c_2\) (drawn as small discs), and three represent the intersection points of the two curves (drawn as small rings). The arrangement also has eight edges, each of which is a maximal portion of one curve not intersecting the other.</p>
<p><a class="anchor" id="fig__aos_fig-simple_arr"></a></p><div class="image">
<img src="simple_arr.png" alt="simple_arr.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-simple_arr">Figure 34.1</a>  </div> <br /> 
<p>Arrangements are not restricted to curves in the plane. There are useful arrangements in three and higher dimensions (these are not so easy to visualize) and they can be induced by geometric objects of any type, such as spheres, simplices, polytopes, or Bézier surfaces. This package provides a data structure that represents a two-dimensional arrangement of curves embedded in an orientable parametric surface in three dimensional space, such as a plane, a cylinder, a sphere, a torus, or a surface homeomorphic to them. This package also provides operations that construct and manipulate such arrangements. Arrangements are ubiquitous in the computational-geometry literature and have many applications; see, e.g., <a class="el" href="citelist.html#CITEREF_as-aa-00">[1]</a>, <a class="el" href="citelist.html#CITEREF_cgal:bfhks-apsca-10">[3]</a>, <a class="el" href="citelist.html#CITEREF_cgal:bfhmw-apsgf-10">[4]</a>, and <a class="el" href="citelist.html#CITEREF_cgal:h-a-04">[8]</a>.</p>
<h2><a class="anchor" id="aos_ssec-intro-sep"></a>
Separation of Topology and Geometry</h2>
<p>The use of the generic programming paradigm enables a convenient separation of the topology and the geometry of data structures.<span class="footnote">In this context, we sometimes say <em>combinatorics</em> instead of topology, and say <em>algebra</em> or <em>numerics</em> instead of geometry. We always mean the same thing—the separation of the abstract, graph-like structure (the topology) from the actual embedding in the plane (the geometry).</span> This is a key aspect in the design of geometric software, and is put into practice, for example, in the design of CGAL polyhedra, CGAL triangulations, and our CGAL arrangements. This separation allows the convenient abstraction of algorithms and data structures in combinatorial and topological terms, regardless of the specific geometry of the objects at hand. This abstraction is realized through class and function templates that represent specific data structures and algorithmic frameworks, respectively. Consider the class template</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> GeometryTraits, <span class="keyword">typename</span> Dcel&gt;</div><div class="line"><span class="keyword">class </span>Arrangement_2 { ... };</div></div><!-- fragment --><p>An instance of this template represents an arrangement embedded in the plane. When the template is instantiated, the <code>GeometryTraits</code> parameter must be substituted with a type that defines a set of geometric-object types, such as point and curve, and a set of operations on objects of these types (see Section <a class="el" href="index.html#aos_sec-geom_traits">The Geometry Traits</a>); the <code>Dcel</code> parameter must be substituted with a type that represents a doubly-connected edge list (DCEL) data structure. It defines types of topological objects, such as vertices, edges, and faces, and the operations required to maintain the incidence relations among objects of these types (see Section <a class="el" href="index.html#aos_ssec-basic-dcel">Representation of Arrangements: The Dcel</a>).</p>
<p>The class template <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> derives from the following class template:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> GeometryTraits, <span class="keyword">typename</span> TopologyTraits&gt;</div><div class="line"><span class="keyword">class </span>Arrangement_on_surface_2 { ... };</div></div><!-- fragment --><p>An instance of this template represents a two-dimensional arrangement embedded in a surface in three dimensional space. When the template is instantiated, the <code>GeometryTraits</code> parameter must be substituted as described above; the <code>TopologyTraits</code> parameter must be substituted with a type that deals with the topology of the surface (see Section <a class="el" href="index.html#aos_sec-topol_traits">The Topology Traits</a>). In particular, it maintains a representation of the arrangement graph embedded in the surface using a doubly-connected edge list (DCEL) data-structure suitable for the particular topology.</p>
<p>Several member functions and nested types defined in the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> derived class-template inherit their definitions from the base class-template <code><a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html">Arrangement_on_surface_2</a></code>; their semantics is equivalent in both class templates. The names of these member functions and nested types typically appear in the manual without any scope, as each of these class templates can serve as their scope. (As a matter of fact, the package provides additional class templates that represent two-dimensional arrangements, such as the <code><a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a></code> class template, which derives from the class template <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code>; these additional class templates also contain inherited definitions of the aforementioned member functions and nested types.)</p>
<p>An immediate advantage of the separation of the topology and the geometry of data structures is that users with limited expertise in computational geometry can employ the data structure with their own special type of objects. They must, however, supply the relevant traits class, which mainly involves algebraic computations. A traits class also encapsulates the number types used to represent coordinates of geometric objects and to carry out algebraic operations on them. It encapsulates the type of coordinate system used (e.g., <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">Cartesian</a> and <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Homogeneous.html">Homogeneous</a>), and the geometric or algebraic computation methods themselves. The precise minimal sets of requirements the actual traits classes must conform to are organized as a hierarchy of concepts; see Section <a class="el" href="index.html#aos_sec-geom_traits">The Geometry Traits</a>.</p>
<h2><a class="anchor" id="aos_ssec-intro-well_behaved"></a>
Well-Behaved Curves</h2>
<p>What constitutes valid curves that can be handled by the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgArrangementOnSurface2">2D Arrangements</a> package is discussed in detail in Section <a class="el" href="index.html#aos_sec-geom_traits">The Geometry Traits</a>, where the models of the traits classes are described. However, when we cite combinatorial complexity bounds or bounds on the resources (i.e., running time and storage space) required by algorithms, we often postulate stricter assumptions on the input curves. The prevalent term in use is that the curves are <em>well behaved</em>, which may have different interpretations in different settings. If we are concerned with combinatorial complexity bounds for curves embedded in a two-dimensional surface, then the standard assumptions are that (i) each curve is non-self-intersecting (a so-called Jordan arc) and (ii) every pair of curves intersects in at most some constant number of points. For algorithmic purposes we need to require more since we assume that any operation on a small constant number of curves takes unit time. In this sense arcs of algebraic curves of degree bounded by a constant (namely the zero set of bivariate polynomials of constant maximum total degree) are well behaved. Naturally, what are typically considered well-behaved surfaces in \(\mathbb{R}^3\) is even more complicated to state.</p>
<p>Remarks </p><ol>
<li>
<p class="startli">From the complexity-bound perspective, most of the arrangements that we can deal with can be regarded as defined by well-behaved curves. Even though the package allows for self-intersecting curves, for most types each curve can be decomposed into a constant number of well-behaved curves, thus having no effect on the asymptotic bounds that we state. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">One type of curves that we deal with is special in this sense: <em>polylines</em>, namely concatenations of an unlimited number of line segments; see Section <a class="el" href="index.html#arr_sssectr_polylines">The Polyline Traits Class</a>. A polyline is not well behaved, as it cannot be decomposed into a constant number of constant-descriptive complexity subcurves. Informative bounds for arrangements of polylines are expressed by other parameters in addition to the number of polylines, for example, the total number of segments in all the polylines together. The same holds for the more general type <em>polycurve</em>, which are piecewise curves that are not necessarily linear; see Section <a class="el" href="index.html#arr_sssectr_polycurves">The Polycurve Traits Class</a>. </p>
<p class="endli"></p>
</li>
</ol>
<h2><a class="anchor" id="aos_ssec-intro-outline"></a>
Outline</h2>
<p>In Section <a class="el" href="index.html#aos_sec-basic">Basic Arrangements</a> we provide the minimum material you need to know in order to use CGAL 2D arrangements in the plane. In Section <a class="el" href="index.html#aos_sec-curved_surfaces">Arrangements on Curved Surfaces</a> we provide additional material you need to know in order use CGAL 2D arrangements embedded in curved surfaces. Most of the succeeding material is oblivious to the type of the embedding surface. In Section <a class="el" href="index.html#arr_secqueries">Issuing Queries on an Arrangement</a> we show how queries on an arrangement can be issued. In Section <a class="el" href="index.html#arr_secgl_funcs">Free Functions</a> we review some useful free (global) functions that operate on arrangements, the most important ones being the free insertion-functions. In Section <a class="el" href="index.html#aos_sec-unbounded">Arrangements of Unbounded Curves</a> we explain how to construct and manipulate arrangements of unbounded curves. Section <a class="el" href="index.html#aos_sec-geom_traits">The Geometry Traits</a> contains detailed descriptions of the geometric traits concept hierarchy and the various geometric traits classes included in the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgArrangementOnSurface2">2D Arrangements</a> package. The different traits classes enables the construction and manipulation of arrangements of different families of curves. Naturally, here, the embedding surface plays a significant role. In Section <a class="el" href="index.html#arr_ssecnotif">The Notification Mechanism</a> we review the notification mechanism that allows external classes to keep track of the changes that an arrangement instance goes through. Section <a class="el" href="index.html#arr_ssecex_dcel">Extending the DCEL</a> explains how to extend the DCEL records, to store extra data with them, and to efficiently update this data. In Section <a class="el" href="index.html#arr_ssecoverlay">Overlaying Arrangements</a> we introduce the fundamental operation of overlaying two arrangements. Section <a class="el" href="index.html#arr_ssecarr_with_hist">Storing the Curve History</a> describes a class-template that extends the arrangement by storing additional history records with its curves. In Section <a class="el" href="index.html#aos_sec-io">Input/Output Streams</a> we review the arrangement input/output functions. In Section <a class="el" href="index.html#aos_sec-bgl">Adapting to Boost Graphs</a> we describes how to apply the graph algorithms implemented in the Boost Graph Library to arrangement types. Finally, in Section <a class="el" href="index.html#aos_sec-tips">How To Speed Up Your Computation</a> we provide some tips that can be applied to expedite computation.</p>
<h1><a class="anchor" id="aos_sec-basic"></a>
Basic Arrangements</h1>
<p>We start with a formal definition of two-dimensional arrangements, and proceed with an introduction to the data structure used to represent the incidence relations among features of two-dimensional arrangements, namely, the <em>doubly-connected edge list</em>, or DCEL for short. In Section <a class="el" href="index.html#aos_ssec-basic-arr_class">The Arrangement Class Template</a> we describe a central component in the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgArrangementOnSurface2">2D Arrangements</a> package, namely, the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> class-template, which can be used to represent arrangements in the plane.</p>
<h2><a class="anchor" id="aos_ssec-basic-dcel"></a>
Representation of Arrangements: The Dcel</h2>
<p>Given a set \(\mathcal{C}\) of curves embedded in a two-dimensional surface, the <em>arrangement</em> \(\mathcal{A}(\mathcal{C})\) is the subdivision of the surface into zero-dimensional, one-dimensional and two-dimensional cells,<span class="footnote">We use the term <em>cell</em> to describe the various dimensional entities in the induced subdivision. Sometimes, the term <em>face</em> is used for this purpose in the literature. However, we use the term <em>face</em> to describe a <em>two-dimensional</em> cell.</span> called <em>vertices</em>, <em>edges</em> and <em>faces</em>, respectively, induced by the curves in \(\mathcal{C}\).</p>
<p>In our implementation we use a definition that slightly deviates from the standard definition above for practical reasons. The curves in \(\mathcal{C}\) can intersect each other (a single curve may also be self-intersecting or may comprise several disconnected branches) and are not necessarily \(x\)-monotone.<span class="footnote">A continuous planar curve \(c\) is <em> \(x\)-monotone</em> if every vertical line intersects it at most once. For example, a non-vertical line segment is always \(x\)-monotone and so is the graph of any continuous function \(y = f(x)\). For convenience, we treat vertical line segments as <em>weakly \(x\)-monotone</em>, as there exists a single vertical line that overlaps them. A circle of radius \(r\) centered at \((x_0, y_0)\) is not \(x\)-monotone, as the vertical line \(x = x_0\) intersects it at \((x_0, y_0 - r)\) and at \((x_0, y_0 + r)\).</span> We construct a collection \(\mathcal{C}''\) of \(x\)-monotone subcurves that are pairwise disjoint in their interiors in two steps as follows. First, we decompose each curve in \(\mathcal{C}\) into maximal \(x\)-monotone subcurves and possibly isolated points, obtaining the collection \(\mathcal{C}'\). Note that an \(x\)-monotone curve cannot be self-intersecting. Then, we decompose each curve in \(\mathcal{C}'\) into maximal connected subcurves not intersecting any other curve (or point) in \(\mathcal{C}'\) in its interior. The collection \(\mathcal{C}''\) contains isolated points, if the collection \(\mathcal{C}'\) contains such points. The arrangement induced by the collection \(\mathcal{C}''\) can be conveniently embedded as a planar graph, the vertices of which are associated with curve endpoints or with isolated points, and the edges of which are associated with subcurves. It is easy to see that the faces of \(\mathcal{A}(\mathcal{C})\) are the same as the faces of \(\mathcal{A}(\mathcal{C}'')\). There are possibly more vertices in \(\mathcal{A}(\mathcal{C}'')\) than in \(\mathcal{A}(\mathcal{C})\)—the vertices where curves were cut into \(x\)-monotone (non-intersecting) pieces; accordingly there may also be more edges in \(\mathcal{A}(\mathcal{C}'')\). This graph can be represented using a <em>doubly-connected edge list</em> data-structure (DCEL), which consists of containers of vertices, edges and faces and maintains the incidence relations among these cells. It is one of a family of combinatorial data structures called <em>halfedge data structures</em> (<span class="textsc">Hds</span>), which are edge-centered data structures capable of maintaining incidence relations among cells of, for example, planar subdivisions, polyhedra, or other orientable, two-dimensional surfaces embedded in a space of arbitrary dimension. Geometric interpretation is added by classes built on top of the halfedge data structure.</p>
<p> </p><div class="CGALAdvanced"> <div>Advanced</div> 
<p>The \(x\)-monotone curves of an arrangement are embedded in a rectangular two-dimensional area called the parameter space. The parameter space is defined as \( X \times Y\), where \( X\) and \( Y\) are open, half-open, or closed intervals with endpoints in the compactified real line \( \mathbb{R} \cup \{-\infty,+\infty\}\). Let \(x_{\rm min}\), \(x_{\rm max}\), \(y_{\rm min}\), and \(y_{\rm max}\) denote the endpoints of \( X\) and \( Y\), respectively. We typically refer to these values as the left, right, bottom, and top sides of the boundary of the parameter space. If the parameter space is, for example, the entire compactified plane, as in the case of arrangements in the plane, \(x_{\rm min} = y_{\rm min} = -\infty\) and \(x_{\rm max} = y_{\rm max} = +\infty\); see Section <a class="el" href="index.html#aos_sec-curved_surfaces">Arrangements on Curved Surfaces</a> for more details.</p>
<p> </p></div> 
<p>The DCEL data-structure represents each edge using a pair of directed <em>halfedges</em>, one going from the \(xy\)-lexicographically smaller (left) endpoint of the curve towards the \(xy\)-lexicographically larger (right) endpoint, and the other, known as its <em>twin</em> halfedge, going in the opposite direction. As each halfedge is directed, it has a <em>source</em> vertex and a <em>target</em> vertex. Halfedges are used to separate faces, and to connect vertices, with the exception of <em>isolated vertices</em> (representing isolated points), which are disconnected. If a vertex \(v\) is the target of a halfedge \(e\), we say that \(v\) and \(e\) are <em>incident</em> to each other. The halfedges incident to a vertex \(v\) form a circular list sorted in a clockwise order around this vertex. (An isolated vertex has no incident halfedges.)</p>
<p>An <em>edge</em> of an arrangement is a maximal portion of a curve between two vertices of the arrangement. Each edge is represented in the DCEL by a pair of twin halfedges. Each halfedge \(e\) stores a pointer to its <em>incident face</em>, which is the face lying to its left. Moreover, every halfedge is followed by another halfedge sharing the same incident face, such that the target vertex of the halfedge is the same as the source vertex of the next halfedge. The halfedges around faces form circular chains, such that all halfedges of a chain are incident to the same face and wind along its boundary. We call such a chain a <em>connected component of the boundary</em>, or <em>CCB</em> for short.</p>
<p>The unique CCB of halfedges winding in a counterclockwise orientation along a face boundary is referred to as the <em>outer CCB</em> of the face. For the time being let us consider only (i) arrangements of bounded curves, such that exactly one unbounded face exists in every arrangement, and (ii) arrangements embedded in the plane, such that every face has at most one outer CCB. The unbounded face does not have an outer boundary. Any other connected component of the boundary of the face is called a <em>hole</em>, or <em>inner CCB</em>, and can be represented as a circular chain of halfedges winding in a clockwise orientation around it. Note that a hole does not necessarily correspond to a face at all, as it may have no area, or alternatively it may contain several faces. Every face can have several inner CCBs in its interior, or may not contain inner CCBs at all. In addition, every face may contain isolated vertices in its interior. We distinguish between isolated vertices and holes even though, theoretically, the former are degenerate holes. See <a class="el" href="index.html#fig__aos_fig-arr_segs">Figure 34.2</a> for an illustration of the various DCEL features. For more details on the DCEL data structure see <a class="el" href="citelist.html#CITEREF_bkos-cgaa-00">[5]</a> Chapter 2.</p>
<p><a class="anchor" id="fig__aos_fig-arr_segs"></a></p><div class="image">
<img src="arr_segs.png" alt="arr_segs.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-arr_segs">Figure 34.2</a> An arrangement of interior-disjoint line segments with some of the DCEL records that represent it. The unbounded face \( f_0\) has a single connected component that forms a hole inside it, and this hole comprises of several faces. The halfedge \( e\) is directed from its source vertex \( v_1\) to its target vertex \( v_2\). This edge, together with its twin \( e'\), correspond to a line segment that connects the points associated with \( v_1\) and \( v_2\) and separates the face \( f_1\) from \( f_2\). The predecessor \( e_{\rm prev}\) and successor \( e_{\rm next}\) of \( e\) are part of the chain that form the outer boundary of the face \( f_2\). The face \( f_1\) has a more complicated structure as it contains two holes in its interior: One hole consists of two adjacent faces \( f_3\) and \( f_4\), while the other hole comprises of two edges. \( f_1\) also contains two isolated vertices \( u_1\) and \( u_2\) in its interior.  </div> <br /> 
<h2><a class="anchor" id="aos_ssec-basic-arr_class"></a>
The Arrangement Class Template</h2>
<p>One of the main components of the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgArrangementOnSurface2">2D Arrangements</a> package is the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt;Traits,Dcel&gt;</code> class template. An instance of this template is used to represent an arrangement embedded in the plane. The class template provides the interface needed to construct such arrangements, traverse them, and maintain them.</p>
<p>The design of the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgArrangementOnSurface2">2D Arrangements</a> package is guided by two aspects of modularity as follows: </p><ul>
<li>
the separation of the representation of the arrangements and the various geometric algorithms that operate on them, and </li>
<li>
the separation of the topological and geometric aspects of the two-dimensional subdivision. </li>
</ul>
<p>The latter separation is exhibited by the two template parameters of the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> class template; their description follows.</p>
<ul>
<li>
<p class="startli">The <code>Traits</code> template-parameter should be instantiated with a model of the <code><a class="el" href="classArrangementBasicTraits__2.html" title="The concept ArrangementBasicTraits_2 defines the minimal set of geometric predicates needed for the c...">ArrangementBasicTraits_2</a></code> concept and optionally additional geometry traits concepts. A model of the <code><a class="el" href="classArrangementBasicTraits__2.html" title="The concept ArrangementBasicTraits_2 defines the minimal set of geometric predicates needed for the c...">ArrangementBasicTraits_2</a></code> concept defines the types of \(x\)-monotone curves and two-dimensional points, namely <code><a class="el" href="classArrangementBasicTraits__2.html#a0fc1f7acfd69a5eae393294b6870a1d2" title="models the concept ArrTraits::XMonotoneCurve_2. ">ArrangementBasicTraits_2::X_monotone_curve_2</a></code> and <code><a class="el" href="classArrangementBasicTraits__2.html#a8cfc873dc62ce86f9479c4689845d4b3" title="models the concept ArrTraits::Point_2. ">ArrangementBasicTraits_2::Point_2</a></code>, respectively, and supports basic geometric predicates on them. The instantiated traits class determines the family of planar curves that induce the arrangement.</p>
<p>In this section we always use <code><a class="el" href="classCGAL_1_1Arr__non__caching__segment__traits__2.html" title="The traits class Arr_non_caching_segment_traits_2 is a model of the ArrangementTraits_2 concept that ...">Arr_non_caching_segment_traits_2</a></code> as our traits-class model in order to construct arrangements of line segments. In succeeding sections we also use <code><a class="el" href="classCGAL_1_1Arr__segment__traits__2.html" title="The traits class Arr_segment_traits_2 is a model of the ArrangementTraits_2 concept, which allows the construction and maintenance of arrangements of line segments. ">Arr_segment_traits_2</a></code> as our traits-class model. These two traits trade computation time and storage space. The latter stores the underlying line of every segment of the arrangement to expedite certain operations on the arrangement segments. In Section <a class="el" href="index.html#aos_sec-unbounded">Arrangements of Unbounded Curves</a> we use <code><a class="el" href="classCGAL_1_1Arr__linear__traits__2.html" title="The traits class Arr_linear_traits_2 is a model of the ArrangementTraits_2 concept, which enables the construction and maintenance of arrangements of linear objects. ">Arr_linear_traits_2</a></code> to construct arrangements of linear curves (i.e., lines, rays, and line segments). The <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgArrangementOnSurface2">2D Arrangements</a> package contains several other traits classes that can handle other types of curves, such as polylines (continuous piecewise-linear curves), conic arcs, and arcs of rational functions. We exemplify the usage of these traits classes in Section <a class="el" href="index.html#aos_sec-geom_traits">The Geometry Traits</a>.</p>
<p class="endli"></p>
</li>
<li>
The <code>Dcel</code> template-parameter should be instantiated with a class that models the <code><a class="el" href="classArrangementDcel.html" title="A doubly-connected edge-list (DCEL for short) data-structure. It consists of three containers of reco...">ArrangementDcel</a></code> concept, which is used to represent the topological layout of the arrangement. This parameter is substituted with <code><a class="el" href="classCGAL_1_1Arr__default__dcel.html" title="The default DCEL class used by the Arrangement_2 class-template is parameterized by a traits class...">Arr_default_dcel</a>&lt;Traits&gt;</code> by default, and we use this default value in this and in the following three sections. However, in many applications it is necessary to extend the DCEL features. This is done by substituting the <code>Dcel</code> parameter with a different type; see Section <a class="el" href="index.html#arr_ssecex_dcel">Extending the DCEL</a> for further explanations and examples. </li>
</ul>
<p>The function template <code>print_arrangement_size()</code> listed below, and defined in the header file <code>Arr_print.h</code>, prints out quantitative measures of a given arrangement. While in what follows it is used only by examples, it demonstrates well the use of the member functions <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a07afeb623d32ef12745c9b368233e4ea"><code>number_of_vertices()</code></a>, <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#ab8c9db7c49f1d4860cd47094a08a6779"><code>number_of_edges()</code></a>, and <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#ac8de48159182ed1dc27d508171c3adb7"><code>number_of_faces()</code></a>, which return the number of vertices, edges, and faces of an arrangement, respectively.</p>
<p><a class="anchor" id="lst_paz"></a></p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Arrangement&gt;</div><div class="line"><span class="keywordtype">void</span> print_arrangement_size(<span class="keyword">const</span> Arrangement&amp; arr) {</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The arrangement size:\n"</span></div><div class="line">            &lt;&lt; <span class="stringliteral">"   |V| = "</span> &lt;&lt; arr.number_of_vertices()</div><div class="line">            &lt;&lt; <span class="stringliteral">",  |E| = "</span> &lt;&lt; arr.number_of_edges()</div><div class="line">            &lt;&lt; <span class="stringliteral">",  |F| = "</span> &lt;&lt; arr.number_of_faces() &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>You can also obtain the number of halfedges of an arrangement using the member function <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#ae4e63cf2763246726d5b705a45d2848f"><code>number_of_halfedges()</code></a>. Recall that the number of halfedges is always twice the number of edges.</p>
<div class="image">
<img src="triangle.png" alt="triangle.png" />
</div>
 <p>The simple program listed below constructs an arrangement of three connected line segments forming a triangle. It uses the <em><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">Cartesian</a></em> kernel with an integral-number type to instantiate the <code><a class="el" href="classCGAL_1_1Arr__non__caching__segment__traits__2.html" title="The traits class Arr_non_caching_segment_traits_2 is a model of the ArrangementTraits_2 concept that ...">Arr_non_caching_segment_traits_2</a>&lt;<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>&gt;</code> class template. The resulting arrangement consists of two faces, a bounded triangular face and the unbounded face. Constructing and maintaining arrangements using limited-precision numbers, such as <code>int</code>, works properly only under severe restrictions, which in many cases render the program not very useful. In this example, however, the points are far apart, and constructions of new geometric objects do not occur. Thus, it is safe to use <code>int</code> after all. The program constructs an arrangement induced by three line segments that are pairwise disjoint in their interior, prints out the number of faces, and ends. It uses the <a class="el" href="group__PkgArrangementOnSurface2Insert.html#ga25a2ae72727ec4c0680d20477bab7a1c"><code>insert()</code></a> free-function, which inserts the segments into the arrangement; see Section <a class="el" href="index.html#arr_secgl_funcs">Free Functions</a>. It uses the member function <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#ac8de48159182ed1dc27d508171c3adb7"><code>number_of_faces()</code></a> to obtain the number of faces (two in this case). We give more elaborate examples in the rest of this chapter. The programs in those examples rely on computing with numbers of arbitrary precision, which guarantees robust execution and correct results.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_non_caching_segment_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">int</span>                                             Number_type;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;Number_type&gt;</a>                    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__non__caching__segment__traits__2.html">CGAL::Arr_non_caching_segment_traits_2&lt;Kernel&gt;</a>  Traits;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Point_2                               Point;</div><div class="line"><span class="keyword">typedef</span> Traits_2::X_monotone_curve_2                    Segment;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2&gt;</a>                   Arrangement;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  Arrangement arr;</div><div class="line">  Point p1(1, 1), p2(1, 2), p3(2, 1);</div><div class="line">  Segment cv[] = {Segment(p1, p2), Segment(p2, p3), Segment(p3, p1)};</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">CGAL::insert</a>(arr, &amp;cv[0], &amp;cv[<span class="keyword">sizeof</span>(cv)/<span class="keyword">sizeof</span>(Segment)]);</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="arr_ssectraverse"></a>
Traversing the Arrangement</h2>
<p>The simplest and most fundamental arrangement operations are the various traversal methods, which allow users to systematically go over the relevant features of the arrangement at hand.</p>
<p>As mentioned above, the arrangement is represented as a DCEL, which stores three containers of vertices, halfedges and faces; thus, the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> class template supplies iterator types for these containers, respectively. For example, if <code>arr</code> is an <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> object, the calls <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#aa042e6d15902031a2df0f5c567deb48d"><code>arr.vertices_begin()</code></a> and <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a13b01c9fe13b28f40311bcf5df5f2372"><code>arr.vertices_end()</code></a> return iterators of the nested <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#ac9e0d41a482a1ce382983871b8e7168d"><code>Vertex_iterator</code></a> type that define the valid range of vertices of the arrangement <code>arr</code>. The value type of this iterator is <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex.html"><code>Vertex</code></a>. Moreover, the vertex-iterator type is convertible to <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a43113edb82930474c25b57b9a8e2143f"><code>Vertex_handle</code></a>, which serves as a pointer to a vertex. As we show next, all functions related to arrangement features accept handle types as input parameters and return handle types as their output. See Chapter <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Circulator.tag:../Circulator/" href="../Circulator/index.html#Chapter_Handles_Ranges_and_Circulators">Handles and Circulators</a> for more information on CGAL handles.</p>
<p>In addition to the iterators for arrangement vertices, halfedges, and faces, the arrangement class also provides an iterator for edges, namely <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a90b95a65ca2ac31782a88f5ee8e83eba"><code>Edge_iterator</code></a>. The value type of this iterator is <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge.html"><code>Halfedge</code></a>, which is the same as the value type of <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#ae8c1944479e0e4cf89522c7dffacd12c"><code>Halfedge_iterator</code></a>. The calls <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a3ecce52c3dbd2d8ffd5910e5c6d2eaa2"><code>arr.edges_begin()</code></a> and <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#ab4e303e84da92938e0993f8fba5166d5"><code>arr.edges_end()</code></a> return iterators that define the valid range of arrangement edges. This range consists of half the number of halfedges of the arrangement, as every twin halfedges has one representative in this range.</p>
<p>All iterator, circulator<span class="footnote">A <em>circulator</em> is used to traverse a circular list, such as the list of halfedges incident to a vertex.</span> and handle types also have non-mutable (<em>const</em>) counterparts. These non-mutable iterator types are useful for traversing an arrangement with the promise to keep it unchanged. For example, the arrangement has a non-constant member function called <code><a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#aa042e6d15902031a2df0f5c567deb48d" title="obtains the begin-iterator of the vertices in the arrangement. ">Arrangement_on_surface_2::vertices_begin()</a></code> that returns a <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#ac9e0d41a482a1ce382983871b8e7168d"><code>Vertex_iterator</code></a> object and another const member function that returns a <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a6e3184096bbb26b96941800251966713"><code>Vertex_const_iterator</code></a> object. In fact, all methods listed in this section that return an iterator, a circulator, or a handle have non-mutable counterparts. It should be noted that, for example, <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a43113edb82930474c25b57b9a8e2143f"><code>Vertex_handle</code></a> can be readily converted into a <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a47fac787fb37cd812814fbb9b6ab9acc"><code>Vertex_const_handle</code></a>, but not the other way around.</p>
<p>Conversions of non-mutable handles to the corresponding mutable handles are nevertheless possible. They can be performed using the overloaded member function <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#ab3ce8cfa533c872fee6496a100121bb4"><code>non_const_handle()</code></a>. There are three variants that accept a non-mutable handle to a vertex, a halfedge, or a face, respectively. The call <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#ab3ce8cfa533c872fee6496a100121bb4"><code>non_const_handle()</code></a> can be issued only if the arrangement object <code>arr</code> is mutable; see, e.g., Section <a class="el" href="index.html#arr_ssecpl">Point-Location Queries</a>.</p>
<h3><a class="anchor" id="arr_sssectr_vertex"></a>
Traversal Methods for an Arrangement Vertex</h3>
<p>A vertex \(v\) of an arrangement induced by bounded curves is always associated with a geometric entity, namely with an <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#aed833c3b69b94eae54994439d70a83a2"><code>Point_2</code></a> object, which can be obtained by <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex.html#a7e2332bc3b949a0f16df7f8e8a22d4fe"><code>v-&gt;point()</code></a>, where <code>v</code> identifies a handle to \(v\).</p>
<p>The call <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex.html#ac7bd85bf195ed9e15b62ef591cd005a9"><code>v-&gt;is_isolated()</code></a> determines whether the vertex \(v\) is isolated or not. Recall that the halfedges incident to a non-isolated vertex, namely, the halfedges that share a common target vertex, form a circular list around this vertex. The call <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex.html#ae8ee4823ad2d0e7a345f61c5778bc8a6"><code>v-&gt;incident_halfedges()</code></a> returns a circulator of the nested type <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a3418d290f692e88e110d4bb12b2c59d9"><code>Halfedge_around_vertex_circulator</code></a> that enables the traversal of this circular list around a given vertex \(v\) in a clockwise order. The value type of this circulator is <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge.html"><code>Halfedge</code></a>. By convention, the target of the halfedge is \(v\). The call <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex.html#ac9e62a9b86fd210c1823e4efe243a50a"><code>v-&gt;degree()</code></a> evaluates to the number of the halfedges incident to \(v\).</p>
<p>The function below prints all the halfedges incident to a given arrangement vertex (assuming that objects of the <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#aed833c3b69b94eae54994439d70a83a2"><code>Point_2</code></a> type can be inserted into the standard output using the <code>&lt;&lt;</code> operator). The arrangement type is the same as in the simple example above.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Arrangement&gt;</div><div class="line"><span class="keywordtype">void</span> print_incident_halfedges(<span class="keyword">typename</span> Arrangement::Vertex_const_handle v) {</div><div class="line">  <span class="keywordflow">if</span> (v-&gt;is_isolated()) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"The vertex ("</span> &lt;&lt; v-&gt;point() &lt;&lt; <span class="stringliteral">") is isolated\n"</span>;</div><div class="line">    <span class="keywordflow">return</span>;</div><div class="line">  }</div><div class="line">  <span class="keyword">typename</span> Arrangement::Halfedge_around_vertex_const_circulator first, curr;</div><div class="line">  first = curr = v-&gt;incident_halfedges();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The neighbors of the vertex ("</span> &lt;&lt; v-&gt;point() &lt;&lt; <span class="stringliteral">") are:"</span>;</div><div class="line">  <span class="keywordflow">do</span> std::cout &lt;&lt; <span class="stringliteral">" ("</span> &lt;&lt; curr-&gt;source()-&gt;point() &lt;&lt; <span class="stringliteral">")"</span>;</div><div class="line">  <span class="keywordflow">while</span> (++curr != first);</div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>If \(v\) is an isolated vertex, the call <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex.html#ae090e4bb8f2f31c020e21d94816e7335"><code>v-&gt;face()</code></a> can be used to obtain the face that contains \(v\).</p>
<h3><a class="anchor" id="arr_sssectr_halfedge"></a>
Traversal Methods for an Arrangement Halfedge</h3>
<p>A halfedge \(e\) of an arrangement induced by bounded curves is associated with an <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#ad7f12c4c83fa1d83a3f0d5ceb16c21e1"><code>X_monotone_curve_2</code></a> object, which can be obtained by <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge.html#a930f8580615f21d9904a7fe200a71ef4"><code>e-&gt;curve()</code></a>, where <code>e</code> identifies a handle to \(e\).</p>
<p>The calls <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge.html#a200611c4a0eadf06eb2543149e0ab61e"><code>e-&gt;source()</code></a> and <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge.html#a837ae4ea98dfde0332d6787c7543cf6c"><code>e-&gt;target()</code></a> return handles to the halfedge's source-vertex and target-vertex, respectively. You can obtain a handle to the twin halfedge using <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge.html#aead87f8c5f95770ed7cb2a6b9a43e23e"><code>e-&gt;twin()</code></a>. Note that from the definition of halfedges in the <code>Dcel</code> structure, the following invariants always hold: </p><ul>
<li>
<a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge.html#a930f8580615f21d9904a7fe200a71ef4"><code>e-&gt;curve()</code></a> is equivalent to <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge.html#a930f8580615f21d9904a7fe200a71ef4"><code>e-&gt;twin()-&gt;curve()</code></a>, </li>
<li>
<a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge.html#a200611c4a0eadf06eb2543149e0ab61e"><code>e-&gt;source()</code></a> is equivalent to <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge.html#a837ae4ea98dfde0332d6787c7543cf6c"><code>e-&gt;twin()-&gt;target()</code></a>, and </li>
<li>
<a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge.html#a837ae4ea98dfde0332d6787c7543cf6c"><code>e-&gt;target()</code></a> is equivalent to <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge.html#a200611c4a0eadf06eb2543149e0ab61e"><code>e-&gt;twin()-&gt;source()</code></a>. </li>
</ul>
<p>Every halfedge has an incident face that lies to its left, which can be obtained by <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge.html#a4af38ef2e7af77b265a86c8ea42972ef"><code>e-&gt;face()</code></a>. Recall that a halfedge is always one link in a connected chain (CCB) of halfedges that share the same incident face. The <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge.html#a42adbd7d0eb22a3e1f7086b163e48fbb"><code>e-&gt;prev()</code></a> and <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge.html#a14440bbd90d03a436279047a82e672cf"><code>e-&gt;next()</code></a> calls return handles to the previous and next halfedges in the CCB, respectively.</p>
<p>As the CCB is a circular list of halfedges, it is only natural to traverse it using a circulator. Indeed <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge.html#a3cb46f49294d3d35c22cdf12e4bd8afc"><code>e-&gt;ccb()</code></a> returns an <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a74c5102548a855c11d1606af503db209"><code>Ccb_halfedge_circulator</code></a> object for traversing all halfedges along the connected component of \(e\). The value type of this circulator is <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge.html"><code>Halfedge</code></a>.</p>
<p>The function template <code>print_ccb()</code> listed below prints all \(x\)-monotone curves along a given CCB (assuming that objects of the <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#aed833c3b69b94eae54994439d70a83a2"><code>Point_2</code></a> and the <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#ad7f12c4c83fa1d83a3f0d5ceb16c21e1"><code>X_monotone_curve_2</code></a> types can be inserted into the standard output using the <code>&lt;&lt;</code> operator).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Arrangement&gt;</div><div class="line"><span class="keywordtype">void</span> print_ccb(<span class="keyword">typename</span> Arrangement::Ccb_halfedge_const_circulator circ) {</div><div class="line">  Ccb_halfedge_const_circulator curr = circ;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"("</span> &lt;&lt; curr-&gt;source()-&gt;point() &lt;&lt; <span class="stringliteral">")"</span>;</div><div class="line">  <span class="keywordflow">do</span> {</div><div class="line">    <span class="keyword">typename</span> Arrangement::Halfedge_const_handle he = curr-&gt;handle();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">" ["</span> &lt;&lt; e-&gt;curve() &lt;&lt; <span class="stringliteral">"] "</span></div><div class="line">              &lt;&lt; <span class="stringliteral">"("</span> &lt;&lt; e-&gt;target()-&gt;point() &lt;&lt; <span class="stringliteral">")"</span>;</div><div class="line">  } <span class="keywordflow">while</span> (++curr != circ);</div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="arr_sssectr_face"></a>
Traversal Methods for an Arrangement Face</h3>
<p>An <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> object <code>arr</code> that identifies an arrangement of bounded curves always has a single unbounded face. The call <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a82638900556c9b8b39d5c207b1a456da"><code>arr.unbounded_face()</code></a> returns a handle to this face. Note that an empty arrangement contains nothing <em>but</em> the unbounded face.</p>
<p>Given a handle to a face \(f\), you can use the call <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Face.html#aa7cc822cc2a86b313532811d9df6dbb4"><code>f-&gt;is_unbounded()</code></a> to determine whether the face \(f\) is unbounded. Bounded faces have an outer CCB, and the <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Face.html#a2fffc48e24aaa154122504983d771f1c"><code>outer_ccb()</code></a> method returns a circulator for the halfedges along this CCB. Note that the halfedges along this CCB wind in a counterclockwise order around the outer boundary of the face.</p>
<p>A face can also contain disconnected components in its interior, namely, holes and isolated vertices. You can access these components as follows:</p>
<ul>
<li>
<p class="startli">You can obtain a pair of iterators of type <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Face.html#a53de656d3ec315b4cf60f385a7667b55"><code>Hole_iterator</code></a> that define the range of holes inside a face \(f\) by calling <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Face.html#acd9525cd21bf2cd7404fddefe4ade7fb"><code>f-&gt;holes_begin()</code></a> and <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Face.html#a64b500ed6fcd24544bc13dbde161b63a"><code>f-&gt;holes_end()</code></a>. The value type of this iterator type is <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a74c5102548a855c11d1606af503db209"><code>Ccb_halfedge_circulator</code></a>, defining the CCB that winds in a clockwise order around a hole. The call <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Face.html#ad926144c5444b2082eda4da7a5142ad2"><code>f-&gt;number_of_holes()</code></a> return the number of holes in \(f\).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The calls <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Face.html#a4471b967010989047b87beff6f3b7ce9"><code>f-&gt;isolated_vertices_begin()</code></a> and <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Face.html#a961217cef87b4411eb8d82178ba00d83"><code>f-&gt;isolated_vertices_end()</code></a> return iterators of type <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a4b8bee4d94c47a284f3f5e14b1327315"><code>Isolated_vertex_iterator</code></a> that define the range of isolated vertices inside the face \(f\). The value type of this iterator is <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex.html"><code>Vertex</code></a>.</p>
<p class="endli"></p>
</li>
</ul>
<p>The function <code>print_face()</code> listed below prints the outer and inner boundaries of a given face. It uses the function template <code>print_ccb()</code> listed above.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Arrangement&gt;</div><div class="line"><span class="keywordtype">void</span> print_face(<span class="keyword">typename</span> Arrangement::Face_const_handle f) {</div><div class="line">  <span class="comment">// Print the outer boundary.</span></div><div class="line">  <span class="keywordflow">if</span> (f-&gt;is_unbounded()) std::cout &lt;&lt; <span class="stringliteral">"Unbounded face.\n"</span>;</div><div class="line">  <span class="keywordflow">else</span> {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Outer boundary: "</span>;</div><div class="line">    print_ccb(f-&gt;outer_ccb());</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Print the boundary of each of the holes.</span></div><div class="line">  <span class="keywordtype">size_t</span> index = 1;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> hi = f-&gt;holes_begin(); hi != f-&gt;holes_end(); ++hi) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">" Hole #"</span> &lt;&lt; index++ &lt;&lt; <span class="stringliteral">": "</span>;</div><div class="line">    print_ccb(*hi);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Print the isolated vertices.</span></div><div class="line">  index = 1;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> iv = f-&gt;isolated_vertices_begin();</div><div class="line">       iv != f-&gt;isolated_vertices_end(); ++iv)</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">" Isolated vertex #"</span> &lt;&lt; index++ &lt;&lt; <span class="stringliteral">": "</span></div><div class="line">              &lt;&lt; <span class="stringliteral">"("</span> &lt;&lt; iv-&gt;point() &lt;&lt; <span class="stringliteral">")\n"</span>;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>The function <code>print_arrangement()</code> listed below prints the features of a given arrangement. The file <code>arr_print.h</code>, which can be found under the examples folder, includes the definitions of this function, as well as the definitions of all other functions listed in this section. This concludes the preview of the various traversal methods.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> print_arrangement (<span class="keyword">const</span> Arrangement_2&amp; arr) {</div><div class="line">  <span class="comment">// Print the arrangement vertices.</span></div><div class="line">  std::cout &lt;&lt; arr.number_of_vertices() &lt;&lt; <span class="stringliteral">" vertices:\n"</span>;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> vit = arr.vertices_begin(); vit != arr.vertices_end(); ++vit) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"("</span> &lt;&lt; vit-&gt;point() &lt;&lt; <span class="stringliteral">")"</span>;</div><div class="line">    <span class="keywordflow">if</span> (vit-&gt;is_isolated()) std::cout &lt;&lt; <span class="stringliteral">" - Isolated.\n"</span>;</div><div class="line">    <span class="keywordflow">else</span> std::cout &lt;&lt; <span class="stringliteral">" - degree "</span> &lt;&lt; vit-&gt;degree() &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Print the arrangement edges.</span></div><div class="line">  std::cout &lt;&lt; arr.number_of_edges() &lt;&lt; <span class="stringliteral">" edges:\n"</span>;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> eit = arr.edges_begin(); eit != arr.edges_end(); ++eit)</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; eit-&gt;curve() &lt;&lt; <span class="stringliteral">"]\n"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Print the arrangement faces.</span></div><div class="line">  std::cout &lt;&lt; arr.number_of_faces() &lt;&lt; <span class="stringliteral">" faces:\n"</span>;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> fit = arr.faces_begin(); fit != arr.faces_end(); ++fit)</div><div class="line">    print_face(fit);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="arr_ssecmodify"></a>
Modifying the Arrangement</h2>
<p>In this section we review the various member functions of the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> class that allow users to modify the topological structure of the arrangement through the introduction of new edges or vertices, or the modification or removal of existing edges and vertices.</p>
<p>The arrangement member-functions that insert new \(x\)-monotone curves into the arrangement, thus enabling the construction of a two-dimensional surface subdivision, are rather specialized, as they assume that the interior of the inserted curve is disjoint from all existing arrangement vertices and edges, and in addition require apriori knowledge of the location of the inserted curve. Indeed, for most purposes it is more convenient to construct an arrangement using the free (global) insertion functions, which relax these restrictions. However, as these free functions are implemented in terms of the specialized insertion functions, we start by describing the fundamental functionality of the arrangement class, and describe the operation of the free functions in Section <a class="el" href="index.html#arr_secgl_funcs">Free Functions</a>.</p>
<h2><a class="anchor" id="arr_sssecmf_insert_cv"></a>
Inserting Pairwise Disjoint x-Monotone Curves</h2>
<p>The most trivial functions that allow users to modify the arrangement are the specialized functions for the insertion of an \(x\)-monotone curve the interior of which is disjoint from the interior of all other curves in the existing arrangement and does not contain any point of the arrangement. In addition, these functions require that the location of the curve in the arrangement be known.</p>
<p>The rather harsh restrictions on the inserted curves enable an efficient implementation. While inserting an \(x\)-monotone curve, the interior of which is disjoint from all curves in the existing arrangement, is quite straightforward, as we show next, (efficiently) inserting a curve that intersects with the curves already in the arrangement is much more complicated and requires the application of nontrivial geometric algorithms. The decoupling of the topological arrangement representation from the various algorithms that operate on it dictates that the general insertion operations be implemented as free functions that operate on the arrangement and the inserted curve(s); see Section <a class="el" href="index.html#arr_secgl_funcs">Free Functions</a> for more details and examples.</p>
<p><a class="anchor" id="fig__aos_fig-insert"></a></p><div class="image">
<img src="insert.png" alt="insert.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-insert">Figure 34.3</a> Illustrations of the various specialized insertion procedures. The inserted \(x\)-monotone curve is drawn as a dashed line, surrounded by two solid arrows that represent the pair of twin halfedges added to the DCEL. Existing vertices are shown as red discs, while new vertices are shown as blue discs. Existing halfedges that are affected by the insertion operations are drawn as dashed arrows. (a) Inserting a curve as a new hole inside the face \(f\). (b) Inserting a curve from an existing vertex \(u\) that corresponds to one of its endpoints. (c) Inserting an \(x\)-monotone curve, the endpoints of which correspond to existing vertices \(u_1\) and \(u_2\). In this case, the new pair of halfedges closes a new face \(f'\). The hole \(h_1\), which belonged to \(f\) before the insertion, becomes a hole in this new face.  </div> <br /> 
<p>When an \(x\)-monotone curve is inserted into an existing arrangement, such that the interior of this curve is disjoint from the interiors of all curves in the arrangement, only the following three scenarios are possible, depending on the status of the endpoints of the inserted curve:</p>
<ol>
<li>
<p class="startli">Neither curve endpoints correspond to any existing arrangement vertex. In this case we have to create two new vertices that correspond to the curve endpoints, respectively, and connect them using a pair of twin halfedges. This halfedge pair forms a new hole inside the face that contains the curve in its interior.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Exactly one endpoint corresponds to an existing arrangement vertex. (We distinguish between a vertex that corresponds to the left endpoint of the inserted curve and a vertex that corresponds to its right endpoint.) In this case we have to create a new vertex that corresponds to the other endpoint of the curve and to connect the two vertices by a pair of twin halfedges that form an "antenna" emanating from the boundary of an existing connected component. (Note that if the existing vertex is isolated, we need to form a new hole inside the face that contains this vertex, essentially falling back to the handling of the previous case, naturally, skipping the creation of the existing vertex.)</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Both endpoints correspond to existing arrangement vertices. In this case we connect these vertices using a pair of twin halfedges. (If one or both vertices are isolated, we fall back to the handling of the first or second case, respectively, naturally, skipping the creation of the existing vertices.) The two following subcases may occur:</p>
<ul>
<li>
<p class="startli">Two disconnected components are merged into a single connected component (as is the case with the segment \(s_1\) in the figure below).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">A new face, which is split from an existing arrangement face, is created (as is the case with the segment \(s_2\) in the figure below). In this case we also have to examine the holes and isolated vertices in the existing face and move the relevant ones inside the new face.</p>
<p class="endli"></p>
</li>
</ul>
</li>
</ol>
<div class="image">
<img src="connect_comp.png" alt="connect_comp.png" />
</div>
 <p>The <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> class offers insertion functions that perform the special insertion procedures listed above, namely, <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a622e04b98c5d0ac773c0a1b6da94b242"><code>insert_in_face_interior()</code></a>, <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a5afb084b94adba3fa294724bd07ccb36"><code>insert_from_left_vertex()</code></a>, <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a1f3b1ceca5219900301e4eefd9f80bd0"><code>insert_from_right_vertex()</code></a> and <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a7f2201fbb9015ddbbd22b7704e958e24"><code>insert_at_vertices()</code></a>. The first function accepts an \(x\)-monotone curve \(c\) and an arrangement face \(f\) that contains this curve in its interior. The other functions accept an \(x\)-monotone curve \(c\) and handles to the existing vertices that correspond to the curve endpoint(s). Each of the four functions returns a handle to one of the twin halfedges that have been created; more precisely:</p>
<ul>
<li>
<p class="startli"><a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a622e04b98c5d0ac773c0a1b6da94b242"><code>insert_in_face_interior(c, f)</code></a> returns a handle to the halfedge directed from the left endpoint of \(c\) towards the vertex corresponding to its right endpoint.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a5afb084b94adba3fa294724bd07ccb36"><code>insert_from_left_vertex(c, v)</code></a> and <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a1f3b1ceca5219900301e4eefd9f80bd0"><code>insert_from_right_vertex(c, v)</code></a> each returns a handle to the halfedge, the source of which is the vertex \(v\), and the target of which is the new vertex that has just been created.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a7f2201fbb9015ddbbd22b7704e958e24"><code>insert_at_vertices(c, v1, v2)</code></a> returns a handle to the halfedge directed from \(v_1\) to \(v_2\).</p>
<p class="endli"></p>
</li>
</ul>
<p><a class="anchor" id="fig__aos_fig-edge_insertion"></a></p><div class="image">
<img src="edge_insertion.png" alt="edge_insertion.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-edge_insertion">Figure 34.4</a> The arrangement of the line segments \(s_1, \ldots, s_5\) constructed in <a class="el" href="Arrangement_on_surface_2_2edge_insertion_8cpp-example.html">Arrangement_on_surface_2/edge_insertion.cpp</a>. The arrows mark the direction of the halfedges returned from the various insertion functions.  </div> <br /> 
<p>The program below demonstrates the usage of the four specialized insertion functions. It creates an arrangement of five line segments \(s_1, \ldots, s_5\), as depicted in <a class="el" href="index.html#fig__aos_fig-edge_insertion">Figure 34.4</a>. <span class="footnote">Notice that in all figures in the rest of this chapter the coordinate axes are drawn only for illustrative purposes and are <em>not</em> part of the arrangement.</span> The first line segment \(s_1\) is inserted in the interior of the unbounded face, while the four succeeding line segments \(s_2, \ldots, s_5\) are inserted using the vertices created by the insertion of preceding segments. The arrows in the figure mark the direction of the halfedges \(e_1, \ldots, e_5\) returned from the insertion functions. The resulting arrangement consists of three faces, where the two bounded faces form together a hole in the unbounded face.</p>
<p>Two header files are included in the code in order to make this and the following examples more compact. The file <code>arr_inexact_construction_segments.h</code> is listed immediately after the program. The file <code>arr_print.h</code> is introduced in Section <a class="el" href="index.html#arr_ssectraverse">Traversing the Arrangement</a>.</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2edge_insertion_8cpp-example.html">Arrangement_on_surface_2/edge_insertion.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Constructing an arrangement using the simple edge-insertion functions.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_inexact_construction_segments.h"</span></div><div class="line"><span class="preprocessor">#include "arr_print.h"</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  Point p1(1, 3), p2(3, 5), p3(5, 3), p4(3, 1);</div><div class="line">  Segment s1(p1, p2), s2(p2, p3), s3(p3, p4), s4(p4, p1), s5(p1, p3);</div><div class="line"></div><div class="line">  Arrangement arr;</div><div class="line">  Halfedge_handle e1 = arr.insert_in_face_interior(s1, arr.unbounded_face());</div><div class="line">  Vertex_handle v1 = e1-&gt;source();</div><div class="line">  Vertex_handle v2 = e1-&gt;target();</div><div class="line">  Halfedge_handle e2 = arr.insert_from_left_vertex(s2, v2);</div><div class="line">  Vertex_handle v3 = e2-&gt;target();</div><div class="line">  Halfedge_handle e3 = arr.insert_from_right_vertex(s3, v3);</div><div class="line">  Vertex_handle v4 = e3-&gt;target();</div><div class="line">  arr.insert_at_vertices(s4, v4, v1);   <span class="comment">// return e4</span></div><div class="line">  arr.insert_at_vertices(s5, v1, v3);   <span class="comment">// return e5</span></div><div class="line"></div><div class="line">  print_arrangement(arr);</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>The statements below define the types for arrangements of line segments common to all examples that do not construct new geometric objects. They are kept in the header file <code>arr_inexact_construction_segments.h</code>. In these examples the <code>Traits</code> parameter of the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt;Traits, Dcel&gt;</code> class template is substituted with an instance of the <code><a class="el" href="classCGAL_1_1Arr__non__caching__segment__traits__2.html" title="The traits class Arr_non_caching_segment_traits_2 is a model of the ArrangementTraits_2 concept that ...">Arr_non_caching_segment_traits_2</a>&lt;<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>&gt;</code> class template. The <code><a class="el" href="classCGAL_1_1Arr__non__caching__segment__traits__2.html" title="The traits class Arr_non_caching_segment_traits_2 is a model of the ArrangementTraits_2 concept that ...">Arr_non_caching_segment_traits_2</a></code> class template is instantiated with the predefined kernel that evaluates predicates in an exact manner, but constructs geometric objects in an inexact manner, as none of these examples construct new geometric objects. In the remaining examples the traits class-template is instantiated with a kernel that evaluates predicates and constructs geometric objects, both in an exact manner.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_non_caching_segment_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a>                                          Number_type;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__non__caching__segment__traits__2.html">CGAL::Arr_non_caching_segment_traits_2&lt;Kernel&gt;</a>      Traits;</div><div class="line"><span class="keyword">typedef</span> Traits::Point_2                                     Point;</div><div class="line"><span class="keyword">typedef</span> Traits::X_monotone_curve_2                          Segment;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits&gt;</a>                         Arrangement;</div><div class="line"><span class="keyword">typedef</span> Arrangement::Vertex_handle                          Vertex_handle;</div><div class="line"><span class="keyword">typedef</span> Arrangement::Halfedge_handle                        Halfedge_handle;</div><div class="line"><span class="keyword">typedef</span> Arrangement::Face_handle                            Face_handle;</div></div><!-- fragment --><h2><a class="anchor" id="arr_sssecmf_iso_verts"></a>
Manipulating Isolated Vertices</h2>
<p>Isolated points are simpler geometric entities than curves, and indeed the member functions that manipulate them are easier to understand.</p>
<p>The call <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a622e04b98c5d0ac773c0a1b6da94b242"><code>arr.insert_in_face_interior(p, f)</code></a> inserts an isolated point \(p\), located in the interior of a given face \( f\), into the arrangement and returns a handle to the arrangement vertex associated with \(p\) it has created. Naturally, this function has a precondition that \(p\) is really an isolated point; namely it does not coincide with any existing arrangement vertex and does not lie on any edge. As mentioned in Section <a class="el" href="index.html#arr_ssectraverse">Traversing the Arrangement</a>, it is possible to obtain the face containing an isolated vertex calling the member function <code><a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex.html#ae090e4bb8f2f31c020e21d94816e7335" title="obtains a handle to the face that contains v in its interior. ">Arrangement_on_surface_2::Vertex::face()</a></code>. The member function <code><a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#ade2ba2bbc1bf47a81bfbcab204d269ca" title="removes the isolated vertex v from the arrangement. ">Arrangement_on_surface_2::remove_isolated_vertex(Vertex_handle v)</a></code> accepts a handle to an isolated vertex and removes it from the arrangement.</p>
<p><a class="anchor" id="fig__aos_fig-isolated_vertices"></a></p><div class="image">
<img src="isolated_vertices.png" alt="isolated_vertices.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-isolated_vertices">Figure 34.5</a> An arrangement of line segments containing three isolated vertices, as constructed in <a class="el" href="Arrangement_on_surface_2_2isolated_vertices_8cpp-example.html">Arrangement_on_surface_2/isolated_vertices.cpp</a>. The vertices \(u_2\) and \(u_3\) are eventually removed from the arrangement.  </div> <br /> 
<p>The following program demonstrates the usage of the arrangement member-functions for manipulating isolated vertices. It first inserts three isolated vertices, \(u_1\), \(u_2\), and \(u_3\), located inside the unbounded face of the arrangement. Then, it inserts four line segments \(s_1, \ldots, s_4\), that form a square hole inside the unbounded face (see <a class="el" href="index.html#fig__aos_fig-edge_insertion">Figure 34.4</a> for an illustration). Finally, it traverses the vertices and removes those isolated vertices that are still contained in the unbounded face ( \(u_2\) and \(u_3\) in this case):</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2isolated_vertices_8cpp-example.html">Arrangement_on_surface_2/isolated_vertices.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Constructing an arrangement with isolated vertices.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_inexact_construction_segments.h"</span></div><div class="line"><span class="preprocessor">#include "arr_print.h"</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <span class="comment">// Insert isolated points.</span></div><div class="line">  Arrangement arr;</div><div class="line">  Face_handle uf = arr.unbounded_face();</div><div class="line">  arr.insert_in_face_interior(Point(3, 3), uf);</div><div class="line">  arr.insert_in_face_interior(Point(1, 5), uf);</div><div class="line">  arr.insert_in_face_interior(Point(5, 5), uf);</div><div class="line"></div><div class="line">  <span class="comment">// Insert four segments that form a square-shaped face.</span></div><div class="line">  Point p1(1, 3), p2(3, 5), p3(5, 3), p4(3, 1);</div><div class="line">  Segment s1(p1, p2), s2(p2, p3), s3(p3, p4), s4(p4, p1);</div><div class="line"></div><div class="line">  Halfedge_handle e1 = arr.insert_in_face_interior(s1, uf);</div><div class="line">  Vertex_handle v1 = e1-&gt;source();</div><div class="line">  Vertex_handle v2 = e1-&gt;target();</div><div class="line">  Halfedge_handle e2 = arr.insert_from_left_vertex(s2, v2);</div><div class="line">  Vertex_handle v3 = e2-&gt;target();</div><div class="line">  Halfedge_handle e3 = arr.insert_from_right_vertex(s3, v3);</div><div class="line">  Vertex_handle v4 = e3-&gt;target();</div><div class="line">  arr.insert_at_vertices(s4, v4, v1);</div><div class="line"></div><div class="line">  <span class="comment">// Remove the isolated vertices located in the unbounded face.</span></div><div class="line">  Arrangement::Vertex_iterator iter = arr.vertices_begin();</div><div class="line">  <span class="keywordflow">while</span> (iter != arr.vertices_end()) {</div><div class="line">    <span class="comment">// Keep an iterator to the next vertex, as curr might be deleted.</span></div><div class="line">    Arrangement::Vertex_iterator curr = iter ++;</div><div class="line">    <span class="keywordflow">if</span> (curr-&gt;is_isolated() &amp;&amp; curr-&gt;face() == uf)</div><div class="line">      arr.remove_isolated_vertex(curr);</div><div class="line">  }</div><div class="line"></div><div class="line">  print_arrangement(arr);</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="arr_sssecmf_halfedges"></a>
Manipulating Halfedges</h2>
<p>While reading the previous subsection you learned how to insert new points that induce isolated vertices into the arrangement. You may wonder now how you can insert a new point that lies on an \(x\)-monotone curve that is associated with existing arrangement edge.</p>
<p>The introduction of a vertex, the geometric mapping of which is a point \(p\) that lies on an \(x\)-monotone curve, requires the splitting of the curve in its interior at \(p\). The two resulting subcurves induce two new edges, respectively. In general, the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> class template relies on the geometry traits to perform such a split. As a matter of fact, it relies on the geometry traits to perform all geometric operations. To insert a point \(p\) that lies on an \(x\)-monotone curve associated with an existing edge \(e\) into the arrangement \(\mathcal{A}\), you must first construct the two curves \(c_1\) and \(c_2\), which are the two subcurves that result from splitting the \(x\)-monotone curve associated with the edge \(e\) at \(p\). Then, you have to issue the call <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a2247def3072f9c94c659c68c55388dee"><code>arr.split_edge(he, c1, c2)</code></a>, where <code>arr</code> identifies the arrangement \(\mathcal{A}\) and <code>he</code> is a handle to one of the two halfedges that represent the edge \(e\). The function splits the two halfedges that represent \(e\) into two pairs of halfedges, respectively. Two new halfedges are incident to the new vertex \(v\) associated with \(p\). The function returns a handle to the new halfedge, the source of which is the source vertex of the halfedge handled by <code>he</code>, and the target of which is the new vertex \(v\).</p>
<p>The reverse operation is also possible. Consider a vertex \(v\) of degree \(2\) that has two incident edges \(e_1\) and \(e_2\) associated with two curves \(c_1\) and \(c_2\), respectively, such that the union of \(c_1\) and \(c_2\) results in a single continuous \(x\)-monotone curve \(c\) of the type supported by the traits class in use. To merge the edges \(e_1\) and \(e_2\) into a single edge associated with the curve \(c\), essentially removing the vertex \(v\) from the arrangement identified by <code>arr</code>, you need to issue the call <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a21ad366a7eca1b0b6494e86162b661b6"><code>arr.merge_edge(he1, he2, c)</code></a>, where <code>he1</code> and <code>he2</code> are handles to halfedges representing \(e_1\) and \(e_2\), respectively.</p>
<p>Finally, the call <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a89618f53b378427e38b7d68fb9f86873"><code>remove_edge(he)</code></a> removes the edge \(e\) from the arrangement, where <code>he</code> is a handle to one of the two halfedges that represents \(e\). Note that this operation is the reverse of an insertion operation, so it may cause a connected component to split into two, or two faces to merge into one, or a hole to disappear. By default, if the removal of \(e\) causes one of its end vertices to become isolated, this vertex is removed as well. However, you can control this behavior and choose to keep the isolated vertices by supplying additional Boolean flags to <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a89618f53b378427e38b7d68fb9f86873"><code>remove_edge()</code></a> indicating whether the source or the target vertices are to be removed should they become isolated.</p>
<p><a class="anchor" id="fig__aos_fig-edge_manipulation"></a></p><div class="image">
<img src="edge_manipulation.png" alt="edge_manipulation.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-edge_manipulation">Figure 34.6</a> The three steps of the example program <a class="el" href="Arrangement_on_surface_2_2edge_manipulation_8cpp-example.html">Arrangement_on_surface_2/edge_manipulation.cpp</a>. In Step (a) it constructs an arrangement of four line segments. In Step (b) the edges \(e_1\) and \(e_2\) are split, and the split points are connected with a new segment \(s\) that is inserted into the arrangement. This operation is undone in Step (c), where \(e\) is removed from the arrangement, rendering its end vertices \(u_1\) and \(u_2\) redundant. We therefore remove these vertices by merging their incident edges and go back to the arrangement depicted in (a).  </div> <br /> 
<p>The following example program shows how the edge-manipulation functions can be used. The program works in three steps, as demonstrated in <a class="el" href="index.html#fig__aos_fig-isolated_vertices">Figure 34.5</a>. Note that the program uses the fact that <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a2247def3072f9c94c659c68c55388dee"><code>split_edge()</code></a> returns one of the new halfedges (after the split) that has the same direction as the original halfedge (the first parameter of the function) and is directed towards the split point. Thus, it is easy to identify the vertices \(u_1\) and \(u_2\) associated with the split points.</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2edge_manipulation_8cpp-example.html">Arrangement_on_surface_2/edge_manipulation.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Using the edge-manipulation functions.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_inexact_construction_segments.h"</span></div><div class="line"><span class="preprocessor">#include "arr_print.h"</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <span class="comment">// Step (a)---construct a rectangular face.</span></div><div class="line">  Point q1(1, 3), q2(3, 5), q3(5, 3), q4(3, 1);</div><div class="line">  Segment s4(q1, q2), s1(q2, q3), s3(q3, q4), s2(q4, q1);</div><div class="line"></div><div class="line">  Arrangement arr;</div><div class="line">  Halfedge_handle e1 = arr.insert_in_face_interior(s1, arr.unbounded_face());</div><div class="line">  Halfedge_handle e2 = arr.insert_in_face_interior(s2, arr.unbounded_face());</div><div class="line"></div><div class="line">  e2 = e2-&gt;twin();     <span class="comment">// as we wish e2 to be directed from right to left</span></div><div class="line">  arr.insert_at_vertices(s3, e1-&gt;target(), e2-&gt;source());</div><div class="line">  arr.insert_at_vertices(s4, e2-&gt;target(), e1-&gt;source());</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"After step (a):\n"</span>;</div><div class="line">  print_arrangement(arr);</div><div class="line"></div><div class="line">  <span class="comment">// Step (b)---split e1 and e2 and connect the split points with a segment.</span></div><div class="line">  Point p1(4,4), p2(2,2);</div><div class="line">  Segment s1_1(q2, p1), s1_2(p1, q3), s2_1(q4, p2), s2_2(p2, q1), s(p1, p2);</div><div class="line"></div><div class="line">  e1 = arr.split_edge(e1, s1_1, s1_2);</div><div class="line">  e2 = arr.split_edge(e2, s2_1, s2_2);</div><div class="line">  Halfedge_handle e = arr.insert_at_vertices(s, e1-&gt;target(), e2-&gt;target());</div><div class="line">  std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">"After step (b):"</span> &lt;&lt; std::endl;</div><div class="line">  print_arrangement(arr);</div><div class="line"></div><div class="line">  <span class="comment">// Step (c)---remove the edge e and merge e1 and e2 with their successors.</span></div><div class="line">  arr.remove_edge(e);</div><div class="line">  arr.merge_edge(e1, e1-&gt;next(), s1);</div><div class="line">  arr.merge_edge(e2, e2-&gt;next(), s2);</div><div class="line">  std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">"After step (c):\n"</span>;</div><div class="line">  print_arrangement(arr);</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>The member functions <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#aa34dd4faba726f8d8f912b48dc239e5d"><code>modify_vertex()</code></a> and <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a04ddf22219d330f989d39beca666f1b9"><code>modify_edge()</code></a> modify the geometric mappings of existing features of the arrangement. The call <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#aa34dd4faba726f8d8f912b48dc239e5d"><code>arr.modify_vertex(v, p)</code></a> accepts a handle to a vertex \(v\) and a reference to a point \(p\), and sets \(p\) to be the point associated with the vertex \(v\). The call <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a04ddf22219d330f989d39beca666f1b9"><code>arr.modify_edge(he, c)</code></a> accepts a handle to one of the two halfedges that represent an edge \(e\) and a reference to a curve \(c\), and sets \(c\) to be the \(x\)-monotone curve associated with \(e\). (Note that both halfedges are modified; that is, both expressions <code>e-&gt;curve()</code> and <code>e-&gt;twin()-&gt;curve()</code> evaluate to \(c\) after the modification.) These functions have preconditions that \(p\) is geometrically equivalent to <code>v-&gt;point()</code> and \(c\) is equivalent to <code>e-&gt;curve()</code>, respectively.<span class="footnote">Roughly speaking, two curves are equivalent iff they have the same graph. In Section <a class="el" href="index.html#aos_sssec-geom_traits-concepts_basic">The Basic Concept</a> we give a formal definition of curves and curve equivalence.</span> If these preconditions are not met, the corresponding operation may invalidate the structure of the arrangement. At first glance it may seem as if these two functions are of little use. However, you should keep in mind that there may be extraneous data (probably non-geometric) associated with the point objects or with the curve objects, as defined by the traits class. With these two functions you can modify this data; see more details in Section <a class="el" href="index.html#arr_ssecmeta_tr">Traits-Class Decorators</a>. In addition, you can use these functions to replace a geometric object (a point or a curve) with an equivalent object that has a more compact representation. For example, if we use some simple rational-number type to represent the point coordinates, we can replace the point \((\frac{20}{40}, \frac{99}{33})\) associated with some vertex \(v\) with an equivalent point with normalized coordinates, namely \((\frac{1}{2}, 3)\).</p>
<h2><a class="anchor" id="arr_sssecadv_insert"></a>
Advanced Insertion Functions</h2>
<p> </p><div class="CGALAdvanced"> <div>Advanced</div> 
<table border="0" cellspacing="10">
<tr>
<td><div class="image">
<img src="pred_around_vertex.png" alt="pred_around_vertex.png" />
</div>
   </td><td><p class="starttd"></p>
<p class="endtd">Assume that the specialized insertion function <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a5afb084b94adba3fa294724bd07ccb36"><code>insert_from_left_vertex(c, v)</code></a> is given a curve \(c\), the left endpoint of which is already associated with a non-isolated vertex \(v\). Namely, \(v\) has already several incident halfedges. It is necessary in this case to locate the exact place for the new halfedge mapped to the inserted new curve \(c\) in the circular list of halfedges incident to \(v\). More precisely, in order to complete the insertion, it is necessary to locate the halfedge \(e_{\mathrm{pred}}\) directed toward \(v\), such that \(c\) is located between the curves associated with \(e_{\mathrm{pred}}\) and the next halfedge in the clockwise order in the circular list of halfedges around \(v\); see <a class="el" href="index.html#fig__aos_fig-insert">Figure 34.3</a>. This search may take \(O(d)\) time, where \(d\) is the degree of the vertex \(v\). <span class="footnote">We can store the handles to the halfedges incident to \(v\) in an efficient search structure to obtain \(O(\log d)\) access time. However, as \(d\) is usually very small, this may lead to a waste of storage space without a meaningful improvement in running time in practice.</span> However, if the halfedge \(e_{\mathrm{pred}}\) is known in advance, the insertion can be carried out in constant time, and without performing any geometric comparisons.   </p>
</td></tr>
</table>
<p>The <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> class provides advanced versions of the specialized insertion functions for a curve \(c\), namely, <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a5afb084b94adba3fa294724bd07ccb36"><code>insert_from_left_vertex(c, he_pred)</code></a> and <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a1f3b1ceca5219900301e4eefd9f80bd0"><code>insert_from_right_vertex(c, he_pred)</code></a>. These functions accept a halfedge \(e_{\mathrm{pred}}\) as specified above, instead of a handle to a vertex \(v\). They are more efficient, as they take constant time and do not perform any geometric operations. Thus, you should use them when the halfedge \(e_{\mathrm{pred}}\) is known. In cases where the vertex \(v\) is isolated or the predecessor halfedge for the newly inserted curve is not known, the simpler versions of these insertion functions should be used. Similarly, the member function <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a7f2201fbb9015ddbbd22b7704e958e24"><code>insert_at_vertices()</code></a> is overloaded with two additional versions as follows. One accepts two handles to the two predecessor halfedges around the two vertices \(v_1\) and \(v_2\), respectively, that correspond to the curve endpoints. The other one accepts a handle to one vertex and a handle to the predecessor halfedge around the other vertex.</p>
<p><a class="anchor" id="fig__aos_fig-special_edge_insertion"></a></p><div class="image">
<img src="special_edge_insertion.png" alt="special_edge_insertion.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-special_edge_insertion">Figure 34.7</a> An arrangement of line segments, as constructed in <a class="el" href="Arrangement_on_surface_2_2special_edge_insertion_8cpp-example.html">Arrangement_on_surface_2/special_edge_insertion.cpp</a>. Note that \(p_0\) is initially inserted as an isolated point and later on connected to the other four vertices.  </div> <br /> 
<p>The following program shows how to construct the arrangement depicted in <a class="el" href="index.html#fig__aos_fig-special_edge_insertion">Figure 34.7</a> using the specialized insertion functions that accept predecessor halfedges:</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2special_edge_insertion_8cpp-example.html">Arrangement_on_surface_2/special_edge_insertion.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Constructing an arrangement using the specialized edge-insertion functions.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_inexact_construction_segments.h"</span></div><div class="line"><span class="preprocessor">#include "arr_print.h"</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  Point p0(3, 3), p1(1, 3), p2(3, 5), p3(5, 3), p4(3, 1);</div><div class="line">  Segment s1(p1, p2), s2(p2, p3), s3(p3, p4), s4(p4, p1);</div><div class="line">  Segment s5(p1, p0), s6(p0, p3), s7(p4, p0), s8(p0, p2);</div><div class="line"></div><div class="line">  Arrangement arr;</div><div class="line">  Vertex_handle v0 = arr.insert_in_face_interior(p0, arr.unbounded_face());</div><div class="line">  Halfedge_handle e1 = arr.insert_in_face_interior(s1, arr.unbounded_face());</div><div class="line">  Halfedge_handle e2 = arr.insert_from_left_vertex(s2, e1);</div><div class="line">  Halfedge_handle e3 = arr.insert_from_right_vertex(s3, e2);</div><div class="line">  Halfedge_handle e4 = arr.insert_at_vertices(s4, e3, e1-&gt;twin());</div><div class="line">  Halfedge_handle e5 = arr.insert_at_vertices(s5, e1-&gt;twin(), v0);</div><div class="line">  Halfedge_handle e6 = arr.insert_at_vertices(s6, e5, e3-&gt;twin());</div><div class="line">  arr.insert_at_vertices(s7, e4-&gt;twin(), e6-&gt;twin());</div><div class="line">  arr.insert_at_vertices(s8, e5, e2-&gt;twin());</div><div class="line"></div><div class="line">  print_arrangement(arr);</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>It is possible to perform even more refined operations on an <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> object given specific topological information. As most of these operations are very fragile and perform no precondition testing on their input in order to gain efficiency, they are not included in the public interface of the arrangement class. Instead, the <code><a class="el" href="classCGAL_1_1Arr__accessor.html">Arr_accessor</a>&lt;Arrangement&gt;</code> class allows access to these internal arrangement operations; see more details in the Reference Manual.  </p></div> 
<h1><a class="anchor" id="arr_secqueries"></a>
Issuing Queries on an Arrangement</h1>
<p>One of the most useful query types defined on arrangements is the <em>point-location</em> query: Given a point, find the arrangement cell that contains it. Typically, the result of a point-location query is one of the arrangement faces, but in degenerate situations the query point can lie on an edge, or it may coincide with a vertex.</p>
<p>Point-location queries are common in many applications, and also play an important role in the incremental construction of arrangements (and more specifically in the free insertion-functions described in Section <a class="el" href="index.html#arr_secgl_funcs">Free Functions</a>). Therefore, it is crucial to have the ability to answer such queries effectively.</p>
<h2><a class="anchor" id="arr_ssecpl"></a>
Point-Location Queries</h2>
<p>Recall that the arrangement representation is decoupled from the geometric algorithms that operate on it. Thus, the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> class template does not support point-location queries directly. Instead, the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgArrangementOnSurface2">2D Arrangements</a> package provides a set of class templates that are capable of answering such queries; all are models of the concept <code><a class="el" href="classArrangementPointLocation__2.html" title="A model of the ArrangementPointLocation_2 concept can answer point-location queries on an arrangement...">ArrangementPointLocation_2</a></code>. Each model employs a different algorithm or <em>strategy</em> for answering queries. A model of this concept must define the <a class="el" href="classArrangementPointLocation__2.html#ad86ba795e886260a7e5858b34b0c4e7b"><code>locate()</code></a> member function, which accepts an input query-point and returns a polymorphic object representing the arrangement cell that contains this point. The returned object is of type <code><a class="el" href="structCGAL_1_1Arr__point__location__result.html" title="A unary metafunction to determine the return type of a point-location or vertical ray-shoot query...">Arr_point_location_result</a>&lt;<a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&gt;::Type</code>, which is a discriminated union container of the bounded types <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a47fac787fb37cd812814fbb9b6ab9acc"><code>Vertex_const_handle</code></a>, <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a22adafaff54a2c42e6c369f198870be5"><code>Halfedge_const_handle</code></a>, or <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a513a10758cc81189887d5f0a492f0245"><code>Face_const_handle</code></a>. Depending on whether the query point is located inside a face, lies on an edge, or coincides with a vertex, the appropriate handle can be obtained with <em>value retrieval</em> by <code>boost::get</code> as demonstrated in the example below.</p>
<p>Note that the handles returned by the <a class="el" href="classArrangementPointLocation__2.html#ad86ba795e886260a7e5858b34b0c4e7b"><code>locate()</code></a> functions are non-mutable (<code>const</code>). If necessary, such handles may be cast to mutable handles using the <code><a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#ab3ce8cfa533c872fee6496a100121bb4" title="casts the given constant vertex handle to an equivalent mutable handle. ">Arrangement_on_surface_2::non_const_handle()</a></code> methods.</p>
<p>An object <code>pl</code> of any point-location class must be attached to an <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> object <code>arr</code> before it is used to answer point-location queries on <code>arr</code>. This attachment can be performed when <code>pl</code> is constructed or at a later time using the <code>pl.init(arr)</code> call.</p>
<p>The function template <code>locate_point()</code> listed below accepts a point-location object, the type of which is a model of the <code><a class="el" href="classArrangementPointLocation__2.html" title="A model of the ArrangementPointLocation_2 concept can answer point-location queries on an arrangement...">ArrangementPointLocation_2</a></code> concept, and a query point. The function template issues a point-location query for the given point, and prints out the result. It is defined in the header file <code>point_location_utils.h</code>.</p>
<p><a class="anchor" id="lst_pl"></a></p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Po<span class="keywordtype">int</span>Location&gt;</div><div class="line"><span class="keywordtype">void</span> locate_point(<span class="keyword">const</span> PointLocation&amp; pl,</div><div class="line">                  <span class="keyword">const</span> <span class="keyword">typename</span> PointLocation::Arrangement_2::Point_2&amp; q)</div><div class="line">{</div><div class="line">  <span class="keyword">typedef</span> PointLocation                                 Point_location;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Point_location::Arrangement_2        Arrangement_2;</div><div class="line">  <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">CGAL::Arr_point_location_result&lt;Arrangement_2&gt;::Type</a> obj =</div><div class="line">    pl.locate(q);</div><div class="line"></div><div class="line">  <span class="comment">// Print the result.</span></div><div class="line">  print_point_location&lt;Arrangement_2&gt;(q, obj);</div><div class="line">}</div></div><!-- fragment --><p>The function template <code>locate_point()</code> calls an instance of the function template <code>print_point_location()</code>, which inserts the result of the query into the standard output-stream. It is listed below, and defined in the header file <code>point_location_utils.h</code>. Observe how the function <code>boost::get()</code> is used to cast the resulting object into a handle to an arrangement feature. The point-location object <code>pl</code> is assumed to be already attached to an arrangement.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Arrangement_&gt;</div><div class="line"><span class="keywordtype">void</span> print_point_location</div><div class="line">(<span class="keyword">const</span> <span class="keyword">typename</span> PointLocation::Arrangement_::Point_2&amp; q</div><div class="line"> <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">CGAL::Arr_point_location_result&lt;Arrangement_&gt;::Type</a> obj)</div><div class="line">{</div><div class="line">  <span class="keyword">typedef</span> Arrangement_                                  Arrangement_2;</div><div class="line"></div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classCGAL_1_1Arrangement__2.html#a2b84fbf1c36a71637c4f09766cc89404">Arrangement_2::Vertex_const_handle</a>   Vertex_const_handle;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classCGAL_1_1Arrangement__2.html#ae6a57d8ef97a928b56bb482085b62360">Arrangement_2::Halfedge_const_handle</a> Halfedge_const_handle;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classCGAL_1_1Arrangement__2.html#aec6445d17ffe4ab1d5730d889bb576bc">Arrangement_2::Face_const_handle</a>     Face_const_handle;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> Vertex_const_handle*   v;</div><div class="line">  <span class="keyword">const</span> Halfedge_const_handle* e;</div><div class="line">  <span class="keyword">const</span> Face_const_handle*     f;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The point ("</span> &lt;&lt; q &lt;&lt; <span class="stringliteral">") is located "</span>;</div><div class="line">  <span class="keywordflow">if</span> (f = boost::get&lt;Face_const_handle&gt;(&amp;obj)) <span class="comment">// located inside a face</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"inside "</span></div><div class="line">              &lt;&lt; (((*f)-&gt;is_unbounded()) ? <span class="stringliteral">"the unbounded"</span> : <span class="stringliteral">"a bounded"</span>)</div><div class="line">              &lt;&lt; <span class="stringliteral">" face.\n"</span>;</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (e = boost::get&lt;Halfedge_const_handle&gt;(&amp;obj)) <span class="comment">// located on an edge</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"on an edge: "</span> &lt;&lt; (*e)-&gt;curve() &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (v = boost::get&lt;Vertex_const_handle&gt;(&amp;obj)) <span class="comment">// located on a vertex</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"on "</span> &lt;&lt; (((*v)-&gt;is_isolated()) ? <span class="stringliteral">"an isolated"</span> : <span class="stringliteral">"a"</span>)</div><div class="line">              &lt;&lt; <span class="stringliteral">" vertex: "</span> &lt;&lt; (*v)-&gt;point() &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">else</span> CGAL_error_msg(<span class="stringliteral">"Invalid object."</span>);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="aos_sssec-pl_strategy"></a>
Choosing a Point-Location Strategy</h2>
<p>Each of the various point-location class templates employs a different algorithm or <em>strategy</em><span class="footnote">The term <em>strategy</em> is borrowed from the design-pattern taxonomy <a class="el" href="citelist.html#CITEREF_cgal:ghjv-dpero-95">[7]</a>, Chapter 5. A <em>strategy</em> provides the means to define a family of algorithms, each implemented by a separate class. All classes that implement the various algorithms are made interchangeable, letting the algorithm in use vary according to the user choice.</span> for answering queries: </p><ul>
<li>
<p class="startli"><code><a class="el" href="classCGAL_1_1Arr__naive__point__location.html">Arr_naive_point_location</a>&lt;Arrangement&gt;</code> employs the <em>naive</em> strategy. It locates the query point naively, exhaustively scanning all arrangement cells.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><code><a class="el" href="classCGAL_1_1Arr__walk__along__line__point__location.html">Arr_walk_along_line_point_location</a>&lt;Arrangement&gt;</code> employs the <em>walk-along-a-line</em> (or <em>walk</em> for short) strategy. It simulates a traversal, in reverse order, along an imaginary vertical ray emanating from the query point. It starts from the unbounded face of the arrangement and moves downward toward the query point until it locates the arrangement cell containing it.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><code><a class="el" href="classCGAL_1_1Arr__landmarks__point__location.html">Arr_landmarks_point_location</a>&lt;Arrangement,Generator&gt;</code> uses a set of <em>landmark</em> points, the location of which in the arrangement is known. It employs the <em>landmark</em> strategy. Given a query point, it uses a nearest-neighbor search-structure (a <span class="textsc">Kd</span>-tree is used by default) to find the nearest landmark, and then traverses the straight-line segment connecting this landmark to the query point.</p>
<p>There are various ways to select the landmark set in the arrangement. The selection is governed by the <code>Generator</code> template parameter. The default generator class, namely <code>Arr_landmarks_vertices_generator</code>, selects all the vertices of the attached arrangement as landmarks. Additional generators that select the set in other ways, such as by sampling random points or choosing points on a grid, are also available; see the Reference Manual for more details.</p>
<p>The landmark strategy requires that the type of the attached arrangement be an instance of the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt;Traits,Dcel&gt;</code> class template, where the <code>Traits</code> parameter is substituted with a geometry-traits class that models the <code><a class="el" href="classArrangementLandmarkTraits__2.html" title="The concept ArrangementLandmarkTraits_2 refines the traits concepts ArrangementApproximateTraits_2 an...">ArrangementLandmarkTraits_2</a></code> concept, which refines the basic <code><a class="el" href="classArrangementBasicTraits__2.html" title="The concept ArrangementBasicTraits_2 defines the minimal set of geometric predicates needed for the c...">ArrangementBasicTraits_2</a></code> concept; see Section <a class="el" href="index.html#aos_sssec-tr_landmarks_concept">The Landmark Concept</a> for details. Most traits classes included in the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgArrangementOnSurface2">2D Arrangements</a> package are models of this refined concept.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><code><a class="el" href="classCGAL_1_1Arr__trapezoid__ric__point__location.html">Arr_trapezoid_ric_point_location</a>&lt;Arrangement&gt;</code> implements an improved variant of Mulmuley's point-location algorithm <a class="el" href="citelist.html#CITEREF_m-fppa-90">[11]</a>; see also <a class="el" href="citelist.html#CITEREF_bkos-cgaa-00">[5]</a>, Chapter 6. The (expected) query-time is logarithmic in the size of the arrangement. The arrangement faces are decomposed into simpler cells each of constant complexity, known as <em>pseudo trapezoids</em>, and a search structure (a directed acyclic graph) is constructed on top of these cells, facilitating the search of the pseudo trapezoid (hence the arrangement cell) containing a query point in expected logarithmic time. The trapezoidal map and the search structure are built by a randomized incremental construction algorithm (RIC).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><code><a class="el" href="classCGAL_1_1Arr__triangulation__point__location.html">Arr_triangulation_point_location</a>&lt;Arrangement&gt;</code> uses a constrained triangulation, provided by the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgTriangulation2">2D Triangulations</a> package, as a search structure. Every time the arrangement is modified the constrained triangulation search-structure is reconstructed from scratch, where the edges of the arrangement are set to be the constrained edges of the triangulation. This strategy is inefficient (especially when the number of modifications applied to the arrangement is high) and provided only for educational purposes.</p>
<p class="endli"></p>
</li>
</ul>
<p>The first two strategies do not require any extra data. The class templates that implement them store a pointer to an arrangement object and operate directly on it. Attaching such point-location objects to an existing arrangement has virtually no running-time cost at all, but the query time is linear in the size of the arrangement (the performance of the walk strategy is much better in practice, but its worst-case performance is linear). Using these strategies is therefore recommended only when a relatively small number of point-location queries are issued by the application, or when the arrangement is constantly changing (That is, changes in the arrangement structure are more frequent than point-location queries). On the other hand, the landmark and the trapezoid RIC strategies require auxiliary data structures on top of the arrangement structure, which they need to construct once they are attached to an arrangement object and need to keep up-to-date as this arrangement changes.</p>
<p>As mentioned above, the triangulation strategy is provided only for educational purposes, and thus we do not elaborate on this strategy. The data structure needed by the landmark and the trapezoidal map RIC strategies can be constructed in \(O(N \log N)\) time, where \(N\) is the overall number of edges in the arrangement, but the constant hidden in the \(O()\) notation for the trapezoidal map RIC strategy is much larger. Thus, construction needed by the landmark algorithm is in practice significantly faster than the construction needed by the trapezoidal map RIC strategy. In addition, although both resulting data structures are asymptotically linear in size, the actual amount of memory consumed by the landmark algorithm is typically smaller than to the amount used by the trapezoidal map RIC algorithm, due to the space-efficient <span class="textsc">Kd</span>-tree used by the landmark algorithm as the nearest-neighbor search-structure. The trapezoidal map RIC algorithm has expected logarithmic query time, while the query time for the landmark algorithm may be as large as linear. In practice however, the query times of both strategies are competitive. For a detailed experimental comparison see <a class="el" href="citelist.html#CITEREF_cgal:hh-eplca-05">[9]</a>.</p>
<p>Updating the auxiliary data structures of the trapezoidal map RIC algorithm is done very efficiently. On the other hand, updating the nearest-neighbor search-structure of the landmark algorithm may consume significant time when the arrangement changes frequently, especially when a <span class="textsc">Kd</span>-tree is used, as it must be rebuilt each time the arrangement changes. It is therefore recommended that the <code><a class="el" href="classCGAL_1_1Arr__landmarks__point__location.html">Arr_landmarks_point_location</a></code> class template be used when the application frequently issues point-location queries on an arrangement that only seldom changes. If the arrangement is more dynamic and is frequently going through changes, the <code><a class="el" href="classCGAL_1_1Arr__trapezoid__ric__point__location.html">Arr_trapezoid_ric_point_location</a></code> class template should be the selected point-location strategy.</p>
<p><a class="anchor" id="fig__aos_fig-point_location"></a></p><div class="image">
<img src="point_location.png" alt="point_location.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-point_location">Figure 34.8</a> The arrangement of line segments, as constructed in <a class="el" href="Arrangement_on_surface_2_2point_location_8cpp-example.html">Arrangement_on_surface_2/point_location.cpp</a>, <a class="el" href="Arrangement_on_surface_2_2vertical_ray_shooting_8cpp-example.html">Arrangement_on_surface_2/vertical_ray_shooting.cpp</a>, and <a class="el" href="Arrangement_on_surface_2_2batched_point_location_8cpp-example.html">Arrangement_on_surface_2/batched_point_location.cpp</a>. The arrangement vertices are drawn as small rings, while the query points \(q_1, \ldots, q_6\) are drawn as crosses.  </div> <br /> 
<p>The program listed below constructs a simple arrangement of five line segments that form a pentagonal face, with a single isolated vertex in its interior, as depicted in <a class="el" href="index.html#fig__aos_fig-point_location">Figure 34.8</a>. Notice that we use the same arrangement structure in the next three example programs. The arrangement construction is performed by the function <code>construct_segment_arr()</code> defined in the header file <code>point_location_utils.h</code>. (Its listing is omitted here.) The program employs the naive and the landmark strategies to issue several point-location queries on this arrangement.</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2point_location_8cpp-example.html">Arrangement_on_surface_2/point_location.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Answering point-location queries.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_naive_point_location.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_landmarks_point_location.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_inexact_construction_segments.h"</span></div><div class="line"><span class="preprocessor">#include "point_location_utils.h"</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__naive__point__location.html">CGAL::Arr_naive_point_location&lt;Arrangement&gt;</a>         Naive_pl;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__landmarks__point__location.html">CGAL::Arr_landmarks_point_location&lt;Arrangement&gt;</a>     Landmarks_pl;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <span class="comment">// Construct the arrangement.</span></div><div class="line">  Arrangement arr;</div><div class="line">  construct_segments_arr(arr);</div><div class="line"></div><div class="line">  <span class="comment">// Perform some point-location queries using the naive strategy.</span></div><div class="line">  Naive_pl naive_pl(arr);</div><div class="line">  locate_point(naive_pl, Point(1, 4));          <span class="comment">// q1</span></div><div class="line">  locate_point(naive_pl, Point(4, 3));          <span class="comment">// q2</span></div><div class="line">  locate_point(naive_pl, Point(6, 3));          <span class="comment">// q3</span></div><div class="line"></div><div class="line">  <span class="comment">// Perform some point-location queries using the landmark strategy.</span></div><div class="line">  Landmarks_pl landmarks_pl(arr);</div><div class="line">  locate_point(landmarks_pl, Point(3, 2));      <span class="comment">// q4</span></div><div class="line">  locate_point(landmarks_pl, Point(5, 2));      <span class="comment">// q5</span></div><div class="line">  locate_point(landmarks_pl, Point(1, 0));      <span class="comment">// q6</span></div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>Note that the program uses the <code>locate_point()</code> function template to locate a point and nicely print the result of each query; see <a class="el" href="index.html#lst_pl">code example</a> in Section <a class="el" href="index.html#arr_ssecpl">Point-Location Queries</a>.</p>
<h2><a class="anchor" id="arr_ssecray_shoot"></a>
Vertical Ray Shooting</h2>
<p>Another query frequently issued on arrangements is the vertical ray-shooting query: Given a query point, which arrangement cell is encounter by a vertical ray shot upward (or downward) from this point? In the general case the ray hits an edge, but it is possible that it hits a vertex, or that the arrangement does not have any vertex or edge lying directly above (or below) the query point.</p>
<p>All point-location classes listed in the previous section are also models of the <code><a class="el" href="classArrangementVerticalRayShoot__2.html" title="A model of the ArrangementVerticalRayShoot_2 concept can answer vertical ray-shooting queries on an a...">ArrangementVerticalRayShoot_2</a></code> concept. That is, they all have member functions called <code>ray_shoot_up(q)</code> and <code>ray_shoot_down(q)</code> that accept a query point \(q\). These functions output a polymorphic object of type <code><a class="el" href="structCGAL_1_1Arr__point__location__result.html" title="A unary metafunction to determine the return type of a point-location or vertical ray-shoot query...">Arr_point_location_result</a>&lt;<a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&gt;::Type</code>, which is a discriminated union container of the bounded types <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a47fac787fb37cd812814fbb9b6ab9acc"><code>Vertex_const_handle</code></a>, <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a22adafaff54a2c42e6c369f198870be5"><code>Halfedge_const_handle</code></a>, or <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a513a10758cc81189887d5f0a492f0245"><code>Face_const_handle</code></a>. The latter type is used for the unbounded face of the arrangement, in case there is no edge or vertex lying directly above (or below) \(q\).</p>
<p>The function template <code>vertical_ray_shooting_query()</code> listed below accepts a vertical ray-shooting object, the type of which models the <code><a class="el" href="classArrangementVerticalRayShoot__2.html" title="A model of the ArrangementVerticalRayShoot_2 concept can answer vertical ray-shooting queries on an a...">ArrangementVerticalRayShoot_2</a></code> concept. It exports the result of the upward vertical ray-shooting operation from a given query point to the standard output-stream. The ray-shooting object <code>vrs</code> is assumed to be already attached to an arrangement. The function template is defined in the header file <code>point_location_utils.h.</code></p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VerticalRayShooting&gt;</div><div class="line"><span class="keywordtype">void</span> shoot_vertical_ray(<span class="keyword">const</span> RayShoot&amp; vrs,</div><div class="line">                        <span class="keyword">const</span> <span class="keyword">typename</span></div><div class="line">                        VerticalRayShooting::Arrangement_2::Point_2&amp; q)</div><div class="line">{</div><div class="line">  <span class="keyword">typedef</span> VerticalRayShooting                           Vertical_ray_shooting;</div><div class="line"></div><div class="line">  <span class="comment">// Perform the point-location query.</span></div><div class="line">  <span class="keyword">typename</span> Vertical_ray_shooting::result_type obj = vrs.ray_shoot_up(q);</div><div class="line"></div><div class="line">  <span class="comment">// Print the result.</span></div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Vertical_ray_shooting::Arrangement_2 Arrangement_2;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classCGAL_1_1Arrangement__2.html#a2b84fbf1c36a71637c4f09766cc89404">Arrangement_2::Vertex_const_handle</a>   Vertex_const_handle;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classCGAL_1_1Arrangement__2.html#ae6a57d8ef97a928b56bb482085b62360">Arrangement_2::Halfedge_const_handle</a> Halfedge_const_handle;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classCGAL_1_1Arrangement__2.html#aec6445d17ffe4ab1d5730d889bb576bc">Arrangement_2::Face_const_handle</a>     Face_const_handle;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> Vertex_const_handle* v;</div><div class="line">  <span class="keyword">const</span> Halfedge_const_handle* e;</div><div class="line">  <span class="keyword">const</span> Face_const_handle* f;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Shooting up from ("</span> &lt;&lt; q &lt;&lt; <span class="stringliteral">") : "</span>;</div><div class="line">  <span class="keywordflow">if</span> (v = boost::get&lt;Vertex_const_handle&gt;(&amp;obj))         <span class="comment">// we hit a vertex</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"hit "</span> &lt;&lt; (((*v)-&gt;is_isolated()) ? <span class="stringliteral">"an isolated"</span> : <span class="stringliteral">"a"</span>)</div><div class="line">              &lt;&lt; <span class="stringliteral">" vertex: "</span> &lt;&lt; (*v)-&gt;point() &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (e = boost::get&lt;Halfedge_const_handle&gt;(&amp;obj))  <span class="comment">// we hit an edge</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"hit an edge: "</span> &lt;&lt; (*e)-&gt;curve() &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (f = boost::get&lt;Face_const_handle&gt;(&amp;obj)) {    <span class="comment">// we hit nothing</span></div><div class="line">    CGAL_assertion((*f)-&gt;is_unbounded());</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"hit nothing.\n"</span>;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">else</span> CGAL_error();</div><div class="line">}</div></div><!-- fragment --><p>The program below uses the function template listed above to perform vertical ray-shooting queries on an arrangement. The arrangement and the query points are exactly the same as in <a class="el" href="Arrangement_on_surface_2_2point_location_8cpp-example.html">Arrangement_on_surface_2/point_location.cpp</a>; see <a class="el" href="index.html#fig__aos_fig-point_location">Figure 34.8</a>. <br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2vertical_ray_shooting_8cpp-example.html">Arrangement_on_surface_2/vertical_ray_shooting.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Answering vertical ray-shooting queries.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_walk_along_line_point_location.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_trapezoid_ric_point_location.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_inexact_construction_segments.h"</span></div><div class="line"><span class="preprocessor">#include "point_location_utils.h"</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__walk__along__line__point__location.html">CGAL::Arr_walk_along_line_point_location&lt;Arrangement&gt;</a> Walk_pl;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__trapezoid__ric__point__location.html">CGAL::Arr_trapezoid_ric_point_location&lt;Arrangement&gt;</a>   Trap_pl;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <span class="comment">// Construct the arrangement.</span></div><div class="line">  Arrangement arr;</div><div class="line">  construct_segments_arr(arr);</div><div class="line"></div><div class="line">  <span class="comment">// Perform some vertical ray-shooting queries using the walk strategy.</span></div><div class="line">  Walk_pl walk_pl(arr);</div><div class="line">  shoot_vertical_ray(walk_pl, Point(1, 4));</div><div class="line">  shoot_vertical_ray(walk_pl, Point(4, 3));</div><div class="line">  shoot_vertical_ray(walk_pl, Point(6, 3));</div><div class="line"></div><div class="line">  <span class="comment">// Attach the trapezoid-RIC object to the arrangement and perform queries.</span></div><div class="line">  Trap_pl trap_pl(arr);</div><div class="line">  shoot_vertical_ray(trap_pl, Point(3, 2));</div><div class="line">  shoot_vertical_ray(trap_pl, Point(5, 2));</div><div class="line">  shoot_vertical_ray(trap_pl, Point(1, 0));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="arr_ssecbatched_pl"></a>
Batched Point-Location</h2>
<p>Suppose that at a given moment our application has to issue a relatively large number \(m\) of point-location queries on a specific arrangement object. Naturally, It is possible to define a point-location object and use it to issue separate queries on the arrangement. However, as explained in Section <a class="el" href="index.html#arr_ssecpl">Point-Location Queries</a> choosing a simple point-location strategy (either the naive or the walk strategy) means inefficient queries, while the more sophisticated strategies need to construct auxiliary structures that incur considerable overhead in running time.</p>
<p>Alternatively, the <em>2D Arrangement</em> package includes a free <code><a class="el" href="group__PkgArrangementOnSurface2PointLocation.html#ga81a8e48ebfc5a10a040f3b7d94a4c97d" title="Performs a batched point-location operation on a given arrangement. ">locate()</a></code> function that accepts an arrangement and a range of query points as its input and sweeps through the arrangement to locate all query points in one pass. The function outputs the query results as pairs, where each pair consists of a query point and a discriminated union container, which represents the cell containing the point; see Section <a class="el" href="index.html#arr_ssecpl">Point-Location Queries</a>. The output pairs are sorted in increasing \(xy\)-lexicographical order of the query point.</p>
<p>The batched point-location operation is carried out by sweeping the arrangement. Thus, it takes \(O((m+N)\log{(m+N)})\) time, where \(N\) is the number of edges in the arrangement. Issuing separate queries exploiting a point-location strategy with logarithmic query time per query, such as the trapezoidal map RIC strategy (see Section <a class="el" href="index.html#aos_sssec-pl_strategy">Choosing a Point-Location Strategy</a>), is asymptotically more efficient. However, experiments show that when the number \(m\) of point-location queries is of the same order of magnitude as \(N\), the batched point-location operation is more efficient in practice. One of the reasons for the inferior performance of the alternative (asymptotically faster) procedures is the necessity to construct and maintain complex additional data structures.</p>
<p>The program below issues a batched point-location query, which is essentially equivalent to the six separate queries performed in <a class="el" href="Arrangement_on_surface_2_2point_location_8cpp-example.html">Arrangement_on_surface_2/point_location.cpp</a>; see Section <a class="el" href="index.html#arr_ssecpl">Point-Location Queries</a>. <br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2batched_point_location_8cpp-example.html">Arrangement_on_surface_2/batched_point_location.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Answering a batched point-location query.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_batched_point_location.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_inexact_construction_segments.h"</span></div><div class="line"><span class="preprocessor">#include "point_location_utils.h"</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="structCGAL_1_1Arr__point__location__result.html">CGAL::Arr_point_location_result&lt;Arrangement&gt;</a>    Point_location_result;</div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Point, Point_location_result::Type&gt;   Query_result;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <span class="comment">// Construct the arrangement.</span></div><div class="line">  Arrangement arr;</div><div class="line">  construct_segments_arr(arr);</div><div class="line"></div><div class="line">  <span class="comment">// Perform a batched point-location query.</span></div><div class="line">  std::vector&lt;Point&gt; points = {</div><div class="line">    Point(1, 4), Point(4, 3), Point(6, 3), Point(3, 2), Point(5, 2), Point(1, 0)</div><div class="line">  };</div><div class="line">  std::list&lt;Query_result&gt; results;</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2PointLocation.html#ga81a8e48ebfc5a10a040f3b7d94a4c97d">locate</a>(arr, points.begin(), points.end(), std::back_inserter(results));</div><div class="line"></div><div class="line">  <span class="comment">// Print the results.</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = results.begin(); it != results.end(); ++it)</div><div class="line">    print_point_location&lt;Arrangement&gt;(it-&gt;first, it-&gt;second);</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="arr_secgl_funcs"></a>
Free Functions</h1>
<p>The <code><a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html">Arrangement_on_surface_2</a></code> class template is used to represent subdivisions of two-dimensional surfaces induced by curves that lie on such surfaces. Its interface is minimal in the sense that the member functions hardly perform any geometric operations. In this section we explain how to utilize the free functions that enhance that set of operations on arrangements. The implementation of these operations typically require non-trivial geometric algorithms, and occasionally incurs additional requirements on the geometry traits class; the implementation of many of the operations is based on two frameworks, namely the <em>surface sweep</em> and the <em>zone construction</em>. These operations accepts \(x\)-monotone curves; thus, the geometry-traits class used by the arrangements passed as input to, or obtained as output from, these operations must be a model of the <code><a class="el" href="classArrangementXMonotoneTraits__2.html" title="The concept ArrangementXMonotoneTraits_2 refines the basic arrangement-traits concept. A model of this concept is able to handle -monotone curves that intersect in their interior (and points that coincide with curve interiors). This is necessary for constructing arrangements of sets of intersecting -monotone curves. ">ArrangementXMonotoneTraits_2</a></code> concept; see Section <a class="el" href="index.html#aos_sec-geom_traits">The Geometry Traits</a> for the precise definition of this concept. It defines the minimal set of geometric primitives, among other things, required to perform the algorithms of the surface-sweep and zone-construction frameworks.</p>
<h2><a class="anchor" id="arr_ssec_zone"></a>
The Zone Construction Algorithm</h2>
<p>Given an arrangement of curves \(\mathcal{A} = \mathcal{A}(\mathcal{C})\) embedded in a two-dimensional surface, the <em>zone</em> of an additional curve \(\gamma \notin \mathcal{C}\) in \(\mathcal{A}\) is the union of the features of \(\mathcal{A}\), whose closure is intersected by \(\gamma\). The complexity of the zone is defined as the sum of the complexities of its constituents. (Notice that some vertices are counted multiple times.) The zone of a curve \(\gamma\) is computed by locating the left endpoint of \(\gamma\) in the arrangement and then "walking"' along the curve towards the right endpoint, keeping track of the vertices, edges, and faces crossed on the way. The <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgArrangementOnSurface2">2D Arrangements</a> package offers a generic implementation of an algorithm that computes the zone. It is used to implement a set of operations that incrementally construct arrangements induced by sets of curves that lie in two-dimensional surfaces. For simplicity, however, we continue to consider arrangements embedded in the plane.</p>
<p>Section <a class="el" href="index.html#aos_ssec-basic-arr_class">The Arrangement Class Template</a> explains how to construct arrangements of \(x\)-monotone curves that are pairwise disjoint in their interior when the location of the segment endpoints in the arrangement is known. Here we relax this constraint, and allow the location of the inserted \(x\)-monotone curve endpoints to be unknown at the time of insertion.</p>
<h3><a class="anchor" id="arr_sssecinsert_non_x"></a>
Inserting Pairwise Disjoint Curves</h3>
<p>We retain, for the moment, the requirement that the interior of the inserted curve is disjoint from all existing arrangement edges and vertices.</p>
<p>The call <a class="el" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225"><code>insert_non_intersecting_curve(arr, c, pl)</code></a> inserts the \(x\)-monotone curve \(c\) into the arrangement <code>arr</code>, with the precondition that the interior of \(c\) is disjoint from all existing edges and vertices of <code>arr</code>. The third argument <code>pl</code> is a point-location object attached to the arrangement; it is used to locate both endpoints of \(c\) in the arrangement. Each endpoint is expected to either coincide with an existing vertex or lie inside a face. It is possible to invoke one of the specialized insertion functions (see Section <a class="el" href="index.html#aos_ssec-basic-arr_class">The Arrangement Class Template</a>), based on the query results, and insert \(c\) at its proper location.<span class="footnote">The <code><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225" title="Inserts a given -monotone curve into a given arrangement, where the interior of the given curve is di...">CGAL::insert_non_intersecting_curve</a>&lt;&gt;()</code> function template, as all other functions reviewed in this section, is parameterized by an arrangement type and a point-location type (The latter must be substituted with a model of the <code><a class="el" href="classArrangementPointLocation__2.html" title="A model of the ArrangementPointLocation_2 concept can answer point-location queries on an arrangement...">ArrangementPointLocation_2</a></code> concept).</span> The insertion operation thus hardly requires any geometric operations on top of the ones needed to answer the point-location queries. Moreover, it is sufficient that the traits class that substitutes the <code>Traits</code> template parameter of the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt;Traits,Dcel&gt;</code> class template when the latter is instantiated models the concept <code><a class="el" href="classArrangementBasicTraits__2.html" title="The concept ArrangementBasicTraits_2 defines the minimal set of geometric predicates needed for the c...">ArrangementBasicTraits_2</a></code> concept (and the concept <code><a class="el" href="classArrangementLandmarkTraits__2.html" title="The concept ArrangementLandmarkTraits_2 refines the traits concepts ArrangementApproximateTraits_2 an...">ArrangementLandmarkTraits_2</a></code> if the landmark point-location strategy is used), and does not have to support the computation of intersection points between curves. This implies that using a kernel that provides exact geometric predicates, but potentially inexact geometric constructions due to round-off errors, is still sufficient.</p>
<p>The free-function template <code><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225" title="Inserts a given -monotone curve into a given arrangement, where the interior of the given curve is di...">CGAL::insert_non_intersecting_curve</a>&lt;&gt;(arr, c, pl)</code> is overloaded. There is a variant that instead of accepting a user-defined point-location object, it constructs a local object of the walk point-location type, namely, an instance of the <code><a class="el" href="classCGAL_1_1Arr__walk__along__line__point__location.html">Arr_walk_along_line_point_location</a></code> class template, and uses it to insert the curve.</p>
<h3><a class="anchor" id="arr_sssecinsert_x_mon"></a>
Inserting X-monotone Curves</h3>
<p>The time it takes to insert a curve \(c\) using the <code><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225" title="Inserts a given -monotone curve into a given arrangement, where the interior of the given curve is di...">insert_non_intersecting_curve()</a></code> function template is the sum of the time is takes to locate the two endpoints of \(c\) and the time is takes to find the exact place for the new two halfedges mapped to \(c\) in the circular list of halfedges incident to the two vertices mapped to the endpoints of \(c\), respectively. This makes the function relatively efficient; however, its preconditions on the input curves are still rather restricting. Let us assume that the traits class that substitutes the <code>Traits</code> template parameter of the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt;Traits,Dcel&gt;</code> class template models the refined <code><a class="el" href="classArrangementXMonotoneTraits__2.html" title="The concept ArrangementXMonotoneTraits_2 refines the basic arrangement-traits concept. A model of this concept is able to handle -monotone curves that intersect in their interior (and points that coincide with curve interiors). This is necessary for constructing arrangements of sets of intersecting -monotone curves. ">ArrangementXMonotoneTraits_2</a></code> concept and supports curve intersection computations; see Section <a class="el" href="index.html#aos_sec-geom_traits">The Geometry Traits</a> for the exact details. Given an \(x\)-monotone curve, it is sufficient to locate its left endpoint in the arrangement and to trace its <em>zone</em> (see Section <a class="el" href="index.html#arr_ssec_zone">The Zone Construction Algorithm</a>) until the right endpoint is reached. Each time the new curve \(c\) crosses an existing vertex or edge, the curve is split into subcurves (in the latter case, we have to split the curve associated with the existing halfedge as well) and new edges are associated with the resulting subcurves. Recall that an edge is represented by a pair of twin halfedges, so we split it into two halfedge pairs.</p>
<p>The call <a class="el" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94"><code>insert(arr, c, pl)</code></a> performs this insertion operation. The <code><a class="el" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94" title="% inserts one or more curves or -monotone curves into a given arrangement, where no restrictions are ...">CGAL::insert</a>&lt;&gt;()</code> function template accepts an \(x\)-monotone curve \(c\), which may intersect some of the curves already in the arrangement <code>arr</code>, and inserts it into the arrangement by computing its zone. Users may supply a point-location object <code>pl</code> or use the default walk point-location strategy (namely, the variant <code><a class="el" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94" title="% inserts one or more curves or -monotone curves into a given arrangement, where no restrictions are ...">CGAL::insert</a>&lt;&gt;(arr, c)</code> is also available). The running-time of this insertion function is proportional to the complexity of the zone of the curve \(c\).</p>
<p> </p><div class="CGALAdvanced"> <div>Advanced</div>  In some cases users may have a prior knowledge of the location of the left endpoint of the \(x\)-monotone curve \(c\) they wish to insert, so they can perform the insertion without issuing any point-location queries. This can be done by calling the free function template <code><a class="el" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94" title="% inserts one or more curves or -monotone curves into a given arrangement, where no restrictions are ...">CGAL::insert</a>&lt;&gt;(arr, c, obj)</code>, where <code>obj</code> is a polymorphic object of type <code><a class="el" href="structCGAL_1_1Arr__point__location__result.html" title="A unary metafunction to determine the return type of a point-location or vertical ray-shoot query...">Arr_point_location_result</a>&lt;<a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&gt;::Type</code> that represents the location of \(c\)s left endpoint in the arrangement. It is a discriminated union container of the bounded types <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a47fac787fb37cd812814fbb9b6ab9acc"><code>Vertex_const_handle</code></a>, <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a22adafaff54a2c42e6c369f198870be5"><code>Halfedge_const_handle</code></a>, or <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a513a10758cc81189887d5f0a492f0245"><code>Face_const_handle</code></a>; see also Section <a class="el" href="index.html#arr_ssecpl">Point-Location Queries</a>.  </div> 
<h3><a class="anchor" id="aos_ssec-insert_gen"></a>
Inserting General Curves</h3>
<p>So far, all the examples have constructed arrangements of line segments, where the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> template was instantiated with an instance of the <code><a class="el" href="classCGAL_1_1Arr__segment__traits__2.html" title="The traits class Arr_segment_traits_2 is a model of the ArrangementTraits_2 concept, which allows the construction and maintenance of arrangements of line segments. ">Arr_segment_traits_2</a></code> class template. In this case, the restriction that <code><a class="el" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94" title="% inserts one or more curves or -monotone curves into a given arrangement, where no restrictions are ...">CGAL::insert</a>&lt;&gt;()</code> requires an \(x\)-monotone is irrelevant, as all line segments are \(x\)-monotone. (Note that we always deal with <em>weakly</em> \(x\)-monotone curves, and we consider vertical line-segments to be weakly \(x\)-monotone).</p>
<p>Consider an arrangement of circles. A circle is obviously not \(x\)-monotone, so <code><a class="el" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94" title="% inserts one or more curves or -monotone curves into a given arrangement, where no restrictions are ...">CGAL::insert</a>&lt;&gt;()</code> cannot be used in this case.<span class="footnote">A key operation performed by <code><a class="el" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94" title="% inserts one or more curves or -monotone curves into a given arrangement, where no restrictions are ...">CGAL::insert</a>&lt;&gt;()</code> is to locate the left endpoint of the curve in the arrangement. A circle, however, does not have any endpoints!</span> , it is necessary to subdivide each circle into two \(x\)-monotone circular arcs, namely, its upper half and its lower half, and to insert the two individual \(x\)-monotone arcs.</p>
<p>The free function template <code><a class="el" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94" title="% inserts one or more curves or -monotone curves into a given arrangement, where no restrictions are ...">CGAL::insert</a>&lt;&gt;()</code> is overloaded. It is possible to another version of this function and pass a curve that is not necessarily \(x\)-monotone, but this is subject to an important condition. Consider the call <a class="el" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94"><code>insert(arr, c, pl)</code></a>, where \(c\) is not necessarily \(x\)-monotone. In this case the type of <code>arr</code> must be an instance of the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt;Traits, Dcel&gt;</code> class template, where the <code>Traits</code> template parameter is substituted with a traits class that models the concept <code><a class="el" href="classArrangementTraits__2.html" title="The concept ArrangementTraits_2 allows the construction of arrangement of general planar curves...">ArrangementTraits_2</a></code>, which refines the <code><a class="el" href="classArrangementXMonotoneTraits__2.html" title="The concept ArrangementXMonotoneTraits_2 refines the basic arrangement-traits concept. A model of this concept is able to handle -monotone curves that intersect in their interior (and points that coincide with curve interiors). This is necessary for constructing arrangements of sets of intersecting -monotone curves. ">ArrangementXMonotoneTraits_2</a></code> concept. It has to define an additional <a class="el" href="classArrangementTraits__2.html#a2cb306c890ab7d32f397b5d246e0271f"><code>Curve_2</code></a> type, which may differ from the <a class="el" href="classArrangementBasicTraits__2.html#a0fc1f7acfd69a5eae393294b6870a1d2"><code>X_monotone_curve_2</code></a> type. It also has to support the subdivision of curves of this new type into \(x\)-monotone curves and possibly singular points; see the exact details in Section <a class="el" href="index.html#aos_sec-geom_traits">The Geometry Traits</a>. The <code><a class="el" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94" title="% inserts one or more curves or -monotone curves into a given arrangement, where no restrictions are ...">CGAL::insert</a>&lt;&gt;(arr, c, pl)</code> function performs the insertion of the curve \(c\) that does not need to be \(x\)-monotone, into the arrangement by subdividing it into \(x\)-monotone subcurves and inserting all individual \(x\)-monotone subcurves. Users may supply a point-location object <code>pl</code>, or use the default walk point-location strategy by calling <code><a class="el" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94" title="% inserts one or more curves or -monotone curves into a given arrangement, where no restrictions are ...">CGAL::insert</a>&lt;&gt;(arr, c)</code>.</p>
<h3><a class="anchor" id="arr_sssecinsert_point"></a>
Inserting Points</h3>
<p>The <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> class template has a member function that inserts a point as an isolated vertex in a given face. The free function template <code><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#ga13c103c1cea5249ca37ce7e0be4d97e4" title="Inserts a given point into a given arrangement. ">CGAL::insert_point</a>&lt;&gt;(arr, p, pl)</code> inserts a vertex that corresponds to the point \(p\) into <code>arr</code> at an arbitrary location. It uses the point-location object <code>pl</code> to locate the point in the arrangement (by default, the walk point-location strategy is used), and acts according to the result as follows:</p>
<ul>
<li>
<p class="startli">If \(p\) is located inside a face, it is inserted as an isolated vertex inside this face.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">If \(p\) lies on an edge, the edge is split to create a vertex associated with \(p\).</p>
<p class="endli"></p>
</li>
<li>
Otherwise, \(p\) coincides with an existing vertex and no further actions are needed. </li>
</ul>
<p>In all cases, the function returns a handle to the vertex associated with \(p\).</p>
<p>The type of <code>arr</code> must be and instance of the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> class template instantiated with a traits class that models the <code><a class="el" href="classArrangementXMonotoneTraits__2.html" title="The concept ArrangementXMonotoneTraits_2 refines the basic arrangement-traits concept. A model of this concept is able to handle -monotone curves that intersect in their interior (and points that coincide with curve interiors). This is necessary for constructing arrangements of sets of intersecting -monotone curves. ">ArrangementXMonotoneTraits_2</a></code> concept, as the insertion operation may involve the splitting of curves.</p>
<h3><a class="anchor" id="arr_sssecinsert_ex"></a>
Inserting Intersecting Line Segments (code example)</h3>
<p><a class="anchor" id="fig__aos_fig-incremental_insertion"></a></p><div class="image">
<img src="incremental_insertion.png" alt="incremental_insertion.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-incremental_insertion">Figure 34.9</a> An arrangement of five intersecting line segments, as constructed in <a class="el" href="Arrangement_on_surface_2_2incremental_insertion_8cpp-example.html">Arrangement_on_surface_2/incremental_insertion.cpp</a> and <a class="el" href="Arrangement_on_surface_2_2aggregated_insertion_8cpp-example.html">Arrangement_on_surface_2/aggregated_insertion.cpp</a>. The segment endpoints are marked by black disks and the arrangement vertices that correspond to intersection points are marked by circles. The query point \(q\) is marked with a cross and the face that contains it is shaded.  </div> <br /> 
<p>The program below constructs an arrangement of five intersecting line-segments \(s_1, \ldots, s_5\). It is known that \(s_1\) and \(s_2\) do not intersect, so <code><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225" title="Inserts a given -monotone curve into a given arrangement, where the interior of the given curve is di...">CGAL::insert_non_intersecting_curve</a>&lt;&gt;()</code> is used to insert them into the empty arrangement. The rest of the segments are inserted using <code><a class="el" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94" title="% inserts one or more curves or -monotone curves into a given arrangement, where no restrictions are ...">CGAL::insert</a>&lt;&gt;()</code>. Using a kernel that constructs geometric objects in an inexact manner (due to round-off errors) may yield a program that computes incorrect results and crashes from time to time. This is avoided by using a kernel that provides exact geometric-object constructions as well as exact geometric-predicate evaluations. The header file <code>arr_exact_construction_segments.h</code>, just like the header file <code>arr_inexact_construction_segments.h</code>, contains the definitions for arrangements of line segments. Unlike the latter, it uses a kernel suitable for arrangements induced by curves that intersect each other, namely a kernel that is exact always. Note that we alternately use the naive point-location strategy, given explicitly to the insertion functions, and the default walk point-location strategy.</p>
<p>The resulting arrangement is depicted in <a class="el" href="index.html#fig__aos_fig-incremental_insertion">Figure 34.9</a>, where the vertices that correspond to segment endpoints are drawn as dark discs, and the vertices that correspond to intersection points are drawn as circles. It consists of 13 vertices, 16 edges, and 5 faces. We also perform a point-location query on the resulting arrangement. The query point \(q\) is drawn as a plus sign. The face that contains it is drawn with a shaded texture. The program calls an instance of the function template <code>print_arrangement_size()</code>, which prints quantitative measures of the arrangement; see <a class="el" href="index.html#lst_paz">code</a>example" for its listing in Section <a class="el" href="index.html#aos_ssec-basic-arr_class">The Arrangement Class Template</a>.</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2incremental_insertion_8cpp-example.html">Arrangement_on_surface_2/incremental_insertion.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Using the global incremental insertion functions.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_naive_point_location.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_exact_construction_segments.h"</span></div><div class="line"><span class="preprocessor">#include "arr_print.h"</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__naive__point__location.html">CGAL::Arr_naive_point_location&lt;Arrangement&gt;</a>             Naive_pl;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">CGAL::Arr_point_location_result&lt;Arrangement&gt;::Type</a>      Pl_result_type;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <span class="comment">// Construct the arrangement of five intersecting segments.</span></div><div class="line">  Arrangement arr;</div><div class="line">  Naive_pl pl(arr);</div><div class="line"></div><div class="line">  Segment s1(Point(1, 0), Point(2, 4));</div><div class="line">  Segment s2(Point(5, 0), Point(5, 5));</div><div class="line">  Segment s3(Point(1, 0), Point(5, 3));</div><div class="line">  Segment s4(Point(0, 2), Point(6, 0));</div><div class="line">  Segment s5(Point(3, 0), Point(5, 5));</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> e = <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr, s1, pl);</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr, s2, pl);</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, s3, Pl_result_type(e-&gt;source()));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, s4, pl);</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, s5, pl);</div><div class="line">  print_arrangement_size(arr);</div><div class="line"></div><div class="line">  <span class="comment">// Perform a point-location query on the resulting arrangement and print</span></div><div class="line">  <span class="comment">// the boundary of the face that contains it.</span></div><div class="line">  Point q(4, 1);</div><div class="line">  <span class="keyword">auto</span> obj = pl.locate(q);</div><div class="line">  <span class="keyword">auto</span>* f = boost::get&lt;Arrangement::Face_const_handle&gt;(&amp;obj);</div><div class="line">  CGAL_assertion(f != <span class="keyword">nullptr</span>);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The query point ("</span> &lt;&lt; q &lt;&lt; <span class="stringliteral">") is located in: "</span>;</div><div class="line">  print_face&lt;Arrangement&gt;(*f);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="arr_ssseczone"></a>
Other Zone Related Functions</h2>
<p>In this section we have described so far free functions that insert curves and points into a given arrangement. Now we describe functions that do not change the arrangement at all; nevertheless, they are closely related to the incremental insertion functions, as they also use the zone framework.</p>
<p>The free function template <code>CGAL::do_intersect&lt;&gt;(arr, c, pl)</code> checks whether the given query curve \(c\) intersects the curves and points of an existing arrangement <code>arr</code>. If \(c\) is not \(x\)-monotone (that is, it is of type <a class="el" href="classArrangementTraits__2.html#a2cb306c890ab7d32f397b5d246e0271f"><code>Curve_2</code></a>) the curve is subdivided into \(x\)-monotone subcurves and isolated points. Each \(x\)-monotone curve (or point) is checked for intersection in turn using the zone framework. For points we simply apply point-location. Given an \(x\)-monotone curve, first its left endpoint is located; then, its zone is computed starting from its left endpoint location. The zone computation terminates when an intersection with an arrangement curve or point is found or when the right endpoint is reached. A given point-location object is used for locating the left endpoint of the curve in the existing arrangement. There is a variant that instead of accepting a user-defined point-location object, it constructs a local object of the walk point-location type, namely, an instance of the <code><a class="el" href="classCGAL_1_1Arr__walk__along__line__point__location.html">Arr_walk_along_line_point_location</a></code> class template, and uses it to locate the endpoint. If the given curve is \(x\)-monotone then the traits type must model the <code><a class="el" href="classArrangementXMonotoneTraits__2.html" title="The concept ArrangementXMonotoneTraits_2 refines the basic arrangement-traits concept. A model of this concept is able to handle -monotone curves that intersect in their interior (and points that coincide with curve interiors). This is necessary for constructing arrangements of sets of intersecting -monotone curves. ">ArrangementXMonotoneTraits_2</a></code> concept. If the curve is not \(x\)-monotone then the traits type must model the <code><a class="el" href="classArrangementTraits__2.html" title="The concept ArrangementTraits_2 allows the construction of arrangement of general planar curves...">ArrangementTraits_2</a></code> concept.</p>
<p>The <code><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#ga9a4a3c00a3265b9885eef9c7d5be1a7d" title="Compute the zone of the given -monotone curve in the existing arrangement. ">CGAL::zone</a>&lt;&gt;(arr, c, oi, pl)</code> function template computes the zone of a given \(x\)-monotone curve in a given arrangement. More precisely, it outputs all the arrangement cells (namely, vertices, edges, and faces) that the input \(x\)-monotone curve \(C\) intersects in the order they are discovered when traversing the curve from left to right. The function uses a given point-location object to locate the left endpoint of the given curve. There is a variant that instead of accepting a user-defined point-location object, it constructs a local object of the walk point-location type, namely, an instance of the <code><a class="el" href="classCGAL_1_1Arr__walk__along__line__point__location.html">Arr_walk_along_line_point_location</a></code> class template, and uses it to locate the endpoint. The traits type must model the <code><a class="el" href="classArrangementXMonotoneTraits__2.html" title="The concept ArrangementXMonotoneTraits_2 refines the basic arrangement-traits concept. A model of this concept is able to handle -monotone curves that intersect in their interior (and points that coincide with curve interiors). This is necessary for constructing arrangements of sets of intersecting -monotone curves. ">ArrangementXMonotoneTraits_2</a></code> concept.</p>
<h2><a class="anchor" id="arr_ssec_sweep"></a>
The Surface-Sweep Algorithm</h2>
<p>The famous plane-sweep algorithm introduced by Bentley and Ottmann was originally formulated for sets of line segments in the plane. The <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgSurfaceSweep2">2D Intersection of Curves</a> package offers a generic implementation of a generalized version of the original plane-sweep algorithm. It (i) operates in two-dimensional surfaces (not restricted to the plane), (ii) accepts various families of \(x\)-monotone curves (not only line segments), and (iii) handles overlaps. (Observe that the original algorithm did not handle overlaps. Handling overlaps is difficult, especially for polyline, as two polylines may overlap in more then one connected component.) The generic implementation serves as the foundation of a family of concrete operations described in the rest of this section, such as aggregately constructing an arrangement induced by a set of curves that lie in a two-dimensional surface and outputting the overlay of two arrangements.</p>
<p>Given a set of \(n\) input curves, you can insert the curves in the set into an arrangement incrementally one by one. However, the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgArrangementOnSurface2">2D Arrangements</a> package also provides a couple of free (overloaded) functions that aggregately insert a range of curves into an arrangement using the surface-Sweep framework.</p>
<ul>
<li>
<p class="startli"><code><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#gad4aa37a4e938747028690579fb703d67" title="Inserts a set of -monotone curves in a given range into a given arrangement. ">CGAL::insert_non_intersecting_curves</a>&lt;&gt;(arr, begin, end)</code> inserts a range of \(x\)-monotone curves given by the range <code>[begin, end)</code> into an arrangement <code>arr</code>. The \(x\)-monotone curves should be pairwise disjoint in their interior and also interior-disjoint from all existing curves and points of <code>arr</code>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94"><code>insert(arr, begin, end)</code></a> operates on a range of \(x\)-monotone curves that may intersect one another.</p>
<p class="endli"></p>
</li>
</ul>
<p>We distinguish between two cases: (i) The given arrangement <code>arr</code> is empty (has only an unbounded face), so it must be construct from scratch. (ii) The given arrangement <code>arr</code> is not empty.</p>
<p>In the first case, we sweep over the input curves, compute their intersection points, and construct the DCEL that represents their arrangement. This process is performed in \(O\left((n + k)\log n\right)\) time, where \(k\) is the total number of intersection points. The running time is asymptotically better than the time needed for incremental insertion if the arrangement is relatively sparse (when \(k\) is \(O(\frac{n^2}{\log n}\))), but it is recommended that this aggregate construction process be used even for dense arrangements, since the plane-sweep algorithm performs fewer geometric operations compared to the incremental insertion algorithms, and hence typically runs much faster in practice.</p>
<p>Another important advantage of the aggregated insertion functions is that they do not issue point-location queries. Thus, no point-location object needs to be attached to the arrangement. As explained in Section <a class="el" href="index.html#arr_ssecpl">Point-Location Queries</a>, there is a trade-off between construction time and query time in each of the point-location strategies, which affects the running times of the incremental insertion process. Naturally, this trade-off is absent in the case of aggregated insertion.</p>
<p>The example below shows how to construct the same arrangement of five line segments built incrementally in <a class="el" href="Arrangement_on_surface_2_2incremental_insertion_8cpp-example.html">Arrangement_on_surface_2/incremental_insertion.cpp</a>` depicted in <a class="el" href="index.html#fig__aos_fig-incremental_insertion">Figure 34.9</a> using the aggregate insertion function <a class="el" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94"><code>insert()</code></a>. Note that no point-location object needs to be defined and attached to the arrangement.</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2aggregated_insertion_8cpp-example.html">Arrangement_on_surface_2/aggregated_insertion.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Using the global aggregated insertion functions.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_exact_construction_segments.h"</span></div><div class="line"><span class="preprocessor">#include "arr_print.h"</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <span class="comment">// Aggregately construct the arrangement of five line segments.</span></div><div class="line">  Segment segments[] = {Segment(Point(1, 0), Point(2, 4)),</div><div class="line">                        Segment(Point(5, 0), Point(5, 5)),</div><div class="line">                        Segment(Point(1, 0), Point(5, 3)),</div><div class="line">                        Segment(Point(0, 2), Point(6, 0)),</div><div class="line">                        Segment(Point(3, 0), Point(5, 5))};</div><div class="line">  Arrangement arr;</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, segments, segments + <span class="keyword">sizeof</span>(segments)/<span class="keyword">sizeof</span>(Segment));</div><div class="line">  print_arrangement_size(arr);</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>Next we handle the case where we have to insert a set of \(n\) curves into an existing arrangement. Let \(N\) denote the number of edges in the arrangement. If \(n\) is very small compared to \(N\) (in theory, we would say that if \(n = o(\sqrt{N})\)), we insert the curves one by one. For larger input sets, we use the aggregate insertion procedures.</p>
<p><a class="anchor" id="fig__aos_fig-global_insertion"></a></p><div class="image">
<img src="global_insertion.png" alt="global_insertion.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-global_insertion">Figure 34.10</a> An arrangement of intersecting line segments, as constructed in <a class="el" href="Arrangement_on_surface_2_2global_insertion_8cpp-example.html">Arrangement_on_surface_2/global_insertion.cpp</a>. The segments of \(\mathcal{S}_1\) are drawn in solid lines and the segments of \(\mathcal{S}_2\) are drawn in dark dashed lines. Note that the segment \( s\) (light dashed line) overlaps one of the segments in \(\mathcal{S}_1\). </div> <br /> 
<p>The program below aggregately construct an arrangement of a set \(\mathcal{S}_1\) containing five line segments (drawn as solid lines). Then, it inserts a single segment \(s\) (drawn as a dotted line) using the incremental insertion function. Finally, it adds a set \(\mathcal{S}_2\) with five more line segments (drawn as dashed lines) in an aggregate fashion. Notice that the line segments of \(\mathcal{S}_1\) are pairwise interior-disjoint, so <code><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#gad4aa37a4e938747028690579fb703d67" title="Inserts a set of -monotone curves in a given range into a given arrangement. ">insert_non_intersecting_curves()</a></code> is safely used. \(\mathcal{S}_2\) also contains pairwise interior-disjoint segments, but as they intersect the existing arrangement, <a class="el" href="group__PkgArrangementOnSurface2Insert.html#ga25a2ae72727ec4c0680d20477bab7a1c"><code>insert()</code></a> must be used to insert them. Also note that the single segment \(s\) inserted incrementally partially overlaps an existing arrangement curve; the overlapped portion is drawn as a dash-dotted line.</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2global_insertion_8cpp-example.html">Arrangement_on_surface_2/global_insertion.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Using the global insertion functions (incremental and aggregated).</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_exact_construction_segments.h"</span></div><div class="line"><span class="preprocessor">#include "arr_print.h"</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  Segment S1[] = {Segment(Point(1, 3), Point(4, 6)),</div><div class="line">                  Segment(Point(1, 3), Point(6, 3)),</div><div class="line">                  Segment(Point(1, 3), Point(4, 0)),</div><div class="line">                  Segment(Point(4, 6), Point(6, 3)),</div><div class="line">                  Segment(Point(4, 0), Point(6, 3))};</div><div class="line">  Segment s = Segment(Point(0, 3), Point(4, 3));</div><div class="line">  Segment S2[] = {Segment(Point(0, 5), Point(6, 6)),</div><div class="line">                  Segment(Point(0, 4), Point(6, 5)),</div><div class="line">                  Segment(Point(0, 2), Point(6, 1)),</div><div class="line">                  Segment(Point(0, 1), Point(6, 0)),</div><div class="line">                  Segment(Point(6, 1), Point(6, 5))};</div><div class="line"></div><div class="line">  Arrangement arr;</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad4aa37a4e938747028690579fb703d67">insert_non_intersecting_curves</a>(arr, S1, S1 + <span class="keyword">sizeof</span>(S1)/<span class="keyword">sizeof</span>(Segment));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, s);                                     <span class="comment">// 1 incremental</span></div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, S2, S2 + <span class="keyword">sizeof</span>(S2)/<span class="keyword">sizeof</span>(Segment));   <span class="comment">// 5 aggregate</span></div><div class="line">  print_arrangement_size(arr);</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>We summarize the three levels of arrangement types based on curve monotonicity and intersection properties in the table below. The three levels, starting from the most restrictive, are (i) \(x\)-monotone curves that are pairwise disjoint in their interior, (ii) \(x\)-monotone curves (which are possibly intersecting one another), and (iii) general curves. We list the single-curve insertion functions.</p>
<table class="doxtable">
<tr>
<th>Type of Curves </th><th>Geometry-Traits Concept </th><th>Insertion Function </th></tr>
<tr>
<td>\(x\)-monotone and pairwise disjoint </td><td><code><a class="el" href="classArrangementBasicTraits__2.html" title="The concept ArrangementBasicTraits_2 defines the minimal set of geometric predicates needed for the c...">ArrangementBasicTraits_2</a></code> or <code><a class="el" href="classArrangementLandmarkTraits__2.html" title="The concept ArrangementLandmarkTraits_2 refines the traits concepts ArrangementApproximateTraits_2 an...">ArrangementLandmarkTraits_2</a></code> </td><td><code><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225" title="Inserts a given -monotone curve into a given arrangement, where the interior of the given curve is di...">CGAL::insert_non_intersecting_curve</a>&lt;&gt;()</code> </td></tr>
<tr>
<td>\(x\)-monotone </td><td><code><a class="el" href="classArrangementXMonotoneTraits__2.html" title="The concept ArrangementXMonotoneTraits_2 refines the basic arrangement-traits concept. A model of this concept is able to handle -monotone curves that intersect in their interior (and points that coincide with curve interiors). This is necessary for constructing arrangements of sets of intersecting -monotone curves. ">ArrangementXMonotoneTraits_2</a></code> </td><td><code>CGAL::insert&lt;&gt;()</code> </td></tr>
<tr>
<td>general </td><td><code><a class="el" href="classArrangementTraits__2.html" title="The concept ArrangementTraits_2 allows the construction of arrangement of general planar curves...">ArrangementTraits_2</a></code> </td><td><code>CGAL::insert&lt;&gt;()</code> </td></tr>
</table>
<p>The insertion function template <code>insert()</code> is overloaded to (i) incrementally insert a single \(x\)-monotone curve, (ii) incrementally insert a single general curve, (iii) aggregately insert a set of \(x\)-monotone curves, and (iv) aggregately insert a set of general curves. The <code><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#gad4aa37a4e938747028690579fb703d67" title="Inserts a set of -monotone curves in a given range into a given arrangement. ">CGAL::insert_non_intersecting_curves</a>&lt;&gt;()</code> function template aggregately inserts a set of \(x\)-monotone pairwise interior-disjoint curves into an arrangement.</p>
<h2><a class="anchor" id="arr_ssecgl_remove"></a>
Removing Vertices and Edges</h2>
<p>The free functions <code><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#gacbb4f22a59c77fb06a9d544cbbb04778" title="Attempts to removed a given vertex from a given arrangement. ">remove_vertex()</a></code> and <code><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#ga324fdf8354e7812fe0e1c0e5ac14196c" title="Removes an edge given by one of the twin halfedges that forms it, from a given arrangement. ">remove_edge()</a></code> handle the removal of vertices and edges from an arrangement, respectively. The difference between these functions and the corresponding member functions of the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> class template (see Section <a class="el" href="index.html#arr_sssecmf_iso_verts">Manipulating Isolated Vertices</a> and Section <a class="el" href="index.html#arr_sssecmf_halfedges">Manipulating Halfedges</a>) has to do with the ability to merge two curves associated with adjacent edges to form a single curve associated with a single edge. An attempt to remove a vertex or an edge from an arrangement object <code>arr</code> using the free functions above requires that the traits class used to instantiate the arrangement type of <code>arr</code> models the concept <code><a class="el" href="classArrangementXMonotoneTraits__2.html" title="The concept ArrangementXMonotoneTraits_2 refines the basic arrangement-traits concept. A model of this concept is able to handle -monotone curves that intersect in their interior (and points that coincide with curve interiors). This is necessary for constructing arrangements of sets of intersecting -monotone curves. ">ArrangementXMonotoneTraits_2</a></code>, which refines the <code><a class="el" href="classArrangementBasicTraits__2.html" title="The concept ArrangementBasicTraits_2 defines the minimal set of geometric predicates needed for the c...">ArrangementBasicTraits_2</a></code> concept; see Section <a class="el" href="index.html#aos_sec-geom_traits">The Geometry Traits</a>.</p>
<p>The function template <code><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#gacbb4f22a59c77fb06a9d544cbbb04778" title="Attempts to removed a given vertex from a given arrangement. ">CGAL::remove_vertex</a>&lt;&gt;(arr, v)</code> removes the vertex \(v\) from the given arrangement <code>arr</code>, where \(v\) is either an isolated vertex or is a <em>redundant</em> vertex. Namely, it has exactly two incident edges that are associated with two curves that can be merged to form a single \(x\)-monotone curve. If neither of the two cases apply, the function returns an indication that it has failed to remove the vertex.</p>
<p>The function <code><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#ga324fdf8354e7812fe0e1c0e5ac14196c" title="Removes an edge given by one of the twin halfedges that forms it, from a given arrangement. ">CGAL::remove_edge</a>&lt;&gt;(arr, e)</code> removes the edge \(e\) from the arrangement by simply calling <code>arr.remove_edge(e)</code>; see Section <a class="el" href="index.html#arr_ssecmodify">Modifying the Arrangement</a>. In addition, if either of the end vertices of \(e\) becomes isolated or redundant after the removal of the edge, it is removed as well.</p>
<div class="image">
<img src="global_removal.png" alt="global_removal.png" />
</div>
 <p>The following example demonstrates the usage of the free removal functions. It creates an arrangement of four line segment \(s_1, \ldots, s_4\) forming an H-shape with two horizontal edges induced by \(s_1\) and \(s_2\) (drawn as dashed lines). Then it removes the two horizontal edges and clears all redundant vertices (drawn as lightly shaded discs), such that the final arrangement consists of just two edges associated with the vertical line segments \(s_3\) and \(s_4\).</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2global_removal_8cpp-example.html">Arrangement_on_surface_2/global_removal.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Using the global removal functions.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_exact_construction_segments.h"</span></div><div class="line"><span class="preprocessor">#include "arr_print.h"</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <span class="comment">// Create an arrangement of four line segments forming an H-shape:</span></div><div class="line">  Arrangement arr;</div><div class="line"></div><div class="line">  Segment s1(Point(1, 3), Point(5, 3));</div><div class="line">  Halfedge_handle e1 = arr.insert_in_face_interior(s1, arr.unbounded_face());</div><div class="line">  Segment s2(Point(1, 4), Point(5, 4));</div><div class="line">  Halfedge_handle e2 = arr.insert_in_face_interior (s2, arr.unbounded_face());</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Segment(Point(1, 1), Point(1, 6)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Segment(Point(5, 1), Point(5, 6)));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The initial arrangement:\n"</span>;</div><div class="line">  print_arrangement(arr);</div><div class="line"></div><div class="line">  <span class="comment">// Remove e1 and its incident vertices using the function remove_edge().</span></div><div class="line">  Vertex_handle v1 = e1-&gt;source(), v2 = e1-&gt;target();</div><div class="line">  arr.remove_edge(e1);</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gacbb4f22a59c77fb06a9d544cbbb04778">remove_vertex</a>(arr, v1);</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gacbb4f22a59c77fb06a9d544cbbb04778">remove_vertex</a>(arr, v2);</div><div class="line"></div><div class="line">  <span class="comment">// Remove e2 using the free remove_edge() function.</span></div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#ga324fdf8354e7812fe0e1c0e5ac14196c">remove_edge</a>(arr, e2);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The final arrangement:\n"</span>;</div><div class="line">  print_arrangement(arr);</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="arr_ssec_decompose"></a>
Vertical Decomposition</h2>
<p>As you have already seen, an arrangement face may have a fairly complicated structure; its outer boundary may be very large, and it may contain numerous holes. For many practical applications, it is more convenient to analyze the faces by decomposing each into a finite number of cells (preferably convex when dealing with arrangements of linear curves) of constant complexity. Vertical decomposition is a generic way to achieve such a simplification of the arrangement.</p>
<p>Given an arrangement, we consider each arrangement vertex \(v\), and locate the feature lying vertically below the vertex and the feature lying vertically above it, or the unbounded face in case there is no such feature. (Such a feature is also the result of the vertical ray-shooting operation from the vertex \(v\), as described in Section <a class="el" href="index.html#arr_ssecray_shoot">Vertical Ray Shooting</a>.) It is now possible to construct two vertical segments connecting \(v\) to the feature above it and to the feature below it, possibly extending the vertical segments to infinity. The collection of the vertical segments and rays computed for all arrangement vertices induces a subdivision of the arrangement into simple cells. There are two types of bounded two-dimensional cells, as follows:</p>
<ul>
<li>
<p class="startli">Cells whose outer boundaries comprise four edges, of which two originate from the original arrangement and the other two are vertical.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Cells whose outer boundaries comprise three edges, of which two originate from the original arrangement and intersect at a common vertex and the remaining one is vertical.</p>
<p class="endli"></p>
</li>
</ul>
<p><a class="anchor" id="fig__aos_fig-bounded_vd"></a></p><div class="image">
<img src="bounded_vertical_decomposition.png" alt="bounded_vertical_decomposition.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-bounded_vd">Figure 34.11</a> An arrangement of four line segments and its vertical decomposition into pseudo trapezoids, as constructed in <a class="el" href="Arrangement_on_surface_2_2bounded_vertical_decomposition_8cpp-example.html">Arrangement_on_surface_2/bounded_vertical_decomposition.cpp</a>. The segments of \(\mathcal{S}_1\) are drawn in solid lines and the segments of \(\mathcal{S}_2\) are drawn in dark dashed lines. Note that the segment \( s\) (light dashed line) overlaps one of the segments in \(\mathcal{S}_1\).  </div> <br /> 
<p>In the case of an arrangement of line segments, two-dimensional cells of the former type are trapezoids (as they have a pair of parallel vertical edges), while two-dimensional cells of the latter type are triangles, which can be viewed as degenerate trapezoids. The unbounded cells can be similarly categorized into two types. Observe that the boundary of an unbounded cell contains only one original edge or none and it may contain only non-vertical edges. The resulting cells are therefore referred to as <em>pseudo trapezoids</em>. The <a class="el" href="index.html#fig__aos_fig-bounded_vd">Figure 34.11</a> depicts the vertical decomposition of an arrangement induced by four line segments, as constructed in <a class="el" href="Arrangement_on_surface_2_2bounded_vertical_decomposition_8cpp-example.html">Arrangement_on_surface_2/bounded_vertical_decomposition.cpp</a> and listed below. The decomposition consists of 14 pseudo trapezoids, out of which two are bounded triangles, two are bounded trapezoids, and 10 are unbounded trapezoids.</p>
<p>The function template <code><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#gae20b2917f6de15db9bf025f83abf8e89" title="Produces the symbolic vertical decomposition of a given arrangement, performing a batched vertical ra...">decompose()</a></code> accepts an arrangement \(\mathcal{A}\) and outputs for each vertex \(v\) of \(\mathcal{A}\) a pair of features—one that directly lies below \(v\) and another that directly lies above \(v\). It is implemented as a plane-sweep algorithm, which aggregately computes the set of pairs of features. Let \(v\) be a vertex of \(\mathcal{A}\). The feature above (respectively below) \(v\) may be one of the following:</p>
<ul>
<li>
<p class="startli">Another vertex \(u\) having the same \(x\)-coordinate as \(v\).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">An arrangement edge associated with an \(x\)-monotone curve that contains \(v\) in its \(x\)-range.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">An unbounded face in case \(v\) is incident to an unbounded face, and there is no curve lying above (respectively below) it.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">An empty object, in case \(v\) is the lower (respectively upper) endpoint of a vertical edge in the arrangement.</p>
<p class="endli"></p>
</li>
</ul>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2bounded_vertical_decomposition_8cpp-example.html">Arrangement_on_surface_2/bounded_vertical_decomposition.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Performing vertical decomposition of an arrangement.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_vertical_decomposition_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_exact_construction_segments.h"</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::pair&lt;CGAL::Object, CGAL::Object&gt;           Object_pair;</div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Vertex_const_handle, Object_pair&gt;     Vert_decomp_entry;</div><div class="line"><span class="keyword">typedef</span> std::list&lt;Vert_decomp_entry&gt;                    Vert_decomp_list;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <span class="comment">// Construct the arrangement.</span></div><div class="line">  Segment segments[] = {Segment(Point(0, 0), Point(3, 3)),</div><div class="line">                        Segment(Point(3, 3), Point(6, 0)),</div><div class="line">                        Segment(Point(2, 0), Point(5, 3)),</div><div class="line">                        Segment(Point(5, 3), Point(8, 0))};</div><div class="line">  Arrangement arr;</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, segments, segments + <span class="keyword">sizeof</span>(segments)/<span class="keyword">sizeof</span>(Segment));</div><div class="line"></div><div class="line">  <span class="comment">// Perform vertical ray-shooting from every vertex and locate the feature</span></div><div class="line">  <span class="comment">// that lie below it and the feature that lies above it.</span></div><div class="line">  Vert_decomp_list vd_list;</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gae20b2917f6de15db9bf025f83abf8e89">CGAL::decompose</a>(arr, std::back_inserter(vd_list));</div><div class="line"></div><div class="line">  <span class="comment">// Print the results.</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> vd_iter = vd_list.begin(); vd_iter != vd_list.end(); ++vd_iter) {</div><div class="line">    <span class="keyword">const</span> Object_pair&amp; curr = vd_iter-&gt;second;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Vertex ("</span> &lt;&lt; vd_iter-&gt;first-&gt;point() &lt;&lt; <span class="stringliteral">") : "</span>;</div><div class="line"></div><div class="line">    Vertex_const_handle vh;</div><div class="line">    Halfedge_const_handle hh;</div><div class="line">    Face_const_handle fh;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">" feature below: "</span>;</div><div class="line">    <span class="keywordflow">if</span> (CGAL::assign(hh, curr.first)) std::cout &lt;&lt; <span class="charliteral">'['</span> &lt;&lt; hh-&gt;curve() &lt;&lt; <span class="charliteral">']'</span>;</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (CGAL::assign(vh, curr.first))</div><div class="line">      std::cout &lt;&lt; <span class="charliteral">'('</span> &lt;&lt; vh-&gt;point() &lt;&lt; <span class="charliteral">')'</span>;</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (CGAL::assign(fh, curr.first)) std::cout &lt;&lt; <span class="stringliteral">"NONE"</span>;</div><div class="line">    <span class="keywordflow">else</span> std::cout &lt;&lt; <span class="stringliteral">"EMPTY"</span>;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"   feature above: "</span>;</div><div class="line">    <span class="keywordflow">if</span> (CGAL::assign(hh, curr.second))</div><div class="line">      std::cout &lt;&lt; <span class="charliteral">'['</span> &lt;&lt; hh-&gt;curve() &lt;&lt; <span class="stringliteral">"]\n"</span>;</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (CGAL::assign(vh, curr.second))</div><div class="line">      std::cout &lt;&lt; <span class="charliteral">'('</span> &lt;&lt; vh-&gt;point() &lt;&lt; <span class="stringliteral">")\n"</span>;</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (CGAL::assign(fh, curr.second)) std::cout &lt;&lt; <span class="stringliteral">"NONE\n"</span>;</div><div class="line">    <span class="keywordflow">else</span> std::cout &lt;&lt; <span class="stringliteral">"EMPTY\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>As you might have noticed, the code above contains a call to an instance of a the function template <code>read_objects()</code>. It reads the description of geometric objects from a file and constructs them. It accepts the name of an input file that contains the plain-text description of the geometric objects and an output iterator for storing the newly constructed objects. When the function is instantiated, the first template parameter, namely Type`, must be substituted with the type of objects to read. It is assumed that an extractor operator (<code>&gt;&gt;</code>) that extracts objects of the given type from the input stream is available. The listing of the function template, which is defined in the file <code>read_objects.h</code>, is omitted here</p>
<p> </p><div class="CGALAdvanced"> <div>Advanced</div> 
<p>In Section <a class="el" href="index.html#aos_sec-unbounded">Arrangements of Unbounded Curves</a> you will learn that we also support arrangements induced by unbounded curves, referred to as <em>unbounded arrangements</em>. For such an arrangement we maintain an imaginary rectangle with left, right, bottom, and top boundaries, which bound the concrete vertices and edges of the arrangement. Halfedges that represent the boundaries of the rectangle are <em>fictitious</em>. The <code><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#gae20b2917f6de15db9bf025f83abf8e89" title="Produces the symbolic vertical decomposition of a given arrangement, performing a batched vertical ra...">decompose()</a></code> function template handles unbounded arrangements. If \(v\) is a vertex of an unbounded arrangement, and \(v\) is incident to an unbounded face and there is no curve lying above (respectively below) it, the feature above (respectively below) \(v\) returned by the function template <code><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#gae20b2917f6de15db9bf025f83abf8e89" title="Produces the symbolic vertical decomposition of a given arrangement, performing a batched vertical ra...">decompose()</a></code> is a fictitious edge.</p>
<p> </p></div> 
<h1><a class="anchor" id="aos_sec-unbounded"></a>
Arrangements of Unbounded Curves</h1>
<p>All the arrangements constructed and manipulated in previous chapters were induced only by line segments, which are, in particular, bounded curves. Such arrangements always have one unbounded face that contains all other arrangement features. In this section we explain how to construct arrangements of unbounded curves. For simplicity of exposition, we stay with linear objects and restrict our examples in this section to lines and rays. However, the discussion in this section, as well as the software described, apply more generally to arbitrary curves in two-dimensional surfaces.</p>
<h2><a class="anchor" id="aos_ssec-unbounded-rep"></a>
Representing Arrangements of Unbounded Curves</h2>
<p>Given a set \(\mathcal{C}\) of unbounded curves, a simple approach for representing the arrangement induced by \(\mathcal{C}\) would be to clip the unbounded curves using an axis-parallel rectangle that contains all finite curve endpoints and intersection points between curves in \(\mathcal{C}\). This process would result in a set of bounded curves (line segments if \(\mathcal{C}\) consists of lines and rays), and it would be straightforward to compute the arrangement induced by this set. However, we would like to operate directly on the unbounded curves without having to preprocess them. Moreover, if we are not given all the curves inducing the arrangement in advance, then the choice of a good bounding rectangle may change as more curves are introduced.</p>
<p><a class="anchor" id="fig__aos_fig-unb_dcel"></a></p><div class="image">
<img src="unb_dcel.png" alt="unb_dcel.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-unb_dcel">Figure 34.12</a> A DCEL representing an arrangement of four lines. Halfedges are drawn as thin arrows. The vertices \(v_1, \ldots, v_8\) lie at infinity, and are not associated with valid points. The halfedges that connect them are fictitious, and are not associated with concrete curves. The face denoted \(f_0\) (lightly shaded) is the fictitious "unbounded face" which lies outside the bounding rectangle (dashed) that bounds the actual arrangement. The four fictitious vertices \(v_{\rm bl}, v_{\rm tl}, v_{\rm br}\) and \(v_{\rm tr}\) represent the four corners of the imaginary bounding rectangle.  </div> <br /> 
<p>Instead of an explicit approach, we use an implicit bounding rectangle embedded in the DCEL structure. <a class="el" href="index.html#fig__aos_fig-unb_dcel">Figure 34.12</a> shows the arrangement of four lines that subdivide the plane into eight unbounded faces and two bounded ones. Notice that in this case portions of the the unbounded faces now have outer boundaries (those portions inside the bounding rectangle), and the halfedges along these outer CCBs are drawn as arrows. The bounding rectangle is drawn dashed. The vertices \(v_1,v_2,\ldots,v_8\), which lie on the bounding rectangle, represent the unbounded ends of the four lines that approach infinity. The halfedges connecting them, which overlap with the bounding rectangle, are not associated with geometric curves. Thus, we refer to them as <em>fictitious</em>. Note that the outer CCBs of the unbounded faces contain fictitious halfedges. The twins of these halfedges form together one connected component that corresponds to the entire imaginary rectangle. It forms a single hole in the face \(\tilde{f}\). We refer to \(\tilde{f}\) as <em>fictitious</em>, since it does not correspond to a real two-dimensional cell of the arrangement. Finally, there are four additional vertices denoted by \(v_{\rm bl}, v_{\rm tl}, v_{\rm br}\), and \(v_{\rm tr}\), which coincide with the bottom-left, top-left, bottom-right, and top-right corners of the bounding rectangle, respectively. They do not lie on any curve, and are referred to as <em>fictitious</em> as well. These four vertices identify each of the fictitious edges as lying on the top, the bottom, the left, and the right edge of the imaginary bounding rectangle. The four fictitious vertices exist even when the arrangement is empty: In this case they are connected by four pairs of fictitious halfedges that define a single unbounded face (which represents the entire \(\mathbb{R}^2\) plane) lying inside the imaginary bounding rectangle and a fictitious face lying outside.</p>
<p>In summary, there are four types of arrangement vertices, which differ from one another by their location with respect to the imaginary bounding rectangle as follows:</p>
<ol>
<li>
<p class="startli"><a class="anchor" id="type-normal"></a>A vertex, associated with a point in \(\mathbb{R}^2\). Such a vertex always lies inside the bounding rectangle and has bounded coordinates..</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="anchor" id="type-unbounded"></a>A vertex that represents an unbounded end of an \(x\)-monotone curve that approaches \(x = -\infty\) or at \(x = \infty\). In case of a horizontal line or a curve with a horizontal asymptote, the \(y\)-coordinate of the curve end may be finite (see, for example, the vertices \(v_2\) and \(v_7\) in <a class="el" href="index.html#fig__aos_fig-unb_dcel">Figure 34.12</a>), but in general the curve end also approaches \(y = \pm\infty\); see for instance the vertices \(v_1\), \(v_3\), \(v_6\) and \(v_8\) in <a class="el" href="index.html#fig__aos_fig-unb_dcel">Figure 34.12</a>). For convenience, we always take a "tall" enough bounding rectangle and treat such vertices as lying on either the left or the right rectangle edges (that is, if a curve approaches \(x = -\infty\), its left end will be represented by a vertex on the left edge of the bounding rectangle, and if it approaches \(x = \infty\), its right end will be represented by a vertex on the right edge).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="anchor" id="typeunboundedvertical"></a>A vertex that represents the unbounded end of a vertical linear curve (line or ray) or of a curve with a vertical asymptote (finite \(x\)-coordinate and an unbounded \(y\)-coordinate). Such a vertex always lies on one of the horizontal edges of the bounding rectangle (either the bottom one if \(y = -\infty\), or the top one if \(y = \infty\)). The vertices \(v_4\) and \(v_5\) in <a class="el" href="index.html#fig__aos_fig-unb_dcel">Figure 34.12</a> are of this type.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="anchor" id="typefictitious"></a>The fictitious vertices that represent the four corners of the bounding rectangle.</p>
<p class="endli"></p>
</li>
</ol>
<p><a class="anchor" id="fig__aos_fig-unb_asymptote"></a></p><div class="image">
<img src="unb_asymptote.png" alt="unb_asymptote.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-unb_asymptote">Figure 34.13</a> The portions of a horizontal line, a vertical line, and two rectangular hyperbolas with horizontal and vertical asymptotes confined to the imaginary bounding rectangle.  </div> <br /> 
<p>A vertex (at infinity) of Type 2 or Type 3 above always has three incident edges—one concrete edge that is associated with an unbounded portion of an \(x\)-monotone curve, and two fictitious edges connecting the vertex to its neighboring vertices at infinity or the corners of the bounding rectangle; see <a class="el" href="index.html#fig__aos_fig-unb_asymptote">Figure 34.13</a>. Fictitious vertices (of type 4 above) have exactly two incident fictitious edges. See Section <a class="el" href="index.html#aos_sec-geom_traits">The Geometry Traits</a> for an explanation on how the traits-class interface helps impose the fact that a vertex at infinity is incident to a single non-fictitious edge.</p>
<p>The traits class that substitutes the <code>Traits</code> parameter of the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt;Traits,Dcel&gt;</code> class template when the latter is instantiated specifies whether the arrangement instance supports unbounded curves through the definitions of some tags nested in the traits class; see Section <a class="el" href="index.html#aos_sssec-geom_traits-concepts_basic">The Basic Concept</a> for details. Every arrangement that supports unbounded curves supports bounded curves as well, but not vice versa. Maintaining an arrangement that supports unbounded curves incurs an overhead due to the necessity to manage the imaginary bounding rectangle. If you know beforehand that all input curves that induce a particular arrangement are bounded, define your arrangement accordingly. That is, use a traits class that does not support unbounded curves.</p>
<h3><a class="anchor" id="arr_sssecunb_basic"></a>
Basic Manipulation and Traversal Methods</h3>
<p>The types <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex.html"><code>Vertex</code></a>, <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge.html"><code>Halfedge</code></a>, and <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Face.html"><code>Face</code></a> nested in the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> class template support the methods described below in addition to the ones listed in Section <a class="el" href="index.html#arr_ssectraverse">Traversing the Arrangement</a>. Let \(v\), \(e\), and \(f\) be handles to a vertex of type <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex.html"><code>Vertex</code></a>, a halfedge of type <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge.html"><code>Halfedge</code></a>, and a face of type <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Face.html"><code>Face</code></a>, respectively.</p>
<ul>
<li>
<p class="startli">The calls <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex.html#aa324ce50ac500bc80bf74abad4b22d78"><code>v-&gt;parameter_space_in_x()</code></a> and <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex.html#acdc784d286542020869d294adc6101eb"><code>v-&gt;parameter_space_in_y()</code></a> determine the location of the geometric embedding of the vertex \(v\). The call <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex.html#aa324ce50ac500bc80bf74abad4b22d78"><code>v-&gt;parameter_space_in_x()</code></a> returns <code><a class="el" href="group__PkgArrangementOnSurface2Enums.html#gad93bd71ee623a2e4fded635967e9c8d2">CGAL::ARR_INTERIOR</a></code> if the \(x\)-coordinate associated with \(v\) is finite, <code><a class="el" href="group__PkgArrangementOnSurface2Enums.html#ga2bbdd8004c0a37409305b01cf7fc2563">CGAL::ARR_LEFT_BOUNDARY</a></code> if \(v\) represents the end of a curve the \(x\)-coordinate of which approaches \(-\infty\), and <code><a class="el" href="group__PkgArrangementOnSurface2Enums.html#ga341fb5c90e8037d651012f955e38fda1">CGAL::ARR_RIGHT_BOUNDARY</a></code> if \(v\) represents the end of a curve the \(x\)-coordinate of which approaches \(\infty\). Similarly, the call <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex.html#acdc784d286542020869d294adc6101eb"><code>v-&gt;parameter_space_in_y()</code></a> returns <code><a class="el" href="group__PkgArrangementOnSurface2Enums.html#gad93bd71ee623a2e4fded635967e9c8d2">CGAL::ARR_INTERIOR</a></code> if the \(y\)-coordinate associated with \(v\) is finite and <code><a class="el" href="group__PkgArrangementOnSurface2Enums.html#gaf276ca43e83c8791923154aba4584651">CGAL::ARR_BOTTOM_BOUNDARY</a></code> or <code><a class="el" href="group__PkgArrangementOnSurface2Enums.html#gaf8d89294c23614f33351e94ff28e0d59">CGAL::ARR_TOP_BOUNDARY</a></code> if \(v\) represents the end of a curve the \(y\)-coordinate of which approaches \(-\infty\) or \(\infty\), respectively.</p>
<p>The nested <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex.html"><code>Vertex</code></a> type also provides the Boolean predicate <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex.html#ad5c3177a4fd6417300001eb286c5bc9f"><code>is_at_open_boundary()</code></a>. If the call <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex.html#ad5c3177a4fd6417300001eb286c5bc9f"><code>v-&gt;is_at_open_boundary()</code></a> predicates evaluates to <code>false</code>, you can access the point associated with \(v\). Otherwise, \(v\) is not associated with a <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#aed833c3b69b94eae54994439d70a83a2"><code>Point_2</code></a> object, as it represents the unbounded end of a curve that approaches infinity.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The nested <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge.html"><code>Halfedge</code></a> type provides the Boolean predicate <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge.html#a3ee455b495c2ee20fc55403d60978004"><code>is_fictitious()</code></a>. If the call <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge.html#a3ee455b495c2ee20fc55403d60978004"><code>e-&gt;is_fictitious()</code></a> evaluates to <code>false</code>, you can access the \(x\)-monotone curve associated with \(e\). Otherwise, \(e\) is not associated with an <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#ad7f12c4c83fa1d83a3f0d5ceb16c21e1"><code>X_monotone_curve_2</code></a> object.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The nested <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Face.html"><code>Face</code></a> type provides the Boolean predicate <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Face.html#adec2dd3f9fb8d7364c8ac7370f721be2"><code>is_fictitious()</code></a>. The call <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Face.html#adec2dd3f9fb8d7364c8ac7370f721be2"><code>f-&gt;is_fictitious()</code></a> evaluates to <code>true</code> only when \(f\) lies outside the bounding rectangle. The method <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Face.html#a2fffc48e24aaa154122504983d771f1c"><code>outer_ccb()</code></a> (see Section <a class="el" href="index.html#arr_sssectr_face">Traversal Methods for an Arrangement Face</a> must not be invoked for the fictitious face. <span class="footnote">Typically, the code is guarded against such malicious calls with adequate preconditions. However, these preconditions are suppressed when the code is compiled with maximum optimization.</span> Note that a valid unbounded face (of an arrangement that supports unbounded curves) has a valid outer CCB, although the CCB comprises only fictitious halfedges if the arrangement is induced only by bounded curves.</p>
<p class="endli"></p>
</li>
</ul>
<p>Let \(p_l = (x_l,y_l)\) and \(p_r = (x_r,y_r)\) be the left and right endpoints of a bounded \(x\)-monotone curve \(c\), respectively. We say that a point \(p = (x_p,y_p)\) lies in the \(x\)-range of \(c\) if \(x_l \leq x_p \leq x_r\). Let \(p_l = (x_l,y_l)\) be the left endpoint of an \(x\)-monotone curve \(c\) unbounded from the right. A point \(p = (x_p,y_p)\) lies in the \(x\)-range of \(c\) if \(x_l \leq x_p\). Similarly, A point \(p = (x_p,y_p)\) lies in the \(x\)-range of an \(x\)-monotone curve unbounded from the left if \(x_p \leq x_r\). Naturally, every point \(p \in \mathbb{R}^2\) is in the \(x\)-range of an \(x\)-monotone curve unbounded from the left and from the right.</p>
<p> </p><div class="CGALAdvanced"> <div>Advanced</div> 
<p>The function template <code>is_in_x_range()</code> listed below, and defined in the file <code>is_in_x_range.h</code>, checks whether a given point \(p\) is in the \(x\)-range of the curve associated with a given halfedge \(e\). The function template also exemplifies how some of the above functions can be used. The traits functor <a class="el" href="classArrangementBasicTraits__2.html#a50f0e201b051be81f31257feab0cdab7"><code>Compare_x_2</code></a> used in the code is described in Section <a class="el" href="index.html#aos_sssec-geom_traits-concepts_basic">The Basic Concept</a>.</p>
<div class="fragment"><div class="line"><span class="comment">// Check whether the given point is in the x-range of the curve associated</span></div><div class="line"><span class="comment">// with the given halfedge.</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Arrangement&gt;</div><div class="line"><span class="keywordtype">bool</span> is_in_x_range(<span class="keyword">typename</span> Arrangement::Halfedge_const_handle he,</div><div class="line">                   <span class="keyword">const</span> <span class="keyword">typename</span> Arrangement::Point_2&amp; p,</div><div class="line">                   <span class="keyword">const</span> <span class="keyword">typename</span> Arrangement::Traits_2&amp; traits)</div><div class="line">{</div><div class="line">  <span class="keyword">auto</span> cmp = traits.compare_x_2_object();</div><div class="line"></div><div class="line">  <span class="comment">// Compare p with the source vertex (which may lie at x = +/- oo).</span></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga69d3e68aa488b8927506333b04400bdf">CGAL::Arr_parameter_space</a> src_px = e-&gt;source()-&gt;parameter_space_in_x();</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga84351c7e66be00efccd4ab1a61070469">CGAL::Comparison_result</a> res_s =</div><div class="line">    (src_px == <a class="code" href="group__PkgArrangementOnSurface2Enums.html#ga2bbdd8004c0a37409305b01cf7fc2563">CGAL::ARR_LEFT_BOUNDARY</a>) ? <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gga84351c7e66be00efccd4ab1a61070469ab925c6b1ff8cd0bdea7f31fe18d3c38b">CGAL::SMALLER</a> :</div><div class="line">    ((src_px == <a class="code" href="group__PkgArrangementOnSurface2Enums.html#ga341fb5c90e8037d651012f955e38fda1">CGAL::ARR_RIGHT_BOUNDARY</a>) ? <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gga84351c7e66be00efccd4ab1a61070469ab25bdbfd193e9ea35187a4f46e7d6fcd">CGAL::LARGER</a> :</div><div class="line">     cmp(e-&gt;source()-&gt;point(), p));</div><div class="line">  <span class="keywordflow">if</span> (res_s == <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gga84351c7e66be00efccd4ab1a61070469a5f224784e56ca565837a5d6d268fe078">CGAL::EQUAL</a>) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Compare p with the target vertex (which may lie at x = +/- oo).</span></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga69d3e68aa488b8927506333b04400bdf">CGAL::Arr_parameter_space</a> trg_px = e-&gt;target()-&gt;parameter_space_in_x();</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga84351c7e66be00efccd4ab1a61070469">CGAL::Comparison_result</a>  res_t =</div><div class="line">    (trg_px == <a class="code" href="group__PkgArrangementOnSurface2Enums.html#ga2bbdd8004c0a37409305b01cf7fc2563">CGAL::ARR_LEFT_BOUNDARY</a>) ? <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gga84351c7e66be00efccd4ab1a61070469ab925c6b1ff8cd0bdea7f31fe18d3c38b">CGAL::SMALLER</a> :</div><div class="line">    ((trg_px == <a class="code" href="group__PkgArrangementOnSurface2Enums.html#ga341fb5c90e8037d651012f955e38fda1">CGAL::ARR_RIGHT_BOUNDARY</a>) ? <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gga84351c7e66be00efccd4ab1a61070469ab25bdbfd193e9ea35187a4f46e7d6fcd">CGAL::LARGER</a> :</div><div class="line">     cmp(e-&gt;target()-&gt;point(), p));</div><div class="line"></div><div class="line">  <span class="comment">// p lies in the x-range of the halfedge iff its source and target lie</span></div><div class="line">  <span class="comment">// at opposite x-positions.</span></div><div class="line">  <span class="keywordflow">return</span> (res_s != res_t);</div><div class="line">}</div></div><!-- fragment --><p> </p></div> 
<p>It is important to observe that the call <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a07afeb623d32ef12745c9b368233e4ea"><code>arr.number_of_vertices()</code></a> does not count the vertices at infinity in the arrangement <code>arr</code>. To find out this number you need to issue the call <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a6456e981d377cd6a13b0df360f3a455d"><code>arr.number_of_vertices_at_infinity()</code></a>. Similarly, <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#ab8c9db7c49f1d4860cd47094a08a6779"><code>arr.number_of_edges()</code></a> does not count the fictitious edges (whose number is always <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a6456e981d377cd6a13b0df360f3a455d"><code>arr.number_of_vertices_at_infinity()</code></a> + 4) and <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#ac8de48159182ed1dc27d508171c3adb7"><code>arr.number_of_faces()</code></a> does not count the fictitious faces. The vertex, halfedge, edge, and face iterators defined by the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> class template only go over true features of the arrangement; namely, vertices at infinity and fictitious halfedges and fictitious faces are skipped. On the other hand, the <code>Ccb_halfedge_circulator</code> of the outer boundary of an unbounded face or the <code>Halfedge_around_vertex_circulator</code> of a vertex at infinity do traverse fictitious halfedges. While an arrangement induced by bounded curves has a single unbounded face, an arrangement induced by unbounded curves may have several unbounded faces. The call <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#abeed5715498a29e1e7f869346998ce5d"><code>arr.number_of_unbounded_faces()</code></a> returns the number of unbounded arrangement faces (Thus, <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#ac8de48159182ed1dc27d508171c3adb7"><code>arr.number_of_faces()</code></a> - <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#abeed5715498a29e1e7f869346998ce5d"><code>arr.number_of_unbounded_faces()</code></a> is the number of bounded faces). The calls <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a1807df960b1c3ebdb7e9afd2443b8651"><code>arr.unbounded_faces_begin()</code></a> and <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a35f815859d85d7b465a4e37129aaa08f"><code>arr.unbounded_faces_end()</code></a> return iterators of the type <code><a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a498b04d51254fac9c16472d2de9412f1" title="a bidirectional iterator over the unbounded faces of arrangement. ">Arrangement_on_surface_2::Unbounded_face_iterator</a></code> (or its non-mutable, <code>const</code>, counterpart type) that define the range of the arrangement unbounded faces. Naturally, the value-type of this iterator is <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Face.html"><code>Face</code></a>.</p>
<p>There is no way to directly obtain the fictitious vertices that represent the four corners of the imaginary bounding rectangle. However, you can obtain the fictitious face through the call <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#aaf85591f55aa56e0cd01dbed708cc691"><code>arr.fictitious_face()</code></a>, and then iterate over the boundary of its single hole, which represents the imaginary bounding rectangle. Recall that an arrangement of bounded curves does not have a fictitious face. In this case the call above returns a null handle.</p>
<p>The example below exhibits the difference between an arrangement induced by bounded curves, which has a single unbounded face, and an arrangement induced by unbounded curves, which may have several unbounded faces. It also demonstrates the usage of the insertion function for pairwise interior-disjoint unbounded curves. In this case we use an instance of the traits class-template <code><a class="el" href="classCGAL_1_1Arr__linear__traits__2.html" title="The traits class Arr_linear_traits_2 is a model of the ArrangementTraits_2 concept, which enables the construction and maintenance of arrangements of linear objects. ">Arr_linear_traits_2</a>&lt;<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>&gt;</code> to substitute the <code>Traits</code> parameter of the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt;Traits,Dcel&gt;</code> class template when instantiated. This traits class-template is capable of representing line segments as well as unbounded linear curves, namely, lines and rays. Observe that objects of the <a class="el" href="classCGAL_1_1Arr__linear__traits__2_1_1X__monotone__curve__2.html"><code>X_monotone_curve_2</code></a> type nested in this traits class-template are constructible from objects of types <a class="el" href="classCGAL_1_1Arr__linear__traits__2.html#ac164fa9f286510a6f82b6d19f1337ea7"><code>Line_2</code></a>, <a class="el" href="classCGAL_1_1Arr__linear__traits__2.html#a9fabc6237c3e8eecaaaec8294d89ed24"><code>Ray_2</code></a>, and <a class="el" href="classCGAL_1_1Arr__linear__traits__2.html#a85c800b80f8a138ce592325131c7e9f4"><code>Segment_2</code></a> also nested in the traits class-template. These three types and the <a class="el" href="classCGAL_1_1Arr__linear__traits__2.html#a0cfd7a27d192fbad2e7756429ed64ef8"><code>Point_2</code></a> type are defined by the traits class-template <code><a class="el" href="classCGAL_1_1Arr__linear__traits__2.html" title="The traits class Arr_linear_traits_2 is a model of the ArrangementTraits_2 concept, which enables the construction and maintenance of arrangements of linear objects. ">Arr_linear_traits_2</a>&lt;<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>&gt;</code> to be the corresponding types of the kernel used to instantiate the traits class-template; see Paragraph <a class="el" href="index.html#arr_sssectr_linear">The Linear-Traits Class</a>.</p>
<p><a class="anchor" id="fig__aos_fig-unbounded_non_intersecting"></a></p><div class="image">
<img src="unbounded_non_intersecting.png" alt="unbounded_non_intersecting.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-unbounded_non_intersecting">Figure 34.14</a> An arrangement of unbounded linear objects, as constructed in <a class="el" href="Arrangement_on_surface_2_2unbounded_non_intersecting_8cpp-example.html">Arrangement_on_surface_2/unbounded_non_intersecting.cpp</a>.  </div> <br /> 
<p>The first three curves, \(c_1\), \(c_2\), and \(c_3\), are inserted using the specialized insertion functions for \(x\)-monotone curves whose location in the arrangement is known. Notice that inserting an unbounded curve in the interior of an unbounded face, or from an existing vertex that represents an bounded end of the curve, may cause an unbounded face to split. (This is never the case when inserting a bounded curve—compare with Section <a class="el" href="index.html#arr_sssecmf_insert_cv">Inserting Pairwise Disjoint x-Monotone Curves</a>.) Three additional rays are then inserted incrementally using the insertion function for \(x\)-monotone curves, the interior of which is disjoint from all arrangement features; see the illustration in <a class="el" href="index.html#fig__aos_fig-unbounded_non_intersecting">Figure 34.14</a>). Finally, the program prints the size of the arrangement using the function template <code>print_unbounded_arrangement_size()</code> defined in the header file <code>arr_print.h</code>. (Its listing is omitted here.) The program also traverses the outer boundaries of its six unbounded faces and prints the curves along these boundaries. The header file <code>arr_linear.h</code>, which contains the definitions used by the example program, is listed immediately after the listing of the main function.</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2unbounded_non_intersecting_8cpp-example.html">Arrangement_on_surface_2/unbounded_non_intersecting.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Constructing an arrangement of unbounded linear objects using the insertion</span></div><div class="line"><span class="comment">// function for non-intersecting curves.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_linear.h"</span></div><div class="line"><span class="preprocessor">#include "arr_print.h"</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  Arrangement arr;</div><div class="line"></div><div class="line">  <span class="comment">// Insert a line in the (currently single) unbounded face of the arrangement;</span></div><div class="line">  <span class="comment">// then, insert a point that lies on the line splitting it into two.</span></div><div class="line">  X_monotone_curve c1 = Line(Point(-1, 0), Point(1, 0));</div><div class="line">  arr.insert_in_face_interior(c1, arr.unbounded_face());</div><div class="line">  Vertex_handle v = <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#ga13c103c1cea5249ca37ce7e0be4d97e4">insert_point</a>(arr, Point(0,0));</div><div class="line">  CGAL_assertion(! v-&gt;is_at_open_boundary());</div><div class="line"></div><div class="line">  <span class="comment">// Add two more rays using the specialized insertion functions.</span></div><div class="line">  arr.insert_from_right_vertex(Ray(Point(0, 0), Point(-1, 1)), v); <span class="comment">// c2</span></div><div class="line">  arr.insert_from_left_vertex(Ray(Point(0, 0), Point(1, 1)), v);   <span class="comment">// c3</span></div><div class="line"></div><div class="line">  <span class="comment">// Insert three more interior-disjoint rays, c4, c5, and c6.</span></div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr, Ray(Point(0, -1), Point(-2, -2)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr, Ray(Point(0, -1), Point(2, -2)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr, Ray(Point(0, 0), Point(0, 1)));</div><div class="line"></div><div class="line">  print_unbounded_arrangement_size(arr);</div><div class="line"></div><div class="line">  <span class="comment">// Print the outer CCBs of the unbounded faces.</span></div><div class="line">  <span class="keywordtype">int</span> k = 1;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = arr.unbounded_faces_begin(); it != arr.unbounded_faces_end();</div><div class="line">       ++it)</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Face no. "</span> &lt;&lt; k++ &lt;&lt; <span class="stringliteral">"("</span> &lt;&lt; it-&gt;is_unbounded() &lt;&lt; <span class="stringliteral">","</span></div><div class="line">              &lt;&lt; it-&gt;number_of_holes() &lt;&lt; <span class="stringliteral">")"</span> &lt;&lt; <span class="stringliteral">": "</span>;</div><div class="line">    Arrangement::Ccb_halfedge_const_circulator first = it-&gt;outer_ccb();</div><div class="line">    <span class="keyword">auto</span> curr = first;</div><div class="line">    <span class="keywordflow">if</span> (! curr-&gt;source()-&gt;is_at_open_boundary())</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">"("</span> &lt;&lt; curr-&gt;source()-&gt;point() &lt;&lt; <span class="stringliteral">")"</span>;</div><div class="line"></div><div class="line">    <span class="keywordflow">do</span> {</div><div class="line">      Arrangement::Halfedge_const_handle e = curr;</div><div class="line">      <span class="keywordflow">if</span> (! e-&gt;is_fictitious()) std::cout &lt;&lt; <span class="stringliteral">" ["</span> &lt;&lt; e-&gt;curve() &lt;&lt; <span class="stringliteral">"] "</span>;</div><div class="line">      <span class="keywordflow">else</span> std::cout &lt;&lt; <span class="stringliteral">" [ ... ] "</span>;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (! e-&gt;target()-&gt;is_at_open_boundary())</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">"("</span> &lt;&lt; e-&gt;target()-&gt;point() &lt;&lt; <span class="stringliteral">")"</span>;</div><div class="line">    } <span class="keywordflow">while</span> (++curr != first);</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>The type definitions used by the example below, as well as by other examples that use the <code><a class="el" href="classCGAL_1_1Arr__linear__traits__2.html" title="The traits class Arr_linear_traits_2 is a model of the ArrangementTraits_2 concept, which enables the construction and maintenance of arrangements of linear objects. ">Arr_linear_traits_2</a></code> class template, are listed next. These types are defined in the header file <code>arr_linear.h</code>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_linear_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">CGAL::Exact_predicates_exact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a>                                        Number_type;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__linear__traits__2.html">CGAL::Arr_linear_traits_2&lt;Kernel&gt;</a>                 Traits;</div><div class="line"><span class="keyword">typedef</span> Traits::Point_2                                   Point;</div><div class="line"><span class="keyword">typedef</span> Traits::Segment_2                                 Segment;</div><div class="line"><span class="keyword">typedef</span> Traits::Ray_2                                     Ray;</div><div class="line"><span class="keyword">typedef</span> Traits::Line_2                                    Line;</div><div class="line"><span class="keyword">typedef</span> Traits::X_monotone_curve_2                        X_monotone_curve;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits&gt;</a>                       Arrangement;</div><div class="line"><span class="keyword">typedef</span> Arrangement::Vertex_handle                        Vertex_handle;</div><div class="line"><span class="keyword">typedef</span> Arrangement::Halfedge_handle                      Halfedge_handle;</div><div class="line"><span class="keyword">typedef</span> Arrangement::Face_handle                          Face_handle;</div></div><!-- fragment --><h3><a class="anchor" id="arr_sssec-unb_global"></a>
Free Functions</h3>
<p>All the free functions that operate on arrangements of bounded curves (see Section <a class="el" href="index.html#arr_secgl_funcs">Free Functions</a>) can also be applied to arrangements of unbounded curves. For example, consider a container of linear curves that has to be inserted into an arrangement object, the type of which is an instance of the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt;Traits,Dcel&gt;</code> class template, where the <code>Traits</code> parameter is substituted with the traits class that handles linear curves; see Section <a class="el" href="index.html#arr_sssectr_linear">The Linear-Traits Class</a>. You can do it incrementally; namely, insert the curves one by one as follows: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> it = curves.begin(); it != curves.end(); ++it) <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, *it);</div></div><!-- fragment --><p> Alternatively, the curves can be inserted aggregately using a single call as follows: </p><div class="fragment"><div class="line"><a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, curves.begin(), curves.end());</div></div><!-- fragment --><p> It is also possible to issue point-location queries and vertical ray-shooting queries (see also Section <a class="el" href="index.html#arr_secqueries">Issuing Queries on an Arrangement</a>) on arrangements of lines, where the only restriction is that the query point has finite coordinates. Note that all the point-location strategies mentioned above, except the trapezoidal map strategy, are capable of handling arrangements of unbounded curves.</p>
<h2><a class="anchor" id="arr_ssec-unb_duality"></a>
Point-Line Duality</h2>
<p>In the following example we show how an arrangement of unbounded lines is utilized to solve the following problem: Given a set of points, does the set contain at least three collinear points? In this example a set of input points is read from a file. The file <code>points.dat</code> is used by default. It contains definitions of \(100\) points randomly selected on the grid \([-10000,10000]\times[-10000,10000]\). We construct an arrangement of the dual lines, where the line \(p^{*}\) dual to the point \(p = (x_p, y_p)\) is given by the equation \(y = x_p*x - y_p\), and check whether three (or more) of the dual lines intersect at a common point, by searching for a (dual) vertex, whose degree is greater than \(4\). If such a vertex exists, then there are at least three dual lines that intersect at a common point, which implies that there are at least three collinear points.</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2dual_lines_8cpp-example.html">Arrangement_on_surface_2/dual_lines.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Checking whether there are three collinear points in a given input set</span></div><div class="line"><span class="comment">// using the arrangement of the dual lines.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_linear.h"</span></div><div class="line"><span class="preprocessor">#include "read_objects.h"</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[]) {</div><div class="line">  <span class="comment">// Get the name of the input file from the command line, or use the default</span></div><div class="line">  <span class="comment">// points.dat file if no command-line parameters are given.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename = (argc &gt; 1) ? argv[1] : <span class="stringliteral">"points.dat"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Open the input file.</span></div><div class="line">  std::ifstream in_file(filename);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (! in_file.is_open()) {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Failed to open "</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">"!\n"</span>;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Read the points from the file, and construct their dual lines.</span></div><div class="line">  <span class="comment">// The input file format should be (all coordinate values are integers):</span></div><div class="line">  <span class="comment">// &lt;n&gt;                                 // number of point.</span></div><div class="line">  <span class="comment">// &lt;x_1&gt; &lt;y_1&gt;                         // point #1.</span></div><div class="line">  <span class="comment">// &lt;x_2&gt; &lt;y_2&gt;                         // point #2.</span></div><div class="line">  <span class="comment">//   :      :       :      :</span></div><div class="line">  <span class="comment">// &lt;x_n&gt; &lt;y_n&gt;                         // point #n.</span></div><div class="line">  std::vector&lt;Point&gt; points;</div><div class="line">  read_objects&lt;Point&gt;(filename, std::back_inserter(points));</div><div class="line">  std::list&lt;X_monotone_curve&gt; dual_lines;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : points) dual_lines.push_back(Line(p.x(), -1, -p.y()));</div><div class="line"></div><div class="line">  <span class="comment">// Construct the dual arrangement by aggregately inserting the lines.</span></div><div class="line">  Arrangement arr;</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, dual_lines.begin(), dual_lines.end());</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The dual arrangement size:\n"</span></div><div class="line">            &lt;&lt; <span class="stringliteral">"V = "</span> &lt;&lt; arr.number_of_vertices()</div><div class="line">            &lt;&lt; <span class="stringliteral">" (+ "</span> &lt;&lt; arr.number_of_vertices_at_infinity()</div><div class="line">            &lt;&lt; <span class="stringliteral">" at infinity)"</span></div><div class="line">            &lt;&lt; <span class="stringliteral">",  E = "</span> &lt;&lt; arr.number_of_edges()</div><div class="line">            &lt;&lt; <span class="stringliteral">",  F = "</span> &lt;&lt; arr.number_of_faces()</div><div class="line">            &lt;&lt; <span class="stringliteral">" ("</span> &lt;&lt; arr.number_of_unbounded_faces()</div><div class="line">            &lt;&lt; <span class="stringliteral">" unbounded)\n"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Look for a vertex whose degree is greater than 4.</span></div><div class="line">  <span class="keywordtype">bool</span> found_collinear = <span class="keyword">false</span>;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> vit = arr.vertices_begin(); vit != arr.vertices_end(); ++vit) {</div><div class="line">    <span class="keywordflow">if</span> (vit-&gt;degree() &gt; 4) {</div><div class="line">      found_collinear = <span class="keyword">true</span>;</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="keywordflow">if</span> (found_collinear)</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Found at least three collinear points in the input set.\n"</span>;</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"No three collinear points are found in the input set.\n"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Pick two points from the input set, compute their midpoint and insert</span></div><div class="line">  <span class="comment">// its dual line into the arrangement.</span></div><div class="line">  Kernel ker;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> n = points.size();</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> k1 = std::rand() % n, k2 = (k1 + 1) % n;</div><div class="line">  Point p_mid = ker.construct_midpoint_2_object()(points[k1], points[k2]);</div><div class="line">  X_monotone_curve dual_p_mid = Line(p_mid.x(), -1, -p_mid.y());</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, dual_p_mid);</div><div class="line"></div><div class="line">  <span class="comment">// Make sure that we now have three collinear points.</span></div><div class="line">  found_collinear = <span class="keyword">false</span>;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> vit = arr.vertices_begin(); vit != arr.vertices_end(); ++vit) {</div><div class="line">    <span class="keywordflow">if</span> (vit-&gt;degree() &gt; 4) {</div><div class="line">      found_collinear = <span class="keyword">true</span>;</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line">  CGAL_assertion(found_collinear);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> (0);</div><div class="line">}</div></div><!-- fragment --><p>Note that there are no three collinear points among the points defined in the input file <code>points.dat</code>. In the second part of the example the existence of a collinear triple is forced and verified as follows. A line dual to the midpoint of two randomly selected points is introduced, and inserted into the arrangement. This operation is followed by a test that verifies that a vertex of degree greater than \(4\) exists.</p>
<h1><a class="anchor" id="aos_sec-curved_surfaces"></a>
Arrangements on Curved Surfaces</h1>
<p>We are given a surface \(S\) in \(\mathbb{R}^3\) and a set \(\mathcal{C}\) of curves embedded in this surface. The curves subdivide \(S\) into cells of dimension 0 (<em>vertices</em>), 1 (<em>edges</em>), and 2 (<em>faces</em>). This subdivision is the <em>arrangement</em> \(\mathcal{A}(\mathcal{C})\) induced by \(\mathcal{C}\) on \(S\). Arrangements embedded in curved surfaces in \(\mathbb{R}^3\) are generalizations of arrangements embedded in the plane. In this section we explain how to construct, maintain, and manipulate two-dimensional arrangements embedded in orientable parametric surfaces in three dimensions, such as planes, cylinders, spheres, and tori, and surfaces homeomorphic to them; see <a class="el" href="index.html#fig__aos_fig-surfaces">Figure 34.15</a>. Such arrangements have many theoretical and practical applications; see, e.g., <a class="el" href="citelist.html#CITEREF_as-aa-00">[1]</a>, <a class="el" href="citelist.html#CITEREF_cgal:bfhks-apsca-10">[3]</a>, <a class="el" href="citelist.html#CITEREF_cgal:bfhmw-apsgf-10">[4]</a>, <a class="el" href="citelist.html#CITEREF_cgal:fhktww-a-07">[6]</a>, and <a class="el" href="citelist.html#CITEREF_cgal:h-a-04">[8]</a>.</p>
<p><a class="anchor" id="fig__aos_fig-surfaces"></a></p><center> <table border="0">
<tr>
<td><div class="image">
<img src="sphere.png" alt="sphere.png" />
</div>
 </td><td><div class="image">
<img src="cylinder.png" alt="cylinder.png" />
</div>
 </td><td><div class="image">
<img src="cone.png" alt="cone.png" />
</div>
 </td><td><div class="image">
<img src="ellipsoid.png" alt="ellipsoid.png" />
</div>
 </td><td><div class="image">
<img src="torus.png" alt="torus.png" />
</div>
 </td><td><div class="image">
<img src="paraboloid.png" alt="paraboloid.png" />
</div>
 </td></tr>
<tr align="center">
<td>(a) Sphere </td><td>(b) Cylinder </td><td>(c) Cone </td><td>(d) Ellipsoid </td><td>(e) Torus </td><td>(f) Paraboloid  </td></tr>
</table>
</center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-surfaces">Figure 34.15</a> Various two-dimensional parametric surfaces, arrangements on which are supported by the framework.  </div> <br /> 
<h2><a class="anchor" id="aos_ssec-curved_surfaces-parameteric"></a>
Parametric Surfaces</h2>
<p>We use \(\overline{\mathbb{R}}\) to denote the compactified real line \(\mathbb{R} \cup \{-\infty,+\infty\}\). The mapping \(x \mapsto x/(1 - x^2)\) is a homeomorphism between \((-1,+1)\) and \(\mathbb{R}\) and between \([-1,+1]\) and \(\overline{\mathbb{R}}\). So you may also think of finite intervals instead of the (compactified) real line in what follows.</p>
<p>A parametric surface \(S\) is given by a continuous function \(\phi_S: \Phi \rightarrow \mathbb{R}^3\), where the domain \(\Phi = X \times Y\) is a rectangular two-dimensional parameter space and \(S = \phi_S(\Phi)\). The sets \(X\) and \(Y\) are open, half-open, or closed intervals with endpoints in \(\overline{\mathbb{R}}\). We use \(x_{\rm min}\), \(x_{\rm max}\), \(y_{\rm min}\), and \(y_{\rm max}\) to denote the endpoints of \(X\) and \(Y\), respectively.</p>
<ul>
<li>
<p class="startli">The left side of the boundary of \(\Phi\) consists of the points \((x_{\rm min},y)\) with \(y \in {\rm closure}(Y)\). It is <em>open</em>, if \(x_{\rm min} \not\in X\) or \(y\not\in Y\), and <em>closed</em>, otherwise. The right side is defined analogously. The bottom side consists of the points \((x, y_{\rm min})\) with \(x \notin (x_{\rm min},x_{\rm max})\); the top side is defined analogously. The bottom or top sides can also be open. Note that the "corners" of the parameter space belong to the vertical sides; this asymmetry corresponds to the fact that we sweep \(x\)-monotone curves, and not \(y\)-monotone curves. The four sides together form the boundary \(\partial \Phi\).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">A point \(p \in S\) is <em>regular</em> if it has only one pre-image under \(\Phi\). All pre-images of a non-regular point lie in the boundary of \(\Phi\). In particular, \(\phi_S\) is bijective on \((x_{\rm min},x_{\rm max})\times(y_{\rm min},y_{\rm max})\). More precisely, a non-regular point has either exactly two pre-images that lie on opposite sides of the domain, or all points of exactly one side of the domain.</p>
<p class="endli"></p>
</li>
</ul>
<p>A side of the domain is contracted if \(\phi_S\) is constant on it. The image of the side is called a <em>contraction point</em>.</p>
<p>The bottom and top sides of the domain (similarly for the left and right sides) are <em>identified</em> if \(\phi_S(x,y_{\rm min}) = \phi_S(x, y_{\rm max})\) for all \(x \in X \). The curve \(x \mapsto \phi_S(x,y_{\rm min})\) is called an <em>identification curve</em>.</p>
<p>Rectangles, strips, quadrants, half-planes, and planes can be modeled with \(\phi_S \) being the identity mapping. For example, \(\Phi_S(x, y) = (x, y, 0)\) with \(X = Y =(-\infty, +\infty)\) parameterizes a plane. Surfaces such as paraboloids can be modeled through continuous and bijective parameterizations, for example, \(\phi_S(x,y) = (x,y,x^2 + y^2)\), where \(U = V =(-\infty, +\infty)\), defines a paraboloid of revolution. Cylinders, tori, spheres, and surfaces homeomorphic to them, require more general parameterizations. For example, the unit sphere is commonly parameterized as \(\phi_S(x, y) = (\cos x \cos y, \sin x \cos y, \sin y)\), where \(\Phi = [-\pi, \pi] \times [-\frac{\pi}{2}, \frac{\pi}{2}]\). With respect to this parameterization, the north and the south pole and all points on the opposite Prime (Greenwich) Meridian are non-regular. The north pole \((0,0,1)\) has infinitely many pre-images \((x, \pi/2)\) with \(-\pi &lt; x &lt; \pi\) and so does the south pole \((0,0,-1)\). The points on the opposite Prime Meridian have two pre-images each, namely \((-\pi,y)\) and \((\pi,y)\) with \(-\pi/2 \leq y \leq \pi/2\). We say that the top and bottom side of the domain are <em>contracted</em> and the left and right sides are <em>identified</em>. These are exactly the kinds of non-injectivity that we allow.</p>
<p>We give more examples. A <em>triangle</em> with corners \((a_1, b_1), (a_2, b_2)\), and \((a_3, b_3)\) can be parameterized via \(\Phi = [0,1] \times [0,1]\) with \(\phi_S(x,y) = (a_1 + x(a_2 - a_1) + xy(a_3-a_2), b_1 + x(b_2 - b_1) + xy(b_3-b_2), 0)\). The left side of the rectangular domain contracts to a point. An open or closed <em>cylinder</em> is modeled by identifying the vertical sides and having \(Y\) open or closed, respectively. A <em>torus</em> is modeled by identifying the vertical sides and the horizontal sides. A <em>paraboloid</em> or <em>half-cone</em> may be modeled by identifying the vertical sides and contracting one of the horizontal sides to a point. More elegantly, they are modeled by a bijective parameterization as given above. A <em>sphere</em> is modeled by identifying the vertical sides and contracting both horizontal sides. A <em>croissant</em>, a torus with one pinch point, is modeled by identifying the vertical and identifying the horizontal sides and, in addition, contracting one of the pairs. However, the croissant is excluded by our definitions. All surfaces supported by our framework are locally homeomorphic to a disk, and hence an DCEL data-structure suffices for representing arrangements on these surfaces. The croissant is, at the pinch point, not locally homeomorphic to a disk, and hence a more general cell-tuple data structure than an DCEL would be needed.</p>
<p>A curve \(\gamma\) is a continuous function \(\gamma: I \rightarrow \Phi\), where \(I\) is an open, half-open, or closed interval with endpoints 0 and 1, and \(\gamma\) is injective except at a finite number of points. If \(0 \not\in I\), the limit \(\lim_{t \rightarrow 0+} \gamma(t)\) exists (in the closure of \(\Phi\)) and lies in an open side of the boundary. Similarly, if \(1 \not\in I\), then \(\lim_{t \rightarrow 1-} \gamma(t)\) exists and lies in an open side of the boundary. A curve \(c\) in \(S\) is the image of a curve \(\gamma\) in the domain.</p>
<p>A curve is <em>closed in the domain</em> if \(\gamma(0) = \gamma(1)\); in particular, \(0 \in I\) and \(1 \in I\). A curve is <em>closed in the surface \(S\) (or simply closed)</em> if \(\phi_S(\gamma(0)) = \phi_S(\gamma(1))\). A curve \(\gamma\) has two <em>ends</em>, the 0-end \(\langle \gamma,0 \rangle\) and the 1-end \(\langle \gamma,1 \rangle\). If \(d \in I\), the \(d\)-end has a geometric interpretation. It is a point in \(\Phi\). If \(d \not\in I\), the \(d\)-end has no geometric interpretation. You may think of it as a point on an open side of the domain or an initial or terminal segment of \(\gamma\). If \(d \not\in I\), we say that the \(d\)-end of the curve is open. The equator curve on the sphere in standard parameterization is given by \(\gamma(t) = (\pi(2t - 1),0)\) for \(t \in [0,1]\). The \(0\)-end of \(\gamma\) is the point \((-\pi,0)\) in \(\Phi\) and a point on the equator of the sphere. It is closed on the sphere, but not closed in \(\Phi\). The diagonal \((u,u)\) in the plane is, for example, given by \(\gamma(t) = (x(t),y(t))\) and \(x(t) = y(t) = (t - 1/2)/(t(1-t))\). Both ends of this curve are open. The \(d\)-end of a curve \(\gamma\) is incident to the left side if either \(d \in I\) and \(\gamma(d)\) lies on the left side or \(d \not\in I\) and \(\lim_{t \rightarrow d} \gamma(t)\) lies on the left side, which is then an open side. Similarly for the other sides.</p>
<p>A <em>strongly \(x\)-monotone curve</em> is the image of a curve \(\gamma\), such that if \(t_1 &lt; t_2\) for \(t_1, t_2 \in I\), then \(x(t_1) &lt; x(t_2)\). A <em>vertical curve</em> is the image of a curve \(\gamma\), such that \(x(t) = C\) for all \(t \in I\) and some \(C \in X\) and \(y(t_1) &lt; y(t_2)\) for \(t_1 &lt; t_2\). For instance, every Meridian curve of a sphere parameterized as above is vertical. An <em> \(x\)-monotone curve</em> is either vertical or strongly \(x\)-monotone.</p>
<h2><a class="anchor" id="aos_ssec-curved_surfaces-aos_class"></a>
The Arrangement on Surface Class Template</h2>
<p>The class template <code><a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html">Arrangement_on_surface_2</a>&lt;GeomTraits, TopolTraits&gt;</code> can be used to represent a 2D arrangement embedded in a 3D surface. The template is parameterized by template parameters <em>geometry traits</em> and <em>topology traits</em>. The topology-traits type deals with the topology of the parametric surface; see Section <a class="el" href="index.html#aos_sec-topol_traits">The Topology Traits</a>. As explained in the previous section, a parametric surface \(S = \phi_S(\Phi)\) is given by a continuous function \(\phi_S: \Phi \rightarrow \mathbb{R}^3\), where the domain \(\Phi = X \times Y\) is a rectangular two-dimensional parameter space. \(X\) and \(Y\) are open, half-open, or closed intervals with endpoints in \(\overline{\mathbb{R}}\).</p>
<p>The geometry-traits type introduces the type names of the basic geometric objects (i.e., point, curve, and \(x\)-monotone curve) and the set of operations on objects of these types required to construct and maintain the arrangement and to operate on it. The traits-concept hierarchy described in Section <a class="el" href="index.html#aos_sec-geom_traits">The Geometry Traits</a> accurately defines the requirements imposed on a model of a geometry traits class. Recall that requirements apply to the parameter space \(\Phi = X \times Y\); thus, they are defined in terms of \(x\) and \(y\) coordinates. Most requirements apply to all type of arrangements regardless of the embedding surface. However, several refined concepts apply only to arrangements on surfaces that are not in the plane, that is, modeled with \(\phi_S\) not being the identity mapping. They differ according to the type of the side boundaries of the parameter space being open, closed, contracted, or identified.</p>
<p>At this point only one type of arrangements on non planar surfaces is supported, namely, arrangements embedded in the sphere and induced by arcs of great circles, also known as geodesic arcs. <a class="el" href="index.html#fig__aos_fig-voronoi">Figure 34.16</a> shows various Voronoi diagrams the bisectors of which are geodesic arcs. They are represented as arrangements induced by geodesic arcs embedded in the sphere.</p>
<p><a class="anchor" id="fig__aos_fig-voronoi"></a></p><center> <table border="0">
<tr>
<td><div class="image">
<img src="voronoi.jpg" alt="voronoi.jpg" />
</div>
 </td><td><div class="image">
<img src="degenerate_voronoi.jpg" alt="degenerate_voronoi.jpg" />
</div>
 </td><td><div class="image">
<img src="power_diagram.jpg" alt="power_diagram.jpg" />
</div>
 </td><td><div class="image">
<img src="degenerate_power_diagram.jpg" alt="degenerate_power_diagram.jpg" />
</div>
 </td></tr>
<tr align="center">
<td>(a) </td><td>(b) </td><td>(c) </td><td>(d)  </td></tr>
</table>
</center><p>  </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-voronoi">Figure 34.16</a> Voronoi diagrams on the sphere. All diagram edges are geodesic arcs. Sites are drawn in red and Voronoi edges are drawn in blue. (a) The Voronoi diagram of 32 random points. (b) A highly degenerate case of Voronoi diagram of 30 point sites on the sphere. (c) The power diagram of 10 random circles. (d) A degenerate power diagram of 14 sites on the sphere.  </div> <br /> 
<h2><a class="anchor" id="aos_ssec-curved_surfaces-basic"></a>
Basic Manipulation and Traversal Methods</h2>
<p>The types <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex.html"><code>Vertex</code></a>, <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge.html"><code>Halfedge</code></a>, and <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Face.html"><code>Face</code></a> nested in the <code><a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html">Arrangement_on_surface_2</a></code> class template support the methods listed in Section <a class="el" href="index.html#arr_ssectraverse">Traversing the Arrangement</a> and in Section <a class="el" href="index.html#arr_sssecunb_basic">Basic Manipulation and Traversal Methods</a>. Additional methods supported by these types are described next. Let \(v\), \(e\), and \(f\) be handles to a vertex of type <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex.html"><code>Vertex</code></a>, a halfedge of type <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Halfedge.html"><code>Halfedge</code></a>, and a face of type <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Face.html"><code>Face</code></a>, respectively.</p>
<ul>
<li>
<p class="startli">The calls <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex.html#aa324ce50ac500bc80bf74abad4b22d78"><code>v-&gt;parameter_space_in_x()</code></a> and <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex.html#acdc784d286542020869d294adc6101eb"><code>v-&gt;parameter_space_in_y()</code></a> determine the location of the geometric embedding of the vertex \(v\). The call <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex.html#aa324ce50ac500bc80bf74abad4b22d78"><code>v-&gt;parameter_space_in_x()</code></a> returns <code>ARR_INTERIOR</code> if the geometric embedding of \(v\) is a point \(p\) the pre-image of which does not lie on the left nor on the right sides of the boundary of the parameter space. If the left and right sides are not identified, then <code>ARR_LEFT_BOUNDARY</code> or <code>ARR_RIGHT_BOUNDARY</code> are returned if the pre-image of \(p\) lies on the left or the right side, respectively. If the left and right sides are identified, the return value is unspecified and can be either <code>ARR_LEFT_BOUNDARY</code> or <code>ARR_RIGHT_BOUNDARY</code>. Similarly, the call <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Vertex.html#acdc784d286542020869d294adc6101eb"><code>v-&gt;parameter_space_in_y()</code></a> returns <code>ARR_INTERIOR</code> if the geometric embedding of \(v\) is a point \(q\), the pre-image of which does not lie on the bottom nor on the top sides of the boundary of the parameter space. If the bottom and top sides are not identified, then <code>ARR_BOTTOM_BOUNDARY</code> or <code>ARR_TOP_BOUNDARY</code> are returned if the pre-image of \(q\) lies on the bottom or the top side, respectively. If the bottom and top sides are identified, the return value is unspecified.</p>
<p>If you want to determine whether the pre-image of a point \(p\) lies on identified sides, you need to employ one of the two traits functors <a class="el" href="classArrangementIdentifiedHorizontalTraits__2.html#a27b52387b49e8e41a31383105b0e1271"><code>Is_on_x_identification_2</code></a> or <a class="el" href="classArrangementIdentifiedVerticalTraits__2.html#a25e81de87d3f3fe7f50668c6efb0698a"><code>Is_on_y_identification_2</code></a>; see Section <a class="el" href="index.html#aos_ssec-traits-curved">Supporting Unbounded Curves or Curved Surfaces</a>. If the pre-image of an \(x\)-monotone curve \(c\) does not entirely lie on identified sides, you can determine the location of the pre-image of an endpoint of \(c\) employing either the <a class="el" href="classArrangementVerticalSideTraits__2.html#aa5f28542a43863ce2d5d5d02d40b9b31"><code>Parameter_space_in_x_2</code></a> functor or the <a class="el" href="classArrangementHorizontalSideTraits__2.html#ade2b2e1b437891f6f570f64df975636f"><code>Parameter_space_in_y_2</code></a> functors; see Section <a class="el" href="index.html#aos_ssec-traits-curved">Supporting Unbounded Curves or Curved Surfaces</a>. The operations in both functors accept an enumeration that indicates the curve end, that is, <code><a class="el" href="group__PkgArrangementOnSurface2Enums.html#gga29246893be4be2ad9a8fbc249f49f0b5ae94b64f2e1653bac4461db9bd5d0ad88">CGAL::ARR_MIN_END</a></code> or <code><a class="el" href="group__PkgArrangementOnSurface2Enums.html#gga29246893be4be2ad9a8fbc249f49f0b5a3e2c2ccf1e5433588fa82aec99013cce">CGAL::ARR_MAX_END</a></code>, in addition to the curve itself.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">A face in a planar arrangement has at most one outer CCB. However, an arrangement embedded on a surface may present additional scenarios. For example, a face of an arrangement embedded on a torus may have two outer CCBs, and a face of an arrangement embedded on a sphere might be consider a hole inside the surrounding face or vice versa. To this end, outer CCBs and inner CCBs of faces of arrangements embedded on surfaces are symmetrically treated (while maintaining the invariant that a face always lies to the left of every halfedge of every CCB of the face regardless of whether the CCB is inner or outer). The classification of a CCB as inner or outer becomes an implementation detail. The calls <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Face.html#ad0464c76e813743d7f80a82ef84e01f6"><code>f-&gt;outer_ccbs_begin()</code></a> and <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Face.html#a5134b106c11cbd421f275dccb0aa2948"><code>f-&gt;outer_ccbs_end()</code></a> return iterators of type <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Face.html#a222b4b4fb958962f4604f63381bac206"><code>Outer_ccb_iterator</code></a> that define a range of outer CCBs inside the face \(f\). Similarly, the methods <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Face.html#a73238866496b4defe425b18095c31089"><code>f-&gt;inner_ccbs_begin()</code></a> and <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Face.html#ab344171878b04ec4353106385941caf3"><code>f-&gt;inner_ccbs_end()</code></a> return iterators of type <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Face.html#afdf407b9a6f2d995a33e54e5ffc55925"><code>Inner_ccb_iterator</code></a> that define a range of inner CCBs inside the face \(f\). (The latter pair of member functions and the iterator type are equivalent to the methods <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Face.html#acd9525cd21bf2cd7404fddefe4ade7fb"><code>holes_begin()</code></a>, <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Face.html#a64b500ed6fcd24544bc13dbde161b63a"><code>holes_end()</code></a>, and <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Face.html#a53de656d3ec315b4cf60f385a7667b55"><code>Hole_iterator</code></a>; see Section <a class="el" href="index.html#arr_sssectr_face">Traversal Methods for an Arrangement Face</a>.) The calls <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Face.html#a519d3b1c9bda314d305f69096461f303"><code>f-&gt;number_of_outer_ccbs()</code></a> and <a class="el" href="classCGAL_1_1Arrangement__on__surface__2_1_1Face.html#aa656d33ec8426fd3db3012632980ddae"><code>f-&gt;number_of_inner_ccbs()</code></a> return the number of outer CCBs and the number of inner CCBs in \(f\), respectively.</p>
<p class="endli"></p>
</li>
</ul>
<p> </p><div class="CGALAdvanced"> <div>Advanced</div> 
<p>The function template <code>is_in_x_range()</code> listed below, and defined in the file <code>spherical_is_in_x_range.h</code> checks whether a given point \(p\), in the interior of the parameter space, is in the \(x\)-range of an \(x\)-monotone curve \(c\) that represents a great-circle arc. It assumes that the left and right sides of the parameter space are identified and the bottom and top sides are contracted, which is the settings used by the traits class template <code><a class="el" href="classCGAL_1_1Arr__geodesic__arc__on__sphere__traits__2.html" title="The traits class Arr_geodesic_arc_on_sphere_traits_2 is a model of the ArrangementTraits_2 concept...">Arr_geodesic_arc_on_sphere_traits_2</a>&lt;<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>,X,Y&gt;</code>; see Section <a class="el" href="index.html#arr_ssectr_spherical">Arcs of Great Circles Embedded in the Sphere</a>. The traits functors <a class="el" href="classArrangementBasicTraits__2.html#ac00c8a45688aeaa21496f4a21c8e22d5"><code>Construct_min_vertex_2</code></a>, <a class="el" href="classArrangementBasicTraits__2.html#a04f2fbd7da5f539f94fab902f9bcf37d"><code>Construct_min_vertex_2</code></a>, and <a class="el" href="classArrangementBasicTraits__2.html#a50f0e201b051be81f31257feab0cdab7"><code>Compare_x_2</code></a> used in the code are described is Section <a class="el" href="index.html#aos_sssec-geom_traits-concepts_basic">The Basic Concept</a>. The traits functors <a class="el" href="classArrangementVerticalSideTraits__2.html#aa5f28542a43863ce2d5d5d02d40b9b31"><code>Parameter_space_in_x_2</code></a>, <a class="el" href="classArrangementHorizontalSideTraits__2.html#ade2b2e1b437891f6f570f64df975636f"><code>Parameter_space_in_y_2</code></a>, <a class="el" href="classArrangementIdentifiedVerticalTraits__2.html#a25e81de87d3f3fe7f50668c6efb0698a"><code>Is_on_y_identification_2</code></a>, and <a class="el" href="classArrangementHorizontalSideTraits__2.html#aa69f216050ce5fee135ae6130633ca97"><code>Compare_x_on_boundary_2</code></a>, are described is Section <a class="el" href="index.html#aos_ssec-traits-curved">Supporting Unbounded Curves or Curved Surfaces</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> GeometryTraits&gt;</div><div class="line"><span class="keywordtype">bool</span> is_in_x_range(<span class="keyword">const</span> <span class="keyword">typename</span> GeometryTraits::X_monotone_curve_2&amp; c,</div><div class="line">                   <span class="keyword">const</span> <span class="keyword">typename</span> GeometryTraits::Point_2&amp; p,</div><div class="line">                   <span class="keyword">const</span> GeometryTraits&amp; traits) {</div><div class="line">  CGAL_assertion(! traits.is_on_y_identification_2_object()(p));</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (traits.is_on_y_identification_2_object()(c)) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Note that a great-circle arc that is incident to a pole is vertical.</span></div><div class="line">  <span class="keyword">auto</span> cmp_x_boundary = traits.compare_x_on_boundary_2_object();</div><div class="line">  <span class="keyword">auto</span> psy = traits.parameter_space_in_y_2_object();</div><div class="line">  <span class="keyword">auto</span> psy_min = psy(c, <a class="code" href="group__PkgArrangementOnSurface2Enums.html#gga29246893be4be2ad9a8fbc249f49f0b5ae94b64f2e1653bac4461db9bd5d0ad88">CGAL::ARR_MIN_END</a>);</div><div class="line">  <span class="keywordflow">if</span> (psy_min == <a class="code" href="group__PkgArrangementOnSurface2Enums.html#gaf276ca43e83c8791923154aba4584651">CGAL::ARR_BOTTOM_BOUNDARY</a>)</div><div class="line">    <span class="keywordflow">return</span> cmp_x_boundary(p, c, <a class="code" href="group__PkgArrangementOnSurface2Enums.html#gga29246893be4be2ad9a8fbc249f49f0b5ae94b64f2e1653bac4461db9bd5d0ad88">CGAL::ARR_MIN_END</a>) == <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gga84351c7e66be00efccd4ab1a61070469a5f224784e56ca565837a5d6d268fe078">CGAL::EQUAL</a>;</div><div class="line">  <span class="keyword">auto</span> psy_max = psy(c, <a class="code" href="group__PkgArrangementOnSurface2Enums.html#gga29246893be4be2ad9a8fbc249f49f0b5a3e2c2ccf1e5433588fa82aec99013cce">CGAL::ARR_MAX_END</a>);</div><div class="line">  <span class="keywordflow">if</span> (psy_max == <a class="code" href="group__PkgArrangementOnSurface2Enums.html#gaf8d89294c23614f33351e94ff28e0d59">CGAL::ARR_TOP_BOUNDARY</a>)</div><div class="line">    <span class="keywordflow">return</span> cmp_x_boundary(p, c, <a class="code" href="group__PkgArrangementOnSurface2Enums.html#gga29246893be4be2ad9a8fbc249f49f0b5a3e2c2ccf1e5433588fa82aec99013cce">CGAL::ARR_MAX_END</a>) == <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gga84351c7e66be00efccd4ab1a61070469a5f224784e56ca565837a5d6d268fe078">CGAL::EQUAL</a>;</div><div class="line">  <span class="keyword">auto</span> psx = traits.parameter_space_in_x_2_object();</div><div class="line">  <span class="keyword">auto</span> psx_min = psx(c, <a class="code" href="group__PkgArrangementOnSurface2Enums.html#gga29246893be4be2ad9a8fbc249f49f0b5ae94b64f2e1653bac4461db9bd5d0ad88">CGAL::ARR_MIN_END</a>);</div><div class="line">  <span class="keyword">auto</span> psx_max = psx(c, <a class="code" href="group__PkgArrangementOnSurface2Enums.html#gga29246893be4be2ad9a8fbc249f49f0b5a3e2c2ccf1e5433588fa82aec99013cce">CGAL::ARR_MAX_END</a>);</div><div class="line">  <span class="keywordflow">if</span> ((psx_min == <a class="code" href="group__PkgArrangementOnSurface2Enums.html#ga2bbdd8004c0a37409305b01cf7fc2563">CGAL::ARR_LEFT_BOUNDARY</a>) &amp;&amp;</div><div class="line">      (psx_min == <a class="code" href="group__PkgArrangementOnSurface2Enums.html#ga341fb5c90e8037d651012f955e38fda1">CGAL::ARR_RIGHT_BOUNDARY</a>))</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">  <span class="keyword">auto</span> cmp_x = traits.compare_x_2_object();</div><div class="line">  <span class="keywordflow">if</span> (psx_min == <a class="code" href="group__PkgArrangementOnSurface2Enums.html#ga2bbdd8004c0a37409305b01cf7fc2563">CGAL::ARR_LEFT_BOUNDARY</a>) {</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; p_right = traits.construct_max_vertex_2_object()(c);</div><div class="line">    <span class="keyword">auto</span> res = cmp_x(p, p_right);</div><div class="line">    <span class="keywordflow">return</span> ((res == <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gga84351c7e66be00efccd4ab1a61070469ab925c6b1ff8cd0bdea7f31fe18d3c38b">CGAL::SMALLER</a>) || (res == <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gga84351c7e66be00efccd4ab1a61070469a5f224784e56ca565837a5d6d268fe078">CGAL::EQUAL</a>));</div><div class="line">  }</div><div class="line">  <span class="keywordflow">if</span> (psx_max == <a class="code" href="group__PkgArrangementOnSurface2Enums.html#ga341fb5c90e8037d651012f955e38fda1">CGAL::ARR_RIGHT_BOUNDARY</a>) {</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; p_left = traits.construct_min_vertex_2_object()(c);</div><div class="line">    <span class="keyword">auto</span> res = cmp_x(p_left, p);</div><div class="line">    <span class="keywordflow">return</span> ((res == <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gga84351c7e66be00efccd4ab1a61070469ab925c6b1ff8cd0bdea7f31fe18d3c38b">CGAL::SMALLER</a>) || (res == <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gga84351c7e66be00efccd4ab1a61070469a5f224784e56ca565837a5d6d268fe078">CGAL::EQUAL</a>));</div><div class="line">  }</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; p_left = traits.construct_min_vertex_2_object()(c);</div><div class="line">  <span class="keyword">auto</span> res = cmp_x(p_left, p);</div><div class="line">  <span class="keywordflow">if</span> (res == <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gga84351c7e66be00efccd4ab1a61070469ab25bdbfd193e9ea35187a4f46e7d6fcd">CGAL::LARGER</a>) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; p_right = traits.construct_max_vertex_2_object()(c);</div><div class="line">  res = cmp_x(p, p_right);</div><div class="line">  <span class="keywordflow">if</span> (res == <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gga84351c7e66be00efccd4ab1a61070469ab25bdbfd193e9ea35187a4f46e7d6fcd">CGAL::LARGER</a>) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><p> </p></div> 
<h1><a class="anchor" id="aos_sec-geom_traits"></a>
The Geometry Traits</h1>
<p>A geometry traits class encapsulates the definitions of the geometric entities and the implementation of the geometric predicates and constructions that handle these geometric entities, used by the <code><a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html">Arrangement_on_surface_2</a></code> class template and by the peripheral modules. The identified minimal requirements imposed by the various algorithms that apply to arrangements are organized in a hierarchy of refined geometry-traits concepts. The requirements listed by each concept include only the utterly essential types and operations needed to implement specific algorithms. This modular structuring yields controllable parts that can be produced, maintained, and utilized with less effort. For each operation, all the preconditions that its operands must satisfy are specified as well, as these may simplify the implementation of models of these concepts even further. Each traits class models one or more concepts. This section contains a detailed description of the concepts in the refinement hierarchy and the various traits classes that model these concepts.</p>
<p>All the algebra required for constructing and manipulating arrangements is concentrated in the traits classes. The knowledge required to devise a good traits class is very different from the knowledge required for the development of the rest of the package or for using the package. It has less to do with computational geometry and it involves mainly algebra and numerical computation. This way, traits classes for new types of curves can be developed with little knowledge of algorithms and data structures in computational geometry. In this section we discuss how to use existing traits classes, but we also explain the concepts these traits classes model—a starting point for every novice developer of such classes.</p>
<p>This section is divided into three parts. The first part describes the refinement hierarchy of the arrangement geometry-traits concepts. The second part reviews various models of these concepts. These traits classes handle different curve families, such as line segments, polylines, conic arcs, Bézier curves, algebraic curves, and geodesic arcs on the sphere. The last part introduces decorators for geometric traits classes. A decorator of a traits class attaches auxiliary data to the geometric objects handled by the original traits class, thereby extending it.</p>
<h2><a class="anchor" id="aos_ssec-geom_traits-concepts"></a>
The Hierarchy of the Geometry Traits Concepts</h2>
<p>A hierarchy of related concepts can be viewed as a directed acyclic graph, where a node of the graph represents a concept and an arc represents a refinement relation. An arc directed from concept <span class="textsc">A</span> to concept <span class="textsc">B</span> indicates that concept <span class="textsc">B</span> refines concept <span class="textsc">A</span>. A rather large directed acyclic graph is required to capture the entire hierarchy of the geometry traits-class concepts. In the following sections we review individual clusters of the graph and describe the relations between them. <a class="el" href="index.html#fig__aos_fig-central_concept_cluster">Figure 34.17</a> depicts the central cluster.</p>
<p><a class="anchor" id="fig__aos_fig-central_concept_cluster"></a></p><div class="image">
<img src="central_concept_cluster.png" alt="central_concept_cluster.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-central_concept_cluster">Figure 34.17</a> The hierarchy of the main geometry traits concepts.  </div> <br /> 
<h3><a class="anchor" id="aos_sssec-geom_traits-concepts_basic"></a>
The Basic Concept</h3>
<p>A model of the basic concept <code><a class="el" href="classArrangementBasicTraits__2.html" title="The concept ArrangementBasicTraits_2 defines the minimal set of geometric predicates needed for the c...">ArrangementBasicTraits_2</a></code> needs to define the types <a class="el" href="classArrangementBasicTraits__2.html#a8cfc873dc62ce86f9479c4689845d4b3"><code>Point_2</code></a> and <a class="el" href="classArrangementBasicTraits__2.html#a0fc1f7acfd69a5eae393294b6870a1d2"><code>X_monotone_curve_2</code></a>, where objects of the former type are the geometric mapping of arrangement vertices, and objects of the latter type are the geometric mapping of edges. In addition, it has to support the set of predicates listed below. This basic set of predicates is sufficient for constructing arrangements of bounded \(x\)-monotone curves that are pairwise disjoint in their interiors and points that do not lie in the interiors of the curves. The basic set of predicates is also sufficient for answering vertical ray-shooting queries and point-location queries with a small exception: Locating a point using the landmark strategy requires a traits class that models the concept <code><a class="el" href="classArrangementLandmarkTraits__2.html" title="The concept ArrangementLandmarkTraits_2 refines the traits concepts ArrangementApproximateTraits_2 an...">ArrangementLandmarkTraits_2</a></code>; see Section <a class="el" href="index.html#aos_sssec-tr_landmarks_concept">The Landmark Concept</a>.</p>
<dl>
<dt><a class="el" href="classArrangementBasicTraits__2.html#a50f0e201b051be81f31257feab0cdab7"><b><code>Compare_x_2</code></b></a>: </dt>
<dd><p class="startdd">Compares the \(x\)-coordinates of two points.</p>
<p class="enddd"></p>
</dd>
<dt><a class="el" href="classArrangementBasicTraits__2.html#a293a8cbafe9449891fd1480f34d0c31c"><b><code>Compare_xy_2</code></b></a>: </dt>
<dd><p class="startdd">Compares two points lexicographically, first by their \(x\)-coordinates, and if they are equal, by their \(y\)-coordinates.</p>
<p class="enddd"></p>
</dd>
<dt><a class="el" href="classArrangementBasicTraits__2.html#aee2d448e95348f47d37aeb1d9d0f705c"><b><code>Equal_2</code></b></a>: </dt>
<dd><p class="startdd">There are two overloaded Boolean operators that test equality. One returns true iff two given points represent the same geometric point in the two-dimensional surface, and the second returns true iff the graphs of two given \(x\)-monotone curves are the same.<span class="footnote">The predicate that tests equality between graphs of two \(x\)-monotone curves is used only for testing as part of the test suite.</span></p>
<p class="enddd"></p>
</dd>
<dt><a class="el" href="classArrangementBasicTraits__2.html#ac00c8a45688aeaa21496f4a21c8e22d5"><b><code>Construct_min_vertex_2</code></b></a>: </dt>
<dd><p class="startdd">Returns the lexicographically smallest (or left) endpoint of an \(x\)-monotone curve.</p>
<p class="enddd"></p>
</dd>
<dt><a class="el" href="classArrangementBasicTraits__2.html#a04f2fbd7da5f539f94fab902f9bcf37d"><b><code>Construct_max_vertex_2</code></b></a>: </dt>
<dd><p class="startdd">Returns the lexicographically largest (or right) endpoint of an \(x\)-monotone curve.</p>
<p class="enddd"></p>
</dd>
<dt><a class="el" href="classArrangementBasicTraits__2.html#a64064c1508c2560a6bab217ad1b969f8"><b><code>Is_vertical_2</code></b></a>: </dt>
<dd><p class="startdd">Determines whether an \(x\)-monotone curve is vertical.</p>
<p class="enddd"></p>
</dd>
<dt><a class="el" href="classArrangementBasicTraits__2.html#ac87c7d7779ddf778dd8be68ad5a4fb37"><b><code>Compare_y_at_x_2</code></b></a>: </dt>
<dd><p class="startdd">Given an \(x\)-monotone curve \(c\) and a point \(p\) that lies in the \(x\)-range of \(c\), determines whether \(p\) is below, above or lies on \(c\).</p>
<p class="enddd"></p>
</dd>
<dt><a class="el" href="classArrangementBasicTraits__2.html#a1eeadafe6fc9b9de597e61bdce250f23"><b><code>Compare_y_at_x_right_2</code></b></a>: </dt>
<dd>Given two \(x\)-monotone curves \(c_1\) and \(c_2\) that share a common minimal (left) endpoint \(p\), determines whether \(c_1\) is above or below \(c_2\) immediately to the right of \(p\), or whether the two curves overlap there. </dd>
</dl>
<p>Every model of the concept <code><a class="el" href="classArrangementBasicTraits__2.html" title="The concept ArrangementBasicTraits_2 defines the minimal set of geometric predicates needed for the c...">ArrangementBasicTraits_2</a></code> needs to define a nested type named <a class="el" href="classArrangementBasicTraits__2.html#a928de1a5dac72286c1e2dd811dcb559f"><code>Has_left_category</code></a>. It determines whether the traits class supports the following predicate:</p>
<dl>
<dt><a class="el" href="classArrangementBasicTraits__2.html#a88da529dbddab3034e71ca82d414e7e1"><b><code>Compare_y_at_x_left_2</code></b></a>: </dt>
<dd><p class="startdd">Given two \(x\)-monotone curves \(c_1\) and \(c_2\) that share a common maximal (right) endpoint \(p\), determines whether \(c_1\) is above or under \(c_2\) immediately to the left of \(p\), or whether the two curves overlap there.</p>
<p class="enddd"></p>
</dd>
</dl>
<p>If the <code><a class="el" href="classArrangementBasicTraits__2.html#a928de1a5dac72286c1e2dd811dcb559f" title="indicates whether the nested functor Compare_at_x_left_2 is provided. ">ArrangementBasicTraits_2::Has_left_category</a></code> type nested in a model of the basic concept is defined as <code>Tag_true</code><span class="footnote">In principle, the category type may only be convertible to the tag type, but in practice the category is typically explicitly defined as the tag.</span> the model must support the predicate. If the type is defined as <code>Tag_false</code>, we resort to an internal version, which is based just on the reduced set of provided operations. The internal version might be less efficient, but it exempts the traits developer from the providing an (efficient) implementation of this predicate—a task that turns out to be nontrivial in some cases.</p>
<p>The basic set of predicates is sufficient for constructing arrangements of \(x\)-monotone curves that do not reach or approach the boundary of the parameter space. The nature of the input curves, whether they are expected to reach or approach the left, right, bottom, or top side of the boundary of the parameter space, must be conveyed by the traits class. This is done through the definition of four additional nested types, namely </p><ol>
<li>
<a class="el" href="classArrangementBasicTraits__2.html#a71e663e1e6e125a70aedf6ab2c82e95f"><code>Left_side_category</code></a>, </li>
<li>
<a class="el" href="classArrangementBasicTraits__2.html#a51ec39783adcc206066f6075bee4ba77"><code>Right_side_category</code></a>, </li>
<li>
<a class="el" href="classArrangementBasicTraits__2.html#ad1c0c7aecbb67a46314b49271af64795"><code>Bottom_side_category</code></a>, and </li>
<li>
<a class="el" href="classArrangementBasicTraits__2.html#ad4077ad8b432735b265f25aa8aafa083"><code>Top_side_category</code></a>. </li>
</ol>
<p>Each of those types must be convertible to the type <code><a class="el" href="structCGAL_1_1Arr__oblivious__side__tag.html" title="This type tag is used to indicate that the condition of a boundary side of the parameter space is irr...">Arr_oblivious_side_tag</a></code> for the class to be a model of the concept <code><a class="el" href="classArrangementBasicTraits__2.html" title="The concept ArrangementBasicTraits_2 defines the minimal set of geometric predicates needed for the c...">ArrangementBasicTraits_2</a></code>.</p>
<h3><a class="anchor" id="aos_sssec-geom_traits-concepts_intersecting"></a>
Intersections</h3>
<p>Constructing an arrangement induced by \(x\)-monotone curves that may intersect in their interior requires operations that are not part of the <code><a class="el" href="classArrangementBasicTraits__2.html" title="The concept ArrangementBasicTraits_2 defines the minimal set of geometric predicates needed for the c...">ArrangementBasicTraits_2</a></code> concept. The additional operations are listed by the concept <code><a class="el" href="classArrangementXMonotoneTraits__2.html" title="The concept ArrangementXMonotoneTraits_2 refines the basic arrangement-traits concept. A model of this concept is able to handle -monotone curves that intersect in their interior (and points that coincide with curve interiors). This is necessary for constructing arrangements of sets of intersecting -monotone curves. ">ArrangementXMonotoneTraits_2</a></code>, which refines the basic arrangement geometry-traits concept described above. While models of the <code><a class="el" href="classArrangementXMonotoneTraits__2.html" title="The concept ArrangementXMonotoneTraits_2 refines the basic arrangement-traits concept. A model of this concept is able to handle -monotone curves that intersect in their interior (and points that coincide with curve interiors). This is necessary for constructing arrangements of sets of intersecting -monotone curves. ">ArrangementXMonotoneTraits_2</a></code> concept still handle only \(x\)-monotone curves, the curves are not restricted to be disjoint in their interiors. Such a model must be capable of computing points of intersection between \(x\)-monotone curves, splitting curves at these intersection points to obtain pairs of interior-disjoint subcurves, and optionally merging pairs of subcurves. A point of intersection between two curves is also represented by the <a class="el" href="classArrangementBasicTraits__2.html#a8cfc873dc62ce86f9479c4689845d4b3"><code>Point_2</code></a> type. A model of the refined concept must define an additional type called <code>Multiplicity</code>. An object of this type indicates the multiplicity of the intersection point of two curves, also referred to as the <em>intersection number</em>.<span class="footnote">See, e.g., <a href="http://en.wikipedia.org/wiki/Intersection_number">http://en.wikipedia.org/wiki/Intersection_number</a> for more information about intersection numbers.</span> Loosely speaking, if two curves intersect at a point \(p\) but have different tangents (first derivatives) at \(p\), The point \(p\) is of multiplicity 1. If the curve tangents are equal but their curvatures (second derivatives) are not, \(p\) is of multiplicity 2, and so on. The multiplicity of points of intersection between line segments is always 1, and the multiplicity of a point of intersection between two polylines is 1 if the intersection point is interior to the corresponding two line segments of the polylines, and undefined (coded as 0) otherwise. A model of the refined concept thus has to support the following additional operations:</p>
<dl>
<dt><a class="el" href="classArrangementXMonotoneTraits__2.html#a2966f1d49ebda07d2de23a749259283f"><b><code>Split_2</code></b></a>: </dt>
<dd><p class="startdd">Splits an \(x\)-monotone curve \(c\) into two subcurves at a given point \(p\) that lies in the interior of \(c\).</p>
<p class="enddd"></p>
</dd>
<dt><a class="el" href="classArrangementXMonotoneTraits__2.html#a3d7c4f0cb7c04aa4cf124c10e556b066"><b><code>Are_mergeable_2</code></b></a>: </dt>
<dd><p class="startdd">Determines whether two \( x\)-monotone curves \(c_1\) and \(c_2\) that share a common endpoint can be merged into a single continuous \(x\)-monotone curve representable by the traits class.<span class="footnote">On the face of it this seems a difficult predicate to implement. In practice we use very simple tests to decide whether two curves are mergeable: We check whether their underlying curves are identical and whether they do not bend to form a non- \(x\)-monotone curve.</span></p>
<p class="enddd"></p>
</dd>
<dt><a class="el" href="classArrangementXMonotoneTraits__2.html#a5fe8859feff75f588bf2000d72087fc9"><b><code>Merge_2</code></b></a>: </dt>
<dd><p class="startdd">Merges two mergeable \(x\)-monotone curves into a single curve.</p>
<p class="enddd"></p>
</dd>
<dt><a class="el" href="classArrangementXMonotoneTraits__2.html#a52bad98a97d6c02f8ea18e4a8eb78c2a"><b><code>Intersect_2</code></b></a>: </dt>
<dd><p class="startdd">Computes all intersection points and overlapping sections of two given \(x\)-monotone curves. If possible, computes also the multiplicity of each intersection point. Providing the multiplicity of an intersection point is not required, but it can expedite the arrangement construction. Typically, the multiplicity is a byproduct of the intersection computation. However, if it is not available, undefined multiplicity (coded as 0) is assumed. Having the multiplicity of intersection points while constructing arrangements enables the exploitation of the geometric knowledge intersection points may have.</p>
<p class="enddd"></p>
</dd>
</dl>
<p>Using a model of the <code><a class="el" href="classArrangementXMonotoneTraits__2.html" title="The concept ArrangementXMonotoneTraits_2 refines the basic arrangement-traits concept. A model of this concept is able to handle -monotone curves that intersect in their interior (and points that coincide with curve interiors). This is necessary for constructing arrangements of sets of intersecting -monotone curves. ">ArrangementXMonotoneTraits_2</a></code> it is possible to construct arrangements of sets of \(x\)-monotone curves (and points) that may intersect one another. The two operations listed above, regarding the merging of curves, are optional, and should be provided only if the type <code>Has_merge_category</code> nested in a model of the <code><a class="el" href="classArrangementXMonotoneTraits__2.html" title="The concept ArrangementXMonotoneTraits_2 refines the basic arrangement-traits concept. A model of this concept is able to handle -monotone curves that intersect in their interior (and points that coincide with curve interiors). This is necessary for constructing arrangements of sets of intersecting -monotone curves. ">ArrangementXMonotoneTraits_2</a></code> concept is defined as <code>Tag_true</code>. Otherwise, it is not possible to merge \(x\)-monotone curve and redundant vertices may be left in the arrangement due to the removal of edges.</p>
<h3><a class="anchor" id="aos_sssec-geom_traits-concepts_arbitrary"></a>
Supporting Arbitrary Curves</h3>
<p>The concept <code><a class="el" href="classArrangementTraits__2.html" title="The concept ArrangementTraits_2 allows the construction of arrangement of general planar curves...">ArrangementTraits_2</a></code> refines the <code><a class="el" href="classArrangementXMonotoneTraits__2.html" title="The concept ArrangementXMonotoneTraits_2 refines the basic arrangement-traits concept. A model of this concept is able to handle -monotone curves that intersect in their interior (and points that coincide with curve interiors). This is necessary for constructing arrangements of sets of intersecting -monotone curves. ">ArrangementXMonotoneTraits_2</a></code> concept. A model of the refined concept must define an additional type that is used to represent general, not necessarily \(x\)-monotone and not necessarily continuous, curves, named <a class="el" href="classArrangementTraits__2.html#a2cb306c890ab7d32f397b5d246e0271f"><code>Curve_2</code></a>. It also has to support the subdivision of a curve of that type into a set of continuous \(x\)-monotone curves and isolated points. For example, the curve \(c:\ (x^2 + y^2)(x^2 + y^2 - 1) = 0\) comprises the unit circle (the locus of all points for which \(x^2 + y^2 = 1\)) and the origin (the singular point \((0,0)\)). \(c\) should therefore be subdivided into two circular arcs, the upper part and the lower part of the unit circle, and a single isolated point. In particular a model of the refined concept has to support the following additional operation:</p>
<dl>
<dt><a class="el" href="classArrangementTraits__2.html#ae7fb20dc627766bd122192d6e5c1da57"><b><code>Make_x_monotone_2</code></b></a>: </dt>
<dd><p class="startdd">Divides a given general curve of type <a class="el" href="classArrangementTraits__2.html#a2cb306c890ab7d32f397b5d246e0271f"><code>Curve_2</code></a> into continuous weakly \(x\)-monotone curves and isolated points.</p>
<p class="enddd"></p>
</dd>
</dl>
<p>Note that a model of the refined concept <code><a class="el" href="classArrangementTraits__2.html" title="The concept ArrangementTraits_2 allows the construction of arrangement of general planar curves...">ArrangementTraits_2</a></code> is required only when using the free <code><a class="el" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94" title="% inserts one or more curves or -monotone curves into a given arrangement, where no restrictions are ...">insert()</a></code> function templates (see Section <a class="el" href="index.html#arr_secgl_funcs">Free Functions</a>) that accept an object of type <a class="el" href="classArrangementTraits__2.html#a2cb306c890ab7d32f397b5d246e0271f"><code>Curve_2</code></a> or a range of objects of that type. In all other cases it is sufficient to use a model of the <code><a class="el" href="classArrangementXMonotoneTraits__2.html" title="The concept ArrangementXMonotoneTraits_2 refines the basic arrangement-traits concept. A model of this concept is able to handle -monotone curves that intersect in their interior (and points that coincide with curve interiors). This is necessary for constructing arrangements of sets of intersecting -monotone curves. ">ArrangementXMonotoneTraits_2</a></code> concept.</p>
<h3><a class="anchor" id="aos_sssec-tr_landmarks_concept"></a>
The Landmark Concept</h3>
<p><a class="anchor" id="fig__aos_fig-landmark_concept_cluster"></a></p><div class="image">
<img src="landmark_concept_cluster.png" alt="landmark_concept_cluster.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-landmark_concept_cluster">Figure 34.18</a> The traits-concept hierarchy for arrangements associated with the landmark point-location strategy.  </div> <br /> 
<p>The type of an arrangement associated with the landmark point-location strategy (see Section <a class="el" href="index.html#arr_ssecpl">Point-Location Queries</a>) must be an instance of the <code><a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html">Arrangement_on_surface_2</a>&lt;GeomTraits, TopolTraits&gt;</code> class template, where the <code>GeomTraits</code> parameter is substituted with a model of the concept <code><a class="el" href="classArrangementLandmarkTraits__2.html" title="The concept ArrangementLandmarkTraits_2 refines the traits concepts ArrangementApproximateTraits_2 an...">ArrangementLandmarkTraits_2</a></code>. (Naturally, it can also model either the <code><a class="el" href="classArrangementXMonotoneTraits__2.html" title="The concept ArrangementXMonotoneTraits_2 refines the basic arrangement-traits concept. A model of this concept is able to handle -monotone curves that intersect in their interior (and points that coincide with curve interiors). This is necessary for constructing arrangements of sets of intersecting -monotone curves. ">ArrangementXMonotoneTraits_2</a></code> concept or the <code><a class="el" href="classArrangementTraits__2.html" title="The concept ArrangementTraits_2 allows the construction of arrangement of general planar curves...">ArrangementTraits_2</a></code> concept.) The <code><a class="el" href="classArrangementLandmarkTraits__2.html" title="The concept ArrangementLandmarkTraits_2 refines the traits concepts ArrangementApproximateTraits_2 an...">ArrangementLandmarkTraits_2</a></code> concept refines the two concepts <code><a class="el" href="classArrangementApproximateTraits__2.html" title="The concept ArrangementApproximateTraits_2 refines the basic traits concept ArrangementBasicTraits_2...">ArrangementApproximateTraits_2</a></code> and <code><a class="el" href="classArrangementConstructXMonotoneCurveTraits__2.html" title="The concept ArrangementConstructXMonotoneCurveTraits_2 refines the basic traits concept ArrangementBa...">ArrangementConstructXMonotoneCurveTraits_2</a></code>. Each of these two concepts, in turn, refines the concept <code><a class="el" href="classArrangementBasicTraits__2.html" title="The concept ArrangementBasicTraits_2 defines the minimal set of geometric predicates needed for the c...">ArrangementBasicTraits_2</a></code>.</p>
<p>A model of the <code><a class="el" href="classArrangementApproximateTraits__2.html" title="The concept ArrangementApproximateTraits_2 refines the basic traits concept ArrangementBasicTraits_2...">ArrangementApproximateTraits_2</a></code> concept must define a fixed precision number type (typically the double-precision floating-point <code>double</code>) and support the operation below (in addition to fulfilling the requirements listed by the <code><a class="el" href="classArrangementBasicTraits__2.html" title="The concept ArrangementBasicTraits_2 defines the minimal set of geometric predicates needed for the c...">ArrangementBasicTraits_2</a></code> concept).</p>
<dl>
<dt><a class="el" href="classArrangementApproximateTraits__2.html#a3551846d630a43eeb909df416f363b5f"><b><code>Approximate_2</code></b></a>: </dt>
<dd><p class="startdd">Given a point <code>p</code>, approximate the \(x\) and \(y\)-coordinates of <code>p</code> using a not necessarily multi-precision number type. We use this operation for approximate computations—there are certain operations performed during the search for the location of the point that need not be exact, and that can be performed faster when carried out, for example, using a fixed-precision number type.</p>
<p class="enddd"></p>
</dd>
</dl>
<p>A model of the <code><a class="el" href="classArrangementConstructXMonotoneCurveTraits__2.html" title="The concept ArrangementConstructXMonotoneCurveTraits_2 refines the basic traits concept ArrangementBa...">ArrangementConstructXMonotoneCurveTraits_2</a></code> concept must support the operation below (in addition to fulfilling the requirements listed by the <code><a class="el" href="classArrangementBasicTraits__2.html" title="The concept ArrangementBasicTraits_2 defines the minimal set of geometric predicates needed for the c...">ArrangementBasicTraits_2</a></code> concept).</p>
<dl>
<dt><a class="el" href="classArrangementConstructXMonotoneCurveTraits__2.html#addb559fd707a1be35f3f3e6a848d2d24"><b><code>Construct_x_monotone_curve_2</code></b></a>: </dt>
<dd><p class="startdd">Given two points \(p_1\) and \(p_2\), construct an \(x\)-monotone curve connecting \(p_1\) and \(p_2\).</p>
<p class="enddd"></p>
</dd>
</dl>
<p>Most traits classes model the <code><a class="el" href="classArrangementTraits__2.html" title="The concept ArrangementTraits_2 allows the construction of arrangement of general planar curves...">ArrangementTraits_2</a></code> concept, and some also model the <code><a class="el" href="classArrangementLandmarkTraits__2.html" title="The concept ArrangementLandmarkTraits_2 refines the traits concepts ArrangementApproximateTraits_2 an...">ArrangementLandmarkTraits_2</a></code> concept.</p>
<h3><a class="anchor" id="aos_ssec-traits-curved"></a>
Supporting Unbounded Curves or Curved Surfaces</h3>
<p>We descend to the bottom level of the hierarchy. The refinements described in this section provide the requirements imposed on traits classes used with arrangements induced by curves with boundary conditions. In particular, these requirements list additional operations that handle curves that either reach specific sides of the parameter-space boundary (the pre-images of their endpoints lie on boundary sides) or approach them (the pre-images of their endpoints approach boundary sides). These boundary conditions typically occur with unbounded curves or with arrangements embedded in curved surfaces. The category types <a class="el" href="classArrangementBasicTraits__2.html#a71e663e1e6e125a70aedf6ab2c82e95f"><code>Left_side_category</code></a>, <a class="el" href="classArrangementBasicTraits__2.html#a51ec39783adcc206066f6075bee4ba77"><code>Right_side_category</code></a>, <a class="el" href="classArrangementBasicTraits__2.html#ad1c0c7aecbb67a46314b49271af64795"><code>Bottom_side_category</code></a>, and <a class="el" href="classArrangementBasicTraits__2.html#ad4077ad8b432735b265f25aa8aafa083"><code>Top_side_category</code></a>, nested in every geometry traits class indicate whether the corresponding boundary side (i.e., left, right, bottom, and top) is open, closed, contracted, or identified, and whether this information is relevant at all. When all curves inserted into the arrangement are expected to neither approach nor reach that particular boundary side, the information is irrelevant. (Note that we explicitly distinguish closed-only, contracted, and identified sides, although the latter two are closed in the parameter space as well.) Each one of the categories above must be convertible to one of the tag types listed below according to the boundary condition that should be handled.</p>
<ul>
<li>
<code><a class="el" href="structCGAL_1_1Arr__open__side__tag.html" title="This type tag is used to indicate that a side of the parameter space, either left, right, bottom, or top, is open, and curves that approach this side might be inserted into the arrangement. ">Arr_open_side_tag</a></code> </li>
<li>
<code><a class="el" href="structCGAL_1_1Arr__closed__side__tag.html" title="This type tag is used to indicate that a side of the parameter space, either left, right, bottom, or top, is closed, and curves that reach this side might be inserted into the arrangement. ">Arr_closed_side_tag</a></code> </li>
<li>
<code><a class="el" href="structCGAL_1_1Arr__contracted__side__tag.html" title="This type tag is used to indicate that a side of the parameter space, either left, right, bottom, or top, is contracted, and curves that approach this side might be inserted into the arrangement. ">Arr_contracted_side_tag</a></code> </li>
<li>
<code><a class="el" href="structCGAL_1_1Arr__identified__side__tag.html" title="This type tag is used to indicate that a side of the parameter space, either left, right, bottom, or top, is identified, and curves that approach this side might be inserted into the arrangement. ">Arr_identified_side_tag</a></code> </li>
<li>
<p class="startli"><code><a class="el" href="structCGAL_1_1Arr__oblivious__side__tag.html" title="This type tag is used to indicate that the condition of a boundary side of the parameter space is irr...">Arr_oblivious_side_tag</a></code></p>
<p class="endli"></p>
</li>
</ul>
<p>For each of the four sides of the parameter space there are four available concepts, models of which can be used to handle open, closed, contracted, and identified sides, respectively. (When curves are expected to neither reach nor approach a particular side, special handling is not required; thus, there is no need for a corresponding concept.) For example, it is required that the category type <a class="el" href="classArrangementOpenBottomTraits__2.html#ab62f6a0eb0874c017425cc84e7ec91c9"><code>Bottom_side_category</code></a>, nested in models of the concept <code><a class="el" href="classArrangementOpenBottomTraits__2.html" title="A model of the concept ArrangementOpenBottomTraits_2 must be used when the parameter space of the sur...">ArrangementOpenBottomTraits_2</a></code>, is convertible to the tag type <code><a class="el" href="structCGAL_1_1Arr__open__side__tag.html" title="This type tag is used to indicate that a side of the parameter space, either left, right, bottom, or top, is open, and curves that approach this side might be inserted into the arrangement. ">Arr_open_side_tag</a></code>. This makes for a total of 16 abstract concepts (combine one of left, right, bottom, and top with one of open, closed, contracted, identified). Any one of these individual abstract concept is useless on its own; only concepts that refine a combination of 0, 1, 2, 3, or 4 abstract concepts (which capture the conditions that occur in the four sides simultaneously) are purposeful. Theoretically, there are \(\sum_{i=0}^4\binom{i}{4} \cdot 4^i = 5^4 = 625\) such concepts. However, only a subset of them is meaningful. If a side is identified, the opposite side must also be identified. In addition, a contracted side must be adjacent to two identified sides. While this narrows down the number of tangible concepts, the total number is still high; in practice we have used only two so far (not counting the "plain" concept, models of which do not handle boundary conditions at all), namely, <code><a class="el" href="classArrangementOpenBoundaryTraits__2.html" title="Several predicates are required to handle -monotone curves that approach infinity and thus approach t...">ArrangementOpenBoundaryTraits_2</a></code> and <code><a class="el" href="classArrangementSphericalBoundaryTraits__2.html" title="Models of the concept ArrangementSphericalBoundaryTraits_2 handle curves on a sphere or a surface tha...">ArrangementSphericalBoundaryTraits_2</a></code>; see below for more details. Many of the traits class-templates provided by the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgArrangementOnSurface2">2D Arrangements</a> package do not handle boundary conditions at all. Some of them, such as the <code><a class="el" href="classCGAL_1_1Arr__segment__traits__2.html" title="The traits class Arr_segment_traits_2 is a model of the ArrangementTraits_2 concept, which allows the construction and maintenance of arrangements of line segments. ">Arr_segment_traits_2</a></code> traits (see Section <a class="el" href="index.html#arr_ssectr_segs">Traits Classes for Line Segments and Linear Objects</a>) only handle bounded curves. Thus, the four category types nested in these models are defined to be <code><a class="el" href="structCGAL_1_1Arr__oblivious__side__tag.html" title="This type tag is used to indicate that the condition of a boundary side of the parameter space is irr...">Arr_oblivious_side_tag</a></code>.</p>
<p><a class="anchor" id="fig__aos_fig-open_concept_hierarchy"></a></p><div class="image">
<img src="open_concept_hierarchy.png" alt="open_concept_hierarchy.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-open_concept_hierarchy">Figure 34.19</a> Bottom portion of the refinement hierarchy of the geometry-traits concepts for curves embedded in an open surface, for instance, the entire plane.  </div> <br /> 
<p>Several predicates are required to handle \(x\)-monotone curves that approach the boundary of the parameter space. These predicates are sufficient to handle not only curves embedded in an unbounded parameter space, but also curves embedded in a bounded parameter space with open boundaries. The arrangement type instantiated with a traits class that models the combined concept <code><a class="el" href="classArrangementOpenBoundaryTraits__2.html" title="Several predicates are required to handle -monotone curves that approach infinity and thus approach t...">ArrangementOpenBoundaryTraits_2</a></code> shown in <a class="el" href="index.html#fig__aos_fig-open_concept_hierarchy">Figure 34.19</a> can handle curves that are open in any direction. Recall that an arrangement that supports unbounded \(x\)-monotone curves maintains an implicit bounding rectangle in the DCEL structure; see Section <a class="el" href="index.html#aos_sec-unbounded">Arrangements of Unbounded Curves</a>. If some curves inserted into an arrangement object are expected to be unbounded; namely, there exists \(d \in \{0,1\}\) such that \(\lim_{t \rightarrow d}x(t) = \pm\infty\) or \(\lim_{t \rightarrow d}y(t) = \pm\infty\) holds for at least one input curve \(c(t) = (x(t),y(t))\), the arrangement template must be instantiated with a model of the <code><a class="el" href="classArrangementOpenBoundaryTraits__2.html" title="Several predicates are required to handle -monotone curves that approach infinity and thus approach t...">ArrangementOpenBoundaryTraits_2</a></code> concept.<span class="footnote">A curve that reaches the boundary of the parameter space in this case is open and unbounded.</span></p>
<p><a class="anchor" id="fig__aos_fig-spherical_concept_hierarchy"></a></p><div class="image">
<img src="spherical_concept_hierarchy.png" alt="spherical_concept_hierarchy.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-spherical_concept_hierarchy">Figure 34.20</a> Bottom portion of the refinement hierarchy of the geometry-traits concepts for curves embedded in a sphere-like parameterized surface  </div> <br /> 
<p>A suitable geometry-traits component for arrangements embedded in surfaces homeomorphic to a sphere is a model of the combined concept <code><a class="el" href="classArrangementSphericalBoundaryTraits__2.html" title="Models of the concept ArrangementSphericalBoundaryTraits_2 handle curves on a sphere or a surface tha...">ArrangementSphericalBoundaryTraits_2</a></code> shown in <a class="el" href="index.html#fig__aos_fig-spherical_concept_hierarchy">Figure 34.20</a>. Here the two vertical sides of the parameter space are identified and the two horizontal sides are contracted.</p>
<p><a class="anchor" id="fig__aos_fig-left_side_cluster"></a></p><div class="image">
<img src="left_side_cluster.png" alt="left_side_cluster.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-left_side_cluster">Figure 34.21</a> Top portion of the refinement hierarchy of the geometry-traits concepts for curves that either reach the left side of the boundary of the parameter space or approach it. A similar hierarchy also exists for the right, bottom, and top sides.  </div> <br /> 
<p>The shared requirements for the four options of a side are collected in abstract layers called <code><a class="el" href="classArrangementLeftSideTraits__2.html" title="ArrangementLeftSideTraits_2 is an abstract concept. It generalizes all concepts that handle curves th...">ArrangementLeftSideTraits_2</a></code>, <code><a class="el" href="classArrangementRightSideTraits__2.html" title="ArrangementRightSideTraits_2 is an abstract concept. It generalizes all concepts that handle curves t...">ArrangementRightSideTraits_2</a></code>, <code><a class="el" href="classArrangementBottomSideTraits__2.html" title="ArrangementBottomSideTraits_2 is an abstract concept. It generalizes all concepts that handle curves ...">ArrangementBottomSideTraits_2</a></code>, and <code><a class="el" href="classArrangementTopSideTraits__2.html" title="ArrangementTopSideTraits_2 is an abstract concept. It generalizes all concepts that handle curves tha...">ArrangementTopSideTraits_2</a></code>; see, e.g., <a class="el" href="index.html#fig__aos_fig-left_side_cluster">Figure 34.21</a>.</p>
<p><a class="anchor" id="fig__aos_fig-side_clusters"></a></p><div class="image">
<img src="side_clusters.png" alt="side_clusters.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-side_clusters">Figure 34.22</a> Top portion of the refinement hierarchy of the geometry-traits concepts for curves that either reach the vertical sides of the boundary of the parameter space or approach it, and similarly for curves that either reach or approach horizontal sides.  </div> <br /> 
<p>The shared requirements for the options of opposite sides are collected in two additional abstract layers called <code><a class="el" href="classArrangementVerticalSideTraits__2.html" title="ArrangementClosedIdentifiedVerticalTraits_2 is an abstract concept. It generalizes the concepts Arran...">ArrangementVerticalSideTraits_2</a></code> and <code><a class="el" href="classArrangementHorizontalSideTraits__2.html" title="ArrangementHorizontalSideTraits_2 is an abstract concept. It generalizes all concepts that handle cur...">ArrangementHorizontalSideTraits_2</a></code>; see <a class="el" href="index.html#fig__aos_fig-side_clusters">Figure 34.22</a>.</p>
<p><a class="anchor" id="fig__aos_fig-identified_clusters"></a></p><div class="image">
<img src="identified_clusters.png" alt="identified_clusters.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-identified_clusters">Figure 34.23</a> Top portion of the refinement hierarchy of the geometry-traits concepts for curves that reach the identified vertical sides of the parameter space and for curves that reach the identified horizontal sides of the parameter space.  </div> <br /> 
<p>Individual concepts for curves that reach the identified left side of the parameter space and for curves that reach the identified right side of the parameter space do not exist, because if one side is identified the opposite side must be identified as well. Similarly, individual concepts for curves that reach the identified bottom side of the parameter space and for curves that reach the identified top side of the parameter space do not exist either. Instead, the shared requirements for opposite identified sides are collected in two additional abstract concepts called <code><a class="el" href="classArrangementIdentifiedVerticalTraits__2.html" title="A model of the concept ArrangementIdentifiedVerticalTraits_2 must be used when the parameter space of...">ArrangementIdentifiedVerticalTraits_2</a></code> and <code><a class="el" href="classArrangementIdentifiedHorizontalTraits__2.html" title="A model of the concept ArrangementIdentifiedHorizontalTraits_2 must be used when the parameter space ...">ArrangementIdentifiedHorizontalTraits_2</a></code>; see <a class="el" href="index.html#fig__aos_fig-identified_clusters">Figure 34.23</a>. The former lists requirements for operations that handle curves that reach identified vertical sides of the parameter space, and the latter lists requirements for operations that handle curves that reach identified horizontal sides of the parameter space.</p>
<p>In the following we list the specific requirements of all the aforementioned concepts.</p>
<p>The abstract concept <code><a class="el" href="classArrangementVerticalSideTraits__2.html" title="ArrangementClosedIdentifiedVerticalTraits_2 is an abstract concept. It generalizes the concepts Arran...">ArrangementVerticalSideTraits_2</a></code> requires the following predicate:</p>
<dl>
<dt><a class="el" href="classArrangementVerticalSideTraits__2.html#aa5f28542a43863ce2d5d5d02d40b9b31"><b><code>Parameter_space_in_x_2</code></b></a>: </dt>
<dd><p class="startdd">This three-valued predicate is overloaded with two versions as follows:</p>
<p>(i) Given a curve \(c = (x(t), y(t))\) and an enumerator that specifies either the minimum end or the maximum end of the curve, and thus maps to a parameter value \(d \in \{0,1\}\), determine the location of the \(d\)-end of \(c\) along the \(x\)-dimension. Formally, if \(c\) is open at its \(d\)-end, determine whether \(\lim_{t \rightarrow d} x(t)\) evaluates to \(x_{\rm min}\), \(x_{\rm max}\), or a value in between. If \(c\) is not open at its \(d\)-end, determine whether \(x(d)\) is equal to \(x_{\rm min}\), \(x_{\rm max}\), or a value in between. Return <code><a class="el" href="group__PkgArrangementOnSurface2Enums.html#ga2bbdd8004c0a37409305b01cf7fc2563">CGAL::ARR_LEFT_BOUNDARY</a></code>, <code><a class="el" href="group__PkgArrangementOnSurface2Enums.html#ga341fb5c90e8037d651012f955e38fda1">CGAL::ARR_RIGHT_BOUNDARY</a></code>, or <code><a class="el" href="group__PkgArrangementOnSurface2Enums.html#gad93bd71ee623a2e4fded635967e9c8d2">CGAL::ARR_INTERIOR</a></code>, accordingly. If \(c\) is vertical and lies on a vertical boundary; that is, either \(\forall p=(x_p, y_p) \in c\) we have \(x_p = x_{\rm min}\) or \(\forall p=(x_p, y_p) \in c\) we have \(x_p = x_{\rm max}\), then the boundary side containing \(c\) cannot be open.</p>
<p>(ii) Given a point \(p=(x_p, y_p)\), determine the location of the point with respect to the \(x\)-axis. Formally, determine whether \(x_p\) is equal to \(x_{\rm min}\), \(x_{\rm max}\), or a value in between. Return <code><a class="el" href="group__PkgArrangementOnSurface2Enums.html#ga2bbdd8004c0a37409305b01cf7fc2563">CGAL::ARR_LEFT_BOUNDARY</a></code>, <code><a class="el" href="group__PkgArrangementOnSurface2Enums.html#ga341fb5c90e8037d651012f955e38fda1">CGAL::ARR_RIGHT_BOUNDARY</a></code>, or <code><a class="el" href="group__PkgArrangementOnSurface2Enums.html#gad93bd71ee623a2e4fded635967e9c8d2">CGAL::ARR_INTERIOR</a></code>, accordingly. If \(p\) is on a vertical boundary; that is, \(x_p \in \{x_{\rm min},x_{\rm max}\}\), then the boundary side containing \(p\) cannot be open and must not be identified. In other words, this overloaded version is required only for the concepts <code><a class="el" href="classArrangementClosedLeftTraits__2.html" title="A model of the concept ArrangementClosedLeftTraits_2 must be used when the parameter space of the sur...">ArrangementClosedLeftTraits_2</a></code>, <code><a class="el" href="classArrangementClosedRightTraits__2.html" title="A model of the concept ArrangementClosedRightTraits_2 must be used when the parameter space of the su...">ArrangementClosedRightTraits_2</a></code>, <code><a class="el" href="classArrangementContractedLeftTraits__2.html" title="A model of the concept ArrangementContractedLeftTraits_2 must be used when the parameter space of the...">ArrangementContractedLeftTraits_2</a></code> and <code><a class="el" href="classArrangementContractedRightTraits__2.html" title="A model of the concept ArrangementContractedRightTraits_2 must be used when the parameter space of th...">ArrangementContractedRightTraits_2</a></code>.</p>
<p class="enddd"></p>
</dd>
</dl>
<p>The abstract concept <code><a class="el" href="classArrangementHorizontalSideTraits__2.html" title="ArrangementHorizontalSideTraits_2 is an abstract concept. It generalizes all concepts that handle cur...">ArrangementHorizontalSideTraits_2</a></code> requires the following predicate:</p>
<dl>
<dt><a class="el" href="classArrangementHorizontalSideTraits__2.html#ade2b2e1b437891f6f570f64df975636f"><b><code>Parameter_space_in_y_2</code></b></a>: </dt>
<dd><p class="startdd">This three-valued predicate is overloaded with two versions as follows:</p>
<p>(i) Given a curve \(c = (x(t), y(t))\) and an enumerator that specifies either the minimum end or the maximum end of the curve, and thus maps to a parameter value \(d \in \{0,1\}\), determine the location of the \(d\)-end of \(c\) along the \(y\)-dimension. Formally, if \(c\) is open at its \(d\)-end, determine whether \(\lim_{t \rightarrow d} y(t)\) evaluates to \(y_{\rm min}\), \(y_{\rm max}\), or a value in between. If \(c\) is not open at its \(d\)-end, determine whether \(y(d)\) is equal to \(y_{\rm min}\), \(y_{\rm max}\), or a value in between. Return <code><a class="el" href="group__PkgArrangementOnSurface2Enums.html#gaf276ca43e83c8791923154aba4584651">CGAL::ARR_BOTTOM_BOUNDARY</a></code>, <code><a class="el" href="group__PkgArrangementOnSurface2Enums.html#gaf8d89294c23614f33351e94ff28e0d59">CGAL::ARR_TOP_BOUNDARY</a></code>, or <code><a class="el" href="group__PkgArrangementOnSurface2Enums.html#gad93bd71ee623a2e4fded635967e9c8d2">CGAL::ARR_INTERIOR</a></code>, accordingly. If \(c\) is horizontal and lies on a horizontal boundary; that is, either \(\forall p=(x_p, y_p) \in c, y_p = y_{\rm min}\) or \(\forall p=(x_p, y_p) \in c, y_p = y_{\rm max}\), then the boundary side containing \(c\) cannot be open and must not be identified.</p>
<p>(ii) Given a point \(p=(x_p, y_p)\), determine the location of the point along the \(y\)-dimension. Formally, determine whether \(y_p\) is equal to \(y_{\rm min}\), \(y_{\rm max}\), or a value in between. Return <code><a class="el" href="group__PkgArrangementOnSurface2Enums.html#gaf276ca43e83c8791923154aba4584651">CGAL::ARR_BOTTOM_BOUNDARY</a></code>, <code><a class="el" href="group__PkgArrangementOnSurface2Enums.html#gaf8d89294c23614f33351e94ff28e0d59">CGAL::ARR_TOP_BOUNDARY</a></code>, or <code><a class="el" href="group__PkgArrangementOnSurface2Enums.html#gad93bd71ee623a2e4fded635967e9c8d2">CGAL::ARR_INTERIOR</a></code>, accordingly. If \(p\) is on a horizontal boundary; that is, \(y_p \in \{y_{\rm min},y_{\rm max}\}\), then the boundary side containing \(p\) cannot be open and must not be identified. In other words, this overloaded version is required only for the concepts <code><a class="el" href="classArrangementClosedBottomTraits__2.html" title="A model of the concept ArrangementClosedBottomTraits_2 must be used when the parameter space of the s...">ArrangementClosedBottomTraits_2</a></code>, <code><a class="el" href="classArrangementClosedTopTraits__2.html" title="A model of the concept ArrangementClosedTopTraits_2 must be used when the parameter space of the surf...">ArrangementClosedTopTraits_2</a></code>, <code><a class="el" href="classArrangementContractedBottomTraits__2.html" title="A model of the concept ArrangementContractedBottomTraits_2 must be used when the parameter space of t...">ArrangementContractedBottomTraits_2</a></code> and <code><a class="el" href="classArrangementContractedTopTraits__2.html" title="A model of the concept ArrangementContractedTopTraits_2 must be used when the parameter space of the ...">ArrangementContractedTopTraits_2</a></code>.</p>
<p class="enddd"></p>
</dd>
</dl>
<p>The two symmetric predicates above determine the location of a curve-end in the parameter space. However, in general, \(x\)-coordinates and \(y\)-coordinates are handled differently. This asymmetry is brought on by the various algorithms applied to arrangements, the input and output arguments of which are \(x\)-monotone curves. Indeed, all curves maintained by any arrangement are continuous weakly \(x\)-monotone curves. A non \(x\)-monotone curve is divided into \(x\)-monotone sub curves (and perhaps points) before it is inserted into an arrangement. This asymmetry is also reflected in the predicates listed below. They help determining the order of curve-ends lying on the boundary of the parameter space with respect to regular points and among each other.</p>
<p>The concept <code><a class="el" href="classArrangementVerticalSideTraits__2.html" title="ArrangementClosedIdentifiedVerticalTraits_2 is an abstract concept. It generalizes the concepts Arran...">ArrangementVerticalSideTraits_2</a></code> requires the following additional predicate:</p>
<dl>
<dt><a class="el" href="classArrangementVerticalSideTraits__2.html#ac398073ee005bd135c9b3e112cfa9c35"><b><code>Compare_y_on_boundary_2</code></b></a>: </dt>
<dd><p class="startdd">Given two points \(p_1=(x_{p_1},y_{p_1})\) and \(p_2=(x_{p_2},y_{p_2})\), such that at least one of them lies on a vertical boundary side, compare the \(y\)-coordinates of the points. That is, compare \(y_{p_1}\) and \(y_{p_2}\). If \(p_1\) (resp. \(p_2\)) is on the boundary; that is, \(x_{p_1} \in \{x_{\rm min},x_{\rm max}\}\) (resp. \(x_{p_2} \in \{x_{\rm min},x_{\rm max}\}\)), then the vertical boundary side containing \(p_1\) (resp. \(p_2\)) must be either closed or identified. In other words, this overloaded version is required only for the concepts <code><a class="el" href="classArrangementClosedLeftTraits__2.html" title="A model of the concept ArrangementClosedLeftTraits_2 must be used when the parameter space of the sur...">ArrangementClosedLeftTraits_2</a></code>, <code><a class="el" href="classArrangementClosedRightTraits__2.html" title="A model of the concept ArrangementClosedRightTraits_2 must be used when the parameter space of the su...">ArrangementClosedRightTraits_2</a></code>, and <code><a class="el" href="classArrangementIdentifiedVerticalTraits__2.html" title="A model of the concept ArrangementIdentifiedVerticalTraits_2 must be used when the parameter space of...">ArrangementIdentifiedVerticalTraits_2</a></code>.</p>
<p class="enddd"></p>
</dd>
<dt><a class="el" href="classArrangementVerticalSideTraits__2.html#a4c3194c1e03aa351ccb19a820ff3fcc9"><b><code>Compare_y_near_boundary_2</code></b></a>: </dt>
<dd><table border="0" cellspacing="10">
<tr>
<td><div class="image">
<img src="compare_y_near_boundary.png" alt="compare_y_near_boundary.png" />
</div>
   </td><td><p class="starttd"></p>
<p>Given two \(x\)-monotone curves \(c_1\) and \(c_2\), and an enumerator \(i\) that specifies either the minimum ends or the maximum ends of the two curves, and thus maps to a parameter value \(d \in \{0,1\}\), compare the \(y\)-coordinates of the curves near their respective ends. More precisely, compare the \(y\)-coordinates of the vertical projections of a point \(p\) onto \(c_1\) and onto \(c_2\). If the enumerator \(i\) specifies the minimum ends, the curves must approach the left boundary-side. In this case \(p\) is located sufficiently close to the left boundary-side, such that the result is invariant under a translation of \(p\) closer to the left boundary-side. If \(i\) specifies the maximum ends, the curves must approach the right boundary-side. In that case \(p\) is located sufficiently close to the right boundary-side in a similar manner.</p>
<p class="endtd"></p>
</td></tr>
</table>
<p class="enddd"></p>
</dd>
</dl>
<p>The concept <code><a class="el" href="classArrangementHorizontalSideTraits__2.html" title="ArrangementHorizontalSideTraits_2 is an abstract concept. It generalizes all concepts that handle cur...">ArrangementHorizontalSideTraits_2</a></code> requires two additional predicates:</p>
<dl>
<dt><a class="el" href="classArrangementHorizontalSideTraits__2.html#aa69f216050ce5fee135ae6130633ca97"><b><code>Compare_x_on_boundary_2</code></b></a>: </dt>
<dd><p class="startdd">This predicate is overloaded with three versions. We distinguish between open and non-open sides as explained below.</p>
<p>(i) Given a regular point \(p=(x_p,y_p)\), an \(x\)-monotone curve \(c = (x(t),y(t))\), and an enumerator that specifies either the minimum end or the maximum end of the curve, and thus maps to a parameter value \(d \in \{0,1\}\), compare the \(x\)-coordinate of \(p\) and the \(x\)-coordinate of \(c\) at its respective limit or end depending on whether it is open or non-open. More precisely, if \(c\) is open at its \(d\)-end, compare the values \(x_p\) and \(\lim_{t \rightarrow d} x(t)\). A precondition assures that \(c\) has a vertical asymptote at its \(d\)-end; that is \(\lim_{t \rightarrow d} x(t)\) is a real value. If \(c\) is not open, compare the values \(x_p\) and \(x(d)\).</p>
<table border="0" cellspacing="10">
<tr>
<td><div class="image">
<img src="compare_x_on_boundary.png" alt="compare_x_on_boundary.png" />
</div>
   </td><td><p class="starttd"></p>
<p>(ii) Given two curves \(c_1 = (x_1(t),y_1(t))\) and \(c_2 = (x_2(t),x_2(t))\) and enumerators that specify either the minimum end or the maximum end of each curve, and thus map to parameter values \(d_1, d_2 \in \{0,1\}\), compare the \(x\)-coordinates of the curves at their respective limits or ends. More precisely, if \(c_1\) (resp. \(c_2\)) is open at its \(d_1\)-end (resp. \(d_2\)-end), use the value \(\lim_{t \rightarrow d_1} x_1(t)\) (resp. \(\lim_{t \rightarrow d_2} x_2(t)\)) for the comparison. A precondition assures that \(c_1\) (resp. \(c_2\)) has a vertical asymptote at its \(d_1\)-end (resp. \(d_2\)-end); that is \(\lim_{t \rightarrow d_1} x_1(t)\) is (resp. \(\lim_{t \rightarrow d_2} x_2(t)\)) a real value. If \(c_1\) (resp. \(c_2\)) is not open at its \(d_1\)-end (resp. \(d_2\)-end), use the value \(x_1(d_1)\) (resp. \(x_2(d_2)\)) for the comparison.</p>
<p class="endtd"></p>
</td></tr>
</table>
<p>(iii) Given two points \(p_1=(x_{p_1},y_{p_1})\) and \(p_2=(x_{p_2},y_{p_2})\), such that at least one of them lies on a horizontal boundary side, compare the \(x\)-coordinates of the points. That is, compare \(x_{p_1}\) and \(x_{p_2}\). If \(p_1\) (resp. \(p_2\)) is on the boundary; that is, \(y_{p_1} \in \{y_{\rm min},y_{\rm max}\}\) (resp. \(y_{p_2} \in \{y_{\rm min},y_{\rm max}\}\)), then the boundary side containing \(p_1\) (resp. \(p_2\)) must be either closed or identified. In other words, this overloaded version is required only for the concepts <code><a class="el" href="classArrangementClosedBottomTraits__2.html" title="A model of the concept ArrangementClosedBottomTraits_2 must be used when the parameter space of the s...">ArrangementClosedBottomTraits_2</a></code>, <code><a class="el" href="classArrangementClosedTopTraits__2.html" title="A model of the concept ArrangementClosedTopTraits_2 must be used when the parameter space of the surf...">ArrangementClosedTopTraits_2</a></code>, and <code><a class="el" href="classArrangementIdentifiedHorizontalTraits__2.html" title="A model of the concept ArrangementIdentifiedHorizontalTraits_2 must be used when the parameter space ...">ArrangementIdentifiedHorizontalTraits_2</a></code>.</p>
<p class="enddd"></p>
</dd>
<dt><a class="el" href="classArrangementHorizontalSideTraits__2.html#a2209149517f07ed6f82db58d8d68f6e9"><b><code>Compare_x_near_boundary_2</code></b></a>: </dt>
<dd><table border="0" cellspacing="10">
<tr>
<td><div class="image">
<img src="compare_x_near_boundary.png" alt="compare_x_near_boundary.png" />
</div>
   </td><td><p class="starttd"></p>
<p>Given two \(x\)-monotone curves \(c_1\) and \(c_2\) and an enumerator \(i\) that specifies either the minimum ends or the maximum ends of the two curves, and thus map to parameter values \(d_1, d_2 \in \{0,1\}\), respectively, compare the \(x\)-coordinate of the curves near their respective limits or ends. A precondition assures that the \(x\)-coordinates of the limits or ends of the curves at their respective ends are equal. That is, the predicate <code>Compare_x_on_boundary_2</code> applied to \(c_1\), \(c_2\), and \(i\) evaluates to <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#gga84351c7e66be00efccd4ab1a61070469a5f224784e56ca565837a5d6d268fe078">CGAL::EQUAL</a></code>. Formally, compare the \(x\)-coordinates of the horizontal projection of a point \(p\) onto \(c_1\) and onto \(c_2\). A precondition assures that \(c_1\) and \(c_2\) have vertical asymptotes at their respective ends. Furthermore, both curves approach the same boundary-side, either the bottom or the top, at their respective ends. If both curves approach the bottom boundary-side, \(p\) is located far to the bottom, such that the result is invariant under a translation of \(p\) farther to the bottom. If both curves approach the top boundary-side, \(p\) is located far to the top in a similar manner.</p>
<p class="endtd"></p>
</td></tr>
</table>
<p class="enddd"></p>
</dd>
</dl>
<p>The concept <code><a class="el" href="classArrangementIdentifiedVerticalTraits__2.html" title="A model of the concept ArrangementIdentifiedVerticalTraits_2 must be used when the parameter space of...">ArrangementIdentifiedVerticalTraits_2</a></code> requires the following predicate:</p>
<dl>
<dt><a class="el" href="classArrangementIdentifiedVerticalTraits__2.html#a25e81de87d3f3fe7f50668c6efb0698a"><b><code>Is_on_y_identification_2</code></b></a>: </dt>
<dd><p class="startdd">This predicate is overloaded with two versions.</p>
<p>(i) Given a point \(p=(x_p, y_p)\), determine whether \(p\) lies in the image of the vertical (and identified) sides of the boundary. More precisely, determine whether \(x_p \in \{x_{\rm min},x_{\rm max}\}\) for all pre-images of \(p\).</p>
<p>(ii) Given a curve \(c\), determine whether the entire curve \(c\) lies in the image of the vertical (and identified) sides of the boundary.</p>
<p class="enddd"></p>
</dd>
</dl>
<p>Similarly, the concept <code><a class="el" href="classArrangementIdentifiedHorizontalTraits__2.html" title="A model of the concept ArrangementIdentifiedHorizontalTraits_2 must be used when the parameter space ...">ArrangementIdentifiedHorizontalTraits_2</a></code> requires the following predicate:</p>
<dl>
<dt><a class="el" href="classArrangementIdentifiedHorizontalTraits__2.html#a27b52387b49e8e41a31383105b0e1271"><b><code>Is_on_x_identification_2</code></b></a>: </dt>
<dd><p class="startdd">This predicate is overloaded with two versions.</p>
<p>(i) Given a point \(p=(x_p, y_p)\), determine whether \(p\) lies in the image of the horizontal (and identified) sides of the boundary. More precisely, determine whether \(y_p \in \{y_{\rm min},y_{\rm max}\}\) for all pre-images of \(p\).</p>
<p>(ii) Given a curve \(c\), determine whether the entire curve \(c\) lies in the image of the horizontal (and identified) sides of the boundary.</p>
<p class="enddd"></p>
</dd>
</dl>
<h2><a class="anchor" id="aos_ssec-geom_traits-models"></a>
Models of the Geometry Traits Concepts</h2>
<p>In this section we review the traits classes that are models of concepts introduced in the previous sections. They handle line segments, circular arcs, polylines, conic arcs, rational functions, arcs of Bézier, and arcs of algebraic curves. The last subsection describes decorators for geometric traits classes distributed with CGAL, which extend geometric traits-classes by attaching auxiliary data with the geometric objects.</p>
<h3><a class="anchor" id="arr_ssectr_segs"></a>
Traits Classes for Line Segments and Linear Objects</h3>
<p>There are two distinct traits classes that handle line segments. One caches information in the curve records (see Section <a class="el" href="index.html#arr_sssectr_caching_segs">The Caching Segment-Traits Class</a>), while the other retains the minimal amount of data (see Section <a class="el" href="index.html#arr_sssectr_non_caching_segs">The Non-Caching Segment-Traits Class</a>). Operations on arrangements instantiated with the former traits class consume more space, but they are more efficient for dense arrangements (namely, arrangements induced by line segments with a large number of intersections). Another model handles not only (bounded) line segments, but also rays and lines; see Section <a class="el" href="index.html#arr_sssectr_linear">The Linear-Traits Class</a>.</p>
<h4><a class="anchor" id="arr_sssectr_caching_segs"></a>
The Caching Segment-Traits Class</h4>
<p>An instance of the <code><a class="el" href="classCGAL_1_1Arr__segment__traits__2.html" title="The traits class Arr_segment_traits_2 is a model of the ArrangementTraits_2 concept, which allows the construction and maintenance of arrangements of line segments. ">Arr_segment_traits_2</a>&lt;<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>&gt;</code> class template used in most example programs so far is instantiated by substituting the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a></code> template parameter with a geometric kernel that must conform to the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a></code> concept; see Package <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__PkgKernel23Concepts.html">Concepts</a>. This traits class defines its point type to be the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a></code> type. However, neither the <a class="el" href="classCGAL_1_1Arr__segment__traits__2.html#ae9748d8e9803fc46af307d41f8613b79"><code>Curve_2</code></a> nor the <a class="el" href="classCGAL_1_1Arr__segment__traits__2_1_1X__monotone__curve__2.html"><code>X_monotone_curve_2</code></a> nested types of the traits are defined as the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Segment__2.html">Kernel::Segment_2</a></code> type. A kernel segment is represented by its two endpoints, and these may have a large bit size representation when the segment is the result of several split operations in comparison with the representation of the original-segment endpoints. The large bit size representation may significantly slow down the various traits-class operations involving such segments. (A straightforward solution would be to repeatedly normalize the results of all computations. However, our experience shows that indiscriminate normalization considerably slows down the arrangement construction.)</p>
<p>In contrast, the <code><a class="el" href="classCGAL_1_1Arr__segment__traits__2.html" title="The traits class Arr_segment_traits_2 is a model of the ArrangementTraits_2 concept, which allows the construction and maintenance of arrangements of line segments. ">Arr_segment_traits_2</a></code> class template represents a segment using its supporting line in addition to the two endpoints. Most computations are performed on the supporting line, which never changes as the segment is split. The <code><a class="el" href="classCGAL_1_1Arr__segment__traits__2.html" title="The traits class Arr_segment_traits_2 is a model of the ArrangementTraits_2 concept, which allows the construction and maintenance of arrangements of line segments. ">Arr_segment_traits_2</a></code> class template also caches some additional information with each segment to speed up various predicates, i.e., two Boolean flags indicating (i) whether the segment is vertical and (ii) whether the segment target-point is lexicographically larger than its source. The calculation of the supporting line and two Boolean flags is delayed to the point in time when needed to achieve further improvement in efficiency. An <a class="el" href="classCGAL_1_1Arr__segment__traits__2_1_1X__monotone__curve__2.html"><code>X_monotone_curve_2</code></a> object is still constructible from two endpoints or from a kernel segment and converted to an <code>X_monotone_curve_2</code> object. Moreover, an <a class="el" href="classCGAL_1_1Arr__segment__traits__2_1_1X__monotone__curve__2.html"><code>X_monotone_curve_2</code></a> instance can also be cast or to a <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Segment__2.html">Kernel::Segment_2</a></code> object. The two types are thus convertible to one another.</p>
<p>Computing the intersection between two segments is preceded by an application of an efficient predicate that tests whether an intersection exists at all. This optimization has negligible overhead; Thus, using an instance of the <code><a class="el" href="classCGAL_1_1Arr__segment__traits__2.html" title="The traits class Arr_segment_traits_2 is a model of the ArrangementTraits_2 concept, which allows the construction and maintenance of arrangements of line segments. ">Arr_segment_traits_2</a>&lt;<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>&gt;</code> class template is still very efficient when constructing arrangements induced by line segments with a large number of intersections. Efficiency is affected by the substituted geometric kernel. Using <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">Exact_predicates_exact_constructions_kernel</a></code> as the kernel type is in general not a bad choice; the coordinates of the segment endpoints are represented as multi-precision rational numbers, which ensures the correctness of all computations regardless of the input. Computations on multi-precision number types (such as <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Gmpq.html">Gmpq</a></code>) take longer than computations on machine-precision floating-point. A kernel object of the aforementioned type uses numerical filtering to expedite computation; see <code>Kernel_2</code> and <code>Kernel_3</code>. If the input set of line segments do not have degeneracies; namely, no two segments in the set share a common endpoint, and no three segments intersect at a common point, or at least, degeneracies exist but their number is relatively small, then filtered computation incurs only negligible overhead compared to floating-point arithmetic, which is error-prone. Indeed, in almost all examples and applications given in this manual, the predefined filtered kernel <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">Exact_predicates_exact_constructions_kernel</a></code> is used to instantiate the line-segment traits class.</p>
<p><a class="anchor" id="fig__aos_figpredef_kernels"></a></p><center> <table border="0">
<tr>
<td><div class="image">
<img src="fan_grids.png" alt="fan_grids.png" />
</div>
   </td><td><div class="image">
<img src="Europe.png" alt="Europe.png" />
</div>
    </td></tr>
</table>
</center><p> </p><div class="cgal_figure_caption">   <a class="el" href="index.html#fig__aos_figpredef_kernels">Figure 34.24</a> (a) An arrangement of \(104\) line segments from the input file <code>fan_grids.dat</code>. (b) An arrangement of more than \(3000\) interior disjoint line segments, defined in the input file <code>Europe.dat</code>.  </div> <br /> 
<p>In the following example we use the predefined <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">Exact_predicates_exact_constructions_kernel</a></code> for instantiating our segment-traits class. This kernel uses interval arithmetic to filter the exact computations. The program reads a set of line segments with integer coordinates from a file and computes their arrangement. By default it opens the <code>fan_grids.dat</code> input-file, located in the examples folder, which contains \(104\) line segments that form four "fan-like" grids and induce a dense arrangement, as illustrated in <a class="el" href="index.html#fig__aos_figpredef_kernels">Figure 34.24</a> (a):</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2predefined_kernel_8cpp-example.html">Arrangement_on_surface_2/predefined_kernel.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Constructing an arrangement of intersecting line segments using the</span></div><div class="line"><span class="comment">// predefined kernel with exact constructions and exact predicates.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_exact_construction_segments.h"</span></div><div class="line"><span class="preprocessor">#include "arr_print.h"</span></div><div class="line"><span class="preprocessor">#include "read_objects.h"</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[]) {</div><div class="line">  <span class="comment">// Get the name of the input file from the command line, or use the default</span></div><div class="line">  <span class="comment">// fan_grids.dat file if no command-line parameters are given.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename = (argc &gt; 1) ? argv[1] : <span class="stringliteral">"fan_grids.dat"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Open the input file.</span></div><div class="line">  std::ifstream in_file(filename);</div><div class="line">  <span class="keywordflow">if</span> (! in_file.is_open()) {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Failed to open "</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">" ...\n"</span>;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::list&lt;Segment&gt; segments;</div><div class="line">  read_objects&lt;Segment&gt;(filename, std::back_inserter(segments));</div><div class="line"></div><div class="line">  <span class="comment">// Construct the arrangement by aggregately inserting all segments.</span></div><div class="line">  Arrangement arr;</div><div class="line">  CGAL::Timer timer;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Performing aggregated insertion of "</span></div><div class="line">            &lt;&lt; segments.size() &lt;&lt; <span class="stringliteral">" segments.\n"</span>;</div><div class="line"></div><div class="line">  timer.start();</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, segments.begin(), segments.end());</div><div class="line">  timer.stop();</div><div class="line"></div><div class="line">  print_arrangement_size(arr);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Construction took "</span> &lt;&lt; timer.time() &lt;&lt; <span class="stringliteral">" seconds.\n"</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h4><a class="anchor" id="arr_sssectr_non_caching_segs"></a>
The Non-Caching Segment-Traits Class</h4>
<p>The arrangement package offers an alternative segment-traits class template that handles line segments, namely the <code><a class="el" href="classCGAL_1_1Arr__non__caching__segment__basic__traits__2.html" title="The traits class Arr_non_caching_segment_basic_traits_2 is a model of the ArrangementTraits_2 concept...">Arr_non_caching_segment_basic_traits_2</a>&lt;<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>&gt;</code> class template. This class template and the <code><a class="el" href="classCGAL_1_1Arr__segment__traits__2.html" title="The traits class Arr_segment_traits_2 is a model of the ArrangementTraits_2 concept, which allows the construction and maintenance of arrangements of line segments. ">Arr_segment_traits_2</a>&lt;<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>&gt;</code> class template are both parameterized by a geometric kernel and model the concepts <code><a class="el" href="classArrangementTraits__2.html" title="The concept ArrangementTraits_2 allows the construction of arrangement of general planar curves...">ArrangementTraits_2</a></code> and <code><a class="el" href="classArrangementLandmarkTraits__2.html" title="The concept ArrangementLandmarkTraits_2 refines the traits concepts ArrangementApproximateTraits_2 an...">ArrangementLandmarkTraits_2</a></code>. <span class="footnote">They also model the refined concept <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Boolean_set_operations_2.tag:../Boolean_set_operations_2/" href="../Boolean_set_operations_2/classArrangementDirectionalXMonotoneTraits__2.html">ArrangementDirectionalXMonotoneTraits_2</a></code>, which enables Boolean set operations; see Package <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Boolean_set_operations_2.tag:../Boolean_set_operations_2/" href="../Boolean_set_operations_2/group__PkgBooleanSetOperations2Ref.html">2D Regularized Boolean Set-Operations Reference</a>.</span> The class template <code><a class="el" href="classCGAL_1_1Arr__non__caching__segment__traits__2.html" title="The traits class Arr_non_caching_segment_traits_2 is a model of the ArrangementTraits_2 concept that ...">Arr_non_caching_segment_traits_2</a>&lt;<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>&gt;</code> derives from the instance <code><a class="el" href="classCGAL_1_1Arr__non__caching__segment__basic__traits__2.html" title="The traits class Arr_non_caching_segment_basic_traits_2 is a model of the ArrangementTraits_2 concept...">Arr_non_caching_segment_basic_traits_2</a>&lt;<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>&gt;</code>, which models the <code><a class="el" href="classArrangementLandmarkTraits__2.html" title="The concept ArrangementLandmarkTraits_2 refines the traits concepts ArrangementApproximateTraits_2 an...">ArrangementLandmarkTraits_2</a></code> traits concept but not the refined <code><a class="el" href="classArrangementXMonotoneTraits__2.html" title="The concept ArrangementXMonotoneTraits_2 refines the basic arrangement-traits concept. A model of this concept is able to handle -monotone curves that intersect in their interior (and points that coincide with curve interiors). This is necessary for constructing arrangements of sets of intersecting -monotone curves. ">ArrangementXMonotoneTraits_2</a></code> concept. Like the <code><a class="el" href="classCGAL_1_1Arr__segment__traits__2.html" title="The traits class Arr_segment_traits_2 is a model of the ArrangementTraits_2 concept, which allows the construction and maintenance of arrangements of line segments. ">Arr_segment_traits_2</a></code> class template it derives from the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a></code> type. Unlike the <code><a class="el" href="classCGAL_1_1Arr__segment__traits__2.html" title="The traits class Arr_segment_traits_2 is a model of the ArrangementTraits_2 concept, which allows the construction and maintenance of arrangements of line segments. ">Arr_segment_traits_2</a></code> class template it defines its point and segment types as <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a></code> and <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Segment__2.html">Kernel::Segment_2</a></code>, respectively, and most of its defined operations are delegations of the corresponding operations of the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a></code> type. For example, the functor <code>Compare_xy_2</code> is defined as <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ab2dc35d1a3971355babff4ceeaef7711">Kernel::Compare_xy_2</a></code>. The remaining operations are defined in terms of just a few other kernel operations. For example, the <code>Compare_y_at_x_right_2</code> predicate is defined in terms of the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#aed1101d5f2a375e952d7276cac2d0cce">Kernel::Compare_slope_2</a></code> predicate (ignoring preconditions for the sake of clarity); see Section <a class="el" href="index.html#aos_sssec-geom_traits-concepts_basic">The Basic Concept</a> for the description of this predicate. The class template <code><a class="el" href="classCGAL_1_1Arr__non__caching__segment__basic__traits__2.html" title="The traits class Arr_non_caching_segment_basic_traits_2 is a model of the ArrangementTraits_2 concept...">Arr_non_caching_segment_basic_traits_2</a>&lt;<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>&gt;</code> is slightly less efficient than the <code><a class="el" href="classCGAL_1_1Arr__segment__traits__2.html" title="The traits class Arr_segment_traits_2 is a model of the ArrangementTraits_2 concept, which allows the construction and maintenance of arrangements of line segments. ">Arr_segment_traits_2</a></code> class template for constructing arrangements of pairwise interior-disjoint line-segments in many cases, as it does not exploit caching at all. Nevertheless, you may choose to use this traits class, as it consumes less memory. For arrangements of line segments that do intersect you may use the class template <code><a class="el" href="classCGAL_1_1Arr__non__caching__segment__traits__2.html" title="The traits class Arr_non_caching_segment_traits_2 is a model of the ArrangementTraits_2 concept that ...">Arr_non_caching_segment_traits_2</a>&lt;<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>&gt;</code>. However, the performance difference in favor of the <code><a class="el" href="classCGAL_1_1Arr__segment__traits__2.html" title="The traits class Arr_segment_traits_2 is a model of the ArrangementTraits_2 concept, which allows the construction and maintenance of arrangements of line segments. ">Arr_segment_traits_2</a></code> class template is much larger, especially when the number of intersections is large.</p>
<p>In the following example we read an input file containing a set of line segments that are pairwise disjoint in their interior. As the segments do not intersect, no new points are constructed and we can instantiate the <code>Arr_non_caching_segment_traits_basic_2&lt;<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>&gt;</code> class-template with the predefined <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">Exact_predicates_inexact_constructions_kernel</a></code>. Note that we use the <code><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#gad4aa37a4e938747028690579fb703d67" title="Inserts a set of -monotone curves in a given range into a given arrangement. ">insert_non_intersecting_curves()</a></code> function to construct the arrangement. By default, the example opens the <code>Europe.dat</code> input-file, located in the examples folder, which contains more than \(3000\) line segments with floating-point coordinates that form the map of Europe, as depicted in <a class="el" href="index.html#fig__aos_figpredef_kernels">Figure 34.24</a> (b):</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2predefined_kernel_non_intersecting_8cpp-example.html">Arrangement_on_surface_2/predefined_kernel_non_intersecting.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Constructing an arrangement of non-intersecting line segments using the</span></div><div class="line"><span class="comment">// predefined kernel with exact predicates.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_non_caching_segment_basic_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Timer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>   Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a>                                            Number_type;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__non__caching__segment__basic__traits__2.html">CGAL::Arr_non_caching_segment_basic_traits_2&lt;Kernel&gt;</a>  Traits_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::Point_2                                     Point_2;</div><div class="line"><span class="keyword">typedef</span> Traits_2::X_monotone_curve_2                          Segment_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits_2&gt;</a>                         Arrangement_2;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[]) {</div><div class="line">  <span class="comment">// Get the name of the input file from the command line, or use the default</span></div><div class="line">  <span class="comment">// Europe.dat file if no command-line parameters are given.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename = (argc &gt; 1) ? argv[1] : <span class="stringliteral">"Europe.dat"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Open the input file.</span></div><div class="line">  std::ifstream in_file(filename);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (! in_file.is_open()) {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Failed to open "</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">" ...\n"</span>;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Read the segments from the file.</span></div><div class="line">  <span class="comment">// The input file format should be (all coordinate values are double</span></div><div class="line">  <span class="comment">// precision floating-point numbers):</span></div><div class="line">  <span class="comment">// &lt;n&gt;                                 // number of segments.</span></div><div class="line">  <span class="comment">// &lt;sx_1&gt; &lt;sy_1&gt;  &lt;tx_1&gt; &lt;ty_1&gt;        // source and target of segment #1.</span></div><div class="line">  <span class="comment">// &lt;sx_2&gt; &lt;sy_2&gt;  &lt;tx_2&gt; &lt;ty_2&gt;        // source and target of segment #2.</span></div><div class="line">  <span class="comment">//   :      :       :      :</span></div><div class="line">  <span class="comment">// &lt;sx_n&gt; &lt;sy_n&gt;  &lt;tx_n&gt; &lt;ty_n&gt;        // source and target of segment #n.</span></div><div class="line">  std::list&lt;Segment_2&gt;  segments;</div><div class="line"></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n;</div><div class="line">  in_file &gt;&gt; n;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;</div><div class="line">  <span class="keywordflow">for</span> (i = 0; i &lt; n; ++i) {</div><div class="line">    <span class="keywordtype">double</span> sx, sy, tx, ty;</div><div class="line">    in_file &gt;&gt; sx &gt;&gt; sy &gt;&gt; tx &gt;&gt; ty;</div><div class="line">    segments.push_back (Segment_2 (Point_2 (Number_type(sx), Number_type(sy)),</div><div class="line">                                   Point_2 (Number_type(tx), Number_type(ty))));</div><div class="line">  }</div><div class="line">  in_file.close();</div><div class="line"></div><div class="line">  <span class="comment">// Construct the arrangement by aggregately inserting all segments.</span></div><div class="line">  Arrangement_2 arr;</div><div class="line">  CGAL::Timer timer;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Performing aggregated insertion of "</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">" segments.\n"</span>;</div><div class="line"></div><div class="line">  timer.start();</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad4aa37a4e938747028690579fb703d67">insert_non_intersecting_curves</a> (arr, segments.begin(), segments.end());</div><div class="line">  timer.stop();</div><div class="line"></div><div class="line">  <span class="comment">// Print the arrangement dimensions.</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"V = "</span> &lt;&lt; arr.number_of_vertices()</div><div class="line">            &lt;&lt; <span class="stringliteral">",  E = "</span> &lt;&lt; arr.number_of_edges()</div><div class="line">            &lt;&lt; <span class="stringliteral">",  F = "</span> &lt;&lt; arr.number_of_faces() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Construction took "</span> &lt;&lt; timer.time() &lt;&lt; <span class="stringliteral">" seconds.\n"</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h4><a class="anchor" id="arr_sssectr_linear"></a>
The Linear-Traits Class</h4>
<p>The <code><a class="el" href="classCGAL_1_1Arr__linear__traits__2.html" title="The traits class Arr_linear_traits_2 is a model of the ArrangementTraits_2 concept, which enables the construction and maintenance of arrangements of linear objects. ">Arr_linear_traits_2</a>&lt;<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>&gt;</code> class used in Section <a class="el" href="index.html#aos_sec-unbounded">Arrangements of Unbounded Curves</a> for demonstrating the construction of arrangements of unbounded curves is capable of handling bounded and unbounded linear objects, namely, lines, rays, and line segments. It models the concepts <code><a class="el" href="classArrangementTraits__2.html" title="The concept ArrangementTraits_2 allows the construction of arrangement of general planar curves...">ArrangementTraits_2</a></code>, <code><a class="el" href="classArrangementLandmarkTraits__2.html" title="The concept ArrangementLandmarkTraits_2 refines the traits concepts ArrangementApproximateTraits_2 an...">ArrangementLandmarkTraits_2</a></code>, and <code>{<a class="el" href="classArrangementOpenBoundaryTraits__2.html" title="Several predicates are required to handle -monotone curves that approach infinity and thus approach t...">ArrangementOpenBoundaryTraits_2</a></code>. It is parameterized by a geometric kernel and its nested <a class="el" href="classCGAL_1_1Arr__linear__traits__2.html#a0cfd7a27d192fbad2e7756429ed64ef8"><code>Point_2</code></a> type is defined to be the kernel-point type. The <a class="el" href="classCGAL_1_1Arr__linear__traits__2.html#aba0cbe450024e7b12c715869b974cbfd"><code>Curve_2</code></a> (and <a class="el" href="classCGAL_1_1Arr__linear__traits__2_1_1X__monotone__curve__2.html"><code>X_monotone_curve_2</code></a>) nested types are constructible from a <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Line__2.html">Kernel::Line_2</a></code>, a <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Ray__2.html">Kernel::Ray_2</a></code>, or from a <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Segment__2.html">Kernel::Segment_2</a></code> object. Given a linear-curve object \(c\), you can use the calls <code>c.is_line()</code>, <code>c.is_ray()</code>, and <code>c.is_segment()</code> to find out whether it has a source point or a target point. Based on the curve type, you can access its endpoints using the methods <code>c.source()</code> (for rays and for line segments) and <code>c.target()</code> (for segments only). It is also possible to cast a curve into a <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Line__2.html">Kernel::Line_2</a></code>, a <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Ray__2.html">Kernel::Ray_2</a></code>, or a <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Segment__2.html">Kernel::Segment_2</a></code> type, using the methods <code>c.line()</code>, <code>c.ray()</code>, and <code>c.segment()</code>, respectively. Just like the default segment-traits class, the linear-curve traits class uses caching techniques to speed up its predicate evaluations and object constructions.</p>
<h3><a class="anchor" id="arr_ssectr_polylines"></a>
The Polyline and Polycurve Traits Classes</h3>
<p>Polylines are continuous piecewise linear curves. Polylines are of particular interest, as they can be used to approximate more complex curves in the plane. At the same time they are easier to handle in comparison to higher-degree algebraic curves, as rational arithmetic is sufficient to carry out computations on polylines, and to construct arrangements of polylines in an exact and robust manner. Here, we extend the notion of polylines and use the term to refer to chains of subcurves that are not necessarily linear. However, each subcurve must be uniquely defined by (and, thus, can be uniquely constructed from) two points within the handled family of curves; see Section <a class="el" href="index.html#arr_sssectr_polylines">The Polyline Traits Class</a>. We also provide a similar traits class that handles continuous piecewise curves that are not necessarily linear and are not subject to the aforementioned constraint; see Section <a class="el" href="index.html#arr_sssectr_polycurves">The Polycurve Traits Class</a>.</p>
<h4><a class="anchor" id="arr_sssectr_polylines"></a>
The Polyline Traits Class</h4>
<p>The <code><a class="el" href="classCGAL_1_1Arr__polyline__traits__2.html" title="The traits class Arr_polyline_traits_2 handles piecewise linear curves, commonly referred to as polyl...">Arr_polyline_traits_2</a>&lt;SubcurveTraits_2&gt;</code> class template handles polylines. It models the following three concepts:</p>
<ul>
<li><code><a class="el" href="classArrangementTraits__2.html" title="The concept ArrangementTraits_2 allows the construction of arrangement of general planar curves...">ArrangementTraits_2</a></code>,</li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Boolean_set_operations_2.tag:../Boolean_set_operations_2/" href="../Boolean_set_operations_2/classArrangementDirectionalXMonotoneTraits__2.html">ArrangementDirectionalXMonotoneTraits_2</a></code>, and</li>
<li><code><a class="el" href="classArrangementConstructXMonotoneCurveTraits__2.html" title="The concept ArrangementConstructXMonotoneCurveTraits_2 refines the basic traits concept ArrangementBa...">ArrangementConstructXMonotoneCurveTraits_2</a></code>; see Package <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Boolean_set_operations_2.tag:../Boolean_set_operations_2/" href="../Boolean_set_operations_2/group__PkgBooleanSetOperations2Ref.html">2D Regularized Boolean Set-Operations Reference</a>.</li>
</ul>
<p>The type that substitutes the template parameter <code>SubcurveTraits_2</code> when <code><a class="el" href="classCGAL_1_1Arr__polyline__traits__2.html" title="The traits class Arr_polyline_traits_2 handles piecewise linear curves, commonly referred to as polyl...">Arr_polyline_traits_2</a>&lt;SubcurveTraits_2&gt;</code> is instantiated must be a geometry-traits class that models the same three concepts. We refer to the type that substitutes the template parameter <code>SubcurveTraits_2</code> as the <em>subcurve traits</em> hereafter. If, in addition, the subcurve traits also models the concept <code><a class="el" href="classArrangementApproximateTraits__2.html" title="The concept ArrangementApproximateTraits_2 refines the basic traits concept ArrangementBasicTraits_2...">ArrangementApproximateTraits_2</a></code> then the instantiated <code><a class="el" href="classCGAL_1_1Arr__polyline__traits__2.html" title="The traits class Arr_polyline_traits_2 handles piecewise linear curves, commonly referred to as polyl...">Arr_polyline_traits_2</a>&lt;SubcurveTraits&gt;</code> type models the concept <code><a class="el" href="classArrangementApproximateTraits__2.html" title="The concept ArrangementApproximateTraits_2 refines the basic traits concept ArrangementBasicTraits_2...">ArrangementApproximateTraits_2</a></code> as well. (By definition, modeling the concepts <code><a class="el" href="classArrangementApproximateTraits__2.html" title="The concept ArrangementApproximateTraits_2 refines the basic traits concept ArrangementBasicTraits_2...">ArrangementApproximateTraits_2</a></code> and <code><a class="el" href="classArrangementConstructXMonotoneCurveTraits__2.html" title="The concept ArrangementConstructXMonotoneCurveTraits_2 refines the basic traits concept ArrangementBa...">ArrangementConstructXMonotoneCurveTraits_2</a></code> implies modeling the concept <code><a class="el" href="classArrangementLandmarkTraits__2.html" title="The concept ArrangementLandmarkTraits_2 refines the traits concepts ArrangementApproximateTraits_2 an...">ArrangementLandmarkTraits_2</a></code>.) Similarly, if the subcurve traits also models the concept <code><a class="el" href="classArrangementOpenBoundaryTraits__2.html" title="Several predicates are required to handle -monotone curves that approach infinity and thus approach t...">ArrangementOpenBoundaryTraits_2</a></code> then the instantiated <code><a class="el" href="classCGAL_1_1Arr__polyline__traits__2.html" title="The traits class Arr_polyline_traits_2 handles piecewise linear curves, commonly referred to as polyl...">Arr_polyline_traits_2</a>&lt;SubcurveTraits&gt;</code> type models the concept <code><a class="el" href="classArrangementOpenBoundaryTraits__2.html" title="Several predicates are required to handle -monotone curves that approach infinity and thus approach t...">ArrangementOpenBoundaryTraits_2</a></code> as well. Modeling the <code><a class="el" href="classArrangementConstructXMonotoneCurveTraits__2.html" title="The concept ArrangementConstructXMonotoneCurveTraits_2 refines the basic traits concept ArrangementBa...">ArrangementConstructXMonotoneCurveTraits_2</a></code> concept implies that the subcurve traits must support the construction of a unique ( \(x\)-monotone) segment given two input points.</p>
<p>An instance of the polyline traits class-template inherits its nested point type, i.e., <a class="el" href="classCGAL_1_1Arr__polyline__traits__2.html#a9bcf8e230ad3ac70bf14484ab47f606b"><code>Point_2</code></a>, from the subcurve traits, and defines the nested types <a class="el" href="classCGAL_1_1Arr__polyline__traits__2_1_1Curve__2.html"><code>Curve_2</code></a> and <a class="el" href="classCGAL_1_1Arr__polyline__traits__2_1_1X__monotone__curve__2.html"><code>X_monotone_curve_2</code></a>, which are used to represent polylines and \(x\)-monotone polylines, respectively. A polyline of the nested type <a class="el" href="classCGAL_1_1Arr__polyline__traits__2_1_1Curve__2.html"><code>Curve_2</code></a> is stored as a vector of <code>SubcurveTraits_2::Curve_2</code> objects, and an \(x\)-monotone polyline of the nested type <a class="el" href="classCGAL_1_1Arr__polyline__traits__2_1_1X__monotone__curve__2.html"><code>X_monotone_curve_2</code></a> is stored as a vector of <code>SubcurveTraits_2::X_monotone_curve_2</code> objects. The nested <code>X_monotone_curve_2</code> type inherits from the nested type <a class="el" href="classCGAL_1_1Arr__polyline__traits__2_1_1Curve__2.html"><code>Curve_2</code></a>. By default, <code><a class="el" href="classCGAL_1_1Arr__segment__traits__2.html" title="The traits class Arr_segment_traits_2 is a model of the ArrangementTraits_2 concept, which allows the construction and maintenance of arrangements of line segments. ">Arr_segment_traits_2</a></code> is used as the subcurve traits (in case where the <code>SubcurveTraits_2</code> parameter is omitted). In this case the nested types <code>SubcurveTraits_2::Curve_2</code> and <code>SubcurveTraits_2::X_monotone_curve_2</code> are identical types representing line segments.</p>
<p>A polyline can be constructed given one of the following inputs:</p>
<ul>
<li><b>A range of <em>points</em></b>, where two succeeding points in the range represent the endpoints of a segment of the polyline.</li>
<li><b>A range of <em>segments</em></b>.</li>
<li><b>A pair of points <em>or</em> a single segment</b>. In this case a polyline that consists of a single segment is constructed.</li>
</ul>
<p>Note that degenerate polylines are not supported. That is, it is impossible to construct a polyline that contains a segment of length zero, or an isolated point. Finally, a polyline is <b><em>continuous</em></b> and <b><em>well-oriented</em></b>. Moreover, the target of the \(i\)th segment is the source of the \(i+1\)st segment. If the macro <code>CGAL_ALWAYS_LEFT_TO_RIGHT</code> is set to 1, then \(x\)-monotone polylines are always directed from left-to-right. (This option is retained for backward compatibility.) Also, note that a single polyline can be split into several \(x\)-monotone polylines, and that the number of intersection points (or overlapping sections) between two polylines can be large.</p>
<p>For example, the general polyline</p>
<div class="image">
<img src="generic-polyline.png" alt="generic-polyline.png" />
</div>
 <p>can be represented by one of the following two orientations.</p>
<div class="image">
<img src="well_oriented_polyline.png" alt="well_oriented_polyline.png" />
</div>
 <p>Distinct \(x\)-monotone polylines are rendered in different colors.</p>
<p> </p><div class="CGALAdvanced"> <div>Advanced</div> 
<p>Technically speaking, it is possible to construct a general polyline that is neither well-oriented nor continuous. However, it is impossible to use such polylines for the purpose of computing an arrangement.  </p></div> 
<p>The polyline traits class also supports the traversal over the range of defining segments of a given polyline. The <em>first</em> and <em>past-the-end</em> iterators can be obtained through the access methods <a class="el" href="classCGAL_1_1Arr__polyline__traits__2_1_1X__monotone__curve__2.html#a798dbec2fd852cf132a98f766ff4969d"><code>begin_segments()</code></a> and <a class="el" href="classCGAL_1_1Arr__polyline__traits__2_1_1X__monotone__curve__2.html#a8dee766c44f0badadec0e269579d9261"><code>end_segments()</code></a>, respectively, of a polyline \(c\). The vertices of an \(x\)-monotone curve are always stored in a strongly monotonic lexicographical order. In other words, \(x\)-monotone polylines can be directed <em>either</em> left-to-right <em>or</em> right-to-left.</p>
<p>The polyline-traits class does not perform any geometric operations directly. Instead, it solely relies on the functionality of the segment traits. For example, when we need to determine the position of a point with respect to an \(x\)-monotone polyline, we use binary search to locate the relevant segment that contains the point in its \(x\)-range. Then, we compute the position of the point with respect to this segment. Thus, operations on \(x\)-monotone polylines of size \(m\) typically take \(O(\log m)\) time.</p>
<p>You are free to choose the underlying segment traits class. Your decision could be based, for example, on the number of expected intersection points; see Section <a class="el" href="index.html#arr_ssectr_segs">Traits Classes for Line Segments and Linear Objects</a>. Moreover, it is possible to substitute the <code>SubcurveTraits_2</code> template parameter with a traits class that handles segments with some additional data attached to each individual segment; see Section <a class="el" href="index.html#arr_ssecmeta_tr">Traits-Class Decorators</a>. This makes it possible to associate different data objects with the different segments that compose a polyline.</p>
<p><a class="anchor" id="fig__aos_fig-polylines"></a></p><div class="image">
<img src="polylines.png" alt="polylines.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-polylines">Figure 34.25</a>
<p>An arrangement of three polylines, as constructed in <a class="el" href="Arrangement_on_surface_2_2polylines_8cpp-example.html">Arrangement_on_surface_2/polylines.cpp</a>. Red disks mark vertices associated with polyline endpoints, while rings mark vertices that correspond to intersection points. The target endpoint of \(\pi_3\) is also an intersection point; it is rendered as a ring. Observe that the polyline \(\pi_2\) is split into three \(x\)-monotone polylines, and that the two curves \(\pi_1\) and \(\pi_3\) have two overlapping sections—an impossible scenario in arrangements of line segments. </p></div> <br /> 
<p>The following example program constructs an arrangement of three polylines, \(\pi_1\), \(\pi_2\), and \(\pi_3\), as depicted in <a class="el" href="index.html#fig__aos_fig-polylines">Figure 34.25</a>. In this example, each polyline is constructed from points stored in a different container, i.e., array, list, and vector. Points defining the polylines are not necessarily associated with arrangement vertices. The arrangement vertices are either the extreme points of each \(x\)-monotone polyline (drawn as red discs) or the intersection points between two polylines (drawn as rings).</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2polylines_8cpp-example.html">Arrangement_on_surface_2/polylines.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Constructing an arrangement of polylines.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_polylines.h"</span></div><div class="line"><span class="preprocessor">#include "arr_print.h"</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  Traits traits;</div><div class="line">  Arrangement arr(&amp;traits);</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> polyline_construct = traits.construct_curve_2_object();</div><div class="line"></div><div class="line">  Point points1[5];</div><div class="line">  points1[0] = Point(0, 0);</div><div class="line">  points1[1] = Point(2, 4);</div><div class="line">  points1[2] = Point(3, 0);</div><div class="line">  points1[3] = Point(4, 4);</div><div class="line">  points1[4] = Point(6, 0);</div><div class="line">  <span class="keyword">auto</span> pi1 = polyline_construct(&amp;points1[0], &amp;points1[5]);</div><div class="line"></div><div class="line">  std::list&lt;Point&gt; points2;</div><div class="line">  points2.push_back(Point(1, 3));</div><div class="line">  points2.push_back(Point(0, 2));</div><div class="line">  points2.push_back(Point(1, 0));</div><div class="line">  points2.push_back(Point(2, 1));</div><div class="line">  points2.push_back(Point(3, 0));</div><div class="line">  points2.push_back(Point(4, 1));</div><div class="line">  points2.push_back(Point(5, 0));</div><div class="line">  points2.push_back(Point(6, 2));</div><div class="line">  points2.push_back(Point(5, 3));</div><div class="line">  points2.push_back(Point(4, 2));</div><div class="line">  <span class="keyword">auto</span> pi2 = polyline_construct(points2.begin(), points2.end());</div><div class="line"></div><div class="line">  std::vector&lt;Segment&gt; segs;</div><div class="line">  segs.push_back(Segment(Point(0, 2), Point(1, 2)));</div><div class="line">  segs.push_back(Segment(Point(1, 2), Point(3, 6)));</div><div class="line">  segs.push_back(Segment(Point(3, 6), Point(5, 2)));</div><div class="line">  <span class="keyword">auto</span> pi3 = polyline_construct(segs.begin(), segs.end());</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, pi1);</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, pi2);</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, pi3);</div><div class="line">  print_arrangement_size(arr);          <span class="comment">// print the arrangement size</span></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>The common types used by the example programs involving arrangements of polylines are listed below, and defined in the header file <code>arr_polylines.h</code>. As we do in the case of segments and linear objects, we use the predefined kernel to instantiate our traits class. However, in this case we have yet another layer of template instantiation, namely the instantiation of the polyline-traits class-template with an instance of a subcurve traits class-template. Naturally, we use the <code><a class="el" href="classCGAL_1_1Arr__segment__traits__2.html" title="The traits class Arr_segment_traits_2 is a model of the ArrangementTraits_2 concept, which allows the construction and maintenance of arrangements of line segments. ">Arr_segment_traits_2</a></code> class template, instantiated with the predefined filtered kernel.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_segment_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_polyline_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">CGAL::Exact_predicates_exact_constructions_kernel</a>  Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a>                                         Number_type;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__segment__traits__2.html">CGAL::Arr_segment_traits_2&lt;Kernel&gt;</a>                 Segment_traits;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__polyline__traits__2.html">CGAL::Arr_polyline_traits_2&lt;Segment_traits&gt;</a>        Traits;</div><div class="line"><span class="keyword">typedef</span> Traits::Point_2                                    Point;</div><div class="line"><span class="keyword">typedef</span> Traits::Curve_2                                    Polyline;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits&gt;</a>                        Arrangement;</div></div><!-- fragment --><h4><a class="anchor" id="arr_sssectr_polycurves"></a>
The Polycurve Traits Class</h4>
<h3><a class="anchor" id="arr_ssectr_algebraic"></a>
Traits Classes for Algebraic Curves</h3>
<p>A curve in our context is typically (but not necessarily) defined as the zero set of a bivariate nonzero polynomial with rational (or, equivalently, integral) coefficients. We call such polynomials and the curves they define <em>algebraic</em>. When dealing with linear curves (e.g., line segments and polylines), having rational coefficients guarantees that all intersection points also have rational coordinates, such that the arrangement of such curves can be constructed and maintained using only rational arithmetic. The <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgArrangementOnSurface2">2D Arrangements</a> package also offers geometry traits-classes that handle algebraic curves defined by algebraic polynomials of degree higher than~ \(1\). Unfortunately, the coordinates of the intersection points constructed by these traits models are in general algebraic numbers<span class="footnote">A number is called <em>algebraic</em>, if it is the root of a univariate algebraic polynomial with rational coefficients.</span> of degree higher than \(1\). It is therefore clear that we have to use number types different from plain rational to represent point coordinates and be able to apply arithmetic operations on them.</p>
<p>Several types of algebraic curves are handled by more than one traits model. Section <a class="el" href="index.html#arr_sssectr_linear">The Linear-Traits Class</a> introduces a few different traits models that handle line segments. This duplication becomes more evident with the introduction of traits classes that handle algebraic curves. The different traits models have different properties. In some cases they were developed by different authors at different times exploiting different tools that were available at the time they were developed. As a general rule, you should always use the minimal traits model that still satisfies your needs, as the most dedicated model is most likely to be the most efficient.</p>
<h4><a class="anchor" id="arr_sssectr_circ_seg"></a>
Circular Arcs and Line Segments</h4>
<p>Arrangement of circular arcs and of line segments are very useful and frequently arise in applications, where curves of interleaved line segments and circular arcs are used to model the boundaries of complex shapes. Such curves can fit the original boundary more tightly and more compactly than, for example, a simple polyline. For example, when dilating a polygon by some radius we obtain a shape whose boundary comprises of line segments, which correspond to dilated polygon edges, and circular arcs, which result from dilated polygon vertices. Using the arrangement of the boundary curves it is possible, for example, to compute the union of a set of dilated polygons. Besides the importance of arrangements of circular arcs and line segments it turns out that it is possible to implement efficient traits models that handle curves restricted to circular arcs and line segments. Rational numbers cannot represent the coordinates of intersection points that may arise in such arrangements in an exact manner. Thus, algebraic numbers must be used. However, the performance impact that (general) algebraic numbers incur can be reduced by the use of an efficient type of exact algebraic numbers called <em>square root extension</em> that uses rational arithmetic in an almost straightforward fashion.</p>
<p>Square root numbers have the form \(\alpha + \beta\sqrt{\gamma}\), where \(\alpha\), \(\beta\), and \(\gamma\) are rational numbers. (Square root numbers are also called one-root numbers.) The rational number \(\gamma\) is referred to as the extension. Each subset that has a particular extension is closed under arithmetic operations and order relations; hence, it is a valid algebraic structure.<span class="footnote">The term algebraic structure refers to the set closed under one or more operations satisfying some axioms; see, e.g., <a href="http://en.wikipedia.org/wiki/Algebraic_structure">http://en.wikipedia.org/wiki/Algebraic_structure</a>. For example, all numbers that can be expressed as \(\alpha + \beta\sqrt{K}\), where \(\alpha\) and \(\beta\) are rational and \(K\) is a rational constant, compose an algebraic structure.</span> The class template <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Sqrt__extension.html">CGAL::Sqrt_extension</a>&lt;NT,Root&gt;</code> implements the square root extension type. Instances of this template represent square root numbers. It is equipped with the implementation of a set of arithmetic operations and order relations that exploit identical extensions of operands. It also provides the ability to compare two numbers with different extensions \(\gamma_1 \neq \gamma_2\) efficiently. Each operation is implemented using only few rational arithmetic operations. Here, <code>NT</code> is the type of \(\alpha\) and \(\beta\), and <code>Root</code> is the type of \(\gamma\). The running times of the arithmetic operations and order relations provided by the square root extension when the identical-extension condition is met are comparable to the running times of the corresponding arithmetic operations of rational-number types. The running times of order relations when the condition is not met are only slightly larger. In practice, using number types that represent (arbitrary) algebraic numbers increases the running time of the application significantly.</p>
<p>We call circles whose center coordinates and squared radii are rational numbers <em>rational circles</em>. The equation of such a circle, that is, \((x - x_0)^2 + (y - y_0)^2 = r^2\), where \((x_0,y_0)\) and \(r\) denote the circle center and its radius, respectively, has rational coefficients. The coordinates of the points of intersection between two such circles are therefore solutions of quadratic equations with rational coefficients, in other words, algebraic numbers of degree~ \(2\) or simply square root numbers. The same applies to intersection points between such a rational circle and a line, or a line segment, with rational coefficients (a line whose equation is \(ax + by + c = 0\), where \(a\), \(b\), and \(c\) are rational).</p>
<p>The <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgArrangementOnSurface2">2D Arrangements</a> package offers a traits class-template called <code><a class="el" href="classCGAL_1_1Arr__circle__segment__traits__2.html" title="The class Arr_circle_segment_traits_2 is a model of the ArrangementTraits_2 concept and can be used t...">Arr_circle_segment_traits_2</a>&lt;<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>&gt;</code> that exclusively handles line segments, circular arcs, and whole circles and models the concepts <code><a class="el" href="classArrangementTraits__2.html" title="The concept ArrangementTraits_2 allows the construction of arrangement of general planar curves...">ArrangementTraits_2</a></code> and <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Boolean_set_operations_2.tag:../Boolean_set_operations_2/" href="../Boolean_set_operations_2/classArrangementDirectionalXMonotoneTraits__2.html">ArrangementDirectionalXMonotoneTraits_2</a></code>; see Package <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Boolean_set_operations_2.tag:../Boolean_set_operations_2/" href="../Boolean_set_operations_2/group__PkgBooleanSetOperations2Ref.html">2D Regularized Boolean Set-Operations Reference</a>. Note that it is not a model of the <code><a class="el" href="classArrangementLandmarkTraits__2.html" title="The concept ArrangementLandmarkTraits_2 refines the traits concepts ArrangementApproximateTraits_2 an...">ArrangementLandmarkTraits_2</a></code> concept. It exploits efficient computations with square root numbers, which makes it attractive for arrangements induced by line segments, circular arcs, and whole circles. When the traits class-template is instantiated, the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a></code> template parameter must be substituted with a geometric kernel that models the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a></code> concept. Always plug in a kernel that uses a rational number type, such as <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">Exact_predicates_exact_constructions_kernel</a></code>. Observe that the nested type <a class="el" href="classCGAL_1_1Arr__circle__segment__traits__2_1_1Point__2.html"><code>Point_2</code></a> defined by the traits class, whose coordinates are typically algebraic numbers of degree 2, is <em>not</em> the same as the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a></code> type. The coordinates of a point are represented using the number type <code>CoordNT</code>, nested in the traits class-template.</p>
<p><a class="anchor" id="fig__aos_fig-circles"></a></p><div class="image">
<img src="circles.png" alt="circles.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-circles">Figure 34.26</a> An arrangement of three circles constructed in <a class="el" href="Arrangement_on_surface_2_2circles_8cpp-example.html">Arrangement_on_surface_2/circles.cpp</a>. Each circle is split into two \(x\)-monotone circular arcs, whose endpoints are drawn as red disks. Rings mark vertices that correspond to intersection points. The vertex \(v_{\rm max}\) is a common intersection point of all three circles.  </div> <br /> 
<p>In the following example an arrangement of three full circles is constructed, as shown in <a class="el" href="index.html#fig__aos_fig-circles">Figure 34.26</a>. Each <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classIndex.html">Index</a> is split into two \(x\)-monotone circular arcs, the endpoints of which are drawn as red discs; rings mark vertices that correspond to intersection points. Once the arrangement is constructed, we locate the vertex of maximal degree in the arrangement. The geometric mapping of this vertex, denoted by \(v_{\rm max}\), is the point \((4,3)\), as all three circles intersect at this point and the associated vertex has six incident edges.</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2circles_8cpp-example.html">Arrangement_on_surface_2/circles.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Constructing an arrangement of circles using the circle-segment traits.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_circular.h"</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  Arrangement arr;</div><div class="line"></div><div class="line">  <span class="comment">// Create a circle centered at the origin with radius 5 (C1).</span></div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Curve(Circle(Rational_point(0, 0), Number_type(25))));</div><div class="line"></div><div class="line">  <span class="comment">// Create a circle centered at (7,7) with radius 5 (C2).</span></div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Curve(Circle(Rational_point(7, 7), Number_type(25))));</div><div class="line"></div><div class="line">  <span class="comment">// Create a circle centered at (4,-0.5) with radius 3.5 (= 7/2) (C3).</span></div><div class="line">  Rational_point c3(4, Number_type(-1) / Number_type(2));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Curve(Circle(c3, Number_type(49) / Number_type(4))));</div><div class="line"></div><div class="line">  <span class="comment">// Locate the vertex with maximal degree.</span></div><div class="line">  <span class="keyword">auto</span> vit = arr.vertices_begin();</div><div class="line">  Arrangement::Vertex_const_handle v_max = vit;</div><div class="line">  <span class="keywordflow">for</span> (++vit; vit != arr.vertices_end(); ++vit)</div><div class="line">    <span class="keywordflow">if</span> (vit-&gt;degree() &gt; v_max-&gt;degree()) v_max = vit;</div><div class="line"></div><div class="line">  <span class="comment">// Locate the vertex with maximum degree.</span></div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The vertex with maximal degree in the arrangement is: "</span></div><div class="line">            &lt;&lt; <span class="stringliteral">"v_max = ("</span> &lt;&lt; v_max-&gt;point() &lt;&lt; <span class="stringliteral">") "</span></div><div class="line">            &lt;&lt; <span class="stringliteral">"with degree "</span> &lt;&lt; v_max-&gt;degree() &lt;&lt; <span class="stringliteral">"."</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>The types common to the example programs that use the <code><a class="el" href="classCGAL_1_1Arr__circle__segment__traits__2.html" title="The class Arr_circle_segment_traits_2 is a model of the ArrangementTraits_2 concept and can be used t...">Arr_circle_segment_traits_2</a></code> class template are listed below and defined in the header file <code>arr_circular.h</code>. Even though algebraic numbers are required to represent coordinates of points where the inducing curves are circles or circular arcs, such as the curves handled by the <code><a class="el" href="classCGAL_1_1Arr__circle__segment__traits__2.html" title="The class Arr_circle_segment_traits_2 is a model of the ArrangementTraits_2 concept and can be used t...">Arr_circle_segment_traits_2</a></code> class template, an (exact) rational kernel suffices, and a filtered one improves the performance further.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_circle_segment_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">CGAL::Exact_predicates_exact_constructions_kernel</a>  Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a>                                         Number_type;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__circle__segment__traits__2.html">CGAL::Arr_circle_segment_traits_2&lt;Kernel&gt;</a>          Traits;</div><div class="line"><span class="keyword">typedef</span> Traits::CoordNT                                    CoordNT;</div><div class="line"><span class="keyword">typedef</span> Traits::Point_2                                    Point;</div><div class="line"><span class="keyword">typedef</span> Traits::Curve_2                                    Curve;</div><div class="line"><span class="keyword">typedef</span> Traits::Rational_point_2                           Rational_point;</div><div class="line"><span class="keyword">typedef</span> Traits::Rational_segment_2                         Segment;</div><div class="line"><span class="keyword">typedef</span> Traits::Rational_circle_2                          Circle;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits&gt;</a>                        Arrangement;</div></div><!-- fragment --><p>The <a class="el" href="classCGAL_1_1Arr__circle__segment__traits__2_1_1Curve__2.html"><code>Curve_2</code></a> type nested in <code><a class="el" href="classCGAL_1_1Arr__circle__segment__traits__2.html" title="The class Arr_circle_segment_traits_2 is a model of the ArrangementTraits_2 concept and can be used t...">Arr_circle_segment_traits_2</a></code> can be used to represent circles, circular arcs, or line segments. We now describe and demonstrate a variety of ways in which the curves of this type can be constructed. A Curve object can be constructed from a <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Circle__2.html">Kernel::Circle_2</a></code> object or from a <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Segment__2.html">Kernel::Segment_2</a></code> object. A circular arc is typically defined by a supporting circle and two endpoints, where the endpoints are of type <a class="el" href="classCGAL_1_1Arr__circle__segment__traits__2_1_1Point__2.html"><code>Point_2</code></a>, with rational or irrational coordinates. The orientation of the arc is determined by the orientation of the supporting circle. Similarly, we also support the construction of line segments given their supporting line (of type <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Line__2.html">Kernel::Line_2</a></code>) and two endpoints, which may have irrational coordinates (unlike the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Segment__2.html">Kernel::Segment_2</a></code> type).</p>
<p>Note that the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Circle__2.html">Kernel::Circle_2</a></code> type is used to represent a circle whose <em>squared radius</em> is rational, where the radius itself may be irrational. However, if the radius is known to be rational, its use is recommended for efficiency. It is therefore also possible to construct a circle, or a circular arc specifying the circle center (a <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a></code>), its rational radius (of type <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a></code>), and its orientation. Finally, we also support the construction of a circular arc that is defined by two endpoints and an arbitrary interior point that lies on the arc in between its endpoints. In this case, all three points are required to have rational coordinates; namely, they are all given as <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a></code> objects.</p>
<p><a class="anchor" id="fig__aos_fig-circular_arcs"></a></p><div class="image">
<img src="circular_arcs.png" alt="circular_arcs.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-circular_arcs">Figure 34.27</a> An arrangement of two full circles, two line segments, and three circular arcs as constructed in <a class="el" href="Arrangement_on_surface_2_2circular_arcs_8cpp-example.html">Arrangement_on_surface_2/circular_arcs.cpp</a>. Endpoints are drawn as red disks and intersection points are drawn as rings.  </div> <br /> 
<p>The following example demonstrates the usage of the various construction methods for circular arcs and line segments. The resulting arrangement is depicted in <a class="el" href="index.html#fig__aos_fig-circular_arcs">Figure 34.27</a>. Note the usage of the constructor of <code>CoordNT(alpha, beta, gamma)</code>, which creates a degree- \(2\) algebraic number whose value is \(\alpha + \beta\sqrt{\gamma}\).</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2circular_arcs_8cpp-example.html">Arrangement_on_surface_2/circular_arcs.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Constructing an arrangement of various circular arcs and line segments.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_circular.h"</span></div><div class="line"><span class="preprocessor">#include "arr_print.h"</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  std::list&lt;Curve&gt; curves;</div><div class="line"></div><div class="line">  <span class="comment">// Create a circle (C1) centered at the origin with squared radius 2.</span></div><div class="line">  curves.push_back(Curve(Circle(Rational_point(0, 0), Number_type(2))));</div><div class="line"></div><div class="line">  <span class="comment">// Create a circle (C2) centered at (2, 3) with radius 3/2. Note that</span></div><div class="line">  <span class="comment">// as the radius is rational we use a different curve constructor.</span></div><div class="line">  Number_type three_halves = Number_type(3) / Number_type(2);</div><div class="line">  curves.push_back(Curve(Rational_point(2, 3), three_halves));</div><div class="line"></div><div class="line">  <span class="comment">// Create a segment (C3) of the line (y = x) with rational endpoints.</span></div><div class="line">  Segment s3 = Segment(Rational_point(-2, -2), Rational_point(2, 2));</div><div class="line">  curves.push_back(Curve(s3));</div><div class="line"></div><div class="line">  <span class="comment">// Create a line segment (C4) with the same supporting line (y = x), but</span></div><div class="line">  <span class="comment">// having one endpoint with irrational coordinates.</span></div><div class="line">  CoordNT sqrt_15 = CoordNT(0, 1, 15); <span class="comment">// = sqrt(15)</span></div><div class="line">  curves.push_back(Curve(s3.supporting_line(),</div><div class="line">                         Point(3, 3), Point(sqrt_15, sqrt_15)));</div><div class="line"></div><div class="line">  <span class="comment">// Create a circular arc (C5) that is the upper half of the circle centered at</span></div><div class="line">  <span class="comment">// (1, 1) with squared radius 3. Create the circle with clockwise orientation,</span></div><div class="line">  <span class="comment">// so the arc is directed from (1 - sqrt(3), 1) to (1 + sqrt(3), 1).</span></div><div class="line">  Rational_point c5(1, 1);</div><div class="line">  Circle circ5(c5, 3, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga5aa0906f2432d414090dd8723c10f304">CGAL::CLOCKWISE</a>);</div><div class="line">  CoordNT one_minus_sqrt_3(1, -1, 3);</div><div class="line">  CoordNT one_plus_sqrt_3(1, 1, 3);</div><div class="line">  Point s5(one_minus_sqrt_3, CoordNT(1));</div><div class="line">  Point t5(one_plus_sqrt_3, CoordNT(1));</div><div class="line">  curves.push_back(Curve(circ5, s5, t5));</div><div class="line"></div><div class="line">  <span class="comment">// Create an arc (C6) of the unit circle, directed clockwise from</span></div><div class="line">  <span class="comment">// (-1/2, sqrt(3)/2) to (1/2, sqrt(3)/2).</span></div><div class="line">  <span class="comment">// The supporting circle is oriented accordingly.</span></div><div class="line">  Rational_point c6(0, 0);</div><div class="line">  Number_type half = Number_type(1) / Number_type(2);</div><div class="line">  CoordNT sqrt_3_div_2(Number_type(0), half, 3);</div><div class="line">  Point s6(-half, sqrt_3_div_2);</div><div class="line">  Point t6(half, sqrt_3_div_2);</div><div class="line">  curves.push_back(Curve(c6, 1, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga5aa0906f2432d414090dd8723c10f304">CGAL::CLOCKWISE</a>, s6, t6));</div><div class="line"></div><div class="line">  <span class="comment">// Create a circular arc (C7) defined by two endpoints and a midpoint,</span></div><div class="line">  <span class="comment">// all having rational coordinates. This arc is the upper right</span></div><div class="line">  <span class="comment">// quarter of a circle centered at the origin with radius 5.</span></div><div class="line">  curves.push_back(Curve(Rational_point(0, 5), Rational_point(3, 4),</div><div class="line">                         Rational_point(5, 0)));</div><div class="line"></div><div class="line">  <span class="comment">// Construct the arrangement of the curves and print its size.</span></div><div class="line">  Arrangement  arr;</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, curves.begin(), curves.end());</div><div class="line">  print_arrangement_size(arr);</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>It is also possible to construct \(x\)-monotone curve objects that represent \(x\)-monotone circular arcs or line segments using similar constructors. (Full circles are not \(x\)-monotone.)</p>
<p>The traits class-template <code><a class="el" href="classCGAL_1_1Arr__circular__line__arc__traits__2.html" title="This class is a traits class for CGAL arrangements, built on top of a model of concept CircularKernel...">Arr_circular_line_arc_traits_2</a>&lt;<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Circular_kernel_2.tag:../Circular_kernel_2/" href="../Circular_kernel_2/classCircularKernel.html">CircularKernel</a>&gt;</code> offered by the arrangement package also handles circular arcs and line segments. It is an alternative to the <code><a class="el" href="classCGAL_1_1Arr__circle__segment__traits__2.html" title="The class Arr_circle_segment_traits_2 is a model of the ArrangementTraits_2 concept and can be used t...">Arr_circle_segment_traits_2</a>&lt;<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>&gt;</code> class-template. These two class templates, while serve similar purposes, are based on different concepts, and posses different characteristics. You are encouraged to experiment with both, compare their performance, and use the most suitable for your case.</p>
<h4><a class="anchor" id="arr_sssectr_conic"></a>
A Traits Class for Conic Arcs</h4>
<p>A <em>conic curve</em> is an algebraic curve of degree 2. Namely, it is the locus of all points \((x,y)\) satisfying the equation \(c:\ r x^2 + s y^2 + t xy + u x + v y + w = 0\), where the six coefficients \(\langle r, s, t, u, v, w \rangle\) completely characterize the curve. The sign of the expression \(\Delta_{c} = 4 r s - t^2\) determines the type of curve:</p>
<ul>
<li>
<p class="startli">If \(\Delta_{c} &gt; 0\), the curve is an ellipse. A circle is a special case of an ellipse, where \(r = s\) and \(t = 0\).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">If \(\Delta_{c} = 0\), the curve is a parabola—an unbounded conic curve with a single connected branch. When \(r = s = t = 0\) we have a line, which can be considered as a degenerate parabola.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">If \(\Delta_{c} &lt; 0\), the curve is a hyperbola. That is, it comprises of two disconnected unbounded branches.</p>
<p class="endli"></p>
</li>
</ul>
<p>The <code><a class="el" href="classCGAL_1_1Arr__conic__traits__2.html" title="The class Arr_conic_traits_2 is a model of the ArrangementTraits_2 concept and can be used to constru...">Arr_conic_traits_2</a>&lt;RatKernel, AlgKernel, NtTraits&gt;</code> class template is capable of handling only bounded arcs of conic curves, referred to as <em>conic arcs</em>. A conic arc \(a\) may be either (i) a full ellipse, or (ii) defined by the tuple \(\langle \kappa, p_s, p_t, o \rangle\), where \(\kappa\) is a conic curve and \(p_s\) and \(p_t\) are two points on \(c\) (namely \(\kappa(p_s) = \kappa(p_t) = 0\)) that define the <em>source</em> and <em>target</em> of the arc, respectively. The arc is formed by traversing \(\kappa\) from the source to the target going in the orientation specified by \(o\), which is typically clockwise or counterclockwise orientation, but may also be collinear in case of degenerate conic conic-curves, namely, lines or pairs of lines.</p>
<p>We always assume that the conic coefficients \(\langle r, s, t, u, v, w \rangle\) are rational. The coordinates of points of intersection between two conic curves with rational coefficients are in general algebraic numbers of degree 4. Namely, they are roots of algebraic polynomials of degree 4. In addition, conic arcs may not necessarily be \(x\)-monotone, and must be split at points where the tangent to the arc is vertical. In the general case such points typically have coordinates that are algebraic numbers of degree 2. Note that as arrangement vertices induced by intersection points and points with vertical tangents are likely to have algebraic coordinates, we also allow the original endpoints of the input arcs \(p_s\) and \(p_t\) to have algebraic coordinates.</p>
<p>The <code><a class="el" href="classCGAL_1_1Arr__conic__traits__2.html" title="The class Arr_conic_traits_2 is a model of the ArrangementTraits_2 concept and can be used to constru...">Arr_conic_traits_2</a>&lt;RatKernel, AlgKernel, NtTraits&gt;</code> class template is designed for efficient handling of arrangements of bounded conic arcs. The template has three parameters, defined as follows:</p>
<ul>
<li>
<p class="startli">The <code>RatKernel</code> template parameter must be substituted with a geometric kernel whose field type is an exact rational type. It is used to define basic geometric entities (e.g., a line segment or a circle) with rational coefficients. Typically we use one of the standard CGAL kernels, instantiated with the number type <code>NtTraits::Rational</code> (see below).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The <code>AlgKernel</code> template parameter must be substituted with a geometric kernel whose field type is an exact algebraic type. It is used to define points with algebraic coordinates. Typically, we use one of the standard CGAL kernels, instantiated with the number type <code>NtTraits::Algebraic</code> (see below).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The <code>NtTraits</code> template parameter must be substituted with a type that encapsulates all the numeric operations needed for performing geometric computation carried out by the geometric traits class. It defines the <code>Integer</code>, <code>Rational</code>, and <code>Algebraic</code> number-types, and supports several operations on these types, such as conversion between these types, solving quadratic equations, and extracting the real roots of polynomials with integer coefficients. The use of the <code>CORE_algebraic_number_traits</code> class, which is included in the arrangement package, is highly recommended. The traits class-template relies on the multi-precision number types implemented in the Core library and performs exact computations on the number types it defines.</p>
<p class="endli"></p>
</li>
</ul>
<p>The instantiation of the conic traits class-template is slightly more complicated than the instantiation of the traits classes you have encountered so far. This instantiation is exemplified in the header file <code>arr_conics.h</code>. Note how we first define the rational and algebraic kernels using the number types given by the Core number type traits-class, then use them to define the conic traits class-template. Also note the types defined by the rational kernels, which we need for conveniently constructing conic arcs.</p>
<p>The <code><a class="el" href="classCGAL_1_1Arr__conic__traits__2.html" title="The class Arr_conic_traits_2 is a model of the ArrangementTraits_2 concept and can be used to constru...">Arr_conic_traits_2</a></code> models the <code><a class="el" href="classArrangementTraits__2.html" title="The concept ArrangementTraits_2 allows the construction of arrangement of general planar curves...">ArrangementTraits_2</a></code> and <code><a class="el" href="classArrangementLandmarkTraits__2.html" title="The concept ArrangementLandmarkTraits_2 refines the traits concepts ArrangementApproximateTraits_2 an...">ArrangementLandmarkTraits_2</a></code> concepts. Its <a class="el" href="classCGAL_1_1Arr__conic__traits__2_1_1Point__2.html"><code>Point_2</code></a> type is derived from <code>AlgKernel::Point_2</code>, while the <a class="el" href="classCGAL_1_1Arr__conic__traits__2_1_1Curve__2.html"><code>Curve_2</code></a> type represents a bounded, not necessarily \(x\)-monotone, conic arc. The <a class="el" href="classCGAL_1_1Arr__conic__traits__2_1_1X__monotone__curve__2.html"><code>X_monotone_curve_2</code></a> type is derived from <a class="el" href="classCGAL_1_1Arr__conic__traits__2_1_1Curve__2.html"><code>Curve_2</code></a>, but its constructors are used only by the traits class. Users should therefore construct only <a class="el" href="classCGAL_1_1Arr__conic__traits__2_1_1Curve__2.html"><code>Curve_2</code></a> objects and insert them into the arrangement using the <code><a class="el" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94" title="% inserts one or more curves or -monotone curves into a given arrangement, where no restrictions are ...">insert()</a></code> function.</p>
<p>Conic arcs are constructible from full ellipses or by specifying a supporting curve, two endpoints, and an orientation. However, several constructors of <a class="el" href="classCGAL_1_1Arr__conic__traits__2_1_1Curve__2.html"><code>Curve_2</code></a> are available to allow for some special cases, such as circular arcs or line segments. The <a class="el" href="classCGAL_1_1Arr__conic__traits__2_1_1Curve__2.html"><code>Curve_2</code></a> and the derived <a class="el" href="classCGAL_1_1Arr__conic__traits__2_1_1X__monotone__curve__2.html"><code>X_monotone_curve_2</code></a> classes also support basic access functions such as <code>source()</code>, <code>target()</code>, and <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__orientation__grp.html#ga91d9866cfde916ba70e5dbc596176d9e">orientation()</a></code>.</p>
<p><a class="anchor" id="fig__aos_fig-conics"></a></p><div class="image">
<img src="conics.png" alt="conics.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-conics">Figure 34.28</a> An arrangement of mixed conic arcs, as constructed in conics.cpp  </div> <br /> 
<p>The following example demonstrates the usage of the various constructors for conic arcs. The resulting arrangement is depicted in <a class="el" href="index.html#fig__aos_fig-conics">Figure 34.28</a>. Especially noteworthy are the constructor of a circular arc that accepts three points, the constructor of a conic arc that accepts five points, and the constructor that allows specifying approximate endpoints, where the exact endpoints are given explicitly as intersections of the supporting conic with two other conic curves. The approximate endpoints are used to select the specific exact endpoints out of all intersection points of the pair of curves (the supporting conic curve and the auxiliary conic curve). Also note that as the preconditions required by some of these constructors are rather complicated (see the Reference Manual for the details), a precondition violation does not cause the program to terminate—instead, an <em>invalid</em> arc is created. The call <code>a.is_valid()</code> verifies the validity of the arc \(a\). Naturally, inserting invalid arcs into an arrangement is not allowed, so the validity of an arc should be checked once it is constructed.</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2conics_8cpp-example.html">Arrangement_on_surface_2/conics.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Constructing an arrangement of various conic arcs.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/config.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef CGAL_USE_CORE</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_conics.h"</span></div><div class="line"><span class="preprocessor">#include "arr_print.h"</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  Arrangement arr;</div><div class="line"></div><div class="line">  <span class="comment">// Insert a hyperbolic arc (C1), supported by the hyperbola y = 1/x</span></div><div class="line">  <span class="comment">// (or: xy - 1 = 0) with the endpoints (1/4, 4) and (2, 1/2).</span></div><div class="line">  <span class="comment">// The arc is counterclockwise oriented.</span></div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Conic_arc(0, 0, 1, 0, 0, -1, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga39fcfbab0b0f0ce9139ad1613e21d60d">CGAL::COUNTERCLOCKWISE</a>,</div><div class="line">                        Point(Rational(1,4), 4), Point(2, Rational(1,2))));</div><div class="line"></div><div class="line">  <span class="comment">// Insert a full ellipse (C2), which is (x/4)^2 + (y/2)^2 = 0 rotated by</span></div><div class="line">  <span class="comment">// phi = 36.87 degrees (such that sin(phi) = 0.6, cos(phi) = 0.8),</span></div><div class="line">  <span class="comment">// yielding: 58x^2 + 72y^2 - 48xy - 360 = 0.</span></div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Conic_arc (58, 72, -48, 0, 0, -360));</div><div class="line"></div><div class="line">  <span class="comment">// Insert the segment (C3) (1, 1) -- (0, -3).</span></div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Conic_arc(Rat_segment(Rat_point(1, 1), Rat_point(0, -3))));</div><div class="line"></div><div class="line">  <span class="comment">// Insert a circular arc (C4) supported by the circle x^2 + y^2 = 5^2,</span></div><div class="line">  <span class="comment">// with (-3, 4) and (4, 3) as its endpoints. We want the arc to be</span></div><div class="line">  <span class="comment">// clockwise-oriented, so it passes through (0, 5) as well.</span></div><div class="line">  Conic_arc c4(Rat_point(-3, 4), Rat_point(0, 5), Rat_point(4, 3));</div><div class="line">  CGAL_assertion(c4.is_valid());</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, c4);</div><div class="line"></div><div class="line">  <span class="comment">// Insert a full unit circle (C5) that is centered at (0, 4).</span></div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Conic_arc(Rat_circle(Rat_point(0,4), 1)));</div><div class="line"></div><div class="line">  <span class="comment">// Insert a parabolic arc (C6) supported by the parabola y = -x^2 with</span></div><div class="line">  <span class="comment">// endpoints (-sqrt(3),-3) (~(-1.73,-3)) and (sqrt(2),-2) (~(1.41,-2)).</span></div><div class="line">  <span class="comment">// Since the x-coordinates of the endpoints cannot be acccurately represented,</span></div><div class="line">  <span class="comment">// we specify them as the intersections of the parabola with the lines</span></div><div class="line">  <span class="comment">// y = -3 and y = -2, respectively. The arc is clockwise-oriented.</span></div><div class="line">  Conic_arc c6 =</div><div class="line">    Conic_arc(1, 0, 0, 0, 1, 0, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga5aa0906f2432d414090dd8723c10f304">CGAL::CLOCKWISE</a>, <span class="comment">// The parabola.</span></div><div class="line">              Point(-1.73, -3),                  <span class="comment">// approximation of the source.</span></div><div class="line">              0, 0, 0, 0, 1, 3,                  <span class="comment">// the line: y = -3.</span></div><div class="line">              Point(1.41, -2),                   <span class="comment">// approximation of the target.</span></div><div class="line">              0, 0, 0, 0, 1, 2);                 <span class="comment">// the line: y = -2.</span></div><div class="line">  CGAL_assertion(c6.is_valid());</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, c6);</div><div class="line"></div><div class="line">  <span class="comment">// Insert the right half of the circle centered at (4, 2.5) whose radius</span></div><div class="line">  <span class="comment">// is 1/2 (therefore its squared radius is 1/4) (C7).</span></div><div class="line">  Rat_circle circ7(Rat_point(4, Rational(5,2)), Rational(1,4));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Conic_arc(circ7, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga5aa0906f2432d414090dd8723c10f304">CGAL::CLOCKWISE</a>, Point(4, 3), Point(4, 2)));</div><div class="line">  print_arrangement_size(arr);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#else</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Sorry, this example needs GMP and CORE\n"</span>;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>The types common to the example programs that use the <code><a class="el" href="classCGAL_1_1Arr__conic__traits__2.html" title="The class Arr_conic_traits_2 is a model of the ArrangementTraits_2 concept and can be used to constru...">Arr_conic_traits_2</a></code> class template are listed below and defined in the header file <code>arr_conics.h</code>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/CORE_algebraic_number_traits.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_conic_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> CGAL::CORE_algebraic_number_traits            Nt_traits;</div><div class="line"><span class="keyword">typedef</span> Nt_traits::Rational                           Rational;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;Rational&gt;</a>                     Rat_kernel;</div><div class="line"><span class="keyword">typedef</span> Rat_kernel::Point_2                           Rat_point;</div><div class="line"><span class="keyword">typedef</span> Rat_kernel::Segment_2                         Rat_segment;</div><div class="line"><span class="keyword">typedef</span> Rat_kernel::Circle_2                          Rat_circle;</div><div class="line"><span class="keyword">typedef</span> Nt_traits::Algebraic                          Algebraic;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;Algebraic&gt;</a>                    Alg_kernel;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__conic__traits__2.html">CGAL::Arr_conic_traits_2&lt;Rat_kernel, Alg_kernel, Nt_traits&gt;</a></div><div class="line">                                                      Traits;</div><div class="line"><span class="keyword">typedef</span> Traits::Point_2                               Point;</div><div class="line"><span class="keyword">typedef</span> Traits::Curve_2                               Conic_arc;</div><div class="line"><span class="keyword">typedef</span> Traits::X_monotone_curve_2                    X_monotone_conic_arc;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits&gt;</a>                   Arrangement;</div></div><!-- fragment --><p><a class="anchor" id="fig__aos_fig-conic_multiplicities"></a></p><div class="image">
<img src="conic_multiplicities.png" alt="conic_multiplicities.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-conic_multiplicities">Figure 34.29</a> An arrangement of a circular arc and an hyperbolic arc, as constructed in <a class="el" href="Arrangement_on_surface_2_2conic_multiplicities_8cpp-example.html">Arrangement_on_surface_2/conic_multiplicities.cpp</a>.  </div> <br /> 
<p>The last example in this section demonstrates how the conic-traits class can handle intersection points with multiplicity. The resulting arrangement is depicted in <a class="el" href="index.html#fig__aos_fig-conic_multiplicities">Figure 34.29</a>. The supporting curves of the two arcs, a circle centered at \((0,\frac{1}{2})\) with radius \(\frac{1}{2}\), and the hyperbola \(y = \frac{x^2}{1-x}\),<span class="footnote">This curve can also be written as \(c: x^2 + xy - y = 0\). It is a hyperbola since \(\Delta_{c} = -1\).</span> intersect at the origin such that the intersection point has multiplicity \(3\) (note that they both have the same horizontal tangent at \((0,0)\) and the same curvature \(1\)). In addition, they have another intersection point at \((\frac{1}{2},\frac{1}{2})\) of multiplicity \(1\).</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2conic_multiplicities_8cpp-example.html">Arrangement_on_surface_2/conic_multiplicities.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Handling intersection points with multiplicity between conic arcs.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/config.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef CGAL_USE_CORE</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_naive_point_location.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_conics.h"</span></div><div class="line"><span class="preprocessor">#include "arr_print.h"</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__naive__point__location.html">CGAL::Arr_naive_point_location&lt;Arrangement&gt;</a>             Naive_pl;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  Arrangement arr;</div><div class="line">  Naive_pl pl(arr);</div><div class="line"></div><div class="line">  <span class="comment">// Insert a hyperbolic arc, supported by the hyperbola y = x^2/(1-x)</span></div><div class="line">  <span class="comment">// (or: x^2 + xy - y = 0) with the endpoints (-1, 1/2) and (1/2, 1/2).</span></div><div class="line">  <span class="comment">// Note that the arc is counterclockwise oriented.</span></div><div class="line">  Point ps1(-1, Rational(1,2));</div><div class="line">  Point pt1(Rational(1,2), Rational(1,2));</div><div class="line">  Conic_arc cv1(1, 0, 1, 0, -1, 0, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga39fcfbab0b0f0ce9139ad1613e21d60d">CGAL::COUNTERCLOCKWISE</a>, ps1, pt1);</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, cv1, pl);</div><div class="line"></div><div class="line">  <span class="comment">// Insert the bottom half of the circle centered at (0, 1/2) whose radius</span></div><div class="line">  <span class="comment">// is 1/2 (therefore its squared radius is 1/4).</span></div><div class="line">  Rat_circle circ2(Rat_point(0, Rational(1,2)), Rational(1,4));</div><div class="line">  Point ps2(-Rational(1,2), Rational(1,2));</div><div class="line">  Point pt2(Rational(1,2), Rational(1,2));</div><div class="line">  Conic_arc cv2(circ2, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga39fcfbab0b0f0ce9139ad1613e21d60d">CGAL::COUNTERCLOCKWISE</a>, ps2, pt2);</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, cv2, pl);</div><div class="line"></div><div class="line">  print_arrangement (arr);</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#else</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Sorry, this example needs GMP and CORE\n"</span>;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><h4><a class="anchor" id="arr_sssectr_ratfunc"></a>
A Traits Class for Arcs of Rational Functions</h4>
<p>A <em>rational function</em> is given by the equation \(y = \frac{P(x)}{Q(x)}\), where \(P\) and \(Q\) are polynomials of arbitrary degrees. In particular, if \( Q(x) = 1\), then the function is simply a polynomial function. A bounded <em>rational arc</em> is defined by the graph of a rational function over some interval \([x_{\rm min}, x_{\rm max}]\), where \(Q\) does not have any real roots in this interval (thus, the arc does not contain any singularities). However, we may consider functions defined over unbounded intervals, namely, over \((-\infty, x_{\max}]\), \([x_{\min}, \infty)\), or \((-\infty, \infty)\). Rational functions, and polynomial functions in particular, are not only interesting in their own right, they are also useful for approximating more complicated curves and for interpolation; see, e.g., <a class="el" href="citelist.html#CITEREF_cgal:ptvf-nrcpp-02">[12]</a> Chapter 3.</p>
<p>Using the <code><a class="el" href="classCGAL_1_1Arr__rational__function__traits__2.html" title="The traits class Arr_rational_function_traits_2 is a model of the ArrangementTraits_2 concept...">Arr_rational_function_traits_2</a></code> class template it is possible to construct and maintain arrangements induced by rational arcs. Every instance of the <code><a class="el" href="classCGAL_1_1Arr__rational__function__traits__2.html" title="The traits class Arr_rational_function_traits_2 is a model of the ArrangementTraits_2 concept...">Arr_rational_function_traits_2</a></code> class template models the concepts <code><a class="el" href="classArrangementTraits__2.html" title="The concept ArrangementTraits_2 allows the construction of arrangement of general planar curves...">ArrangementTraits_2</a></code> and <code><a class="el" href="classArrangementOpenBoundaryTraits__2.html" title="Several predicates are required to handle -monotone curves that approach infinity and thus approach t...">ArrangementOpenBoundaryTraits_2</a></code>, but it does not model the <code><a class="el" href="classArrangementLandmarkTraits__2.html" title="The concept ArrangementLandmarkTraits_2 refines the traits concepts ArrangementApproximateTraits_2 an...">ArrangementLandmarkTraits_2</a></code> concept. It also models the refined concept <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Boolean_set_operations_2.tag:../Boolean_set_operations_2/" href="../Boolean_set_operations_2/classArrangementDirectionalXMonotoneTraits__2.html">ArrangementDirectionalXMonotoneTraits_2</a></code>, which enables Boolean set operations; see Package <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Boolean_set_operations_2.tag:../Boolean_set_operations_2/" href="../Boolean_set_operations_2/group__PkgBooleanSetOperations2Ref.html">2D Regularized Boolean Set-Operations Reference</a>. Note that it is not a model of <code><a class="el" href="classArrangementLandmarkTraits__2.html" title="The concept ArrangementLandmarkTraits_2 refines the traits concepts ArrangementApproximateTraits_2 an...">ArrangementLandmarkTraits_2</a></code> concept, so it is impossible to use the landmark point-location strategy with this traits class.</p>
<p><a class="anchor" id="fig__aos_fig-rat_func_singular"></a></p><div class="image">
<img src="rational_function_singular.png" alt="rational_function_singular.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-rat_func_singular">Figure 34.30</a> An arrangement of an arc of a rational functions that has singularities at \(x = 1\) and at \(x = 2\).  </div> <br /> 
<p>A rational arc is always \(x\)-monotone in the mathematical sense. However, it is not necessarily continuous, as it may have singularities. An arc that has singularities must be split into continuous portions before being inserted into the arrangement. Consider, for example, the rational arc given by the equation \(y = \frac{1}{(x-1)(2-x)}\) defined over the interval \([0,3]\), as depicted in <a class="el" href="index.html#fig__aos_fig-rat_func_singular">Figure 34.30</a>. This arc has two singularities, at \(x = 1\) and at \(x = 2\). It is split into three continuous portions defined over the intervals \([0,1)\), \((1,2)\), and \((2,3]\) by the traits operation <a class="el" href="classArrangementTraits__2.html#ae7fb20dc627766bd122192d6e5c1da57"><code>Make_x_monotone_2</code></a>. Arbitrary rational functions are represented by the nested type <a class="el" href="classCGAL_1_1Arr__rational__function__traits__2_1_1Curve__2.html"><code>Curve_2</code></a> and continuous portions of rational functions are represented by the nested type <a class="el" href="classCGAL_1_1Arr__rational__function__traits__2_1_1X__monotone__curve__2.html"><code>X_monotone_curve_2</code></a>. Constructors for both types are provided by the traits in form of functors.</p>
<p>When the <code><a class="el" href="classCGAL_1_1Arr__rational__function__traits__2.html" title="The traits class Arr_rational_function_traits_2 is a model of the ArrangementTraits_2 concept...">Arr_rational_function_traits_2</a>&lt;<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_kernel_d.tag:../Algebraic_kernel_d/" href="../Algebraic_kernel_d/classAlgebraicKernel__d__1.html">AlgebraicKernel_d_1</a>&gt;</code> class template is instantiated, the template parameter must be substituted with a model of the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_kernel_d.tag:../Algebraic_kernel_d/" href="../Algebraic_kernel_d/classAlgebraicKernel__d__1.html">AlgebraicKernel_d_1</a></code> concept. Models of this concept, such as the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_kernel_d.tag:../Algebraic_kernel_d/" href="../Algebraic_kernel_d/classCGAL_1_1Algebraic__kernel__d__1.html">Algebraic_kernel_d_1</a>&lt;Coefficient&gt;</code> class template provided by the package <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgAlgebraicFoundations">Algebraic Foundations</a> are meant to support algebraic functionalities on univariate polynomials of arbitrary degree. See the documentation of the concept <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_kernel_d.tag:../Algebraic_kernel_d/" href="../Algebraic_kernel_d/classAlgebraicKernel__d__1.html">AlgebraicKernel_d_1</a></code> for more information. A rational function is then represented as the quotient of two polynomials, \(P\) and \(Q\), of type <code>Polynomial_1</code> nested in every model of the concept <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_kernel_d.tag:../Algebraic_kernel_d/" href="../Algebraic_kernel_d/classAlgebraicKernel__d__1.html">AlgebraicKernel_d_1</a></code> and in particular in the algebraic-kernel type that substitutes the template parameter <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_kernel_d.tag:../Algebraic_kernel_d/" href="../Algebraic_kernel_d/classAlgebraicKernel__d__1.html">AlgebraicKernel_d_1</a></code> when the traits class-template is instantiated. Such a rational function is constructible from a single polynomial \(P\) (with \(Q(x) = 1\)), or from two polynomials \(P\) and \(Q\). The type of the polynomial coefficients, namely <code>Coefficient</code>, and the type of the interval bounds, namely <code>Bound</code>, are also nested in the algebraic-kernel type. If an instance of the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_kernel_d.tag:../Algebraic_kernel_d/" href="../Algebraic_kernel_d/classCGAL_1_1Algebraic__kernel__d__1.html">Algebraic_kernel_d_1</a>&lt;Coefficient&gt;</code> class template is used, for example, as the algebraic-kernel type, the type that substitutes its template parameter is defined as the <code>Coefficient</code> type. This type cannot be algebraic. Moreover, it is recommended that this type is not made rational either, since using rational (as opposed to integral) coefficients does not extend the range of the rational arcs and is typically less efficient.<span class="footnote">The <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_kernel_d.tag:../Algebraic_kernel_d/" href="../Algebraic_kernel_d/classCGAL_1_1Algebraic__kernel__d__1.html">Algebraic_kernel_d_1</a></code> class template uses the types provided by the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgPolynomial">Polynomial</a> package to define its nested <code>Polynomial_1</code> type and conveniently expose it to the user.</span> The <code>Bound</code> type, however, can be algebraic. A point of type <a class="el" href="classCGAL_1_1Arr__rational__function__traits__2_1_1Point__2.html"><code>Point_2</code></a> nested in the <code><a class="el" href="classCGAL_1_1Arr__rational__function__traits__2.html" title="The traits class Arr_rational_function_traits_2 is a model of the ArrangementTraits_2 concept...">Arr_rational_function_traits_2</a></code> class template is represented by a rational function and its \(x\)-coordinate, which is derived from the type <code>Algebraic_real_1</code> nested in the algebraic-kernel type. An explicit representation by the nested type <code>Algebraic_real_1</code> of the \(y\)-coordinate is only computed upon request, as it can be a rather costly operation.</p>
<p>The aforementioned types, <code>Polynomial_1</code>, <code>Coefficient</code>, <code>Bound, and</code>Algebraic_real_1<code>, are conveniently nested in the</code>Arr_rational_function_traits_2` class template among the others and obtained from there in the type definitions used in the examples given in this section and listed below. These types are defined in the header file <code>arr_rat_functions.h</code>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/CORE__BigInt_8h.html">CGAL/CORE_BigInt.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Algebraic_kernel_d_1.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_rational_function_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCORE_1_1BigInt.html">CORE::BigInt</a>                               Number_type;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_kernel_d.tag:../Algebraic_kernel_d/" href="../Algebraic_kernel_d/classCGAL_1_1Algebraic__kernel__d__1.html">CGAL::Algebraic_kernel_d_1&lt;Number_type&gt;</a>    AK1;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__rational__function__traits__2.html">CGAL::Arr_rational_function_traits_2&lt;AK1&gt;</a>  Traits;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> Traits::Polynomial_1                       Polynomial;</div><div class="line"><span class="keyword">typedef</span> Traits::Algebraic_real_1                   Alg_real;</div><div class="line"><span class="keyword">typedef</span> Traits::Bound                              Bound;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits&gt;</a>                Arrangement;</div></div><!-- fragment --><p>The constructed rational functions are cached by the traits class. The cache is local to each traits class object. It is therefore necessary to construct curves using only the constructor objects provided by member functions of the traits class. Moreover, a curve must only be used by the traits class object that was used to construct it. The cache is automatically cleaned up from time to time. The amortized clean up costs are constant. In addition, there is also a separate member function that cleans up the cache upon request.</p>
<p><a class="anchor" id="fig__aos_fig-rational_functions"></a></p><div class="image">
<img src="rational_functions.png" alt="rational_functions.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-rational_functions">Figure 34.31</a> An arrangement of four arcs of rational functions, as constructed in <a class="el" href="Arrangement_on_surface_2_2rational_functions_8cpp-example.html">Arrangement_on_surface_2/rational_functions.cpp</a>.  </div> <br /> 
<p>The following example demonstrates the construction of an arrangement induced by rational arcs depicted in <a class="el" href="index.html#fig__aos_fig-rational_functions">Figure 34.31</a>. It uses constructors both for polynomial arcs and for rational arcs.</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2rational_functions_8cpp-example.html">Arrangement_on_surface_2/rational_functions.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Constructing an arrangement of arcs of rational functions.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/config.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifndef CGAL_USE_CORE</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Sorry, this example needs CORE ..."</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#else</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_rat_functions.h"</span></div><div class="line"><span class="preprocessor">#include "arr_print.h"</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga2cbb865dd83eedd780f4a452635b1d28">CGAL::IO::set_pretty_mode</a>(std::cout);             <span class="comment">// for nice printouts.</span></div><div class="line"></div><div class="line">  <span class="comment">// Define a traits class object and a constructor for rational functions.</span></div><div class="line">  Traits traits;</div><div class="line">  <span class="keyword">auto</span> construct = traits.construct_x_monotone_curve_2_object();</div><div class="line"></div><div class="line">  <span class="comment">// Define a polynomial representing x.</span></div><div class="line">  Polynomial x = CGAL::shift(Polynomial(1), 1);</div><div class="line"></div><div class="line">  <span class="comment">// Define a container storing all arcs.</span></div><div class="line">  std::vector&lt;Traits::X_monotone_curve_2&gt; arcs;</div><div class="line"></div><div class="line">  <span class="comment">// Create an arc (C1) supported by the polynomial y = x^4 - 6x^2 + 8,</span></div><div class="line">  <span class="comment">// defined over the (approximate) interval [-2.1, 2.1].</span></div><div class="line">  Polynomial P1 = CGAL::ipower(x,4) - 6*x*x + 8;</div><div class="line">  Alg_real l(Bound(-2.1)), r(Bound(2.1));</div><div class="line">  arcs.push_back(construct(P1, l, r));</div><div class="line"></div><div class="line">  <span class="comment">// Create an arc (C2) supported by the function y = x / (1 + x^2),</span></div><div class="line">  <span class="comment">// defined over the interval [-3, 3].</span></div><div class="line">  Polynomial P2 = x;</div><div class="line">  Polynomial Q2 = 1 + x*x;</div><div class="line">  arcs.push_back(construct(P2, Q2, Alg_real(-3), Alg_real(3)));</div><div class="line"></div><div class="line">  <span class="comment">// Create an arc (C3) supported by the parbola y = 8 - x^2,</span></div><div class="line">  <span class="comment">// defined over the interval [-2, 3].</span></div><div class="line">  Polynomial P3 = 8 - x*x;</div><div class="line">  arcs.push_back(construct(P3, Alg_real(-2), Alg_real(3)));</div><div class="line"></div><div class="line">  <span class="comment">// Create an arc (C4) supported by the line y = -2x,</span></div><div class="line">  <span class="comment">// defined over the interval [-3, 0].</span></div><div class="line">  Polynomial P4 = -2*x;</div><div class="line">  arcs.push_back(construct(P4, Alg_real(-3), Alg_real(0)));</div><div class="line"></div><div class="line">  <span class="comment">// Construct the arrangement of the four arcs.</span></div><div class="line">  Arrangement arr(&amp;traits);</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, arcs.begin(), arcs.end());</div><div class="line">  print_arrangement(arr);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p><a class="anchor" id="fig__aos_fig-unbounded_rational_functions"></a></p><div class="image">
<img src="unbounded_rational_functions.png" alt="unbounded_rational_functions.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-unbounded_rational_functions">Figure 34.32</a> An arrangement of six arcs of rational functions, as constructed in <a class="el" href="Arrangement_on_surface_2_2unbounded_rational_functions_8cpp-example.html">Arrangement_on_surface_2/unbounded_rational_functions.cpp</a>.  </div> <br /> 
<p>The following example demonstrates the construction of an arrangement of six rational arcs, four unbounded arcs and two bounded ones, as depicted in <a class="el" href="index.html#fig__aos_fig-unbounded_rational_functions">Figure 34.32</a>. Note the usage of the constructors of an entire rational function and of an infinite "ray" of such a function. Also observe that the hyperbolas \(y = \pm\frac{1}{x}\) and \(y = \pm\frac{1}{2x}\) never intersect, although they have common vertical and horizontal asymptotes, so very "thin" unbounded faces are created between them:</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2unbounded_rational_functions_8cpp-example.html">Arrangement_on_surface_2/unbounded_rational_functions.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Constructing an arrangement of unbounded portions of rational functions.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/config.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifndef CGAL_USE_CORE</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Sorry, this example needs CORE ..."</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#else</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_rat_functions.h"</span></div><div class="line"><span class="preprocessor">#include "arr_print.h"</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga2cbb865dd83eedd780f4a452635b1d28">CGAL::IO::set_pretty_mode</a>(std::cout);             <span class="comment">// for nice printouts.</span></div><div class="line"></div><div class="line">  <span class="comment">// Define a traits class object and a constructor for rational functions.</span></div><div class="line">  AK1 ak1;</div><div class="line">  Traits traits(&amp;ak1);</div><div class="line">  <span class="keyword">auto</span> construct = traits.construct_curve_2_object();</div><div class="line"></div><div class="line">  <span class="comment">// Define a polynomial representing x.</span></div><div class="line">  Polynomial x = CGAL::shift(Polynomial(1), 1);</div><div class="line"></div><div class="line">  <span class="comment">// Define a container storing all arcs.</span></div><div class="line">  std::vector&lt;Traits::Curve_2&gt; arcs;</div><div class="line"></div><div class="line">  <span class="comment">// Create the arcs (C1, C'1) of the rational functions (y = 1 / x, y = -1 / x).</span></div><div class="line">  Polynomial P1(1);</div><div class="line">  Polynomial minusP1(-P1);</div><div class="line">  Polynomial Q1 = x;</div><div class="line">  arcs.push_back(construct(P1, Q1));</div><div class="line">  arcs.push_back(construct(minusP1, Q1));</div><div class="line"></div><div class="line">  <span class="comment">// Create the bounded segments (C2, C'2) of the parabolas (y = -4*x^2 + 3)</span></div><div class="line">  <span class="comment">// and (y = 4*x^2 - 3), defined over [-sqrt(3)/2, sqrt(3)/2].</span></div><div class="line">  Polynomial P2 = -4*x*x+3;</div><div class="line">  Polynomial minusP2 = -P2;</div><div class="line">  std::vector&lt;std::pair&lt;Alg_real, int&gt; &gt; roots;</div><div class="line">  ak1.solve_1_object()(P2, std::back_inserter(roots));<span class="comment">// [-sqrt(3)/2, sqrt(3)/2]</span></div><div class="line">  arcs.push_back(construct(P2, roots[0].first, roots[1].first));</div><div class="line">  arcs.push_back(construct(minusP2, roots[0].first, roots[1].first));</div><div class="line"></div><div class="line">  <span class="comment">// Create the arcs (C3, C'3) of (i) the rational function (y = 1 / 2*x) for</span></div><div class="line">  <span class="comment">// x &gt; 0, and (ii) the rational function (y = -1 / 2*x) for x &lt; 0.</span></div><div class="line">  Polynomial P3(1);</div><div class="line">  Polynomial minusP3(-P3);</div><div class="line">  Polynomial Q3 = 2*x;</div><div class="line">  arcs.push_back(construct(P3, Q3, Alg_real(0), <span class="keyword">true</span>));</div><div class="line">  arcs.push_back(construct(minusP3, Q3, Alg_real(0), <span class="keyword">false</span>));</div><div class="line"></div><div class="line">  <span class="comment">// Construct the arrangement of the six arcs and print its size.</span></div><div class="line">  Arrangement arr(&amp;traits);</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, arcs.begin(), arcs.end());</div><div class="line">  print_unbounded_arrangement_size(arr);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>The curve constructors have an additional advantage. They conveniently enable the provision of two polynomials that define a rational arc using rational coefficients. For example, let \(P\) and \(Q\) denote two polynomials with integral coefficients that define a rational arc of interest, and let \(P'\) and \(Q'\) denote two polynomials with rational coefficients that define the same rational arc; that is, the quotients \(P/Q\) and \(P'/Q'\) are identical. You can construct the rational arc providing the coefficients of \(P'\) and \(Q'\) to the constructor. In this case the constructor normalizes the coefficients and generates the desired polynomials \(P\) and \(Q\). To this end, the curve constructors of both types, namely <a class="el" href="classCGAL_1_1Arr__rational__function__traits__2_1_1Curve__2.html"><code>Curve_2</code></a> and <a class="el" href="classCGAL_1_1Arr__rational__function__traits__2_1_1X__monotone__curve__2.html"><code>X_monotone_curve_2</code></a>, have operators that accept ranges of polynomial coefficients as well as polynomials. The coefficients in a given range must be in the order of the degrees of the corresponding variables starting from the constant term.</p>
<h4><a class="anchor" id="arr_sssectr_bez"></a>
A Traits Class for Planar Bézier Curves</h4>
<p>A planar <em>Bézier curve</em> \(B\) is a parametric curve defined by a sequence of <em>control points</em> \(p_0, \ldots, p_n\) as follows:</p>
<p class="formulaDsp">
\begin{eqnarray*} B(t) = \left(X(t), Y(t)\right) = \ccSum{k=0}{n}{p_k \cdot \frac{n!}{k! (n-k)!} \cdot t^k (1-t)^{n-k}}\ . \end{eqnarray*}
</p>
<p>where \(t \in [0, 1]\). The degree of the curve is therefore \(n\); namely, \(X(t)\) and \(Y(t)\) are polynomials of degree \(n\). Bézier curves have numerous applications in computer graphics and solid modeling. They are used, for example, in free-form sketches and for defining the true-type fonts.</p>
<p>Using the <code><a class="el" href="classCGAL_1_1Arr__Bezier__curve__traits__2.html" title="The traits class Arr_Bezier_curve_traits_2 is a model of the ArrangementTraits_2 concept that handles...">Arr_Bezier_curve_traits_2</a>&lt;RatKernel, AlgKernel, NtTraits&gt;</code> class template you can construct and maintain arrangements induced by Bézier curves (including self-intersecting Bézier curves) of arbitrary degree. The curves are given by rational control points, that is, a sequence of objects of the <code>RatKernel::Point_2</code> type. (In general, a sequence of \(n+1\) control points define a Bézier curve of degree \(n\).) The three types that substitute the template parameters <code>RatKernel</code>, <code>AlgKernel</code>, and <code>NtTraits</code>, respectively, when the traits is instantiated must fulfill the same requirements of the corresponding types used to instantiate the <code><a class="el" href="classCGAL_1_1Arr__conic__traits__2.html" title="The class Arr_conic_traits_2 is a model of the ArrangementTraits_2 concept and can be used to constru...">Arr_conic_traits_2</a></code> class template. Here, the use of the <code>CORE_algebraic_number_traits</code> class is also recommended with <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">Cartesian</a> kernels instantiated with the <code>Rational</code> and <code>Algebraic</code> number types defined by this class. The examples given in this manual use the type definitions listed below. These types are defined in the header file <code>arr_Bezier.h</code>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/CORE_algebraic_number_traits.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_Bezier_curve_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> CGAL::CORE_algebraic_number_traits              Nt_traits;</div><div class="line"><span class="keyword">typedef</span> Nt_traits::Rational                             NT;</div><div class="line"><span class="keyword">typedef</span> Nt_traits::Rational                             Rational;</div><div class="line"><span class="keyword">typedef</span> Nt_traits::Algebraic                            Algebraic;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;Rational&gt;</a>                       Rat_kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;Algebraic&gt;</a>                      Alg_kernel;</div><div class="line"><span class="keyword">typedef</span> Rat_kernel::Point_2                             Rat_point;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__Bezier__curve__traits__2.html">CGAL::Arr_Bezier_curve_traits_2&lt;Rat_kernel, Alg_kernel, Nt_traits&gt;</a></div><div class="line">                                                        Traits;</div><div class="line"><span class="keyword">typedef</span> Traits::Curve_2                                 Bezier_curve;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits&gt;</a>                     Arrangement;</div></div><!-- fragment --><p>As mentioned above, we assume that the coordinates of all control points that define a Bézier curve are rational numbers, so both \(X(t)\) and \(Y(t)\) are polynomials with rational coefficients. The intersection points between curves are, however, algebraic numbers, and their exact computation is time-consuming. The traits class therefore contains a layer of geometric filtering that performs all computations in an approximate manner whenever possible. Thus, it resorts to exact computations only when the approximate computation fails to produce an unambiguous result. Most arrangement vertices are therefore associated with approximated points. You cannot access the coordinates of such points as algebraic numbers. However, access to the approximate coordinates is possible. See the Reference Manual for the exact interface of the <a class="el" href="classCGAL_1_1Arr__Bezier__curve__traits__2_1_1Point__2.html"><code>Point_2</code></a>, <a class="el" href="classCGAL_1_1Arr__Bezier__curve__traits__2_1_1Curve__2.html"><code>Curve_2</code></a>, and <a class="el" href="classCGAL_1_1Arr__Bezier__curve__traits__2_1_1X__monotone__curve__2.html"><code>X_monotone_curve_2</code></a> types defined by the traits class.</p>
<p>Every instance of the <code><a class="el" href="classCGAL_1_1Arr__Bezier__curve__traits__2.html" title="The traits class Arr_Bezier_curve_traits_2 is a model of the ArrangementTraits_2 concept that handles...">Arr_Bezier_curve_traits_2</a></code> class templates models the concept <code><a class="el" href="classArrangementTraits__2.html" title="The concept ArrangementTraits_2 allows the construction of arrangement of general planar curves...">ArrangementTraits_2</a></code> (but it does not model the <code><a class="el" href="classArrangementLandmarkTraits__2.html" title="The concept ArrangementLandmarkTraits_2 refines the traits concepts ArrangementApproximateTraits_2 an...">ArrangementLandmarkTraits_2</a></code> concept). It also models the refined concept <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Boolean_set_operations_2.tag:../Boolean_set_operations_2/" href="../Boolean_set_operations_2/classArrangementDirectionalXMonotoneTraits__2.html">ArrangementDirectionalXMonotoneTraits_2</a></code>, which enables Boolean set operations; see Package <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Boolean_set_operations_2.tag:../Boolean_set_operations_2/" href="../Boolean_set_operations_2/group__PkgBooleanSetOperations2Ref.html">2D Regularized Boolean Set-Operations Reference</a>.</p>
<p><a class="anchor" id="fig__aos_fig-bezier_curves"></a></p><div class="image">
<img src="bezier_curves.png" alt="bezier_curves.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-bezier_curves">Figure 34.33</a> An arrangement of ten Bézier curves of degree \(5\), as constructed in <a class="el" href="Arrangement_on_surface_2_2Bezier_curves_8cpp-example.html">Arrangement_on_surface_2/Bezier_curves.cpp</a>.  </div> <br /> 
<p>The following example reads a set of Bézier curves from an input file, where each file is specified by an integer stating its number of control points, followed by the sequence of control points given as integer or rational coordinates. By default, the program uses the <code>Bezier.dat</code> file, which contains ten curves of degree \(5\) each; their resulting arrangement is depicted in <a class="el" href="index.html#fig__aos_fig-bezier_curves">Figure 34.33</a>.</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2Bezier_curves_8cpp-example.html">Arrangement_on_surface_2/Bezier_curves.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Constructing an arrangement of Bezier curves.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/config.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef CGAL_USE_CORE</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_Bezier.h"</span></div><div class="line"><span class="preprocessor">#include "arr_print.h"</span></div><div class="line"><span class="preprocessor">#include "read_objects.h"</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[]) {</div><div class="line">  <span class="comment">// Get the name of the input file from the command line, or use the default</span></div><div class="line">  <span class="comment">// Bezier.dat file if no command-line parameters are given.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename = (argc &gt; 1) ? argv[1] : <span class="stringliteral">"Bezier.dat"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Read the Bezier curves.</span></div><div class="line">  std::list&lt;Bezier_curve&gt;  curves;</div><div class="line">  read_objects&lt;Bezier_curve&gt;(filename, std::back_inserter(curves));</div><div class="line"></div><div class="line">  <span class="comment">// Construct the arrangement.</span></div><div class="line">  Arrangement arr;</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">CGAL::insert</a>(arr, curves.begin(), curves.end());</div><div class="line">  print_arrangement_size(arr);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#else</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Sorry, this example needs GMP and CORE\n"</span>;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><h4><a class="anchor" id="arr_sssectr_alg"></a>
A Traits Class for Planar Algebraic Curves of Arbitrary Degree</h4>
<p>The traits class, namely <code><a class="el" href="classCGAL_1_1Arr__algebraic__segment__traits__2.html" title="The traits class Arr_algebraic_segment_traits_2 is a model of the ArrangementTraits_2 concept that ha...">Arr_algebraic_segment_traits_2</a></code>, is based on the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_kernel_d.tag:../Algebraic_kernel_d/" href="../Algebraic_kernel_d/classCGAL_1_1Algebraic__kernel__d__1.html">Algebraic_kernel_d_1</a></code> class template, which models the algebraic-kernel concept <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_kernel_d.tag:../Algebraic_kernel_d/" href="../Algebraic_kernel_d/classAlgebraicKernel__d__1.html">AlgebraicKernel_d_1</a></code>; see Section <a class="el" href="index.html#arr_sssectr_ratfunc">A Traits Class for Arcs of Rational Functions</a>. The traits class handles (i) algebraic curves and (ii) continuous (weakly) \(x\)-monotone segments of algebraic curves, which, however, are not necessarily maximal. (A formal definition is given below.) Observe that non- \(x\)-monotone segments are not supported. Still, it is the traits class that supports the most general type of curves among the traits classes included in the package.</p>
<p>Recall that an algebraic curve \(c\) in the plane is defined as the (real) zero set of a bivariate polynomial \(f(x,y)\). The curve is uniquely defined by \(f\), although several polynomials might define the same curve. We call \(f\) a <em>defining polynomial</em> of \(c\).</p>
<p>A formal definition of (weakly) \(x\)-monotone segments of algebraic curves follows. A point \(p\) on a curve \(c_f \subset \mathbb{R}^2\) (with defining polynomial \(f\)) is called <em>semi-regular</em> if, locally around \(p\), the curve \(c_f\) can be written as a function graph of some continuous function in \(x\) or in \(y\). (We also say that \(p\) is parameterizable in \(x\) or \(y\), respectively.) The only two cases of non-semi-regular points are isolated points and self-intersections. A <em>segment</em> of a curve in this context is a closed and continuous point set such that each interior point is semi-regular. It follows that a segment is either vertical or a closed connected point set, with all interior points parameterizable in \(x\).</p>
<p>Every instance of the <code><a class="el" href="classCGAL_1_1Arr__algebraic__segment__traits__2.html" title="The traits class Arr_algebraic_segment_traits_2 is a model of the ArrangementTraits_2 concept that ha...">Arr_algebraic_segment_traits_2</a>&lt;Coefficient&gt;</code> class template models the <code><a class="el" href="classArrangementTraits__2.html" title="The concept ArrangementTraits_2 allows the construction of arrangement of general planar curves...">ArrangementTraits_2</a></code> and <code><a class="el" href="classArrangementOpenBoundaryTraits__2.html" title="Several predicates are required to handle -monotone curves that approach infinity and thus approach t...">ArrangementOpenBoundaryTraits_2</a></code> concepts (but it does not model the <code><a class="el" href="classArrangementLandmarkTraits__2.html" title="The concept ArrangementLandmarkTraits_2 refines the traits concepts ArrangementApproximateTraits_2 an...">ArrangementLandmarkTraits_2</a></code> concept). The template argument <code>Coefficient</code> determines the type of the scalar coefficients of the polynomial. Currently supported integral number types are <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Gmpz.html">Gmpz</a></code>, <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classleda__integer.html">leda_integer</a></code>, and <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCORE_1_1BigInt.html">CORE::BigInt</a></code>. This is reflected in the statements included in the header file <code>integer_type.h</code>, the listings of which are omitted here. This header file is used by the two example programs listed in this section. The template parameter <code>Coefficient</code> can be substituted in addition with an instance of the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Sqrt__extension.html">Sqrt_extension</a>&lt;A,B&gt;</code> class template, where the template parameters <code>NT</code> and <code>Root</code> are substituted in turn with one of the integral number types above. Finally, the template parameter <code>Coefficient</code> can be substituted also with a rational number type, where the type of the numerator and denominator is one of the types above.</p>
<p>The type <a class="el" href="classCGAL_1_1Arr__algebraic__segment__traits__2_1_1Curve__2.html"><code>Curve_2</code></a> nested in the <code><a class="el" href="classCGAL_1_1Arr__algebraic__segment__traits__2.html" title="The traits class Arr_algebraic_segment_traits_2 is a model of the ArrangementTraits_2 concept that ha...">Arr_algebraic_segment_traits_2</a></code> class template defines an algebraic curve. An object of this type can be constructed by the <a class="el" href="classCGAL_1_1Arr__algebraic__segment__traits__2_1_1Construct__curve__2.html"><code>Construct_curve_2</code></a> functor also nested in the class template. Its function operator accepts as an argument an object of type <a class="el" href="classCGAL_1_1Arr__algebraic__segment__traits__2.html#a9305250a25724c9ecba59aca43aeda25"><code>Polynomial_2</code></a>, nested as well in the traits class-template. The type <a class="el" href="classCGAL_1_1Arr__algebraic__segment__traits__2.html#a9305250a25724c9ecba59aca43aeda25"><code>Polynomial_2</code></a> models the concept <code>Polynomial_d</code>. An object of the nested type <a class="el" href="classCGAL_1_1Arr__algebraic__segment__traits__2.html#a9305250a25724c9ecba59aca43aeda25"><code>Polynomial_2</code></a> represents a bivariate polynomial. It can be constructed in a few convenient ways, some are exemplified by the programs listed below. Consult the reference guide for the complete set of options.</p>
<p><a class="anchor" id="fig__aos_fig-algebraic_curves"></a></p><div class="image">
<img src="algebraic_curves.png" alt="algebraic_curves.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-algebraic_curves">Figure 34.34</a> An arrangement of algebraic curves of degrees \(1\), \(2\), \(3\), and \(6\), as constructed in <a class="el" href="Arrangement_on_surface_2_2algebraic_curves_8cpp-example.html">Arrangement_on_surface_2/algebraic_curves.cpp</a>.  </div> <br /> 
<p>The following examples computes the arrangement depicted in in <a class="el" href="index.html#fig__aos_fig-algebraic_curves">Figure 34.34</a>. The arrangement is induced by four algebraic curves, \(c_1\), \(c_2\), \(c_3\), and \(c_4\), of degrees \(1\), \(2\), \(3\), and \(6\), respectively. For each curve the defining polynomial is constructed first. Then, the algebraic curve is constructed using the <a class="el" href="classCGAL_1_1Arr__algebraic__segment__traits__2_1_1Construct__curve__2.html"><code>Construct_curve_2</code></a> functor. Finally, the curve is inserted into the arrangement.</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2algebraic_curves_8cpp-example.html">Arrangement_on_surface_2/algebraic_curves.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Constructing an arrangement of algebraic curves.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/config.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#if (!CGAL_USE_CORE) &amp;&amp; (!CGAL_USE_LEDA) &amp;&amp; (!(CGAL_USE_GMP &amp;&amp; CGAL_USE_MPFI))</span></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Sorry, this example needs CORE, LEDA, or GMP+MPFI ..."</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#else</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_algebraic_segment_traits_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "integer_type.h"</span></div><div class="line"><span class="preprocessor">#include "arr_print.h"</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__algebraic__segment__traits__2.html">CGAL::Arr_algebraic_segment_traits_2&lt;Integer&gt;</a> Traits;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits&gt;</a>                   Arrangement;</div><div class="line"><span class="keyword">typedef</span> Traits::Curve_2                               Curve;</div><div class="line"><span class="keyword">typedef</span> Traits::Polynomial_2                          Polynomial;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga2cbb865dd83eedd780f4a452635b1d28">CGAL::IO::set_pretty_mode</a>(std::cout);             <span class="comment">// for nice printouts.</span></div><div class="line"></div><div class="line">  Traits traits;</div><div class="line">  Arrangement arr(&amp;traits);</div><div class="line"></div><div class="line">  <span class="comment">// Functor to create a curve from a Polynomial.</span></div><div class="line">  <span class="keyword">auto</span> construct_cv = traits.construct_curve_2_object();</div><div class="line"></div><div class="line">  Polynomial x = CGAL::shift(Polynomial(1), 1, 0);</div><div class="line">  Polynomial y = CGAL::shift(Polynomial(1), 1, 1);</div><div class="line"></div><div class="line">  <span class="comment">// Construct an unbounded line (C1) with the equation 3x - 5y - 2 = 0.</span></div><div class="line">  Polynomial f1 = 3*x - 5*y - 2;</div><div class="line">  Curve cv1 = construct_cv(f1);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Inserting curve "</span> &lt;&lt; f1 &lt;&lt; std::endl;</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">CGAL::insert</a>(arr, cv1);</div><div class="line"></div><div class="line">  <span class="comment">// Construct the ellipse (C2) with the equation x^2 + 3*y^2 - 10 = 0.</span></div><div class="line">  Polynomial f2 = CGAL::ipower(x, 2) + 3*CGAL::ipower(y, 2) - 10;</div><div class="line">  Curve cv2 = construct_cv(f2);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Inserting curve "</span> &lt;&lt; f2 &lt;&lt; std::endl;</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">CGAL::insert</a>(arr, cv2);</div><div class="line"></div><div class="line">  <span class="comment">// Construct a cubic curve (C3) with the equation x^2 + y^2 + xy^2 = 0,</span></div><div class="line">  <span class="comment">// with isolated point at (0,0) and vertical asymptote at x = 1.</span></div><div class="line">  Polynomial f3 = CGAL::ipower(x, 2) + CGAL::ipower(y, 2) +</div><div class="line">    x*CGAL::ipower(y, 2);</div><div class="line">  Curve cv3 = construct_cv(f3);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Inserting curve "</span> &lt;&lt; f3 &lt;&lt; std::endl;</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">CGAL::insert</a>(arr, cv3);</div><div class="line"></div><div class="line">  <span class="comment">// Construct a curve of degree 6 (C4) with the equation</span></div><div class="line">  <span class="comment">// x^6 + y^6 - x^3y^3 - 12 = 0.</span></div><div class="line">  Polynomial f4 = CGAL::ipower(x, 6) + CGAL::ipower(y, 6) -</div><div class="line">    CGAL::ipower(x, 3)*CGAL::ipower(y, 3) - 12;</div><div class="line">  Curve cv4 = construct_cv(f4);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Inserting curve "</span> &lt;&lt; f4 &lt;&lt; std::endl;</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">CGAL::insert</a>(arr, cv4);</div><div class="line"></div><div class="line">  print_arrangement_size(arr);                <span class="comment">// print the arrangement size</span></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>The <code><a class="el" href="classCGAL_1_1Arr__algebraic__segment__traits__2.html" title="The traits class Arr_algebraic_segment_traits_2 is a model of the ArrangementTraits_2 concept that ha...">Arr_algebraic_segment_traits_2</a></code> class template carries state to expedite some of its computations. Thus, it is essential to have only one copy of the traits object during the life time of a program that utilizes this traits class. To this end, the example above uses the constructor of the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> data structure that accepts the traits object as input. Carrying state is not a unique property of the <code><a class="el" href="classCGAL_1_1Arr__algebraic__segment__traits__2.html" title="The traits class Arr_algebraic_segment_traits_2 is a model of the ArrangementTraits_2 concept that ha...">Arr_algebraic_segment_traits_2</a></code> class template; it is common to many traits classes, especially to traits classes that handle algebraic curves. Therefore, as a general rule, if your application requires direct access to a traits object, define it locally, and pass it to the constructor of the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> data structure to avoid the construction of a duplicate traits-class object.</p>
<p>A weakly \(x\)-monotone segment of an algebraic curve is represented by the <a class="el" href="classCGAL_1_1Arr__algebraic__segment__traits__2_1_1X__monotone__curve__2.html"><code>X_monotone_curve_2</code></a> type nested in the traits class-template. You can construct such segments in two ways as follows: (i) using the <a class="el" href="classArrangementTraits__2.html#ae7fb20dc627766bd122192d6e5c1da57"><code>Make_x_monotone_2</code></a> functor or (ii) using the <a class="el" href="classCGAL_1_1Arr__algebraic__segment__traits__2_1_1Construct__x__monotone__segment__2.html"><code>Construct_x_monotone_segment_2</code></a> functor. Both functors are nested in the traits class-template. The former is required by the concept <code><a class="el" href="classArrangementTraits__2.html" title="The concept ArrangementTraits_2 allows the construction of arrangement of general planar curves...">ArrangementTraits_2</a></code> our traits class models; see Section <a class="el" href="index.html#aos_sssec-geom_traits-concepts_arbitrary">Supporting Arbitrary Curves</a>. The latter enables the construction of individual segments. The <a class="el" href="classCGAL_1_1Arr__algebraic__segment__traits__2_1_1X__monotone__curve__2.html"><code>X_monotone_curve_2</code></a> type represents weakly \(x\)-monotone segments of a curve; however, for technical reasons, segments may need to be further subdivided into several sub-segments, called terminal segments. Therefore, <a class="el" href="classCGAL_1_1Arr__algebraic__segment__traits__2_1_1Construct__x__monotone__segment__2.html"><code>Construct_x_monotone_segment_2</code></a> constructs a sequence of <a class="el" href="classCGAL_1_1Arr__algebraic__segment__traits__2_1_1X__monotone__curve__2.html"><code>X_monotone_curve_2</code></a> objects, whose union represents the desired weakly \(x\)-monotone segment. The function operator of the <a class="el" href="classCGAL_1_1Arr__algebraic__segment__traits__2_1_1Construct__x__monotone__segment__2.html"><code>Construct_x_monotone_segment_2</code></a> functor accepts as arguments the underlying algebraic curve, the leftmost point of the segment, the rightmost point of the segment, and an output iterator associated with a container of output terminal segments. The function operator is overloaded. In addition to the variant above, there is one that accepts the underlying algebraic curve, a single point \(p\), an enumerator that delimits the segment, and an output iterator. It returns the maximal \(x\)-monotone segment that contains \(p\). The enumerator specifies whether \(p\) is interior to the returned segment, its left endpoint, or its right endpoint. The third variant accepts only two delimiting points and an output iterator. It constructs line segments.</p>
<p> </p><div class="CGALAdvanced"> <div>Advanced</div>  The subdivision terminal segments is due to the internal representation of \(x\)-monotone segments, which is based on a vertical decomposition. We assume the defining polynomial \(f\) of the curve \(c\) to be <em>square-free</em>. That is, it contains no divisor \(g^2\) of total degree greater than zero. We define a <em>(complex) critical point</em> \(p\in\mathbb{C}^2\) by <p class="formulaDsp">
\[ f(p)=0=\frac{\partial f}{\partial y}(p). \]
</p>
<p> An \(x\)-coordinate \(\alpha\in\mathbb{R}\) is <em>critical</em> either if some critical point has \(x\)-coordinate \(\alpha\), or if the leading coefficient of \(f\), considered as a polynomial in \(y\), vanishes. In particular, vertical lines and isolated points of \(c\) can only take place at critical \(x\)-coordinates. Between two consecutive critical \(x\)-coordinates the curve decomposes into a finite number of \(x\)-monotone segments (the same holds to the left of the leftmost, and to the right of the rightmost critical \(x\)-coordinate). The type <a class="el" href="classCGAL_1_1Arr__algebraic__segment__traits__2_1_1X__monotone__curve__2.html"><code>X_monotone_curve_2</code></a> is only capable of representing such segments (and sub-segments of them). Formally, a terminal segment is either a vertical line-segment or a segment of an \(x\)-monotone curve whose \(x\)-range does not contain critical points in its interior. See <a class="el" href="index.html#fig__aos_fig-algebraic_curves_decomposition">Figure 34.35</a> for an example of a quartic curve and its decomposition into terminal segments. Notice that six vertices split the curve into \(x\)-monotone segments, and four additional vertices further split the corresponding \(x\)-monotone segments into terminal segments.  </p></div> 
<p><a class="anchor" id="fig__aos_fig-algebraic_curves_decomposition"></a></p><div class="image">
<img src="algebraic_curves_decomposition.png" alt="algebraic_curves_decomposition.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-algebraic_curves_decomposition">Figure 34.35</a>
<p>The critical \(x\)-coordinates of an algebraic curve (dashed lines), and its decomposition into terminal segments (in different colors). The segment from \(p\) to \(q\) consists of the union of three terminal segments.  </p></div> <br /> 
<p>The type <code>Algebraic_real_1</code> must be defined by any model of the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_kernel_d.tag:../Algebraic_kernel_d/" href="../Algebraic_kernel_d/classAlgebraicKernel__d__1.html">AlgebraicKernel_d_1</a></code> concept. The traits class-template <code><a class="el" href="classCGAL_1_1Arr__algebraic__segment__traits__2.html" title="The traits class Arr_algebraic_segment_traits_2 is a model of the ArrangementTraits_2 concept that ha...">Arr_algebraic_segment_traits_2</a></code> exploits an instance of the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_kernel_d.tag:../Algebraic_kernel_d/" href="../Algebraic_kernel_d/classCGAL_1_1Algebraic__kernel__d__1.html">Algebraic_kernel_d_1</a></code> class template, which models the concept <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_kernel_d.tag:../Algebraic_kernel_d/" href="../Algebraic_kernel_d/classAlgebraicKernel__d__1.html">AlgebraicKernel_d_1</a></code>. The exploited instance is nested in the traits class-template. You can use this model to create algebraic numbers as roots of univariate polynomials, and process them, for instance, compare them or approximate them to any precision. See the documentation of the concept <code>AlgebraicKernel_1</code> for more information. Coordinates of points are represented by the type <code>Algebraic_real_1</code> nested in the traits class-template. This type is defined as the corresponding type nested in the instance of <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_kernel_d.tag:../Algebraic_kernel_d/" href="../Algebraic_kernel_d/classCGAL_1_1Algebraic__kernel__d__1.html">Algebraic_kernel_d_1</a></code>.</p>
<p>You can construct an object of type <a class="el" href="classCGAL_1_1Arr__algebraic__segment__traits__2_1_1Point__2.html"><code>Point_2</code></a> using the <a class="el" href="classCGAL_1_1Arr__algebraic__segment__traits__2_1_1Construct__point__2.html"><code>Construct_point_2</code></a> functor nested in the traits class-template. Its function operator is overloaded with a couple of variants that accepts the \(x\) and \(y\) coordinates of the point. Their types must be either <code>Algebraic_real_1</code> or <code>Coefficient</code>. Another efficient variant accepts a triple \((x_0,c,i)\), which identifies the \(i\)-th point (counted from below) in the fiber of \(c\) at the \(x\)-coordinate \(x_0\). <span class="footnote">The fiber of a curve \(c\) at some \(x\)-coordinate \(x'\) is the set of all points on \(c\) with \(x\)-coordinate \(x'\). Formally, for a curve \(c\) and \(x' \in \mathbb{R}\), the fiber of \(c\) at \(x'\) is \(c \cap {(x',b),|,b \in \mathbb{R}}\).</span> In the example depicted in <a class="el" href="index.html#fig__aos_fig-algebraic_curves_decomposition">Figure 34.35</a>, if \(x_1\) denotes the \(x\)-coordinate of \(p\), and \(c\) represents the algebraic curve, then \(p\) could be represented by \((x_1,c,3)\). If \(x_2\) is the \(x\)-coordinate of \(q\), then \((x_2,c,1)\) is a valid representation of \(q\). Points are represented internally using the triple described above. Although the \(y\)-coordinate of a point represented by an object of the nested type <code>Algebraic_real_1</code> can be obtained, we advise caution with that option, since computing an explicit representation of the \(y\)-coordinate can be rather expensive.</p>
<p><a class="anchor" id="fig__aos_fig-algebraic_segments"></a></p><div class="image">
<img src="algebraic_segments.png" alt="algebraic_segments.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-algebraic_segments">Figure 34.36</a> An arrangement of algebraic segments (solid lines), as constructed in <a class="el" href="Arrangement_on_surface_2_2algebraic_segments_8cpp-example.html">Arrangement_on_surface_2/algebraic_segments.cpp</a>. The supporting curves are drawn as dashed lines.  </div> <br /> 
<p>The following code exemplifies the method to construct points and the various methods to construct algebraic segments. The computed arrangement is depicted in <a class="el" href="index.html#fig__aos_fig-algebraic_segments">Figure 34.36</a>.</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2algebraic_segments_8cpp-example.html">Arrangement_on_surface_2/algebraic_segments.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Constructing an arrangement of algebraic segments.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/config.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#if (!CGAL_USE_CORE) &amp;&amp; (!CGAL_USE_LEDA) &amp;&amp; (!(CGAL_USE_GMP &amp;&amp; CGAL_USE_MPFI))</span></div><div class="line"><span class="keywordtype">int</span> main ()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Sorry, this example needs CORE, LEDA, or GMP+MPFI ..."</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"><span class="preprocessor">#else</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_algebraic_segment_traits_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "integer_type.h"</span></div><div class="line"><span class="preprocessor">#include "arr_print.h"</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__algebraic__segment__traits__2.html">CGAL::Arr_algebraic_segment_traits_2&lt;Integer&gt;</a> Traits;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits&gt;</a>                   Arrangement;</div><div class="line"><span class="keyword">typedef</span> Traits::Curve_2                               Curve;</div><div class="line"><span class="keyword">typedef</span> Traits::Polynomial_2                          Polynomial;</div><div class="line"><span class="keyword">typedef</span> Traits::Algebraic_real_1                      Algebraic_real;</div><div class="line"><span class="keyword">typedef</span> Traits::X_monotone_curve_2                    X_monotone_curve;</div><div class="line"><span class="keyword">typedef</span> Traits::Point_2                               Point;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> boost::variant&lt;Point, X_monotone_curve&gt;       Make_x_monotone_result;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  Traits traits;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> make_xmon = traits.make_x_monotone_2_object();</div><div class="line">  <span class="keyword">auto</span> ctr_cv = traits.construct_curve_2_object();</div><div class="line">  <span class="keyword">auto</span> ctr_pt = traits.construct_point_2_object();</div><div class="line">  <span class="keyword">auto</span> construct_xseg = traits.construct_x_monotone_segment_2_object();</div><div class="line"></div><div class="line">  Polynomial x = CGAL::shift(Polynomial(1), 1, 0);</div><div class="line">  Polynomial y = CGAL::shift(Polynomial(1), 1, 1);</div><div class="line"></div><div class="line">  <span class="comment">// Construct a curve (C1) with the equation x^4+y^3-1=0.</span></div><div class="line">  Curve cv1 = ctr_cv(CGAL::ipower(x, 4) + CGAL::ipower(y, 3) - 1);</div><div class="line">  <span class="comment">// Construct all x-monotone segments using the Make_x_mononotone functor.</span></div><div class="line">  std::vector&lt;Make_x_monotone_result&gt; pre_segs;</div><div class="line">  make_xmon(cv1, std::back_inserter(pre_segs));</div><div class="line">  <span class="comment">// Cast all CGAL::Objects into X_monotone_segment</span></div><div class="line">  <span class="comment">// (the vector might also contain Point objects for isolated points,</span></div><div class="line">  <span class="comment">// but not in this case).</span></div><div class="line">  std::vector&lt;X_monotone_curve&gt; segs;</div><div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; pre_segs.size(); ++i) {</div><div class="line">    <span class="keyword">auto</span>* curr_p = boost::get&lt;X_monotone_curve&gt;(&amp;pre_segs[i]);</div><div class="line">    CGAL_assertion(curr_p);</div><div class="line">    segs.push_back(*curr_p);</div><div class="line">  }</div><div class="line">  <span class="comment">// Construct an ellipse (C2) with the equation 2*x^2+5*y^2-7=0.</span></div><div class="line">  Curve cv2 = ctr_cv(2*CGAL::ipower(x,2)+5*CGAL::ipower(y,2)-7);</div><div class="line"></div><div class="line">  <span class="comment">// Construct point on the upper arc (counting of arc numbers starts with 0).</span></div><div class="line">  Point p11 = ctr_pt(Algebraic_real(0), cv2, 1);</div><div class="line"></div><div class="line">  construct_xseg(cv2, p11, Traits::POINT_IN_INTERIOR,</div><div class="line">                 std::back_inserter(segs));</div><div class="line"></div><div class="line">  <span class="comment">// Construct a vertical cusp (C3) with the equation x^2-y^3=0.</span></div><div class="line">  Curve cv3 = ctr_cv(CGAL::ipower(x, 2)-CGAL::ipower(y, 3));</div><div class="line"></div><div class="line">  <span class="comment">// Construct a segment containing the cusp point.</span></div><div class="line">  <span class="comment">// This adds two X_monotone_curve objects to the vector,</span></div><div class="line">  <span class="comment">// because the cusp is a critical point.</span></div><div class="line">  Point p21 = ctr_pt(Algebraic_real(-2), cv3, 0);</div><div class="line">  Point p22 = ctr_pt(Algebraic_real(2), cv3, 0);</div><div class="line">  construct_xseg(cv3 ,p21, p22, std::back_inserter(segs));</div><div class="line"></div><div class="line">  <span class="comment">// Construct an unbounded curve, starting at x=3.</span></div><div class="line">  Point p23 = ctr_pt(Algebraic_real(3), cv3, 0);</div><div class="line">  construct_xseg(cv3, p23, Traits::MIN_ENDPOINT, std::back_inserter(segs));</div><div class="line"></div><div class="line">  <span class="comment">// Construct another conic (C4) with the equation y^2-x^2+1=0.</span></div><div class="line">  Curve cv4 = ctr_cv(CGAL::ipower(y,2)-CGAL::ipower(x,2)+1);</div><div class="line"></div><div class="line">  Point p31 = ctr_pt(Algebraic_real(2), cv4, 1);</div><div class="line">  construct_xseg(cv4, p31, Traits::MAX_ENDPOINT, std::back_inserter(segs));</div><div class="line"></div><div class="line">  <span class="comment">// Construct a vertical segment (C5).</span></div><div class="line">  Curve cv5 = ctr_cv(x);</div><div class="line">  Point v1 = ctr_pt(Algebraic_real(0), cv3, 0);</div><div class="line">  Point v2 = ctr_pt(Algebraic_real(0), cv2, 1);</div><div class="line">  construct_xseg(cv5, v1, v2, std::back_inserter(segs));</div><div class="line"></div><div class="line">  Arrangement arr(&amp;traits);</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">CGAL::insert</a>(arr, segs.begin(), segs.end());</div><div class="line"></div><div class="line">  <span class="comment">// Add some isolated points (must be wrapped into CGAL::Object).</span></div><div class="line">  std::vector&lt;CGAL::Object&gt; isolated_pts;</div><div class="line">  isolated_pts.push_back(CGAL::make_object(ctr_pt(Algebraic_real(2), cv4, 0)));</div><div class="line">  isolated_pts.push_back(CGAL::make_object(ctr_pt(Integer(1), Integer(2))));</div><div class="line">  isolated_pts.push_back(CGAL::make_object(ctr_pt(Algebraic_real(-1),</div><div class="line">                                                  Algebraic_real(2))));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">CGAL::insert</a>(arr, isolated_pts.begin(), isolated_pts.end());</div><div class="line"></div><div class="line">  print_arrangement_size(arr);                  <span class="comment">// print the arrangement size</span></div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><h3><a class="anchor" id="arr_ssectr_spherical"></a>
Arcs of Great Circles Embedded in the Sphere</h3>
<p>A great circle of a sphere is the intersection of the sphere and a plane that passes through the center point of the sphere. For all pairs of distinct points on the sphere except for antipodal points, there is a unique great circle through the two points. There are infinitely many great circles through antipodal points. The minor arc of a great circle between two points is the shortest spherical-path between them. In this sense, minor arcs are analogous to line segments in Euclidean geometry.</p>
<p>The <code><a class="el" href="classCGAL_1_1Arr__geodesic__arc__on__sphere__traits__2.html" title="The traits class Arr_geodesic_arc_on_sphere_traits_2 is a model of the ArrangementTraits_2 concept...">Arr_geodesic_arc_on_sphere_traits_2</a>&lt;<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>,X,Y&gt;</code> class template handles arcs of great circles (also known as geodesic arcs) of a unit sphere (centered at the origin in \(\mathbb{R}^3\)). It is a model of the concept <code><a class="el" href="classArrangementSphericalBoundaryTraits__2.html" title="Models of the concept ArrangementSphericalBoundaryTraits_2 handle curves on a sphere or a surface tha...">ArrangementSphericalBoundaryTraits_2</a></code>; see Section <a class="el" href="index.html#aos_ssec-traits-curved">Supporting Unbounded Curves or Curved Surfaces</a>. An arrangement type (an instance of the template <code><a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html">Arrangement_on_surface_2</a>&lt;GeomTraits, TopolTraits&gt;</code>) that uses an instance of this traits class as the geometry traits must use a matching topology traits. Currently, this package provides one template, namely, <code><a class="el" href="classCGAL_1_1Arr__spherical__topology__traits__2.html">Arr_spherical_topology_traits_2</a>&lt;GeometryTraits_2, Dcel&gt;</code> an instance of which can be used as the topology traits.</p>
<p>The unit sphere is defined over a parameter space \(\Phi = [\tau,2\pi+\tau] \times [-\frac{\pi}{2}, \frac{\pi}{2}]\), where \(\tau = \arctan(X, Y)\). By default, \(X = -1, Y = 0\), which implies \(\tau = -\pi\), which implies a default parameterization \(\Phi = [-\pi, \pi] \times [-\frac{\pi}{2}, \frac{\pi}{2}]\). The equator curve, for example, is given by \(\gamma(t) = (2t\pi + \tau, 0)\), for \(t \in [0,1]\). The surface is given by \(\phi_S(\alpha,\beta) = (\cos \alpha \cos \beta, \sin \alpha \cos \beta, \sin \beta)\); see Section <a class="el" href="index.html#aos_sec-curved_surfaces">Arrangements on Curved Surfaces</a> for more details. This parameterization induces two contraction points \((0,0,-1) = \phi_S(\alpha,-\frac{\pi}{2})\) and \((0,0,1) = \phi_S(\alpha,\frac{\pi}{2})\), for all \(\alpha\), referred to as the south and north poles, respectively, and an identification curve \(\{\phi_S(\alpha,\beta)\,|\,-\frac{\pi}{2} \leq \beta \leq \frac{\pi}{2}\}\), as \(\phi_S(\pi,\beta) = \phi_S(2\pi + \tau,\beta)\) for all \(\beta\). When \(\tau = -\pi\) (the default), the identification curve coincides with the opposite Prime (Greenwich) Meridian. In other words, the left and right boundary sides of the parameter space are identified and the top and bottom boundary sides are contracted. The arguments that substitute the template parameters <code>X</code> and <code>Y</code> when <code><a class="el" href="classCGAL_1_1Arr__geodesic__arc__on__sphere__traits__2.html" title="The traits class Arr_geodesic_arc_on_sphere_traits_2 is a model of the ArrangementTraits_2 concept...">Arr_geodesic_arc_on_sphere_traits_2</a>&lt;<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a>, X, Y&gt;</code> is instantiated determine the value of \(\tau\). Essentially, overriding their default values rotates the identification curve about the vertical axes of the image coordinate system (that is, the sphere coordinate system). These arguments must be integral values. They define a not-necessarily normalized vector \((x,y)\) in the \(xy\)-plane in the image coordinate system, that bisects the identification curve. The explicit expression for the surface above is not used at all in the implementation of the traits. Indeed, all the required geometric operations listed in the traits concept are implemented using only rational arithmetic.</p>
<p>The following example constructs an arrangement induced by 12 arcs of great circles embedded in the sphere. The arrangement is depicted in <a class="el" href="index.html#fig__spherical_insert">Figure 34.37</a>.</p>
<p><a class="anchor" id="fig__spherical_insert"></a></p><div class="image">
<img src="spherical_insert.png" alt="spherical_insert.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__spherical_insert">Figure 34.37</a> An arrangement induced by 12 arcs of great circles, as constructed in <a class="el" href="Arrangement_on_surface_2_2spherical_insert_8cpp-example.html">Arrangement_on_surface_2/spherical_insert.cpp</a>. The number of vertices, edges, and faces of the arrangement is 7, 13, and 8, respectively. The intersection of the curve \((-1,0,0),(0,1,0)\) with the identification curve induces a vertex at \((\frac{-11}{\sqrt{11^2+7^2}},\frac{7}{\sqrt{11^2+7^2}},0)\) drawn in green. The north and south poles are drawn as little spheres. The identification curve is drawn as a gray tube.  </div> <br /> 
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2spherical_insert_8cpp-example.html">Arrangement_on_surface_2/spherical_insert.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Constructing an arrangement of arcs of great circles.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_on_surface_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_geodesic_arc_on_sphere_traits_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_spherical_topology_traits_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_print.h"</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">CGAL::Exact_predicates_exact_constructions_kernel</a>         Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__geodesic__arc__on__sphere__traits__2.html">CGAL::Arr_geodesic_arc_on_sphere_traits_2&lt;Kernel&gt;</a>         Geom_traits;</div><div class="line"><span class="keyword">typedef</span> Geom_traits::Point_2                                      Point;</div><div class="line"><span class="keyword">typedef</span> Geom_traits::Curve_2                                      Curve;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__spherical__topology__traits__2.html">CGAL::Arr_spherical_topology_traits_2&lt;Geom_traits&gt;</a>        Topol_traits;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__on__surface__2.html">CGAL::Arrangement_on_surface_2&lt;Geom_traits, Topol_traits&gt;</a> Arrangement;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <span class="comment">// Construct the arrangement from 12 geodesic arcs.</span></div><div class="line">  Geom_traits traits;</div><div class="line">  Arrangement arr(&amp;traits);</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> ctr_p = traits.construct_point_2_object();</div><div class="line">  <span class="keyword">auto</span> ctr_cv = traits.construct_curve_2_object();</div><div class="line"></div><div class="line">  <span class="comment">// Observe that the identification curve is a meridian that contains the</span></div><div class="line">  <span class="comment">// point (-11, 7, 0). The curve (-1,0,0),(0,1,0) intersects the identification</span></div><div class="line">  <span class="comment">// curve.</span></div><div class="line"></div><div class="line">  std::list&lt;Curve&gt; arcs;</div><div class="line"></div><div class="line">  arcs.push_back(ctr_cv(ctr_p(1, 0, 0), ctr_p(0, 0, -1)));</div><div class="line">  arcs.push_back(ctr_cv(ctr_p(1, 0, 0), ctr_p(0, 0, 1)));</div><div class="line">  arcs.push_back(ctr_cv(ctr_p(0, 1, 0), ctr_p(0, 0, -1)));</div><div class="line">  arcs.push_back(ctr_cv(ctr_p(0, 1, 0), ctr_p(0, 0, 1)));</div><div class="line">  arcs.push_back(ctr_cv(ctr_p(-1, 0, 0), ctr_p(0, 0, -1)));</div><div class="line">  arcs.push_back(ctr_cv(ctr_p(-1, 0, 0), ctr_p(0, 0, 1)));</div><div class="line">  arcs.push_back(ctr_cv(ctr_p(0, -1, 0), ctr_p(0, 0, -1)));</div><div class="line">  arcs.push_back(ctr_cv(ctr_p(0, -1, 0), ctr_p(0, 0, 1)));</div><div class="line">  arcs.push_back(ctr_cv(ctr_p(1, 0, 0), ctr_p(0, 1, 0)));</div><div class="line">  arcs.push_back(ctr_cv(ctr_p(1, 0, 0), ctr_p(0, -1, 0)));</div><div class="line">  arcs.push_back(ctr_cv(ctr_p(-1, 0, 0), ctr_p(0, 1, 0)));</div><div class="line">  arcs.push_back(ctr_cv(ctr_p(-1, 0, 0), ctr_p(0, -1, 0)));</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">CGAL::insert</a>(arr, arcs.begin(), arcs.end());</div><div class="line">  print_arrangement_size(arr);          <span class="comment">// print the arrangement size</span></div><div class="line">  <span class="comment">// print_arrangement(arr);</span></div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>Use the <code><a class="el" href="classCGAL_1_1Arr__geodesic__arc__on__sphere__traits__2_1_1Construct__point__2.html" title="Construction functor of a point. ">Arr_geodesic_arc_on_sphere_traits_2::Construct_point_2</a></code>, <code><a class="el" href="classCGAL_1_1Arr__geodesic__arc__on__sphere__traits__2_1_1Construct__x__monotone__curve__2.html" title="Construction functor of -monotone geodesic arcs. ">Arr_geodesic_arc_on_sphere_traits_2::Construct_x_monotone_curve_2</a></code>, and <code><a class="el" href="classCGAL_1_1Arr__geodesic__arc__on__sphere__traits__2_1_1Construct__curve__2.html" title="Construction functor of geodesic arcs. ">Arr_geodesic_arc_on_sphere_traits_2::Construct_curve_2</a></code> functors to construct a point, an \(X\)-monotone curve and a curve objects, respectively. Observe that an \(X\)-monotone curve cannot intersect the identification curve in its interior. A curve can be constructed from either (i) two endpoints, (ii) two endpoints and a normal, or (iii) a normal. The two endpoints determine the plane. The normal determines the orientation of the plane and the final arc (whether it is the minor arc or the major arc). If the normal is not provided, the minor arc is constructed. If a curve is constructed and only the normal is provided a full great circle is constructed. If an \(X\)-monotone curve is constructed and only the normal is provided an arc that resembles a full circle is constructed; this arc has one endpoint that lies on the identification curve; this point is considered both the source and target (and also the left and right) point of the arc. See <a class="el" href="index.html#fig__aos_fig-right_hand_rule">Figure 34.38</a> for an illustration of the right-hand rule, which depicts the relation between the arc and the normal.</p>
<p><a class="anchor" id="fig__aos_fig-right_hand_rule"></a></p><div class="image">
<img src="right_hand_rule.png" alt="right_hand_rule.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-right_hand_rule">Figure 34.38</a> To use the right hand rule, point your right thumb in the direction of the normal and curl your fingers in the direction of the arc starting with source endpoint and ending at the target endpoint.  </div> <br /> 
<h2><a class="anchor" id="arr_ssecmeta_tr"></a>
Traits-Class Decorators</h2>
<p>Geometric traits-class decorators allow you to attach auxiliary data to the geometric objects (curves and to points). The data is automatically manipulated by the decorators and distributed to the constructed geometric entities. Additional information can alternatively be maintained by extending the vertex, halfedge, or face types provided by the DCEL class used by the arrangement; see Section <a class="el" href="index.html#arr_ssecex_dcel">Extending the DCEL</a> for details. In many cases, however, it is convenient to attach the data to the curve itself, exploiting the automatic proliferation of the additional data fields from each curve to all its induced subcurves. Moreover, as two halfedges are associated with a single curve, storing the data once in the curve record either saves space or avoids an indirect access from one halfedge to its twin.</p>
<p>The <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgArrangementOnSurface2">2D Arrangements</a> package includes a traits-class decorator used to attach a data field to curves and to \(x\)-monotone curves. It is a class template named <code><a class="el" href="classCGAL_1_1Arr__curve__data__traits__2.html" title="The class Arr_curve_data_traits_2 is a model of the ArrangementTraits_2 concept and serves as a decor...">Arr_curve_data_traits_2</a>&lt;BaseTraits, XMonotoneCurveData, Merge, CurveData, Convert&gt;</code> parameterized by a base-traits class, which must be substituted with one of the geometric traits models described in the previous subsections or with a user-defined traits model, when the decorator is instantiated. The curve-data decorator derives from the base-traits class, and in particular inherits its <a class="el" href="classCGAL_1_1Arr__curve__data__traits__2.html#a77fe4ede82d2bb99f4212f0476e43d6d"><code>Point_2</code></a> type. The remaining nested types are defined as follows:</p>
<ul>
<li>
<p class="startli"><a class="el" href="classCGAL_1_1Arr__curve__data__traits__2_1_1Curve__2.html"><code>Curve_2</code></a> is derived from the basic <code>BaseTraits::Curve_2</code> class, extending it by an extra field of type <code>CurveData</code>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="classCGAL_1_1Arr__curve__data__traits__2_1_1X__monotone__curve__2.html"><code>X_monotone_curve_2</code></a> is derived from the basic <code>BaseTraits::X_monotone_curve_2</code> class, extending it by an extra field of type <code>XMonotoneCurveData</code>, which must model the concepts <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classCopyConstructible.html">CopyConstructible</a>, <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classEqualityComparable.html">EqualityComparable</a>, and <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classDefaultConstructible.html">DefaultConstructible</a>. The latter ensures that every instance of the class template <code><a class="el" href="classCGAL_1_1Arr__curve__data__traits__2.html" title="The class Arr_curve_data_traits_2 is a model of the ArrangementTraits_2 concept and serves as a decor...">Arr_curve_data_traits_2</a></code> obtained by substituting the <code>BaseTraits</code> template parameter with a model of the <code><a class="el" href="classArrangementLandmarkTraits__2.html" title="The concept ArrangementLandmarkTraits_2 refines the traits concepts ArrangementApproximateTraits_2 an...">ArrangementLandmarkTraits_2</a></code> concept models the ArrangementLandmarkTraits_2` concept as well</p>
<p class="endli"></p>
</li>
</ul>
<p>Note that the nested <a class="el" href="classCGAL_1_1Arr__curve__data__traits__2_1_1Curve__2.html"><code>Curve_2</code></a> and <a class="el" href="classCGAL_1_1Arr__curve__data__traits__2_1_1X__monotone__curve__2.html"><code>X_monotone_curve_2</code></a> are not the same, even if the <code>BaseTraits::Curve_2</code> and <code>BaseTraits::X_monotone_curve_2</code> are (as in the case of the segment-traits class, for example). The extended curve types support the additional methods <a class="el" href="classCGAL_1_1Arr__curve__data__traits__2.html">&lt;Tr, XData, Mrg, CData, Cnv&gt;::Curve_2::data() <code>data()</code></a> and <a class="el" href="classCGAL_1_1Arr__curve__data__traits__2.html">&lt;Tr, XData, Mrg, CData, Cnv&gt;::Curve_2::set_data() <code>set_data()</code></a> for accessing and modifying the data field.</p>
<p>You can create an extended curve (or an extended \(x\)-monotone curve) from a basic curve and a curve-data object. When curves are inserted into an arrangement, they may be split, and the decorator handles their data fields automatically as follows:</p>
<ul>
<li>
<p class="startli">When a curve is subdivided into \(x\)-monotone subcurves, its data field of type <code>CurveData</code> is converted to an object of type <code>XMonotoneCurveData</code> using the <code>Convert</code> functor. The object is automatically associated with each of the resulting \(x\)-monotone subcurves.</p>
<p>Note that by default, the <code>CurveData</code> type is identical to the <code>XMonotoneCurveData</code> type (and the conversion functor <code>Convert</code> is trivially defined). Thus, the data field associated with the original curve is just duplicated and stored with the \(x\)-monotone subcurves.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">When an \(x\)-monotone curve is split into two (typically, when it intersects another curve), the decorator class automatically copies its data field to both resulting subcurves.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">When two \(x\)-monotone curves, \(c_1\) and \(c_2\), intersect, the result may include overlapping sections represented as \(x\)-monotone curves. In this case the data fields of \(c_1\) and \(c_2\) are merged into a single <code>XMonotoneCurveData</code> object using the <code>Merge</code> functor, which is supplied as a parameter to the traits class-template. The resulting object is assigned to the data field of the overlapping subcurves.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Merging two \(x\)-monotone curves is allowed only when (i) the two curves are geometrically mergeable—that is, the base-traits class allows to merge them, and (ii) the two curves store the same data field.</p>
<p class="endli"></p>
</li>
</ul>
<p>Another decorator supported by the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgArrangementOnSurface2">2D Arrangements</a> package is the <code><a class="el" href="classCGAL_1_1Arr__consolidated__curve__data__traits__2.html" title="The class Arr_consolidated_curve_data_traits_2 is a model of the concept ArrangementTraits_2, and serves as a decorator class that enables the extension of the curve type defined by the Traits parameter. ">Arr_consolidated_curve_data_traits_2</a>&lt;BaseTraits, Data&gt;</code> class template. It derives from the <code><a class="el" href="classCGAL_1_1Arr__curve__data__traits__2.html" title="The class Arr_curve_data_traits_2 is a model of the ArrangementTraits_2 concept and serves as a decor...">Arr_curve_data_traits_2</a></code> class template, and it extends the basic type <code>BaseTraits::Curve_2</code> by a single <code>Data</code> field, and the basic <code>BaseTraits::X_monotone_curve_2</code> with a <em>set</em> of (distinct) data objects. The <code>Data</code> type must model the concept <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classEqualityComparable.html">EqualityComparable</a></code> to ensure that each set contains only distinct data objects with no duplicates. When a curve with a data field \(d\) is subdivided into \(x\)-monotone subcurves, each subcurve is associated with a set \(S = \{d\}\). In the case of an overlap between two \(x\)-monotone curves \(c_1\) and \(c_2\) with associated data sets \(S_1\) and \(S_2\), respectively, the overlapping subcurve is associated with the consolidated set \(S_1 \cup S_2\).</p>
<p><a class="anchor" id="fig__aos_fig-consolidated_curve_data"></a></p><div class="image">
<img src="consolidated_curve_data.png" alt="consolidated_curve_data.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-consolidated_curve_data">Figure 34.39</a> An arrangement of six red and blue segments, as constructed in <a class="el" href="Arrangement_on_surface_2_2consolidated_curve_data_8cpp-example.html">Arrangement_on_surface_2/consolidated_curve_data.cpp</a>. Disks correspond to red-blue intersection points, while circles mark the endpoints of red-blue overlaps.  </div> <br /> 
<p>The following example uses <code><a class="el" href="classCGAL_1_1Arr__segment__traits__2.html" title="The traits class Arr_segment_traits_2 is a model of the ArrangementTraits_2 concept, which allows the construction and maintenance of arrangements of line segments. ">Arr_segment_traits_2</a></code> as the base-traits class, attaching an additional <em>color</em> field to the segments using the consolidated curve-data traits class. A color may be either <em>blue</em> or <em>red</em>. Having constructed the arrangement of colored segments, as depicted in <a class="el" href="index.html#fig__aos_fig-consolidated_curve_data">Figure 34.39</a>, we detect the vertices that have incident edges mapped to both blue and red segments. These vertices, drawn as black discs in the figure, correspond to red-blue intersection points. We also locate the edge that corresponds to overlap between a red and a blue line segment (its endpoints are also drawn as black discs)</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2consolidated_curve_data_8cpp-example.html">Arrangement_on_surface_2/consolidated_curve_data.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Associating a color attribute with segments using the consolidated</span></div><div class="line"><span class="comment">// curve-data traits.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_consolidated_curve_data_traits_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_exact_construction_segments.h"</span></div><div class="line"></div><div class="line"><span class="keyword">enum</span> Segment_color {RED, BLUE};</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__consolidated__curve__data__traits__2.html">CGAL::Arr_consolidated_curve_data_traits_2&lt;Traits, Segment_color&gt;</a></div><div class="line">                                                           Data_traits;</div><div class="line"><span class="keyword">typedef</span> Data_traits::Curve_2                               Colored_segment;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Data_traits&gt;</a>                   Colored_arr;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  Colored_arr arr;</div><div class="line"></div><div class="line">  <span class="comment">// Construct an arrangement containing three RED line segments.</span></div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Colored_segment(Segment(Point(-1, -1), Point(1, 3)), RED));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Colored_segment(Segment(Point(2, 0), Point(3, 3)), RED));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Colored_segment(Segment(Point(0, 3), Point(2, 5)), RED));</div><div class="line"></div><div class="line">  <span class="comment">// Insert three BLUE line segments.</span></div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Colored_segment(Segment(Point(-1, 3), Point(4, 1)), BLUE));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Colored_segment(Segment(Point(-1, 0), Point(4, 1)), BLUE));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Colored_segment(Segment(Point(-2, 1), Point(1, 4)), BLUE));</div><div class="line"></div><div class="line">  <span class="comment">// Go over all vertices and print just the ones corresponding to intersection</span></div><div class="line">  <span class="comment">// points between RED segments and BLUE segments. Skip endpoints of</span></div><div class="line">  <span class="comment">// overlapping sections.</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> vit = arr.vertices_begin(); vit != arr.vertices_end(); ++vit) {</div><div class="line">    <span class="comment">// Go over the current-vertex incident-halfedges and examine their colors.</span></div><div class="line">    <span class="keywordtype">bool</span>       has_red = <span class="keyword">false</span>, has_blue = <span class="keyword">false</span>;</div><div class="line">    Colored_arr::Halfedge_around_vertex_const_circulator eit, first;</div><div class="line">    eit = first = vit-&gt;incident_halfedges();</div><div class="line">    <span class="keywordflow">do</span> {</div><div class="line">      <span class="comment">// Get the color of the current halfedge.</span></div><div class="line">      <span class="keywordflow">if</span> (eit-&gt;curve().data().size() == 1) {</div><div class="line">        Segment_color color = eit-&gt;curve().data().front();</div><div class="line">        <span class="keywordflow">if</span> (color == RED)       has_red = <span class="keyword">true</span>;</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (color == BLUE) has_blue = <span class="keyword">true</span>;</div><div class="line">      }</div><div class="line">    } <span class="keywordflow">while</span> (++eit != first);</div><div class="line"></div><div class="line">    <span class="comment">// Print the vertex only if incident RED and BLUE edges were found.</span></div><div class="line">    <span class="keywordflow">if</span> (has_red &amp;&amp; has_blue) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">"Red intersect blue at ("</span> &lt;&lt; vit-&gt;point() &lt;&lt; <span class="stringliteral">")\n"</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Locate the edges that correspond to a red-blue overlap.</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> eit = arr.edges_begin(); eit != arr.edges_end(); ++eit) {</div><div class="line">    <span class="comment">// Go over the incident edges of the current vertex and examine their colors.</span></div><div class="line">    <span class="keywordtype">bool</span> has_red{<span class="keyword">false</span>}, has_blue{<span class="keyword">false</span>};</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = eit-&gt;curve().data().begin(); it != eit-&gt;curve().data().end();</div><div class="line">         ++it)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (*it == RED) has_red = <span class="keyword">true</span>;</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*it == BLUE) has_blue = <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Print the edge only if it corresponds to a red-blue overlap.</span></div><div class="line">    <span class="keywordflow">if</span> (has_red &amp;&amp; has_blue)</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">"Red overlap blue at ["</span> &lt;&lt; eit-&gt;curve() &lt;&lt; <span class="stringliteral">"]\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="fig__aos_fig-generic_curve_data"></a></p><div class="image">
<img src="generic_curve_data.png" alt="generic_curve_data.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-generic_curve_data">Figure 34.40</a> An arrangement of four polylines, named A-D, as constructed in <a class="el" href="Arrangement_on_surface_2_2generic_curve_data_8cpp-example.html">Arrangement_on_surface_2/generic_curve_data.cpp</a>.  </div> <br /> 
<p>The following example uses <code><a class="el" href="classCGAL_1_1Arr__polyline__traits__2.html" title="The traits class Arr_polyline_traits_2 handles piecewise linear curves, commonly referred to as polyl...">Arr_polyline_traits_2</a></code> as the base-traits class, attaching an additional <em>name</em> field to each polyline using the generic curve-data traits class. It constructs an arrangement of four polylines, named \(A\), \(B\), \(c\), and \(D\), as illustrated in <a class="el" href="index.html#fig__aos_fig-generic_curve_data">Figure 34.40</a>. In the case of overlaps, it simply concatenate the names of the overlapping polylines. At the end of the program the curve associated with the edges that correspond to overlapping polylines are replaced with geometrically equivalent curves, but with different data fields.</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2generic_curve_data_8cpp-example.html">Arrangement_on_surface_2/generic_curve_data.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Associating a name attribute with segments using the generic curve-data</span></div><div class="line"><span class="comment">// traits.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_curve_data_traits_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_polylines.h"</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::string Name;               <span class="comment">// The name-field type.</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>Merge_names {</div><div class="line">  Name operator() (<span class="keyword">const</span> Name&amp; s1, <span class="keyword">const</span> Name&amp; s2)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{ <span class="keywordflow">return</span> (s1 + <span class="stringliteral">" "</span> + s2); }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__curve__data__traits__2.html">CGAL::Arr_curve_data_traits_2&lt;Traits, Name, Merge_names&gt;</a></div><div class="line">                                                    Ex_traits;</div><div class="line"><span class="keyword">typedef</span> Ex_traits::Curve_2                          Ex_polyline;</div><div class="line"><span class="keyword">typedef</span> Ex_traits::X_monotone_curve_2               Ex_x_monotone_polyline;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Ex_traits&gt;</a>              Ex_arrangement;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <span class="comment">// Construct an arrangement of four polylines named A--D.</span></div><div class="line">  Ex_traits traits;</div><div class="line">  Ex_arrangement arr(&amp;traits);</div><div class="line">  <span class="keyword">auto</span> ctr_curve = traits.construct_curve_2_object();</div><div class="line"></div><div class="line">  Point pts1[5] =</div><div class="line">    {Point(0, 0), Point(2, 4), Point(3, 3), Point(4, 4), Point(6, 0)};</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Ex_polyline(ctr_curve(pts1, pts1 + 5), <span class="stringliteral">"A"</span>));</div><div class="line"></div><div class="line">  Point pts2[3] = {Point(1, 5), Point(3, 3), Point(5, 5)};</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Ex_polyline(ctr_curve(pts2, pts2 + 3), <span class="stringliteral">"B"</span>));</div><div class="line"></div><div class="line">  Point pts3[4] = {Point(1, 0), Point(2, 2), Point(4, 2), Point(5, 0)};</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Ex_polyline(ctr_curve(pts3, pts3 + 4), <span class="stringliteral">"C"</span>));</div><div class="line"></div><div class="line">  Point pts4[2] = {Point(0, 2), Point(6, 2)};</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Ex_polyline(ctr_curve(pts4, pts4 + 2), <span class="stringliteral">"D"</span>));</div><div class="line"></div><div class="line">  <span class="comment">// Print all edges that correspond to an overlapping polyline.</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The overlapping subcurves:\n"</span>;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> eit = arr.edges_begin(); eit != arr.edges_end(); ++eit) {</div><div class="line">    <span class="keywordflow">if</span> (eit-&gt;curve().data().length() &gt; 1) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">"  ["</span> &lt;&lt; eit-&gt;curve() &lt;&lt; <span class="stringliteral">"]  "</span></div><div class="line">                &lt;&lt; <span class="stringliteral">"named: "</span> &lt;&lt; eit-&gt;curve().data() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="comment">// Modify the curve associated with the edge.</span></div><div class="line">      arr.modify_edge(eit, Ex_x_monotone_polyline(eit-&gt;curve(), <span class="stringliteral">"overlap"</span>));</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>The third example we give in this section is based on <a class="el" href="Arrangement_on_surface_2_2dual_lines_8cpp-example.html">Arrangement_on_surface_2/dual_lines.cpp</a> given in Section <a class="el" href="index.html#arr_ssec-unb_duality">Point-Line Duality</a>. It constructs the arrangement of the dual lines for a set of point given in an input file (by default we use <code>coll_points.dat</code>, which contains \(50\) points randomly selected on the grid \([-100,100]\times[-100,100]\); the file contains two distinct triplets of collinear points). Here we use the generic curve-data decorator to attach the index of the primal point to each of the lines. Doing so, we can go over the incident edges of each vertex whose degree is greater than \(4\) and report the subsets of collinear points (if we have a vertex of degree \(d\), we actually need to go over \(\frac{d}{2}\) edges, as each incident line contributes exactly \(2\) edges). Note that in this case the dual line cannot overlap, so we use a dummy merge functor to instantiate the curve-data traits:</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2dual_with_data_8cpp-example.html">Arrangement_on_surface_2/dual_with_data.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Checking whether there are three collinear points in a given input set</span></div><div class="line"><span class="comment">// using the arrangement of the dual lines.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_curve_data_traits_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_linear.h"</span></div><div class="line"><span class="preprocessor">#include "read_objects.h"</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__curve__data__traits__2.html">CGAL::Arr_curve_data_traits_2&lt;Traits, size_t&gt;</a>   Data_traits;</div><div class="line"><span class="keyword">typedef</span> Data_traits::X_monotone_curve_2                 Data_x_monotone_curve_2;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Data_traits&gt;</a>                Data_arrangement;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[]) {</div><div class="line">  <span class="comment">// Get the name of the input file from the command line, or use the default</span></div><div class="line">  <span class="comment">// points.dat file if no command-line parameters are given.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename = (argc &gt; 1) ? argv[1] : <span class="stringliteral">"coll_points.dat"</span>;</div><div class="line"></div><div class="line">  std::vector&lt;Point&gt; points;</div><div class="line">  read_objects&lt;Point&gt;(filename, std::back_inserter(points));</div><div class="line">  std::vector&lt;Data_x_monotone_curve_2&gt; dual_lines(points.size());</div><div class="line">  <span class="keywordtype">size_t</span> k{0};</div><div class="line">  std::transform(points.begin(), points.end(), dual_lines.begin(),</div><div class="line">                 [&amp;](<span class="keyword">const</span> Point&amp; p) {</div><div class="line">                   Line dual_line(p.x(), -1, -(p.y()));</div><div class="line">                   <span class="keywordflow">return</span> Data_x_monotone_curve_2(dual_line, k++);</div><div class="line">                 });</div><div class="line"></div><div class="line">  <span class="comment">// Construct the dual arrangement by aggregately inserting the lines.</span></div><div class="line">  Data_arrangement arr;</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, dual_lines.begin(), dual_lines.end());</div><div class="line"></div><div class="line">  <span class="comment">// Look for vertices whose degree is greater than 4.</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> vit = arr.vertices_begin(); vit != arr.vertices_end(); ++vit) {</div><div class="line">    <span class="keywordflow">if</span> (vit-&gt;degree() &gt; 4) {</div><div class="line">      <span class="comment">// There should be vit-&gt;degree()/2 lines intersecting at the current</span></div><div class="line">      <span class="comment">// vertex. We print their primal points and their indices.</span></div><div class="line">      <span class="keyword">auto</span> circ = vit-&gt;incident_halfedges();</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> d = 0; d &lt; vit-&gt;degree() / 2; ++d) {</div><div class="line">        k = circ-&gt;curve().data();     <span class="comment">// The index of the primal point.</span></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">"Point no. "</span> &lt;&lt; k+1 &lt;&lt; <span class="stringliteral">": ("</span> &lt;&lt; points[k] &lt;&lt; <span class="stringliteral">"), "</span>;</div><div class="line">        ++circ;</div><div class="line">      }</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">"are collinear.\n"</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="aos_sec-topol_traits"></a>
The Topology Traits</h1>
<p>A topology traits class encapsulates the definitions of the topological entities and the implementation of the functions that handle these topological entities, used by the <code><a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html">Arrangement_on_surface_2</a>&lt;GeometryTraits_2, TopologyTraits&gt;</code> class template and by the peripheral modules. Every topology traits class must model the basic concept <code><a class="el" href="classArrangementBasicTopologyTraits.html" title="The concept ArrangementBasicTopologyTraits defines the minimal functionality needed for a model of a ...">ArrangementBasicTopologyTraits</a></code>. A model of this basic concept holds the (DCEL) data structure used to represent the arrangement cells (i.e., vertices, edges, and facets) and the incidence relations between them. At this point we do not expose the concepts that refine the basic concept. The package contains one topology traits, namely, <code><a class="el" href="classCGAL_1_1Arr__spherical__topology__traits__2.html">Arr_spherical_topology_traits_2</a></code>. It can serve as a topology traits for an arrangement embedded on a sphere. More precisely, for an arrangement embedded on a sphere defined over a parameter space, the left and right boundary sides of which are identified, and the top and bottom boundary sides are contracted.</p>
<h1><a class="anchor" id="arr_sec_extending"></a>
Extending the Arrangement</h1>
<p>Developing applications that use arrangements to solve problems that are a bit more complicated than the problems presented in previous chapters requires the ability to adapt the arrangement data structure to the application needs. One technique to do this is to extend the arrangement with auxiliary, usually non-geometric, data. In this chapter we describe several ways to extend an arrangement data structure.</p>
<h2><a class="anchor" id="arr_ssecnotif"></a>
The Notification Mechanism</h2>
<p>In some cases it is essential to know exactly what happens inside a specific arrangement object. For example, when a new curve is inserted into an arrangement, it may be necessary to keep track of the faces that are split due to this insertion operation. Other important examples are the point-location strategies that require auxiliary data structures (see Section <a class="el" href="index.html#arr_ssecpl">Point-Location Queries</a>), which must be kept up-to-date when the arrangement changes. The <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgArrangementOnSurface2">2D Arrangements</a> package offers a mechanism that uses <em>observers</em> (see <a class="el" href="citelist.html#CITEREF_cgal:ghjv-dpero-95">[7]</a>). The objective behind this mechanism is to define a one-to-many dependency between objects, so that when one object changes state, all its dependents are notified and updated automatically. The observed object does not know anything about the observers. It merely "publishes" information about changes when they occur. In our case observers can be attached to an arrangement object. An attached observer receives notifications about the changes this arrangement undergoes.</p>
<p>An observer object, the type of which is an instance of the <code><a class="el" href="classCGAL_1_1Arr__observer.html">Arr_observer</a>&lt;Arrangement&gt;</code> class template, stores a pointer to an arrangement object. When the <code><a class="el" href="classCGAL_1_1Arr__observer.html">Arr_observer</a>&lt;Arrangement&gt;</code> class template is instantiated, the <code>Arrangement</code> parameter must be substituted with the type of the arrangement object. The observer receives notifications <em>just before</em> a structural change occurs in the arrangement and <em>immediately after</em> such a change takes place. <code><a class="el" href="classCGAL_1_1Arr__observer.html">Arr_observer</a></code> serves as a base class for other observer classes and defines a set of virtual notification functions, with default empty implementations. The set of functions can be divided into three categories, as follows:</p>
<ol>
<li>
<p class="startli">Notifiers of changes that affect the entire topological structure of the arrangement. This category consists of two pairs (<em>before</em> and <em>after</em>) that notify the observer of the following changes:</p>
<ul>
<li>
The arrangement is cleared. </li>
<li>
The arrangement is assigned with the contents of another arrangement. </li>
</ul>
<p class="endli"></p>
</li>
<li>
<p class="startli">Pairs of notifiers before and after a local change that occurs in the topological structure. Most notifier functions belong to this category. The relevant local changes include:</p>
<ul>
<li>
<p class="startli">A new vertex is constructed and associated with a point.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">An edge<span class="footnote">The term "edge" refers here to a pair of twin halfedges.</span> is constructed and associated with an \(x\)-monotone curve.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">An edge is split into two edges.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">An existing face is split into two faces, as a consequence of the insertion of a new edge.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">A hole is created in the interior of a face.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Two holes are merged to form a single hole, as a consequence of the insertion of a new edge.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">A hole is moved from one face to another, as a consequence of a face split.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Two edges are merged into one edge.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Two faces are merged into one face, as a consequence of the removal of an edge that used to separate them.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">One hole is split into two, as a consequence of the deletion of an edge that used to connect the two components.</p>
<p class="endli"></p>
</li>
<li>
A vertex is removed. </li>
<li>
An edge is removed. </li>
<li>
<p class="startli">A hole is deleted from the interior of a face.</p>
<p class="endli"></p>
</li>
</ul>
<p class="endli"></p>
</li>
<li>
<p class="startli">Notifiers about a change caused by a free function; see Section <a class="el" href="index.html#arr_secgl_funcs">Free Functions</a> for a discussion on the free functions. This category consists of a single pair of notifiers, namely <code>before_global_change()</code> and <code>after_global_change()</code>. Neither of these functions is invoked by methods of the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> class template. Instead, they are called by the free functions themselves. It is implied that no point-location queries (or any other queries for that matter) are issued between the call to <code>before_global_change()</code> and the call to <code>after_global_change()</code>.</p>
<p class="endli"></p>
</li>
</ol>
<p>See the Reference Manual for a detailed specification of the <code><a class="el" href="classCGAL_1_1Arr__observer.html">Arr_observer</a></code> class template and the prototypes of all notification functions.</p>
<p>Each arrangement object stores a list of pointers to <code><a class="el" href="classCGAL_1_1Arr__observer.html">Arr_observer</a></code> objects. This list may be empty, in which case the arrangement does not have to notify any external class on the structural changes it undergoes. If, however, there are observers associated with the arrangement object, then whenever one of the structural changes listed in the first two categories above is about to take place, the arrangement object performs a <em>forward</em> traversal on this list and invokes the appropriate function of each observer. After the change takes place the observer list is traversed <em>backward</em> (from tail to head), and the appropriate notification function is invoked for each observer.</p>
<p>Concrete arrangement-observer classes should inherit from <code><a class="el" href="classCGAL_1_1Arr__observer.html">Arr_observer</a></code>. When an observer is constructed, it is attached to a valid arrangement supplied to the observed constructor, or alternatively the observer can be attached to the arrangement at a later time. When this happens, the observer object inserts itself into the observer list of the associated arrangement and starts receiving notifications whenever this arrangement changes thereafter. Subsequently, the observer object unregisters itself by removing itself from this list just before it is destroyed. Most concrete observer-classes do not need to use the full set of notifications. Thus, the bodies of all notification methods defined in the base class <code><a class="el" href="classCGAL_1_1Arr__observer.html">Arr_observer</a></code> are empty. A concrete observer that inherits from <code><a class="el" href="classCGAL_1_1Arr__observer.html">Arr_observer</a></code> needs to override only the relevant notification methods. The remaining methods are invoked when corresponding changes occur, but they do nothing.</p>
<p>The trapezoidal map RIC and the landmark point-location strategies both use observers to keep their auxiliary data structures up-to-date. In addition, you can define your own observer classes, inheriting from the base observer class and overriding the relevant notification functions, as required by their applications.</p>
<p><a class="anchor" id="fig__aos_fig-observer"></a></p><div class="image">
<img src="observer.png" alt="observer.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-observer">Figure 34.41</a> An arrangement of six line segments, as constructed in <a class="el" href="Arrangement_on_surface_2_2observer_8cpp-example.html">Arrangement_on_surface_2/observer.cpp</a>. The halfedge \(e_v\) (dashed) is eventually removed, so that the final arrangement consists of four faces (one unbounded and three bounded ones).  </div> <br /> 
<p>The following example shows how to define and use an observer class. The observer in the example responds to changes in the arrangement faces. It prints a message whenever a face is split into two due to the insertion of an edge and whenever two faces merge into one due to the removal of an edge. The layout of the arrangement is depicted in <a class="el" href="index.html#fig__aos_fig-observer">Figure 34.41</a>; it comprises six line segments and eight edges (the horizontal segment \(s_h\) and the vertical segment \(s_v\) induce two edges each). The halfedge \(e_v\) is induced by the vertical segment \(s_v\). First, it is associated with the (entire) segment, as obtained by the <code><a class="el" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94" title="% inserts one or more curves or -monotone curves into a given arrangement, where no restrictions are ...">insert()</a></code> function; see Line 40 in the code excerpt below. After the insertion of \(s_h\) (see Line 41) the halfedge is split. After the split \(e_v\) (drawn dashed in the figure) is associated with the lower split curve. Eventually, it is removed (along with its twin halfedge). Note the face-split notifications that are invoked as a consequence of the insertion of \(s_v\) and \(s_h\) and the face-merge notification that is invoked as a consequent of the removal of \(e_v\).</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2observer_8cpp-example.html">Arrangement_on_surface_2/observer.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Using a simple arrangement observer.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_observer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_exact_construction_segments.h"</span></div><div class="line"><span class="preprocessor">#include "arr_print.h"</span></div><div class="line"></div><div class="line"><span class="comment">// An observer that receives notifications of face splits and face mergers.</span></div><div class="line"><span class="keyword">class </span>My_observer : <span class="keyword">public</span> <a class="code" href="classCGAL_1_1Arr__observer.html">CGAL::Arr_observer</a>&lt;Arrangement&gt; {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  My_observer(Arrangement&amp; arr) : <a class="code" href="namespaceCGAL.html">CGAL</a>::Arr_observer&lt;Arrangement&gt;(arr) {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> before_split_face(Face_handle, Halfedge_handle e) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"-&gt; The insertion of :  [ "</span> &lt;&lt; e-&gt;curve()</div><div class="line">              &lt;&lt; <span class="stringliteral">" ]  causes a face to split.\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> before_merge_face(Face_handle, Face_handle, Halfedge_handle e) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"-&gt; The removal of :  [ "</span> &lt;&lt; e-&gt;curve()</div><div class="line">              &lt;&lt; <span class="stringliteral">" ]  causes two faces to merge.\n"</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <span class="comment">// Construct the arrangement containing one diamond-shaped face.</span></div><div class="line">  Arrangement arr;</div><div class="line">  My_observer obs(arr);</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr, Segment(Point(-1, 0), Point(0, 1)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr, Segment(Point(0, 1), Point(1, 0)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr, Segment(Point(1, 0), Point(0, -1)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr, Segment(Point(0, -1), Point(-1, 0)));</div><div class="line"></div><div class="line">  <span class="comment">// Insert a vertical segment dividing the diamond into two, and a</span></div><div class="line">  <span class="comment">// a horizontal segment further dividing the diamond into four.</span></div><div class="line">  Segment s_v(Point(0, -1), Point(0, 1));</div><div class="line">  Halfedge_handle e_v = <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr, s_v);</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Segment(Point(-1, 0), Point(1, 0))); <span class="comment">/* \label{lst:observer:insertion} */</span></div><div class="line">  print_arrangement_size(arr);</div><div class="line"></div><div class="line">  <span class="comment">// Now remove a portion of the vertical segment.</span></div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#ga324fdf8354e7812fe0e1c0e5ac14196c">remove_edge</a>(arr, e_v);            <span class="comment">// the observer will make a notification</span></div><div class="line">  print_arrangement_size(arr);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>Observers are especially useful when the DCEL records are extended and store additional data-fields, since they help update this data stored in these fields, as the following sections reveal.</p>
<h2><a class="anchor" id="arr_ssecex_dcel"></a>
Extending the DCEL</h2>
<p>For many applications of the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgArrangementOnSurface2">2D Arrangements</a> package it is necessary to store additional information (perhaps of non-geometric nature) with the arrangement features. Vertices are associated with <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#aed833c3b69b94eae54994439d70a83a2"><code>Point_2</code></a> objects and edges (halfedge pairs) are associated with <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#ad7f12c4c83fa1d83a3f0d5ceb16c21e1"><code>X_monotone_curve_2</code></a> objects, both defined by the traits class. Extending the geometric traits-class types by using a traits-class decorator, as explained in Section <a class="el" href="index.html#arr_ssecmeta_tr">Traits-Class Decorators</a>, might be a sufficient solution for some applications. However, the DCEL faces are not associated with any geometric object, so traits-class decorators cannot help here. Extending the DCEL face records comes in handy is such cases. As a matter of fact, it is possible to conveniently extend all DCEL records (namely vertices, halfedges, and faces), which is advantageous for some applications.</p>
<p>All examples presented so far use the default DCEL; namely, they employ the <code><a class="el" href="classCGAL_1_1Arr__default__dcel.html" title="The default DCEL class used by the Arrangement_2 class-template is parameterized by a traits class...">Arr_default_dcel</a>&lt;Traits&gt;</code> instance. This is done implicitly, as an instance of this class template serves as the default parameter for the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> class template; see Section <a class="el" href="index.html#aos_ssec-basic-arr_class">The Arrangement Class Template</a>. The default DCEL class associates points with vertices and \(x\)-monotone curves with halfedges, but nothing more. In this section we show how to use alternative DCEL types to extend the desired DCEL records.</p>
<h3><a class="anchor" id="arr_sssecex_dcel_face"></a>
Extending the DCEL Faces</h3>
<p>The <code><a class="el" href="classCGAL_1_1Arr__face__extended__dcel.html" title="The Arr_face_extended_dcel class-template extends the DCEL face-records, making it possible to store ...">Arr_face_extended_dcel</a>&lt;Traits, FaceData&gt;</code> class-template is used to associate auxiliary data field of type <code>FaceData</code> to each face record in the DCEL. When the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt;Traits,Dcel&gt;</code> class template is instantiated, substituting the DCEL parameter with an instance of this class template, the interface of the nested <code>Face</code> type is extended with the access function <code>data()</code> and with the modifier <code>set_data()</code>. Using these extra functions it is straightforward to access and maintain the auxiliary face-data field.</p>
<p>Note that the extra data-fields must be maintained by the user application. User may choose to construct their arrangement, and may only then go over the faces and store data in the appropriate data-fields of the arrangement faces. However, in some cases the face data can only be computed when the face is created (split from another face or merged with another face). In such cases one can use an arrangement observer tailored for this task, which receives updates whenever a face is modified and sets its data field accordingly.</p>
<p><a class="anchor" id="fig__aos_fig-dcel_extension"></a></p><div class="image">
<img src="dcel_extension.png" alt="dcel_extension.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-dcel_extension">Figure 34.42</a> An arrangement of six line segments, as constructed in <a class="el" href="Arrangement_on_surface_2_2face_extension_8cpp-example.html">Arrangement_on_surface_2/face_extension.cpp</a> and <a class="el" href="Arrangement_on_surface_2_2dcel_extension_8cpp-example.html">Arrangement_on_surface_2/dcel_extension.cpp</a> (in <a class="el" href="Arrangement_on_surface_2_2dcel_extension_8cpp-example.html">Arrangement_on_surface_2/dcel_extension.cpp</a> we treat the segments as directed, so they are drawn as arrows directed from the source to the target). The indices associated with the halfedges in <a class="el" href="Arrangement_on_surface_2_2face_extension_8cpp-example.html">Arrangement_on_surface_2/face_extension.cpp</a> are shown in brackets.  </div> <br /> 
<p>The next example constructs an arrangement that contains seven bounded faces induced by six line segments, \(s_1, \ldots, s_6\), as shown in <a class="el" href="index.html#fig__aos_fig-dcel_extension">Figure 34.42</a>. An observer gets notified each time a new face \(f\) is created, and it associates \(f\) with a running index, where the index of the unbounded face is 0. As a result, the faces are numbered according to their creation order, These numbers are shown in brackets, and their order can easily be verified by examining the insertion order of the segments.<span class="footnote">For simplicity, the particular observer used must be attached to an empty arrangement. It is not difficult however to modify the program to handle the general case of attaching a similar observer to a non-empty arrangement.</span></p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2face_extension_8cpp-example.html">Arrangement_on_surface_2/face_extension.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Extending the arrangement-face records.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_extended_dcel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_observer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_exact_construction_segments.h"</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__face__extended__dcel.html">CGAL::Arr_face_extended_dcel&lt;Traits, size_t&gt;</a>       Dcel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits, Dcel&gt;</a>                  Ex_arrangement;</div><div class="line"></div><div class="line"><span class="comment">// An arrangement observer, used to receive notifications of face splits and</span></div><div class="line"><span class="comment">// to update the indices of the newly created faces.</span></div><div class="line"><span class="keyword">class </span>Face_index_observer : <span class="keyword">public</span> <a class="code" href="classCGAL_1_1Arr__observer.html">CGAL::Arr_observer</a>&lt;Ex_arrangement&gt; {</div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">size_t</span> n_faces;                       <span class="comment">// the current number of faces</span></div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Face_index_observer(Ex_arrangement&amp; arr) :</div><div class="line">    <a class="code" href="namespaceCGAL.html">CGAL</a>::Arr_observer&lt;Ex_arrangement&gt;(arr), n_faces(0)</div><div class="line">  {</div><div class="line">    CGAL_precondition (arr.is_empty());</div><div class="line">    arr.unbounded_face()-&gt;set_data (0);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> after_split_face(Face_handle, Face_handle new_face, <span class="keywordtype">bool</span>)</div><div class="line">  {</div><div class="line">    new_face-&gt;set_data(++n_faces);        <span class="comment">// assign index to the new face</span></div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <span class="comment">// Construct the arrangement containing two intersecting triangles.</span></div><div class="line">  Ex_arrangement arr;</div><div class="line">  Face_index_observer obs(arr);</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr, Segment(Point(4, 1), Point(7, 6)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr, Segment(Point(1, 6), Point(7, 6)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr, Segment(Point(4, 1), Point(1, 6)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Segment(Point(1, 3), Point(7, 3)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Segment(Point(1, 3), Point(4, 8)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Segment(Point(4, 8), Point(7, 3)));</div><div class="line"></div><div class="line">  <span class="comment">// Go over all arrangement faces and print the index of each face and its</span></div><div class="line">  <span class="comment">// outer boundary. The face index is stored in the data field.</span></div><div class="line">  std::cout &lt;&lt; arr.number_of_faces() &lt;&lt; <span class="stringliteral">" faces:\n"</span>;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> fit = arr.faces_begin(); fit != arr.faces_end(); ++fit) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Face no. "</span> &lt;&lt; fit-&gt;data() &lt;&lt; <span class="stringliteral">": "</span>;</div><div class="line">    <span class="keywordflow">if</span> (fit-&gt;is_unbounded()) std::cout &lt;&lt; <span class="stringliteral">"Unbounded.\n"</span>;</div><div class="line">    <span class="keywordflow">else</span> {</div><div class="line">      <span class="keyword">auto</span> curr = fit-&gt;outer_ccb();</div><div class="line">      std::cout &lt;&lt; curr-&gt;source()-&gt;point();</div><div class="line">      <span class="keywordflow">do</span> std::cout &lt;&lt; <span class="stringliteral">" --&gt; "</span> &lt;&lt; curr-&gt;target()-&gt;point();</div><div class="line">      <span class="keywordflow">while</span> (++curr != fit-&gt;outer_ccb());</div><div class="line">      std::cout &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="arr_sssecex_dcel_all"></a>
Extending All DCEL Records</h3>
<p>As you continue to use arrangements to solve various problems you will find out that the ability to extend the face records is crucial. Perhaps less common, but also important to satisfy, is the need to extend the vertex and halfedge records as well. The <code><a class="el" href="classCGAL_1_1Arr__extended__dcel.html" title="The Arr_extended_dcel class-template extends the topological-features of the DCEL namely the vertex...">Arr_extended_dcel</a>&lt;Traits, VertexData, HalfedgeData, FaceData&gt;</code> class-template is used to associate auxiliary data fields of types <code>VertexData</code>, <code>HalfedgeData</code>, and <code>FaceData</code> with DCEL vertex, halfedge, and face record types, respectively. When the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt;Traits,Dcel&gt;</code> class template is instantiated, substituting the <code>Dcel</code> parameter with an instance of this DCEL class-template, the interfaces of the nested types Vertex, Halfedge, and Face are extended with the access function <code>data()</code> and with the modifier <code>set_data()</code>.</p>
<p>The next example shows how to use a DCEL with extended vertex, halfedge, and face records. In this example each vertex is associated with a color, which is either blue, red, or white, depending on whether the vertex is isolated, represents a segment endpoint, or represents an intersection point. (Notice that the coloring rules suggested here apply only to non-degenerate arrangements, where the sets of isolated points, curve endpoints, and intersection points are mutually exclusive.) In this example segments are treated as directed objects. Each halfedge is associated with Boolean flag indicating whether its direction is the same as the direction of its associated segment. Each face is also extended to store the size of its outer boundary, that is, the number of halfedges along its outer boundary.</p>
<p>The constructed arrangement, depicted in <a class="el" href="index.html#fig__aos_fig-dcel_extension">Figure 34.42</a>, is similar to the arrangement constructed in the previous example. In this case, however, we do not use an observer; instead, all auxiliary data-fields are set after the construction phase. Also note that the data fields are properly maintained when the arrangement is copied to another arrangement object.</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2dcel_extension_8cpp-example.html">Arrangement_on_surface_2/dcel_extension.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Extending all DCEL records (vertices, edges and faces).</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_extended_dcel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_exact_construction_segments.h"</span></div><div class="line"></div><div class="line"><span class="keyword">enum</span> Color {BLUE, RED, WHITE};</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__extended__dcel.html">CGAL::Arr_extended_dcel&lt;Traits, Color, bool, size_t&gt;</a> Dcel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits, Dcel&gt;</a>                    Ex_arrangement;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <span class="comment">// Construct the arrangement containing two intersecting triangles.</span></div><div class="line">  Traits traits;</div><div class="line">  Ex_arrangement arr(&amp;traits);</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr, Segment(Point(4, 1), Point(7, 6)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr, Segment(Point(1, 6), Point(7, 6)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr, Segment(Point(4, 1), Point(1, 6)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Segment(Point(1, 3), Point(7, 3)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Segment(Point(1, 3), Point(4, 8)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Segment(Point(4, 8), Point(7, 3)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#ga13c103c1cea5249ca37ce7e0be4d97e4">insert_point</a>(arr, Point(4, 4.5));</div><div class="line"></div><div class="line">  <span class="comment">// Go over all arrangement edges and set their flags.</span></div><div class="line">  <span class="comment">// Recall that the value type of the edge iterator is the halfedge type.</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> vit = arr.vertices_begin(); vit != arr.vertices_end(); ++vit) {</div><div class="line">    <span class="keyword">auto</span> degree = vit-&gt;degree();</div><div class="line">    vit-&gt;set_data((degree == 0) ? BLUE : ((degree &lt;= 2) ? RED : WHITE));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> equal = traits.equal_2_object();</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> eit = arr.edges_begin(); eit != arr.edges_end(); ++eit) {</div><div class="line">    <span class="comment">// Check whether the halfegde has the same direction as its segment.</span></div><div class="line">    <span class="keywordtype">bool</span> flag = equal(eit-&gt;source()-&gt;point(),eit-&gt;curve().source());</div><div class="line">    eit-&gt;set_data(flag);</div><div class="line">    eit-&gt;twin()-&gt;set_data(!flag);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Store the size of the outer boundary of every face of the arrangement.</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> fit = arr.faces_begin(); fit != arr.faces_end(); ++fit) {</div><div class="line">    <span class="keywordtype">size_t</span> boundary_size = 0;</div><div class="line">    <span class="keywordflow">if</span> (! fit-&gt;is_unbounded()) {</div><div class="line">      Ex_arrangement::Ccb_halfedge_circulator curr = fit-&gt;outer_ccb();</div><div class="line">      boundary_size = std::distance(++curr, fit-&gt;outer_ccb())+1;</div><div class="line">    }</div><div class="line">    fit-&gt;set_data(boundary_size);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Copy the arrangement and print the vertices along with their colors.</span></div><div class="line">  Ex_arrangement arr2 = arr;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The arrangement vertices:\n"</span>;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> vit = arr2.vertices_begin(); vit != arr2.vertices_end(); ++vit) {</div><div class="line">    std::cout &lt;&lt; <span class="charliteral">'('</span> &lt;&lt; vit-&gt;point() &lt;&lt; <span class="stringliteral">") - "</span>;</div><div class="line">    <span class="keywordflow">switch</span> (vit-&gt;data()) {</div><div class="line">      <span class="keywordflow">case</span> BLUE  : std::cout &lt;&lt; <span class="stringliteral">"BLUE.\n"</span>; <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">case</span> RED   : std::cout &lt;&lt; <span class="stringliteral">"RED.\n"</span>; <span class="keywordflow">break</span>;</div><div class="line">      <span class="keywordflow">case</span> WHITE : std::cout &lt;&lt; <span class="stringliteral">"WHITE.\n"</span>; <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The arrangement outer-boundary sizes:"</span>;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> fit = arr2.faces_begin(); fit != arr2.faces_end(); ++fit)</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; fit-&gt;data();</div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> </p><div class="CGALAdvanced"> <div>Advanced</div> 
<p>The various DCEL classes presented in this section are well suited for most applications based on the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgArrangementOnSurface2">2D Arrangements</a> package. They are all defined using helper constructs, and in particular the base DCEL class-template <code><a class="el" href="classCGAL_1_1Arr__dcel__base.html">Arr_dcel_base</a>}</code>. However, there are cases where special requirements, not addressed by these DCEL classes, are needed. In such cases you may explicitly extend the base DCEL class-template, as described in the next paragraph, or implement your own DCEL class from scratch and use the resulting DCEL to instantiate the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> class template. In any case such a class must model the concept <code><a class="el" href="classArrangementDcel.html" title="A doubly-connected edge-list (DCEL for short) data-structure. It consists of three containers of reco...">ArrangementDcel</a></code> or its refinement <code><a class="el" href="classArrangementDcelWithRebind.html" title="The concept ArrangementDcelWithRebind refines the ArrangementDcel concept by adding a policy clone id...">ArrangementDcelWithRebind</a></code>. The latter requires a <code>rebind</code> struct template, which implements a policy-clone idiom. Here, the DCEL class is the policy class and the <code>rebind</code> member template struct is used to pass a different traits type parameter to the policy class template.</p>
<p>In some cases you may want to extend a certain feature type with several fields. You can gather all these fields (and perhaps methods that access and retrieve these fields) in a single construct, and substitute the appropriate parameter of the class template <code><a class="el" href="classCGAL_1_1Arr__extended__dcel.html" title="The Arr_extended_dcel class-template extends the topological-features of the DCEL namely the vertex...">Arr_extended_dcel</a>&lt;Traits, VertexData, HalfedgeData, FaceData&gt;</code> with this construct. Naturally, you can define three constructs, one for each feature type, and substitute all the three corresponding template parameters appropriately. For example, consider an arrangement that represents a map where features of the same type represent different cartographic entities, e.g., an edge represents a road, a river, or a railway. We would like to associate two strings with each feature, namely, the name and the type of the feature. Following the solution above, accessing or retrieving a specific field will always require an indirection through one of the member functions <code>set_data()</code> and <code>data()</code>. While this indirection is typically resolved at compile time, and thus has no negative effect on the running time of the generated code, it may have some implication on the space consumption due to compiler padding.<span class="footnote">Compilers add pad bytes into user-defined constructs to comply with alignment restrictions imposed by target microprocessors.</span> Moreover, the code may look cumbersome.</p>
<p>The extended DCEL class that addresses the problem raised above is listed below. Here, each feature type is explicitly extended with two strings, namely, <code>name</code> and <code>type</code>, eliminating the data constructs.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_dcel_base.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// The map-extended dcel vertex.</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Po<span class="keywordtype">int</span>_2&gt;</div><div class="line"><span class="keyword">class </span>Arr_map_vertex : <span class="keyword">public</span> CGAL::Arr_vertex_base&lt;Point_2&gt; {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  std::string name, type;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// The map-extended dcel halfedge.</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> X_monotone_curve_2&gt;</div><div class="line"><span class="keyword">class </span>Arr_map_halfedge : <span class="keyword">public</span> CGAL::Arr_halfedge_base&lt;X_monotone_curve_2&gt; {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  std::string name, type;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// The map-extended dcel face.</span></div><div class="line"><span class="keyword">class </span>Arr_map_face : <span class="keyword">public</span> CGAL::Arr_face_base {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  std::string name, type;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// The map-extended dcel.</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Traits&gt;</div><div class="line"><span class="keyword">class </span>Arr_map_dcel : <span class="keyword">public</span></div><div class="line">  <a class="code" href="classCGAL_1_1Arr__dcel__base.html">CGAL::Arr_dcel_base</a>&lt;Arr_map_vertex&lt;typename Traits::Point_2&gt;,</div><div class="line">                      Arr_map_halfedge&lt;typename Traits::X_monotone_curve_2&gt;,</div><div class="line">                      Arr_map_face&gt;</div><div class="line">{};</div></div><!-- fragment --><p> </p></div> 
<h2><a class="anchor" id="arr_ssecoverlay"></a>
Overlaying Arrangements</h2>
<p>Assume that we are given two geographic maps represented as arrangements, with some data objects attached to their faces, representing some geographic information—for instance, a map of the annual precipitation in some country and a map of the vegetation in the same country—and you are asked to locate, for example, places where there is a pine forest <em>and</em> the annual precipitation is between 1,000mm and 1,500mm. Overlaying the two maps may help you figure out the answer. Computing the overlay of two two-dimensional arrangements is also useful for supporting Boolean set operations on polygons or general polygons; see e.g., <a class="el" href="citelist.html#CITEREF_cgal:behhms-cbcab-02">[2]</a>).</p>
<p>Formally, the <em>map overlay</em> of two two-dimensional subdivisions \(\mathcal{S}_1\) and \(\mathcal{S}_2\) is a two-dimensional subdivision \(\mathcal{S}\), such that there is a face \(f\) in \(\mathcal{S}\) iff there are faces \(f_1\) and \(f_2\) in \(\mathcal{S}_1\) and \(\mathcal{S}_2\), respectively, such that \(f\) is a maximal connected component of \(f_1 \cap f_2\).</p>
<p>The overlay of two given arrangements, conveniently referred to as the "blue" and the "red" arrangements, is implemented as a plane-sweep algorithm employing a dedicated visitor; see Section <a class="el" href="index.html#arr_ssec_sweep">The Surface-Sweep Algorithm</a>. The \(x\)-monotone curve type is extended with a color attribute (whose value is either blue or red); see Section <a class="el" href="index.html#arr_ssecmeta_tr">Traits-Class Decorators</a>. With the help of the extended type unnecessary computations are filtered out while the plane is swept, yielding an efficient process. For example, monochromatic intersections are not computed.</p>
<p>The plane-sweep visitor that concretizes the overlay operation needs to construct a DCEL that properly represents the overlay of two input arrangements. A face in the overlay arrangement corresponds to overlapping regions of the blue and red faces. An edge in the overlay arrangement is due to a blue edge, a red edge, or an overlap of two differently colored edges. An overlay vertex is due to a blue vertex, a red vertex, a coincidence of two differently colored vertices, or an intersection of a blue and a red curve.</p>
<p>The call <a class="el" href="group__PkgArrangementOnSurface2Funcs.html#ga339cdba93f54001be303595689002396"><code>overlay(arr_r, arr_b, arr_o, ovl_traits)</code></a> constructs the arrangement <code>arr_o</code>, which is the overlay of two input arrangement <code>arr_r</code> and <code>arr_b</code>. All three arrangements must use the same geometric primitives. In other words, their types are instances of the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt;Traits,Dcel&gt;</code> class template, where the <code>Traits</code> parameter is substituted with three geometry-traits classes, respectively. The geometry-traits classes of the input arrangements must be convertible to the geometry-traits class of the resulting arrangement.<span class="footnote">It is sufficient that all three geometry-traits classes used to instantiate the three types of arrangements derive from a common ancestor that models the geometry-traits concept.</span> Typically, all three arrangements use the same geometry-traits class.</p>
<p>The <code><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#ga339cdba93f54001be303595689002396" title="Computes the overlay of two arrangements arr1 and arr2, and sets the output arrangement res to repres...">overlay()</a></code> function template is suitable for arrangements that do not store any additional data with their DCEL records; namely, arrangements defined using an instance of the default DCEL class-template <code><a class="el" href="classCGAL_1_1Arr__default__dcel.html" title="The default DCEL class used by the Arrangement_2 class-template is parameterized by a traits class...">Arr_default_dcel</a></code>. Typically, the overlay arrangement in this case does not store extra data with its DCEL records as well (or if it does, the additional data-fields cannot be computed by the overlay operation). The overlay arrangement is equivalent to the arrangement induced by all curves of <code>arr_r</code> and <code>arr_b</code>. Indeed, it is possible to obtain the same result using the standard insertion-operations instead, but, as mentioned above, this is less efficient.</p>
<p><a class="anchor" id="fig__aos_figex_overlay"></a></p><div class="image">
<img src="overlay.png" alt="overlay.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_figex_overlay">Figure 34.43</a> Overlaying two simple arrangements of line segments, as done in <a class="el" href="Arrangement_on_surface_2_2overlay_8cpp-example.html">Arrangement_on_surface_2/overlay.cpp</a> and <a class="el" href="Arrangement_on_surface_2_2face_extension_overlay_8cpp-example.html">Arrangement_on_surface_2/face_extension_overlay.cpp</a>. In <a class="el" href="Arrangement_on_surface_2_2face_extension_overlay_8cpp-example.html">Arrangement_on_surface_2/face_extension_overlay.cpp</a> the two bounded faces are considered as <em>marked</em>, and the octagonal face which is the intersection of the two marked faces is denoted by \(f_0\).  </div> <br /> 
<p>The next program constructs two simple arrangements; each comprises four line segments that form a square, as depicted in <a class="el" href="index.html#fig__aos_figex_overlay">Figure 34.43</a>. The program computes the overlay of the two arrangements. The resulting arrangement has 16 vertices, 24 edges, and 10 faces (including the unbounded one.</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2overlay_8cpp-example.html">Arrangement_on_surface_2/overlay.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// A simple overlay of two arrangements.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_overlay_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_exact_construction_segments.h"</span></div><div class="line"><span class="preprocessor">#include "arr_print.h"</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <span class="comment">// Construct the first arrangement, containing a square-shaped face.</span></div><div class="line">  Arrangement arr1;</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr1, Segment(Point(2, 2), Point(6, 2)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr1, Segment(Point(6, 2), Point(6, 6)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr1, Segment(Point(6, 6), Point(2, 6)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr1, Segment(Point(2, 6), Point(2, 2)));</div><div class="line"></div><div class="line">  <span class="comment">// Construct the second arrangement, containing a rhombus-shaped face.</span></div><div class="line">  Arrangement arr2;</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr2, Segment(Point(4, 1), Point(7, 4)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr2, Segment(Point(7, 4), Point(4, 7)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr2, Segment(Point(4, 7), Point(1, 4)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr2, Segment(Point(1, 4), Point(4, 1)));</div><div class="line"></div><div class="line">  <span class="comment">// Compute the overlay of the two arrangements.</span></div><div class="line">  Arrangement overlay_arr;</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#ga339cdba93f54001be303595689002396">CGAL::overlay</a>(arr1, arr2, overlay_arr);</div><div class="line">  print_arrangement_size(overlay_arr);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>The <code><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#ga339cdba93f54001be303595689002396" title="Computes the overlay of two arrangements arr1 and arr2, and sets the output arrangement res to repres...">overlay()</a></code> function template is overloaded with a variant that accepts four arguments, that is, <code>overlay(arr_r, arr_b, arr_o, ovl_traits)</code>. The type of the <code>ovl_traits</code> additional argument, referred to as the overlay traits, must model the <code><a class="el" href="classOverlayTraits.html" title="A model for the OverlayTraits should be able to operate on records (namely, vertices, halfedges and faces) of two input DCEL classes, named Dcel_A and Dcel_B, and construct the records of an output DCEL class, referred to as Dcel_R. ">OverlayTraits</a></code> concept described below. Assume that <code>arr_r</code> is of type <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt;Traits,Dcel_R&gt;</code>, <code>arr_b</code> is of type <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt;Traits,Dcel_B&gt;</code>, and the resulting <code>arr_o</code> is of type <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt;Traits,Dcel_O&gt;</code>. The overlay traits enables the creation of <code>Dcel_O</code> records in the overlay arrangement from the features of <code>Dcel_R</code> and <code>Dcel_B</code> records from the arrangements <code>arr_r</code> and <code>arr_b</code>, respectively.</p>
<p>We distinguish between (i) an overlay of two arrangements that store additional data-fields only with their faces e.g., the geographic-map example given at the beginning of this section) and (ii) an overlay of two arrangements that store additional data fields with all their DCEL records (or at least not only with their faces). The arrangement that results from overlaying two face-extended arrangements typically also stores additional data-fields with its faces. The types of such arrangements, for example, could be instances of the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt;Traits,Dcel&gt;</code> class template, where the <code>Dcel</code> parameters are substituted with instances of the <code><a class="el" href="classCGAL_1_1Arr__face__extended__dcel.html" title="The Arr_face_extended_dcel class-template extends the DCEL face-records, making it possible to store ...">Arr_face_extended_dcel</a></code> class template (see Section <a class="el" href="index.html#arr_sssecex_dcel_face">Extending the DCEL Faces</a>). The data field that is attached to an overlay face can be computed from the data fields of the two faces (in <code>arr_r</code> and <code>arr_b</code>) that induce the overlay face. Similarly, the arrangement that results from overlaying two arrangements that store additional data fields with all their DCEL records typically also stores additional data-fields with all its DCEL records. The types of such arrangements, for example, could be instances of the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt;Traits,Dcel&gt;</code> class template, where the <code>Dcel</code> parameters are substituted with instances of the <code><a class="el" href="classCGAL_1_1Arr__extended__dcel.html" title="The Arr_extended_dcel class-template extends the topological-features of the DCEL namely the vertex...">Arr_extended_dcel</a></code> class template (see Section <a class="el" href="index.html#arr_sssecex_dcel_all">Extending All DCEL Records</a>). The data field attached to an overlay feature can be computed from the data fields of the two features (in <code>arr_r</code> and <code>arr_b</code>) that induce the overlay feature.</p>
<p>As mentioned in the previous paragraph, if any of the DCEL records of your arrangements are extended, you can pass a fourth argument to the <code><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#ga339cdba93f54001be303595689002396" title="Computes the overlay of two arrangements arr1 and arr2, and sets the output arrangement res to repres...">overlay()</a></code> call, also referred to as the overlay traits, to control the generation of the extended data in the resulting arrangement. If only the face records are extended, the type of the overlay traits can be an instance of the class template <code><a class="el" href="classCGAL_1_1Arr__face__overlay__traits.html" title="An instance of Arr_face_overlay_traits should be used for overlaying two arrangements of types Arr_A ...">Arr_face_overlay_traits</a>&lt;ArrangementR,ArrangementB,ArrangementO,OverlayFaceData&gt;</code>, which models the concept <code><a class="el" href="classOverlayTraits.html" title="A model for the OverlayTraits should be able to operate on records (namely, vertices, halfedges and faces) of two input DCEL classes, named Dcel_A and Dcel_B, and construct the records of an output DCEL class, referred to as Dcel_R. ">OverlayTraits</a></code>. An object of this type operates on face-extended arrangements. When instantiated, the <code>OverlayFaceData</code> parameter must be substituted with a functor that is capable of combining two face-data fields of types <code>ArrangementR::Dcel::Face_data</code> and <code>ArrangementB::Dcel::Face_data</code> and computing the output <code>ArrangementO::Dcel::Face_data</code> object. The face-overlay traits-class uses this functor to properly construct the overlay faces.</p>
<p>The following example shows how to compute the intersection of two polygons using the <code><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#ga339cdba93f54001be303595689002396" title="Computes the overlay of two arrangements arr1 and arr2, and sets the output arrangement res to repres...">overlay()</a></code> function template. It uses a face-extended DCEL type to instantiate the arrangement classes. Each face of the the DCEL is extended with a Boolean flag. A polygon is represented as a <em>marked</em> arrangement face (whose flag is set). The example uses an instance of the <code><a class="el" href="classCGAL_1_1Arr__face__overlay__traits.html" title="An instance of Arr_face_overlay_traits should be used for overlaying two arrangements of types Arr_A ...">Arr_face_overlay_traits</a>&lt;ArrR,ArrB,ArrO,OverlayFaceData&gt;</code> class template as the face-overlay traits class where the <code>OverlayFaceData</code> template parameter is substituted with a functor that simply performs a logical <em>and</em> operation on Boolean flags. As a result, a face in the overlay arrangement is marked only when it corresponds to an overlapping region of two marked faces in the input arrangements. Namely, it is part of the intersection of the two polygons. The example computes the intersection between a parallel-axis square and a congruent square rotated \(45^\circ\). The resulting polygon from the intersection operation is an octagon, which corresponds to the face~ \(\hat{f}\) in the arrangement depicted in <a class="el" href="index.html#fig__aos_figex_overlay">Figure 34.43</a>.</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2face_extension_overlay_8cpp-example.html">Arrangement_on_surface_2/face_extension_overlay.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// A face overlay of two arrangements with extended face records.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_overlay_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_default_overlay_traits.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_exact_construction_segments.h"</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__face__extended__dcel.html">CGAL::Arr_face_extended_dcel&lt;Traits, bool&gt;</a>       Dcel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits, Dcel&gt;</a>                Ex_arrangement;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__face__overlay__traits.html">CGAL::Arr_face_overlay_traits</a>&lt;Ex_arrangement, Ex_arrangement,</div><div class="line">                                      Ex_arrangement,</div><div class="line">                                      std::logical_and&lt;bool&gt; &gt;</div><div class="line">                                                         Overlay_traits;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <span class="comment">// Construct the first arrangement, containing a square-shaped face.</span></div><div class="line">  Ex_arrangement arr1;</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr1, Segment(Point(2, 2), Point(6, 2)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr1, Segment(Point(6, 2), Point(6, 6)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr1, Segment(Point(6, 6), Point(2, 6)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr1, Segment(Point(2, 6), Point(2, 2)));</div><div class="line">  CGAL_assertion(arr1.number_of_faces() == 2);</div><div class="line"></div><div class="line">  <span class="comment">// Mark just the bounded face.</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> fit = arr1.faces_begin(); fit != arr1.faces_end(); ++fit)</div><div class="line">    fit-&gt;set_data(fit != arr1.unbounded_face());</div><div class="line"></div><div class="line">  <span class="comment">// Construct the second arrangement, containing a rhombus-shaped face.</span></div><div class="line">  Ex_arrangement arr2;</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr2, Segment(Point(4, 1), Point(7, 4)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr2, Segment(Point(7, 4), Point(4, 7)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr2, Segment(Point(4, 7), Point(1, 4)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr2, Segment(Point(1, 4), Point(4, 1)));</div><div class="line">  CGAL_assertion(arr2.number_of_faces() == 2);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> fit = arr2.faces_begin(); fit != arr2.faces_end(); ++fit)</div><div class="line">    fit-&gt;set_data(fit != arr2.unbounded_face());    <span class="comment">// mark the bounded face.</span></div><div class="line"></div><div class="line">  <span class="comment">// Compute the overlay of the two arrangements, marking only the faces that</span></div><div class="line">  <span class="comment">// are intersections of two marked faces in arr1 and arr2, respectively.</span></div><div class="line">  Ex_arrangement overlay_arr;</div><div class="line">  Overlay_traits overlay_traits;</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#ga339cdba93f54001be303595689002396">CGAL::overlay</a>(arr1, arr2, overlay_arr, overlay_traits);</div><div class="line"></div><div class="line">  <span class="comment">// Go over the faces of the resulting arrangement and print the marked ones.</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The intersection is: "</span>;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> fit = overlay_arr.faces_begin(); fit != overlay_arr.faces_end();</div><div class="line">       ++fit)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (! fit-&gt;data()) <span class="keywordflow">continue</span>;</div><div class="line">    Ex_arrangement::Ccb_halfedge_circulator curr = fit-&gt;outer_ccb();</div><div class="line">    std::cout &lt;&lt; curr-&gt;source()-&gt;point();</div><div class="line">    <span class="keywordflow">do</span> std::cout &lt;&lt; <span class="stringliteral">" --&gt; "</span> &lt;&lt; curr-&gt;target()-&gt;point();</div><div class="line">    <span class="keywordflow">while</span> (++curr != fit-&gt;outer_ccb());</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="fig__aos_figex_overlay_unbounded"></a></p><div class="image">
<img src="overlay_unbounded.png" alt="overlay_unbounded.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_figex_overlay_unbounded">Figure 34.44</a> Overlaying two arrangements of lines that have unbounded faces, as done in <a class="el" href="Arrangement_on_surface_2_2overlay_unbounded_8cpp-example.html">Arrangement_on_surface_2/overlay_unbounded.cpp</a>.  </div> <br /> 
<p>The next example, depicted in <a class="el" href="index.html#fig__aos_figex_overlay_unbounded">Figure 34.44</a>, demonstrates the face overlay of two arrangements that have unbounded faces as well as bounded ones. The first arrangement (blue) is induced by the two lines \(y = x\) and \(y = -x\), which subdivide the plane into four unbounded faces, labeled \(A\), \(B\), \(C\) and \(D\). The second arrangement (red) comprises four line segments that form a square-shaped face indexed \(1\). The unbounded face is indexed 2. When the two arrangements are overlaid, each of the four faces \(A\), \(B\), \(C\) and \(D\) is split into an unbounded face (indexed 2) and a bounded face (indexed 1), so the faces of the resulting arrangement are labeled \(A_1, A_2, \ldots, D_1, D_2\). <code>boost::lexical_cast</code> is used to cast the integral indices into strings to produce the final labels.</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2overlay_unbounded_8cpp-example.html">Arrangement_on_surface_2/overlay_unbounded.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// A face overlay of two arrangements with unbounded faces.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/lexical_cast.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_extended_dcel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_overlay_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_default_overlay_traits.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_linear.h"</span></div><div class="line"></div><div class="line"><span class="comment">// Define a functor for creating a label from a characer and an integer.</span></div><div class="line"><span class="keyword">struct </span>Overlay_label {</div><div class="line">  std::string operator()(<span class="keywordtype">char</span> c, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{ <span class="keywordflow">return</span> c + boost::lexical_cast&lt;std::string&gt;(i); }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__face__extended__dcel.html">CGAL::Arr_face_extended_dcel&lt;Traits, char&gt;</a>         Dcel_dlue;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits, Dcel_dlue&gt;</a>             Arrangement_blue;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__face__extended__dcel.html">CGAL::Arr_face_extended_dcel&lt;Traits, unsigned int&gt;</a> Dcel_red;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits, Dcel_red&gt;</a>              Arrangement_red;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__face__extended__dcel.html">CGAL::Arr_face_extended_dcel&lt;Traits, std::string&gt;</a>  Dcel_res;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits, Dcel_res&gt;</a>              Arrangement_res;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__face__overlay__traits.html">CGAL::Arr_face_overlay_traits</a>&lt;Arrangement_blue, Arrangement_red,</div><div class="line">                                      Arrangement_res, Overlay_label&gt;</div><div class="line">                                                           Overlay_traits;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <span class="comment">// Construct the first arrangement, induced by two lines y = x and y = -x.</span></div><div class="line">  Arrangement_blue arr1;</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr1, Line(Point(0, 0), Point(1, 1)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr1, Line(Point(0, 0), Point(1, -1)));</div><div class="line"></div><div class="line">  <span class="comment">// Label the four (unbounded) faces of the arrangement as 'A' to 'D' by</span></div><div class="line">  <span class="comment">// traversing the faces incident to the halfedges around the single</span></div><div class="line">  <span class="comment">// arrangement vertex (0, 0).</span></div><div class="line">  <span class="keywordtype">char</span> clabel = <span class="charliteral">'A'</span>;</div><div class="line">  <span class="keyword">auto</span> first = arr1.vertices_begin()-&gt;incident_halfedges();</div><div class="line">  <span class="keyword">auto</span> curr = first;</div><div class="line">  <span class="keywordflow">do</span> curr-&gt;face()-&gt;set_data(clabel++);</div><div class="line">  <span class="keywordflow">while</span> (++curr != first);</div><div class="line"></div><div class="line">  <span class="comment">// Construct the second arrangement, containing a single square-shaped face.</span></div><div class="line">  Arrangement_red arr2;</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr2, Segment(Point(-3, -3), Point(3, -3)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr2, Segment(Point(3, -3), Point(3, 3)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr2, Segment(Point(3, 3), Point(-3, 3)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr2, Segment(Point(-3, 3), Point(-3, -3)));</div><div class="line"></div><div class="line">  <span class="comment">// Give the unbounded face the index 1, and the bounded face the index 2.</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> fit = arr2.faces_begin(); fit != arr2.faces_end(); ++fit)</div><div class="line">    fit-&gt;set_data((fit == arr2.unbounded_face()) ? 1 : 2);</div><div class="line"></div><div class="line">  <span class="comment">// Compute the overlay of the two arrangements.</span></div><div class="line">  Arrangement_res overlay_arr;</div><div class="line">  Overlay_traits overlay_traits;</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#ga339cdba93f54001be303595689002396">CGAL::overlay</a>(arr1, arr2, overlay_arr, overlay_traits);</div><div class="line"></div><div class="line">  <span class="comment">// Go over the faces of the overlay arrangement and print their labels.</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The overlay faces are:\n"</span>;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> res_fit = overlay_arr.faces_begin();</div><div class="line">       res_fit != overlay_arr.faces_end(); ++res_fit)</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"  "</span> &lt;&lt; res_fit-&gt;data().c_str() &lt;&lt; <span class="stringliteral">" ("</span></div><div class="line">              &lt;&lt; (res_fit-&gt;is_unbounded() ? <span class="stringliteral">"unbounded"</span> : <span class="stringliteral">"bounded"</span>) &lt;&lt; <span class="stringliteral">").\n"</span>;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>If the red and blue arrangements store additional data-fields with all their DCEL records, and the data associated with the overlay DCEL features should be computed from the red and blue DCEL features that induce it, then an appropriate overlay-traits argument must be passed to the <code><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#ga339cdba93f54001be303595689002396" title="Computes the overlay of two arrangements arr1 and arr2, and sets the output arrangement res to repres...">overlay()</a></code> call. The overlay-traits type models the <code><a class="el" href="classOverlayTraits.html" title="A model for the OverlayTraits should be able to operate on records (namely, vertices, halfedges and faces) of two input DCEL classes, named Dcel_A and Dcel_B, and construct the records of an output DCEL class, referred to as Dcel_R. ">OverlayTraits</a></code> concept, which requires the provision of ten functions that handle all possible cases as listed below. Let \(v_r\), \(e_r\), and \(f_r\) denote input <span style="color:red;">red</span> features, i.e., a vertex, an edge, and a face, respectively, \(v_b\), \(e_b\), and \(f_b\) denote input <span style="color:blue;">blue</span> features, and \(v\), \(e\), and \(f\) denote output features.</p>
<ol>
<li>
<p class="startli">A new vertex \(v\) is induced by coinciding vertices \(v_r\) and \(v_b\).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">A new vertex \(v\) is induced by a vertex \(v_r\) that lies on an edge \(e_b\).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">An analogous case of a vertex \(v_b\) that lies on an edge \(e_r\).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">A new vertex \(v\) is induced by a vertex \(v_r\) that is contained in a face \(f_b\).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">An analogous case of a vertex \(v_b\) contained in a face \(f_r\).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">A new vertex \(v\) is induced by the intersection of two edges \(e_r\) and \(e_b\).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">A new edge \(e\) is induced by the (possibly partial) overlap of two edges \(e_r\) and \(e_b\).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">A new edge \(e\) is induced by the an edge \(e_r\) that is contained in a face \(f_b\).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">An analogous case of an edge \(e_b\) contained in a face \(f_r\).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">A new face \(f\) is induced by the overlap of two faces \(f_r\) and \(f_b\).</p>
<p class="endli"></p>
</li>
</ol>
<p>The <code>Overlay_color_traits</code> class template listed below models the concept <code><a class="el" href="classOverlayTraits.html" title="A model for the OverlayTraits should be able to operate on records (namely, vertices, halfedges and faces) of two input DCEL classes, named Dcel_A and Dcel_B, and construct the records of an output DCEL class, referred to as Dcel_R. ">OverlayTraits</a></code>. It assumes that each feature of the input arrangements and of the overlay arrangement is extended with an RGB color stored as an <code>unsigned int</code>. It defines ten member functions that correspond to the ten cases listed above. Each of these functions accepts three handles as follows: two handles to the two features of the input arrangements, respectively, that induce a feature of the overlay arrangement and a handle to the induced overlay-arrangement feature. Each of these member functions blends the colors attached to the inducing features and assigns the resulting color to the induced feature. The <code>Overlay_color_traits</code> class template is defined in the header file <code>Overlay_color_traits.h</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Arrangement&gt; <span class="keyword">struct </span>Overlay_color_traits {</div><div class="line">  <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                                  Color;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Arrangement::Vertex_const_handle     V_const_handle;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Arrangement::Halfedge_const_handle   H_const_handle;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Arrangement::Face_const_handle       F_const_handle;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Arrangement::Vertex_handle           V_handle;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Arrangement::Halfedge_handle         H_handle;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Arrangement::Face_handle             F_handle;</div><div class="line"></div><div class="line">  <span class="comment">// Compute the average of the red, green, and blue components separately.</span></div><div class="line">  Color blend(Color color1, Color color2)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span></div><div class="line">      ((((color1 &amp; 0x000000ff) + (color2 &amp; 0x000000ff)) / 2) &amp; 0x000000ff) |</div><div class="line">      ((((color1 &amp; 0x0000ff00) + (color2 &amp; 0x0000ff00)) / 2) &amp; 0x0000ff00) |</div><div class="line">      ((((color1 &amp; 0x00ff0000) + (color2 &amp; 0x00ff0000)) / 2) &amp; 0x00ff0000);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> create_face(F_const_handle f1, F_const_handle f2, F_handle f)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{ f-&gt;set_data(blend(f1-&gt;data(), f2-&gt;data())); }</div><div class="line">  <span class="keywordtype">void</span> create_vertex(H_const_handle h1, H_const_handle h2, V_handle v)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{ v-&gt;set_data(blend(h1-&gt;data(), h2-&gt;data())); }</div><div class="line">  <span class="keywordtype">void</span> create_vertex(V_const_handle v1, V_const_handle v2, V_handle v)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{ v-&gt;set_data(blend(v1-&gt;data(), v2-&gt;data())); }</div><div class="line">  <span class="keywordtype">void</span> create_vertex(V_const_handle v1, H_const_handle h2, V_handle v)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{ v-&gt;set_data(blend(v1-&gt;data(), h2-&gt;data())); }</div><div class="line">  <span class="keywordtype">void</span> create_vertex(H_const_handle h1, V_const_handle v2, V_handle v)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{ v-&gt;set_data(blend(h1-&gt;data(), v2-&gt;data())); }</div><div class="line">  <span class="keywordtype">void</span> create_vertex(F_const_handle f1, V_const_handle v2, V_handle v)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{ v-&gt;set_data(blend(f1-&gt;data(), v2-&gt;data())); }</div><div class="line">  <span class="keywordtype">void</span> create_vertex(V_const_handle v1, F_const_handle f2, V_handle v)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{ v-&gt;set_data(blend(v1-&gt;data(), f2-&gt;data())); }</div><div class="line">  <span class="keywordtype">void</span> create_edge(H_const_handle h1, H_const_handle h2, H_handle h)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    h-&gt;set_data(blend(h1-&gt;data(), h2-&gt;data()));</div><div class="line">    h-&gt;twin()-&gt;set_data(blend(h1-&gt;data(), h2-&gt;data()));</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> create_edge(H_const_handle h1, F_const_handle f2, H_handle h)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    h-&gt;set_data(blend(h1-&gt;data(), f2-&gt;data()));</div><div class="line">    h-&gt;twin()-&gt;set_data(blend(h1-&gt;data(), f2-&gt;data()));</div><div class="line">  }</div><div class="line">  <span class="keywordtype">void</span> create_edge(F_const_handle f1, H_const_handle h2, H_handle h)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    h-&gt;set_data(blend(f1-&gt;data(), h2-&gt;data()));</div><div class="line">    h-&gt;twin()-&gt;set_data(blend(f1-&gt;data(), h2-&gt;data()));</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="fig__aos_figex_overlay_color"></a></p><div class="image">
<img src="overlay_color.png" alt="overlay_color.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_figex_overlay_color">Figure 34.45</a>
<p>The overlay of two extended arrangements]{The overlay (c) of two arrangements (a) and (b). Each feature of the arrangements is extended with a color. The color of each feature of the overlay arrangement is the blend of the colors of the two inducing features.</p>
<p> </p></div> <br /> 
<p>The example program listed below computes the overlay, depicted in <a class="el" href="index.html#fig__aos_figex_overlay_color">Figure 34.45</a>, of the two arrangements depicted in (a) and (d). Each feature of the input arrangements and of the overlay arrangement is extended with an RGB color stored as an <code>unsigned int</code>. The vertices, halfedges, and faces of the red arrangement are assigned three different shades of red. Similarly, the vertices, halfedges, and faces of the blue arrangement are assigned three different shades of blue. Using an instance of the <code>Overlay_color_traits</code> class template as the overlay traits, each feature of the overlay arrangement is assigned a color that is a blend of the colors attached to the inducing features.</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2overlay_color_8cpp-example.html">Arrangement_on_surface_2/overlay_color.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// The overlay of two arrangement with extended dcel structures</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_extended_dcel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_overlay_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_default_overlay_traits.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_exact_construction_segments.h"</span></div><div class="line"><span class="preprocessor">#include "Overlay_color_traits.h"</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                                         Color;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__extended__dcel.html">CGAL::Arr_extended_dcel&lt;Traits, Color, Color, Color&gt;</a> Dcel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits, Dcel&gt;</a>                    Ex_arrangement;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <span class="keyword">const</span> Color vcol1(0x00000080), hcol1(0x000000ff), fcol1(0x00ccccff);</div><div class="line">  <span class="keyword">const</span> Color vcol2(0x00800000), hcol2(0x00ff0000), fcol2(0x00ffcccc);</div><div class="line"></div><div class="line">  <span class="comment">// Construct the first arrangement and assign colors to its features.</span></div><div class="line">  Ex_arrangement arr1;</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr1, Segment(Point(0, 0), Point(4, 0)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr1, Segment(Point(0, 2), Point(4, 2)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr1, Segment(Point(0, 4), Point(4, 4)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr1, Segment(Point(0, 0), Point(0, 4)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr1, Segment(Point(2, 0), Point(2, 4)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr1, Segment(Point(4, 0), Point(4, 4)));</div><div class="line">  CGAL_assertion(arr1.number_of_faces() == 5);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> vit = arr1.vertices_begin(); vit != arr1.vertices_end(); ++vit)</div><div class="line">    vit-&gt;set_data(vcol1);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> hit = arr1.halfedges_begin(); hit != arr1.halfedges_end(); ++hit)</div><div class="line">    hit-&gt;set_data(hcol1);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> fit = arr1.faces_begin(); fit != arr1.faces_end(); ++fit)</div><div class="line">    fit-&gt;set_data(fcol1);</div><div class="line"></div><div class="line">  <span class="comment">// Construct the second arrangement and assign colors to its features.</span></div><div class="line">  Ex_arrangement  arr2;</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr2, Segment(Point(0, 0), Point(6, 0)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr2, Segment(Point(0, 3), Point(6, 3)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr2, Segment(Point(0, 6), Point(6, 6)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr2, Segment(Point(0, 0), Point(0, 6)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr2, Segment(Point(3, 0), Point(3, 6)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr2, Segment(Point(6, 0), Point(6, 6)));</div><div class="line">  CGAL_assertion(arr2.number_of_faces() == 5);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> vit = arr2.vertices_begin(); vit != arr2.vertices_end(); ++vit)</div><div class="line">    vit-&gt;set_data(vcol2);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> hit = arr2.halfedges_begin(); hit != arr2.halfedges_end(); ++hit)</div><div class="line">    hit-&gt;set_data(hcol2);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> fit = arr2.faces_begin(); fit != arr2.faces_end(); ++fit)</div><div class="line">    fit-&gt;set_data(fcol2);</div><div class="line"></div><div class="line">  <span class="comment">// Compute the overlay of the two arrangements, while blending the colors</span></div><div class="line">  <span class="comment">// of their features.</span></div><div class="line">  Ex_arrangement ovl_arr;</div><div class="line">  Overlay_color_traits&lt;Ex_arrangement&gt; overlay_traits;</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#ga339cdba93f54001be303595689002396">CGAL::overlay</a>(arr1, arr2, ovl_arr, overlay_traits);</div><div class="line"></div><div class="line">  <span class="comment">// Print the overlay-arrangement vertices and their colors.</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> vit = ovl_arr.vertices_begin(); vit != ovl_arr.vertices_end(); ++vit)</div><div class="line">    std::cout &lt;&lt; vit-&gt;point() &lt;&lt; <span class="stringliteral">": 0x"</span> &lt;&lt; std::hex &lt;&lt; std::setfill(<span class="charliteral">'0'</span>)</div><div class="line">              &lt;&lt; std::setw(6) &lt;&lt; vit-&gt;data() &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="arr_ssecarr_with_hist"></a>
Storing the Curve History</h2>
<p>When you constructs an arrangement induced by a set \(\mathcal{C}\) of arbitrary two-dimensional curves, you end up with a collection \(\mathcal{C}''\) of \(x\)-monotone subcurves of \(\mathcal{C}\) that are pairwise disjoint in their interior; see Section <a class="el" href="index.html#aos_sec-intro">Introduction</a>. These subcurves are associated with the arrangement edges (more precisely, with pairs of DCEL halfedges). The connection between the originating input curves and the arrangement edges is lost during the construction process. This loss might be acceptable for some applications. However, in many practical cases it is important to determine the input curves that give rise to the final subcurves.</p>
<p>The <code><a class="el" href="classCGAL_1_1Arrangement__on__surface__with__history__2.html">Arrangement_on_surface_with_history_2</a>&lt;GeometryTraits,TopologyTraits&gt;</code> class-template extends the <code><a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html">Arrangement_on_surface_2</a>&lt;GeometryTraits,TopologyTraots&gt;</code> class template by keeping an additional container of input curves representing \(\mathcal{C}\), and by maintaining a cross-mapping between these curves and the arrangement edges they induce. Similarly, the <code><a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a>&lt;GeometryTraits,Dcel&gt;</code> class-template extends the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt;GeometryTraits,Dcel&gt;</code> class template. The <code>GeometryTraits</code> template parameter, of either class templates, must be substituted with a model of the <code><a class="el" href="classArrangementTraits__2.html" title="The concept ArrangementTraits_2 allows the construction of arrangement of general planar curves...">ArrangementTraits_2</a></code> concept; see Section <a class="el" href="index.html#aos_ssec-insert_gen">Inserting General Curves</a>. It should define the <a class="el" href="classArrangementTraits__2.html#a2cb306c890ab7d32f397b5d246e0271f"><code>Curve_2</code></a> type and support its subdivision into <a class="el" href="classArrangementBasicTraits__2.html#a0fc1f7acfd69a5eae393294b6870a1d2"><code>X_monotone_curve_2</code></a> objects, among the others. The <code>Dcel</code> parameter must be substituted with a model of the <code><a class="el" href="classArrangementDcel.html" title="A doubly-connected edge-list (DCEL for short) data-structure. It consists of three containers of reco...">ArrangementDcel</a></code> concept. You can use either the default DCEL class or an extended DCEL class (see Section <a class="el" href="index.html#arr_ssecex_dcel">Extending the DCEL</a>) based on your needs. An arrangement that support the cross-mapping mentioned above is referred to as an arrangement with history. In the following we use the <code><a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a>&lt;&gt;</code> class template to demonstrate arrangements with history. However, the explanation applies also to <code><a class="el" href="classCGAL_1_1Arrangement__on__surface__with__history__2.html">Arrangement_on_surface_with_history_2</a>&lt;&gt;</code>, as the type of the embedding surface is irrelevant to the discussion.</p>
<h3><a class="anchor" id="arr_sssecarrwh_traverse"></a>
Traversing an Arrangement with History</h3>
<p>The <code><a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a></code> class template extends the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> class template. Thus, all the iterator and circulator types that are defined in the base class are also available in <code><a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a></code>. (Refer to Section <a class="el" href="index.html#arr_ssectraverse">Traversing the Arrangement</a> for a comprehensive review of this functionality.)</p>
<p>As mentioned above, the <code><a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a></code> class template maintains a container of input curves, which can be accessed using curve handles. Let <code>arr</code> identify an object, the type of which is an instance of this template. The call <a class="el" href="classCGAL_1_1Arrangement__on__surface__with__history__2.html#adabd51104d7d446771faeeae3c1cc006"><code>arr.number_of_curves()</code></a> returns the number of input curves stored in the container, while <a class="el" href="classCGAL_1_1Arrangement__on__surface__with__history__2.html#a846c40b96b3527112cb5a1c74a48f284"><code>arr.curves_begin()</code></a> and <a class="el" href="classCGAL_1_1Arrangement__on__surface__with__history__2.html#a30d59f0a6ecf423882e8b6a63ca063b0"><code>arr.curves_end()</code></a> return <code><a class="el" href="classCGAL_1_1Arrangement__with__history__2.html#aaeb6d64d0b074e3bb4b531105709565b">Arrangement_with_history_2::Curve_iterator</a></code> objects that define the range of curves that induce the arrangement. The value type of this iterator is <a class="el" href="classCGAL_1_1Arrangement__with__history__2.html#aa303273192e33c6f0c1fb3e6ca33d3c9"><code>Curve_2</code></a>. Moreover, the curve-iterator type is convertible to <code><a class="el" href="classCGAL_1_1Arrangement__with__history__2.html#a66661bfe6e4c7c0aae696dc4e9c8f20e">Arrangement_with_history_2::Curve_handle</a></code>, which is used for accessing the stored curves. For convenience, the corresponding constant-iterator and constant-handle types are also defined.</p>
<p>As mentioned in the previous paragraph, a <code>Curve_handle</code> object <code>ch</code> serves as a pointer to a curve stored in an arrangement-with-history object <code>arr</code>. Using this handle, it is possible to obtain the number of arrangement edges this curve induces by calling <a class="el" href="classCGAL_1_1Arrangement__on__surface__with__history__2.html#a736c888847f5cbe4223bff41b7cac58d"><code>arr.number_of_induced_edges(ch)</code></a>. The functions <a class="el" href="classCGAL_1_1Arrangement__on__surface__with__history__2.html#ad8430b861299627388f22056a956ae1d"><code>arr.induced_edges_begin(ch)</code></a> and <a class="el" href="classCGAL_1_1Arrangement__on__surface__with__history__2.html#accf9d2f8f20219060db5950c5224467f"><code>arr.induced_edges_end(ch)</code></a> return iterators of type <code>Arrangement_with_history_2::Induced_edges_iterator</code> that define the range of edges induced by <code>ch</code>. The value type of these iterators is <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#aaae449ff521205c5ba837143c431d3d3"><code>Halfedge_handle</code></a>. It is thus possible to traverse all arrangement edges induced by an input curve.</p>
<p>The ability to perform the inverse mapping is also important. Given an arrangement edge, you may want to determine which input curve induces it. In case the edge represents an overlap of several curves, you should be able to trace all input curves that overlap in this edge. The <code><a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a></code> class template is extended by several member functions that enable such an inverse mapping. Given a handle to halfedge <code>e</code> in an arrangement with history object <code>arr</code>, the call <a class="el" href="classCGAL_1_1Arrangement__on__surface__with__history__2.html#aefdc80dd47efc942dc1f445287627091"><code>arr.number_of_originating_curves(e)</code></a> returns the number of curves that induce the edge (which should be 1 in non-degenerate cases, and 2 or more in case of overlaps), while <a class="el" href="classCGAL_1_1Arrangement__on__surface__with__history__2.html#aec69b664d8dc3e7de12effed4fcda7bc"><code>arr.originating_curves_begin(e)</code></a> and <a class="el" href="classCGAL_1_1Arrangement__on__surface__with__history__2.html#a82d5f9d897f72653681a0897b3e6dfb9"><code>arr.originating_curves_end(e)</code></a> return <code><a class="el" href="classCGAL_1_1Arrangement__with__history__2.html#a81214726cd69ee6d0f50cd3b3c543342">Arrangement_with_history_2::Originating_curve_iterator</a></code> objects that define the range of curves that induce <code>e</code>. The value type of these iterators is <a class="el" href="classCGAL_1_1Arrangement__with__history__2.html#aa303273192e33c6f0c1fb3e6ca33d3c9"><code>Curve_2</code></a>.</p>
<p>Overlaying two arrangement-with-history objects is possible only if their types are instances of the <code><a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a>&lt;Traits,Dcel&gt;</code> class template, where the respective <code>Traits</code> parameters are substituted with two traits classes that are convertible to one another. In this case, the resulting arrangement stores a consolidated container of input curves, and automatically preserves the cross-mapping between the arrangement edges and the consolidated curve-set. You may also employ an overlay-traits class to maintain any type of auxiliary data stored with the DCEL cells; see Section <a class="el" href="index.html#arr_ssecoverlay">Overlaying Arrangements</a>.</p>
<h3><a class="anchor" id="arr_sssecmodif_traverse"></a>
Modifying an Arrangement with History</h3>
<p>The <code><a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a></code> class template extends the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> class template; thus, it inherits the fundamental modification operations, such as <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a9eccc63d91d51f0e1a100dc8d0927472"><code>assign()</code></a> and <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a61a86c3bc36e5c7bdd872f676f23ffbd"><code>clear()</code></a>, from it. The vertex-manipulation functions are also inherited and supported; see Sections <a class="el" href="index.html#arr_sssecmf_iso_verts">Manipulating Isolated Vertices</a> and <a class="el" href="index.html#arr_sssecinsert_point">Inserting Points</a> for details. However, there are some fundamental differences between the interfaces of the two class templates, which we highlight next.</p>
<p>The most significant difference between the arrangement-with-history class template and the basic arrangement class template is the way they handle their input curves. <code><a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a></code> always stores the <a class="el" href="classCGAL_1_1Arrangement__with__history__2.html#aa303273192e33c6f0c1fb3e6ca33d3c9"><code>Curve_2</code></a> objects that induce it. Thus, it is impossible to insert \(x\)-monotone curves into an arrangement with history. The free functions <code><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225" title="Inserts a given -monotone curve into a given arrangement, where the interior of the given curve is di...">insert_non_intersecting_curve()</a></code> and the version of <code><a class="el" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94" title="% inserts one or more curves or -monotone curves into a given arrangement, where no restrictions are ...">insert()</a></code> that accept \(x\)-monotone curves, as well as their aggregated versions), are therefore not available for arrangement-with-history instances. Only the free overloaded functions <code><a class="el" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94" title="% inserts one or more curves or -monotone curves into a given arrangement, where no restrictions are ...">insert()</a></code> that accept general curves, namely, the incremental insertion function and the aggregate insertion function, are supported; see Section <a class="el" href="index.html#aos_ssec-insert_gen">Inserting General Curves</a> for a review of these functions. Notice however that while the incremental insertion function <code>insert(arr, c)</code> for an <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> object <code>arr</code> does not have a return value, the corresponding arrangement-with-history function returns a <code>Curve_handle</code> object that points to the inserted curve.</p>
<p>As we are able to keep track of all edges induced by an input curve, we also provide a free function that removes a curve from an arrangement. By calling <code>remove_curve(arr,ch)</code>, where <code>ch</code> is a valid curve handle, the given curve is deleted from the curve container, and all edges induced solely by this curve (i.e., excluding overlapping edges) are removed from the arrangement. The function returns the number of edges that have been removed.</p>
<p>In some cases, users may need to operate directly on the arrangement edges. We first mention that the specialized insertion functions (see Section <a class="el" href="index.html#arr_sssecmf_insert_cv">Inserting Pairwise Disjoint x-Monotone Curves</a>) are not supported, as they accept \(x\)-monotone curves. Insertion can only be performed via the free insertion-functions. The other edge-manipulation functions (see Section <a class="el" href="index.html#arr_sssecmf_halfedges">Manipulating Halfedges</a>) are, however, available, but have a different interface that does not use \(x\)-monotone curves.</p>
<ul>
<li>
<p class="startli">Invoking <a class="el" href="classCGAL_1_1Arrangement__on__surface__with__history__2.html#a7e98f9636292c2463e3f77d37400a334"><code>split_edge(e,p)</code></a> splits the edge <code>e</code> at a given point <code>p</code> that lies in its interior.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Invoking <a class="el" href="classCGAL_1_1Arrangement__on__surface__with__history__2.html#a90d4e65838563799a880471fc45d2cf2"><code>merge_edge(e1,e2)</code></a> merges the two given edges. There is a precondition that <code>e1</code> and <code>e2</code> shared a common end-vertex of degree 2 prior to the merge, and that the \(x\)-monotone subcurves associated with these edges are mergeable.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">It is possible to remove an edge by simply invoking <a class="el" href="classCGAL_1_1Arrangement__on__surface__with__history__2.html#a7205ebb492267cfb8fafdcb1c635f265"><code>remove_edge(e)</code></a>.</p>
<p class="endli"></p>
</li>
</ul>
<p>In all cases, the maintenance of cross-pointers for the appropriate input curves will be done automatically.</p>
<p>Note that it is possible to attach observers to an arrangement-with-history object in order to get detailed notifications of the changes the arrangements undergoes; see Section <a class="el" href="index.html#arr_ssecnotif">The Notification Mechanism</a> for the details).</p>
<p><a class="anchor" id="fig__aos_fig-curve_history"></a></p><div class="image">
<img src="curve_history.png" alt="curve_history.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-curve_history">Figure 34.46</a> An arrangement with history as constructed in <a class="el" href="Arrangement_on_surface_2_2curve_history_8cpp-example.html">Arrangement_on_surface_2/curve_history.cpp</a>. Note that \(s_1\) and \(s_3\) overlap over two edges. The point-location query points \(q_1\), \(q_2\), and \(q_3\) are drawn as lightly shaded dots.  </div> <br /> 
<p>In the following example we construct a simple arrangement of six line segments, as depicted in <a class="el" href="index.html#fig__aos_fig-curve_history">Figure 34.46</a>, while maintaining the curve history. Note that the input segments \(s_1\) and \(s_3\) overlap over two edges. The example demonstrates the usage of the special traversal functions. It also shows how to issue point-location queries on the resulting arrangement (the query points \(q_1\), \(q_2\), and \(q_3\) are drawn as crosses), using the auxiliary function <code>locate_point()</code> defined in the header file <code>point_location_utils.h</code>; see also Section <a class="el" href="index.html#arr_ssecpl">Point-Location Queries</a>.</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2curve_history_8cpp-example.html">Arrangement_on_surface_2/curve_history.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Constructing an arrangement with curve history.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_with_history_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_trapezoid_ric_point_location.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_exact_construction_segments.h"</span></div><div class="line"><span class="preprocessor">#include "point_location_utils.h"</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__with__history__2.html">CGAL::Arrangement_with_history_2&lt;Traits&gt;</a>              Arr_with_hist;</div><div class="line"><span class="keyword">typedef</span> Arr_with_hist::Curve_handle                           Curve_handle;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__trapezoid__ric__point__location.html">CGAL::Arr_trapezoid_ric_point_location&lt;Arr_with_hist&gt;</a> Point_location;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <span class="comment">// Insert 3 curves incrementally.</span></div><div class="line">  Arr_with_hist arr;</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Segment(Point(0, 3), Point(4, 3)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Segment(Point(3, 2), Point(3, 5)));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Segment(Point(2, 3), Point(5, 3)));</div><div class="line"></div><div class="line">  <span class="comment">// Insert three additional segments aggregately.</span></div><div class="line">  Segment segs[] = {Segment(Point(2, 6), Point(7, 1)),</div><div class="line">                    Segment(Point(0, 0), Point(2, 6)),</div><div class="line">                    Segment(Point(3, 4), Point(6, 4))};</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, segs, segs + <span class="keyword">sizeof</span>(segs)/<span class="keyword">sizeof</span>(Segment));</div><div class="line"></div><div class="line">  <span class="comment">// Print out the curves and the number of edges each one induces.</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The arrangement contains "</span></div><div class="line">            &lt;&lt; arr.number_of_curves() &lt;&lt; <span class="stringliteral">" curves:\n"</span>;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> cit = arr.curves_begin(); cit != arr.curves_end(); ++cit)</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Curve ["</span> &lt;&lt; *cit &lt;&lt; <span class="stringliteral">"] induces "</span></div><div class="line">              &lt;&lt; arr.number_of_induced_edges(cit) &lt;&lt; <span class="stringliteral">" edges.\n"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Print the arrangement edges along with the list of curves that</span></div><div class="line">  <span class="comment">// induce each edge.</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The arrangement comprises "</span></div><div class="line">            &lt;&lt; arr.number_of_edges() &lt;&lt; <span class="stringliteral">" edges:\n"</span>;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> eit = arr.edges_begin(); eit != arr.edges_end(); ++eit) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; eit-&gt;curve() &lt;&lt; <span class="stringliteral">"]. Originating curves: "</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> ocit = arr.originating_curves_begin(eit);</div><div class="line">         ocit != arr.originating_curves_end(eit); ++ocit)</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">" ["</span> &lt;&lt; *ocit &lt;&lt; <span class="stringliteral">"]"</span> &lt;&lt; std::flush;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Perform some point-location queries.</span></div><div class="line">  Point_location pl(arr);</div><div class="line">  locate_point(pl, Point(4, 6));      <span class="comment">// q1</span></div><div class="line">  locate_point(pl, Point(6, 2));      <span class="comment">// q2</span></div><div class="line">  locate_point(pl, Point(2, 4));      <span class="comment">// q3</span></div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="fig__aos_fig-edge_manipulation_curve_hostory"></a></p><div class="image">
<img src="edge_manipulation_curve_history.png" alt="edge_manipulation_curve_history.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-edge_manipulation_curve_hostory">Figure 34.47</a> An arrangement with history of nine circles as constructed in <a class="el" href="Arrangement_on_surface_2_2edge_manipulation_curve_history_8cpp-example.html">Arrangement_on_surface_2/edge_manipulation_curve_history.cpp</a>. Note the vertical tangency points of \(c_0\), marked as dark dots, which subdivide this circle into an upper half and a lower half, each consists of 9 edges. The large circle \(c_0\) is eventually removed from the arrangement, with all 18 edges it induces.  </div> <br /> 
<p>The following example demonstrates the usage of the free <code><a class="el" href="group__PkgArrangementOnSurface2Funcs.html#gaa323bd67be0dc7cc326eb4f26653e326" title="Removes a given curve from a given arrangement. ">remove_curve()</a></code> function. We construct an arrangement of nine circles, while keeping a handle to each inserted circle. We then remove the large circle \(c_0\), which induces \(18\) edges, as depicted in <a class="el" href="index.html#fig__aos_fig-edge_manipulation_curve_hostory">Figure 34.47</a>. The example also shows how to use the <a class="el" href="classCGAL_1_1Arrangement__on__surface__with__history__2.html#a7e98f9636292c2463e3f77d37400a334"><code>split_edge()</code></a> and <a class="el" href="classCGAL_1_1Arrangement__on__surface__with__history__2.html#a90d4e65838563799a880471fc45d2cf2"><code>merge_edge()</code></a> member functions when operating on an arrangement-with-history object.</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2edge_manipulation_curve_history_8cpp-example.html">Arrangement_on_surface_2/edge_manipulation_curve_history.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Removing curves and manipulating edges in an arrangement with history.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_with_history_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_walk_along_line_point_location.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_circular.h"</span></div><div class="line"><span class="preprocessor">#include "arr_print.h"</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__with__history__2.html">CGAL::Arrangement_with_history_2&lt;Traits&gt;</a>                Arr_with_hist;</div><div class="line"><span class="keyword">typedef</span> Arr_with_hist::Curve_handle                             Curve_handle;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__walk__along__line__point__location.html">CGAL::Arr_walk_along_line_point_location&lt;Arr_with_hist&gt;</a> Point_location;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <span class="comment">// Construct an arrangement containing nine circles: C[0] of radius 2 and</span></div><div class="line">  <span class="comment">// C[1], ..., C[8] of radius 1.</span></div><div class="line">  <span class="keyword">const</span> Number_type _7_halves = Number_type(7) / Number_type(2);</div><div class="line">  Curve C[9];</div><div class="line"></div><div class="line">  C[0] = Circle(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>(_7_halves, _7_halves), 4, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga5aa0906f2432d414090dd8723c10f304">CGAL::CLOCKWISE</a>);</div><div class="line">  C[1] = Circle(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>(_7_halves, 6), 1, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga5aa0906f2432d414090dd8723c10f304">CGAL::CLOCKWISE</a>);</div><div class="line">  C[2] = Circle(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>(5, 6), 1, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga5aa0906f2432d414090dd8723c10f304">CGAL::CLOCKWISE</a>);</div><div class="line">  C[3] = Circle(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>(6, _7_halves), 1, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga5aa0906f2432d414090dd8723c10f304">CGAL::CLOCKWISE</a>);</div><div class="line">  C[4] = Circle(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>(5, 2), 1, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga5aa0906f2432d414090dd8723c10f304">CGAL::CLOCKWISE</a>);</div><div class="line">  C[5] = Circle(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>(_7_halves, 1), 1, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga5aa0906f2432d414090dd8723c10f304">CGAL::CLOCKWISE</a>);</div><div class="line">  C[6] = Circle(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>(2, 2), 1, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga5aa0906f2432d414090dd8723c10f304">CGAL::CLOCKWISE</a>);</div><div class="line">  C[7] = Circle(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>(1, _7_halves), 1, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga5aa0906f2432d414090dd8723c10f304">CGAL::CLOCKWISE</a>);</div><div class="line">  C[8] = Circle(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>(2, 5), 1, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__kernel__enums.html#ga5aa0906f2432d414090dd8723c10f304">CGAL::CLOCKWISE</a>);</div><div class="line"></div><div class="line">  Arr_with_hist arr;</div><div class="line">  Curve_handle handles[9];</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k = 0; k &lt; 9; ++k) handles[k] = <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, C[k]);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The initial arrangement size:\n"</span>;</div><div class="line">  print_arrangement_size(arr);</div><div class="line"></div><div class="line">  <span class="comment">// Remove the large circle C[0].</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Removing C[0]: "</span>;</div><div class="line">  std::cout &lt;&lt; <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gaa323bd67be0dc7cc326eb4f26653e326">remove_curve</a>(arr, handles[0])</div><div class="line">            &lt;&lt; <span class="stringliteral">" edges have been removed.\n"</span>;</div><div class="line">  print_arrangement_size(arr);</div><div class="line"></div><div class="line">  <span class="comment">// Locate the point q, which should be on an edge e.</span></div><div class="line">  Point_location pl(arr);</div><div class="line">  <span class="keyword">const</span> Point q{_7_halves, 7};</div><div class="line">  Point_location::result_type obj = pl.locate(q);</div><div class="line">  <span class="keyword">auto</span>* e = boost::get&lt;Arr_with_hist::Halfedge_const_handle&gt;(&amp;obj);</div><div class="line">  CGAL_assertion(e);</div><div class="line"></div><div class="line">  <span class="comment">// Split the edge e to two edges e1 and e2;</span></div><div class="line">  <span class="keyword">auto</span> e1 = arr.split_edge(arr.non_const_handle(*e), q);</div><div class="line">  <span class="keyword">auto</span> e2 = e1-&gt;next();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"After edge split:\n"</span>;</div><div class="line">  print_arrangement_size(arr);</div><div class="line"></div><div class="line">  <span class="comment">// Merge back the two split edges.</span></div><div class="line">  arr.merge_edge(e1, e2);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"After edge merge:\n"</span>;</div><div class="line">  print_arrangement_size(arr);</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="aos_sec-io"></a>
Input/Output Streams</h1>
<p>In some cases, one would like to save an arrangement object constructed by some application, so that later on it can be restored. In other cases one would like to create nice drawings that represent arrangements constructed by some application. These drawings can be hard printed or displayed on a computer screen.</p>
<h2><a class="anchor" id="aos_ssec-io-stream"></a>
Input/Output Stream</h2>
<p>Consider an arrangement that represents a very complicated geographical map, and assume that there are various applications that need to answer point-location queries on this map. Naturally, you can store the set of curves that induces the arrangement, but this implies that you would need to construct the arrangement from scratch each time you need to reuse it. A more efficient solution is to write the arrangement to a file in a format that other applications can read.</p>
<p>This package provides an <em>inserter</em> (the <code>&lt;&lt;</code> operator) and an <em>extractor</em> (the <code>&gt;&gt;</code> operator) for the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&lt;Traits,Dcel&gt;</code> class that inserts an arrangement object into an output stream and extracts an arrangement object from an input stream, respectively. The arrangement is written using a simple predefined ASCII format that encodes the arrangement topology, as well as all geometric entities associated with vertices and edges.</p>
<p>The ability to use the input/output operators, requires that the <a class="el" href="classArrangementBasicTraits__2.html#a8cfc873dc62ce86f9479c4689845d4b3"><code>Point_2</code></a> type and the <a class="el" href="classArrangementBasicTraits__2.html#a0fc1f7acfd69a5eae393294b6870a1d2"><code>X_monotone_curve_2</code></a> type defined by the traits class both support the <code>&lt;&lt;</code> and <code>&gt;&gt;</code> operators. The <code><a class="el" href="classCGAL_1_1Arr__conic__traits__2.html" title="The class Arr_conic_traits_2 is a model of the ArrangementTraits_2 concept and can be used to constru...">Arr_conic_traits_2</a></code> class (see Section <a class="el" href="index.html#arr_sssectr_conic">A Traits Class for Conic Arcs</a>), the <code><a class="el" href="classCGAL_1_1Arr__rational__function__traits__2.html" title="The traits class Arr_rational_function_traits_2 is a model of the ArrangementTraits_2 concept...">Arr_rational_function_traits_2</a></code> class (see Section <a class="el" href="index.html#arr_sssectr_ratfunc">A Traits Class for Arcs of Rational Functions</a>), and the <code><a class="el" href="classCGAL_1_1Arr__linear__traits__2.html" title="The traits class Arr_linear_traits_2 is a model of the ArrangementTraits_2 concept, which enables the construction and maintenance of arrangements of linear objects. ">Arr_linear_traits_2</a></code> class (see Section <a class="el" href="index.html#arr_ssectr_segs">Traits Classes for Line Segments and Linear Objects</a>) currently do not provide these operators for the geometric types they define. Thus, only arrangements of line segments or of polylines can be written or read.</p>
<p>The following example constructs the arrangement depicted in <a class="el" href="index.html#fig__aos_fig-special_edge_insertion">Figure 34.7</a> and writes it to an output file. It also demonstrates how to re-read the arrangement from a file.</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2io_8cpp-example.html">Arrangement_on_surface_2/io.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Using the arrangement I/O operators.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/Arr_iostream.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_inexact_construction_segments.h"</span></div><div class="line"><span class="preprocessor">#include "arr_print.h"</span></div><div class="line"><span class="preprocessor">#include "point_location_utils.h"</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <span class="comment">// Construct the arrangement.</span></div><div class="line">  Arrangement arr1;</div><div class="line">  construct_segments_arr(arr1);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Writing\n"</span>;</div><div class="line">  print_arrangement_size(arr1);</div><div class="line"></div><div class="line">  <span class="comment">// Write the arrangement to a file.</span></div><div class="line">  std::ofstream out_file(<span class="stringliteral">"arr_ex_io.dat"</span>);</div><div class="line">  out_file &lt;&lt; arr1;</div><div class="line">  out_file.close();</div><div class="line"></div><div class="line">  <span class="comment">// Read the arrangement from the file.</span></div><div class="line">  Arrangement arr2;</div><div class="line">  std::ifstream in_file(<span class="stringliteral">"arr_ex_io.dat"</span>);</div><div class="line">  in_file &gt;&gt; arr2;</div><div class="line">  in_file.close();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Reading\n"</span>;</div><div class="line">  print_arrangement_size(arr2);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="arr_ssecarr_io_aux_data"></a>
Arrangements with Auxiliary Data</h2>
<p> </p><div class="CGALAdvanced"> <div>Advanced</div> 
<p>The inserter and extractor both ignore any auxiliary data stored with the arrangement features. Thus, they are ideal for arrangements instantiated using the <code><a class="el" href="classCGAL_1_1Arr__default__dcel.html" title="The default DCEL class used by the Arrangement_2 class-template is parameterized by a traits class...">Arr_default_dcel</a></code> class. However, as explained in Section <a class="el" href="index.html#arr_ssecex_dcel">Extending the DCEL</a>, one can easily extend the arrangement faces by using the <code><a class="el" href="classCGAL_1_1Arr__face__extended__dcel.html" title="The Arr_face_extended_dcel class-template extends the DCEL face-records, making it possible to store ...">Arr_face_extended_dcel</a></code> template, or extend all DCEL records by using the <code><a class="el" href="classCGAL_1_1Arr__extended__dcel.html" title="The Arr_extended_dcel class-template extends the topological-features of the DCEL namely the vertex...">Arr_extended_dcel</a></code> template. In such cases, it might be crucial that the auxiliary data fields are written to the file and read from there.</p>
<p>The arrangement package includes the free functions <code>write(arr, os, formatter)</code>, which writes the arrangement <code>arr</code> to an output stream <code>os</code>, and <code>read(arr, os, formatter)</code>, which reads the arrangement <code>arr</code> from an input stream <code>is</code>. Both operations are performed using a <code>formatter</code> object, which defines the I/O format. The package contains three formatter classes: </p><ul>
<li>
<code><a class="el" href="classCGAL_1_1Arr__text__formatter.html" title="Arr_text_formatter defines the format of an arrangement in an input or output stream (typically a fil...">Arr_text_formatter</a>&lt;Arrangement&gt;</code> defines a simple textual I/O format for the arrangement topology and geometry, disregarding any auxiliary data that may be associated with the arrangement features. This is the default formatter used by the arrangement inserter and the arrangement extractor, as defined above. </li>
<li>
<code><a class="el" href="classCGAL_1_1Arr__face__extended__text__formatter.html" title="Arr_face_extended_text_formatter defines the format of an arrangement in an input or output stream (t...">Arr_face_extended_text_formatter</a>&lt;Arrangement&gt;</code> operates on arrangements whose DCEL representation is based on the <code><a class="el" href="classCGAL_1_1Arr__face__extended__dcel.html" title="The Arr_face_extended_dcel class-template extends the DCEL face-records, making it possible to store ...">Arr_face_extended_dcel</a>&lt;Traits,FaceData&gt;</code> class (see Section <a class="el" href="index.html#arr_sssecex_dcel_face">Extending the DCEL Faces</a>). It supports reading and writing the auxiliary data objects stored with the arrangement faces provided that the <code>FaceData</code> class supports an inserter and an extractor. </li>
<li>
<code><a class="el" href="classCGAL_1_1Arr__extended__dcel__text__formatter.html" title="Arr_extended_dcel_text_formatter defines the format of an arrangement in an input or output stream (t...">Arr_extended_dcel_text_formatter</a>&lt;Arrangement&gt;</code> operates on arrangements whose DCEL representation is based on the <code><a class="el" href="classCGAL_1_1Arr__extended__dcel.html" title="The Arr_extended_dcel class-template extends the topological-features of the DCEL namely the vertex...">Arr_extended_dcel</a>&lt;Traits,VertexData,HalfedgeData,FaceData&gt;</code> class (see Section <a class="el" href="index.html#arr_sssecex_dcel_all">Extending All DCEL Records</a>). It supports reading and writing the auxiliary data objects stored with the arrangement vertices, edges and faces, provided that the <code>VertexData</code>, <code>HalfedgeData</code> and <code>FaceData</code> classed all have inserters and extractors. </li>
</ul>
<p>The following example constructs the same arrangement as the example <code>dcel_extension</code> does (see Section <a class="el" href="index.html#arr_sssecex_dcel_all">Extending All DCEL Records</a>), depicted in <a class="el" href="index.html#fig__aos_fig-dcel_extension">Figure 34.42</a>, and writes it to an output file. It also demonstrates how to re-read the arrangement from a file:</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2dcel_extension_io_8cpp-example.html">Arrangement_on_surface_2/dcel_extension_io.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Using the I/O operators for arrangements with extended DCEL records.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_extended_dcel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/Arr_iostream.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/Arr_text_formatter.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_exact_construction_segments.h"</span></div><div class="line"></div><div class="line"><span class="keyword">enum</span> Color {BLUE, RED, WHITE};</div><div class="line"></div><div class="line">std::ostream&amp; <a class="code" href="group__PkgArrangementOnSurface2op__left__shift.html#ga1d41d87be91090b47c095e878251d6f0">operator&lt;&lt;</a>(std::ostream&amp; os, <span class="keyword">const</span> Color&amp; color) {</div><div class="line">  <span class="keywordflow">switch</span> (color) {</div><div class="line">   <span class="keywordflow">case</span> BLUE: os &lt;&lt; <span class="stringliteral">"BLUE"</span>;  <span class="keywordflow">break</span>;</div><div class="line">   <span class="keywordflow">case</span> RED: os &lt;&lt; <span class="stringliteral">"RED"</span>;   <span class="keywordflow">break</span>;</div><div class="line">   <span class="keywordflow">case</span> WHITE: os &lt;&lt; <span class="stringliteral">"WHITE"</span>; <span class="keywordflow">break</span>;</div><div class="line">   <span class="keywordflow">default</span>: os &lt;&lt; <span class="stringliteral">"ERROR!"</span>;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> os;</div><div class="line">}</div><div class="line"></div><div class="line">std::istream&amp; <a class="code" href="group__PkgArrangementOnSurface2op__right__shift.html#gad6a067ca598edefd04a6698f64cc8215">operator&gt;&gt;</a>(std::istream&amp; is, Color&amp; color) {</div><div class="line">  std::string str;</div><div class="line">  is &gt;&gt; str;</div><div class="line">  <span class="keywordflow">if</span> (str == <span class="stringliteral">"BLUE"</span>) color = BLUE;</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (str == <span class="stringliteral">"RED"</span>) color = RED;</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (str == <span class="stringliteral">"WHITE"</span>) color = WHITE;</div><div class="line">  <span class="keywordflow">return</span> is;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__extended__dcel.html">CGAL::Arr_extended_dcel&lt;Traits, Color, bool, int&gt;</a>       Ext_dcel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits, Ext_dcel&gt;</a>                   Ext_arrangement;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__extended__dcel__text__formatter.html">CGAL::Arr_extended_dcel_text_formatter&lt;Ext_arrangement&gt;</a> Formatter;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <span class="comment">// Construct the arrangement containing two intersecting triangles.</span></div><div class="line">  Ext_arrangement arr;</div><div class="line"></div><div class="line">  Segment s1(Point(4, 1), Point(7, 6));</div><div class="line">  Segment s2(Point(1, 6), Point(7, 6));</div><div class="line">  Segment s3(Point(4, 1), Point(1, 6));</div><div class="line">  Segment s4(Point(1, 3), Point(7, 3));</div><div class="line">  Segment s5(Point(1, 3), Point(4, 8));</div><div class="line">  Segment s6(Point(4, 8), Point(7, 3));</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr, s1);</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr, s2);</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr, s3);</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, s4);</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, s5);</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, s6);</div><div class="line"></div><div class="line">  <span class="comment">// Go over all arrangement vertices and set their colors.</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> vit = arr.vertices_begin(); vit != arr.vertices_end(); ++vit) {</div><div class="line">    <span class="keyword">auto</span> degree = vit-&gt;degree();</div><div class="line">    <span class="keywordflow">if</span> (degree == 0) vit-&gt;set_data(BLUE);      <span class="comment">// Isolated vertex</span></div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (degree &lt;= 2) vit-&gt;set_data(RED);  <span class="comment">// Vertex represents an endpoint</span></div><div class="line">    <span class="keywordflow">else</span> vit-&gt;set_data(WHITE);      <span class="comment">// Vertex represents an intersection point</span></div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Go over all arrangement edges and set their flags.</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> eit = arr.edges_begin(); eit != arr.edges_end(); ++eit) {</div><div class="line">    <span class="comment">// Check if the halfedge has the same direction as its associated</span></div><div class="line">    <span class="comment">// segment. Note that its twin always has an opposite direction.</span></div><div class="line">    <span class="keyword">auto</span> flag = (eit-&gt;source()-&gt;point() == eit-&gt;curve().source());</div><div class="line">    eit-&gt;set_data(flag);</div><div class="line">    eit-&gt;twin()-&gt;set_data(! flag);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Go over all arrangement faces and print their outer boundary and indices.</span></div><div class="line">  <span class="keywordtype">int</span> boundary_size;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> fit = arr.faces_begin(); fit != arr.faces_end(); ++fit) {</div><div class="line">    boundary_size = 0;</div><div class="line">    <span class="keywordflow">if</span> (! fit-&gt;is_unbounded()) {</div><div class="line">      <span class="keyword">auto</span> curr = fit-&gt;outer_ccb();</div><div class="line">      <span class="keywordflow">do</span> ++boundary_size;</div><div class="line">      <span class="keywordflow">while</span> (++curr != fit-&gt;outer_ccb());</div><div class="line">    }</div><div class="line">    fit-&gt;set_data(boundary_size);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Write the arrangement to a file.</span></div><div class="line">  std::ofstream out_file(<span class="stringliteral">"arr_ex_dcel_io.dat"</span>);</div><div class="line">  Formatter formatter;</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Write.html#gac12d9100363a7d24af40336af2ed4855">CGAL::IO::write</a>(arr, out_file, formatter);</div><div class="line">  out_file.close();</div><div class="line"></div><div class="line">  <span class="comment">// Read the arrangement from the file.</span></div><div class="line">  Ext_arrangement arr2;</div><div class="line">  std::ifstream in_file(<span class="stringliteral">"arr_ex_dcel_io.dat"</span>);</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Read.html#ga02bd2845bba9c4501e2f9fc8a5128b8b">CGAL::IO::read</a>(arr2, in_file, formatter);</div><div class="line">  in_file.close();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The arrangement vertices:\n"</span>;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> vit = arr2.vertices_begin(); vit != arr2.vertices_end(); ++vit)</div><div class="line">    std::cout &lt;&lt; <span class="charliteral">'('</span> &lt;&lt; vit-&gt;point() &lt;&lt; <span class="stringliteral">") - "</span> &lt;&lt; vit-&gt;data() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>You may develop your own formatter classes - models of the <code><a class="el" href="classArrangementInputFormatter.html" title="A model for the ArrangementInputFormatter concept supports a set of functions that enable reading an ...">ArrangementInputFormatter</a></code> and <code><a class="el" href="classArrangementOutputFormatter.html" title="A model for the ArrangementOutputFormatter concept supports a set of functions that enable writing an...">ArrangementOutputFormatter</a></code> concepts, as defined in the Reference Manual. Doing so, you can define other I/O formats, such as an XML-based format or a binary format.  </p></div> 
<h2><a class="anchor" id="arr_ssecarr_io_hist"></a>
Arrangements with Curve History</h2>
<p>Section <a class="el" href="index.html#arr_ssecarr_with_hist">Storing the Curve History</a> introduces the <code><a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a>&lt;Traits,Dcel&gt;</code> class, which saves the set of curves inducing an arrangement and maintains the relations between these curves and the edges they induce. Naturally, when reading or writing an arrangement-with-history instance we would like this information to be saved to the output stream or restored from the input stream alongside with the basic arrangement structure.</p>
<p>The arrangement package supplies an inserter and an extractor for the <code><a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a>&lt;Traits,Dcel&gt;</code> class. The arrangement is represented using a simple predefined ASCII format. An object of the <code><a class="el" href="classCGAL_1_1Arrangement__with__history__2.html">Arrangement_with_history_2</a>&lt;Traits,Dcel&gt;</code> type can be saved and restored, as long as the <a class="el" href="classCGAL_1_1Arrangement__with__history__2.html#aa303273192e33c6f0c1fb3e6ca33d3c9"><code>Curve_2</code></a> type defined by the traits class—as well as the <a class="el" href="classCGAL_1_1Arrangement__with__history__2.html#ad7955c45cc6c5fc356b49bcad2c175f8"><code>Point_2</code></a> type and the <a class="el" href="classCGAL_1_1Arrangement__with__history__2.html#ad368cff686575c0a5104f580c1f66d6d"><code>X_monotone_curve_2</code></a> types—support the <code>&lt;&lt;</code> and<code>&gt;&gt;</code> operators.</p>
<p>The following example constructs the same arrangement as example <code>curve_history</code> does, depicted in <a class="el" href="index.html#fig__aos_fig-curve_history">Figure 34.46</a>, and writes it to an output file. It also demonstrates how to re-read the arrangement-with-history from a file:</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2io_curve_history_8cpp-example.html">Arrangement_on_surface_2/io_curve_history.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Using the arrangement-with-history I/O operators.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/basic.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arrangement_with_history_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/Arr_with_history_iostream.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_exact_construction_segments.h"</span></div><div class="line"><span class="preprocessor">#include "arr_print.h"</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__with__history__2.html">CGAL::Arrangement_with_history_2&lt;Traits&gt;</a>        Arr_with_hist;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <span class="comment">// Insert six additional segments aggregately:</span></div><div class="line">  Segment segs[6];</div><div class="line">  segs[0] = Segment(Point(2, 6), Point(7, 1));</div><div class="line">  segs[1] = Segment(Point(3, 2), Point(3, 5));</div><div class="line">  segs[2] = Segment(Point(2, 3), Point(5, 3));</div><div class="line">  segs[3] = Segment(Point(2, 6), Point(7, 1));</div><div class="line">  segs[4] = Segment(Point(0, 0), Point(2, 6));</div><div class="line">  segs[5] = Segment(Point(3, 4), Point(6, 4));</div><div class="line"></div><div class="line">  Arr_with_hist arr1;</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr1, segs, segs + 6);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Writing an arrangement of "</span></div><div class="line">            &lt;&lt; arr1.number_of_curves() &lt;&lt; <span class="stringliteral">" input segments:\n"</span>;</div><div class="line">  print_arrangement_size(arr1);</div><div class="line"></div><div class="line">  <span class="comment">// Write the arrangement to a file.</span></div><div class="line">  std::ofstream out_file(<span class="stringliteral">"arr_ex_io_hist.dat"</span>);</div><div class="line">  out_file &lt;&lt; arr1;</div><div class="line">  out_file.close();</div><div class="line"></div><div class="line">  <span class="comment">// Read the arrangement from the file.</span></div><div class="line">  Arr_with_hist arr2;</div><div class="line">  std::ifstream in_file(<span class="stringliteral">"arr_ex_io_hist.dat"</span>);</div><div class="line">  in_file &gt;&gt; arr2;</div><div class="line">  in_file.close();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Read an arrangement of "</span></div><div class="line">            &lt;&lt; arr2.number_of_curves() &lt;&lt; <span class="stringliteral">" input segments:\n"</span>;</div><div class="line">  print_arrangement_size(arr2);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> </p><div class="CGALAdvanced"> <div>Advanced</div> 
<p>The arrangement package also includes the free functions <code>write(arr, os, formatter)</code> and <code>read(arr, os, formatter)</code> that operate on a given arrangement-with-history instance <code>arr</code>. Both functions are parameterized by a <code>formatter</code> object, which defines the I/O format. The package contains a template called, <code>Arr_with_hist_text_formatter&lt;ArranagmentFormatter&gt;</code>, which extends an arrangement formatter class (see Section <a class="el" href="index.html#arr_ssecarr_io_aux_data">Arrangements with Auxiliary Data</a>) and defines a simple textual input/output format.  </p></div> 
<h1><a class="anchor" id="aos_sec-bgl"></a>
Adapting to Boost Graphs</h1>
<p>Boost<span class="footnote">See also Boost's homepage at: <code>www.boost.org</code>.</span> is a collection of portable C++ libraries that extend the C++ Standard Library. The Boost Graph Library (BGL), which one of the libraries in the collection, offers an extensive set of generic graph algorithms parameterized through templates. As our arrangements are embedded as planar graphs, it is only natural to extend the underlying data structure with the interface that the BGL expects, and gain the ability to perform the operations that the BGL supports, such as shortest-path computation. This section describes how to apply the graph algorithms implemented in the BGL to <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> instances.</p>
<p>An instance of <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> is adapted to a Boost graph through the provision of a set of free functions that operate on the arrangement features and conform with the relevant BGL concepts. Besides the straightforward adaptation, which associates a vertex with each DCEL vertex and an edge with each DCEL halfedge, the package also offer a <em>dual</em> adaptor, which associates a graph vertex with each DCEL face, such that two vertices are connected, iff there is a DCEL halfedge that connects the two corresponding faces.</p>
<h2><a class="anchor" id="arr_ssecbgl_primal"></a>
The Primal Arrangement Representation</h2>
<p>Arrangement instances are adapted to Boost graphs by specializing the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLTraits.html#BGLArgtGT"><code>boost::graph_traits</code> </a> template for <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> instances. The graph-traits states the graph concepts that the arrangement class models (see below) and defines the types required by these concepts.</p>
<p>In this specialization the <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> vertices correspond to the graph vertices, where two vertices are adjacent if there is at least one halfedge connecting them. More precisely, <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a43113edb82930474c25b57b9a8e2143f"><code>Vertex_handle</code></a> is the graph-vertex type, while <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#aaae449ff521205c5ba837143c431d3d3"><code>Halfedge_handle</code></a> is the graph-edge type. As halfedges are directed, we consider the graph to be directed as well. Moreover, as several interior-disjoint \(x\)-monotone curves (say circular arcs) may share two common endpoints, inducing an arrangement with two vertices that are connected with several edges, we allow parallel edges in our Boost.</p>
<p>Given an <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code> instance, we can efficiently traverse its vertices and halfedges. Thus, the arrangement graph is a model of the concepts <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/classVertexListGraph.html">VertexListGraph</a></code> and <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/classEdgeListGraph.html">EdgeListGraph</a></code> introduced by the BGL. At the same time, we use an iterator adapter of the circulator over the halfedges incident to a vertex (<code>Halfedge_around_vertex_circulator</code> - see Section <a class="el" href="index.html#arr_sssectr_vertex">Traversal Methods for an Arrangement Vertex</a>), so it is possible to go over the ingoing and outgoing edges of a vertex in linear time. Thus, our arrangement graph is a model of the concept <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classBidirectionalGraph.html">BidirectionalGraph</a></code> (this concept refines <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classIncidenceGraph.html">IncidenceGraph</a></code>, which requires only the traversal of outgoing edges).</p>
<p>It is important to notice that the vertex descriptors we use are <a class="el" href="classCGAL_1_1Arrangement__2.html">Vertex_handle <code>Vertex_handle</code></a> objects and <em>not</em> vertex indices. However, in order to gain more efficiency in most BGL algorithms, it is better to have them indexed \(0, 1, \ldots, (n-1)\), where \(n\) is the number of vertices. We therefore introduce the <code><a class="el" href="classCGAL_1_1Arr__vertex__index__map.html" title="Arr_vertex_index_map maintains a mapping of vertex handles of an attached arrangement object to indic...">Arr_vertex_index_map</a>&lt;Arrangement&gt;</code> class-template, which maintains a mapping of vertex handles to indices, as required by the BGL. An instance of this class must be attached to a valid arrangement vertex when it is created. It uses the notification mechanism (see Section <a class="el" href="index.html#arr_ssecnotif">The Notification Mechanism</a>) to automatically maintain the mapping of vertices to indices, even when new vertices are inserted into the arrangement or existing vertices are removed.</p>
<p>In most algorithms provided by the BGL, the output is given by <em>property maps</em>, such that each map entry corresponds to a vertex. For example, when we compute the shortest paths from a given source vertex \(s\) to all other vertices we can obtain a map of distances and a map of predecessors - namely for each \(v\) vertex we have its distance from \(s\) and a descriptor of the vertex that precedes \(v\) in a shortest path from \(s\).</p>
<p>If the vertex descriptors are simply indices, boost supplies tools to easily represent property maps using vectors. The <code><a class="el" href="classCGAL_1_1Arr__vertex__index__map.html" title="Arr_vertex_index_map maintains a mapping of vertex handles of an attached arrangement object to indic...">Arr_vertex_index_map</a>&lt;Arrangement&gt;</code> class template enables the creation of such indices, and together with <code>boost::vector_property_map&lt;Type, IndexMap&gt;</code> it generates an efficient mapping from <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a43113edb82930474c25b57b9a8e2143f"><code>Vertex_handle</code></a> objects to properties of type <code>Type</code>. Note, however, that unlike the <code><a class="el" href="classCGAL_1_1Arr__vertex__index__map.html" title="Arr_vertex_index_map maintains a mapping of vertex handles of an attached arrangement object to indic...">Arr_vertex_index_map</a></code> class template, the vertex property-map class is not kept synchronized with the number of vertices in the arrangement, so it should not be reused in calls to BGL functions in case the arrangement is modified in between these calls.</p>
<p>The first example of this section demonstrates the application of Dijkstra's shortest path algorithm to compute the shortest-path length between a given vertex of an arrangement of linear curves and all other vertices. The length of a path is defined as the sum of squared Euclidean lengths of its segments. It uses an instance of the functor template <code>Edge_length&lt;Arrangement&gt;}</code> to compute the squared Euclidean length of the linear curve associated with a given halfedge of the arrangement. The functor implements a Boost property-map that attaches square lengths to edges; when the BGL algorithm queries the property map for a squared length of an edge the property map computes and returns it. The functor template is defined in the header file <code>Edge_length.h</code>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">CGAL::Exact_predicates_exact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a>                                        Number_type;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Arrangement&gt; <span class="keyword">struct </span>Edge_length {</div><div class="line">  <span class="comment">// Boost property-type definitions.</span></div><div class="line">  <span class="keyword">typedef</span> boost::readable_property_map_tag      category;</div><div class="line">  <span class="keyword">typedef</span> Number_type                           value_type;</div><div class="line">  <span class="keyword">typedef</span> value_type                            reference;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Arrangement::Halfedge_handle key_type;</div><div class="line"></div><div class="line">  value_type operator()(<span class="keyword">typename</span> Arrangement::Halfedge_handle e)<span class="keyword"> const </span>{</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> diff_x = e-&gt;target()-&gt;point().x() - e-&gt;source()-&gt;point().x();</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> diff_y = e-&gt;target()-&gt;point().y() - e-&gt;source()-&gt;point().y();</div><div class="line">    <span class="keywordflow">return</span> diff_x * diff_x + diff_y * diff_y;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">friend</span> value_type <span class="keyword">get</span>(<span class="keyword">const</span> Edge_length&amp; edge_length, key_type key)</div><div class="line">  { <span class="keywordflow">return</span> edge_length(key); }</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="fig__aos_fig-bgl_primal_adapter"></a></p><div class="image">
<img src="bgl_primal_adapter.png" alt="bgl_primal_adapter.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-bgl_primal_adapter">Figure 34.48</a> An arrangement of seven line segments, as constructed by <a class="el" href="Arrangement_on_surface_2_2bgl_primal_adapter_8cpp-example.html">Arrangement_on_surface_2/bgl_primal_adapter.cpp</a> and <a class="el" href="Arrangement_on_surface_2_2bgl_dual_adapter_8cpp-example.html">Arrangement_on_surface_2/bgl_dual_adapter.cpp</a>.  </div> <br /> 
<p>In the following example we construct an arrangement of seven line segments, as shown in <a class="el" href="index.html#fig__aos_fig-bgl_primal_adapter">Figure 34.48</a>. Then, it uses the BGL generic implementation of Dijkstra's shortest-paths algorithm to compute the sum of squared distances to all vertices from the lexicographically smallest vertex \(v_0\) in the arrangement. Note the usage of the <code>Arr_vertex_property_map</code> class template in the call to <code>boost::dijkstra_shortest_paths()</code> and in the definition of the distance property-map. We instantiate a property map that attaches a number of type <code>Number_type</code> (which is a type of unlimited precision) to each vertex. The number represents the sum of squared distances of the vertex from \(v_0\).</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2bgl_primal_adapter_8cpp-example.html">Arrangement_on_surface_2/bgl_primal_adapter.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Adapting an arrangement to a BGL graph.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/config.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/graph/dijkstra_shortest_paths.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/property_map/vector_property_map.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/graph_traits_Arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_vertex_index_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "arr_exact_construction_segments.h"</span></div><div class="line"><span class="preprocessor">#include "Edge_length.h"</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__vertex__index__map.html">CGAL::Arr_vertex_index_map&lt;Arrangement&gt;</a>  Vertex_index_map;</div><div class="line"><span class="keyword">typedef</span> Edge_length&lt;Arrangement&gt;                 My_edge_length;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <span class="comment">// Construct an arrangement of seven intersecting line segments.</span></div><div class="line">  <span class="comment">// We keep a handle for the vertex v0 that corresponds to the point (1,1).</span></div><div class="line">  Point p1(1, 1), p2(1, 4), p3(2, 2), p4(3, 7), p5(4, 4), p6(7, 1), p7(9, 3);</div><div class="line">  Arrangement arr;</div><div class="line">  Segment s(p1, p6);</div><div class="line">  Arrangement::Halfedge_handle e = <a class="code" href="group__PkgArrangementOnSurface2Funcs.html#gad453feb3ff2f60a9741bf9d2917bf225">insert_non_intersecting_curve</a>(arr, s);</div><div class="line">  Arrangement::Vertex_handle v0 = e-&gt;source();</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Segment(p1, p4));  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Segment(p2, p6));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Segment(p3, p7));  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Segment(p3, p5));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Segment(p6, p7));  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Segment(p4, p7));</div><div class="line"></div><div class="line">  <span class="comment">// Create a mapping of the arrangement vertices to indices.</span></div><div class="line">  Vertex_index_map index_map(arr);</div><div class="line"></div><div class="line">  <span class="comment">// Create a property map based on std::vector to keep the result distances.</span></div><div class="line">  boost::vector_property_map&lt;Number_type, Vertex_index_map&gt;</div><div class="line">    dist_map(static_cast&lt;unsigned int&gt;(arr.number_of_vertices()), index_map);</div><div class="line"></div><div class="line">  <span class="comment">// Perform Dijkstra's algorithm from the vertex v0.</span></div><div class="line">  My_edge_length edge_length;</div><div class="line">  boost::dijkstra_shortest_paths(arr, v0, boost::vertex_index_map(index_map).</div><div class="line">                                 weight_map(edge_length).distance_map(dist_map).</div><div class="line">                                 distance_zero(Number_type(0)).</div><div class="line">                                 distance_inf(Number_type(1000)));</div><div class="line"></div><div class="line">  <span class="comment">// Print the distance of each vertex from v0.</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The graph distances of the arrangement vertices from ("</span></div><div class="line">            &lt;&lt; v0-&gt;point() &lt;&lt; <span class="stringliteral">") :\n"</span>;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> vit = arr.vertices_begin(); vit != arr.vertices_end(); ++vit)</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"("</span> &lt;&lt; vit-&gt;point() &lt;&lt; <span class="stringliteral">") at distance "</span></div><div class="line">              &lt;&lt; <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1f1bcd74fce34fd532445590bbda5cd5">CGAL::to_double</a>(dist_map[vit]) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="arr_ssecbgl_dual"></a>
The Dual Arrangement Representation</h2>
<p>An arrangement instance can be represented as a graph other than the one described in the previous section. A dual-graph representation refers to the graph, where each arrangement face corresponds to a graph vertex, and two vertices are adjacent iff the corresponding faces share a common edge on their boundaries. This is done by specializing the <code>boost::graph_traits</code> template for <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/classCGAL_1_1Dual.html">Dual</a>&lt;<a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&gt;</code> instances, where <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/classCGAL_1_1Dual.html">Dual</a>&lt;<a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a>&gt;</code> is a template specialization that gives a dual interpretation to an arrangement instance.</p>
<p>In a dual representation, <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a5c97d46fc76cf9ab96ceced3b795b3c9"><code>Face_handle</code></a> is the graph-vertex type, while <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#aaae449ff521205c5ba837143c431d3d3"><code>Halfedge_handle</code></a> is the graph-edge type. We treat the graph edges as directed, such that a halfedge <code>e</code> is directed from \(f_1\), which is its incident face, to \(f_2\), which is the incident face of its twin halfedge. As two arrangement faces may share more than a single edge on their boundary, we allow parallel edges (loops) in our Boost graph. As is the case in the primal graph, the dual arrangement graph is also a model of the concepts <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/classVertexListGraph.html">VertexListGraph</a></code>, <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/classEdgeListGraph.html">EdgeListGraph</a></code> and <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classBidirectionalGraph.html">BidirectionalGraph</a></code> (thus also of <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classIncidenceGraph.html">IncidenceGraph</a></code>).</p>
<p>Since we use <a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a5c97d46fc76cf9ab96ceced3b795b3c9"><code>Face_handle</code></a> objects as the vertex descriptors, we define the <code><a class="el" href="classCGAL_1_1Arr__face__index__map.html" title="Arr_face_index_map maintains a mapping of face handles of an attached arrangement object to indices (...">Arr_face_index_map</a>&lt;Arrangement&gt;</code> class-template, which maintains an efficient mapping of face handles to indices.</p>
<p>The next example demonstrates how a property map can be used to update or receive information directly from a feature of the arrangement without the need to search for its index. The example also demonstrates the application of the breadth-first search} (BFS) algorithm on a dual arrangement. It uses the functor template <code>Extended_face_property_map&lt;Arrangement, Type&gt;</code> to directly access information stored inside the faces. The functor implements a property map that utilizes the <code>data()</code> and `set_data() member functions of the extended face to update or obtain the property. When the property map is instantiated, the <code>Type</code> parameter must be substituted with the same type that is used to extend the arrangement face; see Section <a class="el" href="index.html#arr_sssecex_dcel_face">Extending the DCEL Faces</a>. The functor template is defined in the header file <code>Extended_face_property_map.h</code> listed below.</p>
<div class="fragment"><div class="line"><span class="comment">// A property map that reads/writes the information to/from the extended face.</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Arrangement, <span class="keyword">class</span> Type&gt; <span class="keyword">class </span>Extended_face_property_map {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Arrangement::Face_handle       Face_handle;</div><div class="line"></div><div class="line">  <span class="comment">// Boost property type definitions.</span></div><div class="line">  <span class="keyword">typedef</span> boost::read_write_property_map_tag      category;</div><div class="line">  <span class="keyword">typedef</span> Type                                    value_type;</div><div class="line">  <span class="keyword">typedef</span> value_type&amp;                             reference;</div><div class="line">  <span class="keyword">typedef</span> Face_handle                             key_type;</div><div class="line"></div><div class="line">  <span class="comment">// The get function is required by the property map concept.</span></div><div class="line">  <span class="keyword">friend</span> reference <span class="keyword">get</span>(<span class="keyword">const</span> Extended_face_property_map&amp; map, key_type key)</div><div class="line">  { <span class="keywordflow">return</span> key-&gt;data(); }</div><div class="line"></div><div class="line">  <span class="comment">// The put function is required by the property map concept.</span></div><div class="line">  <span class="keyword">friend</span> <span class="keywordtype">void</span> put(<span class="keyword">const</span> Extended_face_property_map&amp; map,</div><div class="line">                  key_type key, value_type val)</div><div class="line">  { key-&gt;set_data(val); }</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="fig__aos_fig-bgl_dual_adapter"></a></p><div class="image">
<img src="bgl_dual_adapter.png" alt="bgl_dual_adapter.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__aos_fig-bgl_dual_adapter">Figure 34.49</a> An arrangement of seven line segments, as constructed by <a class="el" href="Arrangement_on_surface_2_2bgl_dual_adapter_8cpp-example.html">Arrangement_on_surface_2/bgl_dual_adapter.cpp</a> and its dual face graph, where every arrangement face is a vertex of the graph. The index of a dual vertex is the discovery time of a breadth-first search applied to the face graph, starting from the unbounded face \(f_0\).  </div> <br /> 
<p>The following example constructs the same arrangement constructed by the program coded in <a class="el" href="Arrangement_on_surface_2_2bgl_primal_adapter_8cpp-example.html">Arrangement_on_surface_2/bgl_primal_adapter.cpp</a>; see <a class="el" href="index.html#fig__aos_fig-bgl_primal_adapter">Figure 34.48</a>. Then, it performs a breadth-first search traversal on the face graph, starting from the unbounded face. The DCEL faces are extended with an unsigned integer indicating the discovered time of the face. The code uses a visitor that obtains the times and writes them into a property map that updates the faces accordingly. <a class="el" href="index.html#fig__aos_fig-bgl_dual_adapter">Figure 34.49</a> shows the graph dual to the arrangement. It is clear that the unbounded face \(f_0\) is discovered at time \(0\), the neighboring faces \(f_1\), \(f_3\), and \(f_4\) are discovered at times \(1\), \(2\), and \(3\), and finally \(f_2\) is discovered at time \(4\).</p>
<p><br />
<b>File</b> <a class="el" href="Arrangement_on_surface_2_2bgl_dual_adapter_8cpp-example.html">Arrangement_on_surface_2/bgl_dual_adapter.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// Adapting the dual of an arrangement to a BGL graph.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/config.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/graph/breadth_first_search.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/graph/visitors.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_extended_dcel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/graph_traits_dual_arrangement_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_face_index_map.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "Extended_face_property_map.h"</span></div><div class="line"><span class="preprocessor">#include "arr_exact_construction_segments.h"</span></div><div class="line"><span class="preprocessor">#include "arr_print.h"</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__face__extended__dcel.html">CGAL::Arr_face_extended_dcel&lt;Traits, unsigned int&gt;</a> Dcel;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arrangement__2.html">CGAL::Arrangement_2&lt;Traits, Dcel&gt;</a>                  Ex_arrangement;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/classCGAL_1_1Dual.html">CGAL::Dual&lt;Ex_arrangement&gt;</a>                         Dual_arrangement;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Arr__face__index__map.html">CGAL::Arr_face_index_map&lt;Ex_arrangement&gt;</a>           Face_index_map;</div><div class="line"><span class="keyword">typedef</span> Extended_face_property_map&lt;Ex_arrangement,unsigned int&gt;</div><div class="line">                                                           Face_property_map;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">  <span class="comment">// Construct an arrangement of seven intersecting line segments.</span></div><div class="line">  Point p1(1, 1), p2(1, 4), p3(2, 2), p4(3, 7), p5(4, 4), p6(7, 1), p7(9, 3);</div><div class="line">  Ex_arrangement  arr;</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Segment(p1, p6));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Segment(p1, p4));  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Segment(p2, p6));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Segment(p3, p7));  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Segment(p3, p5));</div><div class="line">  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Segment(p6, p7));  <a class="code" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94">insert</a>(arr, Segment(p4, p7));</div><div class="line"></div><div class="line">  <span class="comment">// Create a mapping of the arrangement faces to indices.</span></div><div class="line">  Face_index_map index_map(arr);</div><div class="line"></div><div class="line">  <span class="comment">// Perform breadth-first search from the unbounded face, using the event</span></div><div class="line">  <span class="comment">// visitor to associate each arrangement face with its discover time.</span></div><div class="line">  <span class="keywordtype">int</span> time = -1;</div><div class="line">  boost::breadth_first_search(Dual_arrangement(arr), arr.unbounded_face(),</div><div class="line">                              boost::vertex_index_map(index_map).visitor</div><div class="line">                              (boost::make_bfs_visitor</div><div class="line">                               (stamp_times(Face_property_map(), time,</div><div class="line">                                            boost::on_discover_vertex()))));</div><div class="line"></div><div class="line">  <span class="comment">// Print the discover time of each arrangement face.</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> fit = arr.faces_begin(); fit != arr.faces_end(); ++fit) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Discover time "</span> &lt;&lt; fit-&gt;data() &lt;&lt; <span class="stringliteral">" for "</span>;</div><div class="line">    <span class="keywordflow">if</span> (fit != arr.unbounded_face()) {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">"face "</span>;</div><div class="line">      print_ccb&lt;Ex_arrangement&gt;(fit-&gt;outer_ccb());</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> std::cout &lt;&lt; <span class="stringliteral">"the unbounded face.\n"</span>;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="aos_sec-tips"></a>
How To Speed Up Your Computation</h1>
<p>Before the specific tips, we remind you that compiling programs with debug flags disabled and with optimization flags enabled significantly reduces the running time.</p>
<ol>
<li>
<p class="startli">When the curves to be inserted into an arrangement are \(x\)-monotone and pairwise disjoint in their interior to start with, then it is more efficient (in running time) and less demanding (in traits-class functionality) to use the non-intersecting insertion-functions instead of the general ones; e.g., <code><a class="el" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94" title="% inserts one or more curves or -monotone curves into a given arrangement, where no restrictions are ...">insert()</a></code>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">When the curves to be inserted into an arrangement are segments that are pairwise disjoint in their interior, it is more efficient to use the traits class <code><a class="el" href="classCGAL_1_1Arr__non__caching__segment__traits__2.html" title="The traits class Arr_non_caching_segment_traits_2 is a model of the ArrangementTraits_2 concept that ...">Arr_non_caching_segment_traits_2</a></code> rather than the default one (<code><a class="el" href="classCGAL_1_1Arr__segment__traits__2.html" title="The traits class Arr_segment_traits_2 is a model of the ArrangementTraits_2 concept, which allows the construction and maintenance of arrangements of line segments. ">Arr_segment_traits_2</a></code>).</p>
<p>If the segments may intersect each other, the default traits class <code><a class="el" href="classCGAL_1_1Arr__segment__traits__2.html" title="The traits class Arr_segment_traits_2 is a model of the ArrangementTraits_2 concept, which allows the construction and maintenance of arrangements of line segments. ">Arr_segment_traits_2</a></code> can be safely used with the somehow limited number type <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/classCGAL_1_1Quotient.html">Quotient</a>&lt;MP_float&gt;</code>.</p>
<p>On rare occasions the traits class <code><a class="el" href="classCGAL_1_1Arr__non__caching__segment__traits__2.html" title="The traits class Arr_non_caching_segment_traits_2 is a model of the ArrangementTraits_2 concept that ...">Arr_non_caching_segment_traits_2</a></code> exhibits slightly better performance than the default one (<code><a class="el" href="classCGAL_1_1Arr__segment__traits__2.html" title="The traits class Arr_segment_traits_2 is a model of the ArrangementTraits_2 concept, which allows the construction and maintenance of arrangements of line segments. ">Arr_segment_traits_2</a></code> even when the segments intersect each other, due to the small overhead of the latter (optimized) traits class. (For example, when the so-called LEDA rational kernel is used.)</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Prior knowledge of the combinatorial structure of the arrangement can be used to accelerate operations that insert \(x\)-monotone curves, whose interior is disjoint from existing edges and vertices of the arrangement. The specialized insertion functions, i.e., <code><a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a622e04b98c5d0ac773c0a1b6da94b242" title="inserts the point p into the arrangement as an isolated vertex in the interior of the face f and retu...">Arrangement_on_surface_2::insert_in_face_interior()</a></code>, <code><a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a5afb084b94adba3fa294724bd07ccb36" title="inserts the curve c into the arrangement, such that its left endpoint corresponds to a given arrangem...">Arrangement_on_surface_2::insert_from_left_vertex()</a></code>, <code><a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a1f3b1ceca5219900301e4eefd9f80bd0" title="inserts the curve c into the arrangement, such that its right endpoint corresponds to a given arrange...">Arrangement_on_surface_2::insert_from_right_vertex()</a></code>, and <code><a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a7f2201fbb9015ddbbd22b7704e958e24" title="inserts the curve c into the arrangement, such that both c's endpoints correspond to existing arrange...">Arrangement_on_surface_2::insert_at_vertices()</a></code> can be used according to the available information. These functions hardly involve any geometric operations, if at all. They accept topologically related parameters, and use them to operate directly on the DCEL records, thus saving algebraic operations, which are especially expensive when high-degree curves are involved.</p>
<p>A polygon, represented by a list of segments along its boundary, can be inserted into an empty arrangement as follows. First, one segment is inserted using <code><a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a622e04b98c5d0ac773c0a1b6da94b242" title="inserts the point p into the arrangement as an isolated vertex in the interior of the face f and retu...">Arrangement_on_surface_2::insert_in_face_interior()</a></code> into the unbounded face. Then, a segment with a common end point is inserted using either <code><a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a5afb084b94adba3fa294724bd07ccb36" title="inserts the curve c into the arrangement, such that its left endpoint corresponds to a given arrangem...">Arrangement_on_surface_2::insert_from_left_vertex()</a></code> or <code><a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a1f3b1ceca5219900301e4eefd9f80bd0" title="inserts the curve c into the arrangement, such that its right endpoint corresponds to a given arrange...">Arrangement_on_surface_2::insert_from_right_vertex()</a></code>, and so on with the rest of the segments except for the last, which is inserted using <code><a class="el" href="classCGAL_1_1Arrangement__on__surface__2.html#a7f2201fbb9015ddbbd22b7704e958e24" title="inserts the curve c into the arrangement, such that both c's endpoints correspond to existing arrange...">Arrangement_on_surface_2::insert_at_vertices()</a></code>, as both endpoints of which are the mapping of known vertices.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The main trade-off among point-location strategies is between time and storage. Using the naive or walk strategies, for example, takes more query time but does not require preprocessing or maintenance of auxiliary structures and saves storage space.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">If point-location queries are not performed frequently, but other modifying functions, such as removing, splitting, or merging edges are, then using a point-location strategy that does not require the maintenance of auxiliary structures, such as the naive or walk strategies, is preferable.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">There is a trade-off between two modes of the trapezoidal RIC strategy that enables the user to choose whether preprocessing should be performed or not. If preprocessing is not used, the creation of the structure is faster. However, for some input sequences the structure might be unbalanced and therefore queries and updates might take longer, especially, if many removal and split operations are performed.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">When the curves to be inserted into an arrangement are available in advance (as opposed to supplied on-line), it is advised to use the more efficient aggregate (sweep-based) insertion over the incremental insertion; e.g., <a class="el" href="group__PkgArrangementOnSurface2Insert.html#gaf7d5aac2640c2a706f8c5e6adc8a7e94"><code>insert(arr, first, last)</code></a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The various traits classes should be instantiated with an exact number type to ensure robustness when the input of the operations to be carried out might be degenerate. Inexact number types can be used at the user's own risk.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Maintaining short bit-lengths of coordinate representations may drastically decrease the time consumption of arithmetic operations on the coordinates. This can be achieved by caching certain information or normalization (of rational numbers). However, both solutions should be used cautiously, as the former may lead to an undue space consumption, and indiscriminate normalization may considerably slow down the overall process.</p>
<p class="endli"></p>
</li>
<li>
Geometric functions (e.g., traits methods) dominate the time consumption of most operations. Thus, calls to such function should be avoided or at least their number should be decreased, perhaps at the expense of increased combinatorial-function calls or increased space consumption. For example, repetition of geometric-function calls could be avoided by storing the results obtained by the first call, and reusing them when needed. </li>
</ol>
<h1><a class="anchor" id="aos_sec-design"></a>
Design and Implementation History</h1>
<p>The code of this package is the result of a long development process. Initially (and until version 3.1), the code was spread among several components, namely, <code>Topological_map</code>, <code>Planar_map_2</code>, <code>Planar_map_with_intersections_2</code> and <code><a class="el" href="classCGAL_1_1Arrangement__2.html">Arrangement_2</a></code>, that were developed by Ester Ezra, Eyal Flato, Efi Fogel, Dan Halperin, Iddo Hanniel, Idit Haran, Shai Hirsch, Eugene Lipovetsky, Oren Nechushtan, Sigal Raab, Ron Wein, Baruch Zukerman, and Tali Zvi.</p>
<p>In version 3.2, as part of the ACS project, the packages have gone through a major re-design, resulting in an improved and unified <em>2D Arrangements</em> package. The code of the new package was restructured and developed by Efi Fogel, Idit Haran, Ron Wein, and Baruch Zukerman. This version included for the first time a new geometry-traits class that handles circular and linear curves, and is based on the circular kernel. The circular kernel was developed by Monique Teillaud, Sylvain Pion, and Julien Hazebrouck.</p>
<p>Version 3.3 features arrangements of unbounded curves for the first time. The design and development of this feature required yet another restructuring of the entire package. All this was done by Eric Berberich, Efi Fogel, Dan Halperin, Ophir Setter, and Ron Wein. Michael Hemmer helped tuning up parts of the geometry-traits concept related to unbounded curves.</p>
<p>Version 3.7 introduced a geometry-traits class that handles planar algebraic curves of arbitrary degree. It was developed by Eric Berberich and Michael Kerber.</p>
<p>Version 3.9 introduced a new geometry-traits class that handles rational arcs. It was developed by Oren Salzman and Michael Hemmer. It replaced an old traits, which handled the same family of curves, developed by Ron Wein.</p>
<p>Version 4.1 introduces a revised implementation of the point location class via a randomized incremental construction of the trapezoidal map. The old class was implemented by Oren Nechushtan, while the revamp was done by Michal Kleinbort and Michael Hemmer. The new class adds support for unbounded curves and can now guarantee logarithmic query time in all cases. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Dec 3 2021 15:10:35 for CGAL 5.4 - 2D Arrangements by
    <a href="https://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>


</html>
