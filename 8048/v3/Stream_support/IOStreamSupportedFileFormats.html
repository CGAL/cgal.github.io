<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Stream_support/IOStreamSupportedFileFormats.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=11">
<meta name="generator" content="Doxygen 1.9.6">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CGAL 6.1 - IO Streams: Supported File Formats</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/doxygen.css" rel="stylesheet" type="text/css">
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      },
      equationNumbers: { autoNumber: "AMS" }
  }
}
);
MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
  var PARSE = MathJax.InputJax.TeX.Parse,
      TEXT = PARSE.prototype.InternalText;
  PARSE.Augment({
    InternalText: function (text,def) {
      text = text.replace(/\\/g,"");
      return TEXT.call(this,text,def);
    }
  });
});
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
      <span class="left">
         <span id="MSearchSelect" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()">Â 
        </span>
        <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
      </span>
      <span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.svg" alt=""></a>
      </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CGAL 6.1 - IO Streams
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search/",'.html');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('IOStreamSupportedFileFormats.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">Supported File Formats </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>CGAL provides a large number of data structures and algorithms dedicated to various applications.</p>
<p>This page lists the various supported file formats and the data structures offered by CGAL that may be used to read and write files of each specific format.</p>
<ul>
<li><a class="el" href="IOStreamSupportedFileFormats.html#IOStreamOFF">Object File Format (OFF)</a></li>
<li><a class="el" href="IOStreamSupportedFileFormats.html#IOStreamOBJ">Wavefront Advanced Visualizer Object Format (OBJ)</a></li>
<li><a class="el" href="IOStreamSupportedFileFormats.html#IOStreamOM">OpenMesh (OM) File format</a></li>
<li><a class="el" href="IOStreamSupportedFileFormats.html#IOStreamSTL">STereoLithography (STL) File Format</a></li>
<li><a class="el" href="IOStreamSupportedFileFormats.html#IOStreamPLY">Polygon File Format (PLY)</a></li>
<li><a class="el" href="IOStreamSupportedFileFormats.html#IOStreamXYZ">XYZ File Format</a></li>
<li><a class="el" href="IOStreamSupportedFileFormats.html#IOStreamVTK">VTK (VTU / VTP / legacy) File Formats</a></li>
<li><a class="el" href="IOStreamSupportedFileFormats.html#IOStreamGocad">GOCAD (TS) File Format</a></li>
<li><a class="el" href="IOStreamSupportedFileFormats.html#IOStream3MF">3D Manufacturing Format (3MF)</a></li>
<li><a class="el" href="IOStreamSupportedFileFormats.html#IOStreamWRL">Virtual Reality Modeling Language (VRML) File Format</a></li>
<li><a class="el" href="IOStreamSupportedFileFormats.html#IOStreamLAS">LAS (Lidar) File Format</a></li>
<li><a class="el" href="IOStreamSupportedFileFormats.html#IOStreamAvizo">Avizo File Format</a></li>
<li><a class="el" href="IOStreamSupportedFileFormats.html#IOStreamMedit">Medit File Format</a></li>
<li><a class="el" href="IOStreamSupportedFileFormats.html#IOStreamTetgen">Tetgen File Format</a></li>
<li><a class="el" href="IOStreamSupportedFileFormats.html#IOStreamWKT">Well-Known Text (WKT) File Format</a></li>
</ul>
<h1><a class="anchor" id="IOStreamOFF"></a>
Object File Format (OFF)</h1>
<p>The <code>OFF</code> file format, using the file extension <code>.off</code>, can be used to represent collections of planar polygons with possibly shared vertices. Although it can be as light as providing points and faces described by IDs, the format also allows users to provide more properties such as associating normals or colors to vertices.</p>
<p>A precise specification of the format is available at <a href="http://www.geomview.org/docs/html/OFF.html">geomview.org</a>.</p>
<p>Note that the format defines both ASCII and binary OFF formats, but only the ASCII OFF format is supported in CGAL.</p>
<p>The following table lists some CGAL data structures that have I/O functions compatible with this file format.</p>
<table class="iotable">
<tr>
<th colspan="4">Object File Format (OFF)  </th></tr>
<tr>
<td rowspan="6" width="75">Input </td><td rowspan="3" width="175">Polygon Mesh </td><td width="250"><code><a class="elRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh</a></code> </td><td width="550"><a class="elRef" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncOFF.html">CGAL::IO::read_OFF(const std::string&amp;, CGAL::Surface_mesh&amp;)</a>  </td></tr>
<tr>
<td><code><a class="elRef" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3</a></code> </td><td><a class="elRef" href="../Polyhedron/group__PkgPolyhedronIOFunc.html#ga10b94345dc68a8ec43f8bb5e125c6bed">CGAL::IO::read_OFF(std::istream&amp; in, CGAL::Polyhedron_3&lt;Traits&gt;&amp; P)</a>  </td></tr>
<tr>
<td>Any model of <code><a class="elRef" href="../BGL/classMutableFaceGraph.html">MutableFaceGraph</a></code> </td><td><a class="elRef" href="../BGL/group__PkgBGLIoFuncsOFF.html">CGAL::IO::read_OFF(const std::string&amp;, Graph&amp;)</a>  </td></tr>
<tr>
<td rowspan="2">Point Set </td><td><code><a class="elRef" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3</a></code> </td><td><a class="elRef" href="../Point_set_3/group__PkgPointSet3IOOFF.html">CGAL::IO::read_OFF(const std::string&amp;, CGAL::Point_set_3&amp;)</a>  </td></tr>
<tr>
<td>Any point range </td><td><a class="elRef" href="../Point_set_processing_3/group__PkgPointSetProcessing3IOOff.html">CGAL::IO::read_OFF(const std::string&amp;, PointOutputIterator)</a>  </td></tr>
<tr>
<td>Polygon Soup </td><td>Any point + polygon range </td><td><a class="el" href="group__PkgStreamSupportIoFuncsOFF.html">CGAL::IO::read_OFF(const std::string&amp;, PointRange&amp;, PolygonRange&amp;)</a>  </td></tr>
<tr>
<td rowspan="6">Output </td><td rowspan="3">Polygon Mesh </td><td><code><a class="elRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh</a></code> </td><td><a class="elRef" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncOFF.html">CGAL::IO::write_OFF(const std::string, CGAL::Surface_mesh&amp;)</a>  </td></tr>
<tr>
<td><code><a class="elRef" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3</a></code> </td><td><a class="elRef" href="../Polyhedron/group__PkgPolyhedronIOFunc.html#gacb2c1ede31e1b17378d021d24c54a644">CGAL::IO::write_OFF(std::ostream&amp;, const CGAL::Polyhedron_3&lt;Traits&gt;&amp;)</a>  </td></tr>
<tr>
<td>Any model of <code><a class="elRef" href="../BGL/classFaceGraph.html">FaceGraph</a></code> </td><td><a class="elRef" href="../BGL/group__PkgBGLIoFuncsOFF.html">CGAL::IO::write_OFF(const std::string&amp;, const Graph&amp;)</a>  </td></tr>
<tr>
<td rowspan="2">Point Set </td><td><code><a class="elRef" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3</a></code> </td><td><a class="elRef" href="../Point_set_3/group__PkgPointSet3IOOFF.html">CGAL::IO::write_OFF(const std::string&amp;, const CGAL::Point_set_3&amp;)</a>  </td></tr>
<tr>
<td>Any point range </td><td><a class="elRef" href="../Point_set_processing_3/group__PkgPointSetProcessing3IOOff.html">CGAL::IO::write_OFF(const std::string&amp;, const PointRange&amp;)</a>  </td></tr>
<tr>
<td>Polygon Soup </td><td>Any point + polygon range </td><td><a class="el" href="group__PkgStreamSupportIoFuncsOFF.html">CGAL::IO::write_OFF(const std::string&amp;, const PointRange&amp;, const PolygonRange&amp;)</a>  </td></tr>
</table>
<p>If the data of a polygon mesh cannot be read in a <code><a class="elRef" href="../BGL/classFaceGraph.html">FaceGraph</a></code> due to bad orientation or manifoldness issues, consider using <a class="elRef" href="../Polygon_mesh_processing/group__PMP__IO__grp.html"><code>CGAL::Polygon_mesh_processing::IO::read_polygon_mesh()</code> </a>, which offers combinatorial repairing while reading bad inputs.</p>
<h1><a class="anchor" id="IOStreamOBJ"></a>
Wavefront Advanced Visualizer Object Format (OBJ)</h1>
<p>The <code>OBJ</code> file format, using the file extension <code>.obj</code>, is a simple ASCII data format that represents 3D geometry. Vertices are stored in a counterclockwise order by default, making explicit declaration of face normals unnecessary.</p>
<p>A precise specification of the format is available <a href="https://www.martinreddy.net/gfx/3d/OBJ.spec">here</a>.</p>
<table class="iotable">
<tr>
<th colspan="4">Wavefront Advanced Visualizer Object Format (OBJ)  </th></tr>
<tr>
<td rowspan="2" width="75">Input </td><td rowspan="1" width="175">Polygon Mesh </td><td width="250">Any model of <code><a class="elRef" href="../BGL/classMutableFaceGraph.html">MutableFaceGraph</a></code> </td><td width="550"><a class="elRef" href="../BGL/group__PkgBGLIoFuncsOBJ.html">CGAL::IO::read_OBJ(const std::string&amp;, Graph&amp;)</a>  </td></tr>
<tr>
<td>Polygon Soup </td><td>Any point + polygon range </td><td><a class="el" href="group__PkgStreamSupportIoFuncsOBJ.html">CGAL::IO::read_OBJ(const std::string&amp;, PointRange&amp;, PolygonRange&amp;)</a>  </td></tr>
<tr>
<td rowspan="2">Output </td><td rowspan="1">Polygon Mesh </td><td>Any model of <code><a class="elRef" href="../BGL/classFaceGraph.html">FaceGraph</a></code> </td><td><a class="elRef" href="../BGL/group__PkgBGLIoFuncsOBJ.html">CGAL::IO::write_OBJ(const std::string&amp;, const Graph&amp;)</a>  </td></tr>
<tr>
<td>Polygon Soup </td><td>Any point + polygon range </td><td><a class="el" href="group__PkgStreamSupportIoFuncsOBJ.html">CGAL::IO::write_OBJ(const std::string&amp;, const PointRange&amp;, const PolygonRange&amp;)</a>  </td></tr>
</table>
<p>If the data of a polygon mesh cannot be read in a <code><a class="elRef" href="../BGL/classFaceGraph.html">FaceGraph</a></code> due to bad orientation or manifoldness issues, consider using <a class="elRef" href="../Polygon_mesh_processing/group__PMP__IO__grp.html"><code>CGAL::Polygon_mesh_processing::IO::read_polygon_mesh()</code> </a>, which offers combinatorial repairing while reading bad inputs.</p>
<h1><a class="anchor" id="IOStreamOM"></a>
OpenMesh (OM) File format</h1>
<p>The OpenMesh proprietary format, using the file extension <code>.om</code>, can be used to represent collections of planar polygons with possibly shared vertices. Additionally, it allows to store and restore custom properties along with the standard properties.</p>
<p>More information are provided <a href="https://www.graphics.rwth-aachen.de/media/openmesh_static/Documentations/OpenMesh-Doc-Latest/a06338.html">here</a>.</p>
<table class="iotable">
<tr>
<th colspan="4">OpenMesh Format (OM)  </th></tr>
<tr>
<td width="75">Input </td><td width="175">Polygon Mesh </td><td width="250">Any model of <code><a class="elRef" href="../BGL/classMutableFaceGraph.html">MutableFaceGraph</a></code> </td><td width="550"><a class="elRef" href="../BGL/group__PkgBGLIoFuncsOM.html">CGAL::IO::read_OM(const std::string&amp;, Graph&amp;)</a>  </td></tr>
<tr>
<td>Output </td><td>Polygon Mesh </td><td>Any model of <code><a class="elRef" href="../BGL/classFaceGraph.html">FaceGraph</a></code> </td><td><a class="elRef" href="../BGL/group__PkgBGLIoFuncsOM.html">CGAL::IO::write_OM(const std::string&amp;, const Graph&amp;)</a>  </td></tr>
</table>
<h1><a class="anchor" id="IOStreamSTL"></a>
STereoLithography (STL) File Format</h1>
<p>The <code>STL</code> file format, using the file extension <code>.stl</code>, is an ASCII or binary format native to the stereolithography CAD software created by 3D Systems. STL files describe the surface geometry of a three-dimensional object.</p>
<p>A precise specification of those formats is available <a href="https://www.fabbers.com/tech/STL_Format">here</a>.</p>
<table class="iotable">
<tr>
<th colspan="4">STereoLithography (STL)  </th></tr>
<tr>
<td rowspan="2" width="75">Input </td><td rowspan="1" width="175">Polygon Mesh </td><td width="250">Any model of <code><a class="elRef" href="../BGL/classMutableFaceGraph.html">MutableFaceGraph</a></code> </td><td width="550"><a class="elRef" href="../BGL/group__PkgBGLIoFuncsSTL.html">CGAL::IO::read_STL(const std::string&amp;, Graph&amp;)</a>  </td></tr>
<tr>
<td>Polygon Soup </td><td>Any point + polygon range </td><td><a class="el" href="group__PkgStreamSupportIoFuncsSTL.html">CGAL::IO::read_STL(const std::string&amp;, PointRange&amp;, TriangleRange&amp;)</a>  </td></tr>
<tr>
<td rowspan="2">Output </td><td rowspan="1">Polygon Mesh </td><td>Any model of <code><a class="elRef" href="../BGL/classFaceGraph.html">FaceGraph</a></code> </td><td><a class="elRef" href="../BGL/group__PkgBGLIoFuncsSTL.html">CGAL::IO::write_STL(const std::string&amp;, const Graph&amp;)</a>  </td></tr>
<tr>
<td>Polygon Soup </td><td>Any point + polygon range </td><td><a class="el" href="group__PkgStreamSupportIoFuncsSTL.html">CGAL::IO::write_STL(const std::string&amp;, const PointRange&amp;, const TriangleRange&amp;)</a>  </td></tr>
</table>
<p>Note that the STL file format exports triangular faces as geometric triangles and thus combinatorial information is lost.</p>
<p>If the data of a polygon mesh cannot be read in a <code><a class="elRef" href="../BGL/classFaceGraph.html">FaceGraph</a></code> due to bad orientation or manifoldness issues, consider using <a class="elRef" href="../Polygon_mesh_processing/group__PMP__IO__grp.html"><code>CGAL::Polygon_mesh_processing::IO::read_polygon_mesh()</code> </a>, which offers combinatorial repairing while reading bad inputs.</p>
<h1><a class="anchor" id="IOStreamPLY"></a>
Polygon File Format (PLY)</h1>
<p>The <code>PLY</code> file format, using the file extension <code>.ply</code>, is an ASCII or binary format conceived to store the data obtained during 3D scans. Objects are stored as a simple list of polygons and external properties can be stored.</p>
<p>A precise specification of those formats is available <a href="https://paulbourke.net/dataformats/ply/">here</a>.</p>
<table class="iotable">
<tr>
<th colspan="4">Polygon File Format (PLY)  </th></tr>
<tr>
<td rowspan="5" width="75">Input </td><td rowspan="2" width="175">Polygon Mesh </td><td width="250"><code><a class="elRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh</a></code> </td><td width="550"><a class="elRef" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html">CGAL::IO::read_PLY(const std::string&amp;, CGAL::Surface_mesh&amp;)</a>  </td></tr>
<tr>
<td>Any model of <code><a class="elRef" href="../BGL/classMutableFaceGraph.html">MutableFaceGraph</a></code> </td><td><a class="elRef" href="../BGL/group__PkgBGLIoFuncsPLY.html">CGAL::IO::read_PLY(const std::string&amp;, Graph&amp;)</a>  </td></tr>
<tr>
<td rowspan="2">Point Set </td><td><code><a class="elRef" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3</a></code> </td><td><a class="elRef" href="../Point_set_3/group__PkgPointSet3IOPLY.html">CGAL::IO::read_PLY(const std::string&amp;, CGAL::Point_set_3&amp;)</a>  </td></tr>
<tr>
<td>Any point range </td><td><a class="elRef" href="../Point_set_processing_3/group__PkgPointSetProcessing3IOPly.html">CGAL::IO::read_PLY(const std::string&amp;, PointRange&amp;)</a>  </td></tr>
<tr>
<td>Polygon Soup </td><td>Any point + polygon range </td><td><a class="el" href="group__PkgStreamSupportIoFuncsPLY.html">CGAL::IO::read_PLY(const std::string&amp;, PointRange&amp;, PolygonRange&amp;)</a>  </td></tr>
<tr>
<td rowspan="5">Output </td><td rowspan="2">Polygon Mesh </td><td><code><a class="elRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh</a></code> </td><td><a class="elRef" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html">CGAL::IO::write_PLY(const std::string&amp;, const CGAL::Surface_mesh&amp;)</a>  </td></tr>
<tr>
<td>Any model of <code><a class="elRef" href="../BGL/classFaceGraph.html">FaceGraph</a></code> </td><td><a class="elRef" href="../BGL/group__PkgBGLIoFuncsPLY.html">CGAL::IO::write_PLY(const std::string&amp;, const Graph&amp;)</a>  </td></tr>
<tr>
<td rowspan="2">Point Set </td><td><code><a class="elRef" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3</a></code> </td><td><a class="elRef" href="../Point_set_3/group__PkgPointSet3IOPLY.html">CGAL::IO::write_PLY(const std::string&amp;, const CGAL::Point_set_3&amp;)</a>  </td></tr>
<tr>
<td>Any point range </td><td><a class="elRef" href="../Point_set_processing_3/group__PkgPointSetProcessing3IOPly.html">CGAL::IO::write_PLY(const std::string&amp;, const PointRange&amp;)</a>  </td></tr>
<tr>
<td>Polygon Soup </td><td>Any point + polygon range </td><td><a class="el" href="group__PkgStreamSupportIoFuncsPLY.html">CGAL::IO::write_PLY(const std::string&amp;, const PointRange&amp;, PolygonRange&amp;)</a>  </td></tr>
</table>
<p>If the data of a polygon mesh cannot be read in a <code><a class="elRef" href="../BGL/classFaceGraph.html">FaceGraph</a></code> due to bad orientation or manifoldness issues, consider using <a class="elRef" href="../Polygon_mesh_processing/group__PMP__IO__grp.html"><code>CGAL::Polygon_mesh_processing::IO::read_polygon_mesh()</code> </a>, which offers combinatorial repairing while reading bad inputs.</p>
<h1><a class="anchor" id="IOStreamLAS"></a>
LAS (Lidar) File Format</h1>
<p>The <code>LAS</code> file format, using the file extension <code>.las</code>, is similar to the <a class="el" href="IOStreamSupportedFileFormats.html#IOStreamPLY">Polygon File Format (PLY)</a>, except for some characteristics: this format is binary-only and does not handle normals. The <a class="elRef" href="../Manual/thirdparty.html#thirdpartyLASlib">LASlib</a> library is required to read or write using this format.</p>
<p>A precise specification of those formats is available <a href="https://www.loc.gov/preservation/digital/formats/fdd/fdd000418.shtml">here</a>.</p>
<table class="iotable">
<tr>
<th colspan="4">LAS (Lidar) File Format  </th></tr>
<tr>
<td rowspan="2" width="75">Input </td><td rowspan="2" width="175">Point Set </td><td width="250"><code><a class="elRef" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3</a></code> </td><td width="550"><a class="elRef" href="../Point_set_3/group__PkgPointSet3IOLAS.html">CGAL::IO::read_LAS(const std::string&amp;, CGAL::Point_set_3&amp;)</a>  </td></tr>
<tr>
<td>Any point range </td><td><a class="elRef" href="../Point_set_processing_3/group__PkgPointSetProcessing3IOLas.html">CGAL::IO::read_LAS(const std::string&amp;, PointRange&amp;)</a>  </td></tr>
<tr>
<td rowspan="2">Output </td><td rowspan="2">Point Set </td><td><code><a class="elRef" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3</a></code> </td><td><a class="elRef" href="../Point_set_3/group__PkgPointSet3IOLAS.html">CGAL::IO::write_LAS(const std::string&amp;, const CGAL::Point_set_3&amp;)</a>  </td></tr>
<tr>
<td>Any point range </td><td><a class="elRef" href="../Point_set_processing_3/group__PkgPointSetProcessing3IOLas.html">CGAL::IO::write_LAS(const std::string&amp;, const PointRange&amp;)</a>  </td></tr>
</table>
<h1><a class="anchor" id="IOStreamXYZ"></a>
XYZ File Format</h1>
<p>The <code>XYZ</code> format, using the file extension <code>.xyz</code>, is a non-standard ASCII data format regularly used to describe point sets. Each line represent a point, and is composed of its coordinates and other properties. Only coordinates and normals are currently supported in CGAL.</p>
<table class="iotable">
<tr>
<th colspan="4">XYZ File Format  </th></tr>
<tr>
<td rowspan="2" width="75">Input </td><td rowspan="2" width="175">Point Set </td><td width="250"><code><a class="elRef" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3</a></code> </td><td width="550"><a class="elRef" href="../Point_set_3/group__PkgPointSet3IOXYZ.html">CGAL::IO::read_XYZ(const std::string&amp;, CGAL::Point_set_3&amp;)</a>  </td></tr>
<tr>
<td>Any point range </td><td><a class="elRef" href="../Point_set_processing_3/group__PkgPointSetProcessing3IOXyz.html">CGAL::IO::read_XYZ(const std::string&amp;, PointRange&amp;)</a>  </td></tr>
<tr>
<td rowspan="2">Output </td><td rowspan="2">Point Set </td><td><code><a class="elRef" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3</a></code> </td><td><a class="elRef" href="../Point_set_3/group__PkgPointSet3IOXYZ.html">CGAL::IO::write_XYZ(const std::string&amp;, const CGAL::Point_set_3&amp;)</a>  </td></tr>
<tr>
<td>Any point range </td><td><a class="elRef" href="../Point_set_processing_3/group__PkgPointSetProcessing3IOXyz.html">CGAL::IO::write_XYZ(const std::string&amp;, const PointRange&amp;)</a>  </td></tr>
</table>
<h1><a class="anchor" id="IOStreamGocad"></a>
GOCAD (TS) File Format</h1>
<p>The <code>GOCAD</code> format, using the file extension <code>.ts</code>, is an ASCII file format that enables a range of primitive types to be imported into the GOCAD package.</p>
<p>A precise specification of the format is available <a href="https://paulbourke.net/dataformats/gocad/gocad.pdf">here</a>.</p>
<table class="iotable">
<tr>
<th colspan="4">GOCAD (TS) File Format  </th></tr>
<tr>
<td rowspan="2" width="75">Input </td><td rowspan="1" width="175">Polygon Mesh </td><td width="250">Any model of <code><a class="elRef" href="../BGL/classMutableFaceGraph.html">MutableFaceGraph</a></code> </td><td width="550"><a class="elRef" href="../BGL/group__PkgBGLIoFuncsGOCAD.html">CGAL::IO::read_GOCAD(const std::string&amp;, Graph&amp;)</a>  </td></tr>
<tr>
<td>Polygon Soup </td><td>Any point + polygon range </td><td><a class="el" href="group__PkgStreamSupportIoFuncsGOCAD.html">CGAL::IO::read_GOCAD(const std::string&amp;, PointRange&amp;, PolygonRange&amp;)</a>  </td></tr>
<tr>
<td rowspan="2">Output </td><td rowspan="1">Polygon Mesh </td><td>Any model of <code><a class="elRef" href="../BGL/classFaceGraph.html">FaceGraph</a></code> </td><td><a class="elRef" href="../BGL/group__PkgBGLIoFuncsGOCAD.html">CGAL::IO::write_GOCAD(const std::string&amp;, const Graph&amp;)</a>  </td></tr>
<tr>
<td>Polygon Soup </td><td>Any point + polygon range </td><td><a class="el" href="group__PkgStreamSupportIoFuncsGOCAD.html">CGAL::IO::write_GOCAD(const std::string&amp;, const PointRange&amp;, const PolygonRange&amp;)</a>  </td></tr>
</table>
<p>If the data of a polygon mesh cannot be read in a <code><a class="elRef" href="../BGL/classFaceGraph.html">FaceGraph</a></code> due to bad orientation or manifoldness issues, consider using <a class="elRef" href="../Polygon_mesh_processing/group__PMP__IO__grp.html"><code>CGAL::Polygon_mesh_processing::IO::read_polygon_mesh()</code> </a>, which offers combinatorial repairing while reading bad inputs.</p>
<h1><a class="anchor" id="IOStream3MF"></a>
3D Manufacturing Format (3MF)</h1>
<dl class="section attention"><dt>Attention</dt><dd>CGAL needs to be configured with the 3MF Libraries for this function to be available.</dd></dl>
<p>The <code>3MF</code>, using the file extension <code>.3mf</code>, is an open source file format created by the 3MF Consortium. It is an XML-based format that aims to enhance the <a class="el" href="IOStreamSupportedFileFormats.html#IOStreamSTL">STereoLithography (STL) File Format</a> by adding means to include extra information such as colors.</p>
<p>A precise specification of the format is available at <a href="https://3mf.io/3mf-specification/">3mf.io</a>; note that only versions <code>1.x</code> are currently supported in CGAL.</p>
<table class="iotable">
<tr>
<th colspan="4">3D Manufacturing Format (3MF)  </th></tr>
<tr>
<td rowspan="2" width="75">Input </td><td rowspan="1" width="175">Polygon Mesh </td><td width="250"><code><a class="elRef" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh</a></code> </td><td width="550"><a class="elRef" href="../Surface_mesh/group__PkgSurfaceMeshIOFunc3MF.html">CGAL::IO::read_3MF(const std::string&amp;, Surface_meshRange&amp;)</a>  </td></tr>
<tr>
<td>Polygon Soup </td><td>Any point + polygon range </td><td><a class="el" href="group__PkgStreamSupportIoFuncs3MF.html">CGAL::IO::read_3MF(const std::string&amp;, PointRanges&amp;, PolygonRanges&amp;)</a>  </td></tr>
<tr>
<td rowspan="2">Output </td><td rowspan="1">Polygon Mesh </td><td>Any model of <code><a class="elRef" href="../BGL/classFaceGraph.html">FaceGraph</a></code> </td><td><a class="elRef" href="../BGL/group__PkgBGLIoFuncs3MF.html">CGAL::IO::write_3MF(const std::string&amp;, const GraphRange&amp;)</a>  </td></tr>
<tr>
<td>Polygon Soup </td><td>Any point + polygon range </td><td><a class="el" href="group__PkgStreamSupportIoFuncs3MF.html">CGAL::IO::write_3MF(const std::string&amp;, const PointRanges&amp;, const PolygonRanges&amp;)</a>  </td></tr>
</table>
<p>If the data of a polygon mesh cannot be read in a <code><a class="elRef" href="../BGL/classFaceGraph.html">FaceGraph</a></code> due to bad orientation or manifoldness issues, consider using <a class="elRef" href="../Polygon_mesh_processing/group__PMP__IO__grp.html"><code>CGAL::Polygon_mesh_processing::IO::read_polygon_mesh()</code> </a>, which offers combinatorial repairing while reading bad inputs.</p>
<h1><a class="anchor" id="IOStreamWRL"></a>
Virtual Reality Modeling Language (VRML) File Format</h1>
<p>The <code>VRML</code> format, using the file extension <code>.wrl</code>, is an ASCII format often used by browser plug-ins to display virtual reality environments. VRML files are known as âworlds,â which is what "WRL" stands for. A WRL file includes data specifying 3-D details such as vertices, edges for a 3-D polygon, surface color, ...</p>
<p>A precise specification of the format is available <a href="http://gun.teipir.gr/VRML-amgem/spec/">here</a>.</p>
<table class="iotable">
<tr>
<th colspan="4">3D VRML Format (WRL)  </th></tr>
<tr>
<td rowspan="1" width="75">Output </td><td rowspan="1" width="175">Polygon Mesh </td><td width="250">Any model of <code><a class="elRef" href="../BGL/classFaceGraph.html">FaceGraph</a></code> </td><td width="550"><a class="elRef" href="../BGL/group__PkgBGLIoFuncsWRL.html">CGAL::IO::write_WRL(const std::string&amp;, const Graph&amp;)</a>  </td></tr>
</table>
<h1><a class="anchor" id="IOStreamVTK"></a>
VTK (VTU / VTP / legacy) File Formats</h1>
<dl class="section attention"><dt>Attention</dt><dd>CGAL needs to be configured with the VTK Libraries for this function to be available.</dd></dl>
<p>The VTK libraries use different file formats to handle data structures, but we only support two:</p><ul>
<li>The <code>VTU</code> format can be used to store a collection of 3D cells, like tetrahedra, but also points, triangles, lines, etc. In the <a href="https://vtk.org/">VTK Libraries</a>. It is the format reserved to store <a href="https://kitware.github.io/vtk-examples/site/VTKFileFormats/#unstructuredgrid"><code>Unstructured Grids</code></a>, and in CGAL, we use it to store triangulations (2D and 3D).</li>
<li>The <code>VTP</code> format can be used to store collections of points, lines, and triangles. In the <a href="https://vtk.org/">VTK Libraries</a>, it is the format reserved to store <code>PolyData</code>, and in CGAL, we use it to store polygon meshes.</li>
</ul>
<p>We additionally provide a read function for the legacy non-XML <code>VTK</code> file format for polygon meshes.</p>
<p>A precise specification of those formats is available at <a href="https://vtk.org/wp-content/uploads/2015/04/file-formats.pdf">vtk.org</a>.</p>
<table class="iotable">
<tr>
<th colspan="4">VTK (VTU / VTP / legacy) File Formats  </th></tr>
<tr>
<td rowspan="2" width="75">Input </td><td rowspan="1" width="175">Polygon Mesh </td><td width="250">Any model of <code><a class="elRef" href="../BGL/classMutableFaceGraph.html">MutableFaceGraph</a></code> </td><td width="550"><a class="elRef" href="../BGL/group__PkgBGLIoFuncsVTP.html">CGAL::IO::read_VTP(const std::string&amp;, Graph&amp;)</a>  </td></tr>
<tr>
<td>Polygon Soup </td><td>Any point + polygon range </td><td><a class="el" href="group__PkgStreamSupportIoFuncsVTK.html">CGAL::IO::read_VTP(const std::string&amp;, PointRange&amp;, PolygonRange&amp;)</a>, <br>
 <a class="el" href="group__PkgStreamSupportIoFuncsVTK.html">CGAL::IO::read_VTK(const std::string&amp;, PointRange&amp;, PolygonRange&amp;)</a>  </td></tr>
<tr>
<td rowspan="2">Output </td><td rowspan="1">Polygon Mesh </td><td>Any model of <code><a class="elRef" href="../BGL/classFaceGraph.html">FaceGraph</a></code> </td><td><a class="elRef" href="../BGL/group__PkgBGLIoFuncsVTP.html">CGAL::IO::write_VTP(const std::string&amp;, const Graph&amp;)</a>  </td></tr>
<tr>
<td>Polygon Soup </td><td>Any point + polygon range </td><td><a class="el" href="group__PkgStreamSupportIoFuncsVTK.html">CGAL::IO::write_VTP(const std::string&amp;, const PointRange&amp;, const PolygonRange&amp;)</a>  </td></tr>
</table>
<p>The following CGAL data structures can be exported into the <code>.VTU</code> file format:</p>
<ul>
<li><code><a class="elRef" href="../SMDS_3/classCGAL_1_1Mesh__complex__3__in__triangulation__3.html">CGAL::Mesh_complex_3_in_triangulation_3</a></code>, using <a class="elRef" href="../SMDS_3/group__PkgSMDS3ExportFunctions.html#gae43fbd7adc8ca9598471575c96a44a3a"><code>CGAL::IO::output_to_vtu()</code> </a></li>
<li><code><a class="elRef" href="../Triangulation_2/classCGAL_1_1Constrained__Delaunay__triangulation__2.html">CGAL::Constrained_Delaunay_triangulation_2</a></code>, using the function <a class="elRef" href="../Mesh_2/group__PkgMesh2IO.html#ga938b5d46b0dcff1b56f7342926e9f564"><code>CGAL::IO::write_VTU()</code> </a></li>
</ul>
<h1><a class="anchor" id="IOStreamAvizo"></a>
Avizo File Format</h1>
<p>The AmiraMesh format, using file extension <code>.am</code>, is used by the <a href="https://www.fei.com/software/avizo3d">Avizo</a> software to read 3D geometry.</p>
<p>A single CGAL data structure, <code><a class="elRef" href="../SMDS_3/classCGAL_1_1Mesh__complex__3__in__triangulation__3.html">CGAL::Mesh_complex_3_in_triangulation_3</a></code>, can be exported into <code>.am</code> files. This can be done using the function <a class="elRef" href="../SMDS_3/group__PkgSMDS3ExportFunctions.html#ga94b54be4b5bd58928241f9d389a222f0"><code>CGAL::IO::output_to_avizo()</code></a>.</p>
<p>A precise specification of the format is available <a href="https://assets.thermofisher.com/TFS-Assets/MSD/Product-Guides/users-guide-avizo-software-2019.pdf">in this guide</a>.</p>
<h1><a class="anchor" id="IOStreamMedit"></a>
Medit File Format</h1>
<p>The Medit format, using file extension <code>.mesh</code>, is a format used by the Medit software. In CGAL, it is used to represent 3D meshes.</p>
<p>A precise specification of the format is available <a href="https://inria.hal.science/inria-00069921/document">in this report</a>, in the appendices (section 7.2.1, page 36).</p>
<p>The following CGAL data structures can be exported into the <code>.mesh</code> file format:</p>
<ul>
<li><code><a class="elRef" href="../SMDS_3/classCGAL_1_1Mesh__complex__3__in__triangulation__3.html">CGAL::Mesh_complex_3_in_triangulation_3</a></code>, using the function <a class="elRef" href="../SMDS_3/group__PkgSMDS3IOFunctions.html#ga507712bcd0ba0d717be00a6bdf9207ba"><code>CGAL::IO::write_MEDIT(</code> </a>, and</li>
<li><code><a class="elRef" href="../Constrained_triangulation_3/classCGAL_1_1Conforming__constrained__Delaunay__triangulation__3.html">CGAL::Conforming_constrained_Delaunay_triangulation_3</a></code>, using the function <a class="elRef" href="../Constrained_triangulation_3/group__PkgCDT3IOFunctions.html#gaa0df5e7c276da22dcdb53c6a35ef976e"><code>CGAL::IO::write_MEDIT(</code> </a>.</li>
</ul>
<h1><a class="anchor" id="IOStreamTetgen"></a>
Tetgen File Format</h1>
<p>The <code>Tetgen</code> file formats can be used to represent lists of nodes, edges, faces, ... A precise specification of the format is available at <a href="https://wias-berlin.de/software/tetgen/fformats.html">wias-berlin.de</a>.</p>
<p>Only the <code><a class="elRef" href="../SMDS_3/classCGAL_1_1Mesh__complex__3__in__triangulation__3.html">CGAL::Mesh_complex_3_in_triangulation_3</a></code> CGAL data structure can be exported into some of the Tetgen file formats, namely <code>.node</code>, <code>.ele</code> and <code>.face</code>. This can be done using the function <a class="elRef" href="../SMDS_3/group__PkgSMDS3ExportFunctions.html#gaad775f6b0b4a36dfcab35c8d005fdca3"><code>CGAL::IO::output_to_tetgen()</code></a>.</p>
<h1><a class="anchor" id="IOStreamWKT"></a>
Well-Known Text (WKT) File Format</h1>
<p>The <code>WKT</code> format, using the file extension <code>.wkt</code>, is a text markup language for representing vector geometry objects on a geographical map.</p>
<p>A precise specification of the format is available on <a href="https://en.wikipedia.org/wiki/Well-known_text">wikipedia</a>.</p>
<p>See Section <a class="el" href="index.html#IOstream2DGeo">Simple 2D Geometry IO</a> for a list of available functions. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"></a> 1.9.6 </li>
  </ul>
</div>
</div>
</body>

</html>
