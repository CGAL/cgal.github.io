<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Kinetic_surface_reconstruction/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=11">
<meta name="generator" content="Doxygen 1.9.6">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CGAL 6.2 - Kinetic Surface Reconstruction: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/doxygen.css" rel="stylesheet" type="text/css">
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      },
      equationNumbers: { autoNumber: "AMS" }
  }
}
);
MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
  var PARSE = MathJax.InputJax.TeX.Parse,
      TEXT = PARSE.prototype.InternalText;
  PARSE.Augment({
    InternalText: function (text,def) {
      text = text.replace(/\\/g,"");
      return TEXT.call(this,text,def);
    }
  });
});
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
      <span class="left">
         <span id="MSearchSelect" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()">Â 
        </span>
        <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
      </span>
      <span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.svg" alt=""></a>
      </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CGAL 6.2 - Kinetic Surface Reconstruction
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search/",'.html');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">User Manual </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Kinetic_Surface_Reconstruction"></a></p> <div id="autotoc" class="toc"></div> <dl class="section author"><dt>Authors</dt><dd>Sven Oesau and Florent Lafarge</dd></dl>
<h1><a class="anchor" id="ksrIntroduction"></a>
Introduction</h1>
<p>Reconstruction of man-made objects from point clouds pose a challenge to traditional surface reconstruction methods that often produce a smooth surface, e.g., by meshing a fitted implicit function, see <a class="elRef" href="../Poisson_surface_reconstruction_3/index.html#Chapter_Poisson_Surface_Reconstruction">Poisson Surface Reconstruction</a>, or by interpolation, see <a class="elRef" href="../Advancing_front_surface_reconstruction/index.html#Chapter_Advancing_Front_Surface_Reconstruction">Advancing Front Surface Reconstruction</a> and <a class="elRef" href="../Scale_space_reconstruction_3/index.html#Chapter_Scale_space_reconstruction">Scale Space Surface Reconstruction</a>. The kinetic surface reconstruction package implements the pipeline proposed by Bauchet et. al <a class="el" href="citelist.html#CITEREF_bauchet2020kinetic">[1]</a>. At the core is the <a class="elRef" href="../Manual/packages.html#PkgKineticSpacePartition">Kinetic space partition</a> which efficiently decomposes the bounding box into a set of convex polyhedra. The decomposition is guided by a set of planar shapes which are aforehand abstracted from an input point cloud. The final surface is obtained via an energy formulation trading data faithfulness for low complexity which is solved via min-cut. The output is a polygonal watertight mesh.</p>
<p>The method overcomes the major limitation of similar approaches which decompose the bounding box using planar shapes. By partitioning the space into fewer cells using the kinetic approach and aforehand splitting of input data via an adaptive octree the method beats the common full decomposition of the bounding box which has a complexity of \(O(n^3)\). This allows for effective handling of large scenes. At the same time the kinetic approach of decomposing the bounding box limits the number of tiny cells in the partition. Tiny cells are often responsible for small artifacts and at the same time increase the memory requirements and running time.</p>
<h1><a class="anchor" id="ksrAlgorithm"></a>
Algorithm</h1>
<p>The method takes as input a point cloud with oriented normals, see <a class="el" href="index.html#fig__Ksr_pipelinefig">Figure 73.1</a>. In a first step, <a class="elRef" href="../Manual/packages.html#PkgShapeDetection">Shape Detection</a> is used to abstract planar shapes from the point cloud. The optional regularization of shapes, see <a class="elRef" href="../Manual/packages.html#PkgShapeRegularization">Shape regularization</a>, can not just improve the accuracy of the data by aligning parallel, coplanar and orthogonal shapes, but provides in the same time a reduction in complexity. Before inserting the planar shapes into the kinetic space partition, coplanar shapes are merged into a single shape and the 2d convex hull of each shape is constructed. The reconstruction is posed as an energy minimization labeling the convex volumes of the kinetic space partition as inside or outside. The optimal surface separating the differently labeled volumes is found via min-cut. A graph is embedded into the kinetic partition representing every volume by a vertex and every face between to volumes by an edge connecting the corresponding vertices. </p><center> <table class="center-table" border="0">
<tr>
<td><p class="starttd">\(\operatorname*{arg\,min}\limits_{l \in {\{0, 1\}}^n} E(l) = (1 - \lambda) D(l) + \lambda U(l)\)</p>
<p class="intertd">\(D(l) = \sum\limits_{i \in C}\sum\limits_{p \in I_i}d_i(p, l_i)\)</p>
<p class="endtd">\(U(l) = \frac{I}{A}\sum\limits_{i\mathtt{\sim} j}a_{ij} \cdot (1-\delta_{l_i,l_j})\)  </p>
</td><td><p class="starttd">The energy function trads data term for regularization term via parameter \(\lambda\)</p>
<p class="intertd">The data term counts votes from the points \(p \in I_i\) based on their associated normal pointing towards or away from each volume \(i \in C\).</p>
<p class="endtd">The regularization term penalizes the total surface area and thus favors surfaces with low complexity.   </p>
</td></tr>
</table>
</center><p>The labels \(l \in {\{0, 1\}}^n\) denote the label for the \(n\) volumes of the kinetic space partition. The data term measures the coherence of the labeled volumes with the orientation of normals of the input points. The preferred label for a volume is determined by a voting of the input points and their associated normals. For each volume \(i \in C\) the inliers from the shape detection associated with the faces of the volume \(I_i\) either vote inside or outside for the volume. The vote is inside \(d_i(p, inside) = 1\) and \(d_i(p, outside = 0)\) if the normal associated to the point is directed to the outwards of the volume or outside \(d_i(p, inside) = 0\) and \(d_i(p, outside = 1)\) if the normal is oriented inwards. The regularization term is penalizing the total surface area of the surface and thus favoring less complex surfaces. To put the data term and regularization term into balance, area of each face is normalized by the total area of all faces \(A\) and scaled by twice the total number of inliners \(I\) from the shape detection as each inlier counts as one <em>inside</em> and one <em>outside</em> vote.</p>
<p>Thus the reconstruction is guaranteed to be watertight as it equals a union of volumes. However, the reconstruction may consist of several components and is not guaranteed to be 2-manifold as different components may share a vertex or an edge.</p>
<p><a class="anchor" id="fig__Ksr_pipelinefig"></a></p><center> <img src="ksr_pipeline_small.png" alt="" style="max-width:80%;" class="inline"> </center>  <div class="cgal_figure_caption"> <p> <a class="el" href="index.html#fig__Ksr_pipelinefig">Figure 73.1</a> Kinetic surface reconstruction pipeline.<br>
 From left to right: 1. input point cloud with 382k points 2. 98 detected planar shapes 3. 63 regularized convex shapes 4. kinetic space partition with 1,487 cells 5. reconstructed polygonal mesh with 131 faces. </p> </div> <p> <br>
</p>
<h1><a class="anchor" id="ksrParameters"></a>
Parameters</h1>
<p>The parameters of the method include the parameters from other packages which are used internally:</p><ul>
<li><a class="elRef" href="../Shape_detection/index.html#Shape_detection_RegionGrowingPoints_parameters">Shape detection</a>: <em>k_neighbors</em>, <em>maximum_distance</em>, <em>maximum_angle</em> and <em>minimum_region_size</em></li>
<li><a class="elRef" href="../Shape_regularization/group__PkgShapeRegularizationRefPlanes.html#ga9ace5aafd056ce9ccb348c96e38d361a">Shape Regularization</a>: <em>maximum_offset</em>, <em>angle_tolerance</em>, <em>regularize_parallelism</em>, <em>regularize_coplanarity</em>, <em>regularize_orthogonality</em>, <em>regularize_axis_symmetry</em> and <em>symmetry_direction</em><ul>
<li><em>angle_tolerance</em> is replacing <em>maximum_angle</em> from Shape regularization due to a name collision with Shape detection</li>
</ul>
</li>
<li><a class="elRef" href="../Kinetic_space_partition/index.html#Ksp_parameters">Kinetic space partition</a>: <em>k</em>, <em>reorient_bbox</em> and <em>bbox_dilation_ratio</em></li>
</ul>
<p>The reconstruction adds two new parameters:</p><ul>
<li><em>external_nodes</em>: The min-cut formulation embeds a vertex into each volume and connects all vertices if the corresponding volumes share a common face. While each face inside the kinetic space partition is exactly between two volumes, faces on the boundary do not. Thus, 6 external vertices are inserted into the graph representing a volume on each side of the bounding box. The parameter <em>external_nodes</em> allows the user to either provide a fixed label <em>inside</em> or <em>outside</em> for each node or leave the label up to the energy minimization. Typical choices for this parameter are to choose all external nodes as outside for scanned objects, e.g., as in <a class="el" href="index.html#fig__Ksr_pipelinefig">Figure 73.1</a>, or the <em>ZMIN</em> node <em>inside</em> and all other nodes <em>outside</em> as for exterior scans of buildings, e.g., as in <a class="el" href="index.html#fig__Ksr_parametersfig">Figure 73.2</a>. The default value for this parameter is to leave the labels of the external nodes up to the energy minimization. The alternative method <code>reconstruct_with_ground</code> estimates a ground plane within the detected shapes and sets up all faces on the bounding box below that ground plane to be connected to an external node set as <em>inside</em> while all other faces on the outside are connected to external nodes set to <em>outside</em>. It assumes the z-axis to be the upward pointing vertical direction.</li>
<li><em>lambda</em>: The <em>lambda</em> parameter trades the data faithfulness of the energy minimization for low complexity. The parameter has to be chosen in the range of \([0,1)\). \(0\) indicates maximal data faithfulness, while the default value of \(0.5\) gives an equal weight to data faithfulness and low complexity. The value should be chosen according to the quality of the input data. If the point cloud is accurate, low in noise and complete a low value can be chosen.</li>
</ul>
<h1><a class="anchor" id="ksrParameterChoice"></a>
Choice of Parameters</h1>
<p>The kinetic space partition determines all possible reconstructions as the energy formulation only decides about the labels for the volumes, but cannot change the volumes themselves. Thus, the first stages of the pipeline, <a class="elRef" href="../Manual/packages.html#PkgShapeDetection">Shape Detection</a> and <a class="elRef" href="../Manual/packages.html#PkgShapeRegularization">Shape Regularization</a>, have a large impact on the final reconstruction. In the simple case of a cube, one missing side would depending on the chosen <em>lambda</em> parameter either make the cube expand on that side towards the bounding box or make the full cube disappear. A proper parameterization of the <a class="elRef" href="../Manual/packages.html#PkgShapeDetection">Shape Detection</a> to detect all relevant shapes may have a large impact. The <em>debug</em> parameter allows to export intermediate results for inspection. This is especially helpful for larger scenes, where the time for the whole reconstruction requires more computational effort.</p>
<p>However, in many cases a point cloud may be incomplete and not cover all shapes. The method offers two parameters to handle missing data. The <em>k</em> parameter of the kinetic space partition can extend the convex polygons further in the partition and thus may make up for missing shapes. The <em>external_nodes</em> parameter allows to preset an <em>inside</em> or <em>outside</em> label for bounding box sides. This is especially helpful for scanned buildings, where no points have been collect on the bottom side of the building, partial scans or scans where the orientation is inverted, e.g., inside an apartment.</p>
<p>The <em>lambda</em> parameter allows to trade data faithfulness for low complexity. The best choice depends on the individual point cloud and the sampled object. <a class="el" href="index.html#fig__Ksr_parametersfig">Figure 73.2</a> shows the lower complexity of the reconstruction with a higher <em>lambda</em> value. However, the actual reconstruction using min-cut only makes up a small fraction from the whole pipeline. Performing several reconstructions with different values of <em>lambda</em> is a reasonal approach, see <a class="el" href="index.html#ksrParametersExample">Parameters Example</a>.</p>
<p><a class="anchor" id="fig__Ksr_parametersfig"></a></p><center> <img src="ksr_parameters_gray_small.png" alt="" style="max-width:80%;" class="inline"> </center>  <div class="cgal_figure_caption"> <p> <a class="el" href="index.html#fig__Ksr_parametersfig">Figure 73.2</a> Impact of parameters on the reconstruction of the rotated lans model.<br>
 From left to right: 1. &amp; 2. Reconstruction with using \(\lambda = 0.7\) and \(\lambda = 0.8\). A higher value of lambda removes some details on the roof as well as the chimney. As no planar shape was detected at the top of the chimney, the kinetic space partition does not offer a volume that well covers the point cloud. The volume of the chimney is either too large for \(\lambda = 0.7\) or gets cut completely for \(\lambda = 0.8\) 3. Reconstruction of the model without reorienting the bbox. For the reconstruction to succeed it is necessary to set the external_node for <em>ZMIN</em> to <em>inside</em> as the point cloud does not close the church from below. 4. Reconstruction as in 3., but without setting external_node for <em>ZMIN</em>. </p> </div> <p> <br>
</p>
<h1><a class="anchor" id="ksrExamples"></a>
Examples</h1>
<h2><a class="anchor" id="ksrBasicExample"></a>
Basic Example</h2>
<p>This minimal example shows the import of a simple synthetic point cloud and an reconstruction using mostly default parameters.</p>
<p><b>Example: </b> <a class="el" href="Kinetic_surface_reconstruction_2ksr_basic_8cpp-example.html">Kinetic_surface_reconstruction/ksr_basic.cpp</a> <br>
</p><details>
<summary>
Show / Hide</summary>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Kinetic_surface_reconstruction_3.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3/IO.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/IO/polygon_soup_io.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span><a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>    = <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div>
<div class="line"><span class="keyword">using </span>FT        = <span class="keyword">typename</span> Kernel::FT;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__3.html">Point_3</a>   = <span class="keyword">typename</span> <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Vector__3.html">Vector_3</a>  = <span class="keyword">typename</span> <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a>;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Segment__3.html">Segment_3</a> = <span class="keyword">typename</span> <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Segment__3.html">Kernel::Segment_3</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>Point_set    = CGAL::Point_set_3&lt;Point_3&gt;;</div>
<div class="line"><span class="keyword">using </span>Point_map    = <span class="keyword">typename</span> Point_set::Point_map;</div>
<div class="line"><span class="keyword">using </span>Normal_map   = <span class="keyword">typename</span> Point_set::Vector_map;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>KSR = <a class="code hl_class" href="classCGAL_1_1Kinetic__surface__reconstruction__3.html">CGAL::Kinetic_surface_reconstruction_3&lt;Kernel, Point_set, Point_map, Normal_map&gt;</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">  <span class="comment">// Input.</span></div>
<div class="line"> </div>
<div class="line">  Point_set point_set;</div>
<div class="line">  CGAL::IO::read_point_set(<a class="code hl_functionRef" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/building.ply"</span>), point_set);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> param = CGAL::parameters::maximum_distance(0.5)</div>
<div class="line">    .maximum_angle(10)</div>
<div class="line">    .k_neighbors(12)</div>
<div class="line">    .minimum_region_size(250);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Algorithm.</span></div>
<div class="line">  KSR ksr(point_set, param);</div>
<div class="line"> </div>
<div class="line">  ksr.detection_and_partition(1, param);</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; ksr.detected_planar_shapes().size() &lt;&lt; <span class="stringliteral">" planar shapes detected"</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;Point_3&gt; vtx;</div>
<div class="line">  std::vector&lt;std::vector&lt;std::size_t&gt; &gt; polylist;</div>
<div class="line"> </div>
<div class="line">  ksr.reconstruct_with_ground(0.7, std::back_inserter(vtx), std::back_inserter(polylist));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (polylist.size() &gt; 0) {</div>
<div class="line">    std::cout &lt;&lt; polylist.size() &lt;&lt; <span class="stringliteral">" faces in reconstruction"</span> &lt;&lt; std::endl;</div>
<div class="line">    CGAL::IO::write_polygon_soup(<span class="stringliteral">"building_0.7.ply"</span>, vtx, polylist);</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span> {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Reconstruction empty!"</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="aclassCGAL_1_1Exact__predicates__inexact__constructions__kernel_html"><div class="ttname"><a href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a></div></div>
<div class="ttc" id="aclassCGAL_1_1Kinetic__surface__reconstruction__3_html"><div class="ttname"><a href="classCGAL_1_1Kinetic__surface__reconstruction__3.html">CGAL::Kinetic_surface_reconstruction_3</a></div><div class="ttdoc">Pipeline for piecewise planar surface reconstruction from a point cloud via inside/outside labeling o...</div><div class="ttdef"><b>Definition:</b> Kinetic_surface_reconstruction_3.h:59</div></div>
<div class="ttc" id="aclassKernel_1_1Point__3_html"><div class="ttname"><a href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a></div></div>
<div class="ttc" id="aclassKernel_1_1Segment__3_html"><div class="ttname"><a href="../Kernel_23/classKernel_1_1Segment__3.html">Kernel::Segment_3</a></div></div>
<div class="ttc" id="aclassKernel_1_1Vector__3_html"><div class="ttname"><a href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a></div></div>
<div class="ttc" id="anamespaceCGAL_html_acdae9a147ad2a3998cc21f88bc292dac"><div class="ttname"><a href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a></div><div class="ttdeci">std::string data_file_path(const std::string &amp;filename)</div></div>
<div class="ttc" id="anamespaceKernel_html"><div class="ttname"><a href="../Kernel_23/namespaceKernel.html">Kernel</a></div></div>
</div><!-- fragment --> </details>
<h2><a class="anchor" id="ksrBuildingExample"></a>
Building Example</h2>
<p>This example shows the import of an acquired point cloud of a building and a reconstruction using a common choice of parameters for building reconstruction. The input point cloud is reoriented to be axis-aligned and regularization is used to simplify the detected shapes before reconstruction. The actual reconstruction method is actually fast. To avoid running the full shape detection and kinetic partition just to try different values for beta, several reconstructions are performed and exported into ply format.</p>
<p><b>Example: </b> <a class="el" href="Kinetic_surface_reconstruction_2ksr_building_8cpp-example.html">Kinetic_surface_reconstruction/ksr_building.cpp</a> <br>
</p><details>
<summary>
Show / Hide</summary>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Kinetic_surface_reconstruction_3.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3/IO.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/IO/polygon_soup_io.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span><a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>    = <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div>
<div class="line"><span class="keyword">using </span>FT        = <span class="keyword">typename</span> Kernel::FT;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__3.html">Point_3</a>   = <span class="keyword">typename</span> <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Vector__3.html">Vector_3</a>  = <span class="keyword">typename</span> <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a>;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Segment__3.html">Segment_3</a> = <span class="keyword">typename</span> <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Segment__3.html">Kernel::Segment_3</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>Point_set    = CGAL::Point_set_3&lt;Point_3&gt;;</div>
<div class="line"><span class="keyword">using </span>Point_map    = <span class="keyword">typename</span> Point_set::Point_map;</div>
<div class="line"><span class="keyword">using </span>Normal_map   = <span class="keyword">typename</span> Point_set::Vector_map;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>KSR = <a class="code hl_class" href="classCGAL_1_1Kinetic__surface__reconstruction__3.html">CGAL::Kinetic_surface_reconstruction_3&lt;Kernel, Point_set, Point_map, Normal_map&gt;</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keyword">const</span> <span class="keywordtype">int</span>, <span class="keyword">const</span> <span class="keywordtype">char</span>**) {</div>
<div class="line">  <span class="comment">// Input.</span></div>
<div class="line"> </div>
<div class="line">  Point_set point_set;</div>
<div class="line">  CGAL::IO::read_point_set(<a class="code hl_functionRef" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/building.ply"</span>), point_set);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> param = CGAL::parameters::maximum_distance(0.1)</div>
<div class="line">    .maximum_angle(10)</div>
<div class="line">    .minimum_region_size(100)</div>
<div class="line">    .reorient_bbox(<span class="keyword">true</span>)</div>
<div class="line">    .regularize_parallelism(<span class="keyword">true</span>)</div>
<div class="line">    .regularize_coplanarity(<span class="keyword">true</span>)</div>
<div class="line">    .angle_tolerance(5)</div>
<div class="line">    .maximum_offset(0.02);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Algorithm.</span></div>
<div class="line">  KSR ksr(point_set, param);</div>
<div class="line"> </div>
<div class="line">  ksr.detection_and_partition(2, param);</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;Point_3&gt; vtx;</div>
<div class="line">  std::vector&lt;std::vector&lt;std::size_t&gt; &gt; polylist;</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;FT&gt; lambdas{0.5, 0.7, 0.8, 0.9};</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">bool</span> non_empty = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (FT l : lambdas) {</div>
<div class="line">    vtx.clear();</div>
<div class="line">    polylist.clear();</div>
<div class="line"> </div>
<div class="line">    ksr.reconstruct_with_ground(l, std::back_inserter(vtx), std::back_inserter(polylist));</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (polylist.size() &gt; 0) {</div>
<div class="line">      non_empty = <span class="keyword">true</span>;</div>
<div class="line">      CGAL::IO::write_polygon_soup(<span class="stringliteral">"polylist_"</span> + std::to_string(l) + <span class="stringliteral">".ply"</span>, vtx, polylist);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> (non_empty) ? EXIT_SUCCESS : EXIT_FAILURE;</div>
<div class="line">}</div>
</div><!-- fragment --> </details>
<h2><a class="anchor" id="ksrParametersExample"></a>
Parameters Example</h2>
<p>This example provides a command line version of the kinetic surface reconstruction allowing to configure the input point cloud filename and most parameters.</p>
<p><b>Example: </b> <a class="el" href="Kinetic_surface_reconstruction_2ksr_parameters_8cpp-example.html">Kinetic_surface_reconstruction/ksr_parameters.cpp</a> <br>
</p><details>
<summary>
Show / Hide</summary>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Kinetic_surface_reconstruction_3.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3/IO.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/IO/PLY.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/IO/polygon_soup_io.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/pca_estimate_normals.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/mst_orient_normals.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/bounding_box.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include "include/Parameters.h"</span></div>
<div class="line"><span class="preprocessor">#include "include/Terminal_parser.h"</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span><a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a> = <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div>
<div class="line"><span class="keyword">using </span>FT = <span class="keyword">typename</span> Kernel::FT;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__3.html">Point_3</a> = <span class="keyword">typename</span> <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Vector__3.html">Vector_3</a> = <span class="keyword">typename</span> <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a>;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Segment__3.html">Segment_3</a> = <span class="keyword">typename</span> <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Segment__3.html">Kernel::Segment_3</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>Point_set = CGAL::Point_set_3&lt;Point_3&gt;;</div>
<div class="line"><span class="keyword">using </span>Point_map = <span class="keyword">typename</span> Point_set::Point_map;</div>
<div class="line"><span class="keyword">using </span>Normal_map = <span class="keyword">typename</span> Point_set::Vector_map;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>KSR = <a class="code hl_class" href="classCGAL_1_1Kinetic__surface__reconstruction__3.html">CGAL::Kinetic_surface_reconstruction_3&lt;Kernel, Point_set, Point_map, Normal_map&gt;</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>Parameters = CGAL::KSR::All_parameters&lt;FT&gt;;</div>
<div class="line"><span class="keyword">using </span>Terminal_parser = CGAL::KSR::Terminal_parser&lt;FT&gt;;</div>
<div class="line"><span class="keyword">using </span>Timer = CGAL::Real_timer;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">std::string to_stringp(<span class="keyword">const</span> T a_value, <span class="keyword">const</span> <span class="keywordtype">int</span> n = 6)</div>
<div class="line">{</div>
<div class="line">  std::ostringstream out;</div>
<div class="line">  out.precision(n);</div>
<div class="line">  out &lt;&lt; std::fixed &lt;&lt; a_value;</div>
<div class="line">  <span class="keywordflow">return</span> out.str();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> parse_terminal(Terminal_parser&amp; parser, Parameters&amp; parameters) {</div>
<div class="line">  <span class="comment">// Set all parameters that can be loaded from the terminal.</span></div>
<div class="line">  <span class="comment">// add_str_parameter  - adds a string-type parameter</span></div>
<div class="line">  <span class="comment">// add_val_parameter  - adds a scalar-type parameter</span></div>
<div class="line">  <span class="comment">// add_bool_parameter - adds a boolean parameter</span></div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"--- INPUT PARAMETERS: "</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  parser.add_str_parameter(<span class="stringliteral">"-data"</span>, parameters.data);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Shape detection.</span></div>
<div class="line">  parser.add_val_parameter(<span class="stringliteral">"-kn"</span>, parameters.k_neighbors);</div>
<div class="line">  parser.add_val_parameter(<span class="stringliteral">"-dist"</span>, parameters.maximum_distance);</div>
<div class="line">  parser.add_val_parameter(<span class="stringliteral">"-angle"</span>, parameters.maximum_angle);</div>
<div class="line">  parser.add_val_parameter(<span class="stringliteral">"-minp"</span>, parameters.min_region_size);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Shape regularization.</span></div>
<div class="line">  parser.add_bool_parameter(<span class="stringliteral">"-regparallel"</span>, parameters.regparallel);</div>
<div class="line">  parser.add_bool_parameter(<span class="stringliteral">"-regcoplanar"</span>, parameters.regcoplanar);</div>
<div class="line">  parser.add_bool_parameter(<span class="stringliteral">"-regorthogonal"</span>, parameters.regorthogonal);</div>
<div class="line">  parser.add_bool_parameter(<span class="stringliteral">"-regsymmetric"</span>, parameters.regsymmetric);</div>
<div class="line"> </div>
<div class="line">  parser.add_val_parameter(<span class="stringliteral">"-regoff"</span>, parameters.maximum_offset);</div>
<div class="line">  parser.add_val_parameter(<span class="stringliteral">"-regangle"</span>, parameters.angle_tolerance);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Shape regularization.</span></div>
<div class="line">  parser.add_bool_parameter(<span class="stringliteral">"-reorient"</span>, parameters.reorient);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Partitioning.</span></div>
<div class="line">  parser.add_val_parameter(<span class="stringliteral">"-k"</span>, parameters.k_intersections);</div>
<div class="line">  parser.add_val_parameter(<span class="stringliteral">"-odepth"</span>, parameters.max_octree_depth);</div>
<div class="line">  parser.add_val_parameter(<span class="stringliteral">"-osize"</span>, parameters.max_octree_node_size);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Reconstruction.</span></div>
<div class="line">  parser.add_val_parameter(<span class="stringliteral">"-lambda"</span>, parameters.graphcut_lambda);</div>
<div class="line">  parser.add_val_parameter(<span class="stringliteral">"-ground"</span>, parameters.use_ground);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Debug.</span></div>
<div class="line">  parser.add_bool_parameter(<span class="stringliteral">"-debug"</span>, parameters.debug);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Verbose.</span></div>
<div class="line">  parser.add_bool_parameter(<span class="stringliteral">"-verbose"</span>, parameters.verbose);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keyword">const</span> <span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span>** argv) {</div>
<div class="line">  <span class="comment">// Parameters.</span></div>
<div class="line">  std::cout.precision(20);</div>
<div class="line">  std::cout &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"--- PARSING INPUT: "</span> &lt;&lt; std::endl;</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> kernel_name = boost::typeindex::type_id&lt;Kernel&gt;().pretty_name();</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* used kernel: "</span> &lt;&lt; kernel_name &lt;&lt; std::endl;</div>
<div class="line">  <span class="keyword">const</span> std::string path_to_save = <span class="stringliteral">""</span>;</div>
<div class="line">  Terminal_parser parser(argc, argv, path_to_save);</div>
<div class="line"> </div>
<div class="line">  Parameters parameters;</div>
<div class="line">  parse_terminal(parser, parameters);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// If no input data is provided, use input from data directory.</span></div>
<div class="line">  <span class="keywordflow">if</span> (parameters.data.empty())</div>
<div class="line">    parameters.data = <a class="code hl_functionRef" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/building.ply"</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Input.</span></div>
<div class="line">  Point_set point_set(parameters.with_normals);</div>
<div class="line">  CGAL::IO::read_point_set(parameters.data, point_set);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (point_set.size() == 0) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">"input file not found or empty!"</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (!point_set.has_normal_map()) {</div>
<div class="line">    point_set.add_normal_map();</div>
<div class="line">    CGAL::pca_estimate_normals&lt;CGAL::Parallel_if_available_tag&gt;(point_set, 9);</div>
<div class="line">    CGAL::mst_orient_normals(point_set, 9);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; point_set.size(); i++) {</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Vector__3.html">Vector_3</a> n = point_set.normal(i);</div>
<div class="line">    <span class="keywordflow">if</span> (abs(n * n) &lt; 0.05)</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">"point "</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">" does not have a proper normal"</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (parameters.maximum_distance == 0) {</div>
<div class="line">    <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Bbox__3.html">CGAL::Bbox_3</a> <a class="code hl_functionRef" href="../Polygon_mesh_processing/group__PMP__misc__grp.html#gaf633ec6397f5f065b01462fe42235d56">bbox</a> = CGAL::bbox_3(CGAL::make_transform_iterator_from_property_map(point_set.begin(), point_set.point_map()),</div>
<div class="line">      CGAL::make_transform_iterator_from_property_map(point_set.end(), point_set.point_map()));</div>
<div class="line"> </div>
<div class="line">    FT d = CGAL::approximate_sqrt</div>
<div class="line">    ((<a class="code hl_functionRef" href="../Polygon_mesh_processing/group__PMP__misc__grp.html#gaf633ec6397f5f065b01462fe42235d56">bbox</a>.<a class="code hl_functionRef" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a3f5e323700e1509624a02d151237cc4c">xmax</a>() - <a class="code hl_functionRef" href="../Polygon_mesh_processing/group__PMP__misc__grp.html#gaf633ec6397f5f065b01462fe42235d56">bbox</a>.<a class="code hl_functionRef" href="../Kernel_23/classCGAL_1_1Bbox__3.html#aab574470a2591f187553ca1166e682e1">xmin</a>()) * (<a class="code hl_functionRef" href="../Polygon_mesh_processing/group__PMP__misc__grp.html#gaf633ec6397f5f065b01462fe42235d56">bbox</a>.<a class="code hl_functionRef" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a3f5e323700e1509624a02d151237cc4c">xmax</a>() - <a class="code hl_functionRef" href="../Polygon_mesh_processing/group__PMP__misc__grp.html#gaf633ec6397f5f065b01462fe42235d56">bbox</a>.<a class="code hl_functionRef" href="../Kernel_23/classCGAL_1_1Bbox__3.html#aab574470a2591f187553ca1166e682e1">xmin</a>())</div>
<div class="line">      + (<a class="code hl_functionRef" href="../Polygon_mesh_processing/group__PMP__misc__grp.html#gaf633ec6397f5f065b01462fe42235d56">bbox</a>.<a class="code hl_functionRef" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a9d06f61bd89faa841e011ff53edf745f">ymax</a>() - <a class="code hl_functionRef" href="../Polygon_mesh_processing/group__PMP__misc__grp.html#gaf633ec6397f5f065b01462fe42235d56">bbox</a>.<a class="code hl_functionRef" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a2088e16a1f0a20e011e5b94c2e9c222a">ymin</a>()) * (<a class="code hl_functionRef" href="../Polygon_mesh_processing/group__PMP__misc__grp.html#gaf633ec6397f5f065b01462fe42235d56">bbox</a>.<a class="code hl_functionRef" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a9d06f61bd89faa841e011ff53edf745f">ymax</a>() - <a class="code hl_functionRef" href="../Polygon_mesh_processing/group__PMP__misc__grp.html#gaf633ec6397f5f065b01462fe42235d56">bbox</a>.<a class="code hl_functionRef" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a2088e16a1f0a20e011e5b94c2e9c222a">ymin</a>())</div>
<div class="line">      + (<a class="code hl_functionRef" href="../Polygon_mesh_processing/group__PMP__misc__grp.html#gaf633ec6397f5f065b01462fe42235d56">bbox</a>.<a class="code hl_functionRef" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a98def8b9515f31ded759d781969ddaf6">zmax</a>() - <a class="code hl_functionRef" href="../Polygon_mesh_processing/group__PMP__misc__grp.html#gaf633ec6397f5f065b01462fe42235d56">bbox</a>.<a class="code hl_functionRef" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a6c55430abc7fda54571cf1075c7f2f8b">zmin</a>()) * (<a class="code hl_functionRef" href="../Polygon_mesh_processing/group__PMP__misc__grp.html#gaf633ec6397f5f065b01462fe42235d56">bbox</a>.<a class="code hl_functionRef" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a98def8b9515f31ded759d781969ddaf6">zmax</a>() - <a class="code hl_functionRef" href="../Polygon_mesh_processing/group__PMP__misc__grp.html#gaf633ec6397f5f065b01462fe42235d56">bbox</a>.<a class="code hl_functionRef" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a6c55430abc7fda54571cf1075c7f2f8b">zmin</a>()));</div>
<div class="line"> </div>
<div class="line">    parameters.maximum_distance = d * 0.03;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (parameters.min_region_size == 0)</div>
<div class="line">    parameters.min_region_size = <span class="keyword">static_cast&lt;</span>std::atomic_size_t<span class="keyword">&gt;</span>(point_set.size() * 0.01);</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"--- INPUT STATS: "</span> &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* number of points: "</span> &lt;&lt; point_set.size() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"verbose "</span> &lt;&lt; parameters.verbose &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"maximum_distance "</span> &lt;&lt; parameters.maximum_distance &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"maximum_angle "</span> &lt;&lt; parameters.maximum_angle &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"min_region_size "</span> &lt;&lt; parameters.min_region_size &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"k "</span> &lt;&lt; parameters.k_intersections &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"graphcut_lambda "</span> &lt;&lt; parameters.graphcut_lambda &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> param = CGAL::parameters::maximum_distance(parameters.maximum_distance)</div>
<div class="line">    .maximum_angle(parameters.maximum_angle)</div>
<div class="line">    .k_neighbors(parameters.k_neighbors)</div>
<div class="line">    .minimum_region_size(parameters.min_region_size)</div>
<div class="line">    .debug(parameters.debug)</div>
<div class="line">    .verbose(parameters.verbose)</div>
<div class="line">    .max_octree_depth(parameters.max_octree_depth)</div>
<div class="line">    .max_octree_node_size(parameters.max_octree_node_size)</div>
<div class="line">    .reorient_bbox(parameters.reorient)</div>
<div class="line">    .regularize_parallelism(parameters.regparallel)</div>
<div class="line">    .regularize_coplanarity(parameters.regcoplanar)</div>
<div class="line">    .regularize_orthogonality(parameters.regorthogonal)</div>
<div class="line">    .regularize_axis_symmetry(parameters.regsymmetric)</div>
<div class="line">    .angle_tolerance(parameters.angle_tolerance)</div>
<div class="line">    .maximum_offset(parameters.maximum_offset);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Algorithm.</span></div>
<div class="line">  KSR ksr(point_set, param);</div>
<div class="line"> </div>
<div class="line">  Timer timer;</div>
<div class="line">  timer.start();</div>
<div class="line">  std::size_t num_shapes = ksr.detect_planar_shapes(param);</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; num_shapes &lt;&lt; <span class="stringliteral">" regularized detected planar shapes"</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  FT after_shape_detection = timer.time();</div>
<div class="line"> </div>
<div class="line">  ksr.partition(parameters.k_intersections);</div>
<div class="line"> </div>
<div class="line">  FT after_partition = timer.time();</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;Point_3&gt; vtx;</div>
<div class="line">  std::vector&lt;std::vector&lt;std::size_t&gt; &gt; polylist;</div>
<div class="line"> </div>
<div class="line">  std::map&lt;typename KSR::KSP::Face_support, bool&gt; external_nodes;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (parameters.use_ground) {</div>
<div class="line">    external_nodes[KSR::KSP::Face_support::ZMIN] = <span class="keyword">false</span>;</div>
<div class="line">    ksr.reconstruct_with_ground(parameters.graphcut_lambda, std::back_inserter(vtx), std::back_inserter(polylist));</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    ksr.reconstruct(parameters.graphcut_lambda, external_nodes, std::back_inserter(vtx), std::back_inserter(polylist));</div>
<div class="line"> </div>
<div class="line">  FT after_reconstruction = timer.time();</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; polylist.size() &lt;&lt; <span class="stringliteral">" polygons, "</span> &lt;&lt; vtx.size() &lt;&lt; <span class="stringliteral">" vertices"</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (polylist.size() &gt; 0)</div>
<div class="line">    CGAL::IO::write_polygon_soup(<span class="stringliteral">"polylist_"</span> + std::to_string(parameters.graphcut_lambda) + (parameters.use_ground ? <span class="stringliteral">"_g"</span> : <span class="stringliteral">"_"</span>) + <span class="stringliteral">".off"</span>, vtx, polylist);</div>
<div class="line"> </div>
<div class="line">  timer.stop();</div>
<div class="line">  <span class="keyword">const</span> FT time = <span class="keyword">static_cast&lt;</span>FT<span class="keyword">&gt;</span>(timer.time());</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;FT&gt; lambdas{ 0.3, 0.5, 0.6, 0.7, 0.73, 0.75, 0.77, 0.8, 0.9, 0.95, 0.99 };</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">bool</span> non_empty = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (FT l : lambdas) {</div>
<div class="line">    <span class="keywordflow">if</span> (l == parameters.graphcut_lambda)</div>
<div class="line">      <span class="keywordflow">continue</span>;</div>
<div class="line"> </div>
<div class="line">    vtx.clear();</div>
<div class="line">    polylist.clear();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (parameters.use_ground)</div>
<div class="line">      ksr.reconstruct_with_ground(l, std::back_inserter(vtx), std::back_inserter(polylist));</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">      ksr.reconstruct(l, external_nodes, std::back_inserter(vtx), std::back_inserter(polylist));</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (polylist.size() &gt; 0) {</div>
<div class="line">      non_empty = <span class="keyword">true</span>;</div>
<div class="line">      CGAL::IO::write_polygon_soup(<span class="stringliteral">"polylist_"</span> + std::to_string(l) + (parameters.use_ground ? <span class="stringliteral">"_g"</span> : <span class="stringliteral">"_"</span>) + <span class="stringliteral">".off"</span>, vtx, polylist);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Shape detection and initialization\nof kinetic partition:     "</span> &lt;&lt; after_shape_detection &lt;&lt; <span class="stringliteral">" seconds!"</span> &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Kinetic partition:        "</span> &lt;&lt; (after_partition - after_shape_detection) &lt;&lt; <span class="stringliteral">" seconds!"</span> &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Kinetic reconstruction:   "</span> &lt;&lt; (after_reconstruction - after_partition) &lt;&lt; <span class="stringliteral">" seconds!"</span> &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Total time:               "</span> &lt;&lt; time &lt;&lt; <span class="stringliteral">" seconds!"</span> &lt;&lt; std::endl &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> (non_empty) ? EXIT_SUCCESS : EXIT_FAILURE;</div>
<div class="line">}</div>
<div class="ttc" id="aclassCGAL_1_1Bbox__3_html"><div class="ttname"><a href="../Kernel_23/classCGAL_1_1Bbox__3.html">CGAL::Bbox_3</a></div></div>
<div class="ttc" id="aclassCGAL_1_1Bbox__3_html_a2088e16a1f0a20e011e5b94c2e9c222a"><div class="ttname"><a href="../Kernel_23/classCGAL_1_1Bbox__3.html#a2088e16a1f0a20e011e5b94c2e9c222a">CGAL::Bbox_3::ymin</a></div><div class="ttdeci">double ymin() const</div></div>
<div class="ttc" id="aclassCGAL_1_1Bbox__3_html_a3f5e323700e1509624a02d151237cc4c"><div class="ttname"><a href="../Kernel_23/classCGAL_1_1Bbox__3.html#a3f5e323700e1509624a02d151237cc4c">CGAL::Bbox_3::xmax</a></div><div class="ttdeci">double xmax() const</div></div>
<div class="ttc" id="aclassCGAL_1_1Bbox__3_html_a6c55430abc7fda54571cf1075c7f2f8b"><div class="ttname"><a href="../Kernel_23/classCGAL_1_1Bbox__3.html#a6c55430abc7fda54571cf1075c7f2f8b">CGAL::Bbox_3::zmin</a></div><div class="ttdeci">double zmin() const</div></div>
<div class="ttc" id="aclassCGAL_1_1Bbox__3_html_a98def8b9515f31ded759d781969ddaf6"><div class="ttname"><a href="../Kernel_23/classCGAL_1_1Bbox__3.html#a98def8b9515f31ded759d781969ddaf6">CGAL::Bbox_3::zmax</a></div><div class="ttdeci">double zmax() const</div></div>
<div class="ttc" id="aclassCGAL_1_1Bbox__3_html_a9d06f61bd89faa841e011ff53edf745f"><div class="ttname"><a href="../Kernel_23/classCGAL_1_1Bbox__3.html#a9d06f61bd89faa841e011ff53edf745f">CGAL::Bbox_3::ymax</a></div><div class="ttdeci">double ymax() const</div></div>
<div class="ttc" id="aclassCGAL_1_1Bbox__3_html_aab574470a2591f187553ca1166e682e1"><div class="ttname"><a href="../Kernel_23/classCGAL_1_1Bbox__3.html#aab574470a2591f187553ca1166e682e1">CGAL::Bbox_3::xmin</a></div><div class="ttdeci">double xmin() const</div></div>
<div class="ttc" id="agroup__PMP__misc__grp_html_gaf633ec6397f5f065b01462fe42235d56"><div class="ttname"><a href="../Polygon_mesh_processing/group__PMP__misc__grp.html#gaf633ec6397f5f065b01462fe42235d56">CGAL::Polygon_mesh_processing::bbox</a></div><div class="ttdeci">CGAL::Bbox_3 bbox(const PolygonMesh &amp;pmesh, const NamedParameters &amp;np=parameters::default_values())</div></div>
</div><!-- fragment --> </details>
<h1><a class="anchor" id="ksrPerformance"></a>
Performance</h1>
<p>Kinetic surface reconstruction is aimed at reconstructing piece-wise planar objects, e.g., man-made objects and architecture. Reconstruction results on point clouds acquired from architecture in different qualities are shown in figure <a class="el" href="index.html#fig__ksr_result_small">Figure 73.3</a> in the first and last row. Synthetic point clouds from a CAD model and a fractal object are shown in rows 2 and three. The datasets used here are available at <a href="https://files.inria.fr/titane/KSR42_dataset.zip">https://files.inria.fr/titane/KSR42_dataset.zip</a>.</p>
<p>However, also smooth surfaces can be reconstructed to a certain level of detail as is shown on the fourth row. While the scales of the dragon are not replicated with their smooth boundary, each scale can still be recognized in the final model.</p>
<p><a class="anchor" id="fig__ksr_result_small"></a></p><center> <img src="ksr_result_small.jpg" alt="" style="max-width:90%;" class="inline"> </center>  <div class="cgal_figure_caption"> <p> <a class="el" href="index.html#fig__ksr_result_small">Figure 73.3</a> Results of kinetic surface reconstruction.<br>
 From left to right: 1. input point cloud 2. reconstructed polygon mesh 3. overlay of input and result 4. detail view.<br>
From top to bottom: 1. <em>Meeting room</em>. Reconstruction of the roof framework is not perfect due to missing data. 2. <em>Full Thing</em>. Synthetic point cloud sampled from a CAD model. All details are well reconstructed 3. <em>Hilbert cube</em>. Synthetic point cloud from a fractal object. 4. <em>Asian Dragon</em>. Acquired point cloud from the Stanford 3D Scanning Repository. 5. <em>Building_C</em>. Point Cloud from multi view stereo. </p> </div> <p> <br>
</p>
<p>The running time of the method depends mostly on the shape detection and the kinetic space partition steps. While running time of the shape detection scales with the complexity of the point cloud, the kinetic space partition depends on the number of input polygons. The running time of the shape regularization and the min-cut have not been listed, as they are &lt;1 seconds in all cases besides the Asian Dragon with 2,75s for the min-cut.</p>
<table cellspacing="5">
<tr>
<td align="left" nowrap colspan="10"><hr>
 </td></tr>
<tr>
<td class="math" align="center" nowrap>Data set </td><td class="math" align="center" nowrap>Points </td><td class="math" align="center" nowrap>Detected shapes </td><td class="math" align="center" nowrap>Regularized shapes </td><td class="math" align="center" nowrap>Volumes in partition </td><td class="math" align="center" nowrap>Polygons in reconstruction </td><td class="math" align="center" nowrap>Vertices in reconstruction </td><td class="math" align="center" nowrap>Shape Detection </td><td class="math" align="center" nowrap>Kinetic Space Partition </td><td class="math" align="center" nowrap>Total Time </td></tr>
<tr>
<td align="left" nowrap colspan="10"><hr>
 </td></tr>
<tr>
<td class="math" align="center" nowrap>Foam_box </td><td class="math" align="right" nowrap>382.059 </td><td class="math" align="right" nowrap>103 </td><td class="math" align="right" nowrap>60 </td><td class="math" align="right" nowrap>998 </td><td class="math" align="right" nowrap>97 </td><td class="math" align="right" nowrap>444 </td><td class="math" align="right" nowrap>6.4 </td><td class="math" align="right" nowrap>3.4 </td><td class="math" align="right" nowrap>9.9 </td></tr>
<tr>
<td class="math" align="center" nowrap>Lans </td><td class="math" align="right" nowrap>1.220.459 </td><td class="math" align="right" nowrap>324 </td><td class="math" align="right" nowrap>169 </td><td class="math" align="right" nowrap>3.338 </td><td class="math" align="right" nowrap>330 </td><td class="math" align="right" nowrap>1.175 </td><td class="math" align="right" nowrap>27,2 </td><td class="math" align="right" nowrap>11,1 </td><td class="math" align="right" nowrap>38,4 </td></tr>
<tr>
<td class="math" align="center" nowrap>Meeting Room </td><td class="math" align="right" nowrap>3.074.625 </td><td class="math" align="right" nowrap>1.652 </td><td class="math" align="right" nowrap>777 </td><td class="math" align="right" nowrap>29.737 </td><td class="math" align="right" nowrap>2.876 </td><td class="math" align="right" nowrap>11.839 </td><td class="math" align="right" nowrap>41,4 </td><td class="math" align="right" nowrap>100,7 </td><td class="math" align="right" nowrap>142,1 </td></tr>
<tr>
<td class="math" align="center" nowrap>Full Thing </td><td class="math" align="right" nowrap>1.377.666 </td><td class="math" align="right" nowrap>1.947 </td><td class="math" align="right" nowrap>1.790 </td><td class="math" align="right" nowrap>21.845 </td><td class="math" align="right" nowrap>2.656 </td><td class="math" align="right" nowrap>12.980 </td><td class="math" align="right" nowrap>9,9 </td><td class="math" align="right" nowrap>279,8 </td><td class="math" align="right" nowrap>289,7 </td></tr>
<tr>
<td class="math" align="center" nowrap>Hilbert cube </td><td class="math" align="right" nowrap>144.092 </td><td class="math" align="right" nowrap>968 </td><td class="math" align="right" nowrap>48 </td><td class="math" align="right" nowrap>5.778 </td><td class="math" align="right" nowrap>986 </td><td class="math" align="right" nowrap>4.124 </td><td class="math" align="right" nowrap>0,6 </td><td class="math" align="right" nowrap>10,2 </td><td class="math" align="right" nowrap>10,9 </td></tr>
<tr>
<td class="math" align="center" nowrap>Asian Dragon </td><td class="math" align="right" nowrap>3.609.455 </td><td class="math" align="right" nowrap>2.842 </td><td class="math" align="right" nowrap>2.842 </td><td class="math" align="right" nowrap>101.651 </td><td class="math" align="right" nowrap>11.158 </td><td class="math" align="right" nowrap>35.776 </td><td class="math" align="right" nowrap>31,7 </td><td class="math" align="right" nowrap>869,9 </td><td class="math" align="right" nowrap>903,5 </td></tr>
<tr>
<td class="math" align="center" nowrap>Building_C </td><td class="math" align="right" nowrap>1.000.000 </td><td class="math" align="right" nowrap>221 </td><td class="math" align="right" nowrap>172 </td><td class="math" align="right" nowrap>3.468 </td><td class="math" align="right" nowrap>370 </td><td class="math" align="right" nowrap>1.468 </td><td class="math" align="right" nowrap>41,9 </td><td class="math" align="right" nowrap>14,5 </td><td class="math" align="right" nowrap>56,5 </td></tr>
<tr>
<td align="left" nowrap colspan="10"><hr>
 </td></tr>
</table>
<p>The parameters to reconstruct these models are available in the following table:</p>
<table cellspacing="5">
<tr>
<td align="left" nowrap colspan="10"><hr>
 </td></tr>
<tr>
<td class="math" align="center" nowrap>Data set </td><td class="math" align="center" nowrap>Maximum distance </td><td class="math" align="center" nowrap>Maximum angle </td><td class="math" align="center" nowrap>Minimum region size </td><td class="math" align="center" nowrap>K nearest neighbors </td><td class="math" align="center" nowrap>Regularize parallelism<br>
 Angle tolerance </td><td class="math" align="center" nowrap>Regularize coplanarity<br>
 Maximum offset </td><td class="math" align="center" nowrap>K </td><td class="math" align="center" nowrap>Lambda </td></tr>
<tr>
<td align="left" nowrap colspan="10"><hr>
 </td></tr>
<tr>
<td class="math" align="center" nowrap>Foam_box </td><td class="math" align="right" nowrap>0,05 </td><td class="math" align="right" nowrap>15 </td><td class="math" align="right" nowrap>250 </td><td class="math" align="right" nowrap>12 </td><td class="math" align="right" nowrap>10 </td><td class="math" align="right" nowrap>0,01 </td><td class="math" align="right" nowrap>2 </td><td class="math" align="right" nowrap>0,7 </td></tr>
<tr>
<td class="math" align="center" nowrap>Lans </td><td class="math" align="right" nowrap>0,15 </td><td class="math" align="right" nowrap>20 </td><td class="math" align="right" nowrap>300 </td><td class="math" align="right" nowrap>12 </td><td class="math" align="right" nowrap>8 </td><td class="math" align="right" nowrap>0,08 </td><td class="math" align="right" nowrap>2 </td><td class="math" align="right" nowrap>0,7 </td></tr>
<tr>
<td class="math" align="center" nowrap>Meeting Room </td><td class="math" align="right" nowrap>0,03 </td><td class="math" align="right" nowrap>19 </td><td class="math" align="right" nowrap>100 </td><td class="math" align="right" nowrap>15 </td><td class="math" align="right" nowrap>10 </td><td class="math" align="right" nowrap>0,03 </td><td class="math" align="right" nowrap>3 </td><td class="math" align="right" nowrap>0,5 </td></tr>
<tr>
<td class="math" align="center" nowrap>Full Thing </td><td class="math" align="right" nowrap>0,3 </td><td class="math" align="right" nowrap>36 </td><td class="math" align="right" nowrap>30 </td><td class="math" align="right" nowrap>12 </td><td class="math" align="right" nowrap>3 </td><td class="math" align="right" nowrap>0,05 </td><td class="math" align="right" nowrap>1 </td><td class="math" align="right" nowrap>0,5 </td></tr>
<tr>
<td class="math" align="center" nowrap>Hilbert cube </td><td class="math" align="right" nowrap>0,3 </td><td class="math" align="right" nowrap>10 </td><td class="math" align="right" nowrap>10 </td><td class="math" align="right" nowrap>12 </td><td class="math" align="right" nowrap>5 </td><td class="math" align="right" nowrap>0,03 </td><td class="math" align="right" nowrap>4 </td><td class="math" align="right" nowrap>0,5 </td></tr>
<tr>
<td class="math" align="center" nowrap>Asian Dragon </td><td class="math" align="right" nowrap>0,7 </td><td class="math" align="right" nowrap>26 </td><td class="math" align="right" nowrap>150 </td><td class="math" align="right" nowrap>10 </td><td class="math" align="right" nowrap>0 </td><td class="math" align="right" nowrap>0 </td><td class="math" align="right" nowrap>1 </td><td class="math" align="right" nowrap>0,75 </td></tr>
<tr>
<td class="math" align="center" nowrap>Building_C </td><td class="math" align="right" nowrap>1,1 </td><td class="math" align="right" nowrap>26 </td><td class="math" align="right" nowrap>500 </td><td class="math" align="right" nowrap>15 </td><td class="math" align="right" nowrap>3 </td><td class="math" align="right" nowrap>0,5 </td><td class="math" align="right" nowrap>2 </td><td class="math" align="right" nowrap>0,77 </td></tr>
<tr>
<td align="left" nowrap colspan="10"><hr>
 </td></tr>
</table>
<h1><a class="anchor" id="Ksurfp_history"></a>
Design and Implementation History</h1>
<p>This package is an implementation of Bauchet et. al <a class="el" href="citelist.html#CITEREF_bauchet2020kinetic">[1]</a>. A proof of concept of the kinetic surface reconstruction was developed by Dmitry Anisimov. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"></a> 1.9.6 </li>
  </ul>
</div>
</div>
</body>


</html>
