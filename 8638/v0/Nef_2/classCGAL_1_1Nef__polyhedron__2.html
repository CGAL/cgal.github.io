<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Nef_2/classCGAL_1_1Nef__polyhedron__2.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=11">
<meta name="generator" content="Doxygen 1.9.6">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CGAL 6.2 - 2D Boolean Operations on Nef Polygons: CGAL::Nef_polyhedron_2&lt; T &gt; Class Template Reference</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/doxygen.css" rel="stylesheet" type="text/css">
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      },
      equationNumbers: { autoNumber: "AMS" }
  }
}
);
MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
  var PARSE = MathJax.InputJax.TeX.Parse,
      TEXT = PARSE.prototype.InternalText;
  PARSE.Augment({
    InternalText: function (text,def) {
      text = text.replace(/\\/g,"");
      return TEXT.call(this,text,def);
    }
  });
});
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
      <span class="left">
         <span id="MSearchSelect" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()">Â 
        </span>
        <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
      </span>
      <span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.svg" alt=""></a>
      </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CGAL 6.2 - 2D Boolean Operations on Nef Polygons
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search/",'.html');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classCGAL_1_1Nef__polyhedron__2.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="classCGAL_1_1Nef__polyhedron__2-members.html">List of all members</a> |
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle"><div class="title">CGAL::Nef_polyhedron_2&lt; T &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__PkgNef2Ref.html">Reference Manual</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;CGAL/Nef_polyhedron_2.h&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br>
class CGAL::Nef_polyhedron_2&lt; T &gt;</div><p>An instance of data type <code><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html" title="An instance of data type Nef_polyhedron_2&lt;T&gt; is a subset of the plane that is the result of forming c...">Nef_polyhedron_2</a>&lt;T&gt;</code> is a subset of the plane that is the result of forming complements and intersections starting from a finite set <code>H</code> of halfspaces. </p>
<p><code><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html" title="An instance of data type Nef_polyhedron_2&lt;T&gt; is a subset of the plane that is the result of forming c...">Nef_polyhedron_2</a></code> is closed under all binary set operations <code>intersection</code>, <code>union</code>, <code>difference</code>, <code>complement</code> and under the topological operations <code>boundary</code>, <code>closure</code>, and <code>interior</code>.</p>
<p>The template parameter <code>T</code> is specified via an extended kernel concept. <code>T</code> must be a model of the concept <code><a class="el" href="classExtendedKernelTraits__2.html" title="ExtendedKernelTraits_2 is a kernel concept providing extended geometryIt is called extended geometry ...">ExtendedKernelTraits_2</a></code>.</p>
<p><b>Exploration - Point location - Ray shooting</b><br>
</p>
<p>As Nef polyhedra are the result of forming complements and intersections starting from a set <code>H</code> of halfspaces that are defined by oriented lines in the plane, they can be represented by an attributed plane map \( M = (V,E,F)\). For topological queries within <code>M</code> the following types and operations allow exploration access to this structure.</p>
<p><b>Implementation</b><br>
</p>
<p>Nef polyhedra are implemented on top of a halfedge data structure and use linear space in the number of vertices, edges and facets. Operations like <code>empty</code> take constant time. The operations <code>clear</code>, <code>complement</code>, <code>interior</code>, <code>closure</code>, <code>boundary</code>, <code>regularization</code>, input and output take linear time. All binary set operations and comparison operations take time \(O(n \log n)\) where \( n\) is the size of the output plus the size of the input.</p>
<p>The point location and ray shooting operations are implemented in two flavors. The <code>NAIVE</code> operations run in linear query time without any preprocessing, the <code>DEFAULT</code> operations (equals <code>LMWT</code>) run in sub-linear query time, but preprocessing is triggered with the first operation. Preprocessing takes time \(O(N^2)\), the sub-linear point location time is either logarithmic when LEDA's persistent dictionaries are present or if not then the point location time is worst-case linear, but experiments show often sublinear runtimes. Ray shooting equals point location plus a walk in the constrained triangulation overlaid on the plane map representation. The cost of the walk is proportional to the number of triangles passed in direction <code>d</code> until an obstacle is met. In a minimum weight triangulation of the obstacles (the plane map representing the polyhedron) the theory provides a \(O(\sqrt{n})\) bound for the number of steps. Our locally minimum weight triangulation approximates the minimum weight triangulation only heuristically (the calculation of the minimum weight triangulation is conjectured to be NP hard). Thus we have no runtime guarantee but a strong experimental motivation for its approximation.</p>
<p><b>Example</b><br>
</p>
<p>Nef polyhedra are parameterized by a so-called extended geometric kernel. There are three kernels, one based on a homogeneous representation of extended points called <code><a class="el" href="classCGAL_1_1Extended__homogeneous.html" title="The class Extended_homogeneous serves as a traits class for the class Nef_polyhedron_2&lt;T&gt;.">Extended_homogeneous</a>&lt;RT&gt;</code> where <code>RT</code> is a ring type providing additionally a <code>gcd</code> operation, one based on a Cartesian representation of extended points called <code><a class="el" href="classCGAL_1_1Extended__cartesian.html" title="The class Extended_cartesian serves as a traits class for the class Nef_polyhedron_2&lt;T&gt;.">Extended_cartesian</a>&lt;NT&gt;</code> where <code>NT</code> is a field type, and finally <code><a class="el" href="classCGAL_1_1Filtered__extended__homogeneous.html" title="The class Filtered_extended_homogeneous serves as a traits class for the class Nef_polyhedron_2&lt;T&gt;.">Filtered_extended_homogeneous</a>&lt;RT&gt;</code> (an optimized version of the first). The following example uses the filtered homogeneous kernel to construct the intersection of two halfspaces.</p>
<p><br>
<b>File</b> <a class="el" href="Nef_2_2nef_2_intersection_8cpp-example.html">Nef_2/nef_2_intersection.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" href="../Number_types/Exact__integer_8h.html">CGAL/Exact_integer.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Filtered_extended_homogeneous.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Nef_polyhedron_2.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Manual/classunspecified__type.html">CGAL::Exact_integer</a> RT;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classCGAL_1_1Filtered__extended__homogeneous.html">CGAL::Filtered_extended_homogeneous&lt;RT&gt;</a> Extended_kernel;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2&lt;Extended_kernel&gt;</a> Nef_polyhedron;</div>
<div class="line"><span class="keyword">typedef</span> Nef_polyhedron::Line  <a class="code hl_typedef" href="classCGAL_1_1Nef__polyhedron__2.html#a1e0e9aa5868dc87384c1cb65df4b2828">Line</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  Nef_polyhedron N1(<a class="code hl_typedef" href="classCGAL_1_1Nef__polyhedron__2.html#a1e0e9aa5868dc87384c1cb65df4b2828">Line</a>(1,0,0));</div>
<div class="line">  Nef_polyhedron N2(<a class="code hl_typedef" href="classCGAL_1_1Nef__polyhedron__2.html#a1e0e9aa5868dc87384c1cb65df4b2828">Line</a>(0,1,0), Nef_polyhedron::EXCLUDED);</div>
<div class="line">  Nef_polyhedron N3 = N1 * N2; <span class="comment">// line (*)</span></div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aExact__integer_8h_html"><div class="ttname"><a href="../Number_types/Exact__integer_8h.html">Exact_integer.h</a></div></div>
<div class="ttc" id="aclassCGAL_1_1Filtered__extended__homogeneous_html"><div class="ttname"><a href="classCGAL_1_1Filtered__extended__homogeneous.html">CGAL::Filtered_extended_homogeneous</a></div><div class="ttdoc">The class Filtered_extended_homogeneous serves as a traits class for the class Nef_polyhedron_2&lt;T&gt;.</div><div class="ttdef"><b>Definition:</b> Filtered_extended_homogeneous.h:20</div></div>
<div class="ttc" id="aclassCGAL_1_1Nef__polyhedron__2_html"><div class="ttname"><a href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2</a></div><div class="ttdoc">An instance of data type Nef_polyhedron_2&lt;T&gt; is a subset of the plane that is the result of forming c...</div><div class="ttdef"><b>Definition:</b> Nef_polyhedron_2.h:92</div></div>
<div class="ttc" id="aclassCGAL_1_1Nef__polyhedron__2_html_a1e0e9aa5868dc87384c1cb65df4b2828"><div class="ttname"><a href="classCGAL_1_1Nef__polyhedron__2.html#a1e0e9aa5868dc87384c1cb65df4b2828">CGAL::Nef_polyhedron_2::Line</a></div><div class="ttdeci">unspecified_type Line</div><div class="ttdoc">the oriented lines modeling halfplanes.</div><div class="ttdef"><b>Definition:</b> Nef_polyhedron_2.h:101</div></div>
<div class="ttc" id="aclassunspecified__type_html"><div class="ttname"><a href="../Manual/classunspecified__type.html">unspecified_type</a></div></div>
</div><!-- fragment --><p>After line (*) <code>N3</code> is the intersection of <code>N1</code> and <code>N2</code>. The member types of <code><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html" title="An instance of data type Nef_polyhedron_2&lt;T&gt; is a subset of the plane that is the result of forming c...">Nef_polyhedron_2</a>&lt; <a class="el" href="classCGAL_1_1Extended__homogeneous.html" title="The class Extended_homogeneous serves as a traits class for the class Nef_polyhedron_2&lt;T&gt;.">Extended_homogeneous</a>&lt;NT&gt; &gt;</code> map to corresponding types of the standard CGAL geometry kernel (type equality in pseudo-code notation):</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2&lt; CGAL::Extended_cartesian&lt; FT &gt;</a> &gt;<a class="code hl_typedef" href="classCGAL_1_1Nef__polyhedron__2.html#a5dba79fcf624dbb9e3163f68f4f75e00">::Point</a> == <a class="code hl_structRef" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;FT&gt;::Point_2</a></div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2&lt; CGAL::Extended_homogeneous&lt; RT &gt;</a> &gt;<a class="code hl_typedef" href="classCGAL_1_1Nef__polyhedron__2.html#a5dba79fcf624dbb9e3163f68f4f75e00">::Point</a> == <a class="code hl_structRef" href="../Kernel_23/structCGAL_1_1Homogeneous.html">CGAL::Homogeneous&lt; RT &gt;::Point_2</a></div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2&lt; CGAL::Filtered_extended_homogeneous&lt;RT&gt;</a> &gt;<a class="code hl_typedef" href="classCGAL_1_1Nef__polyhedron__2.html#a5dba79fcf624dbb9e3163f68f4f75e00">::Point</a> == <a class="code hl_structRef" href="../Kernel_23/structCGAL_1_1Homogeneous.html">CGAL::Homogeneous&lt;RT&gt;::Point_2</a></div>
<div class="ttc" id="aclassCGAL_1_1Nef__polyhedron__2_html_a5dba79fcf624dbb9e3163f68f4f75e00"><div class="ttname"><a href="classCGAL_1_1Nef__polyhedron__2.html#a5dba79fcf624dbb9e3163f68f4f75e00">CGAL::Nef_polyhedron_2::Point</a></div><div class="ttdeci">unspecified_type Point</div><div class="ttdoc">the affine points of the plane.</div><div class="ttdef"><b>Definition:</b> Nef_polyhedron_2.h:106</div></div>
<div class="ttc" id="astructCGAL_1_1Cartesian_html"><div class="ttname"><a href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian</a></div></div>
<div class="ttc" id="astructCGAL_1_1Homogeneous_html"><div class="ttname"><a href="../Kernel_23/structCGAL_1_1Homogeneous.html">CGAL::Homogeneous</a></div></div>
</div><!-- fragment --><p>The same holds for the types <code>Line</code> and <code>Direction</code> in the local scope of <code><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html" title="An instance of data type Nef_polyhedron_2&lt;T&gt; is a subset of the plane that is the result of forming c...">Nef_polyhedron_2</a>&lt;...&gt;</code>. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Nef_2_2nef_2_construction_8cpp-example.html#_a2">Nef_2/nef_2_construction.cpp</a>, <a class="el" href="Nef_2_2nef_2_exploration_8cpp-example.html#_a2">Nef_2/nef_2_exploration.cpp</a>, <a class="el" href="Nef_2_2nef_2_intersection_8cpp-example.html#_a2">Nef_2/nef_2_intersection.cpp</a>, and <a class="el" href="Nef_2_2nef_2_polylines_8cpp-example.html#_a2">Nef_2/nef_2_polylines.cpp</a>.</dd>
</dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class Â </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2_1_1Explorer.html">Explorer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">Â </td><td class="mdescRight">a decorator to examine the underlying plane map.  <a href="classCGAL_1_1Nef__polyhedron__2_1_1Explorer.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class Â </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2_1_1Topological__explorer.html">Topological_explorer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">Â </td><td class="mdescRight">An instance <code>D</code> of the data type <code><a class="el" href="classCGAL_1_1Nef__polyhedron__2_1_1Topological__explorer.html" title="An instance D of the data type Topological_explorer is a decorator for interfacing the topological st...">Topological_explorer</a></code> is a decorator for interfacing the topological structure of a plane map <code>P</code> (read-only).  <a href="classCGAL_1_1Nef__polyhedron__2_1_1Topological__explorer.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">Â </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Types</h2></td></tr>
<tr class="memitem:a8cb9d4db15905d56ae4be1d502aab8ff"><td class="memItemLeft" align="right" valign="top">enum Â </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a8cb9d4db15905d56ae4be1d502aab8ff">Boundary</a> { <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a8cb9d4db15905d56ae4be1d502aab8ffa94a77215e20d6be276e5b7ec032c3139">EXCLUDED</a>
, <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a8cb9d4db15905d56ae4be1d502aab8ffa8bca0012800a9d7df0cc129218be8b43">INCLUDED</a>
 }</td></tr>
<tr class="memdesc:a8cb9d4db15905d56ae4be1d502aab8ff"><td class="mdescLeft">Â </td><td class="mdescRight">construction selection.  <a href="classCGAL_1_1Nef__polyhedron__2.html#a8cb9d4db15905d56ae4be1d502aab8ff">More...</a><br></td></tr>
<tr class="separator:a8cb9d4db15905d56ae4be1d502aab8ff"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:ab5f1c19c50d23c0a759c2d2b1bb60bd0"><td class="memItemLeft" align="right" valign="top">enum Â </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ab5f1c19c50d23c0a759c2d2b1bb60bd0">Content</a> { <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ab5f1c19c50d23c0a759c2d2b1bb60bd0a4786fccb661c483062e02b784e1c722c">EMPTY</a>
, <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ab5f1c19c50d23c0a759c2d2b1bb60bd0acbd2d7c6e526cfad582f001a6a0042a3">COMPLETE</a>
 }</td></tr>
<tr class="memdesc:ab5f1c19c50d23c0a759c2d2b1bb60bd0"><td class="mdescLeft">Â </td><td class="mdescRight">construction selection  <a href="classCGAL_1_1Nef__polyhedron__2.html#ab5f1c19c50d23c0a759c2d2b1bb60bd0">More...</a><br></td></tr>
<tr class="separator:ab5f1c19c50d23c0a759c2d2b1bb60bd0"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:aa7cddcb2fffffe488f897da1f3cf4abc"><td class="memItemLeft" align="right" valign="top">enum Â </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#aa7cddcb2fffffe488f897da1f3cf4abc">Location_mode</a> { <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#aa7cddcb2fffffe488f897da1f3cf4abcac595e6612a1f0c393f022857702887af">DEFAULT</a>
, <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#aa7cddcb2fffffe488f897da1f3cf4abcaca828eed6da20a9383aeb13ef1dcdbed">NAIVE</a>
, <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#aa7cddcb2fffffe488f897da1f3cf4abca775e12588827baac52ff0b8d3dec1616">LMWT</a>
 }</td></tr>
<tr class="memdesc:aa7cddcb2fffffe488f897da1f3cf4abc"><td class="mdescLeft">Â </td><td class="mdescRight">selectionflag for the point location mode.  <a href="classCGAL_1_1Nef__polyhedron__2.html#aa7cddcb2fffffe488f897da1f3cf4abc">More...</a><br></td></tr>
<tr class="separator:aa7cddcb2fffffe488f897da1f3cf4abc"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:a1e0e9aa5868dc87384c1cb65df4b2828"><td class="memItemLeft" align="right" valign="top"><a id="a1e0e9aa5868dc87384c1cb65df4b2828" name="a1e0e9aa5868dc87384c1cb65df4b2828"></a>
typedef <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a>Â </td><td class="memItemRight" valign="bottom"><b>Line</b></td></tr>
<tr class="memdesc:a1e0e9aa5868dc87384c1cb65df4b2828"><td class="mdescLeft">Â </td><td class="mdescRight">the oriented lines modeling halfplanes. <br></td></tr>
<tr class="separator:a1e0e9aa5868dc87384c1cb65df4b2828"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:a5dba79fcf624dbb9e3163f68f4f75e00"><td class="memItemLeft" align="right" valign="top"><a id="a5dba79fcf624dbb9e3163f68f4f75e00" name="a5dba79fcf624dbb9e3163f68f4f75e00"></a>
typedef <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a>Â </td><td class="memItemRight" valign="bottom"><b>Point</b></td></tr>
<tr class="memdesc:a5dba79fcf624dbb9e3163f68f4f75e00"><td class="mdescLeft">Â </td><td class="mdescRight">the affine points of the plane. <br></td></tr>
<tr class="separator:a5dba79fcf624dbb9e3163f68f4f75e00"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:ac5779dcd0d9aa9007e4bafe0bceb3ae4"><td class="memItemLeft" align="right" valign="top"><a id="ac5779dcd0d9aa9007e4bafe0bceb3ae4" name="ac5779dcd0d9aa9007e4bafe0bceb3ae4"></a>
typedef <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a>Â </td><td class="memItemRight" valign="bottom"><b>Direction</b></td></tr>
<tr class="memdesc:ac5779dcd0d9aa9007e4bafe0bceb3ae4"><td class="mdescLeft">Â </td><td class="mdescRight">directions in our plane. <br></td></tr>
<tr class="separator:ac5779dcd0d9aa9007e4bafe0bceb3ae4"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:ac640be6a8130703344a89ad4859d4867"><td class="memItemLeft" align="right" valign="top"><a id="ac640be6a8130703344a89ad4859d4867" name="ac640be6a8130703344a89ad4859d4867"></a>
typedef <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a>Â </td><td class="memItemRight" valign="bottom"><b>Polygons_tag</b></td></tr>
<tr class="memdesc:ac640be6a8130703344a89ad4859d4867"><td class="mdescLeft">Â </td><td class="mdescRight">tag for calling polygon constructor. <br></td></tr>
<tr class="separator:ac640be6a8130703344a89ad4859d4867"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:afa372c8392eae26070c04575ec8d198d"><td class="memItemLeft" align="right" valign="top"><a id="afa372c8392eae26070c04575ec8d198d" name="afa372c8392eae26070c04575ec8d198d"></a>
typedef <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a>Â </td><td class="memItemRight" valign="bottom"><b>Polylines_tag</b></td></tr>
<tr class="memdesc:afa372c8392eae26070c04575ec8d198d"><td class="mdescLeft">Â </td><td class="mdescRight">tag for calling polyline constructor. <br></td></tr>
<tr class="separator:afa372c8392eae26070c04575ec8d198d"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:a2ae6d7ad3ab6fa5417b87d9cfec493af"><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a>Â </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a2ae6d7ad3ab6fa5417b87d9cfec493af">Object_handle</a></td></tr>
<tr class="memdesc:a2ae6d7ad3ab6fa5417b87d9cfec493af"><td class="mdescLeft">Â </td><td class="mdescRight">a generic handle to an object of the underlying plane map.  <br></td></tr>
<tr class="separator:a2ae6d7ad3ab6fa5417b87d9cfec493af"><td class="memSeparator" colspan="2">Â </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Creation</h2></td></tr>
<tr class="memitem:ab4af61958347b01b464fb87ce06d7571"><td class="memItemLeft" align="right" valign="top"><a id="ab4af61958347b01b464fb87ce06d7571" name="ab4af61958347b01b464fb87ce06d7571"></a>
Â </td><td class="memItemRight" valign="bottom"><b>Nef_polyhedron_2</b> (<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ab5f1c19c50d23c0a759c2d2b1bb60bd0">Content</a> plane=<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ab5f1c19c50d23c0a759c2d2b1bb60bd0a4786fccb661c483062e02b784e1c722c">EMPTY</a>)</td></tr>
<tr class="memdesc:ab4af61958347b01b464fb87ce06d7571"><td class="mdescLeft">Â </td><td class="mdescRight">creates an instance <code>N</code> of type <code><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html" title="An instance of data type Nef_polyhedron_2&lt;T&gt; is a subset of the plane that is the result of forming c...">Nef_polyhedron_2</a>&lt;T&gt;</code> and initializes it to the empty set if <code>plane == EMPTY</code> and to the whole plane if <code>plane == COMPLETE</code>. <br></td></tr>
<tr class="separator:ab4af61958347b01b464fb87ce06d7571"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:a5c6718ebe574d776b5cc9c767eff9acf"><td class="memItemLeft" align="right" valign="top"><a id="a5c6718ebe574d776b5cc9c767eff9acf" name="a5c6718ebe574d776b5cc9c767eff9acf"></a>
Â </td><td class="memItemRight" valign="bottom"><b>Nef_polyhedron_2</b> (<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a1e0e9aa5868dc87384c1cb65df4b2828">Line</a> l, <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a8cb9d4db15905d56ae4be1d502aab8ff">Boundary</a> line=<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a8cb9d4db15905d56ae4be1d502aab8ffa8bca0012800a9d7df0cc129218be8b43">INCLUDED</a>)</td></tr>
<tr class="memdesc:a5c6718ebe574d776b5cc9c767eff9acf"><td class="mdescLeft">Â </td><td class="mdescRight">creates a Nef polyhedron <code>N</code> containing the halfplane left of <code>l</code> including <code>l</code> if <code>line==INCLUDED</code>, excluding <code>l</code> if <code>line==EXCLUDED</code>. <br></td></tr>
<tr class="separator:a5c6718ebe574d776b5cc9c767eff9acf"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:ab97de249020e516c3e6a599f18a1f745"><td class="memTemplParams" colspan="2">template&lt;class Forward_iterator &gt; </td></tr>
<tr class="memitem:ab97de249020e516c3e6a599f18a1f745"><td class="memTemplItemLeft" align="right" valign="top">Â </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ab97de249020e516c3e6a599f18a1f745">Nef_polyhedron_2</a> (Forward_iterator it, Forward_iterator end, <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a8cb9d4db15905d56ae4be1d502aab8ff">Boundary</a> b=<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a8cb9d4db15905d56ae4be1d502aab8ffa8bca0012800a9d7df0cc129218be8b43">INCLUDED</a>)</td></tr>
<tr class="memdesc:ab97de249020e516c3e6a599f18a1f745"><td class="mdescLeft">Â </td><td class="mdescRight">creates a Nef polyhedron <code>N</code> from the simple polygon <code>P</code> spanned by the list of points in the iterator range <code>[it,end)</code> and including its boundary if <code>b = INCLUDED</code> excluding the boundary otherwise.  <br></td></tr>
<tr class="separator:ab97de249020e516c3e6a599f18a1f745"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:ad68e86a3bdeddb587363bf73edaae184"><td class="memTemplParams" colspan="2"><a id="ad68e86a3bdeddb587363bf73edaae184" name="ad68e86a3bdeddb587363bf73edaae184"></a>
template&lt;class Forward_iterator &gt; </td></tr>
<tr class="memitem:ad68e86a3bdeddb587363bf73edaae184"><td class="memTemplItemLeft" align="right" valign="top">Â </td><td class="memTemplItemRight" valign="bottom"><b>Nef_polyhedron_2</b> (Forward_iterator it, Forward_iterator end, <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ac640be6a8130703344a89ad4859d4867">Polygons_tag</a>)</td></tr>
<tr class="memdesc:ad68e86a3bdeddb587363bf73edaae184"><td class="mdescLeft">Â </td><td class="mdescRight">The iterator range [it, end) defines a set point ranges, each of which defines the boundary of simple polygon. <br></td></tr>
<tr class="separator:ad68e86a3bdeddb587363bf73edaae184"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:af756cab6f8712b0aaaeddb72f6115aee"><td class="memTemplParams" colspan="2"><a id="af756cab6f8712b0aaaeddb72f6115aee" name="af756cab6f8712b0aaaeddb72f6115aee"></a>
template&lt;class Forward_iterator &gt; </td></tr>
<tr class="memitem:af756cab6f8712b0aaaeddb72f6115aee"><td class="memTemplItemLeft" align="right" valign="top">Â </td><td class="memTemplItemRight" valign="bottom"><b>Nef_polyhedron_2</b> (Forward_iterator it, Forward_iterator end, <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#afa372c8392eae26070c04575ec8d198d">Polylines_tag</a>)</td></tr>
<tr class="memdesc:af756cab6f8712b0aaaeddb72f6115aee"><td class="mdescLeft">Â </td><td class="mdescRight">The iterator range [it, end) defines a set point ranges, each of which defines a polyline. <br></td></tr>
<tr class="separator:af756cab6f8712b0aaaeddb72f6115aee"><td class="memSeparator" colspan="2">Â </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Operations</h2></td></tr>
<tr class="memitem:ad8a2c296b76e8bb29c715bbabac6654b"><td class="memItemLeft" align="right" valign="top"><a id="ad8a2c296b76e8bb29c715bbabac6654b" name="ad8a2c296b76e8bb29c715bbabac6654b"></a>
voidÂ </td><td class="memItemRight" valign="bottom"><b>clear</b> (<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ab5f1c19c50d23c0a759c2d2b1bb60bd0">Content</a> plane=<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ab5f1c19c50d23c0a759c2d2b1bb60bd0a4786fccb661c483062e02b784e1c722c">EMPTY</a>)</td></tr>
<tr class="memdesc:ad8a2c296b76e8bb29c715bbabac6654b"><td class="mdescLeft">Â </td><td class="mdescRight">makes <code>N</code> the empty set if <code>plane == EMPTY</code> and the full plane if <code>plane == COMPLETE</code>. <br></td></tr>
<tr class="separator:ad8a2c296b76e8bb29c715bbabac6654b"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:a5014cbf16cdb80a88729b259741bf16f"><td class="memItemLeft" align="right" valign="top"><a id="a5014cbf16cdb80a88729b259741bf16f" name="a5014cbf16cdb80a88729b259741bf16f"></a>
boolÂ </td><td class="memItemRight" valign="bottom"><b>is_empty</b> ()</td></tr>
<tr class="memdesc:a5014cbf16cdb80a88729b259741bf16f"><td class="mdescLeft">Â </td><td class="mdescRight">returns true if <code>N</code> is empty, false otherwise. <br></td></tr>
<tr class="separator:a5014cbf16cdb80a88729b259741bf16f"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:ada3ed3315cae400bdfdfcac4c9be5bce"><td class="memItemLeft" align="right" valign="top"><a id="ada3ed3315cae400bdfdfcac4c9be5bce" name="ada3ed3315cae400bdfdfcac4c9be5bce"></a>
boolÂ </td><td class="memItemRight" valign="bottom"><b>is_plane</b> ()</td></tr>
<tr class="memdesc:ada3ed3315cae400bdfdfcac4c9be5bce"><td class="mdescLeft">Â </td><td class="mdescRight">returns true if <code>N</code> is the whole plane, false otherwise. <br></td></tr>
<tr class="separator:ada3ed3315cae400bdfdfcac4c9be5bce"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:a8de0d51fb5bc6e9e73f87047fa0f1f3f"><td class="memItemLeft" align="right" valign="top"><a id="a8de0d51fb5bc6e9e73f87047fa0f1f3f" name="a8de0d51fb5bc6e9e73f87047fa0f1f3f"></a>
boolÂ </td><td class="memItemRight" valign="bottom"><b>contains</b> (<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a2ae6d7ad3ab6fa5417b87d9cfec493af">Object_handle</a> h)</td></tr>
<tr class="memdesc:a8de0d51fb5bc6e9e73f87047fa0f1f3f"><td class="mdescLeft">Â </td><td class="mdescRight">returns true iff the object <code>h</code> is contained in the set represented by <code>N</code>. <br></td></tr>
<tr class="separator:a8de0d51fb5bc6e9e73f87047fa0f1f3f"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:ae40387867733e7ddc47f5a29f33cac02"><td class="memItemLeft" align="right" valign="top"><a id="ae40387867733e7ddc47f5a29f33cac02" name="ae40387867733e7ddc47f5a29f33cac02"></a>
boolÂ </td><td class="memItemRight" valign="bottom"><b>contained_in_boundary</b> (<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a2ae6d7ad3ab6fa5417b87d9cfec493af">Object_handle</a> h)</td></tr>
<tr class="memdesc:ae40387867733e7ddc47f5a29f33cac02"><td class="mdescLeft">Â </td><td class="mdescRight">returns true iff the object <code>h</code> is contained in the \( 1\)-skeleton of <code>N</code>. <br></td></tr>
<tr class="separator:ae40387867733e7ddc47f5a29f33cac02"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:a1eca334fed696603f7bed85da151582c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a2ae6d7ad3ab6fa5417b87d9cfec493af">Object_handle</a>Â </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a1eca334fed696603f7bed85da151582c">locate</a> (const <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a5dba79fcf624dbb9e3163f68f4f75e00">Point</a> &amp;p, <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#aa7cddcb2fffffe488f897da1f3cf4abc">Location_mode</a> m=<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#aa7cddcb2fffffe488f897da1f3cf4abcac595e6612a1f0c393f022857702887af">DEFAULT</a>)</td></tr>
<tr class="memdesc:a1eca334fed696603f7bed85da151582c"><td class="mdescLeft">Â </td><td class="mdescRight">returns a generic handle <code>h</code> to an object (face, halfedge, vertex) of the underlying plane map that contains the point <code>p</code> in its relative interior.  <br></td></tr>
<tr class="separator:a1eca334fed696603f7bed85da151582c"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:a59903a8983c436a9be57e4bf9d49cfd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a2ae6d7ad3ab6fa5417b87d9cfec493af">Object_handle</a>Â </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a59903a8983c436a9be57e4bf9d49cfd8">ray_shoot</a> (const <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a5dba79fcf624dbb9e3163f68f4f75e00">Point</a> &amp;p, const <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ac5779dcd0d9aa9007e4bafe0bceb3ae4">Direction</a> &amp;d, <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#aa7cddcb2fffffe488f897da1f3cf4abc">Location_mode</a> m=<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#aa7cddcb2fffffe488f897da1f3cf4abcac595e6612a1f0c393f022857702887af">DEFAULT</a>)</td></tr>
<tr class="memdesc:a59903a8983c436a9be57e4bf9d49cfd8"><td class="mdescLeft">Â </td><td class="mdescRight">returns a handle <code>h</code> with <code>N.contains(h)</code>, that can be converted to a <code>Vertex_/Halfedge_/Face_const_handle</code> as described above.  <br></td></tr>
<tr class="separator:a59903a8983c436a9be57e4bf9d49cfd8"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:a7e858bf751d797d0299e312238bd0688"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a2ae6d7ad3ab6fa5417b87d9cfec493af">Object_handle</a>Â </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a7e858bf751d797d0299e312238bd0688">ray_shoot_to_boundary</a> (const <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a5dba79fcf624dbb9e3163f68f4f75e00">Point</a> &amp;p, const <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ac5779dcd0d9aa9007e4bafe0bceb3ae4">Direction</a> &amp;d, <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#aa7cddcb2fffffe488f897da1f3cf4abc">Location_mode</a> m=<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#aa7cddcb2fffffe488f897da1f3cf4abcac595e6612a1f0c393f022857702887af">DEFAULT</a>)</td></tr>
<tr class="memdesc:a7e858bf751d797d0299e312238bd0688"><td class="mdescLeft">Â </td><td class="mdescRight">returns a handle <code>h</code>, that can be converted to a <code>Vertex_/Halfedge_const_handle</code> as described above.  <br></td></tr>
<tr class="separator:a7e858bf751d797d0299e312238bd0688"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:a067bf42f1a6b9b13a6fcc45baa30299b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Nef__polyhedron__2_1_1Explorer.html">Explorer</a>Â </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a067bf42f1a6b9b13a6fcc45baa30299b">explorer</a> ()</td></tr>
<tr class="memdesc:a067bf42f1a6b9b13a6fcc45baa30299b"><td class="mdescLeft">Â </td><td class="mdescRight">returns a decorator object that allows read-only access of the underlying plane map.  <br></td></tr>
<tr class="separator:a067bf42f1a6b9b13a6fcc45baa30299b"><td class="memSeparator" colspan="2">Â </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Constructive Operations</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Additionally there are operators <code>*,+,-,^,!</code> which implement the binary operations <em>intersection</em>, <em>join</em>, <em>difference</em>, <em>symmetric difference</em>, and the unary operation <em>complement</em>, respectively.</p>
<p>There are also the corresponding modification operations There are also comparison operations like <code>&lt;,&lt;=,&gt;,&gt;=,==,!=</code> which implement the relations subset, subset or equal, superset, superset or equal, equality, inequality, respectively. </p>
</td></tr>
<tr class="memitem:afe15ea80568bc19adfc9a78b61d94b9d"><td class="memItemLeft" align="right" valign="top"><a id="afe15ea80568bc19adfc9a78b61d94b9d" name="afe15ea80568bc19adfc9a78b61d94b9d"></a>
<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt; T &gt;Â </td><td class="memItemRight" valign="bottom"><b>complement</b> ()</td></tr>
<tr class="memdesc:afe15ea80568bc19adfc9a78b61d94b9d"><td class="mdescLeft">Â </td><td class="mdescRight">returns the complement of <code>N</code> in the plane. <br></td></tr>
<tr class="separator:afe15ea80568bc19adfc9a78b61d94b9d"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:ac2ab0eb5ebce64cfae2f0ef7a781fa99"><td class="memItemLeft" align="right" valign="top"><a id="ac2ab0eb5ebce64cfae2f0ef7a781fa99" name="ac2ab0eb5ebce64cfae2f0ef7a781fa99"></a>
<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt; T &gt;Â </td><td class="memItemRight" valign="bottom"><b>interior</b> ()</td></tr>
<tr class="memdesc:ac2ab0eb5ebce64cfae2f0ef7a781fa99"><td class="mdescLeft">Â </td><td class="mdescRight">returns the interior of <code>N</code>. <br></td></tr>
<tr class="separator:ac2ab0eb5ebce64cfae2f0ef7a781fa99"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:ab590d816fbe6fae5d1503a461a6a52f4"><td class="memItemLeft" align="right" valign="top"><a id="ab590d816fbe6fae5d1503a461a6a52f4" name="ab590d816fbe6fae5d1503a461a6a52f4"></a>
<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt; T &gt;Â </td><td class="memItemRight" valign="bottom"><b>closure</b> ()</td></tr>
<tr class="memdesc:ab590d816fbe6fae5d1503a461a6a52f4"><td class="mdescLeft">Â </td><td class="mdescRight">returns the closure of <code>N</code>. <br></td></tr>
<tr class="separator:ab590d816fbe6fae5d1503a461a6a52f4"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:ac470e4f51ea938cbda3fbef705f225ec"><td class="memItemLeft" align="right" valign="top"><a id="ac470e4f51ea938cbda3fbef705f225ec" name="ac470e4f51ea938cbda3fbef705f225ec"></a>
<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt; T &gt;Â </td><td class="memItemRight" valign="bottom"><b>boundary</b> ()</td></tr>
<tr class="memdesc:ac470e4f51ea938cbda3fbef705f225ec"><td class="mdescLeft">Â </td><td class="mdescRight">returns the boundary of <code>N</code>. <br></td></tr>
<tr class="separator:ac470e4f51ea938cbda3fbef705f225ec"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:afe97139024ff9e43b1301fe3cc26dd01"><td class="memItemLeft" align="right" valign="top"><a id="afe97139024ff9e43b1301fe3cc26dd01" name="afe97139024ff9e43b1301fe3cc26dd01"></a>
<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt; T &gt;Â </td><td class="memItemRight" valign="bottom"><b>regularization</b> ()</td></tr>
<tr class="memdesc:afe97139024ff9e43b1301fe3cc26dd01"><td class="mdescLeft">Â </td><td class="mdescRight">returns the regularized polyhedron (closure of interior). <br></td></tr>
<tr class="separator:afe97139024ff9e43b1301fe3cc26dd01"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:a54fc43261c9f44822f8f5ef9cf457c98"><td class="memItemLeft" align="right" valign="top"><a id="a54fc43261c9f44822f8f5ef9cf457c98" name="a54fc43261c9f44822f8f5ef9cf457c98"></a>
<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt; T &gt;Â </td><td class="memItemRight" valign="bottom"><b>intersection</b> (const <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt; T &gt; &amp;N1)</td></tr>
<tr class="memdesc:a54fc43261c9f44822f8f5ef9cf457c98"><td class="mdescLeft">Â </td><td class="mdescRight">returns <code>N</code> \( \cap\) <code>N1</code>. <br></td></tr>
<tr class="separator:a54fc43261c9f44822f8f5ef9cf457c98"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:aa97b20003d4c31bf0cc9bf611c4258bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt; T &gt;Â </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#aa97b20003d4c31bf0cc9bf611c4258bc">join</a> (const <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt; T &gt; &amp;N1)</td></tr>
<tr class="memdesc:aa97b20003d4c31bf0cc9bf611c4258bc"><td class="mdescLeft">Â </td><td class="mdescRight">returns <code>N</code> \( \cup\) <code>N1</code>.  <br></td></tr>
<tr class="separator:aa97b20003d4c31bf0cc9bf611c4258bc"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:a82bb8df64f83bfa57cf8e6e7657dc5d7"><td class="memItemLeft" align="right" valign="top"><a id="a82bb8df64f83bfa57cf8e6e7657dc5d7" name="a82bb8df64f83bfa57cf8e6e7657dc5d7"></a>
<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt; T &gt;Â </td><td class="memItemRight" valign="bottom"><b>difference</b> (const <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt; T &gt; &amp;N1)</td></tr>
<tr class="memdesc:a82bb8df64f83bfa57cf8e6e7657dc5d7"><td class="mdescLeft">Â </td><td class="mdescRight">returns <code>N</code> \( -\) <code>N1</code>. <br></td></tr>
<tr class="separator:a82bb8df64f83bfa57cf8e6e7657dc5d7"><td class="memSeparator" colspan="2">Â </td></tr>
<tr class="memitem:a9da7a1f021accae1db53304ec0c07e14"><td class="memItemLeft" align="right" valign="top"><a id="a9da7a1f021accae1db53304ec0c07e14" name="a9da7a1f021accae1db53304ec0c07e14"></a>
<a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt; T &gt;Â </td><td class="memItemRight" valign="bottom"><b>symmetric_difference</b> (const <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt; T &gt; &amp;N1)</td></tr>
<tr class="memdesc:a9da7a1f021accae1db53304ec0c07e14"><td class="mdescLeft">Â </td><td class="mdescRight">returns the symmetric difference <code>N - T</code> \( \cup\) <code>T - N</code>. <br></td></tr>
<tr class="separator:a9da7a1f021accae1db53304ec0c07e14"><td class="memSeparator" colspan="2">Â </td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a2ae6d7ad3ab6fa5417b87d9cfec493af" name="a2ae6d7ad3ab6fa5417b87d9cfec493af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae6d7ad3ab6fa5417b87d9cfec493af">âÂ </a></span>Object_handle</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2</a>&lt; T &gt;::Object_handle</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a generic handle to an object of the underlying plane map. </p>
<p>The kind of object <code>(vertex, halfedge, face)</code> can be determined and the object can be assigned to a corresponding handle by the three functions:</p>
<p><code>bool assign(Vertex_const_handle&amp; h, Object_handle)</code></p>
<p><code>bool assign(Halfedge_const_handle&amp; h, Object_handle)</code></p>
<p><code>bool assign(Face_const_handle&amp; h, Object_handle)</code></p>
<p>where each function returns <code>true</code> iff the assignment to <code>h</code> was done. </p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a8cb9d4db15905d56ae4be1d502aab8ff" name="a8cb9d4db15905d56ae4be1d502aab8ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cb9d4db15905d56ae4be1d502aab8ff">âÂ </a></span>Boundary</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a8cb9d4db15905d56ae4be1d502aab8ff">CGAL::Nef_polyhedron_2::Boundary</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>construction selection. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8cb9d4db15905d56ae4be1d502aab8ffa94a77215e20d6be276e5b7ec032c3139" name="a8cb9d4db15905d56ae4be1d502aab8ffa94a77215e20d6be276e5b7ec032c3139"></a>EXCLUDEDÂ </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8cb9d4db15905d56ae4be1d502aab8ffa8bca0012800a9d7df0cc129218be8b43" name="a8cb9d4db15905d56ae4be1d502aab8ffa8bca0012800a9d7df0cc129218be8b43"></a>INCLUDEDÂ </td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ab5f1c19c50d23c0a759c2d2b1bb60bd0" name="ab5f1c19c50d23c0a759c2d2b1bb60bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f1c19c50d23c0a759c2d2b1bb60bd0">âÂ </a></span>Content</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ab5f1c19c50d23c0a759c2d2b1bb60bd0">CGAL::Nef_polyhedron_2::Content</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>construction selection </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab5f1c19c50d23c0a759c2d2b1bb60bd0a4786fccb661c483062e02b784e1c722c" name="ab5f1c19c50d23c0a759c2d2b1bb60bd0a4786fccb661c483062e02b784e1c722c"></a>EMPTYÂ </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab5f1c19c50d23c0a759c2d2b1bb60bd0acbd2d7c6e526cfad582f001a6a0042a3" name="ab5f1c19c50d23c0a759c2d2b1bb60bd0acbd2d7c6e526cfad582f001a6a0042a3"></a>COMPLETEÂ </td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="aa7cddcb2fffffe488f897da1f3cf4abc" name="aa7cddcb2fffffe488f897da1f3cf4abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7cddcb2fffffe488f897da1f3cf4abc">âÂ </a></span>Location_mode</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#aa7cddcb2fffffe488f897da1f3cf4abc">CGAL::Nef_polyhedron_2::Location_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>selectionflag for the point location mode. </p>
<p>LMWT stands for Locally Minimum Weight Triangulation, a locally optimized constrained triangulation where the weight corresponds to the length of the edges of the triangulation. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa7cddcb2fffffe488f897da1f3cf4abcac595e6612a1f0c393f022857702887af" name="aa7cddcb2fffffe488f897da1f3cf4abcac595e6612a1f0c393f022857702887af"></a>DEFAULTÂ </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa7cddcb2fffffe488f897da1f3cf4abcaca828eed6da20a9383aeb13ef1dcdbed" name="aa7cddcb2fffffe488f897da1f3cf4abcaca828eed6da20a9383aeb13ef1dcdbed"></a>NAIVEÂ </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa7cddcb2fffffe488f897da1f3cf4abca775e12588827baac52ff0b8d3dec1616" name="aa7cddcb2fffffe488f897da1f3cf4abca775e12588827baac52ff0b8d3dec1616"></a>LMWTÂ </td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab97de249020e516c3e6a599f18a1f745" name="ab97de249020e516c3e6a599f18a1f745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab97de249020e516c3e6a599f18a1f745">âÂ </a></span>Nef_polyhedron_2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;class Forward_iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2</a>&lt; T &gt;::Nef_polyhedron_2 </td>
          <td>(</td>
          <td class="paramtype">Forward_iteratorÂ </td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Forward_iteratorÂ </td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a8cb9d4db15905d56ae4be1d502aab8ff">Boundary</a>Â </td>
          <td class="paramname"><em>b</em> = <code><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a8cb9d4db15905d56ae4be1d502aab8ffa8bca0012800a9d7df0cc129218be8b43">INCLUDED</a></code>Â </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a Nef polyhedron <code>N</code> from the simple polygon <code>P</code> spanned by the list of points in the iterator range <code>[it,end)</code> and including its boundary if <code>b = INCLUDED</code> excluding the boundary otherwise. </p>
<p><code>Forward_iterator</code> has to be an iterator with value type <code>Point</code>. This construction expects that <code>P</code> is simple. The degenerate cases where <code>P</code> contains no point, one point or spans just one segment (two points) are correctly handled. In all degenerate cases there's only one unbounded face adjacent to the degenerate polygon. If <code>b == INCLUDED</code> then <code>N</code> is just the boundary. If <code>b == EXCLUDED</code> then <code>N</code> is the whole plane without the boundary. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a067bf42f1a6b9b13a6fcc45baa30299b" name="a067bf42f1a6b9b13a6fcc45baa30299b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a067bf42f1a6b9b13a6fcc45baa30299b">âÂ </a></span>explorer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Nef__polyhedron__2_1_1Explorer.html">Explorer</a> <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2</a>&lt; T &gt;::explorer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a decorator object that allows read-only access of the underlying plane map. </p>
<p>See the manual page <code><a class="el" href="classCGAL_1_1Nef__polyhedron__2_1_1Explorer.html" title="a decorator to examine the underlying plane map.">Explorer</a></code> for its usage. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Nef_2_2nef_2_exploration_8cpp-example.html#a3">Nef_2/nef_2_exploration.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="aa97b20003d4c31bf0cc9bf611c4258bc" name="aa97b20003d4c31bf0cc9bf611c4258bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa97b20003d4c31bf0cc9bf611c4258bc">âÂ </a></span>join()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt; T &gt; <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2</a>&lt; T &gt;::join </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a>&lt; T &gt; &amp;Â </td>
          <td class="paramname"><em>N1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns <code>N</code> \( \cup\) <code>N1</code>. </p>
<p>Note that "union" is a keyword of C++ and cannot be used for this operation. </p>

</div>
</div>
<a id="a1eca334fed696603f7bed85da151582c" name="a1eca334fed696603f7bed85da151582c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eca334fed696603f7bed85da151582c">âÂ </a></span>locate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a2ae6d7ad3ab6fa5417b87d9cfec493af">Object_handle</a> <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2</a>&lt; T &gt;::locate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a5dba79fcf624dbb9e3163f68f4f75e00">Point</a> &amp;Â </td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#aa7cddcb2fffffe488f897da1f3cf4abc">Location_mode</a>Â </td>
          <td class="paramname"><em>m</em> = <code><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#aa7cddcb2fffffe488f897da1f3cf4abcac595e6612a1f0c393f022857702887af">DEFAULT</a></code>Â </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a generic handle <code>h</code> to an object (face, halfedge, vertex) of the underlying plane map that contains the point <code>p</code> in its relative interior. </p>
<p>The point <code>p</code> is contained in the set represented by <code>N</code> if <code>N.contains(h)</code> is true. The location mode flag <code>m</code> allows one to choose between different point location strategies. </p>

</div>
</div>
<a id="a59903a8983c436a9be57e4bf9d49cfd8" name="a59903a8983c436a9be57e4bf9d49cfd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59903a8983c436a9be57e4bf9d49cfd8">âÂ </a></span>ray_shoot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a2ae6d7ad3ab6fa5417b87d9cfec493af">Object_handle</a> <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2</a>&lt; T &gt;::ray_shoot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a5dba79fcf624dbb9e3163f68f4f75e00">Point</a> &amp;Â </td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ac5779dcd0d9aa9007e4bafe0bceb3ae4">Direction</a> &amp;Â </td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#aa7cddcb2fffffe488f897da1f3cf4abc">Location_mode</a>Â </td>
          <td class="paramname"><em>m</em> = <code><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#aa7cddcb2fffffe488f897da1f3cf4abcac595e6612a1f0c393f022857702887af">DEFAULT</a></code>Â </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a handle <code>h</code> with <code>N.contains(h)</code>, that can be converted to a <code>Vertex_/Halfedge_/Face_const_handle</code> as described above. </p>
<p>The object returned is intersected by the ray starting in <code>p</code> with direction <code>d</code> and has minimal distance to <code>p</code>. The operation returns an empty <code>Object_handle</code> if the ray shoot along <code>d</code> does not hit any object <code>h</code> of <code>N</code> with <code>N.contains(h)</code>. The location mode flag <code>m</code> allows one to choose between different point location strategies. </p>

</div>
</div>
<a id="a7e858bf751d797d0299e312238bd0688" name="a7e858bf751d797d0299e312238bd0688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e858bf751d797d0299e312238bd0688">âÂ </a></span>ray_shoot_to_boundary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a2ae6d7ad3ab6fa5417b87d9cfec493af">Object_handle</a> <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">CGAL::Nef_polyhedron_2</a>&lt; T &gt;::ray_shoot_to_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#a5dba79fcf624dbb9e3163f68f4f75e00">Point</a> &amp;Â </td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#ac5779dcd0d9aa9007e4bafe0bceb3ae4">Direction</a> &amp;Â </td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#aa7cddcb2fffffe488f897da1f3cf4abc">Location_mode</a>Â </td>
          <td class="paramname"><em>m</em> = <code><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html#aa7cddcb2fffffe488f897da1f3cf4abcac595e6612a1f0c393f022857702887af">DEFAULT</a></code>Â </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a handle <code>h</code>, that can be converted to a <code>Vertex_/Halfedge_const_handle</code> as described above. </p>
<p>The object returned is part of the \( 1\)-skeleton of <code>N</code>, intersected by the ray starting in <code>p</code> with direction <code>d</code> and has minimal distance to <code>p</code>. The operation returns an empty <code>Object_handle</code> if the ray shoot along <code>d</code> does not hit any \( 1\)-skeleton object <code>h</code> of <code>N</code>. The location mode flag <code>m</code> allows one to choose between different point location strategies. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>CGAL</b></li><li class="navelem"><a class="el" href="classCGAL_1_1Nef__polyhedron__2.html">Nef_polyhedron_2</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"></a> 1.9.6 </li>
  </ul>
</div>
</div>
</body>



</html>
