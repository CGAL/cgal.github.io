<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Surface_mesh_segmentation/group__PkgSurfaceMeshSegmentationRef.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=11">
<meta name="generator" content="Doxygen 1.9.6">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CGAL 6.2 - Triangulated Surface Mesh Segmentation: Reference Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/doxygen.css" rel="stylesheet" type="text/css">
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      },
      equationNumbers: { autoNumber: "AMS" }
  }
}
);
MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
  var PARSE = MathJax.InputJax.TeX.Parse,
      TEXT = PARSE.prototype.InternalText;
  PARSE.Augment({
    InternalText: function (text,def) {
      text = text.replace(/\\/g,"");
      return TEXT.call(this,text,def);
    }
  });
});
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
      <span class="left">
         <span id="MSearchSelect" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"> 
        </span>
        <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
      </span>
      <span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.svg" alt=""></a>
      </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CGAL 6.2 - Triangulated Surface Mesh Segmentation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search/",'.html');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__PkgSurfaceMeshSegmentationRef.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> |
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Reference Manual</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader"> </h2>
<div class="PkgImage">  <div class="image">
<img src="segmentation_ico.png" alt="">
</div>
 </div><div class="PkgSummary"> <div class="PkgAuthors">Ilker O. Yaz and Sébastien Loriot</div> <div class="PkgDescription">This package provides a method to generate a segmentation of a triangulated surface mesh. The algorithm first computes the <em>Shape Diameter Function</em> (SDF) for all facets and applies a graph-cut based algorithm over these values. Low level functions are provided to replace any intermediate step by a custom one. </div> <div class="PkgManuals"></div> </div><div class="PkgShortInfo"> <b>Introduced in:</b> CGAL 4.4<br>
 <b>Depends on:</b> <a class="elRef" href="../Manual/packages.html#PkgAABBTree">2D and 3D Fast Intersection and Distance Computation</a> <br>
 <b>BibTeX:</b> <a href="../Manual/how_to_cite_cgal.html#cgal:y-smsimpl-26a">cgal:y-smsimpl-26a</a><br>
 <b>License:</b> <a class="elRef" href="../Manual/license.html#licensesGPL">GPL</a> <br>
 <b>Windows Demo:</b> <a href="https://www.cgal.org/demo/6.2/CGALlab.zip">CGAL Lab</a><br>
 </div> <h2 class="groupheader">Classified Reference Pages</h2> <h2>Concepts</h2>
<ul>
<li><code>#<a class="el" href="classSegmentationGeomTraits.html" title="The concept SegmentationGeomTraits describes the set of requirements of the geometric traits needed b...">SegmentationGeomTraits</a></code></li>
</ul>
<h2>Main Functions</h2>
<ul>
<li><code>#<a class="el" href="group__PkgSurfaceMeshSegmentationRef.html#ga455877137a269a61c1b980609adeac78" title="Function computing the Shape Diameter Function over a surface mesh.">CGAL::sdf_values()</a></code></li>
<li><code>#<a class="el" href="group__PkgSurfaceMeshSegmentationRef.html#gaf57d1108ef1f1a6315e5e406006a4a3d" title="Function postprocessing raw SDF values computed per facet.">CGAL::sdf_values_postprocessing()</a></code></li>
<li><code>#<a class="el" href="group__PkgSurfaceMeshSegmentationRef.html#ga8a429857a748922d0e8460619db69764" title="Function computing the segmentation of a surface mesh given an SDF value per facet.">CGAL::segmentation_from_sdf_values()</a></code></li>
<li><code>#<a class="el" href="group__PkgSurfaceMeshSegmentationRef.html#gabc864f396347009726b858434c6d8659" title="Function computing the segmentation of a surface mesh.">CGAL::segmentation_via_sdf_values()</a></code> </li>
</ul>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__PkgSurfaceMeshSegmentationConcepts"><td class="memItemLeft" align="right" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="group__PkgSurfaceMeshSegmentationConcepts.html">Concepts</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga455877137a269a61c1b980609adeac78"><td class="memTemplParams" colspan="2">template&lt;class TriangleMesh , class SDFPropertyMap , class PointPropertyMap  = typename boost::property_map&lt;TriangleMesh, boost::vertex_point_t&gt;::type, class GeomTraits  = typename Kernel_traits&lt;typename boost::property_traits&lt;PointPropertyMap&gt;::value_type&gt;::Kernel&gt; </td></tr>
<tr class="memitem:ga455877137a269a61c1b980609adeac78"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; double, double &gt; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgSurfaceMeshSegmentationRef.html#ga455877137a269a61c1b980609adeac78">CGAL::sdf_values</a> (const TriangleMesh &amp;triangle_mesh, SDFPropertyMap sdf_values_map, double cone_angle=2.0/3.0 *CGAL_PI, std::size_t number_of_rays=25, bool postprocess=true, PointPropertyMap ppmap=PointPropertyMap(), GeomTraits traits=GeomTraits())</td></tr>
<tr class="memdesc:ga455877137a269a61c1b980609adeac78"><td class="mdescLeft"> </td><td class="mdescRight">Function computing the Shape Diameter Function over a surface mesh.  <br></td></tr>
<tr class="separator:ga455877137a269a61c1b980609adeac78"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaf57d1108ef1f1a6315e5e406006a4a3d"><td class="memTemplParams" colspan="2">template&lt;class TriangleMesh , class SDFPropertyMap &gt; </td></tr>
<tr class="memitem:gaf57d1108ef1f1a6315e5e406006a4a3d"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; double, double &gt; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgSurfaceMeshSegmentationRef.html#gaf57d1108ef1f1a6315e5e406006a4a3d">CGAL::sdf_values_postprocessing</a> (const TriangleMesh &amp;triangle_mesh, SDFPropertyMap sdf_values_map)</td></tr>
<tr class="memdesc:gaf57d1108ef1f1a6315e5e406006a4a3d"><td class="mdescLeft"> </td><td class="mdescRight">Function postprocessing raw SDF values computed per facet.  <br></td></tr>
<tr class="separator:gaf57d1108ef1f1a6315e5e406006a4a3d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga8a429857a748922d0e8460619db69764"><td class="memTemplParams" colspan="2">template&lt;class TriangleMesh , class SDFPropertyMap , class SegmentPropertyMap , class PointPropertyMap  = typename boost::property_map&lt;TriangleMesh, boost::vertex_point_t&gt;::type, class GeomTraits  = typename Kernel_traits&lt;typename boost::property_traits&lt;PointPropertyMap&gt;::value_type&gt;::Kernel&gt; </td></tr>
<tr class="memitem:ga8a429857a748922d0e8460619db69764"><td class="memTemplItemLeft" align="right" valign="top">std::size_t </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgSurfaceMeshSegmentationRef.html#ga8a429857a748922d0e8460619db69764">CGAL::segmentation_from_sdf_values</a> (const TriangleMesh &amp;triangle_mesh, SDFPropertyMap sdf_values_map, SegmentPropertyMap segment_ids, std::size_t number_of_clusters=5, double smoothing_lambda=0.26, bool output_cluster_ids=false, PointPropertyMap ppmap=PointPropertyMap(), GeomTraits traits=GeomTraits())</td></tr>
<tr class="memdesc:ga8a429857a748922d0e8460619db69764"><td class="mdescLeft"> </td><td class="mdescRight">Function computing the segmentation of a surface mesh given an SDF value per facet.  <br></td></tr>
<tr class="separator:ga8a429857a748922d0e8460619db69764"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gabc864f396347009726b858434c6d8659"><td class="memTemplParams" colspan="2">template&lt;class TriangleMesh , class SegmentPropertyMap , class PointPropertyMap  = typename boost::property_map&lt;TriangleMesh, boost::vertex_point_t&gt;::type, class GeomTraits  = typename Kernel_traits&lt;typename boost::property_traits&lt;PointPropertyMap&gt;::value_type&gt;::Kernel&gt; </td></tr>
<tr class="memitem:gabc864f396347009726b858434c6d8659"><td class="memTemplItemLeft" align="right" valign="top">std::size_t </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgSurfaceMeshSegmentationRef.html#gabc864f396347009726b858434c6d8659">CGAL::segmentation_via_sdf_values</a> (const TriangleMesh &amp;triangle_mesh, SegmentPropertyMap segment_ids, double cone_angle=2.0/3.0 *CGAL_PI, std::size_t number_of_rays=25, std::size_t number_of_clusters=5, double smoothing_lambda=0.26, bool output_cluster_ids=false, PointPropertyMap ppmap=PointPropertyMap(), GeomTraits traits=GeomTraits())</td></tr>
<tr class="memdesc:gabc864f396347009726b858434c6d8659"><td class="mdescLeft"> </td><td class="mdescRight">Function computing the segmentation of a surface mesh.  <br></td></tr>
<tr class="separator:gabc864f396347009726b858434c6d8659"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga455877137a269a61c1b980609adeac78" name="ga455877137a269a61c1b980609adeac78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga455877137a269a61c1b980609adeac78">◆ </a></span>sdf_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TriangleMesh , class SDFPropertyMap , class PointPropertyMap  = typename boost::property_map&lt;TriangleMesh, boost::vertex_point_t&gt;::type, class GeomTraits  = typename Kernel_traits&lt;typename boost::property_traits&lt;PointPropertyMap&gt;::value_type&gt;::Kernel&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; double, double &gt; CGAL::sdf_values </td>
          <td>(</td>
          <td class="paramtype">const TriangleMesh &amp; </td>
          <td class="paramname"><em>triangle_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SDFPropertyMap </td>
          <td class="paramname"><em>sdf_values_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double </td>
          <td class="paramname"><em>cone_angle</em> = <code>2.0 / 3.0 * CGAL_PI</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t </td>
          <td class="paramname"><em>number_of_rays</em> = <code>25</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>postprocess</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointPropertyMap </td>
          <td class="paramname"><em>ppmap</em> = <code>PointPropertyMap()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GeomTraits </td>
          <td class="paramname"><em>traits</em> = <code>GeomTraits()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/mesh_segmentation.h&gt;</code></p>

<p>Function computing the Shape Diameter Function over a surface mesh. </p>
<p>This function implements the Shape Diameter Function (SDF) as described in <a class="el" href="citelist.html#CITEREF_Shapira2008Consistent">[4]</a>. It is possible to compute raw SDF values (without postprocessing). In such a case, -1 is used to indicate when no SDF value could be computed for a facet.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="elRef" href="../BGL/group__PkgBGLHelperFct.html#ga11883d231eec1b58f37efe4acedd9588"><code>CGAL::is_triangle_mesh(tmesh)</code> </a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriangleMesh</td><td>a model of <code><a class="elRef" href="../BGL/classFaceListGraph.html">FaceListGraph</a></code> </td></tr>
    <tr><td class="paramname">SDFPropertyMap</td><td>a <code><a class="elRef" href="../Manual/classReadWritePropertyMap.html">ReadWritePropertyMap</a></code> with <code>boost::graph_traits&lt;TriangleMesh&gt;::face_descriptor</code> as key and <code>double</code> as value type </td></tr>
    <tr><td class="paramname">GeomTraits</td><td>a model of <code><a class="el" href="classSegmentationGeomTraits.html" title="The concept SegmentationGeomTraits describes the set of requirements of the geometric traits needed b...">SegmentationGeomTraits</a></code> </td></tr>
    <tr><td class="paramname">PointPropertyMap</td><td>a <code><a class="elRef" href="../Manual/classReadablePropertyMap.html">ReadablePropertyMap</a></code> with <code>boost::graph_traits&lt;TriangleMesh&gt;::vertex_descriptor</code> as key and <code>GeomTraits::Point_3</code> as value type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">triangle_mesh</td><td>surface mesh on which SDF values are computed </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sdf_values_map</td><td>the SDF value of each facet </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cone_angle</td><td>opening angle in radians for the cone of each facet </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">number_of_rays</td><td>number of rays picked in the cone of each facet. In our experiments, we observe that increasing the number of rays beyond the default has little effect on the quality of the segmentation result </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">postprocess</td><td>if <code>true</code>, <code><a class="el" href="group__PkgSurfaceMeshSegmentationRef.html#gaf57d1108ef1f1a6315e5e406006a4a3d" title="Function postprocessing raw SDF values computed per facet.">CGAL::sdf_values_postprocessing()</a></code> is called on raw SDF value computed. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">traits</td><td>traits class </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ppmap</td><td>point property map. An overload is provided with <code>get(boost::vertex_point,triangle_mesh)</code> as default.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>minimum and maximum raw SDF values if <code>postprocess</code> is <code>true</code>, otherwise minimum and maximum SDF values (before linear normalization) </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Surface_mesh_segmentation_2extract_segmentation_into_mesh_example_8cpp-example.html#a4">Surface_mesh_segmentation/extract_segmentation_into_mesh_example.cpp</a>, <a class="el" href="Surface_mesh_segmentation_2sdf_values_example_8cpp-example.html#a3">Surface_mesh_segmentation/sdf_values_example.cpp</a>, <a class="el" href="Surface_mesh_segmentation_2segmentation_from_sdf_values_SM_example_8cpp-example.html#a5">Surface_mesh_segmentation/segmentation_from_sdf_values_SM_example.cpp</a>, <a class="el" href="Surface_mesh_segmentation_2segmentation_from_sdf_values_example_8cpp-example.html#a3">Surface_mesh_segmentation/segmentation_from_sdf_values_example.cpp</a>, and <a class="el" href="Surface_mesh_segmentation_2segmentation_with_facet_ids_example_8cpp-example.html#a3">Surface_mesh_segmentation/segmentation_with_facet_ids_example.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="gaf57d1108ef1f1a6315e5e406006a4a3d" name="gaf57d1108ef1f1a6315e5e406006a4a3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf57d1108ef1f1a6315e5e406006a4a3d">◆ </a></span>sdf_values_postprocessing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TriangleMesh , class SDFPropertyMap &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; double, double &gt; CGAL::sdf_values_postprocessing </td>
          <td>(</td>
          <td class="paramtype">const TriangleMesh &amp; </td>
          <td class="paramname"><em>triangle_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SDFPropertyMap </td>
          <td class="paramname"><em>sdf_values_map</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/mesh_segmentation.h&gt;</code></p>

<p>Function postprocessing raw SDF values computed per facet. </p>
<p>Postprocessing steps applied :</p><ul>
<li>Facets with -1 SDF values are assigned the average SDF value of their edge-adjacent neighbors. If there is still a facet having -1 SDF value, the minimum valid SDF value assigned to it. Note that this step is not inherited from the paper. The main reason for not assigning 0 to facets with no SDF values (i.e., -1) is that it can obstruct log-normalization process which takes place at the beginning of <code><a class="el" href="group__PkgSurfaceMeshSegmentationRef.html#ga8a429857a748922d0e8460619db69764" title="Function computing the segmentation of a surface mesh given an SDF value per facet.">CGAL::segmentation_from_sdf_values()</a></code>.</li>
<li>SDF values are smoothed with bilateral filtering.</li>
<li>SDF values are linearly normalized between [0,1].</li>
</ul>
<p>See the section <a class="el" href="index.html#Surface_mesh_segmentationPostprocessing">Postprocessing of Raw SDF Values</a> for more details.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="elRef" href="../BGL/group__PkgBGLHelperFct.html#ga11883d231eec1b58f37efe4acedd9588"><code>CGAL::is_triangle_mesh(tmesh)</code> </a> </dd>
<dd>
Raw values should be greater or equal to 0. -1 indicates when no value could be computed</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriangleMesh</td><td>a model of <code><a class="elRef" href="../BGL/classFaceListGraph.html">FaceListGraph</a></code> </td></tr>
    <tr><td class="paramname">SDFPropertyMap</td><td>a <code><a class="elRef" href="../Manual/classReadWritePropertyMap.html">ReadWritePropertyMap</a></code> with <code>boost::graph_traits&lt;TriangleMesh&gt;::face_descriptor</code> as key and <code>double</code> as value type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">triangle_mesh</td><td>surface mesh on which SDF values are computed </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sdf_values_map</td><td>the SDF value of each facet</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>minimum and maximum SDF values before linear normalization </dd></dl>

</div>
</div>
<a id="ga8a429857a748922d0e8460619db69764" name="ga8a429857a748922d0e8460619db69764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a429857a748922d0e8460619db69764">◆ </a></span>segmentation_from_sdf_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TriangleMesh , class SDFPropertyMap , class SegmentPropertyMap , class PointPropertyMap  = typename boost::property_map&lt;TriangleMesh, boost::vertex_point_t&gt;::type, class GeomTraits  = typename Kernel_traits&lt;typename boost::property_traits&lt;PointPropertyMap&gt;::value_type&gt;::Kernel&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t CGAL::segmentation_from_sdf_values </td>
          <td>(</td>
          <td class="paramtype">const TriangleMesh &amp; </td>
          <td class="paramname"><em>triangle_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SDFPropertyMap </td>
          <td class="paramname"><em>sdf_values_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SegmentPropertyMap </td>
          <td class="paramname"><em>segment_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t </td>
          <td class="paramname"><em>number_of_clusters</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double </td>
          <td class="paramname"><em>smoothing_lambda</em> = <code>0.26</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>output_cluster_ids</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointPropertyMap </td>
          <td class="paramname"><em>ppmap</em> = <code>PointPropertyMap()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GeomTraits </td>
          <td class="paramname"><em>traits</em> = <code>GeomTraits()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/mesh_segmentation.h&gt;</code></p>

<p>Function computing the segmentation of a surface mesh given an SDF value per facet. </p>
<p>This function fills a property map which associates a segment-id (in [0, number of segments -1]) or a cluster-id (in [0, <code>number_of_clusters</code> -1]) to each facet. A segment is a set of connected facets which are placed under the same cluster (see <a class="el" href="index.html#fig__Cluster_vs_segment">Figure 80.5</a>).</p>
<dl class="section note"><dt>Note</dt><dd>Log-normalization is applied on <code>sdf_values_map</code> before segmentation. As described in the original paper <a class="el" href="citelist.html#CITEREF_Shapira2008Consistent">[4]</a>, this normalization is done to preserve thin parts of the mesh by increasing the distance between smaller SDF values and reducing it between larger ones. </dd>
<dd>
There is no direct relation between the parameter <code>number_of_clusters</code> and the final number of segments after segmentation. However, setting a large number of clusters will result in a detailed segmentation of the mesh with a large number of segments.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="elRef" href="../BGL/group__PkgBGLHelperFct.html#ga11883d231eec1b58f37efe4acedd9588"><code>CGAL::is_triangle_mesh(tmesh)</code> </a> </dd>
<dd>
<code>number_of_clusters &gt; 0</code></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriangleMesh</td><td>a model of <code><a class="elRef" href="../BGL/classFaceListGraph.html">FaceListGraph</a></code> </td></tr>
    <tr><td class="paramname">SDFPropertyMap</td><td>a <code><a class="elRef" href="../Manual/classReadablePropertyMap.html">ReadablePropertyMap</a></code> with <code>boost::graph_traits&lt;TriangleMesh&gt;::face_descriptor</code> as key and <code>double</code> as value type </td></tr>
    <tr><td class="paramname">SegmentPropertyMap</td><td>a <code><a class="elRef" href="../Manual/classReadWritePropertyMap.html">ReadWritePropertyMap</a></code> with <code>boost::graph_traits&lt;TriangleMesh&gt;::face_descriptor</code> as key and <code>std::size_t</code> as value type </td></tr>
    <tr><td class="paramname">GeomTraits</td><td>a model of <code><a class="el" href="classSegmentationGeomTraits.html" title="The concept SegmentationGeomTraits describes the set of requirements of the geometric traits needed b...">SegmentationGeomTraits</a></code> </td></tr>
    <tr><td class="paramname">PointPropertyMap</td><td>a <code><a class="elRef" href="../Manual/classReadablePropertyMap.html">ReadablePropertyMap</a></code> with <code>boost::graph_traits&lt;TriangleMesh&gt;::vertex_descriptor</code> as key and <code>GeomTraits::Point_3</code> as value type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">triangle_mesh</td><td>surface mesh corresponding to the SDF values </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sdf_values_map</td><td>the SDF value of each facet between [0-1] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">segment_ids</td><td>the segment or cluster id of each facet </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">number_of_clusters</td><td>number of clusters for the soft clustering </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">smoothing_lambda</td><td>factor which indicates the importance of the surface features for the energy minimization. It is recommended to choose a value in the interval [0,1]. See the section <a class="el" href="index.html#Surface_mesh_segmentationGraphCut">Hard clustering</a> for more details. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">output_cluster_ids</td><td>if <code>false</code> fill <code>segment_ids</code> with segment-ids, and with cluster-ids otherwise (see <a class="el" href="index.html#fig__Cluster_vs_segment">Figure 80.5</a>) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">traits</td><td>traits class </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ppmap</td><td>point property map. An overload is provided with <code>get(boost::vertex_point,triangle_mesh)</code> as default.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of segments if <code>output_cluster_ids</code> is set to <code>false</code> and <code>number_of_clusters</code> otherwise </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Surface_mesh_segmentation_2extract_segmentation_into_mesh_example_8cpp-example.html#a5">Surface_mesh_segmentation/extract_segmentation_into_mesh_example.cpp</a>, <a class="el" href="Surface_mesh_segmentation_2segmentation_from_sdf_values_SM_example_8cpp-example.html#a6">Surface_mesh_segmentation/segmentation_from_sdf_values_SM_example.cpp</a>, <a class="el" href="Surface_mesh_segmentation_2segmentation_from_sdf_values_example_8cpp-example.html#a4">Surface_mesh_segmentation/segmentation_from_sdf_values_example.cpp</a>, and <a class="el" href="Surface_mesh_segmentation_2segmentation_with_facet_ids_example_8cpp-example.html#a4">Surface_mesh_segmentation/segmentation_with_facet_ids_example.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="gabc864f396347009726b858434c6d8659" name="gabc864f396347009726b858434c6d8659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc864f396347009726b858434c6d8659">◆ </a></span>segmentation_via_sdf_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TriangleMesh , class SegmentPropertyMap , class PointPropertyMap  = typename boost::property_map&lt;TriangleMesh, boost::vertex_point_t&gt;::type, class GeomTraits  = typename Kernel_traits&lt;typename boost::property_traits&lt;PointPropertyMap&gt;::value_type&gt;::Kernel&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t CGAL::segmentation_via_sdf_values </td>
          <td>(</td>
          <td class="paramtype">const TriangleMesh &amp; </td>
          <td class="paramname"><em>triangle_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SegmentPropertyMap </td>
          <td class="paramname"><em>segment_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double </td>
          <td class="paramname"><em>cone_angle</em> = <code>2.0 / 3.0 * CGAL_PI</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t </td>
          <td class="paramname"><em>number_of_rays</em> = <code>25</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t </td>
          <td class="paramname"><em>number_of_clusters</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double </td>
          <td class="paramname"><em>smoothing_lambda</em> = <code>0.26</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>output_cluster_ids</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointPropertyMap </td>
          <td class="paramname"><em>ppmap</em> = <code>PointPropertyMap()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GeomTraits </td>
          <td class="paramname"><em>traits</em> = <code>GeomTraits()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/mesh_segmentation.h&gt;</code></p>

<p>Function computing the segmentation of a surface mesh. </p>
<p>This function is equivalent to calling the functions <code><a class="el" href="group__PkgSurfaceMeshSegmentationRef.html#ga455877137a269a61c1b980609adeac78" title="Function computing the Shape Diameter Function over a surface mesh.">CGAL::sdf_values()</a></code> and <code><a class="el" href="group__PkgSurfaceMeshSegmentationRef.html#ga8a429857a748922d0e8460619db69764" title="Function computing the segmentation of a surface mesh given an SDF value per facet.">CGAL::segmentation_from_sdf_values()</a></code> with the same parameters.</p>
<dl class="section note"><dt>Note</dt><dd>There is no direct relation between the parameter <code>number_of_clusters</code> and the final number of segments after segmentation. However, setting a large number of clusters will result in a detailed segmentation of the mesh with a large number of segments. </dd>
<dd>
For computing segmentations of the mesh with different parameters (i.e. number of levels, and smoothing lambda), it is more efficient to first compute the SDF values using <code><a class="el" href="group__PkgSurfaceMeshSegmentationRef.html#ga455877137a269a61c1b980609adeac78" title="Function computing the Shape Diameter Function over a surface mesh.">CGAL::sdf_values()</a></code> and use them in different calls to <code><a class="el" href="group__PkgSurfaceMeshSegmentationRef.html#ga8a429857a748922d0e8460619db69764" title="Function computing the segmentation of a surface mesh given an SDF value per facet.">CGAL::segmentation_from_sdf_values()</a></code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="elRef" href="../BGL/group__PkgBGLHelperFct.html#ga11883d231eec1b58f37efe4acedd9588"><code>CGAL::is_triangle_mesh(tmesh)</code> </a> </dd>
<dd>
<code>number_of_clusters &gt; 0</code></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriangleMesh</td><td>a model of <code><a class="elRef" href="../BGL/classFaceListGraph.html">FaceListGraph</a></code> </td></tr>
    <tr><td class="paramname">SegmentPropertyMap</td><td>a <code><a class="elRef" href="../Manual/classReadWritePropertyMap.html">ReadWritePropertyMap</a></code> with <code>boost::graph_traits&lt;TriangleMesh&gt;::face_descriptor</code> as key and <code>std::size_t</code> as value type </td></tr>
    <tr><td class="paramname">GeomTraits</td><td>a model of <code><a class="el" href="classSegmentationGeomTraits.html" title="The concept SegmentationGeomTraits describes the set of requirements of the geometric traits needed b...">SegmentationGeomTraits</a></code> </td></tr>
    <tr><td class="paramname">PointPropertyMap</td><td>a <code><a class="elRef" href="../Manual/classReadablePropertyMap.html">ReadablePropertyMap</a></code> with <code>boost::graph_traits&lt;TriangleMesh&gt;::vertex_descriptor</code> as key and <code>GeomTraits::Point_3</code> as value type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">triangle_mesh</td><td>surface mesh on which SDF values are computed </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">segment_ids</td><td>the segment or cluster id of each facet </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cone_angle</td><td>opening angle in radians for the cone of each facet </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">number_of_rays</td><td>number of rays picked in the cone of each facet. In our experiments, we observe that increasing the number of rays beyond the default has a little effect on the quality of the segmentation result </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">number_of_clusters</td><td>number of clusters for the soft clustering </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">smoothing_lambda</td><td>factor which indicates the importance of the surface features for the energy minimization. It is recommended to choose a value in the interval [0,1]. See the section <a class="el" href="index.html#Surface_mesh_segmentationGraphCut">Hard clustering</a> for more details. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">output_cluster_ids</td><td>if <code>false</code> fill <code>segment_ids</code> with segment-ids, and with cluster-ids otherwise (see <a class="el" href="index.html#fig__Cluster_vs_segment">Figure 80.5</a>) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">traits</td><td>traits class </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ppmap</td><td>point property map. An overload is provided with <code>get(boost::vertex_point,triangle_mesh)</code> as default.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of segments if <code>output_cluster_ids</code> is set to <code>false</code> and <code>number_of_clusters</code> otherwise </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Surface_mesh_segmentation_2segmentation_via_sdf_values_example_8cpp-example.html#a3">Surface_mesh_segmentation/segmentation_via_sdf_values_example.cpp</a>.</dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"></a> 1.9.6 </li>
  </ul>
</div>
</div>
</body>


</html>
