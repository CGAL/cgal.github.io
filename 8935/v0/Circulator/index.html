<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Circulator/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=11">
<meta name="generator" content="Doxygen 1.9.6">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CGAL 6.1 - Handles and Circulators: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/doxygen.css" rel="stylesheet" type="text/css">
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      },
      equationNumbers: { autoNumber: "AMS" }
  }
}
);
MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
  var PARSE = MathJax.InputJax.TeX.Parse,
      TEXT = PARSE.prototype.InternalText;
  PARSE.Augment({
    InternalText: function (text,def) {
      text = text.replace(/\\/g,"");
      return TEXT.call(this,text,def);
    }
  });
});
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
      <span class="left">
         <span id="MSearchSelect" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()">Â 
        </span>
        <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
      </span>
      <span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.svg" alt=""></a>
      </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CGAL 6.1 - Handles and Circulators
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search/",'.html');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">User Manual </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Handles_Ranges_and_Circulators"></a><a class="anchor" id="chapterCirculators"></a> </p> <div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Authors</dt><dd>Olivier Devillers, Lutz Kettner, Sylvain Pion, Michael Seel, and Mariette Yvinec</dd></dl>
<h1><a class="anchor" id="CirculatorHandles"></a>
Handles</h1>
<p>Most data structures in CGAL use the concept of <code><a class="el" href="classHandle.html" title="Most data structures in CGAL use the concept of Handle in their user interface to refer to the elemen...">Handle</a></code> in their user interface to refer to the elements they store. This concept describes what is sometimes called a trivial iterator. A <code><a class="el" href="classHandle.html" title="Most data structures in CGAL use the concept of Handle in their user interface to refer to the elemen...">Handle</a></code> is akin to a pointer to an object providing the dereference operator <code>operator*()</code> and member access <code>operator-&gt;()</code> but no increment or decrement operators like iterators. A <code><a class="el" href="classHandle.html" title="Most data structures in CGAL use the concept of Handle in their user interface to refer to the elemen...">Handle</a></code> is intended to be used whenever the referenced object is not part of a logical sequence.</p>
<p><b>Model for a handle</b> A simple pointer <code>T*</code>, an iterator or a circulator with value type <code>T</code>, are also handles.</p>
<h1><a class="anchor" id="CirculatorRanges"></a>
Ranges</h1>
<p>Most data structures in CGAL use the concept of an iterator range. The <code><a class="el" href="classRange.html" title="CGAL and the STL heavily use the concepts of iterators and iterator ranges to describe linear sequenc...">Range</a></code> and <code><a class="el" href="classConstRange.html" title="A constant iterator range. Refer to the Range concept for more details.">ConstRange</a></code> concepts encapsulate the access to the first and the past-the-end iterators of an iterator range. STL containers are models of <code><a class="el" href="classRange.html" title="CGAL and the STL heavily use the concepts of iterators and iterator ranges to describe linear sequenc...">Range</a></code>. The Boost.Range library provides good support around this concept as well.</p>
<h1><a class="anchor" id="circulatorsCirculators"></a>
Circulators</h1>
<p>An introduction to the concept of circulators is given here. A couple of adaptors are presented that convert between iterators and circulators. Some useful functions for circulators follow. This chapter concludes with a discussion of the design decisions taken. For the full description of the circulator requirements, the provided base classes, the circulator tags, and the support for generic algorithms that work for iterators as well as for circulators please refer to the reference pages. Note that circulators are not part of STL, but of CGAL.</p>
<h2><a class="anchor" id="sectionIntroduction"></a>
Introduction</h2>
<p>The concept of iterators in STL is tailored for linear sequences <a class="el" href="citelist.html#CITEREF_cgal:ansi-is14882-98">[1]</a>, <a class="el" href="citelist.html#CITEREF_cgal:ms-strg-96">[2]</a>. In contrast, circular sequences occur naturally in many combinatorial and geometric structures. Examples are polyhedral surfaces and planar maps, where the edges emanating from a vertex or the edges around a facet form a circular sequence.</p>
<p>Since circular sequences do not allow for efficient iterators, we have introduced the new concept of <em>circulators</em>. They share most of the requirements of iterators, while the main difference is the lack of a past-the-end position in the sequence. Appropriate adaptors are provided between iterators and circulators to integrate circulators smoothly into the framework of STL. An example of a generic <code>contains</code> function illustrates the use of circulators. As usual for circular structures, a <code>do</code>-<code>while</code> loop is preferable, such that for the specific input, <code>c == d</code>, all elements in the sequence are reached.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Circulator, <span class="keyword">class</span> T&gt;</div>
<div class="line"><span class="keywordtype">bool</span> contains( <a class="code hl_class" href="classCirculator.html">Circulator</a> c, <a class="code hl_class" href="classCirculator.html">Circulator</a> d, <span class="keyword">const</span> T&amp; value) {</div>
<div class="line">  <span class="keywordflow">if</span> (c != 0) {</div>
<div class="line">    <span class="keywordflow">do</span> {</div>
<div class="line">      <span class="keywordflow">if</span> (*c == value)</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    } <span class="keywordflow">while</span> (++c != d);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="ttc" id="aclassCirculator_html"><div class="ttname"><a href="classCirculator.html">Circulator</a></div><div class="ttdoc">A Circulator is similar to an Iterator, with the difference that it is designed for circular data str...</div><div class="ttdef"><b>Definition:</b> Circulator.h:297</div></div>
</div><!-- fragment --><p>Three circulator categories are defined: forward, bidirectional and random-access circulators. Given a circulator <code>c</code>, the operation <code>*c</code> denotes the item the circulator refers to. The operation <code>++c</code> advances the circulator by one item and <code>-c</code> steps a bidirectional circulator one item backwards. For random-access circulators <code>c+n</code> advances the circulator <code>n</code> steps. Two circulators can be compared for equality.</p>
<p>Circulators have a different notion of reachability and ranges than iterators. A circulator <code>d</code> is called <em>reachable</em> from a circulator <code>c</code> if <code>c</code> can be made equal to <code>d</code> with finitely many applications of the operator <code>++</code>. Due to the circularity of the sequence this is always true if both circulators refer to items of the same sequence. In particular, <code>c</code> is always reachable from <code>c</code>. Given two circulators <code>c</code> and <code>d</code>, the range <code>[c,d)</code> denotes all circulators obtained by starting with <code>c</code> and advancing <code>c</code> until <code>d</code> is reached, but does not include <code>d</code>, for <code>d != c</code>. So far it is the same range definition as for iterators. The difference lies in the use of <code>[c,c)</code> to denote all items in the circular sequence, whereas for an iterator <code>i</code> the range <code>[i,i)</code> denotes the empty range. As long as <code>c != d</code> the range <code>[c,d)</code> behaves like an iterator range and could be used in STL algorithms. For circulators however, an additional test <code>c == nullptr</code> is required that returns true if and only if the circular sequence is empty. As for C++, we recommend the use of 0 instead of <code>nullptr</code>.</p>
<p>Besides the conceptual cleanness, the main reason for inventing a new concept with a similar intent as iterators is efficiency. An iterator is supposed to be a light-weight object - merely a pointer and a single indirection to advance the iterator. Although iterators could be written for circular sequences, we do not know of an efficient solution. The missing past-the-end situation in circular sequences can be solved with an arbitrary sentinel in the cyclic order, but this would destroy the natural symmetry in the structure (which is in itself a bad idea) and additional bookkeeping in the items and checking in the iterator advance method reduces efficiency. Another solution may use more bookkeeping in the iterator, e.g. with a start item, a current item, and a kind of winding-number that is zero for the <code>begin()</code>-iterator and one for the past-the-end situation<span class="footnote">This is currently implemented as the adaptor class which provides a pair of iterators for a given circulator.</span>. We have introduced the concept of circulators that allows light-weight implementations and the CGAL support library provides adaptor classes that convert between iterators and circulators (with the corresponding penalty in efficiency), so as to integrate this new concept into the framework of STL.</p>
<p>A serious design problem is the slight change of the semantic for circulator ranges as compared to iterator ranges. Since this semantic is defined by the intuitive operators <code>++</code> and <code>==</code>, which we would like to keep for circulators as well, circulator ranges can be used in STL algorithms. This is in itself a useful feature, if there would not be the definition of a full range <code>[c, c)</code> that an STL algorithm will treat as an empty range. However, the likelihood of a mistake may be overestimated, since for a container <code>C</code> supporting circulators there is no <code>end()</code> member function, and an expression such as <code>std::sort( C.begin(), C.end())</code> will fail. It is easy to distinguish iterators and circulators at compile time, which allows for generic algorithms supporting both as arguments. It is also possible to protect algorithms against inappropriate arguments using the same technique, see the reference pages for circulators, specifically the <code><a class="el" href="group__PkgHandlesAndCirculatorsAssert.html#ga28a51d41a222f90c19b75bc6f5e1155f" title="checks at compile time if its argument is an iterator.">Assert_iterator()</a></code> and <code><a class="el" href="group__PkgHandlesAndCirculatorsFunctions.html#gaf4e8c8285d91a1d8acd582191da0f255" title="is true if the range [i, j) is empty, false otherwise.">is_empty_range()</a></code> functions.</p>
<p><a class="anchor" id="sectionCirculatorWarning"></a></p><dl class="section attention"><dt>Attention</dt><dd>Please note that the definition of a range is different from that of iterators. An interface of a data structure must declare whether it works with iterators, circulators, or both. STL algorithms always specify only iterators in their interfaces. A range <code>[c, d)</code> of circulators used in an interface for iterators will work as expected as long as <code>c != d</code>. A range <code>[c, c)</code> will be interpreted as the empty range like for iterators, which is different than the full range that it should denote for circulators.</dd></dl>
<h2><a class="anchor" id="sectionCirculatorAdaptor"></a>
Adaptors Between Iterators and Circulators</h2>
<p>Algorithms working on iterator ranges can not be applied to circulator ranges in full generality, only to subranges as pointed out in the previous section. The following adaptors convert circulators to iterators and vice versa (with the unavoidable space and time penalty) to reestablish this generality.</p>
<ul>
<li><code><a class="el" href="classCGAL_1_1Container__from__circulator.html" title="The adaptor Container_from_circulator is a class that converts any circulator type C to a kind of con...">Container_from_circulator</a></code> is a container-like class with iterators built from a circulator</li>
<li><code><a class="el" href="classCGAL_1_1Circulator__from__iterator.html" title="The adaptor Circulator_from_iterator converts two iterators of type I, a begin and a past-the-end val...">Circulator_from_iterator</a></code> is a circulator over a range of two iterators</li>
<li><code><a class="el" href="classCGAL_1_1Circulator__from__container.html" title="The adaptor Circulator_from_container provides a circulator for an STL container C of equal category ...">Circulator_from_container</a></code> is a circulator for a container</li>
</ul>
<p>The following example applies the generic <code>std::reverse()</code> algorithm from STL to a sequence given by a bidirectional circulator <code>c</code>. It uses the <code><a class="el" href="classCGAL_1_1Container__from__circulator.html" title="The adaptor Container_from_circulator is a class that converts any circulator type C to a kind of con...">Container_from_circulator</a></code> adaptor.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classCirculator.html">Circulator</a> c; <span class="comment">// c must be at least bidirectional.</span></div>
<div class="line"><a class="code hl_class" href="classCGAL_1_1Container__from__circulator.html">CGAL::Container_from_circulator&lt;Circulator&gt;</a> container(c);</div>
<div class="line">std::reverse( container.begin(), container.end());</div>
<div class="ttc" id="aclassCGAL_1_1Container__from__circulator_html"><div class="ttname"><a href="classCGAL_1_1Container__from__circulator.html">CGAL::Container_from_circulator</a></div><div class="ttdoc">The adaptor Container_from_circulator is a class that converts any circulator type C to a kind of con...</div><div class="ttdef"><b>Definition:</b> circulator.h:430</div></div>
</div><!-- fragment --><p>Another example defines a circulator <code>c</code> for a vector of <code>int</code>'s. However, since there are no elements in the vector, the circulator denotes an empty sequence. If there were elements in the vector, the circulator would implement a random access modulus the size of the sequence.</p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; v;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classCGAL_1_1Circulator__from__iterator.html">CGAL::Circulator_from_iterator&lt; std::vector&lt;int&gt;::iterator</a> &gt; <a class="code hl_class" href="classCirculator.html">Circulator</a>;</div>
<div class="line"><a class="code hl_class" href="classCirculator.html">Circulator</a> c( v.begin(), v.end());</div>
<div class="ttc" id="aclassCGAL_1_1Circulator__from__iterator_html"><div class="ttname"><a href="classCGAL_1_1Circulator__from__iterator.html">CGAL::Circulator_from_iterator</a></div><div class="ttdoc">The adaptor Circulator_from_iterator converts two iterators of type I, a begin and a past-the-end val...</div><div class="ttdef"><b>Definition:</b> circulator.h:224</div></div>
</div><!-- fragment --><h2><a class="anchor" id="sectionCirculatorFunctions"></a>
Functions on Circulators</h2>
<p>Several functions deal with circulators and circulator ranges. The type <code>C</code> denotes a circulator. The type <code>IC</code> denotes either a circulator or an iterator. More on algorithms that work with circulators as well with iterators can be found in the reference pages.</p>
<div class="fragment"><div class="line">C c, d;</div>
<div class="line">IC ic1, ic2;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="group__PkgHandlesAndCirculatorsFunctions.html#ga2d7bfa21e8eb046b8ae90104aa4fcce4">circulator_size</a>(c);          <span class="comment">// size of the sequence reachable by c</span></div>
<div class="line"><a class="code hl_function" href="group__PkgHandlesAndCirculatorsFunctions.html#gaa7e7be37f74469fd362a65b9263f290f">circulator_distance</a>(c, d);   <span class="comment">// number of elements in the range [c, d)</span></div>
<div class="line"><a class="code hl_function" href="group__PkgHandlesAndCirculatorsFunctions.html#gadaabb38d2411a4370d963a07c55ea3a8">iterator_distance</a>(ic1, ic2); <span class="comment">// number of elements in the range [ic2, ic1)</span></div>
<div class="line"><a class="code hl_function" href="group__PkgHandlesAndCirculatorsFunctions.html#gaf4e8c8285d91a1d8acd582191da0f255">is_empty_range</a>(ic1, ic2);    <span class="comment">// test the range [ic2, ic1) for emptiness</span></div>
<div class="ttc" id="agroup__PkgHandlesAndCirculatorsFunctions_html_ga2d7bfa21e8eb046b8ae90104aa4fcce4"><div class="ttname"><a href="group__PkgHandlesAndCirculatorsFunctions.html#ga2d7bfa21e8eb046b8ae90104aa4fcce4">CGAL::circulator_size</a></div><div class="ttdeci">C::size_type circulator_size(C c)</div><div class="ttdoc">The size of a circulator is the size of the data structure it refers to.</div></div>
<div class="ttc" id="agroup__PkgHandlesAndCirculatorsFunctions_html_gaa7e7be37f74469fd362a65b9263f290f"><div class="ttname"><a href="group__PkgHandlesAndCirculatorsFunctions.html#gaa7e7be37f74469fd362a65b9263f290f">CGAL::circulator_distance</a></div><div class="ttdeci">C::difference_type circulator_distance(C c, C d)</div><div class="ttdoc">The distance of a circulator c to a circulator d is the number of elements in the range [c,...</div></div>
<div class="ttc" id="agroup__PkgHandlesAndCirculatorsFunctions_html_gadaabb38d2411a4370d963a07c55ea3a8"><div class="ttname"><a href="group__PkgHandlesAndCirculatorsFunctions.html#gadaabb38d2411a4370d963a07c55ea3a8">CGAL::iterator_distance</a></div><div class="ttdeci">iterator_traits&lt; IC &gt;::difference_type iterator_distance(IC ic1, IC ic2)</div><div class="ttdoc">The following function returns the distance between either two iterators or two circulators.</div></div>
<div class="ttc" id="agroup__PkgHandlesAndCirculatorsFunctions_html_gaf4e8c8285d91a1d8acd582191da0f255"><div class="ttname"><a href="group__PkgHandlesAndCirculatorsFunctions.html#gaf4e8c8285d91a1d8acd582191da0f255">CGAL::is_empty_range</a></div><div class="ttdeci">bool is_empty_range(const IC &amp;i, const IC &amp;j)</div><div class="ttdoc">is true if the range [i, j) is empty, false otherwise.</div></div>
</div><!-- fragment --> </div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"></a> 1.9.6 </li>
  </ul>
</div>
</div>
</body>

</html>
