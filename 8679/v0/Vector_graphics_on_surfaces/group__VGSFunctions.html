<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Vector_graphics_on_surfaces/group__VGSFunctions.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=11">
<meta name="generator" content="Doxygen 1.9.6">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CGAL 6.0 - Vector Graphics on Triangulated Surface Meshes: Functions</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/doxygen.css" rel="stylesheet" type="text/css">
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      },
      equationNumbers: { autoNumber: "AMS" }
  }
}
);
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
      <span class="left">
         <span id="MSearchSelect" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"> 
        </span>
        <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
      </span>
      <span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.svg" alt=""></a>
      </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CGAL 6.0 - Vector Graphics on Triangulated Surface Meshes
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search/",'.html');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__VGSFunctions.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Functions<div class="ingroups"><a class="el" href="group__PkgVGoS__Ref.html">Vector Graphics on Triangulated Surface Meshes Reference</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader"> </h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae3cabfdfa1368ed3263071ccce5ad3c4"><td class="memTemplParams" colspan="2">template&lt;class FT , class TriangleMesh , class EdgeLocationRange &gt; </td></tr>
<tr class="memitem:gae3cabfdfa1368ed3263071ccce5ad3c4"><td class="memTemplItemLeft" align="right" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__VGSFunctions.html#gae3cabfdfa1368ed3263071ccce5ad3c4">CGAL::Vector_graphics_on_surfaces::locally_shortest_path</a> (<a class="elRef" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">CGAL::Polygon_mesh_processing::Face_location</a>&lt; TriangleMesh, FT &gt; src, <a class="elRef" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">CGAL::Polygon_mesh_processing::Face_location</a>&lt; TriangleMesh, FT &gt; tgt, const TriangleMesh &amp;tmesh, EdgeLocationRange &amp;edge_locations, const <a class="el" href="structCGAL_1_1Vector__graphics__on__surfaces_1_1Dual__geodesic__solver.html">Dual_geodesic_solver</a>&lt; FT &gt; &amp;solver)</td></tr>
<tr class="memdesc:gae3cabfdfa1368ed3263071ccce5ad3c4"><td class="mdescLeft"> </td><td class="mdescRight">computes an approximated geodesic shortest path between two locations on a <code>tmesh</code>.  <br></td></tr>
<tr class="separator:gae3cabfdfa1368ed3263071ccce5ad3c4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga36d3f5cce3aa7a2d2f7379093647e918"><td class="memTemplParams" colspan="2">template&lt;class TriangleMesh , class FT &gt; </td></tr>
<tr class="memitem:ga36d3f5cce3aa7a2d2f7379093647e918"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="elRef" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">CGAL::Polygon_mesh_processing::Face_location</a>&lt; TriangleMesh, FT &gt; &gt; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__VGSFunctions.html#ga36d3f5cce3aa7a2d2f7379093647e918">CGAL::Vector_graphics_on_surfaces::recursive_de_Casteljau</a> (const TriangleMesh &amp;mesh, const <a class="el" href="group__VGSMiscellaneous.html#ga33529a30fe5deb5cc0bb71b06c3cce6f">Bezier_segment</a>&lt; TriangleMesh, FT &gt; &amp;control_points, const int num_subdiv, const <a class="el" href="structCGAL_1_1Vector__graphics__on__surfaces_1_1Dual__geodesic__solver.html">Dual_geodesic_solver</a>&lt; FT &gt; &amp;solver=<a class="el" href="structCGAL_1_1Vector__graphics__on__surfaces_1_1Dual__geodesic__solver.html">Dual_geodesic_solver</a>&lt; FT &gt;())</td></tr>
<tr class="memdesc:ga36d3f5cce3aa7a2d2f7379093647e918"><td class="mdescLeft"> </td><td class="mdescRight">computes a discretization of a Bézier segment defined by the location of four control points on <code>tmesh</code>.  <br></td></tr>
<tr class="separator:ga36d3f5cce3aa7a2d2f7379093647e918"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga77d40acb67e61b6be0cc9be33248650b"><td class="memTemplParams" colspan="2">template&lt;class K , class TriangleMesh &gt; </td></tr>
<tr class="memitem:ga77d40acb67e61b6be0cc9be33248650b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="elRef" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">CGAL::Polygon_mesh_processing::Face_location</a>&lt; TriangleMesh, typename K::FT &gt; &gt; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__VGSFunctions.html#ga77d40acb67e61b6be0cc9be33248650b">CGAL::Vector_graphics_on_surfaces::straightest_geodesic</a> (const <a class="elRef" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">CGAL::Polygon_mesh_processing::Face_location</a>&lt; TriangleMesh, typename K::FT &gt; &amp;src, const typename K::Vector_2 &amp;dir, const typename K::FT len, const TriangleMesh &amp;tmesh)</td></tr>
<tr class="memdesc:ga77d40acb67e61b6be0cc9be33248650b"><td class="mdescLeft"> </td><td class="mdescRight">computes a path on a triangle mesh that is computed by starting a walk on <code>tmesh</code> given a direction and a maximum distance.  <br></td></tr>
<tr class="separator:ga77d40acb67e61b6be0cc9be33248650b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga751dea8a73cbf18d11ed477ad91cb77d"><td class="memTemplParams" colspan="2">template&lt;class K , class TriangleMesh &gt; </td></tr>
<tr class="memitem:ga751dea8a73cbf18d11ed477ad91cb77d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="elRef" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">CGAL::Polygon_mesh_processing::Face_location</a>&lt; TriangleMesh, typename K::FT &gt; &gt; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__VGSFunctions.html#ga751dea8a73cbf18d11ed477ad91cb77d">CGAL::Vector_graphics_on_surfaces::trace_geodesic_polygon</a> (const <a class="elRef" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">CGAL::Polygon_mesh_processing::Face_location</a>&lt; TriangleMesh, typename K::FT &gt; &amp;center, const std::vector&lt; typename K::Vector_2 &gt; &amp;directions, const std::vector&lt; typename K::FT &gt; &amp;lengths, const TriangleMesh &amp;tmesh, const <a class="el" href="structCGAL_1_1Vector__graphics__on__surfaces_1_1Dual__geodesic__solver.html">Dual_geodesic_solver</a>&lt; typename K::FT &gt; &amp;solver={})</td></tr>
<tr class="memdesc:ga751dea8a73cbf18d11ed477ad91cb77d"><td class="mdescLeft"> </td><td class="mdescRight">computes the face location of each vertex of a 2D polygon on <code>tmesh</code>.  <br></td></tr>
<tr class="separator:ga751dea8a73cbf18d11ed477ad91cb77d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga5966853b004c327fff062ed41621a0fa"><td class="memTemplParams" colspan="2">template&lt;class K , class TriangleMesh &gt; </td></tr>
<tr class="memitem:ga5966853b004c327fff062ed41621a0fa"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="elRef" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">CGAL::Polygon_mesh_processing::Face_location</a>&lt; TriangleMesh, typename K::FT &gt; &gt; &gt; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__VGSFunctions.html#ga5966853b004c327fff062ed41621a0fa">CGAL::Vector_graphics_on_surfaces::trace_geodesic_polygons</a> (const <a class="elRef" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">CGAL::Polygon_mesh_processing::Face_location</a>&lt; TriangleMesh, typename K::FT &gt; &amp;center, const std::vector&lt; std::vector&lt; typename K::Point_2 &gt; &gt; &amp;polygons, const typename K::FT scaling, const TriangleMesh &amp;tmesh, const <a class="el" href="structCGAL_1_1Vector__graphics__on__surfaces_1_1Dual__geodesic__solver.html">Dual_geodesic_solver</a>&lt; typename K::FT &gt; &amp;solver={})</td></tr>
<tr class="memdesc:ga5966853b004c327fff062ed41621a0fa"><td class="mdescLeft"> </td><td class="mdescRight">computes for each vertex of each polygon in <code>polygons</code> a face location on <code>tmesh</code>, where <code>center</code> represents the center of the 2D bounding box of the polygons.  <br></td></tr>
<tr class="separator:ga5966853b004c327fff062ed41621a0fa"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga7fb4a93991531410f9bcda6e9935444e"><td class="memTemplParams" colspan="2">template&lt;class K , class TriangleMesh &gt; </td></tr>
<tr class="memitem:ga7fb4a93991531410f9bcda6e9935444e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="elRef" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">CGAL::Polygon_mesh_processing::Face_location</a>&lt; TriangleMesh, typename K::FT &gt; &gt; &gt; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__VGSFunctions.html#ga7fb4a93991531410f9bcda6e9935444e">CGAL::Vector_graphics_on_surfaces::trace_geodesic_label</a> (const <a class="elRef" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">CGAL::Polygon_mesh_processing::Face_location</a>&lt; TriangleMesh, typename K::FT &gt; &amp;center, const std::vector&lt; std::vector&lt; typename K::Point_2 &gt; &gt; &amp;polygons, const typename K::FT scaling, const TriangleMesh &amp;tmesh, const <a class="el" href="structCGAL_1_1Vector__graphics__on__surfaces_1_1Dual__geodesic__solver.html">Dual_geodesic_solver</a>&lt; typename K::FT &gt; &amp;solver={})</td></tr>
<tr class="memdesc:ga7fb4a93991531410f9bcda6e9935444e"><td class="mdescLeft"> </td><td class="mdescRight">computes for each vertex of each polygon in <code>polygons</code> a face location on <code>tmesh</code>, where <code>center</code> represents the center of the 2D bounding box of the polygons.  <br></td></tr>
<tr class="separator:ga7fb4a93991531410f9bcda6e9935444e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gadb83a7cae7993f2c6609ba3ad0eee944"><td class="memTemplParams" colspan="2">template&lt;class K , class TriangleMesh &gt; </td></tr>
<tr class="memitem:gadb83a7cae7993f2c6609ba3ad0eee944"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="elRef" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">CGAL::Polygon_mesh_processing::Face_location</a>&lt; TriangleMesh, typename K::FT &gt; &gt; &gt; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__VGSFunctions.html#gadb83a7cae7993f2c6609ba3ad0eee944">CGAL::Vector_graphics_on_surfaces::trace_geodesic_label_along_curve</a> (const std::vector&lt; <a class="elRef" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">CGAL::Polygon_mesh_processing::Face_location</a>&lt; TriangleMesh, typename K::FT &gt; &gt; &amp;supporting_curve, const std::vector&lt; std::vector&lt; typename K::Point_2 &gt; &gt; &amp;polygons, const typename K::FT scaling, const typename K::FT padding, const bool is_centered, const TriangleMesh &amp;tmesh, const <a class="el" href="structCGAL_1_1Vector__graphics__on__surfaces_1_1Dual__geodesic__solver.html">Dual_geodesic_solver</a>&lt; typename K::FT &gt; &amp;solver={})</td></tr>
<tr class="memdesc:gadb83a7cae7993f2c6609ba3ad0eee944"><td class="mdescLeft"> </td><td class="mdescRight">computes for each vertex of each polygon in <code>polygons</code> a face location on <code>tmesh</code> along the curve <code>supporting_curve</code>.  <br></td></tr>
<tr class="separator:gadb83a7cae7993f2c6609ba3ad0eee944"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gabd0c70a9ee4c6247b20e1b139977706c"><td class="memTemplParams" colspan="2">template&lt;class K , class TriangleMesh &gt; </td></tr>
<tr class="memitem:gabd0c70a9ee4c6247b20e1b139977706c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="elRef" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">CGAL::Polygon_mesh_processing::Face_location</a>&lt; TriangleMesh, typename K::FT &gt; &gt; &gt; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__VGSFunctions.html#gabd0c70a9ee4c6247b20e1b139977706c">CGAL::Vector_graphics_on_surfaces::trace_bezier_curves</a> (const <a class="elRef" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">CGAL::Polygon_mesh_processing::Face_location</a>&lt; TriangleMesh, typename K::FT &gt; &amp;center, const std::vector&lt; std::array&lt; typename K::Vector_2, 4 &gt; &gt; &amp;directions, const std::vector&lt; std::array&lt; typename K::FT, 4 &gt; &gt; &amp;lengths, const int num_subdiv, const TriangleMesh &amp;tmesh, const <a class="el" href="structCGAL_1_1Vector__graphics__on__surfaces_1_1Dual__geodesic__solver.html">Dual_geodesic_solver</a>&lt; typename K::FT &gt; &amp;solver={})</td></tr>
<tr class="memdesc:gabd0c70a9ee4c6247b20e1b139977706c"><td class="mdescLeft"> </td><td class="mdescRight">computes a path representing a Bézier curve defined by four control points.  <br></td></tr>
<tr class="separator:gabd0c70a9ee4c6247b20e1b139977706c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga3930b8c9d284ac52cf0969d2da2a6138"><td class="memTemplParams" colspan="2">template&lt;class K , class TriangleMesh &gt; </td></tr>
<tr class="memitem:ga3930b8c9d284ac52cf0969d2da2a6138"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="elRef" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">CGAL::Polygon_mesh_processing::Face_location</a>&lt; TriangleMesh, typename K::FT &gt; &gt; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__VGSFunctions.html#ga3930b8c9d284ac52cf0969d2da2a6138">CGAL::Vector_graphics_on_surfaces::trace_polyline_of_bezier_curves</a> (const <a class="elRef" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">CGAL::Polygon_mesh_processing::Face_location</a>&lt; TriangleMesh, typename K::FT &gt; &amp;center, const std::vector&lt; typename K::Vector_2 &gt; &amp;directions, const std::vector&lt; typename K::FT &gt; &amp;lengths, bool <a class="elRef" href="../BGL/group__PkgBGLHelperFct.html#gae04c8044cf1eee6a84baa5b79ab99fef">is_closed</a>, const int num_subdiv, const TriangleMesh &amp;tmesh, const <a class="el" href="structCGAL_1_1Vector__graphics__on__surfaces_1_1Dual__geodesic__solver.html">Dual_geodesic_solver</a>&lt; typename K::FT &gt; &amp;solver={})</td></tr>
<tr class="memdesc:ga3930b8c9d284ac52cf0969d2da2a6138"><td class="mdescLeft"> </td><td class="mdescRight">computes a path representing a Bézier polyline (a sequence of Bézier curves having an identical control points, that is the fourth control point of the nth curve is the first control point of the (n+1)th curve).  <br></td></tr>
<tr class="separator:ga3930b8c9d284ac52cf0969d2da2a6138"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gad3c42245b9590055f0239e5cad485e0b"><td class="memTemplParams" colspan="2">template&lt;class K , class TriangleMesh , class VNM , class FNM , class <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> &gt; </td></tr>
<tr class="memitem:gad3c42245b9590055f0239e5cad485e0b"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__VGSFunctions.html#gad3c42245b9590055f0239e5cad485e0b">CGAL::Vector_graphics_on_surfaces::refine_mesh_along_paths</a> (const std::vector&lt; std::vector&lt; <a class="elRef" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">CGAL::Polygon_mesh_processing::Face_location</a>&lt; TriangleMesh, typename K::FT &gt; &gt; &gt; &amp;paths, TriangleMesh &amp;tmesh, VNM vnm, FNM fnm, <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> out)</td></tr>
<tr class="memdesc:gad3c42245b9590055f0239e5cad485e0b"><td class="mdescLeft"> </td><td class="mdescRight">refines <code>tmesh</code> so that each path in <code>paths</code> corresponds to a set edges of <code>tmesh</code> after the call.  <br></td></tr>
<tr class="separator:gad3c42245b9590055f0239e5cad485e0b"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="gae3cabfdfa1368ed3263071ccce5ad3c4" name="gae3cabfdfa1368ed3263071ccce5ad3c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3cabfdfa1368ed3263071ccce5ad3c4">◆ </a></span>locally_shortest_path()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FT , class TriangleMesh , class EdgeLocationRange &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CGAL::Vector_graphics_on_surfaces::locally_shortest_path </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">CGAL::Polygon_mesh_processing::Face_location</a>&lt; TriangleMesh, FT &gt; </td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">CGAL::Polygon_mesh_processing::Face_location</a>&lt; TriangleMesh, FT &gt; </td>
          <td class="paramname"><em>tgt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TriangleMesh &amp; </td>
          <td class="paramname"><em>tmesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeLocationRange &amp; </td>
          <td class="paramname"><em>edge_locations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structCGAL_1_1Vector__graphics__on__surfaces_1_1Dual__geodesic__solver.html">Dual_geodesic_solver</a>&lt; FT &gt; &amp; </td>
          <td class="paramname"><em>solver</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Vector_graphics_on_surfaces/locally_shortest_path.h&gt;</code></p>

<p>computes an approximated geodesic shortest path between two locations on a <code>tmesh</code>. </p>
<p>The points<code>src</code> and <code>tgt</code> must be on the same connected component. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriangleMesh</td><td>a model of <code><a class="elRef" href="../BGL/classFaceListGraph.html">FaceListGraph</a></code> and <code><a class="elRef" href="../BGL/classEdgeListGraph.html">EdgeListGraph</a></code> </td></tr>
    <tr><td class="paramname">FT</td><td>floating point number type (float or double) </td></tr>
    <tr><td class="paramname">EdgeLocationRange</td><td>a model of <code><a class="elRef" href="../Manual/classBackInsertionSequence.html">BackInsertionSequence</a></code> whose value type <code><a class="elRef" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#gaf2b980ebb4851a5b80b9a766da59d0e2">CGAL::Polygon_mesh_processing::Edge_location</a>&lt;FT&gt;</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>source of the path </td></tr>
    <tr><td class="paramname">tgt</td><td>target of the path </td></tr>
    <tr><td class="paramname">tmesh</td><td>input triangle mesh to compute the path on </td></tr>
    <tr><td class="paramname">edge_locations</td><td>contains the path as a sequence of edge locations. Two consecutives edges <code>e_k</code> and <code>e_kp1</code> stored in <code>edge_locations</code> are such that <code>face(halfedge(e_k, tmesh), tmesh) == face(opposite(halfedge(e_kp1, tmesh), tmesh), tmesh))</code>. In parcular, it means that if the path goes through a vertex of <code>tmesh</code>, several edge locations will be reported to maintain this property. Additionally, if <code>src</code> is in the interior of a face <code>f</code>, then the first edge location <code>e_0</code> of <code>edge_locations</code> is such that <code>f == face(opposite(halfedge(e_0, tmesh), tmesh), tmesh))</code>. Similarly, if <code>tgt</code> is in the interior of a face <code>f</code>, then the last edge location <code>e_n</code> of <code>edge_locations</code> is such that <code>f == face(halfedge(e_n, tmesh), tmesh)</code>. </td></tr>
    <tr><td class="paramname">solver</td><td>container for the precomputed information. If not initialized, it will be initialized internally. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd><p class="startdd">add named parameters </p>
<p class="enddd">should we have halfedge location instead? </p>
</dd></dl>

</div>
</div>
<a id="ga36d3f5cce3aa7a2d2f7379093647e918" name="ga36d3f5cce3aa7a2d2f7379093647e918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36d3f5cce3aa7a2d2f7379093647e918">◆ </a></span>recursive_de_Casteljau()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TriangleMesh , class FT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="elRef" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">CGAL::Polygon_mesh_processing::Face_location</a>&lt; TriangleMesh, FT &gt; &gt; CGAL::Vector_graphics_on_surfaces::recursive_de_Casteljau </td>
          <td>(</td>
          <td class="paramtype">const TriangleMesh &amp; </td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__VGSMiscellaneous.html#ga33529a30fe5deb5cc0bb71b06c3cce6f">Bezier_segment</a>&lt; TriangleMesh, FT &gt; &amp; </td>
          <td class="paramname"><em>control_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int </td>
          <td class="paramname"><em>num_subdiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structCGAL_1_1Vector__graphics__on__surfaces_1_1Dual__geodesic__solver.html">Dual_geodesic_solver</a>&lt; FT &gt; &amp; </td>
          <td class="paramname"><em>solver</em> = <code><a class="el" href="structCGAL_1_1Vector__graphics__on__surfaces_1_1Dual__geodesic__solver.html">Dual_geodesic_solver</a>&lt;FT&gt;()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Vector_graphics_on_surfaces/locally_shortest_path.h&gt;</code></p>

<p>computes a discretization of a Bézier segment defined by the location of four control points on <code>tmesh</code>. </p>
<p>All control points must be on the same connected component. This functions applies several iterations of the de Casteljau algorithm, and geodesic shortest paths are drawn between the control points. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriangleMesh</td><td>a model of <code><a class="elRef" href="../BGL/classFaceListGraph.html">FaceListGraph</a></code> and <code><a class="elRef" href="../BGL/classEdgeListGraph.html">EdgeListGraph</a></code> </td></tr>
    <tr><td class="paramname">FT</td><td>floating point number type (float or double) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>input triangle mesh to compute the path on </td></tr>
    <tr><td class="paramname">control_points</td><td>control points of the Bézier segment </td></tr>
    <tr><td class="paramname">num_subdiv</td><td>the number of iterations of the subdivision algorithm </td></tr>
    <tr><td class="paramname">solver</td><td>container for the precomputed information. If not initialized, it will be initialized internally. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>descretization of the Bézier segment as face locations </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd><p class="startdd">add named parameters </p>
<p class="enddd">do we want to also have a way to return Bézier segments? The output is actually Bézier segments subdivided. </p>
</dd></dl>

</div>
</div>
<a id="gad3c42245b9590055f0239e5cad485e0b" name="gad3c42245b9590055f0239e5cad485e0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3c42245b9590055f0239e5cad485e0b">◆ </a></span>refine_mesh_along_paths()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class TriangleMesh , class VNM , class FNM , class <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> CGAL::Vector_graphics_on_surfaces::refine_mesh_along_paths </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="elRef" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">CGAL::Polygon_mesh_processing::Face_location</a>&lt; TriangleMesh, typename K::FT &gt; &gt; &gt; &amp; </td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TriangleMesh &amp; </td>
          <td class="paramname"><em>tmesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VNM </td>
          <td class="paramname"><em>vnm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FNM </td>
          <td class="paramname"><em>fnm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> </td>
          <td class="paramname"><em>out</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Vector_graphics_on_surfaces/locally_shortest_path.h&gt;</code></p>

<p>refines <code>tmesh</code> so that each path in <code>paths</code> corresponds to a set edges of <code>tmesh</code> after the call. </p>
<p>Note that each path must be such that for two consecutive face locations, there exists a face in <code>tmesh</code> containing the two corresponding points. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriangleMesh</td><td>a model of <code><a class="elRef" href="../BGL/classMutableFaceGraph.html">MutableFaceGraph</a></code> </td></tr>
    <tr><td class="paramname">K</td><td>a model of <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> with <code>K::FT</code> being a floating point number type (float or double) </td></tr>
    <tr><td class="paramname">VNM</td><td>a model of <code><a class="elRef" href="../Manual/classReadWritePropertyMap.html">ReadWritePropertyMap</a></code> with <code>boost::graph_traits&lt;TriangleMesh&gt;::vertex_descriptor</code> as key type and <code><a class="elRef" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a></code> as value type. </td></tr>
    <tr><td class="paramname">FNM</td><td>a model of <code><a class="elRef" href="../Manual/classReadWritePropertyMap.html">ReadWritePropertyMap</a></code> with <code>boost::graph_traits&lt;TriangleMesh&gt;::face_descriptor</code> as key type and <code><a class="elRef" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a></code> as value type. </td></tr>
    <tr><td class="paramname"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a></td><td>an output iterator accepting <code>boost::graph_traits&lt;TriangleMesh&gt;::halfedge_descriptor</code> to be put </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tmesh</td><td>the triangle mesh to be refined </td></tr>
    <tr><td class="paramname">paths</td><td>a path described as a range of edge locations, with the property that for two consecutive edge locations, there exists a face in <code>tmesh</code> containing the two corresponding points. </td></tr>
    <tr><td class="paramname">vnm</td><td>property map associating a normal to each vertex of <code>tmesh</code> that is updated by this function </td></tr>
    <tr><td class="paramname">fnm</td><td>property map associating a normal to each face of <code>tmesh</code> that is updated by this function </td></tr>
    <tr><td class="paramname">out</td><td>output iterator where created halfedges are put </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000014">Todo:</a></b></dt><dd><p class="startdd">add named parameters </p>
<p class="interdd">vnm and fnm are optional </p>
<p class="interdd">intersection between path or self-intersections are not handle. Should it be? If not what do we do? </p>
<p class="interdd">out should contain edges, and also existing edges already part of a path </p>
<p class="enddd">shall we also have the edges in the order of the input rather than all at once </p>
</dd></dl>

</div>
</div>
<a id="ga77d40acb67e61b6be0cc9be33248650b" name="ga77d40acb67e61b6be0cc9be33248650b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77d40acb67e61b6be0cc9be33248650b">◆ </a></span>straightest_geodesic()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class TriangleMesh &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="elRef" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">CGAL::Polygon_mesh_processing::Face_location</a>&lt; TriangleMesh, typename K::FT &gt; &gt; CGAL::Vector_graphics_on_surfaces::straightest_geodesic </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">CGAL::Polygon_mesh_processing::Face_location</a>&lt; TriangleMesh, typename K::FT &gt; &amp; </td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename K::Vector_2 &amp; </td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename K::FT </td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TriangleMesh &amp; </td>
          <td class="paramname"><em>tmesh</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Vector_graphics_on_surfaces/locally_shortest_path.h&gt;</code></p>

<p>computes a path on a triangle mesh that is computed by starting a walk on <code>tmesh</code> given a direction and a maximum distance. </p>
<p>The distance will not be achieved if a border edge is reached before. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriangleMesh</td><td>a model of <code><a class="elRef" href="../BGL/classFaceListGraph.html">FaceListGraph</a></code> and <code><a class="elRef" href="../BGL/classEdgeListGraph.html">EdgeListGraph</a></code> </td></tr>
    <tr><td class="paramname">FT</td><td>floating point number type (float or double) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tmesh</td><td>input triangle mesh to compute the path on </td></tr>
    <tr><td class="paramname">src</td><td>the source of the path </td></tr>
    <tr><td class="paramname">len</td><td>the distance to walk along the straightest </td></tr>
    <tr><td class="paramname">dir</td><td>the initial direction of the walk, given as a 2D vector in the face of src, the halfedge of the face being the y-axis. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the straightest path (not containing <code>src</code>) </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd><p class="startdd">add named parameters </p>
<p class="interdd">do we want to also have a way to return Bézier segments? The output is actually Bézier segments subdivided. </p>
<p class="enddd">offer something better than a 2D vector for the direction </p>
</dd></dl>

</div>
</div>
<a id="gabd0c70a9ee4c6247b20e1b139977706c" name="gabd0c70a9ee4c6247b20e1b139977706c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd0c70a9ee4c6247b20e1b139977706c">◆ </a></span>trace_bezier_curves()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class TriangleMesh &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; <a class="elRef" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">CGAL::Polygon_mesh_processing::Face_location</a>&lt; TriangleMesh, typename K::FT &gt; &gt; &gt; CGAL::Vector_graphics_on_surfaces::trace_bezier_curves </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">CGAL::Polygon_mesh_processing::Face_location</a>&lt; TriangleMesh, typename K::FT &gt; &amp; </td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::array&lt; typename K::Vector_2, 4 &gt; &gt; &amp; </td>
          <td class="paramname"><em>directions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::array&lt; typename K::FT, 4 &gt; &gt; &amp; </td>
          <td class="paramname"><em>lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int </td>
          <td class="paramname"><em>num_subdiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TriangleMesh &amp; </td>
          <td class="paramname"><em>tmesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structCGAL_1_1Vector__graphics__on__surfaces_1_1Dual__geodesic__solver.html">Dual_geodesic_solver</a>&lt; typename K::FT &gt; &amp; </td>
          <td class="paramname"><em>solver</em> = <code>{}</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Vector_graphics_on_surfaces/locally_shortest_path.h&gt;</code></p>

<p>computes a path representing a Bézier curve defined by four control points. </p>
<p>Control points are defined by the endpoints of straightest geodesic curves starting from <code>center</code> along given directions and distances. The iterative de Casteljau subdivision algorithm is applied to create more control points that are then connected with locally shortest paths. The output path is such that for two consecutive face locations, there must exist a face in <code>tmesh</code> containing the two corresponding points. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriangleMesh</td><td>a model of <code><a class="elRef" href="../BGL/classFaceListGraph.html">FaceListGraph</a></code> and <code><a class="elRef" href="../BGL/classEdgeListGraph.html">EdgeListGraph</a></code> </td></tr>
    <tr><td class="paramname">K</td><td>a model of <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> with <code>K::FT</code> being a floating point number type (float or double) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>the location on <code>tmesh</code> where straightest geodesic for the placement of control points starts. The y-axis used is <code>halfedge(center.first, tmesh)</code>. </td></tr>
    <tr><td class="paramname">directions</td><td>contains the direction of the straightest geodesic for each control point </td></tr>
    <tr><td class="paramname">lengths</td><td>contains the length of the straightest geodesic for each control point </td></tr>
    <tr><td class="paramname">num_subdiv</td><td>the number of iterations of the de Casteljau subdivision algorithm </td></tr>
    <tr><td class="paramname">tmesh</td><td>input triangle mesh supporting the vertices of the output polygon </td></tr>
    <tr><td class="paramname">solver</td><td>container for the precomputed information. If not initialized, it will be initialized internally. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a face location for each vertex of each polygon </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000012">Todo:</a></b></dt><dd><p class="startdd">add named parameters </p>
<p class="interdd">polygon orientation is not handled in the function and should be done outside of the function for now </p>
<p class="interdd">for better rendering we can group polygons to have one center for the same group of polygon (useful for letters that are not simply connected) </p>
<p class="enddd">what if boundary is reached </p>
</dd></dl>

</div>
</div>
<a id="ga7fb4a93991531410f9bcda6e9935444e" name="ga7fb4a93991531410f9bcda6e9935444e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fb4a93991531410f9bcda6e9935444e">◆ </a></span>trace_geodesic_label()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class TriangleMesh &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; <a class="elRef" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">CGAL::Polygon_mesh_processing::Face_location</a>&lt; TriangleMesh, typename K::FT &gt; &gt; &gt; CGAL::Vector_graphics_on_surfaces::trace_geodesic_label </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">CGAL::Polygon_mesh_processing::Face_location</a>&lt; TriangleMesh, typename K::FT &gt; &amp; </td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; typename K::Point_2 &gt; &gt; &amp; </td>
          <td class="paramname"><em>polygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename K::FT </td>
          <td class="paramname"><em>scaling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TriangleMesh &amp; </td>
          <td class="paramname"><em>tmesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structCGAL_1_1Vector__graphics__on__surfaces_1_1Dual__geodesic__solver.html">Dual_geodesic_solver</a>&lt; typename K::FT &gt; &amp; </td>
          <td class="paramname"><em>solver</em> = <code>{}</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Vector_graphics_on_surfaces/locally_shortest_path.h&gt;</code></p>

<p>computes for each vertex of each polygon in <code>polygons</code> a face location on <code>tmesh</code>, where <code>center</code> represents the center of the 2D bounding box of the polygons. </p>
<p>This method starts by considering the segment splitting in two halves along the y-axis the bounding box of the polygons. 2D centers for each polygon are computed on this segment as the intersection with the line splitting the bounding box of the polygon in two halves along the x-axis. The splitting segment is then drawn on <code>tmesh</code> and the face location of the 2D centers is found. <code><a class="el" href="group__VGSFunctions.html#ga751dea8a73cbf18d11ed477ad91cb77d" title="computes the face location of each vertex of a 2D polygon on tmesh.">trace_geodesic_polygon()</a></code> is then called for each polygon and center, with appropriate directions and distances to have a consistent orientation for the polygons. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriangleMesh</td><td>a model of <code><a class="elRef" href="../BGL/classFaceListGraph.html">FaceListGraph</a></code> and <code><a class="elRef" href="../BGL/classEdgeListGraph.html">EdgeListGraph</a></code> </td></tr>
    <tr><td class="paramname">K</td><td>a model of <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> with <code>K::FT</code> being a floating point number type (float or double) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>the location on <code>tmesh</code> corresponding to the center of the 2D bounding box of the polygons. </td></tr>
    <tr><td class="paramname">polygons</td><td>2D polygons </td></tr>
    <tr><td class="paramname">scaling</td><td>a scaling factor to scale the polygons on <code>tmesh</code> (considering geodesic distances on <code>tmesh</code>) </td></tr>
    <tr><td class="paramname">tmesh</td><td>input triangle mesh supporting the vertices of the output polygon </td></tr>
    <tr><td class="paramname">solver</td><td>container for the precomputed information. If not initialized, it will be initialized internally. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a face location for each vertex of each polygon </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd><p class="startdd">add named parameters </p>
<p class="interdd">polygon orientation is not handled in the function and should be done outside of the function for now </p>
<p class="interdd">for better rendering we can group polygons to have one center for the same group of polygon (useful for letters that are not simply connected) </p>
<p class="enddd">what if boundary is reached </p>
</dd></dl>

</div>
</div>
<a id="gadb83a7cae7993f2c6609ba3ad0eee944" name="gadb83a7cae7993f2c6609ba3ad0eee944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb83a7cae7993f2c6609ba3ad0eee944">◆ </a></span>trace_geodesic_label_along_curve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class TriangleMesh &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; <a class="elRef" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">CGAL::Polygon_mesh_processing::Face_location</a>&lt; TriangleMesh, typename K::FT &gt; &gt; &gt; CGAL::Vector_graphics_on_surfaces::trace_geodesic_label_along_curve </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="elRef" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">CGAL::Polygon_mesh_processing::Face_location</a>&lt; TriangleMesh, typename K::FT &gt; &gt; &amp; </td>
          <td class="paramname"><em>supporting_curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; typename K::Point_2 &gt; &gt; &amp; </td>
          <td class="paramname"><em>polygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename K::FT </td>
          <td class="paramname"><em>scaling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename K::FT </td>
          <td class="paramname"><em>padding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool </td>
          <td class="paramname"><em>is_centered</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TriangleMesh &amp; </td>
          <td class="paramname"><em>tmesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structCGAL_1_1Vector__graphics__on__surfaces_1_1Dual__geodesic__solver.html">Dual_geodesic_solver</a>&lt; typename K::FT &gt; &amp; </td>
          <td class="paramname"><em>solver</em> = <code>{}</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Vector_graphics_on_surfaces/locally_shortest_path.h&gt;</code></p>

<p>computes for each vertex of each polygon in <code>polygons</code> a face location on <code>tmesh</code> along the curve <code>supporting_curve</code>. </p>
<p>This method starts by considering the segment splitting in two halves along the y-axis the bounding box of the polygons. 2D centers for each polygon are computed on this segment as the intersection with the line splitting the bounding box of the polygon in two halves along the x-axis. The splitting segment is then mapped onto <code>supporting_curve</code> by first scaling it using <code>scaling</code>, and using <code>padding</code> and <code>is_centered</code>. Face locations of the 2D center are found on <code>supporting_curve</code>. <code><a class="el" href="group__VGSFunctions.html#ga751dea8a73cbf18d11ed477ad91cb77d" title="computes the face location of each vertex of a 2D polygon on tmesh.">trace_geodesic_polygon()</a></code> is then called for each polygon and center, with appropriate directions and distances to have a consistent orientation for the polygons. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriangleMesh</td><td>a model of <code><a class="elRef" href="../BGL/classFaceListGraph.html">FaceListGraph</a></code> and <code><a class="elRef" href="../BGL/classEdgeListGraph.html">EdgeListGraph</a></code> </td></tr>
    <tr><td class="paramname">K</td><td>a model of <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> with <code>K::FT</code> being a floating point number type (float or double) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">supporting_curve</td><td>a path on <code>tmesh</code> that will support the center of the bounding box of each polygon. For two consecutive face locations, there must exist a face in <code>tmesh</code> containing the two corresponding points. </td></tr>
    <tr><td class="paramname">polygons</td><td>2D polygons </td></tr>
    <tr><td class="paramname">scaling</td><td>a scaling factor to scale the polygons on <code>tmesh</code> (considering geodesic distances on <code>tmesh</code>) </td></tr>
    <tr><td class="paramname">padding</td><td>padding applied at the beggining of supporting curve to start the drawing </td></tr>
    <tr><td class="paramname">is_centered</td><td>is <code>true</code>, <code>padding</code> is ignored and the bounding box of the polygon is centered on the supporting curve (in 1D) </td></tr>
    <tr><td class="paramname">tmesh</td><td>input triangle mesh supporting the vertices of the output polygon </td></tr>
    <tr><td class="paramname">solver</td><td>container for the precomputed information. If not initialized, it will be initialized internally. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a face location for each vertex of each polygon </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000011">Todo:</a></b></dt><dd><p class="startdd">add named parameters </p>
<p class="interdd">polygon orientation is not handled in the function and should be done outside of the function for now </p>
<p class="interdd">for better rendering we can group polygons to have one center for the same group of polygon (useful for letters that are not simply connected) </p>
<p class="interdd">check padding is ignored if is_centered is used + update the doc if not </p>
<p class="enddd">doc what happens if supporting curve is not long enough + boundary reached </p>
</dd></dl>

</div>
</div>
<a id="ga751dea8a73cbf18d11ed477ad91cb77d" name="ga751dea8a73cbf18d11ed477ad91cb77d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga751dea8a73cbf18d11ed477ad91cb77d">◆ </a></span>trace_geodesic_polygon()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class TriangleMesh &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="elRef" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">CGAL::Polygon_mesh_processing::Face_location</a>&lt; TriangleMesh, typename K::FT &gt; &gt; CGAL::Vector_graphics_on_surfaces::trace_geodesic_polygon </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">CGAL::Polygon_mesh_processing::Face_location</a>&lt; TriangleMesh, typename K::FT &gt; &amp; </td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; typename K::Vector_2 &gt; &amp; </td>
          <td class="paramname"><em>directions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; typename K::FT &gt; &amp; </td>
          <td class="paramname"><em>lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TriangleMesh &amp; </td>
          <td class="paramname"><em>tmesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structCGAL_1_1Vector__graphics__on__surfaces_1_1Dual__geodesic__solver.html">Dual_geodesic_solver</a>&lt; typename K::FT &gt; &amp; </td>
          <td class="paramname"><em>solver</em> = <code>{}</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Vector_graphics_on_surfaces/locally_shortest_path.h&gt;</code></p>

<p>computes the face location of each vertex of a 2D polygon on <code>tmesh</code>. </p>
<p>The vertices of the polygon are given as a pair of direction and distance with respect to a point corresponding to <code>center</code> on <code>tmesh</code>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriangleMesh</td><td>a model of <code><a class="elRef" href="../BGL/classFaceListGraph.html">FaceListGraph</a></code> and <code><a class="elRef" href="../BGL/classEdgeListGraph.html">EdgeListGraph</a></code> </td></tr>
    <tr><td class="paramname">K</td><td>a model of <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> with <code>K::FT</code> being a floating point number type (float or double) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>the location on <code>tmesh</code> used as reference. The y-axis used for coordinates is <code>halfedge(center.first, tmesh)</code>. </td></tr>
    <tr><td class="paramname">directions</td><td>contains the direction one need to move from <code>center</code> to reach each vertex of the polygon. </td></tr>
    <tr><td class="paramname">lengths</td><td>the distance one need to move from <code>center</code> along the direction at the same position in <code>directions</code> to reach each vertex of the polygon. </td></tr>
    <tr><td class="paramname">tmesh</td><td>input triangle mesh supporting the vertices of the output polygon </td></tr>
    <tr><td class="paramname">solver</td><td>container for the precomputed information. If not initialized, it will be initialized internally. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a face location for each vertex of the polygon </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd><p class="startdd">add named parameters </p>
<p class="interdd">polygon orientation is not handled in the function and should be done outside of the function for now </p>
<p class="interdd">offer something better than a 2D vector for the direction </p>
<p class="interdd">directly handle polyline? </p>
<p class="enddd">why the first polygon vertex is duplicated by the function? (most probably for the example but it shouldn't be done here) </p>
</dd></dl>

</div>
</div>
<a id="ga5966853b004c327fff062ed41621a0fa" name="ga5966853b004c327fff062ed41621a0fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5966853b004c327fff062ed41621a0fa">◆ </a></span>trace_geodesic_polygons()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class TriangleMesh &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; <a class="elRef" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">CGAL::Polygon_mesh_processing::Face_location</a>&lt; TriangleMesh, typename K::FT &gt; &gt; &gt; CGAL::Vector_graphics_on_surfaces::trace_geodesic_polygons </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">CGAL::Polygon_mesh_processing::Face_location</a>&lt; TriangleMesh, typename K::FT &gt; &amp; </td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; typename K::Point_2 &gt; &gt; &amp; </td>
          <td class="paramname"><em>polygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename K::FT </td>
          <td class="paramname"><em>scaling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TriangleMesh &amp; </td>
          <td class="paramname"><em>tmesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structCGAL_1_1Vector__graphics__on__surfaces_1_1Dual__geodesic__solver.html">Dual_geodesic_solver</a>&lt; typename K::FT &gt; &amp; </td>
          <td class="paramname"><em>solver</em> = <code>{}</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Vector_graphics_on_surfaces/locally_shortest_path.h&gt;</code></p>

<p>computes for each vertex of each polygon in <code>polygons</code> a face location on <code>tmesh</code>, where <code>center</code> represents the center of the 2D bounding box of the polygons. </p>
<p>This method computes the location of the center of the bounding box of each polygon on the mesh with respect to <code>center</code> and calls <code><a class="el" href="group__VGSFunctions.html#ga751dea8a73cbf18d11ed477ad91cb77d" title="computes the face location of each vertex of a 2D polygon on tmesh.">trace_geodesic_polygon()</a></code> with that center with appropriate directions and distances to have a consistent orientation for the polygons. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriangleMesh</td><td>a model of <code><a class="elRef" href="../BGL/classFaceListGraph.html">FaceListGraph</a></code> and <code><a class="elRef" href="../BGL/classEdgeListGraph.html">EdgeListGraph</a></code> </td></tr>
    <tr><td class="paramname">K</td><td>a model of <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> with <code>K::FT</code> being a floating point number type (float or double) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>the location on <code>tmesh</code> corresponding to the center of the 2D bounding box of the polygons. </td></tr>
    <tr><td class="paramname">polygons</td><td>2D polygons </td></tr>
    <tr><td class="paramname">scaling</td><td>a scaling factor to scale the polygons on <code>tmesh</code> (considering geodesic distances on <code>tmesh</code>) </td></tr>
    <tr><td class="paramname">tmesh</td><td>input triangle mesh supporting the vertices of the output polygon </td></tr>
    <tr><td class="paramname">solver</td><td>container for the precomputed information. If not initialized, it will be initialized internally. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a face location for each vertex of each polygon </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd><p class="startdd">add named parameters </p>
<p class="interdd">polygon orientation is not handled in the function and should be done outside of the function for now </p>
<p class="interdd">for better rendering we can group polygons to have one center for the same group of polygon (useful for letters that are not simply connected) </p>
<p class="enddd">what if boundary is reached </p>
</dd></dl>

</div>
</div>
<a id="ga3930b8c9d284ac52cf0969d2da2a6138" name="ga3930b8c9d284ac52cf0969d2da2a6138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3930b8c9d284ac52cf0969d2da2a6138">◆ </a></span>trace_polyline_of_bezier_curves()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class TriangleMesh &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="elRef" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">CGAL::Polygon_mesh_processing::Face_location</a>&lt; TriangleMesh, typename K::FT &gt; &gt; CGAL::Vector_graphics_on_surfaces::trace_polyline_of_bezier_curves </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#ga35604eae6b378b8254a3f41f1a274b9e">CGAL::Polygon_mesh_processing::Face_location</a>&lt; TriangleMesh, typename K::FT &gt; &amp; </td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; typename K::Vector_2 &gt; &amp; </td>
          <td class="paramname"><em>directions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; typename K::FT &gt; &amp; </td>
          <td class="paramname"><em>lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>is_closed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int </td>
          <td class="paramname"><em>num_subdiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TriangleMesh &amp; </td>
          <td class="paramname"><em>tmesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structCGAL_1_1Vector__graphics__on__surfaces_1_1Dual__geodesic__solver.html">Dual_geodesic_solver</a>&lt; typename K::FT &gt; &amp; </td>
          <td class="paramname"><em>solver</em> = <code>{}</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;CGAL/Vector_graphics_on_surfaces/locally_shortest_path.h&gt;</code></p>

<p>computes a path representing a Bézier polyline (a sequence of Bézier curves having an identical control points, that is the fourth control point of the nth curve is the first control point of the (n+1)th curve). </p>
<p>Control points are defined by the endpoints of straightest geodesic curves starting from <code>center</code> along given directions and distances. The iterative de Casteljau subdivision algorithm is applied to create more control points that are then connected with locally shortest paths. The output path is such that for two consecutive face locations, there must exist a face in <code>tmesh</code> containing the two corresponding points. The first portion of the curve is defined by the 4 first values in <code>directions</code> and <code>lengths</code>. The second portion is defined by the 4'th value and the next 3, and so on until the end is reached. If <code>is_closed</code> is true, then the first value will be used with the last three to define the last portion. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriangleMesh</td><td>a model of <code><a class="elRef" href="../BGL/classFaceListGraph.html">FaceListGraph</a></code> and <code><a class="elRef" href="../BGL/classEdgeListGraph.html">EdgeListGraph</a></code> </td></tr>
    <tr><td class="paramname">K</td><td>a model of <code><a class="elRef" href="../Kernel_23/classKernel.html">Kernel</a></code> with <code>K::FT</code> being a floating point number type (float or double) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>the location on <code>tmesh</code> where straightest geodesic for the placement of control points starts. The y-axis used is <code>halfedge(center.first, tmesh)</code>. </td></tr>
    <tr><td class="paramname">directions</td><td>contains the direction of the straightest geodesic for each control point </td></tr>
    <tr><td class="paramname">lengths</td><td>contains the length of the straightest geodesic for each control point </td></tr>
    <tr><td class="paramname">num_subdiv</td><td>the number of iterations of the de Casteljau subdivision algorithm </td></tr>
    <tr><td class="paramname">is_closed</td><td>if true [directions/lengths].front() will be used as additional last point, generating a closed path </td></tr>
    <tr><td class="paramname">tmesh</td><td>input triangle mesh supporting the vertices of the output polygon </td></tr>
    <tr><td class="paramname">solver</td><td>container for the precomputed information. If not initialized, it will be initialized internally. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a face location for each vertex of each polygon </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000013">Todo:</a></b></dt><dd><p class="startdd">add named parameters </p>
<p class="interdd">polygon orientation is not handled in the function and should be done outside of the function for now </p>
<p class="interdd">for better rendering we can group polygons to have one center for the same group of polygon (useful for letters that are not simply connected) </p>
<p class="enddd">what if boundary is reached </p>
</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"></a> 1.9.6 </li>
  </ul>
</div>
</div>
</body>

</html>
