<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="https://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Shape_detection/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 5.6 - Shape Detection: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//&amp;lt;![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      }
  }
}
);
//]]&amp;gt;
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.6 - Shape Detection
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Shape_Detection"></a> </p><div id="autotoc" class="toc"></div> 
<dl class="section author"><dt>Authors</dt><dd>Sven Oesau, Yannick Verdie, Cl√©ment Jamin, Pierre Alliez, Florent Lafarge, Simon Giraudot, Thien Hoang, and Dmitry Anisimov</dd></dl>
<h1><a class="anchor" id="Shape_detection_Introduction"></a>
Introduction</h1>
<p>This CGAL component implements two algorithms for shape detection:</p>
<ul>
<li>the <em>Efficient RANSAC (RANdom SAmple Consensus)</em> method, contributed by Schnabel et al. <a class="el" href="citelist.html#CITEREF_schnabel2007efficient">[2]</a>;</li>
<li>the <em>Region Growing</em> method, contributed by Lafarge and Mallet <a class="el" href="citelist.html#CITEREF_cgal:lm-clscm-12">[1]</a>.</li>
</ul>
<h1><a class="anchor" id="Shape_detection_RANSAC"></a>
Efficient RANSAC</h1>
<p>From an unstructured point set with unoriented normals, this algorithm detects a set of shapes (see Figure <a class="el" href="index.html#fig__Efficient_RANSAC_overview">Figure 82.1</a>). Five types of primitive shapes are provided by this package: plane, sphere, cylinder, cone, and torus. Other primitive shapes can be easily added by the user (see Section <a class="el" href="index.html#Shape_detection_RANSACExample_with_custom_shapes">Custom Shapes</a>).</p>
<p><a class="anchor" id="fig__Efficient_RANSAC_overview"></a></p><div class="image">
<img src="overview2.png" alt="overview2.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Efficient_RANSAC_overview">Figure 82.1</a> Input and output of the Efficient RANSAC method. (a) Input point set. (b) Point set depicted with one color per detected shape.  </div> <br /> 
<p>This method takes as input a point set with unoriented normals and provides as output a set of detected shapes with associated input points. The output of the algorithm is a set of detected shapes with assigned points and all remaining points not covered by these shapes. Each input point can be assigned to at most one detected shape.</p>
<p>The shapes are detected via a RANSAC-type approach, that is a random sample consensus. The basic RANSAC approach repeats the following steps:</p>
<ol type="1">
<li>Randomly select samples from the input points;</li>
<li>Fit a shape to the selected samples;</li>
<li>Count the number of inliers to the shape, inliers being within a user-specified error tolerance to the shape.</li>
</ol>
<p>Steps 1-3 are repeated for a prescribed number of iterations and the shape with the highest number of inliers, referred to as the largest shape, is kept.</p>
<p>In our context, the error between a point and a shape is defined by its distance and normal deviation to the shape. A random subset corresponds to the minimum number of points (with normals) required to uniquely define a primitive.</p>
<p>For very large point sets, the basic RANSAC method is not practical when testing all possible shape candidates against the input data in order to find the largest shape. The main idea behind the Efficient RANSAC method is testing shape candidates against subsets of the input data. Shape candidates are constructed until the probability to miss the largest candidate is lower than a user-specified threshold. The largest shape is repeatedly extracted until no more shapes, restricted to cover a minimum number of points, can be extracted. An additional gain in efficiency is achieved through exploiting the normal attributes during initial shape construction and enumeration of inliers.</p>
<p>The <em>support</em> of a shape refers to the footprint of the points covered by the primitive. To avoid generating shapes with the fragmented support, we enforce a connectivity constraint by considering only one connected component, referred to as <em>cluster</em>, selected as the one covering the largest number of inliers (see Section <a class="el" href="index.html#Shape_detection_RANSACParameters">Parameters</a> for more details).</p>
<h2><a class="anchor" id="Shape_detection_RANSACParameters"></a>
Parameters</h2>
<p>The algorithm has five parameters:</p>
<ul>
<li><code>epsilon</code> and <code>normal_threshold</code>: The error between a point-with-normal \(p\) and a shape \(S\) is defined by its Euclidean distance and normal deviation to \(S\). The normal deviation is computed between the normal at \(p\) and the normal of \(S\) at the closest projection of \(p\) onto \(S\). The parameter <code>epsilon</code> defines the absolute maximum tolerance Euclidean distance between a point and a shape. A high value of <code>epsilon</code> leads to the detection of fewer large shapes and hence a less detailed detection. A low value of <code>epsilon</code> yields a more detailed detection, but may lead to either lower coverage or over-segmentation. Over-segmentation translates into detection of fragmented shapes when <code>epsilon</code> is within or below the noise level. When the input point set is made of free-form parts, a higher tolerance <code>epsilon</code> enables to detect more primitive shapes that approximate some of the free-form surfaces. The impact of this parameter is depicted by Figure <a class="el" href="index.html#fig__Efficient_RANSAC_parameter_epsilon_variation">Figure 82.2</a>. Its impact on performance is evaluated in Section <a class="el" href="index.html#Shape_detection_RANSACPerformance">Performance</a>.</li>
</ul>
<p><a class="anchor" id="fig__Efficient_RANSAC_parameter_epsilon_variation"></a></p><div class="image">
<img src="epsilon_variation2.png" alt="epsilon_variation2.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Efficient_RANSAC_parameter_epsilon_variation">Figure 82.2</a> Impact of the epsilon parameter over the levels of detail of the detection. (a) Input point set. (b) Detection of planar shapes with <code>epsilon</code> set to 2.0 (one color per detected shape). Most details such as chimneys on the roof are not distinguished. (c) Detection with <code>epsilon</code> set to 0.5. The facades are correctly detected and some details of the roof are detected. (d) Setting <code>epsilon</code> to 0.25 yields a more detailed but slightly over-segmented detection.  </div> <br /> 
<ul>
<li><code>cluster_epsilon</code>: The Efficient RANSAC uses this parameter to cluster the points into connected components covered by a detected shape. For developable shapes that admit a trivial planar parameterization (plane, cylinder, cone), the points covered by a shape are mapped to a 2D parameter space chosen to minimize distortion and best preserve arc-length distances. This 2D parameter space is discretized using a regular grid, and a connected component search is performed to identify the largest cluster. The parameter <code>cluster_epsilon</code> defines the spacing between two cells of the regular grid, so that two points separated by a distance of at most \(2\sqrt{2}\) <code>cluster_epsilon</code> are considered adjacent. For non-developable shapes, the connected components are identified by computing a neighboring graph in 3D and walking in the graph. The impact of the parameter <code>cluster_epsilon</code> is depicted in Figure <a class="el" href="index.html#fig__Efficient_RANSAC_parameter_connectivity">Figure 82.3</a>.</li>
</ul>
<p><a class="anchor" id="fig__Efficient_RANSAC_parameter_connectivity"></a></p><div class="image">
<img src="varying_connectivity.png" alt="varying_connectivity.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Efficient_RANSAC_parameter_connectivity">Figure 82.3</a> The parameter <code>cluster_epsilon</code> controls the connectivity of the points covered by a detected shape. The input point set is sampled on four coplanar squares. (a) A large value of <code>cluster_epsilon</code> leads to detecting a single planar shape. (b) A moderate value of <code>cluster_epsilon</code> yields the detection of four squares. Notice that a few points within the squares are not detected as not connected. (c) A small value of <code>cluster_epsilon</code> leads to over-segmentation.  </div> <br /> 
<ul>
<li><code>min_points</code>: The minimum number of points controls the termination of the algorithm. The shape search is iterated until no further shapes can be found with a higher support. Note that this parameter is not strict: depending on the chosen probability, shapes may be extracted with a number of points lower than the specified parameter.</li>
<li><code>probability</code>: This parameter defines the probability to miss the largest candidate shape. A lower probability provides a higher reliability and determinism at the cost of longer running time due to a higher search endurance.</li>
</ul>
<h2><a class="anchor" id="Shape_detection_RANSACExamples"></a>
Examples</h2>
<p>The main class <code><a class="el" href="classCGAL_1_1Shape__detection_1_1Efficient__RANSAC.html" title="Shape detection algorithm based on the RANSAC method. ">Shape_detection::Efficient_RANSAC</a></code> takes a template parameter <code><a class="el" href="structCGAL_1_1Shape__detection_1_1Efficient__RANSAC__traits.html" title="Default traits class for the CGAL::Shape_detection::Efficient_RANSAC. ">Shape_detection::Efficient_RANSAC_traits</a></code> that defines the geometric types and input format. Property maps provide a means to interface with the user-specific data structures. The first parameter of the <code><a class="el" href="structCGAL_1_1Shape__detection_1_1Efficient__RANSAC__traits.html" title="Default traits class for the CGAL::Shape_detection::Efficient_RANSAC. ">Shape_detection::Efficient_RANSAC_traits</a></code> class is the common <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a></code>. In order to match the constraints of property maps, an iterator type and two maps that map an iterator to a point and a normal are specified in the <code><a class="el" href="structCGAL_1_1Shape__detection_1_1Efficient__RANSAC__traits.html" title="Default traits class for the CGAL::Shape_detection::Efficient_RANSAC. ">Shape_detection::Efficient_RANSAC_traits</a></code> class. The concept behind property maps is detailed in Manual <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/index.html#chapterProperty_map">CGAL and Property Maps</a>.</p>
<p>Typical usage consists of five steps:</p>
<ol type="1">
<li>Provide input data via a range iterator;</li>
<li>Register shape factories;</li>
<li>Choose parameters;</li>
<li>Detect;</li>
<li>Retrieve detected shapes.</li>
</ol>
<h3><a class="anchor" id="Shape_detection_RANSACExample_basic"></a>
Basic Plane Detection</h3>
<p>The following example reads a point set from a file and detects only planar shapes. The default parameters are used for detection.</p>
<p><br />
<b>File</b> <a class="el" href="Shape_detection_2efficient_RANSAC_basic_8cpp-example.html">Shape_detection/efficient_RANSAC_basic.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#if defined (_MSC_VER) &amp;&amp; !defined (_WIN64)</span></div><div class="line"><span class="preprocessor">#pragma warning(disable:4244) // boost::number_distance::distance()</span></div><div class="line">                              <span class="comment">// converts 64 to 32 bits integers</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_with_normal_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Shape_detection/Efficient_RANSAC.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Type declarations.</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Kernel::Point_3, Kernel::Vector_3&gt;         Point_with_normal;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point_with_normal&gt;                       Pwn_vector;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Point_with_normal&gt;</a>  Point_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;Point_with_normal&gt;</a> Normal_map;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="structCGAL_1_1Shape__detection_1_1Efficient__RANSAC__traits.html">CGAL::Shape_detection::Efficient_RANSAC_traits</a></div><div class="line">&lt;<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>, Pwn_vector, Point_map, Normal_map&gt;             Traits;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Shape__detection_1_1Efficient__RANSAC.html">CGAL::Shape_detection::Efficient_RANSAC&lt;Traits&gt;</a> Efficient_ransac;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Shape__detection_1_1Plane.html">CGAL::Shape_detection::Plane&lt;Traits&gt;</a>            Plane;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Efficient RANSAC"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : CGAL::data_file_path(<span class="stringliteral">"points_3/cube.pwn"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Points with normals.</span></div><div class="line">  Pwn_vector points;</div><div class="line"></div><div class="line">  <span class="comment">// Load point set from a file.</span></div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(</div><div class="line">        filename,</div><div class="line">        std::back_inserter(points),</div><div class="line">        CGAL::parameters::point_map(Point_map()).</div><div class="line">        normal_map(Normal_map()))) {</div><div class="line"></div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file cube.pwn!"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Instantiate shape detection engine.</span></div><div class="line">  Efficient_ransac ransac;</div><div class="line"></div><div class="line">  <span class="comment">// Provide input data.</span></div><div class="line">  ransac.set_input(points);</div><div class="line"></div><div class="line">  <span class="comment">// Register planar shapes via template method.</span></div><div class="line">  ransac.add_shape_factory&lt;Plane&gt;();</div><div class="line"></div><div class="line">  <span class="comment">// Detect registered shapes with default parameters.</span></div><div class="line">  ransac.detect();</div><div class="line"></div><div class="line">  <span class="comment">// Print number of detected shapes.</span></div><div class="line">  std::cout &lt;&lt; ransac.shapes().end() - ransac.shapes().begin()</div><div class="line">  &lt;&lt; <span class="stringliteral">" shapes detected."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="Shape_detection_RANSACExample_with_callback"></a>
Plane Detection With Callback</h3>
<p>The Efficient RANSAC class provides a callback mechanism that enables the user to track the progress of the algorithm. It can be used, for example, to terminate the algorithm based on a timeout. In the following example, the algorithm stops if it takes more than half a second and prints out the progress made.</p>
<p><br />
<b>File</b> <a class="el" href="Shape_detection_2efficient_RANSAC_with_callback_8cpp-example.html">Shape_detection/efficient_RANSAC_with_callback.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#if defined (_MSC_VER) &amp;&amp; !defined (_WIN64)</span></div><div class="line"><span class="preprocessor">#pragma warning(disable:4244) // boost::number_distance::distance()</span></div><div class="line">                              <span class="comment">// converts 64 to 32 bits integers</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Timer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_with_normal_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Shape_detection/Efficient_RANSAC.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Type declarations.</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Kernel::Point_3, Kernel::Vector_3&gt;         Point_with_normal;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point_with_normal&gt;                       Pwn_vector;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Point_with_normal&gt;</a>  Point_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;Point_with_normal&gt;</a> Normal_map;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="structCGAL_1_1Shape__detection_1_1Efficient__RANSAC__traits.html">CGAL::Shape_detection::Efficient_RANSAC_traits</a></div><div class="line">&lt;Kernel, Pwn_vector, Point_map, Normal_map&gt;             Traits;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Shape__detection_1_1Efficient__RANSAC.html">CGAL::Shape_detection::Efficient_RANSAC&lt;Traits&gt;</a> Efficient_ransac;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Shape__detection_1_1Plane.html">CGAL::Shape_detection::Plane&lt;Traits&gt;</a>            Plane;</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Timeout_callback {</div><div class="line"></div><div class="line">  <span class="keyword">mutable</span> <span class="keywordtype">int</span> nb;</div><div class="line">  <span class="keyword">mutable</span> CGAL::Timer timer;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> limit;</div><div class="line"></div><div class="line">  Timeout_callback(<span class="keywordtype">double</span> limit) :</div><div class="line">  nb(0), limit(limit) {</div><div class="line">    timer.start();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> operator()(<span class="keywordtype">double</span> advancement)<span class="keyword"> const </span>{</div><div class="line"></div><div class="line">    <span class="comment">// Avoid calling time() at every single iteration, which could</span></div><div class="line">    <span class="comment">// impact performances very badly.</span></div><div class="line">    ++nb;</div><div class="line">    <span class="keywordflow">if</span> (nb % 1000 != 0)</div><div class="line">      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="comment">// If the limit is reached, interrupt the algorithm.</span></div><div class="line">    <span class="keywordflow">if</span> (timer.time() &gt; limit) {</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">"Algorithm takes too long, exiting ("</span></div><div class="line">                &lt;&lt; 100.0 * advancement &lt;&lt; <span class="stringliteral">"% done)"</span> &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Efficient RANSAC"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : CGAL::data_file_path(<span class="stringliteral">"points_3/cube.pwn"</span>);</div><div class="line"></div><div class="line">  Pwn_vector points;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(</div><div class="line">        filename,</div><div class="line">        std::back_inserter(points),</div><div class="line">        CGAL::parameters::point_map(Point_map()).</div><div class="line">        normal_map(Normal_map()))) {</div><div class="line"></div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file cube.pwn!"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  Efficient_ransac ransac;</div><div class="line">  ransac.set_input(points);</div><div class="line">  ransac.add_shape_factory&lt;Plane&gt;();</div><div class="line"></div><div class="line">  <span class="comment">// Create callback that interrupts the algorithm</span></div><div class="line">  <span class="comment">// if it takes more than half a second.</span></div><div class="line">  Timeout_callback timeout_callback(0.5);</div><div class="line"></div><div class="line">  <span class="comment">// Detect registered shapes with the default parameters.</span></div><div class="line">  ransac.detect(Efficient_ransac::Parameters(), timeout_callback);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="Shape_detection_RANSACExample_with_parameters"></a>
Setting Parameters And Using Different Shape Types</h3>
<p>This example illustrates the user selection of parameters using the <code><a class="el" href="structCGAL_1_1Shape__detection_1_1Efficient__RANSAC_1_1Parameters.html" title="Parameters for the shape detection algorithm. ">Shape_detection::Efficient_RANSAC::Parameters</a></code> class. Shape detection is performed on five shape types (plane, cylinder, sphere, cone, and torus). The input point set is sampled on a surface mostly composed of piecewise planar and cylindrical parts, in addition to free-form parts.</p>
<p>Basic information of the detected shapes is written to the standard output: if the shape is either a plane or a cylinder, specific parameters are recovered, otherwise the general method <code>info()</code> is used to get the shape parameters in a string object. Note that specific parameters can be recovered for any of the provided shapes.</p>
<p><br />
<b>File</b> <a class="el" href="Shape_detection_2efficient_RANSAC_with_parameters_8cpp-example.html">Shape_detection/efficient_RANSAC_with_parameters.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_with_normal_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Shape_detection/Efficient_RANSAC.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Type declarations.</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>  Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a>                                           FT;</div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Kernel::Point_3, Kernel::Vector_3&gt;         Point_with_normal;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point_with_normal&gt;                       Pwn_vector;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Point_with_normal&gt;</a>  Point_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;Point_with_normal&gt;</a> Normal_map;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="structCGAL_1_1Shape__detection_1_1Efficient__RANSAC__traits.html">CGAL::Shape_detection::Efficient_RANSAC_traits</a></div><div class="line">&lt;Kernel, Pwn_vector, Point_map, Normal_map&gt;             Traits;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Shape__detection_1_1Efficient__RANSAC.html">CGAL::Shape_detection::Efficient_RANSAC&lt;Traits&gt;</a> Efficient_ransac;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Shape__detection_1_1Cone.html">CGAL::Shape_detection::Cone&lt;Traits&gt;</a>             Cone;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Shape__detection_1_1Cylinder.html">CGAL::Shape_detection::Cylinder&lt;Traits&gt;</a>         Cylinder;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Shape__detection_1_1Plane.html">CGAL::Shape_detection::Plane&lt;Traits&gt;</a>            Plane;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Shape__detection_1_1Sphere.html">CGAL::Shape_detection::Sphere&lt;Traits&gt;</a>           Sphere;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Shape__detection_1_1Torus.html">CGAL::Shape_detection::Torus&lt;Traits&gt;</a>            Torus;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div><div class="line"></div><div class="line">  <span class="comment">// Points with normals.</span></div><div class="line">  Pwn_vector points;</div><div class="line"></div><div class="line">  <span class="comment">// Load point set from a file.</span></div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(</div><div class="line">      ((argc &gt; 1) ? argv[1] : CGAL::data_file_path(<span class="stringliteral">"points_3/cube.pwn"</span>)),</div><div class="line">      std::back_inserter(points),</div><div class="line">      CGAL::parameters::point_map(Point_map()).</div><div class="line">      normal_map(Normal_map()))) {</div><div class="line"></div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file cube.pwn!"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; points.size() &lt;&lt; <span class="stringliteral">" points"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Instantiate shape detection engine.</span></div><div class="line">  Efficient_ransac ransac;</div><div class="line"></div><div class="line">  <span class="comment">// Provide input data.</span></div><div class="line">  ransac.set_input(points);</div><div class="line"></div><div class="line">  <span class="comment">// Register shapes for detection.</span></div><div class="line">  ransac.add_shape_factory&lt;Plane&gt;();</div><div class="line">  ransac.add_shape_factory&lt;Sphere&gt;();</div><div class="line">  ransac.add_shape_factory&lt;Cylinder&gt;();</div><div class="line">  ransac.add_shape_factory&lt;Cone&gt;();</div><div class="line">  ransac.add_shape_factory&lt;Torus&gt;();</div><div class="line"></div><div class="line">  <span class="comment">// Set parameters for shape detection.</span></div><div class="line">  Efficient_ransac::Parameters parameters;</div><div class="line"></div><div class="line">  <span class="comment">// Set probability to miss the largest primitive at each iteration.</span></div><div class="line">  parameters.probability = 0.05;</div><div class="line"></div><div class="line">  <span class="comment">// Detect shapes with at least 200 points.</span></div><div class="line">  parameters.min_points = 200;</div><div class="line"></div><div class="line">  <span class="comment">// Set maximum Euclidean distance between a point and a shape.</span></div><div class="line">  parameters.epsilon = 0.002;</div><div class="line"></div><div class="line">  <span class="comment">// Set maximum Euclidean distance between points to be clustered.</span></div><div class="line">  parameters.cluster_epsilon = 0.01;</div><div class="line"></div><div class="line">  <span class="comment">// Set maximum normal deviation.</span></div><div class="line">  <span class="comment">// 0.9 &lt; dot(surface_normal, point_normal);</span></div><div class="line">  parameters.normal_threshold = 0.9;</div><div class="line"></div><div class="line">  <span class="comment">// Detect shapes.</span></div><div class="line">  ransac.detect(parameters);</div><div class="line"></div><div class="line">  <span class="comment">// Print number of detected shapes and unassigned points.</span></div><div class="line">  std::cout &lt;&lt; ransac.shapes().end() - ransac.shapes().begin()</div><div class="line">  &lt;&lt; <span class="stringliteral">" detected shapes, "</span></div><div class="line">  &lt;&lt; ransac.number_of_unassigned_points()</div><div class="line">  &lt;&lt; <span class="stringliteral">" unassigned points."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Efficient_ransac::shapes() provides</span></div><div class="line">  <span class="comment">// an iterator range to the detected shapes.</span></div><div class="line">  Efficient_ransac::Shape_range shapes = ransac.shapes();</div><div class="line">  Efficient_ransac::Shape_range::iterator it = shapes.begin();</div><div class="line"></div><div class="line">  <span class="keywordflow">while</span> (it != shapes.end()) {</div><div class="line"></div><div class="line">    <span class="comment">// Get specific parameters depending on the detected shape.</span></div><div class="line">    <span class="keywordflow">if</span> (Plane* plane = dynamic_cast&lt;Plane*&gt;(it-&gt;get())) {</div><div class="line"></div><div class="line">      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__normal__grp.html#ga49a712e57564602ad468a3888784e971">normal</a> = plane-&gt;plane_normal();</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">"Plane with normal "</span> &lt;&lt; normal &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="comment">// Plane shape can also be converted to the Kernel::Plane_3.</span></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">"Kernel::Plane_3: "</span> &lt;&lt;</div><div class="line">      <span class="keyword">static_cast&lt;</span><a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Plane__3.html">Kernel::Plane_3</a><span class="keyword">&gt;</span>(*plane) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Cylinder* cyl = dynamic_cast&lt;Cylinder*&gt;(it-&gt;get())) {</div><div class="line"></div><div class="line">      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Line__3.html">Kernel::Line_3</a> axis = cyl-&gt;axis();</div><div class="line">      FT radius = cyl-&gt;radius();</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">"Cylinder with axis "</span></div><div class="line">      &lt;&lt; axis &lt;&lt; <span class="stringliteral">" and radius "</span> &lt;&lt; radius &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line"></div><div class="line">      <span class="comment">// Print the parameters of the detected shape.</span></div><div class="line">      <span class="comment">// This function is available for any type of shape.</span></div><div class="line">      std::cout &lt;&lt; (*it)-&gt;info() &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Proceed with the next detected shape.</span></div><div class="line">    it++;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="Shape_detection_RANSACExample_with_point_access"></a>
Retrieving Points Assigned To Shapes</h3>
<p>This example illustrates how to access the points assigned to each shape and compute the mean error. A timer measures the running performance.</p>
<p><br />
<b>File</b> <a class="el" href="Shape_detection_2efficient_RANSAC_with_point_access_8cpp-example.html">Shape_detection/efficient_RANSAC_with_point_access.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Timer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/number_utils.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Shape_detection/Efficient_RANSAC.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Type declarations.</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>  Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a>                                           FT;</div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Kernel::Point_3, Kernel::Vector_3&gt;         Point_with_normal;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point_with_normal&gt;                       Pwn_vector;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Point_with_normal&gt;</a>  Point_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;Point_with_normal&gt;</a> Normal_map;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="code" href="structCGAL_1_1Shape__detection_1_1Efficient__RANSAC__traits.html">CGAL::Shape_detection::Efficient_RANSAC_traits</a></div><div class="line">&lt;Kernel, Pwn_vector, Point_map, Normal_map&gt;             Traits;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Shape__detection_1_1Efficient__RANSAC.html">CGAL::Shape_detection::Efficient_RANSAC&lt;Traits&gt;</a> Efficient_ransac;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCGAL_1_1Shape__detection_1_1Plane.html">CGAL::Shape_detection::Plane&lt;Traits&gt;</a>            Plane;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div><div class="line"></div><div class="line">  <span class="comment">// Points with normals.</span></div><div class="line">  Pwn_vector points;</div><div class="line"></div><div class="line">  <span class="comment">// Load point set from a file.</span></div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(</div><div class="line">      ((argc &gt; 1) ? argv[1] : CGAL::data_file_path(<span class="stringliteral">"points_3/cube.pwn"</span>)),</div><div class="line">      std::back_inserter(points),</div><div class="line">      CGAL::parameters::point_map(Point_map()).</div><div class="line">      normal_map(Normal_map()))) {</div><div class="line"></div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file cube.pwn!"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Instantiate shape detection engine.</span></div><div class="line">  Efficient_ransac ransac;</div><div class="line"></div><div class="line">  <span class="comment">// Provide input data.</span></div><div class="line">  ransac.set_input(points);</div><div class="line"></div><div class="line">  <span class="comment">// Register detection of planes.</span></div><div class="line">  ransac.add_shape_factory&lt;Plane&gt;();</div><div class="line"></div><div class="line">  <span class="comment">// Measure time before setting up the shape detection.</span></div><div class="line">  CGAL::Timer time;</div><div class="line">  time.start();</div><div class="line"></div><div class="line">  <span class="comment">// Build internal data structures.</span></div><div class="line">  ransac.preprocess();</div><div class="line"></div><div class="line">  <span class="comment">// Measure time after preprocessing.</span></div><div class="line">  time.stop();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"preprocessing took: "</span> &lt;&lt; time.time() * 1000 &lt;&lt; <span class="stringliteral">"ms"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Perform detection several times and choose result with the highest coverage.</span></div><div class="line">  Efficient_ransac::Shape_range shapes = ransac.shapes();</div><div class="line"></div><div class="line">  FT best_coverage = 0;</div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; 3; ++i) {</div><div class="line"></div><div class="line">    <span class="comment">// Reset timer.</span></div><div class="line">    time.reset();</div><div class="line">    time.start();</div><div class="line"></div><div class="line">    <span class="comment">// Detect shapes.</span></div><div class="line">    ransac.detect();</div><div class="line"></div><div class="line">    <span class="comment">// Measure time after detection.</span></div><div class="line">    time.stop();</div><div class="line"></div><div class="line">    <span class="comment">// Compute coverage, i.e. ratio of the points assigned to a shape.</span></div><div class="line">    FT coverage =</div><div class="line">    FT(points.size() - ransac.number_of_unassigned_points()) / FT(points.size());</div><div class="line"></div><div class="line">    <span class="comment">// Print number of assigned shapes and unassigned points.</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"time: "</span> &lt;&lt; time.time() * 1000 &lt;&lt; <span class="stringliteral">"ms"</span> &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; ransac.shapes().end() - ransac.shapes().begin()</div><div class="line">    &lt;&lt; <span class="stringliteral">" primitives, "</span> &lt;&lt; coverage &lt;&lt; <span class="stringliteral">" coverage"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// Choose result with the highest coverage.</span></div><div class="line">    <span class="keywordflow">if</span> (coverage &gt; best_coverage) {</div><div class="line"></div><div class="line">      best_coverage = coverage;</div><div class="line"></div><div class="line">      <span class="comment">// Efficient_ransac::shapes() provides</span></div><div class="line">      <span class="comment">// an iterator range to the detected shapes.</span></div><div class="line">      shapes = ransac.shapes();</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  Efficient_ransac::Shape_range::iterator it = shapes.begin();</div><div class="line">  <span class="keywordflow">while</span> (it != shapes.end()) {</div><div class="line"></div><div class="line">    boost::shared_ptr&lt;Efficient_ransac::Shape&gt; shape = *it;</div><div class="line"></div><div class="line">    <span class="comment">// Use Shape_base::info() to print the parameters of the detected shape.</span></div><div class="line">    std::cout &lt;&lt; (*it)-&gt;<a class="code" href="classCGAL_1_1Shape__detection_1_1Shape__base.html#ac1bbd0a749fbc118fe266039fcb88b09">info</a>();</div><div class="line"></div><div class="line">    <span class="comment">// Sums distances of points to the detected shapes.</span></div><div class="line">    FT sum_distances = 0;</div><div class="line"></div><div class="line">    <span class="comment">// Iterate through point indices assigned to each detected shape.</span></div><div class="line">    std::vector&lt;std::size_t&gt;::const_iterator</div><div class="line">    index_it = (*it)-&gt;indices_of_assigned_points().begin();</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (index_it != (*it)-&gt;indices_of_assigned_points().end()) {</div><div class="line"></div><div class="line">      <span class="comment">// Retrieve point.</span></div><div class="line">      <span class="keyword">const</span> Point_with_normal&amp; p = *(points.begin() + (*index_it));</div><div class="line"></div><div class="line">      <span class="comment">// Adds Euclidean distance between point and shape.</span></div><div class="line">      sum_distances += <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">CGAL::sqrt</a>((*it)-&gt;squared_distance(p.first));</div><div class="line"></div><div class="line">      <span class="comment">// Proceed with the next point.</span></div><div class="line">      index_it++;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Compute and print the average distance.</span></div><div class="line">    FT average_distance = sum_distances / shape-&gt;indices_of_assigned_points().size();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">" average distance: "</span> &lt;&lt; average_distance &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// Proceed with the next detected shape.</span></div><div class="line">    it++;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="Shape_detection_RANSACExample_with_custom_shapes"></a>
Custom Shapes</h3>
<p>Other shape types can be detected by implementing a shape class derived from the class <code><a class="el" href="classCGAL_1_1Shape__detection_1_1Shape__base.html" title="Base class for shape types that defines an interface to construct a shape from a set of points and to...">Shape_detection::Shape_base</a></code> and registering it to the shape detection factory of the Efficient RANSAC object. This class must provide the following functions: construct a shape from a small set of given points, compute the squared distance from a query point to the shape, and compute the normal deviation between a query point with the normal and the normal to the shape at the closest point from the query. The used shape parameters are added as members to the derived class.</p>
<p>Note that the RANSAC approach is efficient for shapes that are uniquely defined by a small number of points, denoted by the number of required samples. The algorithm aims at detecting the largest shape via many random samples, and the combinatorial complexity of possible samples increases rapidly with the number of required samples.</p>
<p>More specifically, the functions to be implemented are defined in the base class <code><a class="el" href="classCGAL_1_1Shape__detection_1_1Shape__base.html" title="Base class for shape types that defines an interface to construct a shape from a set of points and to...">Shape_detection::Shape_base</a></code>:</p>
<ul>
<li><code><a class="el" href="classCGAL_1_1Shape__detection_1_1Shape__base.html#afba75428e79da4371347314858440a41" title="Returns minimal number of sample points required for construction. ">Shape_detection::Shape_base::minimum_sample_size()</a></code> const: Returns the minimum number of required samples.</li>
<li><code><a class="el" href="classCGAL_1_1Shape__detection_1_1Shape__base.html#a4f4e29f440b04dccebd9597f98bb3b2e" title="Constructs the shape based on a minimal set of samples from the input data. ">Shape_detection::Shape_base::create_shape</a>(const std::vector&lt;size_t&gt;&amp; indices)</code>: The randomly generated samples are provided via a vector of indices. <code><a class="el" href="classCGAL_1_1Shape__detection_1_1Shape__base.html#a541fb82f5936525b01dc690ae3317fa4" title="Retrieves the point location from its index. ">Shape_detection::Shape_base::point</a></code><code>(std::size_t index)</code> and <code><a class="el" href="classCGAL_1_1Shape__detection_1_1Shape__base.html#afa97971c02d019424edf02f87911c542" title="Retrieves the normal vector from its index. ">Shape_detection::Shape_base::normal</a></code><code>(std::size_t index)</code> are used to retrieve the actual points and normals (see the example below). The provided number of samples might actually be larger than the above minimum number of required samples, depending on the other shape types. If the provided samples are not sufficient to define a unique shape, for example in a degenerated case, the shape is considered invalid.</li>
<li><code><a class="el" href="classCGAL_1_1Shape__detection_1_1Shape__base.html#ab04f03619adb9bee6112f074ba2508ff" title="Computes the squared Euclidean distance from the query point p to the shape. ">Shape_detection::Shape_base::squared_distance</a></code><code>(const Point&amp; point)</code> const: This function computes the squared distance from a query point to the shape. It is used for traversing the hierarchical spatial data structure.</li>
<li><code><a class="el" href="classCGAL_1_1Shape__detection_1_1Shape__base.html#ab04f03619adb9bee6112f074ba2508ff" title="Computes the squared Euclidean distance from the query point p to the shape. ">Shape_detection::Shape_base::squared_distance</a>(std::vector&lt;FT&gt;&amp; distances, const std::vector&lt;size_t&gt;&amp; indices)</code> and</li>
<li><code><a class="el" href="classCGAL_1_1Shape__detection_1_1Shape__base.html#a07f487f782693af3fa42a29f9ad14a97" title="Computes the deviation of the point normal from the surface normal at the projected point in form of ...">Shape_detection::Shape_base::cos_to_normal</a></code><code>(const std::vector&lt;size_t&gt;&amp; indices, std::vector&lt;FT&gt;&amp; angles)</code> const.</li>
</ul>
<p>The last two functions are used to determine the number of inlier points to the shape. They compute respectively the squared distance from a set of points to the shape, and the dot product between the point normals and the normals at the shape for the closest points on the shape.</p>
<p>The access to the actual point and normal data is carried out via <code><a class="el" href="classCGAL_1_1Shape__detection_1_1Shape__base.html#a541fb82f5936525b01dc690ae3317fa4" title="Retrieves the point location from its index. ">Shape_detection::Shape_base::point</a></code><code>(std::size_t index)</code> and <code><a class="el" href="classCGAL_1_1Shape__detection_1_1Shape__base.html#afa97971c02d019424edf02f87911c542" title="Retrieves the normal vector from its index. ">Shape_detection::Shape_base::normal</a></code><code>(std::size_t index)</code> (see the example below). The resulting squared distance/dot product is stored in the vector provided as the first argument.</p>
<p>By default, the connected component is detected via the neighbor graph as mentioned above. However, for shapes that admit a faster approach to detect a connected component, the user can provide his/her own implementation to extract the connected component via:</p><ul>
<li><code><a class="el" href="classCGAL_1_1Shape__detection_1_1Shape__base.html#a48186a53453c9a0c11cfebc8dcd399eb" title="Determines the largest cluster of inlier points. ">Shape_detection::Shape_base::connected_component</a></code><code>(std::vector&lt;std::size_t&gt;&amp; indices, FT cluster_epsilon)</code>: The indices of all supporting points are stored in the vector <code>indices</code>. All points that do not belong to the largest cluster of points are removed from the vector <code>indices</code>.</li>
</ul>
<p>Another optional method can be implemented to provide a helper function providing the shape parameters written to a string:</p><ul>
<li><code><a class="el" href="classCGAL_1_1Shape__detection_1_1Shape__base.html#ac1bbd0a749fbc118fe266039fcb88b09" title="Returns a string containing the shape type and the numerical parameters. ">Shape_detection::Shape_base::info</a></code><code>()</code>: This function returns a string suitable for printing the shape parameters into a log/console. The default solution provides an empty string.</li>
</ul>
<p>The property maps are used to map the indices to the corresponding points and normals. The following header shows an implementation of a planar shape primitive, which is used by the example <a class="el" href="Shape_detection_2efficient_RANSAC_with_custom_shape_8cpp-example.html">Shape_detection/efficient_RANSAC_with_custom_shape.cpp</a>.</p>
<p><br />
<b>File</b> <a class="el" href="Shape_detection_2include_2efficient_RANSAC_with_custom_shape_8h-example.html">Shape_detection/include/efficient_RANSAC_with_custom_shape.h</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#ifndef MY_PLANE_SHAPE_H</span></div><div class="line"><span class="preprocessor">#define MY_PLANE_SHAPE_H</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/number_utils.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Shape_detection/Efficient_RANSAC.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// My_Plane is derived from Shape_base. The plane is represented by</span></div><div class="line"><span class="comment">// its normal vector and distance to the origin.</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Traits&gt;</div><div class="line"><span class="keyword">class </span>My_Plane : <span class="keyword">public</span> <a class="code" href="classCGAL_1_1Shape__detection_1_1Shape__base.html">CGAL::Shape_detection::Shape_base</a>&lt;Traits&gt; {</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Traits::FT FT;           <span class="comment">// number type</span></div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Traits::Point_3 Point;   <span class="comment">// point type</span></div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Traits::Vector_3 Vector; <span class="comment">// vector type</span></div><div class="line"></div><div class="line">  My_Plane() :</div><div class="line">  <a class="code" href="namespaceCGAL.html">CGAL</a>::Shape_detection::Shape_base&lt;Traits&gt;()</div><div class="line">  { }</div><div class="line"></div><div class="line">  <span class="comment">// Compute squared Euclidean distance from query point to the shape.</span></div><div class="line">  <span class="keyword">virtual</span> FT <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">squared_distance</a>(<span class="keyword">const</span> Point&amp; p)<span class="keyword"> const </span>{</div><div class="line"></div><div class="line">    <span class="keyword">const</span> FT sd = (this-&gt;constr_vec(m_point_on_primitive, p)) * m_normal;</div><div class="line">    <span class="keywordflow">return</span> sd * sd;</div><div class="line">  }</div><div class="line"></div><div class="line">  Vector plane_normal()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> m_normal;</div><div class="line">  }</div><div class="line"></div><div class="line">  FT d()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> m_d;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Return a string with shape parameters.</span></div><div class="line">  <span class="keyword">virtual</span> std::string info()<span class="keyword"> const </span>{</div><div class="line"></div><div class="line">    std::stringstream sstr;</div><div class="line"></div><div class="line">    sstr &lt;&lt; <span class="stringliteral">"Type: plane ("</span> &lt;&lt; this-&gt;get_x(m_normal) &lt;&lt; <span class="stringliteral">", "</span></div><div class="line">    &lt;&lt; this-&gt;get_y(m_normal) &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; this-&gt;get_z(m_normal) &lt;&lt; <span class="stringliteral">")x - "</span> &lt;&lt;</div><div class="line"></div><div class="line">    m_d &lt;&lt; <span class="stringliteral">" = 0"</span> &lt;&lt; <span class="stringliteral">" #Pts: "</span> &lt;&lt; this-&gt;m_indices.size();</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> sstr.str();</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line"></div><div class="line">  <span class="comment">// Construct shape base on a minimal set of samples from the input data.</span></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> create_shape(<span class="keyword">const</span> std::vector&lt;std::size_t&gt;&amp; indices) {</div><div class="line"></div><div class="line">    <span class="keyword">const</span> Point p1 = this-&gt;point(indices[0]);</div><div class="line">    <span class="keyword">const</span> Point p2 = this-&gt;point(indices[1]);</div><div class="line">    <span class="keyword">const</span> Point p3 = this-&gt;point(indices[2]);</div><div class="line"></div><div class="line">    m_normal = this-&gt;cross_pdct(p1 - p2, p1 - p3);</div><div class="line"></div><div class="line">    m_normal = m_normal * (1.0 / <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#gab922269072ee9ee99ba8c541418b2e11">sqrt</a>(this-&gt;sqlen(m_normal)));</div><div class="line">    m_d = -(p1[0] * m_normal[0] + p1[1] * m_normal[1] + p1[2] * m_normal[2]);</div><div class="line"></div><div class="line">    m_point_on_primitive = p1;</div><div class="line">    this-&gt;m_is_valid = <span class="keyword">true</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Compute squared Euclidean distance from a set of points.</span></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">squared_distance</a>(</div><div class="line">    <span class="keyword">const</span> std::vector&lt;std::size_t&gt;&amp; indices,</div><div class="line">    std::vector&lt;FT&gt;&amp; dists)<span class="keyword"> const </span>{</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; indices.size(); ++i) {</div><div class="line"></div><div class="line">      <span class="keyword">const</span> FT sd = (this-&gt;point(indices[i]) - m_point_on_primitive) * m_normal;</div><div class="line">      dists[i] = sd * sd;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Compute the normal deviation between a shape and</span></div><div class="line">  <span class="comment">// a set of points with normals.</span></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> cos_to_normal(</div><div class="line">    <span class="keyword">const</span> std::vector&lt;std::size_t&gt;&amp; indices,</div><div class="line">    std::vector&lt;FT&gt;&amp; angles)<span class="keyword"> const </span>{</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; indices.size(); ++i)</div><div class="line">      angles[i] = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">CGAL::abs</a>(this-&gt;<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__normal__grp.html#ga49a712e57564602ad468a3888784e971">normal</a>(indices[i]) * m_normal);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Return the number of required samples for construction.</span></div><div class="line">  <span class="keyword">virtual</span> std::size_t minimum_sample_size()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> 3;</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line"></div><div class="line">  Point  m_point_on_primitive;</div><div class="line">  Vector m_normal;</div><div class="line">  FT     m_d;</div><div class="line"></div><div class="line">};</div><div class="line"></div><div class="line"><span class="preprocessor">#endif // MY_PLANE_SHAPE_H</span></div></div><!-- fragment --><h2><a class="anchor" id="Shape_detection_RANSACPerformance"></a>
Performance</h2>
<p>The running time and detection performance of the Efficient RANSAC depend on the chosen parameters. A selective error tolerance parameter leads to higher running time and fewer shapes, as many shape candidates are generated to find the largest shape. We plot the detection performance against the <code>epsilon</code> error tolerance parameter for detecting planes in a complex scene with 5M points (see Figure <a class="el" href="index.html#fig__Efficient_RANSAC_performance_epsilon">Figure 82.4</a>). The <code>probability</code> parameter controls the endurance when searching for the largest candidate at each iteration. It barely impacts the number of detected shapes, has a moderate impact on the size of the detected shapes, and increases the running time. We plot the performance against the <code>probability</code> parameter (see Figure <a class="el" href="index.html#fig__Efficient_RANSAC_performance_probability">Figure 82.5</a>).</p>
<p><a class="anchor" id="fig__Efficient_RANSAC_performance_epsilon"></a></p><div class="image">
<img src="epsilon_graph.png" alt="epsilon_graph.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Efficient_RANSAC_performance_epsilon">Figure 82.4</a> The graph depicts the number of detected shapes (purple) and the coverage (green), that is the ratio assignedPoints / totalPoints, against the <code>epsilon</code> tolerance parameter. A higher value for <code>epsilon</code>, that is a more tolerant error, leads to fewer but larger shapes and shorter running times.  </div> <br /> 
<p><a class="anchor" id="fig__Efficient_RANSAC_performance_probability"></a></p><div class="image">
<img src="prob_graph.png" alt="prob_graph.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Efficient_RANSAC_performance_probability">Figure 82.5</a> The graph depicts the time, coverage, and the number of detected primitives against the search endurance parameter, that is <code>probability</code> to miss the largest shape at each iteration. The number of shapes is stable and the coverage increases when the <code>probability</code> is lowered. The running time increases significantly as many more candidates are generated during each iteration of the algorithm.  </div> <br /> 
<h1><a class="anchor" id="Shape_detection_RegionGrowing"></a>
Region Growing</h1>
<p>This shape detection component is based on the region growing algorithm applied to a set of user-specified items. Shapes are detected by growing regions from seed items, where each region is created as follows:</p>
<ol type="1">
<li>Pick the next available seed item;</li>
<li>Find its neighbors in the data set;</li>
<li>Include those neighbors, which satisfy the region requirements;</li>
<li>Repeat the procedure for all included neighbors;</li>
<li>If no further neighbor satisfies the requirements, start a new region.</li>
</ol>
<p>Together with the generic algorithm's implementation <code><a class="el" href="classCGAL_1_1Shape__detection_1_1Region__growing.html" title="Main class/entry point for running the region growing algorithm. ">CGAL::Shape_detection::Region_growing</a></code>, three particular instances of this algorithm are provided:</p>
<ul>
<li>Line and circle detection in a <a class="el" href="index.html#Shape_detection_RegionGrowingPoints">2D point set</a>;</li>
<li>Plane, sphere, and cylinder detection in a <a class="el" href="index.html#Shape_detection_RegionGrowingPoints">3D point set</a>;</li>
<li>Plane detection on a <a class="el" href="index.html#Shape_detection_RegionGrowingMesh">polygon mesh</a>.</li>
</ul>
<p>Other instances can be easily added by the user, as explained below.</p>
<h2><a class="anchor" id="Shape_detection_RegionGrowingFramework"></a>
Framework</h2>
<p>The main class <code><a class="el" href="classCGAL_1_1Shape__detection_1_1Region__growing.html" title="Main class/entry point for running the region growing algorithm. ">CGAL::Shape_detection::Region_growing</a></code> is parameterized by</p>
<ul>
<li><code>InputRange</code> that stores a range of user-defined input items;</li>
<li><a class="el" href="index.html#Shape_detection_RegionGrowingFramework_connectivity">NeighborQuery</a> that provides the means for accessing neighbors of an item;</li>
<li><a class="el" href="index.html#Shape_detection_RegionGrowingFramework_conditions">RegionType</a> that provides the means for validating regions;</li>
<li><a class="el" href="index.html#Shape_detection_RegionGrowingFramework_seeding">SeedMap</a> that defines the seeding order of items.</li>
</ul>
<p>Using this generic framework, users can grow any type of regions on a set of arbitrary items with their own propagation and seeding conditions (see <a class="el" href="index.html#Shape_detection_RegionGrowingFramework_examples">an example</a>).</p>
<h3><a class="anchor" id="Shape_detection_RegionGrowingFramework_connectivity"></a>
Neighborhood</h3>
<p>The concept <code><a class="el" href="classNeighborQuery.html" title="A concept that describes the set of methods used by the CGAL::Shape_detection::Region_growing to acce...">NeighborQuery</a></code> provides the means for accessing neighbors of an item. To create a model that respects this concept, the user has to provide an overload of the operator:</p>
<ul>
<li><code><a class="el" href="classNeighborQuery.html#add6d86d139b057a9b819311d383b3bd2" title="fills neighbors with the indices of all items, which are connected to the item with the index query_i...">NeighborQuery::operator()()</a></code> that has to fill a vector with indices of all items, which are neighbors of the query item.</li>
</ul>
<h3><a class="anchor" id="Shape_detection_RegionGrowingFramework_conditions"></a>
Regions</h3>
<p>The concept <code><a class="el" href="classRegionType.html" title="A concept that describes the set of methods used by the CGAL::Shape_detection::Region_growing to main...">RegionType</a></code> provides the means for validating regions. In fact, a model of this concept maintains a description of the region type that is used in region growing. To create a model that respect this concept, three functions have to be defined:</p>
<ul>
<li><code><a class="el" href="classRegionType.html#abf9f02613b07bce21e53f2d175532eae" title="checks if the item with the index index_to, which is a neighbor of the item with the index index_from...">RegionType::is_part_of_region()</a></code> This function checks if an item satisfies all necessary region requirements and can be added to a region. It is called per item.</li>
<li><code><a class="el" href="classRegionType.html#abb5a96a01ed18ea325abf58ad726f6e5" title="checks if the region represented by indices satisfies all necessary conditions. ">RegionType::is_valid_region()</a></code> This function checks if a region satisfies all necessary region requirements. It is called per region.</li>
<li><code><a class="el" href="classRegionType.html#a3a11858e85d9c5f7354b6ffec4f653ff" title="enables to update any information that is maintained with the region represented by indices...">RegionType::update()</a></code> This utility function enables to update any information, which is maintained with the region.</li>
</ul>
<h3><a class="anchor" id="Shape_detection_RegionGrowingFramework_seeding"></a>
Seeding</h3>
<p>The <code>SeedMap</code> property map, provided as an optional parameter to the main class, enables to define the seeding order of items that is which items are used first to grow regions from. Such items are referred to as <em>seed</em> items. The <code>SeedMap</code> maps the index of an item to its order number in the overall region growing processing queue. The default map is the identity one that is the seed index of the item equals to the item's index in the <code>input_range</code>. If it maps to <code>std::size_t(-1)</code>, then the corresponding item is skipped.</p>
<h3><a class="anchor" id="Shape_detection_RegionGrowingFramework_examples"></a>
Examples</h3>
<p>This toy example shows how to define one's own <a class="el" href="index.html#Shape_detection_RegionGrowingFramework_connectivity">NeighborQuery</a> and <a class="el" href="index.html#Shape_detection_RegionGrowingFramework_conditions">RegionType</a> classes, which are used to parameterize the <code><a class="el" href="classCGAL_1_1Shape__detection_1_1Region__growing.html" title="Main class/entry point for running the region growing algorithm. ">CGAL::Shape_detection::Region_growing</a></code>. It also shows how to skip unnecessary items and change their default seeding order.</p>
<p>We choose a simple custom object item. We define four such objects, where for each object, we manually store indices of its neighbors. The operator <code><a class="el" href="classNeighborQuery.html#add6d86d139b057a9b819311d383b3bd2" title="fills neighbors with the indices of all items, which are connected to the item with the index query_i...">NeighborQuery::operator()()</a></code> does nothing but accessing these neighbors. The <code><a class="el" href="classRegionType.html" title="A concept that describes the set of methods used by the CGAL::Shape_detection::Region_growing to main...">RegionType</a></code> class defines the three necessary functions:</p>
<ul>
<li><code><a class="el" href="classRegionType.html#abf9f02613b07bce21e53f2d175532eae" title="checks if the item with the index index_to, which is a neighbor of the item with the index index_from...">RegionType::is_part_of_region()</a></code> - <code>true</code> if the first and second objects are neighbors,</li>
<li><code><a class="el" href="classRegionType.html#abb5a96a01ed18ea325abf58ad726f6e5" title="checks if the region represented by indices satisfies all necessary conditions. ">RegionType::is_valid_region()</a></code> - always <code>true</code> after the first call to the function <code>update()</code>,</li>
<li><code><a class="el" href="classRegionType.html#a3a11858e85d9c5f7354b6ffec4f653ff" title="enables to update any information that is maintained with the region represented by indices...">RegionType::update()</a></code> - updates the internal flag from the default <code>false</code> to <code>true</code>.</li>
</ul>
<p>We also define a <code>SeedMap</code>, such that the second object is handled first, while the first object follows. Moreover, the last object is always skipped. Notice that in this example, the container with objects is <code>std::vector</code>, which is random access. However, the generic region growing algorithm can be applied to any other type of container, e.g. <code>std::list</code>.</p>
<p>The result of using these classes with the region growing main class is that the first two objects form the first region, the third object forms the second region, and the last object is skipped.</p>
<p><br />
<b>File</b> <a class="el" href="Shape_detection_2region_growing_with_custom_classes_8cpp-example.html">Shape_detection/region_growing_with_custom_classes.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// STL includes.</span></div><div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iterator&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// CGAL includes.</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Shape_detection/Region_growing/Region_growing.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Custom Neighbor_query, Region_type, and Seed_map classes for region growing.</span></div><div class="line"><span class="keyword">namespace </span>Custom {</div><div class="line"></div><div class="line">  <span class="comment">// An object that stores indices of all its neighbors.</span></div><div class="line">  <span class="keyword">struct </span>Object {</div><div class="line">    std::vector&lt;std::size_t&gt; neighbors;</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="comment">// A range of objects.</span></div><div class="line">  <span class="keyword">using</span> Objects = std::vector&lt;Object&gt;;</div><div class="line"></div><div class="line">  <span class="comment">// The Neighbor_query functor that accesses neighbors stored in</span></div><div class="line">  <span class="comment">// the object struct above.</span></div><div class="line">  <span class="keyword">class </span>Neighbor_query {</div><div class="line">    <span class="keyword">const</span> Objects&amp; m_objects;</div><div class="line"></div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    Neighbor_query(<span class="keyword">const</span> Objects&amp; objects) :</div><div class="line">    m_objects(objects)</div><div class="line">    { }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> operator()(</div><div class="line">      <span class="keyword">const</span> std::size_t query_index,</div><div class="line">      std::vector&lt;std::size_t&gt;&amp; neighbors)<span class="keyword"> const </span>{</div><div class="line"></div><div class="line">      std::size_t i = 0;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; <span class="keywordtype">object</span> : m_objects) {</div><div class="line">        <span class="keywordflow">if</span> (i == query_index) {</div><div class="line"></div><div class="line">          neighbors = <span class="keywordtype">object</span>.neighbors;</div><div class="line">          <span class="keywordflow">return</span>;</div><div class="line">        } ++i;</div><div class="line">      }</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="comment">// The Region_type class, where the function is_part_of_region() verifies</span></div><div class="line">  <span class="comment">// a very specific condition that the first and second objects in the</span></div><div class="line">  <span class="comment">// range are in fact neighbors; is_valid_region() function always</span></div><div class="line">  <span class="comment">// returns true after the first call to the update() function.</span></div><div class="line">  <span class="comment">// These are the only functions that have to be defined.</span></div><div class="line">  <span class="keyword">class </span>Region_type {</div><div class="line">    <span class="keywordtype">bool</span> m_is_valid = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    Region_type() { }</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> is_part_of_region(</div><div class="line">      <span class="keyword">const</span> std::size_t,</div><div class="line">      <span class="keyword">const</span> std::size_t query_index,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;std::size_t&gt;&amp; region)<span class="keyword"> const </span>{</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (region.size() == 0)</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::size_t index = region[0];</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (index == 0 &amp;&amp; query_index == 1) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">      <span class="keywordflow">if</span> (query_index == 0 &amp;&amp; index == 1) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">bool</span> is_valid_region(<span class="keyword">const</span> std::vector&lt;std::size_t&gt;&amp;)<span class="keyword"> const </span>{</div><div class="line">      <span class="keywordflow">return</span> m_is_valid;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> update(<span class="keyword">const</span> std::vector&lt;std::size_t&gt;&amp;) {</div><div class="line">      m_is_valid = <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="comment">// The SeedMap class that uses the m_objects_map to define</span></div><div class="line">  <span class="comment">// the seeding order of objects.</span></div><div class="line">  <span class="keyword">class </span>Seed_map {</div><div class="line"></div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">using</span> key_type   = std::size_t;</div><div class="line">    <span class="keyword">using</span> value_type = std::size_t;</div><div class="line">    <span class="keyword">using</span> reference  = std::size_t;</div><div class="line">    <span class="keyword">using</span> category   = boost::readable_property_map_tag;</div><div class="line"></div><div class="line">    Seed_map(<span class="keyword">const</span> std::map&lt;std::size_t, std::size_t&gt;&amp; objects_map)</div><div class="line">      : m_objects_map(objects_map)</div><div class="line">    { }</div><div class="line"></div><div class="line">    value_type operator[](<span class="keyword">const</span> key_type&amp; key)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> m_objects_map.find(key)-&gt;second;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">friend</span> value_type <span class="keyword">get</span>(<span class="keyword">const</span> Seed_map&amp; seed_map,</div><div class="line">                          <span class="keyword">const</span> key_type&amp; key)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">return</span> seed_map[key];</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> std::map&lt;std::size_t, std::size_t&gt;&amp; m_objects_map;</div><div class="line">  };</div><div class="line"></div><div class="line">} <span class="comment">// namespace Custom</span></div><div class="line"></div><div class="line"><span class="comment">// Type declarations.</span></div><div class="line"><span class="keyword">using</span> Object         = Custom::Object;</div><div class="line"><span class="keyword">using</span> Objects        = Custom::Objects;</div><div class="line"><span class="keyword">using</span> Neighbor_query = Custom::Neighbor_query;</div><div class="line"><span class="keyword">using</span> Region_type    = Custom::Region_type;</div><div class="line"><span class="keyword">using</span> Seed_map       = Custom::Seed_map;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Region  = std::vector&lt;std::size_t&gt;;</div><div class="line"><span class="keyword">using</span> Regions = std::vector&lt;Region&gt;;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Region_growing =</div><div class="line"><a class="code" href="classCGAL_1_1Shape__detection_1_1Region__growing.html">CGAL::Shape_detection::Region_growing&lt;Objects, Neighbor_query, Region_type, Seed_map&gt;</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line"></div><div class="line">  std::cout &lt;&lt; std::endl &lt;&lt;</div><div class="line">    <span class="stringliteral">"region_growing_with_custom_classes example started"</span></div><div class="line">  &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Define a range of objects, where the first two objects form</span></div><div class="line">  <span class="comment">// the first region, while the third object forms the second region.</span></div><div class="line">  <span class="comment">// Note that Objects is a random access container here, however the</span></div><div class="line">  <span class="comment">// same algorithm/example can work with other containers, e.g. std::list.</span></div><div class="line">  Objects objects;</div><div class="line"></div><div class="line">  <span class="comment">// Region 1.</span></div><div class="line">  Object object1;</div><div class="line">  object1.neighbors.resize(1, 1);</div><div class="line">  objects.push_back(object1);</div><div class="line"></div><div class="line">  Object object2;</div><div class="line">  object2.neighbors.resize(1, 0);</div><div class="line">  objects.push_back(object2);</div><div class="line"></div><div class="line">  <span class="comment">// Region 2.</span></div><div class="line">  Object object3;</div><div class="line">  objects.push_back(object3);</div><div class="line"></div><div class="line">  <span class="comment">// Extra object to skip.</span></div><div class="line">  Object object4;</div><div class="line">  objects.push_back(object4);</div><div class="line"></div><div class="line">  <span class="comment">// Create instances of the classes Neighbor_query and Region_type.</span></div><div class="line">  Neighbor_query neighbor_query = Neighbor_query(objects);</div><div class="line">  Region_type    region_type    = Region_type();</div><div class="line"></div><div class="line">  <span class="comment">// Create a seed map.</span></div><div class="line">  std::map&lt;std::size_t, std::size_t&gt; objects_map;</div><div class="line">  objects_map[0] = 1; <span class="comment">// the order is swapped with the next object</span></div><div class="line">  objects_map[1] = 0;</div><div class="line">  objects_map[2] = 2; <span class="comment">// the default order</span></div><div class="line">  objects_map[3] = std::size_t(-1); <span class="comment">// skip this object</span></div><div class="line">  <span class="keyword">const</span> Seed_map seed_map(objects_map);</div><div class="line"></div><div class="line">  <span class="comment">// Create an instance of the region growing class.</span></div><div class="line">  Region_growing region_growing(</div><div class="line">    objects, neighbor_query, region_type, seed_map);</div><div class="line"></div><div class="line">  <span class="comment">// Run the algorithm.</span></div><div class="line">  Regions regions;</div><div class="line">  region_growing.detect(std::back_inserter(regions));</div><div class="line"></div><div class="line">  <span class="comment">// Print the number of found regions. It must be two regions.</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* "</span> &lt;&lt; regions.size() &lt;&lt;</div><div class="line">    <span class="stringliteral">" regions have been found among "</span> &lt;&lt; objects.size() &lt;&lt;  <span class="stringliteral">" objects"</span></div><div class="line">  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; std::endl &lt;&lt;</div><div class="line">    <span class="stringliteral">"region_growing_with_custom_classes example finished"</span></div><div class="line">  &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Shape_detection_RegionGrowingPoints"></a>
Point Set</h2>
<p>If one wants to detect lines (see <a class="el" href="index.html#Shape_detection_RegionGrowingPoints_examples">2D Example</a>)</p>
<p><a class="anchor" id="fig__Region_growing_on_point_set_2"></a></p><div class="image">
<img src="region_growing_on_point_set_2.png" alt="region_growing_on_point_set_2.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Region_growing_on_point_set_2">Figure 82.6</a> A 2D point set depicted with one color per detected line.  </div> <br /> 
<p>or planes (see <a class="el" href="index.html#Shape_detection_RegionGrowingPoints_examples">3D Example</a>)</p>
<p><a class="anchor" id="fig__Region_growing_on_point_set_3"></a></p><div class="image">
<img src="region_growing_on_point_set_3.png" alt="region_growing_on_point_set_3.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Region_growing_on_point_set_3">Figure 82.7</a> A 3D point set depicted with one color per detected plane.  </div> <br /> 
<p>in a 2D or 3D point set respectively, this CGAL component provides the corresponding models of the concepts <a class="el" href="index.html#Shape_detection_RegionGrowingFramework_connectivity">NeighborQuery</a> and <a class="el" href="index.html#Shape_detection_RegionGrowingFramework_conditions">RegionType</a>. In particular, it provides two different ways to define neighbors of a point:</p>
<ul>
<li>Fuzzy sphere neighbors search via <code><a class="el" href="classCGAL_1_1Shape__detection_1_1Point__set_1_1Sphere__neighbor__query.html" title="Fuzzy sphere neighbors search in a set of Kernel::Point_2 or Kernel::Point_3. ">CGAL::Shape_detection::Point_set::Sphere_neighbor_query</a></code>. This class creates a circle (in 2D case) or a sphere (in 3D case) centered at the query point with a user-specified sphere radius. All points, which belong to the sphere, will be treated as neighbors of the query point;</li>
<li>Nearest neighbors search via <code><a class="el" href="classCGAL_1_1Shape__detection_1_1Point__set_1_1K__neighbor__query.html" title="K nearest neighbors search in a set of Kernel::Point_2 or Kernel::Point_3. ">CGAL::Shape_detection::Point_set::K_neighbor_query</a></code>. This class finds K (specified by the user) nearest neighbors of the query point either 2D or 3D.</li>
</ul>
<p>The component also provides</p>
<ul>
<li><code><a class="el" href="classCGAL_1_1Shape__detection_1_1Point__set_1_1Least__squares__line__fit__region.html" title="Region type based on the quality of the least squares line fit applied to 2D points. ">CGAL::Shape_detection::Point_set::Least_squares_line_fit_region</a></code> - least squares line fit type of region for 2D points</li>
<li><code><a class="el" href="classCGAL_1_1Shape__detection_1_1Point__set_1_1Least__squares__circle__fit__region.html" title="Region type based on the quality of the least squares circle fit applied to 2D points. ">CGAL::Shape_detection::Point_set::Least_squares_circle_fit_region</a></code> - least squares circle fit type of region for 2D points</li>
<li><code><a class="el" href="classCGAL_1_1Shape__detection_1_1Point__set_1_1Least__squares__plane__fit__region.html" title="Region type based on the quality of the least squares plane fit applied to 3D points. ">CGAL::Shape_detection::Point_set::Least_squares_plane_fit_region</a></code> - least squares plane fit type of region for 3D points</li>
<li><code><a class="el" href="classCGAL_1_1Shape__detection_1_1Point__set_1_1Least__squares__sphere__fit__region.html" title="Region type based on the quality of the least squares sphere fit applied to 3D points. ">CGAL::Shape_detection::Point_set::Least_squares_sphere_fit_region</a></code> - least squares sphere fit type of region for 3D points</li>
<li><code><a class="el" href="classCGAL_1_1Shape__detection_1_1Point__set_1_1Least__squares__cylinder__fit__region.html" title="Region type based on the quality of the least squares cylinder fit applied to 3D points. ">CGAL::Shape_detection::Point_set::Least_squares_cylinder_fit_region</a></code> - least squares cylinder fit type of region for 3D points</li>
</ul>
<p>The program associates all points from a region to the best-fit object (2D line, 2D circle, 3D plane, 3D sphere, etc.) and controls the quality of this fit.</p>
<p>The quality of region growing in a point set (2D or 3D) can be improved by slightly sacrificing the running time. To achieve this, one can sort indices of input points with respect to some quality criteria. These quality criteria can be included through the <a class="el" href="index.html#Shape_detection_RegionGrowingFramework_seeding">SeedMap</a> input parameter. We provide a quality sorting both for 2D and 3D points:</p>
<ul>
<li><code><a class="el" href="classCGAL_1_1Shape__detection_1_1Point__set_1_1Least__squares__line__fit__sorting.html" title="Sorting of 2D points with respect to the local line fit quality. ">CGAL::Shape_detection::Point_set::Least_squares_line_fit_sorting</a></code> - indices of 2D input points are sorted with respect to the quality of the least squares line fit applied to the neighbors of each point;</li>
<li><code><a class="el" href="classCGAL_1_1Shape__detection_1_1Point__set_1_1Least__squares__circle__fit__sorting.html" title="Sorting of 2D points with respect to the local circle fit quality. ">CGAL::Shape_detection::Point_set::Least_squares_circle_fit_sorting</a></code> - indices of 2D input points are sorted with respect to the quality of the least squares circle fit applied to the neighbors of each point;</li>
<li><code><a class="el" href="classCGAL_1_1Shape__detection_1_1Point__set_1_1Least__squares__plane__fit__sorting.html" title="Sorting of 3D points with respect to the local plane fit quality. ">CGAL::Shape_detection::Point_set::Least_squares_plane_fit_sorting</a></code> - indices of 3D input points are sorted with respect to the quality of the least squares plane fit applied to the neighbors of each point.</li>
<li><code><a class="el" href="classCGAL_1_1Shape__detection_1_1Point__set_1_1Least__squares__sphere__fit__sorting.html" title="Sorting of 3D points with respect to the local sphere fit quality. ">CGAL::Shape_detection::Point_set::Least_squares_sphere_fit_sorting</a></code> - indices of 3D input points are sorted with respect to the quality of the least squares sphere fit applied to the neighbors of each point.</li>
<li><code><a class="el" href="classCGAL_1_1Shape__detection_1_1Point__set_1_1Least__squares__cylinder__fit__sorting.html" title="Sorting of 3D points with respect to the local cylinder fit quality. ">CGAL::Shape_detection::Point_set::Least_squares_cylinder_fit_sorting</a></code> - indices of 3D input points are sorted with respect to the quality of the least squares cylinder fit applied to the neighbors of each point.</li>
</ul>
<h3><a class="anchor" id="Shape_detection_RegionGrowingPoints_parameters"></a>
Parameters</h3>
<p>The classes in Section <a class="el" href="index.html#Shape_detection_RegionGrowingPoints">Region Growing On Point Set</a> depend on a few parameters that should be defined by the user. They also have default values, but these values do not necessarily guarantee to produce pleasant results.</p>
<p>The <code><a class="el" href="classNeighborQuery.html" title="A concept that describes the set of methods used by the CGAL::Shape_detection::Region_growing to acce...">NeighborQuery</a></code> related classes depend on the following parameters:</p>
<ul>
<li><code>sphere_radius</code> is used by the class <code><a class="el" href="classCGAL_1_1Shape__detection_1_1Point__set_1_1Sphere__neighbor__query.html" title="Fuzzy sphere neighbors search in a set of Kernel::Point_2 or Kernel::Point_3. ">CGAL::Shape_detection::Point_set::Sphere_neighbor_query</a></code> and defines the radius of the fuzzy search sphere centered at the query point;</li>
<li><code>k</code> is used by the class <code><a class="el" href="classCGAL_1_1Shape__detection_1_1Point__set_1_1K__neighbor__query.html" title="K nearest neighbors search in a set of Kernel::Point_2 or Kernel::Point_3. ">CGAL::Shape_detection::Point_set::K_neighbor_query</a></code> and defines the number K of nearest neighbors of the query point.</li>
</ul>
<p>The right choice of <code>sphere_radius</code> or <code>k</code> parameters plays an important role in producing a good result. For example, if we consider the fuzzy sphere neighborhood, when <code>sphere_radius</code> is too large, we have fewer regions, and the details are not clearly separated. Meanwhile, if <code>sphere_radius</code> is too small, we produce more regions, and the point set may be over-segmented. Consider a 2D map of an intersection of streets in a city as in Figure <a class="el" href="index.html#fig__Region_growing_parameter_sphere_radius_variation">Figure 82.8</a>. Each region is painted with a unique color. As <code>sphere_radius</code> increases, the details become less clear. When <code>sphere_radius</code> = 0.3 (c), the best visual result is produced.</p>
<p><a class="anchor" id="fig__Region_growing_parameter_sphere_radius_variation"></a></p><div class="image">
<img src="sphere_radius_parameter_2D.png" alt="sphere_radius_parameter_2D.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Region_growing_parameter_sphere_radius_variation">Figure 82.8</a> (a) Input 2D point set; (b) 17 regions are found when <code>sphere_radius</code> = 0.1; (c) 8 regions are found when <code>sphere_radius</code> = 0.3; (d) 4 regions are found when <code>sphere_radius</code> = 1.2.  </div> <br /> 
<p>The <code><a class="el" href="classRegionType.html" title="A concept that describes the set of methods used by the CGAL::Shape_detection::Region_growing to main...">RegionType</a></code> related classes depend on the following parameters:</p>
<ul>
<li><code>distance_threshold</code> - the maximum distance from a point to a line/plane;</li>
<li><code>angle_threshold</code> - the maximum accepted angle between the normal associated with a point and the normal of a line/plane;</li>
<li><code>min_region_size</code> - the minimum number of points a region must have.</li>
</ul>
<p>The first two parameters are used by the functions <code><a class="el" href="classRegionType.html#abf9f02613b07bce21e53f2d175532eae" title="checks if the item with the index index_to, which is a neighbor of the item with the index index_from...">RegionType::is_part_of_region()</a></code> and <code><a class="el" href="classRegionType.html#a3a11858e85d9c5f7354b6ffec4f653ff" title="enables to update any information that is maintained with the region represented by indices...">RegionType::update()</a></code>, while the third parameter is used by the function <code><a class="el" href="classRegionType.html#abb5a96a01ed18ea325abf58ad726f6e5" title="checks if the region represented by indices satisfies all necessary conditions. ">RegionType::is_valid_region()</a></code> explained in Section <a class="el" href="index.html#Shape_detection_RegionGrowingFramework_conditions">Framework Region Type</a>.</p>
<p>The right choice of <code>distance_threshold</code> and <code>angle_threshold</code> parameters is also very important. For example, Figure <a class="el" href="index.html#fig__Region_growing_parameter_angle_threshold_variation">Figure 82.9</a> shows that the roof top of the house can be distinguished as two planes (painted in blue and dark red) when <code>angle_threshold</code> is strict enough (c), or it can be recognized as only one plane (painted in pale yellow) in the other case (b).</p>
<p><a class="anchor" id="fig__Region_growing_parameter_angle_threshold_variation"></a></p><div class="image">
<img src="angle_threshold_parameter_3D.png" alt="angle_threshold_parameter_3D.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Region_growing_parameter_angle_threshold_variation">Figure 82.9</a> (a) Input 3D point cloud; (b) Result when <code>angle_threshold</code> = 60 degrees; (c) Result when <code>angle_threshold</code> = 25 degrees.  </div> <br /> 
<h3><a class="anchor" id="Shape_detection_RegionGrowingPoints_examples"></a>
Examples</h3>
<h4><a class="anchor" id="Shape_detection_RegionGrowingPoints_example_2D_lines"></a>
Detecting 2D Lines</h4>
<p>Typical usage of the Region Growing component consists of five steps:</p>
<ol type="1">
<li>Define an input range with points;</li>
<li>Create instances of the classes <code><a class="el" href="classNeighborQuery.html" title="A concept that describes the set of methods used by the CGAL::Shape_detection::Region_growing to acce...">NeighborQuery</a></code> and <code><a class="el" href="classRegionType.html" title="A concept that describes the set of methods used by the CGAL::Shape_detection::Region_growing to main...">RegionType</a></code> with the proper parameters;</li>
<li>Create an instance of the class <code><a class="el" href="classCGAL_1_1Shape__detection_1_1Region__growing.html" title="Main class/entry point for running the region growing algorithm. ">CGAL::Shape_detection::Region_growing</a></code>;</li>
<li>Detect;</li>
<li>Postprocess.</li>
</ol>
<p>Given a 2D point set, we detect 2D lines using the fuzzy sphere neighborhood. We then color all points from the found regions and save them in a file (see Figure <a class="el" href="index.html#fig__Region_growing_on_point_set_2">Figure 82.6</a>).</p>
<p>The points with assigned to them normal vectors are stored in <code>std::vector</code> and the used <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a></code> is <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian</a></code>, where the number type is <code>double</code>.</p>
<p><br />
<b>File</b> <a class="el" href="Shape_detection_2region_growing_lines_on_point_set_2_8cpp-example.html">Shape_detection/region_growing_lines_on_point_set_2.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// CGAL includes.</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/array.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_ply_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Shape_detection/Region_growing/Region_growing.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Shape_detection/Region_growing/Region_growing_on_point_set.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// STL includes.</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iterator&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Type declarations.</span></div><div class="line"><span class="keyword">using</span> Kernel = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> FT       = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"><span class="keyword">using</span> Point_2  = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>;</div><div class="line"><span class="keyword">using</span> Point_3  = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ae82b7f4be77dd5b8819ebe419e4ae753">Kernel::Point_3</a>;</div><div class="line"><span class="keyword">using</span> Vector_2 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ac99a26c147a66317cc6afcaf27b091e2">Kernel::Vector_2</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Point_with_normal = std::pair&lt;Point_2, Vector_2&gt;;</div><div class="line"><span class="keyword">using</span> Input_range       = std::vector&lt;Point_with_normal&gt;;</div><div class="line"><span class="keyword">using</span> Point_map         = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Point_with_normal&gt;</a>;</div><div class="line"><span class="keyword">using</span> Normal_map        = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;Point_with_normal&gt;</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Neighbor_query = <a class="code" href="classCGAL_1_1Shape__detection_1_1Point__set_1_1Sphere__neighbor__query.html">CGAL::Shape_detection::Point_set::Sphere_neighbor_query&lt;Kernel, Input_range, Point_map&gt;</a>;</div><div class="line"><span class="keyword">using</span> Region_type    = <a class="code" href="classCGAL_1_1Shape__detection_1_1Point__set_1_1Least__squares__line__fit__region.html">CGAL::Shape_detection::Point_set::Least_squares_line_fit_region&lt;Kernel, Input_range, Point_map, Normal_map&gt;</a>;</div><div class="line"><span class="keyword">using</span> Region_growing = <a class="code" href="classCGAL_1_1Shape__detection_1_1Region__growing.html">CGAL::Shape_detection::Region_growing&lt;Input_range, Neighbor_query, Region_type&gt;</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Region  = std::vector&lt;std::size_t&gt;;</div><div class="line"><span class="keyword">using</span> Regions = std::vector&lt;Region&gt;;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Color            = std::array&lt;unsigned char, 3&gt;;</div><div class="line"><span class="keyword">using</span> Point_with_color = std::pair&lt;Point_3, Color&gt;;</div><div class="line"><span class="keyword">using</span> Pwc_vector       = std::vector&lt;Point_with_color&gt;;</div><div class="line"><span class="keyword">using</span> PLY_Point_map    = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Point_with_color&gt;</a>;</div><div class="line"><span class="keyword">using</span> PLY_Color_map    = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;Point_with_color&gt;</a>;</div><div class="line"></div><div class="line"><span class="comment">// Define how a color should be stored.</span></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceCGAL.html">CGAL</a> {</div><div class="line"></div><div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt;</div><div class="line">  <span class="keyword">struct </span>Output_rep&lt; ::Color, F &gt; {</div><div class="line"></div><div class="line">    const ::Color&amp; c;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_specialized = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1Output__rep.html#a3ecfc0ce6d2e5db55ad05d08c549ce27">Output_rep</a>(const ::Color&amp; c) : c(c) { }</div><div class="line"></div><div class="line">    std::ostream&amp; <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1Output__rep.html#a022b1af6b20bcd6957908d70b3c9136b">operator()</a>(std::ostream&amp; out)<span class="keyword"> const </span>{</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#gaf145cf5cbf5e27ebb907a8260002a5f3">IO::is_ascii</a>(out))</div><div class="line">        out &lt;&lt; int(c[0]) &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; int(c[1]) &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; int(c[2]);</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        out.write(reinterpret_cast&lt;const char*&gt;(&amp;c), <span class="keyword">sizeof</span>(c));</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> out;</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line">} <span class="comment">// namespace CGAL</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div><div class="line"></div><div class="line">  std::cout &lt;&lt; std::endl &lt;&lt;</div><div class="line">    <span class="stringliteral">"region_growing_on_point_set_2 example started"</span></div><div class="line">  &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cout &lt;&lt;</div><div class="line">    <span class="stringliteral">"Note: if 0 points are loaded, please specify the path to the file data/point_set_2.xyz by hand!"</span></div><div class="line">  &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Load xyz data either from a local folder or a user-provided file.</span></div><div class="line">  std::ifstream in(argc &gt; 1 ? argv[1] : CGAL::data_file_path(<span class="stringliteral">"points_3/point_set_2.xyz"</span>));</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7d51c854b865a7eb367e21fc43bd37b8">CGAL::IO::set_ascii_mode</a>(in);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (!in) {</div><div class="line">    std::cout &lt;&lt;</div><div class="line">    <span class="stringliteral">"Error: cannot read the file point_set_2.xyz!"</span> &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt;</div><div class="line">    <span class="stringliteral">"You can either create a symlink to the data folder or provide this file by hand."</span></div><div class="line">    &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  Input_range input_range;</div><div class="line">  FT a, b, c, d, e, f;</div><div class="line"></div><div class="line">  <span class="keywordflow">while</span> (in &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e &gt;&gt; f)</div><div class="line">    input_range.push_back(</div><div class="line">      std::make_pair(Point_2(a, b), Vector_2(d, e)));</div><div class="line"></div><div class="line">  in.close();</div><div class="line">  std::cout &lt;&lt;</div><div class="line">    <span class="stringliteral">"* loaded "</span></div><div class="line">  &lt;&lt; input_range.size() &lt;&lt;</div><div class="line">    <span class="stringliteral">" points with normals"</span></div><div class="line">  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Default parameter values for the data file point_set_2.xyz.</span></div><div class="line">  <span class="keyword">const</span> FT          search_sphere_radius = FT(5);</div><div class="line">  <span class="keyword">const</span> FT          max_distance_to_line = FT(45) / FT(10);</div><div class="line">  <span class="keyword">const</span> FT          max_accepted_angle   = FT(45);</div><div class="line">  <span class="keyword">const</span> std::size_t min_region_size      = 5;</div><div class="line"></div><div class="line">  <span class="comment">// Create instances of the classes Neighbor_query and Region_type.</span></div><div class="line">  Neighbor_query neighbor_query(</div><div class="line">    input_range,</div><div class="line">    search_sphere_radius);</div><div class="line"></div><div class="line">  Region_type region_type(</div><div class="line">    input_range,</div><div class="line">    max_distance_to_line, max_accepted_angle, min_region_size);</div><div class="line"></div><div class="line">  <span class="comment">// Create an instance of the region growing class.</span></div><div class="line">  Region_growing region_growing(</div><div class="line">    input_range, neighbor_query, region_type);</div><div class="line"></div><div class="line">  <span class="comment">// Run the algorithm.</span></div><div class="line">  Regions regions;</div><div class="line">  region_growing.detect(std::back_inserter(regions));</div><div class="line"></div><div class="line">  <span class="comment">// Print the number of found regions.</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* "</span> &lt;&lt; regions.size() &lt;&lt;</div><div class="line">    <span class="stringliteral">" regions have been found"</span></div><div class="line">  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  Pwc_vector pwc;</div><div class="line">  srand(static_cast&lt;unsigned int&gt;(time(<span class="keyword">nullptr</span>)));</div><div class="line"></div><div class="line">  <span class="comment">// Iterate through all regions.</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; region : regions) {</div><div class="line"></div><div class="line">    <span class="comment">// Generate a random color.</span></div><div class="line">    <span class="keyword">const</span> Color color =</div><div class="line">      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__PkgSTLExtensionRef.html#ga6b9a3534a37aeb7d3095ec08801931d7">CGAL::make_array</a>(</div><div class="line">        static_cast&lt;unsigned char&gt;(rand() % 256),</div><div class="line">        static_cast&lt;unsigned char&gt;(rand() % 256),</div><div class="line">        static_cast&lt;unsigned char&gt;(rand() % 256));</div><div class="line"></div><div class="line">    <span class="comment">// Iterate through all region items.</span></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> index : region) {</div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span>&amp; key = *(input_range.begin() + index);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> Point_2&amp; point = <span class="keyword">get</span>(Point_map(), key);</div><div class="line">      pwc.push_back(std::make_pair(Point_3(point.x(), point.y(), 0), color));</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Save the result to a file in the user-provided path if any.</span></div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 2) {</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string path     = argv[2];</div><div class="line">    <span class="keyword">const</span> std::string fullpath = path + <span class="stringliteral">"regions_point_set_2.ply"</span>;</div><div class="line"></div><div class="line">    std::ofstream out(fullpath);</div><div class="line"></div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7d51c854b865a7eb367e21fc43bd37b8">CGAL::IO::set_ascii_mode</a>(out);</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3IOPly.html#gac1fd90a9d5266e631c68cb31bfe31516">CGAL::IO::write_PLY_with_properties</a>(</div><div class="line">      out, pwc,</div><div class="line">      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3IOPly.html#ga241c6df9d93e26ec7254ef6366cb7e5b">CGAL::make_ply_point_writer</a>(PLY_Point_map()),</div><div class="line">        std::make_tuple(</div><div class="line">          PLY_Color_map(),</div><div class="line">          CGAL::PLY_property&lt;unsigned char&gt;(<span class="stringliteral">"red"</span>),</div><div class="line">          CGAL::PLY_property&lt;unsigned char&gt;(<span class="stringliteral">"green"</span>),</div><div class="line">          CGAL::PLY_property&lt;unsigned char&gt;(<span class="stringliteral">"blue"</span>)));</div><div class="line"></div><div class="line">    std::cout &lt;&lt;</div><div class="line">      <span class="stringliteral">"* found regions are saved in "</span></div><div class="line">    &lt;&lt; fullpath &lt;&lt; std::endl;</div><div class="line">    out.close();</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; std::endl &lt;&lt;</div><div class="line">    <span class="stringliteral">"region_growing_on_point_set_2 example finished"</span></div><div class="line">  &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h4><a class="anchor" id="Shape_detection_RegionGrowingPoints_example_2D_circles"></a>
Detecting 2D Circles</h4>
<p>The following example shows a similar example, this time detecting circles instead of lines. In that case, we also preprocess points so that they are sorted according to their likelihood of belonging to a circle:</p>
<p><br />
<b>File</b> <a class="el" href="Shape_detection_2region_growing_circles_on_point_set_2_8cpp-example.html">Shape_detection/region_growing_circles_on_point_set_2.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Random.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3/IO.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Shape_detection/Region_growing/Region_growing.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Shape_detection/Region_growing/Region_growing_on_point_set.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/iterator/function_output_iterator.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> Kernel = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> Point_3 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ae82b7f4be77dd5b8819ebe419e4ae753">Kernel::Point_3</a>;</div><div class="line"><span class="keyword">using</span> Vector_3 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a39fb0222695ae5e7e32f4e570ea28225">Kernel::Vector_3</a>;</div><div class="line"><span class="keyword">using</span> Point_2 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>;</div><div class="line"><span class="keyword">using</span> Vector_2 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ac99a26c147a66317cc6afcaf27b091e2">Kernel::Vector_2</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Point_set_3 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3&lt;Point_3, Vector_3&gt;</a>;</div><div class="line"><span class="keyword">using</span> Point_set_2 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3&lt;Point_2, Vector_2&gt;</a>;</div><div class="line"><span class="keyword">using</span> Point_map = Point_set_2::Point_map;</div><div class="line"><span class="keyword">using</span> Normal_map = Point_set_2::Vector_map;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Shape_detection = <a class="code" href="namespaceCGAL_1_1Shape__detection_1_1Point__set.html">CGAL::Shape_detection::Point_set</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Neighbor_query = Shape_detection::K_neighbor_query</div><div class="line">  &lt;Kernel, Point_set_2, Point_map&gt;;</div><div class="line"><span class="keyword">using</span> Region_type = Shape_detection::Least_squares_circle_fit_region</div><div class="line">  &lt;Kernel, Point_set_2, Point_map, Normal_map&gt;;</div><div class="line"><span class="keyword">using</span> Sorting = Shape_detection::Least_squares_circle_fit_sorting</div><div class="line">  &lt;Kernel, Point_set_2, Neighbor_query, Point_map&gt;;</div><div class="line"><span class="keyword">using</span> Region_growing = <a class="code" href="classCGAL_1_1Shape__detection_1_1Region__growing.html">CGAL::Shape_detection::Region_growing</a></div><div class="line">  &lt;Point_set_2, Neighbor_query, Region_type, <span class="keyword">typename</span> Sorting::Seed_map&gt;;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::ifstream ifile (argc &gt; 1 ? argv[1] : CGAL::data_file_path(<span class="stringliteral">"points_3/circles.ply"</span>));</div><div class="line">  Point_set_3 points3;</div><div class="line">  ifile &gt;&gt; points3;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; points3.size() &lt;&lt; <span class="stringliteral">" points read"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Input should have normals</span></div><div class="line">  assert (points3.has_normal_map());</div><div class="line"></div><div class="line">  Point_set_2 points;</div><div class="line">  points.add_normal_map();</div><div class="line">  <span class="keywordflow">for</span> (Point_set_3::Index idx : points3)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> Point_3&amp; p = points3.point(idx);</div><div class="line">    <span class="keyword">const</span> Vector_3&amp; n = points3.normal(idx);</div><div class="line">    points.insert (Point_2 (p.x(), p.y()), Vector_2 (n.x(), n.y()));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Default parameters for data/circles.ply</span></div><div class="line">  <span class="keyword">const</span> std::size_t k = 12;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> tolerance = 0.01;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> max_angle = 10.;</div><div class="line">  <span class="keyword">const</span> std::size_t min_region_size = 20;</div><div class="line"></div><div class="line">  <span class="comment">// No constraint on radius</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> min_radius = 0.;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> max_radius = std::numeric_limits&lt;double&gt;::infinity();</div><div class="line"></div><div class="line">  Neighbor_query neighbor_query(points, k, points.point_map());</div><div class="line">  Region_type region_type(points, tolerance, max_angle, min_region_size,</div><div class="line">                          min_radius, max_radius,</div><div class="line">                          points.point_map(), points.normal_map());</div><div class="line"></div><div class="line">  <span class="comment">// Sort indices</span></div><div class="line">  Sorting sorting(points, neighbor_query, points.point_map());</div><div class="line">  sorting.sort();</div><div class="line"></div><div class="line">  Region_growing region_growing(points, neighbor_query, region_type, sorting.seed_map());</div><div class="line"></div><div class="line">  <span class="comment">// Add maps to get colored output</span></div><div class="line">  Point_set_3::Property_map&lt;unsigned char&gt;</div><div class="line">    red = points3.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"red"</span>, 0).first,</div><div class="line">    green = points3.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"green"</span>, 0).first,</div><div class="line">    blue = points3.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"blue"</span>, 0).first;</div><div class="line"></div><div class="line">  CGAL::Random random;</div><div class="line"></div><div class="line">  std::size_t nb_circles = 0;</div><div class="line">  CGAL::Real_timer timer;</div><div class="line">  timer.start();</div><div class="line">  region_growing.detect</div><div class="line">    (boost::make_function_output_iterator</div><div class="line">     ([&amp;](<span class="keyword">const</span> std::vector&lt;std::size_t&gt;&amp; region)</div><div class="line">      {</div><div class="line">        <span class="comment">// Assign a random color to each region</span></div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> r = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(random.get_int(64, 192));</div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> g = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(random.get_int(64, 192));</div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> b = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(random.get_int(64, 192));</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> std::size_t&amp; idx : region)</div><div class="line">        {</div><div class="line">          red[idx] = r;</div><div class="line">          green[idx] = g;</div><div class="line">          blue[idx] = b;</div><div class="line">        }</div><div class="line">        ++ nb_circles;</div><div class="line">      }));</div><div class="line">  timer.stop();</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; nb_circles &lt;&lt; <span class="stringliteral">" circles detected in "</span></div><div class="line">            &lt;&lt; timer.time() &lt;&lt; <span class="stringliteral">" seconds"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save in colored_circles.ply</span></div><div class="line">  std::ofstream out (<span class="stringliteral">"colored_circles.ply"</span>);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (out);</div><div class="line">  out &lt;&lt; points3;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h4><a class="anchor" id="Shape_detection_RegionGrowingPoints_example_3D_planes"></a>
Detecting 3D Planes</h4>
<p>If we are given a 3D point set, then the example below shows how to detect 3D planes using the K nearest neighbors search. We color all points from the found regions and save them in a file (see Figure <a class="el" href="index.html#fig__Region_growing_on_point_set_3">Figure 82.7</a>). The example also shows how to retrieve all points, which are not assigned to any region, and how to use a custom output iterator.</p>
<p>The point set with associated normals is stored in <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3</a></code> and the used <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a></code> is <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a></code>.</p>
<p><br />
<b>File</b> <a class="el" href="Shape_detection_2region_growing_planes_on_point_set_3_8cpp-example.html">Shape_detection/region_growing_planes_on_point_set_3.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// STL includes.</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iterator&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Boost includes.</span></div><div class="line"><span class="preprocessor">#include &lt;boost/iterator/function_output_iterator.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// CGAL includes.</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Timer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Random.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3/IO.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Shape_detection/Region_growing/Region_growing.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Shape_detection/Region_growing/Region_growing_on_point_set.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Type declarations.</span></div><div class="line"><span class="keyword">using</span> Kernel = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> FT       = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"><span class="keyword">using</span> Point_3  = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ae82b7f4be77dd5b8819ebe419e4ae753">Kernel::Point_3</a>;</div><div class="line"><span class="keyword">using</span> Vector_3 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a39fb0222695ae5e7e32f4e570ea28225">Kernel::Vector_3</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Input_range = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3&lt;Point_3&gt;</a>;</div><div class="line"><span class="keyword">using</span> Point_map   = <span class="keyword">typename</span> Input_range::Point_map;</div><div class="line"><span class="keyword">using</span> Normal_map  = <span class="keyword">typename</span> Input_range::Vector_map;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Neighbor_query = <a class="code" href="classCGAL_1_1Shape__detection_1_1Point__set_1_1K__neighbor__query.html">CGAL::Shape_detection::Point_set::K_neighbor_query&lt;Kernel, Input_range, Point_map&gt;</a>;</div><div class="line"><span class="keyword">using</span> Region_type    = <a class="code" href="classCGAL_1_1Shape__detection_1_1Point__set_1_1Least__squares__plane__fit__region.html">CGAL::Shape_detection::Point_set::Least_squares_plane_fit_region&lt;Kernel, Input_range, Point_map, Normal_map&gt;</a>;</div><div class="line"><span class="keyword">using</span> Region_growing = <a class="code" href="classCGAL_1_1Shape__detection_1_1Region__growing.html">CGAL::Shape_detection::Region_growing&lt;Input_range, Neighbor_query, Region_type&gt;</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Indices      = std::vector&lt;std::size_t&gt;;</div><div class="line"><span class="keyword">using</span> Output_range = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3&lt;Point_3&gt;</a>;</div><div class="line"><span class="keyword">using</span> Points_3     = std::vector&lt;Point_3&gt;;</div><div class="line"></div><div class="line"><span class="comment">// Define an insert iterator.</span></div><div class="line"><span class="keyword">struct </span>Insert_point_colored_by_region_index {</div><div class="line"></div><div class="line">  <span class="keyword">using</span> argument_type = Indices;</div><div class="line">  <span class="keyword">using</span> result_type   = void;</div><div class="line"></div><div class="line">  <span class="keyword">using</span> Color_map =</div><div class="line">  <span class="keyword">typename</span> Output_range:: template Property_map&lt;unsigned char&gt;;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> Input_range&amp; m_input_range;</div><div class="line">  <span class="keyword">const</span>   Point_map  m_point_map;</div><div class="line">       Output_range&amp; m_output_range;</div><div class="line">        std::size_t&amp; m_number_of_regions;</div><div class="line"></div><div class="line">  Color_map m_red, m_green, m_blue;</div><div class="line"></div><div class="line">  Insert_point_colored_by_region_index(</div><div class="line">    <span class="keyword">const</span> Input_range&amp; input_range,</div><div class="line">    <span class="keyword">const</span>   Point_map  point_map,</div><div class="line">         Output_range&amp; output_range,</div><div class="line">          std::size_t&amp; number_of_regions) :</div><div class="line">  m_input_range(input_range),</div><div class="line">  m_point_map(point_map),</div><div class="line">  m_output_range(output_range),</div><div class="line">  m_number_of_regions(number_of_regions) {</div><div class="line"></div><div class="line">    m_red =</div><div class="line">    m_output_range.template add_property_map&lt;unsigned char&gt;(<span class="stringliteral">"red"</span>, 0).first;</div><div class="line">    m_green =</div><div class="line">    m_output_range.template add_property_map&lt;unsigned char&gt;(<span class="stringliteral">"green"</span>, 0).first;</div><div class="line">    m_blue =</div><div class="line">    m_output_range.template add_property_map&lt;unsigned char&gt;(<span class="stringliteral">"blue"</span>, 0).first;</div><div class="line">  }</div><div class="line"></div><div class="line">  result_type operator()(<span class="keyword">const</span> argument_type&amp; region) {</div><div class="line"></div><div class="line">    CGAL::Random rand(static_cast&lt;unsigned int&gt;(m_number_of_regions));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> r =</div><div class="line">    <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(64 + rand.get_int(0, 192));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> g =</div><div class="line">    <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(64 + rand.get_int(0, 192));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> b =</div><div class="line">    <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(64 + rand.get_int(0, 192));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> std::size_t index : region) {</div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span>&amp; key = *(m_input_range.begin() + index);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> Point_3&amp; point = <span class="keyword">get</span>(m_point_map, key);</div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> it = m_output_range.insert(point);</div><div class="line"></div><div class="line">      m_red[*it]   = r;</div><div class="line">      m_green[*it] = g;</div><div class="line">      m_blue[*it]  = b;</div><div class="line">    }</div><div class="line">    ++m_number_of_regions;</div><div class="line">  }</div><div class="line">}; <span class="comment">// Insert_point_colored_by_region_index</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div><div class="line"></div><div class="line">  std::cout &lt;&lt; std::endl &lt;&lt;</div><div class="line">    <span class="stringliteral">"region_growing_on_point_set_3 example started"</span></div><div class="line">  &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cout &lt;&lt;</div><div class="line">    <span class="stringliteral">"Note: if 0 points are loaded, please specify the path to the file data/point_set_3.xyz by hand!"</span></div><div class="line">  &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Load xyz data either from a local folder or a user-provided file.</span></div><div class="line">  std::ifstream in(argc &gt; 1 ? argv[1] : CGAL::data_file_path(<span class="stringliteral">"points_3/point_set_3.xyz"</span>));</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7d51c854b865a7eb367e21fc43bd37b8">CGAL::IO::set_ascii_mode</a>(in);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (!in) {</div><div class="line">    std::cout &lt;&lt;</div><div class="line">    <span class="stringliteral">"Error: cannot read the file point_set_3.xyz!"</span> &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt;</div><div class="line">    <span class="stringliteral">"You can either create a symlink to the data folder or provide this file by hand."</span></div><div class="line">    &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span> with_normal_map = <span class="keyword">true</span>;</div><div class="line">  Input_range input_range(with_normal_map);</div><div class="line"></div><div class="line">  in &gt;&gt; input_range;</div><div class="line">  in.close();</div><div class="line"></div><div class="line">  std::cout &lt;&lt;</div><div class="line">    <span class="stringliteral">"* loaded "</span></div><div class="line">  &lt;&lt; input_range.size() &lt;&lt;</div><div class="line">    <span class="stringliteral">" points with normals"</span></div><div class="line">  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Default parameter values for the data file point_set_3.xyz.</span></div><div class="line">  <span class="keyword">const</span> std::size_t k                     = 12;</div><div class="line">  <span class="keyword">const</span> FT          max_distance_to_plane = FT(2);</div><div class="line">  <span class="keyword">const</span> FT          max_accepted_angle    = FT(20);</div><div class="line">  <span class="keyword">const</span> std::size_t min_region_size       = 50;</div><div class="line"></div><div class="line">  <span class="comment">// Create instances of the classes Neighbor_query and Region_type.</span></div><div class="line">  Neighbor_query neighbor_query(</div><div class="line">    input_range,</div><div class="line">    k,</div><div class="line">    input_range.point_map());</div><div class="line"></div><div class="line">  Region_type region_type(</div><div class="line">    input_range,</div><div class="line">    max_distance_to_plane, max_accepted_angle, min_region_size,</div><div class="line">    input_range.point_map(), input_range.normal_map());</div><div class="line"></div><div class="line">  <span class="comment">// Create an instance of the region growing class.</span></div><div class="line">  Region_growing region_growing(</div><div class="line">    input_range, neighbor_query, region_type);</div><div class="line"></div><div class="line">  <span class="comment">// Run the algorithm.</span></div><div class="line">  Output_range output_range;</div><div class="line">  std::size_t number_of_regions = 0;</div><div class="line"></div><div class="line">  Insert_point_colored_by_region_index inserter(</div><div class="line">     input_range, input_range.point_map(),</div><div class="line">    output_range, number_of_regions);</div><div class="line"></div><div class="line">  CGAL::Timer timer;</div><div class="line"></div><div class="line">  timer.start();</div><div class="line">  region_growing.detect(</div><div class="line">    boost::make_function_output_iterator(inserter));</div><div class="line">  timer.stop();</div><div class="line"></div><div class="line">  <span class="comment">// Print the number of found regions.</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* "</span> &lt;&lt; number_of_regions &lt;&lt;</div><div class="line">    <span class="stringliteral">" regions have been found in "</span> &lt;&lt; timer.time() &lt;&lt; <span class="stringliteral">" seconds"</span></div><div class="line">  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save the result to a file in the user-provided path if any.</span></div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 2) {</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string path     = argv[2];</div><div class="line">    <span class="keyword">const</span> std::string fullpath = path + <span class="stringliteral">"regions_point_set_3.ply"</span>;</div><div class="line"></div><div class="line">    std::ofstream out(fullpath);</div><div class="line">    out &lt;&lt; output_range;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"* found regions are saved in "</span> &lt;&lt; fullpath &lt;&lt; std::endl;</div><div class="line">    out.close();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Get all unassigned items.</span></div><div class="line">  Indices unassigned_items;</div><div class="line">  region_growing.unassigned_items(std::back_inserter(unassigned_items));</div><div class="line"></div><div class="line">  <span class="comment">// Print the number of unassigned items.</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* "</span> &lt;&lt; unassigned_items.size() &lt;&lt;</div><div class="line">    <span class="stringliteral">" points do not belong to any region"</span></div><div class="line">  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Store all unassigned points.</span></div><div class="line">  Points_3 unassigned_points;</div><div class="line">  unassigned_points.reserve(unassigned_items.size());</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> index : unassigned_items) {</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; key = *(input_range.begin() + index);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> Point_3&amp; point = <span class="keyword">get</span>(input_range.point_map(), key);</div><div class="line">    unassigned_points.push_back(point);</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* "</span> &lt;&lt; unassigned_points.size() &lt;&lt;</div><div class="line">    <span class="stringliteral">" unassigned points are stored"</span></div><div class="line">  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; std::endl &lt;&lt;</div><div class="line">    <span class="stringliteral">"region_growing_on_point_set_3 example finished"</span></div><div class="line">  &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h4><a class="anchor" id="Shape_detection_RegionGrowingPoints_example_3D_spheres"></a>
Detecting 3D Spheres</h4>
<p>The following example shows a similar example, this time detecting spheres instead of planes.</p>
<p><br />
<b>File</b> <a class="el" href="Shape_detection_2region_growing_spheres_on_point_set_3_8cpp-example.html">Shape_detection/region_growing_spheres_on_point_set_3.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Random.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3/IO.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Shape_detection/Region_growing/Region_growing.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Shape_detection/Region_growing/Region_growing_on_point_set.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/iterator/function_output_iterator.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> Kernel = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> Point_3 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ae82b7f4be77dd5b8819ebe419e4ae753">Kernel::Point_3</a>;</div><div class="line"><span class="keyword">using</span> Vector_3 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a39fb0222695ae5e7e32f4e570ea28225">Kernel::Vector_3</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Point_set = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3&lt;Point_3&gt;</a>;</div><div class="line"><span class="keyword">using</span> Point_map = <span class="keyword">typename</span> Point_set::Point_map;</div><div class="line"><span class="keyword">using</span> Normal_map = <span class="keyword">typename</span> Point_set::Vector_map;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Shape_detection = <a class="code" href="namespaceCGAL_1_1Shape__detection_1_1Point__set.html">CGAL::Shape_detection::Point_set</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Neighbor_query = Shape_detection::K_neighbor_query</div><div class="line">  &lt;Kernel, Point_set, Point_map&gt;;</div><div class="line"><span class="keyword">using</span> Region_type = Shape_detection::Least_squares_sphere_fit_region</div><div class="line">  &lt;Kernel, Point_set, Point_map, Normal_map&gt;;</div><div class="line"><span class="keyword">using</span> Region_growing = <a class="code" href="classCGAL_1_1Shape__detection_1_1Region__growing.html">CGAL::Shape_detection::Region_growing</a></div><div class="line">  &lt;Point_set, Neighbor_query, Region_type&gt;;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::ifstream ifile (argc &gt; 1 ? argv[1] : CGAL::data_file_path(<span class="stringliteral">"points_3/spheres.ply"</span>));</div><div class="line">  Point_set points;</div><div class="line">  ifile &gt;&gt; points;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; points.size() &lt;&lt; <span class="stringliteral">" points read"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Input should have normals</span></div><div class="line">  assert (points.has_normal_map());</div><div class="line"></div><div class="line">  <span class="comment">// Default parameters for data/spheres.ply</span></div><div class="line">  <span class="keyword">const</span> std::size_t k = 12;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> tolerance = 0.01;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> max_angle = 10.;</div><div class="line">  <span class="keyword">const</span> std::size_t min_region_size = 50;</div><div class="line"></div><div class="line">  <span class="comment">// No constraint on radius</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> min_radius = 0.;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> max_radius = std::numeric_limits&lt;double&gt;::infinity();</div><div class="line"></div><div class="line">  Neighbor_query neighbor_query(points, k, points.point_map());</div><div class="line">  Region_type region_type(points, tolerance, max_angle, min_region_size,</div><div class="line">                          min_radius, max_radius,</div><div class="line">                          points.point_map(), points.normal_map());</div><div class="line">  Region_growing region_growing(points, neighbor_query, region_type);</div><div class="line"></div><div class="line">  <span class="comment">// Add maps to get colored output</span></div><div class="line">  Point_set::Property_map&lt;unsigned char&gt;</div><div class="line">    red = points.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"red"</span>, 0).first,</div><div class="line">    green = points.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"green"</span>, 0).first,</div><div class="line">    blue = points.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"blue"</span>, 0).first;</div><div class="line"></div><div class="line">  CGAL::Random random;</div><div class="line"></div><div class="line">  std::size_t nb_spheres = 0;</div><div class="line">  CGAL::Real_timer timer;</div><div class="line">  timer.start();</div><div class="line">  region_growing.detect</div><div class="line">    (boost::make_function_output_iterator</div><div class="line">     ([&amp;](<span class="keyword">const</span> std::vector&lt;std::size_t&gt;&amp; region)</div><div class="line">      {</div><div class="line">        <span class="comment">// Assign a random color to each region</span></div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> r = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(random.get_int(64, 192));</div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> g = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(random.get_int(64, 192));</div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> b = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(random.get_int(64, 192));</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> std::size_t&amp; idx : region)</div><div class="line">        {</div><div class="line">          red[idx] = r;</div><div class="line">          green[idx] = g;</div><div class="line">          blue[idx] = b;</div><div class="line">        }</div><div class="line">        ++ nb_spheres;</div><div class="line">      }));</div><div class="line">  timer.stop();</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; nb_spheres &lt;&lt; <span class="stringliteral">" spheres detected in "</span></div><div class="line">            &lt;&lt; timer.time() &lt;&lt; <span class="stringliteral">" seconds"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save in colored_spheres.ply</span></div><div class="line">  std::ofstream out (<span class="stringliteral">"colored_spheres.ply"</span>);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (out);</div><div class="line">  out &lt;&lt; points;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h4><a class="anchor" id="Shape_detection_RegionGrowingPoints_example_3D_cylinders"></a>
Detecting 3D Cylinders</h4>
<p>The following example shows another similar example, this time detecting (infinite) cylinders.</p>
<p><br />
<b>File</b> <a class="el" href="Shape_detection_2region_growing_cylinders_on_point_set_3_8cpp-example.html">Shape_detection/region_growing_cylinders_on_point_set_3.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Random.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3/IO.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Shape_detection/Region_growing/Region_growing.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Shape_detection/Region_growing/Region_growing_on_point_set.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/iterator/function_output_iterator.hpp&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">using</span> Kernel = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> Point_3 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ae82b7f4be77dd5b8819ebe419e4ae753">Kernel::Point_3</a>;</div><div class="line"><span class="keyword">using</span> Vector_3 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a39fb0222695ae5e7e32f4e570ea28225">Kernel::Vector_3</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Point_set = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3&lt;Point_3&gt;</a>;</div><div class="line"><span class="keyword">using</span> Point_map = <span class="keyword">typename</span> Point_set::Point_map;</div><div class="line"><span class="keyword">using</span> Normal_map = <span class="keyword">typename</span> Point_set::Vector_map;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Shape_detection = <a class="code" href="namespaceCGAL_1_1Shape__detection_1_1Point__set.html">CGAL::Shape_detection::Point_set</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Neighbor_query = Shape_detection::K_neighbor_query</div><div class="line">  &lt;Kernel, Point_set, Point_map&gt;;</div><div class="line"><span class="keyword">using</span> Region_type = Shape_detection::Least_squares_cylinder_fit_region</div><div class="line">  &lt;Kernel, Point_set, Point_map, Normal_map&gt;;</div><div class="line"><span class="keyword">using</span> Region_growing = <a class="code" href="classCGAL_1_1Shape__detection_1_1Region__growing.html">CGAL::Shape_detection::Region_growing</a></div><div class="line">  &lt;Point_set, Neighbor_query, Region_type&gt;;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::ifstream ifile (argc &gt; 1 ? argv[1] : CGAL::data_file_path(<span class="stringliteral">"points_3/cube.pwn"</span>));</div><div class="line">  Point_set points;</div><div class="line">  ifile &gt;&gt; points;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; points.size() &lt;&lt; <span class="stringliteral">" points read"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Input should have normals</span></div><div class="line">  assert (points.has_normal_map());</div><div class="line"></div><div class="line">  <span class="comment">// Default parameters for data/cube.pwn</span></div><div class="line">  <span class="keyword">const</span> std::size_t k = 24;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> tolerance = 0.05;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> max_angle = 5.;</div><div class="line">  <span class="keyword">const</span> std::size_t min_region_size = 200;</div><div class="line"></div><div class="line">  <span class="comment">// No constraint on radius</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> min_radius = 0.;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> max_radius = std::numeric_limits&lt;double&gt;::infinity();</div><div class="line"></div><div class="line">  Neighbor_query neighbor_query(points, k, points.point_map());</div><div class="line">  Region_type region_type(points, tolerance, max_angle, min_region_size,</div><div class="line">                          min_radius, max_radius,</div><div class="line">                          points.point_map(), points.normal_map());</div><div class="line">  Region_growing region_growing(points, neighbor_query, region_type);</div><div class="line"></div><div class="line">  <span class="comment">// Add maps to get colored output</span></div><div class="line">  Point_set::Property_map&lt;unsigned char&gt;</div><div class="line">    red = points.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"red"</span>, 0).first,</div><div class="line">    green = points.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"green"</span>, 0).first,</div><div class="line">    blue = points.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"blue"</span>, 0).first;</div><div class="line"></div><div class="line">  CGAL::Random random;</div><div class="line"></div><div class="line">  std::size_t nb_cylinders = 0;</div><div class="line">  CGAL::Real_timer timer;</div><div class="line">  timer.start();</div><div class="line">  region_growing.detect</div><div class="line">    (boost::make_function_output_iterator</div><div class="line">     ([&amp;](<span class="keyword">const</span> std::vector&lt;std::size_t&gt;&amp; region)</div><div class="line">      {</div><div class="line">        <span class="comment">// Assign a random color to each region</span></div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> r = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(random.get_int(64, 192));</div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> g = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(random.get_int(64, 192));</div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> b = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(random.get_int(64, 192));</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> std::size_t&amp; idx : region)</div><div class="line">        {</div><div class="line">          red[idx] = r;</div><div class="line">          green[idx] = g;</div><div class="line">          blue[idx] = b;</div><div class="line">        }</div><div class="line">        ++ nb_cylinders;</div><div class="line">      }));</div><div class="line">  timer.stop();</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; nb_cylinders &lt;&lt; <span class="stringliteral">" cylinders detected in "</span></div><div class="line">            &lt;&lt; timer.time() &lt;&lt; <span class="stringliteral">" seconds"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save in colored_cylinders.ply</span></div><div class="line">  std::ofstream out (<span class="stringliteral">"colored_cylinders.ply"</span>);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (out);</div><div class="line">  out &lt;&lt; points;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="Shape_detection_RegionGrowingPoints_performance"></a>
Performance</h3>
<p>The main parameter that affects the region growing algorithm on a point set is the neighborhood size at each retrieval (<code>sphere_radius</code> or <code>k</code>). Larger neighbor lists are often followed by a smaller number of regions, larger coverage (the ratio between the number of points assigned to regions and the total number of input points), and longer running time. For example, for a test of about 70k 2D points with the fuzzy sphere neighborhood, the following table is produced:</p>
<table class="markdownTable" align="center">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter"><code>sphere_radius</code> </th><th class="markdownTableHeadCenter">Time (in seconds) </th><th class="markdownTableHeadCenter">Number of regions </th><th class="markdownTableHeadCenter">Number of assigned points  </th></tr>
<tr class="markdownTableBody">
<td class="markdownTableBodyCenter">1 </td><td class="markdownTableBodyCenter">0.138831 </td><td class="markdownTableBodyCenter">794 </td><td class="markdownTableBodyCenter">4483  </td></tr>
<tr class="markdownTableBody">
<td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyCenter">0.069098 </td><td class="markdownTableBodyCenter">3063 </td><td class="markdownTableBodyCenter">63038  </td></tr>
<tr class="markdownTableBody">
<td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyCenter">0.077703 </td><td class="markdownTableBodyCenter">2508 </td><td class="markdownTableBodyCenter">64906  </td></tr>
<tr class="markdownTableBody">
<td class="markdownTableBodyCenter">9 </td><td class="markdownTableBodyCenter">0.093415 </td><td class="markdownTableBodyCenter">2302 </td><td class="markdownTableBodyCenter">65334  </td></tr>
</table>
<p>If the neighborhood size is set too low, some points might be isolated, the region size would not reach a critical mass and so will be discarded. This does not only cause the latency in the program, but also reduces the coverage value, as can be seen when the <code>sphere_radius = 1</code>. A typical time measure for a 3D point set with the K nearest neighborhood and well-defined parameters can be found in the following table:</p>
<table class="markdownTable" align="center">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter"><code>Number of points</code>  </th><th class="markdownTableHeadCenter">Time (in seconds)  </th></tr>
<tr class="markdownTableBody">
<td class="markdownTableBodyCenter">300k </td><td class="markdownTableBodyCenter">0.761617  </td></tr>
<tr class="markdownTableBody">
<td class="markdownTableBodyCenter">600k </td><td class="markdownTableBodyCenter">1.68735  </td></tr>
<tr class="markdownTableBody">
<td class="markdownTableBodyCenter">900k </td><td class="markdownTableBodyCenter">2.80346  </td></tr>
<tr class="markdownTableBody">
<td class="markdownTableBodyCenter">1200k </td><td class="markdownTableBodyCenter">4.06246  </td></tr>
</table>
<h2><a class="anchor" id="Shape_detection_RegionGrowingMesh"></a>
Polygon Mesh</h2>
<p>If one wants to detect planes on a polygon mesh, this CGAL component provides the corresponding models of the concepts <a class="el" href="index.html#Shape_detection_RegionGrowingFramework_connectivity">NeighborQuery</a> and <a class="el" href="index.html#Shape_detection_RegionGrowingFramework_conditions">RegionType</a>. In particular, it has</p>
<ul>
<li><code><a class="el" href="classCGAL_1_1Shape__detection_1_1Polygon__mesh_1_1One__ring__neighbor__query.html" title="Edge-adjacent faces connectivity in a polygon mesh. ">CGAL::Shape_detection::Polygon_mesh::One_ring_neighbor_query</a></code> class that retrieves all edge-adjacent faces of a face, and</li>
<li><code><a class="el" href="classCGAL_1_1Shape__detection_1_1Polygon__mesh_1_1Least__squares__plane__fit__region.html" title="Region type based on the quality of the least squares plane fit applied to faces of a polygon mesh...">CGAL::Shape_detection::Polygon_mesh::Least_squares_plane_fit_region</a></code> class that fits a 3D plane to the vertices of all mesh faces, which have been added to the region so far, and controls the quality of this fit.</li>
</ul>
<p>This component accepts any model of the concept <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/classFaceListGraph.html">FaceListGraph</a></code> as a polygon mesh. A picture below gives an <a class="el" href="index.html#Shape_detection_RegionGrowingMesh_examples">example</a> of the region growing algorithm for detecting 3D planes on <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh</a></code>.</p>
<p><a class="anchor" id="fig__Region_growing_on_surface_mesh"></a></p><div class="image">
<img src="region_growing_on_polygon_mesh.png" alt="region_growing_on_polygon_mesh.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Region_growing_on_surface_mesh">Figure 82.10</a> A surface mesh depicted with one color per detected plane.  </div> <br /> 
<p>The quality of region growing on a polygon mesh can be improved by slightly sacrificing the running time. To achieve this, one can sort indices of input faces with respect to some quality criteria. These quality criteria can be included in region growing through the <a class="el" href="index.html#Shape_detection_RegionGrowingFramework_seeding">SeedMap</a> input parameter. We provide such a quality sorting:</p>
<ul>
<li><code><a class="el" href="classCGAL_1_1Shape__detection_1_1Polygon__mesh_1_1Least__squares__plane__fit__sorting.html" title="Sorting of polygon mesh faces with respect to the local plane fit quality. ">CGAL::Shape_detection::Polygon_mesh::Least_squares_plane_fit_sorting</a></code> - indices of input faces are sorted with respect to the quality of the least squares plane fit applied to the neighbors of each face.</li>
</ul>
<h3><a class="anchor" id="Shape_detection_RegionGrowingMesh_parameters"></a>
Parameters</h3>
<p>The <code><a class="el" href="classNeighborQuery.html" title="A concept that describes the set of methods used by the CGAL::Shape_detection::Region_growing to acce...">NeighborQuery</a></code> related class does not require any parameters, because edge-adjacent faces are found using the internal face graph connectivity, while the <code><a class="el" href="classRegionType.html" title="A concept that describes the set of methods used by the CGAL::Shape_detection::Region_growing to main...">RegionType</a></code> related class depends on three parameters:</p>
<ul>
<li><code>distance_threshold</code> - the maximum distance from the furthest face vertex to a plane;</li>
<li><code>angle_threshold</code> - the maximum accepted angle between the face normal and the normal of a plane;</li>
<li><code>min_region_size</code> - the minimum number of mesh faces a region must have.</li>
</ul>
<p>The first two parameters are used by the functions <code><a class="el" href="classRegionType.html#abf9f02613b07bce21e53f2d175532eae" title="checks if the item with the index index_to, which is a neighbor of the item with the index index_from...">RegionType::is_part_of_region()</a></code> and <code><a class="el" href="classRegionType.html#a3a11858e85d9c5f7354b6ffec4f653ff" title="enables to update any information that is maintained with the region represented by indices...">RegionType::update()</a></code>, while the third parameter is used by the function <code><a class="el" href="classRegionType.html#abb5a96a01ed18ea325abf58ad726f6e5" title="checks if the region represented by indices satisfies all necessary conditions. ">RegionType::is_valid_region()</a></code> explained in Section <a class="el" href="index.html#Shape_detection_RegionGrowingFramework_conditions">Framework Regions</a>. The right choice of these parameters is as important as the one explained in Section <a class="el" href="index.html#Shape_detection_RegionGrowingPoints_parameters">Parameters For Region Growing On Point Set</a>.</p>
<h3><a class="anchor" id="Shape_detection_RegionGrowingMesh_examples"></a>
Examples</h3>
<p>In the example below, we show how to use region growing to detect planes on a polygon mesh that can be either stored as <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh</a></code> or <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3</a></code>. If it is a surface mesh, this example also provides a way to save the result in a file (see Figure <a class="el" href="index.html#fig__Region_growing_on_surface_mesh">Figure 82.10</a>). The used <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html">Kernel</a></code> here is <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">CGAL::Exact_predicates_exact_constructions_kernel</a></code>. Though this exact kernel provides better quality results, please note that it may significantly slow down the execution of the program, so if you need a faster version of region growing, use a floating type based kernel.</p>
<p>We can improve the quality of region growing by providing a different seeding order (analogously to <a class="el" href="index.html#Shape_detection_RegionGrowingPoints">Point Sets</a>) that is why in this example we also sort indices of input faces using the <code><a class="el" href="classCGAL_1_1Shape__detection_1_1Polygon__mesh_1_1Least__squares__plane__fit__sorting.html" title="Sorting of polygon mesh faces with respect to the local plane fit quality. ">CGAL::Shape_detection::Polygon_mesh::Least_squares_plane_fit_sorting</a></code> and only then detect regions.</p>
<p><br />
<b>File</b> <a class="el" href="Shape_detection_2region_growing_planes_on_polygon_mesh_8cpp-example.html">Shape_detection/region_growing_planes_on_polygon_mesh.cpp</a> </p><div class="fragment"><div class="line"><span class="comment">// STL includes.</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iterator&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// CGAL includes.</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/memory.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/Color.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Iterator_range.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/HalfedgeDS_vector.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_exact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Shape_detection/Region_growing/Region_growing.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Shape_detection/Region_growing/Region_growing_on_polygon_mesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Type declarations.</span></div><div class="line"><span class="keyword">using</span> Kernel = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__exact__constructions__kernel.html">CGAL::Exact_predicates_exact_constructions_kernel</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> FT      = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a55e83f5a9f8ca43588b02ae8256a8fbd">Kernel::FT</a>;</div><div class="line"><span class="keyword">using</span> Point_3 = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ae82b7f4be77dd5b8819ebe419e4ae753">Kernel::Point_3</a>;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Color = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a>;</div><div class="line"></div><div class="line"><span class="comment">// Choose the type of a container for a polygon mesh.</span></div><div class="line"><span class="preprocessor">#define USE_SURFACE_MESH</span></div><div class="line"></div><div class="line"><span class="preprocessor">#if defined(USE_SURFACE_MESH)</span></div><div class="line"></div><div class="line">    <span class="keyword">using</span> Polygon_mesh = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point_3&gt;</a>;</div><div class="line">    <span class="keyword">using</span> Face_range   = <span class="keyword">typename</span> Polygon_mesh::Face_range;</div><div class="line"></div><div class="line">    <span class="keyword">using</span> Neighbor_query = <a class="code" href="classCGAL_1_1Shape__detection_1_1Polygon__mesh_1_1One__ring__neighbor__query.html">CGAL::Shape_detection::Polygon_mesh::One_ring_neighbor_query&lt;Polygon_mesh&gt;</a>;</div><div class="line">    <span class="keyword">using</span> Region_type    = <a class="code" href="classCGAL_1_1Shape__detection_1_1Polygon__mesh_1_1Least__squares__plane__fit__region.html">CGAL::Shape_detection::Polygon_mesh::Least_squares_plane_fit_region&lt;Kernel, Polygon_mesh&gt;</a>;</div><div class="line">    <span class="keyword">using</span> Sorting        = <a class="code" href="classCGAL_1_1Shape__detection_1_1Polygon__mesh_1_1Least__squares__plane__fit__sorting.html">CGAL::Shape_detection::Polygon_mesh::Least_squares_plane_fit_sorting&lt;Kernel, Polygon_mesh, Neighbor_query&gt;</a>;</div><div class="line"></div><div class="line"><span class="preprocessor">#else</span></div><div class="line"></div><div class="line">    <span class="keyword">using</span> Polygon_mesh = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polyhedron.tag:../Polyhedron/" href="../Polyhedron/classCGAL_1_1Polyhedron__3.html">CGAL::Polyhedron_3&lt;Kernel, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_vector&gt;</a>;</div><div class="line">    <span class="keyword">using</span> Face_range   = <span class="keyword">typename</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classCGAL_1_1Iterator__range.html">CGAL::Iterator_range&lt;typename boost::graph_traits&lt;Polygon_mesh&gt;::face_iterator</a>&gt;;</div><div class="line"></div><div class="line">    <span class="keyword">using</span> Neighbor_query = <a class="code" href="classCGAL_1_1Shape__detection_1_1Polygon__mesh_1_1One__ring__neighbor__query.html">CGAL::Shape_detection::Polygon_mesh::One_ring_neighbor_query&lt;Polygon_mesh, Face_range&gt;</a>;</div><div class="line">    <span class="keyword">using</span> Region_type    = <a class="code" href="classCGAL_1_1Shape__detection_1_1Polygon__mesh_1_1Least__squares__plane__fit__region.html">CGAL::Shape_detection::Polygon_mesh::Least_squares_plane_fit_region&lt;Kernel, Polygon_mesh, Face_range&gt;</a>;</div><div class="line">    <span class="keyword">using</span> Sorting        = <a class="code" href="classCGAL_1_1Shape__detection_1_1Polygon__mesh_1_1Least__squares__plane__fit__sorting.html">CGAL::Shape_detection::Polygon_mesh::Least_squares_plane_fit_sorting&lt;Kernel, Polygon_mesh, Neighbor_query, Face_range&gt;</a>;</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> Region  = std::vector&lt;std::size_t&gt;;</div><div class="line"><span class="keyword">using</span> Regions = std::vector&lt;Region&gt;;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Vertex_to_point_map = <span class="keyword">typename</span> Region_type::Vertex_to_point_map;</div><div class="line"></div><div class="line"><span class="keyword">using</span> Region_growing = <a class="code" href="classCGAL_1_1Shape__detection_1_1Region__growing.html">CGAL::Shape_detection::Region_growing&lt;Face_range, Neighbor_query, Region_type, typename Sorting::Seed_map&gt;</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div><div class="line"></div><div class="line">  std::cout &lt;&lt; std::endl &lt;&lt;</div><div class="line">    <span class="stringliteral">"region_growing_on_polygon_mesh example started"</span></div><div class="line">  &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Load off data either from a local folder or a user-provided file.</span></div><div class="line">  std::ifstream in(argc &gt; 1 ? argv[1] : CGAL::data_file_path(<span class="stringliteral">"meshes/polygon_mesh.off"</span>));</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7d51c854b865a7eb367e21fc43bd37b8">CGAL::IO::set_ascii_mode</a>(in);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (!in) {</div><div class="line">    std::cout &lt;&lt;</div><div class="line">    <span class="stringliteral">"Error: cannot read the file polygon_mesh.off!"</span> &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt;</div><div class="line">    <span class="stringliteral">"You can either create a symlink to the data folder or provide this file by hand."</span></div><div class="line">    &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  Polygon_mesh polygon_mesh;</div><div class="line">  in &gt;&gt; polygon_mesh;</div><div class="line"></div><div class="line">  in.close();</div><div class="line">  <span class="keyword">const</span> Face_range face_range = faces(polygon_mesh);</div><div class="line"></div><div class="line">  std::cout &lt;&lt;</div><div class="line">    <span class="stringliteral">"* polygon mesh with "</span></div><div class="line">  &lt;&lt; face_range.size() &lt;&lt;</div><div class="line">    <span class="stringliteral">" faces is loaded"</span></div><div class="line">  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Default parameter values for the data file polygon_mesh.off.</span></div><div class="line">  <span class="keyword">const</span> FT          max_distance_to_plane = FT(1);</div><div class="line">  <span class="keyword">const</span> FT          max_accepted_angle    = FT(45);</div><div class="line">  <span class="keyword">const</span> std::size_t min_region_size       = 5;</div><div class="line"></div><div class="line">  <span class="comment">// Create instances of the classes Neighbor_query and Region_type.</span></div><div class="line">  Neighbor_query neighbor_query(polygon_mesh);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> Vertex_to_point_map vertex_to_point_map(</div><div class="line">    <span class="keyword">get</span>(CGAL::vertex_point, polygon_mesh));</div><div class="line"></div><div class="line">  Region_type region_type(</div><div class="line">    polygon_mesh,</div><div class="line">    max_distance_to_plane, max_accepted_angle, min_region_size,</div><div class="line">    vertex_to_point_map);</div><div class="line"></div><div class="line">  <span class="comment">// Sort face indices.</span></div><div class="line">  Sorting sorting(</div><div class="line">    polygon_mesh, neighbor_query,</div><div class="line">    vertex_to_point_map);</div><div class="line">  sorting.sort();</div><div class="line"></div><div class="line">  <span class="comment">// Create an instance of the region growing class.</span></div><div class="line">  Region_growing region_growing(</div><div class="line">    face_range, neighbor_query, region_type,</div><div class="line">    sorting.seed_map());</div><div class="line"></div><div class="line">  <span class="comment">// Run the algorithm.</span></div><div class="line">  Regions regions;</div><div class="line">  region_growing.detect(std::back_inserter(regions));</div><div class="line"></div><div class="line">  <span class="comment">// Print the number of found regions.</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"* "</span> &lt;&lt; regions.size() &lt;&lt;</div><div class="line">    <span class="stringliteral">" regions have been found"</span></div><div class="line">  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save the result in a file only if it is stored in CGAL::Surface_mesh.</span></div><div class="line"><span class="preprocessor">  #if defined(USE_SURFACE_MESH)</span></div><div class="line"></div><div class="line">    <span class="keyword">using</span> Face_index = <span class="keyword">typename</span> Polygon_mesh::Face_index;</div><div class="line"></div><div class="line">    <span class="comment">// Save the result to a file in the user-provided path if any.</span></div><div class="line">    srand(static_cast&lt;unsigned int&gt;(time(<span class="keyword">nullptr</span>)));</div><div class="line">    <span class="keywordflow">if</span> (argc &gt; 2) {</div><div class="line"></div><div class="line">      <span class="keywordtype">bool</span> created;</div><div class="line">      <span class="keyword">typename</span> Polygon_mesh::template Property_map&lt;Face_index, Color&gt; face_color;</div><div class="line">      boost::tie(face_color, created) =</div><div class="line">        polygon_mesh.template add_property_map&lt;Face_index, Color&gt;(</div><div class="line">          <span class="stringliteral">"f:color"</span>, Color(0, 0, 0));</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (!created) {</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl &lt;&lt;</div><div class="line">          <span class="stringliteral">"region_growing_on_polygon_mesh example finished"</span></div><div class="line">        &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">      }</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::string path     = argv[2];</div><div class="line">      <span class="keyword">const</span> std::string fullpath = path + <span class="stringliteral">"regions_polygon_mesh.off"</span>;</div><div class="line"></div><div class="line">      std::ofstream out(fullpath);</div><div class="line"></div><div class="line">      <span class="comment">// Iterate through all regions.</span></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; region : regions) {</div><div class="line"></div><div class="line">        <span class="comment">// Generate a random color.</span></div><div class="line">        <span class="keyword">const</span> Color color(</div><div class="line">          static_cast&lt;unsigned char&gt;(rand() % 256),</div><div class="line">          static_cast&lt;unsigned char&gt;(rand() % 256),</div><div class="line">          static_cast&lt;unsigned char&gt;(rand() % 256));</div><div class="line"></div><div class="line">        <span class="comment">// Iterate through all region items.</span></div><div class="line">        <span class="keyword">using</span> size_type = <span class="keyword">typename</span> Polygon_mesh::size_type;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> index : region)</div><div class="line">          face_color[Face_index(static_cast&lt;size_type&gt;(index))] = color;</div><div class="line">      }</div><div class="line"></div><div class="line">      out &lt;&lt; polygon_mesh;</div><div class="line">      out.close();</div><div class="line"></div><div class="line">      std::cout &lt;&lt;</div><div class="line">        <span class="stringliteral">"* polygon mesh is saved in "</span></div><div class="line">      &lt;&lt; fullpath &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="preprocessor">  #endif</span></div><div class="line"></div><div class="line">  std::cout &lt;&lt; std::endl &lt;&lt;</div><div class="line">    <span class="stringliteral">"region_growing_on_polygon_mesh example finished"</span></div><div class="line">  &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="Shape_detection_RegionGrowingMesh_performance"></a>
Performance</h3>
<p>Since accessing neighbors of a face in a polygon mesh is fast, performance of the region growing on a polygon mesh mostly depends on the <code><a class="el" href="classRegionType.html" title="A concept that describes the set of methods used by the CGAL::Shape_detection::Region_growing to main...">RegionType</a></code> model's implementation, which is usually fast, too.</p>
<h1><a class="anchor" id="Shape_detection_Comparison"></a>
Comparison</h1>
<p>The Efficient RANSAC algorithm is very quick, however, since it is not deterministic, some small shapes might be missed in the detection process.</p>
<p>Instead, the region growing algorithm usually takes longer to complete, but it may provide better quality output in the presence of large scenes with numerous small details. Since it iterates throughout all items of the scene, there are fewer chances to miss a shape. In addition, it is deterministic (for a given input and a given set of parameters, it always returns the same output, whereas the Efficient RANSAC algorithm is randomized and so the output may vary at each run), see Figure <a class="el" href="index.html#fig__Shape_detection_comparison">Figure 82.11</a>.</p>
<p><a class="anchor" id="fig__Shape_detection_comparison"></a></p><div class="image">
<img src="comparison.png" alt="comparison.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Shape_detection_comparison">Figure 82.11</a> Comparison of the Efficient RANSAC and region growing algorithms. Top: the input point set. Bottom left: the output of the Efficient RANSAC, \(78\%\) of the shapes are correctly detected in 8 seconds. Bottom right: the output of the region growing, \(100\%\) of the shapes detected in 15 seconds. Unassigned points are in black in both output images.  </div> <br /> 
<h1><a class="anchor" id="Shape_detection_DeprecatedComponents"></a>
Deprecated Components</h1>
<p>The new version (see all examples above) of the class <code><a class="el" href="classCGAL_1_1Shape__detection_1_1Region__growing.html" title="Main class/entry point for running the region growing algorithm. ">CGAL::Shape_detection::Region_growing</a></code> is not compatible with the old API. For the old API, see an example below and use <code><a class="el" href="classCGAL_1_1Shape__detection_1_1deprecated_1_1Region__growing__depr.html" title="A shape detection algorithm using a region growing method. ">CGAL::Shape_detection::deprecated::Region_growing_depr</a></code> instead.</p>
<p><br />
<b>File</b> <a class="el" href="Shape_detection_2shape_detection_basic_deprecated_8cpp-example.html">Shape_detection/shape_detection_basic_deprecated.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#if defined (_MSC_VER) &amp;&amp; !defined (_WIN64)</span></div><div class="line"><span class="preprocessor">#pragma warning(disable:4244) // boost::number_distance::distance()</span></div><div class="line">                              <span class="comment">// converts 64 to 32 bits integers</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Installation/internal/disable_deprecation_warnings_and_errors.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Shape_detection_3.h&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Type declarations.</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>  Kernel;</div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Kernel::Point_3, Kernel::Vector_3&gt;         Point_with_normal;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point_with_normal&gt;                       Pwn_vector;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Point_with_normal&gt;</a>  Point_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;Point_with_normal&gt;</a> Normal_map;</div><div class="line"></div><div class="line"><span class="comment">// In Shape_detection_traits the basic types, i.e., Point and Vector types</span></div><div class="line"><span class="comment">// as well as iterator type and property maps, are defined.</span></div><div class="line"><span class="keyword">typedef</span> CGAL::Shape_detection_3::Shape_detection_traits</div><div class="line">&lt;Kernel, Pwn_vector, Point_map, Normal_map&gt;                  Traits;</div><div class="line"><span class="keyword">typedef</span> CGAL::Shape_detection_3::Efficient_RANSAC&lt;Traits&gt;    Efficient_ransac;</div><div class="line"><span class="keyword">typedef</span> CGAL::Shape_detection_3::Region_growing_depr&lt;Traits&gt; Region_growing;</div><div class="line"><span class="keyword">typedef</span> CGAL::Shape_detection_3::Plane&lt;Traits&gt;               Plane;</div><div class="line"></div><div class="line"><span class="comment">// This program both works for RANSAC and Region Growing.</span></div><div class="line"><span class="comment">// This example is using deprecated code!</span></div><div class="line"><span class="comment">// Please update your code to the new version using other examples!</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ShapeDetection&gt;</div><div class="line"><span class="keywordtype">int</span> run(<span class="keyword">const</span> std::string filename) {</div><div class="line"></div><div class="line">  <span class="comment">// Points with normals.</span></div><div class="line">  Pwn_vector points;</div><div class="line"></div><div class="line">  <span class="comment">// Load a point set from a file.</span></div><div class="line">  <span class="comment">// read_points takes an OutputIterator for storing the points</span></div><div class="line">  <span class="comment">// and a property map to store the normal vector with each point.</span></div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (!<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(filename,</div><div class="line">                             std::back_inserter(points),</div><div class="line">                             CGAL::parameters::point_map(Point_map()).</div><div class="line">                             normal_map(Normal_map()))) {</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Error: cannot read the file cube.pwn"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Instantiate a shape detection engine.</span></div><div class="line">  ShapeDetection shape_detection;</div><div class="line"></div><div class="line">  <span class="comment">// Provide the input data.</span></div><div class="line">  shape_detection.set_input(points);</div><div class="line"></div><div class="line">  <span class="comment">// Register planar shapes via template method.</span></div><div class="line">  shape_detection.template add_shape_factory&lt;Plane&gt;();</div><div class="line"></div><div class="line">  <span class="comment">// Detect registered shapes with default parameters.</span></div><div class="line">  shape_detection.detect();</div><div class="line"></div><div class="line">  <span class="comment">// Print number of detected shapes.</span></div><div class="line">  std::cout &lt;&lt; shape_detection.shapes().end() - shape_detection.shapes().begin()</div><div class="line">  &lt;&lt; <span class="stringliteral">" shapes detected."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1 &amp;&amp; std::string(argv[1]) == <span class="stringliteral">"-r"</span>) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Efficient RANSAC"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> run&lt;Efficient_ransac&gt; ((argc &gt; 2) ? argv[2] : CGAL::data_file_path(<span class="stringliteral">"points_3/cube.pwn"</span>));</div><div class="line">  }</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Region Growing"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">return</span> run&lt;Region_growing&gt; ((argc &gt; 1) ? argv[1] : CGAL::data_file_path(<span class="stringliteral">"points_3/cube.pwn"</span>));</div><div class="line">}</div></div><!-- fragment --><p>The old API is still supported, but will be removed in the next releases. In particular, the classes <code><a class="el" href="classCGAL_1_1Shape__detection_1_1deprecated_1_1Region__growing__depr.html" title="A shape detection algorithm using a region growing method. ">CGAL::Shape_detection::deprecated::Region_growing_depr</a></code> and <code><a class="el" href="structCGAL_1_1Shape__detection_1_1deprecated_1_1Shape__detection__traits.html" title="A traits class to use with the shape detection classes Efficient_RANSAC and deprecated::Region_growin...">CGAL::Shape_detection::deprecated::Shape_detection_traits</a></code> will be removed. Please update your code.</p>
<h1><a class="anchor" id="Shape_detection_History"></a>
History</h1>
<p>The Efficient RANSAC component was developed by Sven Oesau based on the prototype version created by Yannick Verdie, with the help of Cl√©ment Jamin and under the supervision of Pierre Alliez.</p>
<p>The region growing algorithm on a 3D point set was first implemented by Simon Giraudot based on the prototype version developed by Florent Lafarge and then generalized to arbitrary items including versions for a 2D point set, a 3D point set, and a polygon mesh by Thien Hoang during the Google Summer of Code 2018 under the supervision of Dmitry Anisimov.</p>
<h1><a class="anchor" id="Shape_detection_Acknowledgments"></a>
Acknowledgments</h1>
<p>The authors wish to thank our reviewers Andreas Fabri, S√©bastien Loriot, and Simon Giraudot for helpful comments and discussions. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Jan 26 2023 07:35:16 for CGAL 5.6 - Shape Detection by
    <a href="https://www.doxygen.nl/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>


</html>
