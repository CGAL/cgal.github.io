<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Triangulation_3/classCGAL_1_1Triangulation__3.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=11">
<meta name="generator" content="Doxygen 1.9.6">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CGAL 6.1 - 3D Triangulations: CGAL::Triangulation_3&lt; Traits, TDS, SLDS &gt; Class Template Reference</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/doxygen.css" rel="stylesheet" type="text/css">
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      },
      equationNumbers: { autoNumber: "AMS" }
  }
}
);
MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
  var PARSE = MathJax.InputJax.TeX.Parse,
      TEXT = PARSE.prototype.InternalText;
  PARSE.Augment({
    InternalText: function (text,def) {
      text = text.replace(/\\/g,"");
      return TEXT.call(this,text,def);
    }
  });
});
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<script src="modules.js" type="text/javascript"></script>
<link href="cgal_stylesheet.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
      <span class="left">
         <span id="MSearchSelect" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"> 
        </span>
        <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
      </span>
      <span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.svg" alt=""></a>
      </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CGAL 6.1 - 3D Triangulations
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search/",'.html');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classCGAL_1_1Triangulation__3.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="classCGAL_1_1Triangulation__3-members.html">List of all members</a> |
<a href="#pub-types">Public Types</a>  </div>
  <div class="headertitle"><div class="title">CGAL::Triangulation_3&lt; Traits, TDS, SLDS &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__PkgTriangulation3Ref.html">3D Triangulations Reference</a> » <a class="el" href="group__PkgTriangulation3TriangulationClasses.html">Triangulation Classes</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;CGAL/Triangulation_3.h&gt;</code></p>

<h2 class="groupheader">Inherits from</h2><p><a class="elRef" href="../TDS_3/structCGAL_1_1Triangulation__utils__3.html">CGAL::Triangulation_utils_3</a>.</p>

<p>Inherited by <a class="el" href="classCGAL_1_1Regular__triangulation__3.html">CGAL::Regular_triangulation_3&lt; Traits, TDS, SLDS &gt;</a>.</p>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Traits, typename TDS, typename SLDS&gt;<br>
class CGAL::Triangulation_3&lt; Traits, TDS, SLDS &gt;</div><p>The class <code><a class="el" href="classCGAL_1_1Triangulation__3.html" title="The class Triangulation_3 represents a 3-dimensional tetrahedralization of points.">Triangulation_3</a></code> represents a 3-dimensional tetrahedralization of points. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Traits</td><td>is the geometric traits class and must be a model of <code><a class="el" href="classTriangulationTraits__3.html">TriangulationTraits_3</a></code>.</td></tr>
    <tr><td class="paramname">TDS</td><td>is the triangulation data structure and must be a model of <code><a class="elRef" href="../TDS_3/classTriangulationDataStructure__3.html">TriangulationDataStructure_3</a></code>. <code><a class="elRef" href="../STL_Extension/structCGAL_1_1Default.html">Default</a></code> may be used, with default type <code><a class="elRef" href="../TDS_3/classCGAL_1_1Triangulation__data__structure__3.html">Triangulation_data_structure_3</a>&lt;<a class="el" href="classCGAL_1_1Triangulation__vertex__base__3.html" title="The class Triangulation_vertex_base_3 is a model of the concept TriangulationVertexBase_3,...">Triangulation_vertex_base_3</a>&lt;Traits&gt;, <a class="el" href="classCGAL_1_1Triangulation__cell__base__3.html" title="The class Triangulation_cell_base_3 is a model of the concept TriangulationCellBase_3,...">Triangulation_cell_base_3</a>&lt;Traits&gt; &gt;</code>. Any custom type can be used instead of <code><a class="el" href="classCGAL_1_1Triangulation__vertex__base__3.html" title="The class Triangulation_vertex_base_3 is a model of the concept TriangulationVertexBase_3,...">Triangulation_vertex_base_3</a></code> and <code><a class="el" href="classCGAL_1_1Triangulation__cell__base__3.html" title="The class Triangulation_cell_base_3 is a model of the concept TriangulationCellBase_3,...">Triangulation_cell_base_3</a></code>, provided that they are models of the concepts <code><a class="el" href="classTriangulationVertexBase__3.html" title="The vertex base used by the geometric triangulation must store a point. We list here the additional r...">TriangulationVertexBase_3</a></code> and <code><a class="el" href="classTriangulationCellBase__3.html" title="The cell base required by the basic triangulation does not need to store any geometric information,...">TriangulationCellBase_3</a></code>, respectively.</td></tr>
    <tr><td class="paramname">SLDS</td><td>is an optional parameter to specify the type of the spatial lock data structure. It must be a model of the <code><a class="elRef" href="../STL_Extension/classSurjectiveLockDataStructure.html">SurjectiveLockDataStructure</a></code> concept, with <code><a class="elRef" href="../STL_Extension/classCGAL_1_1Object.html">Object</a></code> being a <code>Point</code> (as defined below). It is only used if the triangulation data structure used is concurrency-safe (i.e. when <code><a class="elRef" href="../TDS_3/classTriangulationDataStructure__3.html#a540c1ac639e9ac22317900eba52dc92a">TriangulationDataStructure_3::Concurrency_tag</a></code> is <code><a class="elRef" href="../STL_Extension/structCGAL_1_1Parallel__tag.html">Parallel_tag</a></code>). The default value is <code><a class="elRef" href="../STL_Extension/classCGAL_1_1Spatial__lock__grid__3.html">Spatial_lock_grid_3</a>&lt;Tag_priority_blocking&gt;</code> if the triangulation data structure is concurrency-safe, and <code>void</code> otherwise. In order to use concurrent operations, the user must provide a reference to a SLDS instance via the constructor or <code><a class="el" href="classCGAL_1_1Triangulation__3.html#afba384e440c57f3bb0a71e4b4f7f9944" title="Set the pointer to the lock data structure.">Triangulation_3::set_lock_data_structure</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Traversal of the Triangulation</b><br>
</p>
<p>The triangulation class provides several iterators and circulators that allow one to traverse it (completely or partially).</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classCGAL_1_1Delaunay__triangulation__3.html" title="The class Delaunay_triangulation_3 represents a three-dimensional Delaunay triangulation.">CGAL::Delaunay_triangulation_3</a></code> </dd>
<dd>
<code><a class="el" href="classCGAL_1_1Regular__triangulation__3.html" title="Let  be a set of weighted points in .">CGAL::Regular_triangulation_3</a></code> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Triangulation_3_2for_loop_8cpp-example.html#_a1">Triangulation_3/for_loop.cpp</a>, <a class="el" href="Triangulation_3_2simple_triangulation_3_8cpp-example.html#_a1">Triangulation_3/simple_triangulation_3.cpp</a>, and <a class="el" href="Triangulation_3_2simplex_8cpp-example.html#_a1">Triangulation_3/simplex.cpp</a>.</dd>
</dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5bea7d3470854571f97c18a675daca75"><td class="memItemLeft" align="right" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a5bea7d3470854571f97c18a675daca75">Locate_type</a> { <br>
  <a class="el" href="classCGAL_1_1Triangulation__3.html#a5bea7d3470854571f97c18a675daca75a285953109776e1f27769b65bb7249994">VERTEX</a> =0
, <a class="el" href="classCGAL_1_1Triangulation__3.html#a5bea7d3470854571f97c18a675daca75a708387eea38c6e1ffbd7ef5ef695f2e1">EDGE</a>
, <a class="el" href="classCGAL_1_1Triangulation__3.html#a5bea7d3470854571f97c18a675daca75acb284e3051bc02bd4645aca6b2382b42">FACET</a>
, <a class="el" href="classCGAL_1_1Triangulation__3.html#a5bea7d3470854571f97c18a675daca75aa264f5df83d639caa57ea1def2f16f36">CELL</a>
, <br>
  <a class="el" href="classCGAL_1_1Triangulation__3.html#a5bea7d3470854571f97c18a675daca75a4ed6b6faec7f4a57a66120b7c5c11471">OUTSIDE_CONVEX_HULL</a>
, <a class="el" href="classCGAL_1_1Triangulation__3.html#a5bea7d3470854571f97c18a675daca75a922f153be5cccf0228b56f5160e47e6a">OUTSIDE_AFFINE_HULL</a>
<br>
 }</td></tr>
<tr class="memdesc:a5bea7d3470854571f97c18a675daca75"><td class="mdescLeft"> </td><td class="mdescRight">The enum <code>Locate_type</code> is defined by <code><a class="el" href="classCGAL_1_1Triangulation__3.html" title="The class Triangulation_3 represents a 3-dimensional tetrahedralization of points.">Triangulation_3</a></code> to specify which case occurs when locating a point in the triangulation.  <a href="classCGAL_1_1Triangulation__3.html#a5bea7d3470854571f97c18a675daca75">More...</a><br></td></tr>
<tr class="separator:a5bea7d3470854571f97c18a675daca75"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Types</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>The class <code><a class="el" href="classCGAL_1_1Triangulation__3.html" title="The class Triangulation_3 represents a 3-dimensional tetrahedralization of points.">Triangulation_3</a></code> defines the following types: </p>
</td></tr>
<tr class="memitem:ab250045d0412b06d83977a0c2cf33ff9"><td class="memItemLeft" align="right" valign="top"><a id="ab250045d0412b06d83977a0c2cf33ff9" name="ab250045d0412b06d83977a0c2cf33ff9"></a>
typedef Traits </td><td class="memItemRight" valign="bottom"><b>Geom_traits</b></td></tr>
<tr class="separator:ab250045d0412b06d83977a0c2cf33ff9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a142364d710a44fb68daf6cbd185861ce"><td class="memItemLeft" align="right" valign="top"><a id="a142364d710a44fb68daf6cbd185861ce" name="a142364d710a44fb68daf6cbd185861ce"></a>
typedef TDS </td><td class="memItemRight" valign="bottom"><b>Triangulation_data_structure</b></td></tr>
<tr class="separator:a142364d710a44fb68daf6cbd185861ce"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1f96730cb3b4cfd6c2893ecb7300ec90"><td class="memItemLeft" align="right" valign="top"><a id="a1f96730cb3b4cfd6c2893ecb7300ec90" name="a1f96730cb3b4cfd6c2893ecb7300ec90"></a>
typedef SLDS </td><td class="memItemRight" valign="bottom"><b>Lock_data_structure</b></td></tr>
<tr class="separator:a1f96730cb3b4cfd6c2893ecb7300ec90"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a064de663ce02121ba3f0f4223547e064"><td class="memItemLeft" align="right" valign="top"><a id="a064de663ce02121ba3f0f4223547e064" name="a064de663ce02121ba3f0f4223547e064"></a>
typedef Triangulation_data_structure::Vertex::Point </td><td class="memItemRight" valign="bottom"><b>Point</b></td></tr>
<tr class="separator:a064de663ce02121ba3f0f4223547e064"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2ee20454a8adb0ff5d6db5acabd10e05"><td class="memItemLeft" align="right" valign="top"><a id="a2ee20454a8adb0ff5d6db5acabd10e05" name="a2ee20454a8adb0ff5d6db5acabd10e05"></a>
typedef Geom_traits::Segment_3 </td><td class="memItemRight" valign="bottom"><b>Segment</b></td></tr>
<tr class="separator:a2ee20454a8adb0ff5d6db5acabd10e05"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adc409424d433ef56a79d5e71c02b8e15"><td class="memItemLeft" align="right" valign="top"><a id="adc409424d433ef56a79d5e71c02b8e15" name="adc409424d433ef56a79d5e71c02b8e15"></a>
typedef Geom_traits::Triangle_3 </td><td class="memItemRight" valign="bottom"><b>Triangle</b></td></tr>
<tr class="separator:adc409424d433ef56a79d5e71c02b8e15"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa88be907873b0469824cc3b2212f2eee"><td class="memItemLeft" align="right" valign="top"><a id="aa88be907873b0469824cc3b2212f2eee" name="aa88be907873b0469824cc3b2212f2eee"></a>
typedef Geom_traits::Tetrahedron_3 </td><td class="memItemRight" valign="bottom"><b>Tetrahedron</b></td></tr>
<tr class="separator:aa88be907873b0469824cc3b2212f2eee"><td class="memSeparator" colspan="2"> </td></tr>
<tr><td class="ititle" colspan="2"><p>Only vertices (0-faces) and cells (3-faces) are stored.</p>
<p>Edges (1-faces) and facets (2-faces) are not explicitly represented and thus there are no corresponding classes (see Section <a class="el" href="index.html#Triangulation3secintro">Representation</a>). </p>
</td></tr>
<tr class="memitem:a689822c56fb0d30a538df471fe076fc1"><td class="memItemLeft" align="right" valign="top"><a id="a689822c56fb0d30a538df471fe076fc1" name="a689822c56fb0d30a538df471fe076fc1"></a>
typedef Triangulation_data_structure::Vertex </td><td class="memItemRight" valign="bottom"><b>Vertex</b></td></tr>
<tr class="separator:a689822c56fb0d30a538df471fe076fc1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6ccf0bf0c3ca54b4a2e8f2f1b09a103f"><td class="memItemLeft" align="right" valign="top"><a id="a6ccf0bf0c3ca54b4a2e8f2f1b09a103f" name="a6ccf0bf0c3ca54b4a2e8f2f1b09a103f"></a>
typedef Triangulation_data_structure::Cell </td><td class="memItemRight" valign="bottom"><b>Cell</b></td></tr>
<tr class="separator:a6ccf0bf0c3ca54b4a2e8f2f1b09a103f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa100228164b0cf78d5c2b1009c2df258"><td class="memItemLeft" align="right" valign="top"><a id="aa100228164b0cf78d5c2b1009c2df258" name="aa100228164b0cf78d5c2b1009c2df258"></a>
typedef Triangulation_data_structure::Facet </td><td class="memItemRight" valign="bottom"><b>Facet</b></td></tr>
<tr class="separator:aa100228164b0cf78d5c2b1009c2df258"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0f355dbb38cf631f24d4df8abd7a942f"><td class="memItemLeft" align="right" valign="top"><a id="a0f355dbb38cf631f24d4df8abd7a942f" name="a0f355dbb38cf631f24d4df8abd7a942f"></a>
typedef Triangulation_data_structure::Edge </td><td class="memItemRight" valign="bottom"><b>Edge</b></td></tr>
<tr class="separator:a0f355dbb38cf631f24d4df8abd7a942f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a029910b5cfe5d470afdd8f79ea49e24e"><td class="memItemLeft" align="right" valign="top"><a id="a029910b5cfe5d470afdd8f79ea49e24e" name="a029910b5cfe5d470afdd8f79ea49e24e"></a>
typedef Triangulation_data_structure::Concurrency_tag </td><td class="memItemRight" valign="bottom"><b>Concurrency_tag</b></td></tr>
<tr class="memdesc:a029910b5cfe5d470afdd8f79ea49e24e"><td class="mdescLeft"> </td><td class="mdescRight">Concurrency tag (from the TDS). <br></td></tr>
<tr class="separator:a029910b5cfe5d470afdd8f79ea49e24e"><td class="memSeparator" colspan="2"> </td></tr>
<tr><td class="ititle" colspan="2"><p>The vertices and faces of the triangulations are accessed through <code>handles</code>, <code>iterators</code> and <code>circulators</code>.</p>
<p>A handle is a model of the <code><a class="elRef" href="../Circulator/classHandle.html">Handle</a></code> concept, and supports the two dereference operators and <code>operator-&gt;</code>. A circulator is a model of the concept <code><a class="elRef" href="../Circulator/classCirculator.html">Circulator</a></code>. Iterators and circulators are bidirectional and non-mutable. The edges and facets of the triangulation can also be visited through iterators and circulators which are bidirectional and non-mutable. Iterators and circulators are convertible to the corresponding handles, thus the user can pass them directly as arguments to the functions. The handles are also model of the concepts <code><a class="elRef" href="../Manual/classLessThanComparable.html">LessThanComparable</a></code> and <code><a class="elRef" href="../STL_Extension/classHashable.html">Hashable</a></code>, that is they can be used as keys in containers such as <code>std::map</code> and <code>boost::unordered_map</code>. </p>
</td></tr>
<tr class="memitem:a1ba56e37b3a5acb1ba49a56d9d101a19"><td class="memItemLeft" align="right" valign="top"><a id="a1ba56e37b3a5acb1ba49a56d9d101a19" name="a1ba56e37b3a5acb1ba49a56d9d101a19"></a>
typedef Triangulation_data_structure::Vertex_handle </td><td class="memItemRight" valign="bottom"><b>Vertex_handle</b></td></tr>
<tr class="memdesc:a1ba56e37b3a5acb1ba49a56d9d101a19"><td class="mdescLeft"> </td><td class="mdescRight">handle to a vertex <br></td></tr>
<tr class="separator:a1ba56e37b3a5acb1ba49a56d9d101a19"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac076eb6ecdeeeb2b5bf678a21b3d23ee"><td class="memItemLeft" align="right" valign="top"><a id="ac076eb6ecdeeeb2b5bf678a21b3d23ee" name="ac076eb6ecdeeeb2b5bf678a21b3d23ee"></a>
typedef Triangulation_data_structure::Cell_handle </td><td class="memItemRight" valign="bottom"><b>Cell_handle</b></td></tr>
<tr class="memdesc:ac076eb6ecdeeeb2b5bf678a21b3d23ee"><td class="mdescLeft"> </td><td class="mdescRight">handle to a cell <br></td></tr>
<tr class="separator:ac076eb6ecdeeeb2b5bf678a21b3d23ee"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a431de9481031045367856fa156fc643f"><td class="memItemLeft" align="right" valign="top"><a id="a431de9481031045367856fa156fc643f" name="a431de9481031045367856fa156fc643f"></a>
typedef <a class="el" href="classCGAL_1_1Triangulation__simplex__3.html">Triangulation_simplex_3</a>&lt; Self &gt; </td><td class="memItemRight" valign="bottom"><b>Simplex</b></td></tr>
<tr class="memdesc:a431de9481031045367856fa156fc643f"><td class="mdescLeft"> </td><td class="mdescRight">Reference to a simplex (vertex, edge, facet or cell) of the triangulation. <br></td></tr>
<tr class="separator:a431de9481031045367856fa156fc643f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab33c8cdfd6a571cf9635a531d2d261a0"><td class="memItemLeft" align="right" valign="top"><a id="ab33c8cdfd6a571cf9635a531d2d261a0" name="ab33c8cdfd6a571cf9635a531d2d261a0"></a>
typedef Triangulation_data_structure::size_type </td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="memdesc:ab33c8cdfd6a571cf9635a531d2d261a0"><td class="mdescLeft"> </td><td class="mdescRight">Size type (an unsigned integral type) <br></td></tr>
<tr class="separator:ab33c8cdfd6a571cf9635a531d2d261a0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4f5b67204a2a310e48525abd3cdd3660"><td class="memItemLeft" align="right" valign="top"><a id="a4f5b67204a2a310e48525abd3cdd3660" name="a4f5b67204a2a310e48525abd3cdd3660"></a>
typedef Triangulation_data_structure::difference_type </td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr class="memdesc:a4f5b67204a2a310e48525abd3cdd3660"><td class="mdescLeft"> </td><td class="mdescRight">Difference type (a signed integral type) <br></td></tr>
<tr class="separator:a4f5b67204a2a310e48525abd3cdd3660"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aff2c019af34403770e6e922d616eaf0f"><td class="memItemLeft" align="right" valign="top"><a id="aff2c019af34403770e6e922d616eaf0f" name="aff2c019af34403770e6e922d616eaf0f"></a>
typedef Triangulation_data_structure::Cell_iterator </td><td class="memItemRight" valign="bottom"><b>All_cells_iterator</b></td></tr>
<tr class="memdesc:aff2c019af34403770e6e922d616eaf0f"><td class="mdescLeft"> </td><td class="mdescRight">iterator over cells <br></td></tr>
<tr class="separator:aff2c019af34403770e6e922d616eaf0f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a086ed61d6d43a10f77f6a4d695a256fc"><td class="memItemLeft" align="right" valign="top"><a id="a086ed61d6d43a10f77f6a4d695a256fc" name="a086ed61d6d43a10f77f6a4d695a256fc"></a>
typedef Triangulation_data_structure::Facet_iterator </td><td class="memItemRight" valign="bottom"><b>All_facets_iterator</b></td></tr>
<tr class="memdesc:a086ed61d6d43a10f77f6a4d695a256fc"><td class="mdescLeft"> </td><td class="mdescRight">iterator over facets <br></td></tr>
<tr class="separator:a086ed61d6d43a10f77f6a4d695a256fc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a67ff0ee4eca14392f1fcb55acd5a6edc"><td class="memItemLeft" align="right" valign="top"><a id="a67ff0ee4eca14392f1fcb55acd5a6edc" name="a67ff0ee4eca14392f1fcb55acd5a6edc"></a>
typedef Triangulation_data_structure::Edge_iterator </td><td class="memItemRight" valign="bottom"><b>All_edges_iterator</b></td></tr>
<tr class="memdesc:a67ff0ee4eca14392f1fcb55acd5a6edc"><td class="mdescLeft"> </td><td class="mdescRight">iterator over edges <br></td></tr>
<tr class="separator:a67ff0ee4eca14392f1fcb55acd5a6edc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab930d6f34c8346b5191e93ab79475c70"><td class="memItemLeft" align="right" valign="top"><a id="ab930d6f34c8346b5191e93ab79475c70" name="ab930d6f34c8346b5191e93ab79475c70"></a>
typedef Triangulation_data_structure::Vertex_iterator </td><td class="memItemRight" valign="bottom"><b>All_vertices_iterator</b></td></tr>
<tr class="memdesc:ab930d6f34c8346b5191e93ab79475c70"><td class="mdescLeft"> </td><td class="mdescRight">iterator over vertices <br></td></tr>
<tr class="separator:ab930d6f34c8346b5191e93ab79475c70"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6d1b83cb6fba001622452aa0f6592e02"><td class="memItemLeft" align="right" valign="top"><a id="a6d1b83cb6fba001622452aa0f6592e02" name="a6d1b83cb6fba001622452aa0f6592e02"></a>
typedef <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> </td><td class="memItemRight" valign="bottom"><b>Finite_cells_iterator</b></td></tr>
<tr class="memdesc:a6d1b83cb6fba001622452aa0f6592e02"><td class="mdescLeft"> </td><td class="mdescRight">iterator over finite cells <br></td></tr>
<tr class="separator:a6d1b83cb6fba001622452aa0f6592e02"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6bc54bfb8362670059a4c1a416269994"><td class="memItemLeft" align="right" valign="top"><a id="a6bc54bfb8362670059a4c1a416269994" name="a6bc54bfb8362670059a4c1a416269994"></a>
typedef <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> </td><td class="memItemRight" valign="bottom"><b>Finite_facets_iterator</b></td></tr>
<tr class="memdesc:a6bc54bfb8362670059a4c1a416269994"><td class="mdescLeft"> </td><td class="mdescRight">iterator over finite facets <br></td></tr>
<tr class="separator:a6bc54bfb8362670059a4c1a416269994"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1c91aeb6128d5bf33995dca02398d330"><td class="memItemLeft" align="right" valign="top"><a id="a1c91aeb6128d5bf33995dca02398d330" name="a1c91aeb6128d5bf33995dca02398d330"></a>
typedef <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> </td><td class="memItemRight" valign="bottom"><b>Finite_edges_iterator</b></td></tr>
<tr class="memdesc:a1c91aeb6128d5bf33995dca02398d330"><td class="mdescLeft"> </td><td class="mdescRight">iterator over finite edges <br></td></tr>
<tr class="separator:a1c91aeb6128d5bf33995dca02398d330"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af8d044953011cb5ff6a5ecf87e6f308e"><td class="memItemLeft" align="right" valign="top"><a id="af8d044953011cb5ff6a5ecf87e6f308e" name="af8d044953011cb5ff6a5ecf87e6f308e"></a>
typedef <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> </td><td class="memItemRight" valign="bottom"><b>Finite_vertices_iterator</b></td></tr>
<tr class="memdesc:af8d044953011cb5ff6a5ecf87e6f308e"><td class="mdescLeft"> </td><td class="mdescRight">iterator over finite vertices <br></td></tr>
<tr class="separator:af8d044953011cb5ff6a5ecf87e6f308e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3ec38d2d1afffea88a760f5a50c4f9f0"><td class="memItemLeft" align="right" valign="top"><a id="a3ec38d2d1afffea88a760f5a50c4f9f0" name="a3ec38d2d1afffea88a760f5a50c4f9f0"></a>
typedef <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> </td><td class="memItemRight" valign="bottom"><b>Point_iterator</b></td></tr>
<tr class="memdesc:a3ec38d2d1afffea88a760f5a50c4f9f0"><td class="mdescLeft"> </td><td class="mdescRight">iterator over the points corresponding to the finite vertices of the triangulation. <br></td></tr>
<tr class="separator:a3ec38d2d1afffea88a760f5a50c4f9f0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a064fb43553690504ee55c4b9a74188e5"><td class="memItemLeft" align="right" valign="top"><a id="a064fb43553690504ee55c4b9a74188e5" name="a064fb43553690504ee55c4b9a74188e5"></a>
typedef Triangulation_data_structure::Cell_circulator </td><td class="memItemRight" valign="bottom"><b>Cell_circulator</b></td></tr>
<tr class="memdesc:a064fb43553690504ee55c4b9a74188e5"><td class="mdescLeft"> </td><td class="mdescRight">circulator over all cells incident to a given edge <br></td></tr>
<tr class="separator:a064fb43553690504ee55c4b9a74188e5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1c904fc6cbfe189b2cb09f7175044b00"><td class="memItemLeft" align="right" valign="top"><a id="a1c904fc6cbfe189b2cb09f7175044b00" name="a1c904fc6cbfe189b2cb09f7175044b00"></a>
typedef Triangulation_data_structure::Facet_circulator </td><td class="memItemRight" valign="bottom"><b>Facet_circulator</b></td></tr>
<tr class="memdesc:a1c904fc6cbfe189b2cb09f7175044b00"><td class="mdescLeft"> </td><td class="mdescRight">circulator over all facets incident to a given edge <br></td></tr>
<tr class="separator:a1c904fc6cbfe189b2cb09f7175044b00"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a39088e35d874ae7361d96a19acd572c7"><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a39088e35d874ae7361d96a19acd572c7">Segment_cell_iterator</a></td></tr>
<tr class="memdesc:a39088e35d874ae7361d96a19acd572c7"><td class="mdescLeft"> </td><td class="mdescRight">iterator over cells intersected by a line segment.  <br></td></tr>
<tr class="separator:a39088e35d874ae7361d96a19acd572c7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a822c7264ac03f629735cb85be4871e1f"><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a822c7264ac03f629735cb85be4871e1f">Segment_simplex_iterator</a></td></tr>
<tr class="memdesc:a822c7264ac03f629735cb85be4871e1f"><td class="mdescLeft"> </td><td class="mdescRight">iterator over simplices intersected by a line segment.  <br></td></tr>
<tr class="separator:a822c7264ac03f629735cb85be4871e1f"><td class="memSeparator" colspan="2"> </td></tr>
<tr><td class="ititle" colspan="2"><p>In order to write C++ 11 <code>for</code>-loops we provide the following range types. </p>
</td></tr>
<tr class="memitem:a0ffff120af16e255cee2ccc20be34775"><td class="memItemLeft" align="right" valign="top"><a id="a0ffff120af16e255cee2ccc20be34775" name="a0ffff120af16e255cee2ccc20be34775"></a>
typedef <a class="elRef" href="../STL_Extension/classCGAL_1_1Iterator__range.html">Iterator_range</a>&lt; <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> &gt; </td><td class="memItemRight" valign="bottom"><b>All_cell_handles</b></td></tr>
<tr class="memdesc:a0ffff120af16e255cee2ccc20be34775"><td class="mdescLeft"> </td><td class="mdescRight">range type for iterating over all cell handles (including infinite cells), with a nested type <code>iterator</code> that has as value type <code>Cell_handle</code>. <br></td></tr>
<tr class="separator:a0ffff120af16e255cee2ccc20be34775"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abe601aa6506352a8df0877449bcf0dd3"><td class="memItemLeft" align="right" valign="top"><a id="abe601aa6506352a8df0877449bcf0dd3" name="abe601aa6506352a8df0877449bcf0dd3"></a>
typedef <a class="elRef" href="../STL_Extension/classCGAL_1_1Iterator__range.html">Iterator_range</a>&lt; <a class="el" href="classCGAL_1_1Triangulation__3.html#a086ed61d6d43a10f77f6a4d695a256fc">All_facets_iterator</a> &gt; </td><td class="memItemRight" valign="bottom"><b>All_facets</b></td></tr>
<tr class="memdesc:abe601aa6506352a8df0877449bcf0dd3"><td class="mdescLeft"> </td><td class="mdescRight">range type for iterating over facets. <br></td></tr>
<tr class="separator:abe601aa6506352a8df0877449bcf0dd3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a60c2dacc98d57951b9209f94dfcad921"><td class="memItemLeft" align="right" valign="top"><a id="a60c2dacc98d57951b9209f94dfcad921" name="a60c2dacc98d57951b9209f94dfcad921"></a>
typedef <a class="elRef" href="../STL_Extension/classCGAL_1_1Iterator__range.html">Iterator_range</a>&lt; <a class="el" href="classCGAL_1_1Triangulation__3.html#a67ff0ee4eca14392f1fcb55acd5a6edc">All_edges_iterator</a> &gt; </td><td class="memItemRight" valign="bottom"><b>All_edges</b></td></tr>
<tr class="memdesc:a60c2dacc98d57951b9209f94dfcad921"><td class="mdescLeft"> </td><td class="mdescRight">range type for iterating over edges. <br></td></tr>
<tr class="separator:a60c2dacc98d57951b9209f94dfcad921"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae53e08aa6f86bee125ef6ba075b0e973"><td class="memItemLeft" align="right" valign="top"><a id="ae53e08aa6f86bee125ef6ba075b0e973" name="ae53e08aa6f86bee125ef6ba075b0e973"></a>
typedef <a class="elRef" href="../STL_Extension/classCGAL_1_1Iterator__range.html">Iterator_range</a>&lt; <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> &gt; </td><td class="memItemRight" valign="bottom"><b>All_vertex_handles</b></td></tr>
<tr class="memdesc:ae53e08aa6f86bee125ef6ba075b0e973"><td class="mdescLeft"> </td><td class="mdescRight">range type for iterating over all vertex handles, with a nested type <code>iterator</code> that has as value type <code>Vertex_handle</code>. <br></td></tr>
<tr class="separator:ae53e08aa6f86bee125ef6ba075b0e973"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4c94face5ab29897bcb291f157f1635d"><td class="memItemLeft" align="right" valign="top"><a id="a4c94face5ab29897bcb291f157f1635d" name="a4c94face5ab29897bcb291f157f1635d"></a>
typedef <a class="elRef" href="../STL_Extension/classCGAL_1_1Iterator__range.html">Iterator_range</a>&lt; <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> &gt; </td><td class="memItemRight" valign="bottom"><b>Finite_cell_handles</b></td></tr>
<tr class="memdesc:a4c94face5ab29897bcb291f157f1635d"><td class="mdescLeft"> </td><td class="mdescRight">range type for iterating over finite cell handles, with a nested type <code>iterator</code> that has as value type <code>Cell_handle</code>. <br></td></tr>
<tr class="separator:a4c94face5ab29897bcb291f157f1635d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa35974d42ec9564687ffbe5f664cb906"><td class="memItemLeft" align="right" valign="top"><a id="aa35974d42ec9564687ffbe5f664cb906" name="aa35974d42ec9564687ffbe5f664cb906"></a>
typedef <a class="elRef" href="../STL_Extension/classCGAL_1_1Iterator__range.html">Iterator_range</a>&lt; <a class="el" href="classCGAL_1_1Triangulation__3.html#a6bc54bfb8362670059a4c1a416269994">Finite_facets_iterator</a> &gt; </td><td class="memItemRight" valign="bottom"><b>Finite_facets</b></td></tr>
<tr class="memdesc:aa35974d42ec9564687ffbe5f664cb906"><td class="mdescLeft"> </td><td class="mdescRight">range type for iterating over finite facets. <br></td></tr>
<tr class="separator:aa35974d42ec9564687ffbe5f664cb906"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a514f885323d414200cd13e8fa6e79e34"><td class="memItemLeft" align="right" valign="top"><a id="a514f885323d414200cd13e8fa6e79e34" name="a514f885323d414200cd13e8fa6e79e34"></a>
typedef <a class="elRef" href="../STL_Extension/classCGAL_1_1Iterator__range.html">Iterator_range</a>&lt; <a class="el" href="classCGAL_1_1Triangulation__3.html#a1c91aeb6128d5bf33995dca02398d330">Finite_edges_iterator</a> &gt; </td><td class="memItemRight" valign="bottom"><b>Finite_edges</b></td></tr>
<tr class="memdesc:a514f885323d414200cd13e8fa6e79e34"><td class="mdescLeft"> </td><td class="mdescRight">range type for iterating over finite edges. <br></td></tr>
<tr class="separator:a514f885323d414200cd13e8fa6e79e34"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac59a8c8f173db4a1e72b537bb59e16a5"><td class="memItemLeft" align="right" valign="top"><a id="ac59a8c8f173db4a1e72b537bb59e16a5" name="ac59a8c8f173db4a1e72b537bb59e16a5"></a>
typedef <a class="elRef" href="../STL_Extension/classCGAL_1_1Iterator__range.html">Iterator_range</a>&lt; <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> &gt; </td><td class="memItemRight" valign="bottom"><b>Finite_vertex_handles</b></td></tr>
<tr class="memdesc:ac59a8c8f173db4a1e72b537bb59e16a5"><td class="mdescLeft"> </td><td class="mdescRight">range type for iterating over finite vertex handles, with a nested type <code>iterator</code> that has as value type <code>Vertex_handle</code>. <br></td></tr>
<tr class="separator:ac59a8c8f173db4a1e72b537bb59e16a5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5c8812f38413b29cdd7aae517c457d52"><td class="memItemLeft" align="right" valign="top"><a id="a5c8812f38413b29cdd7aae517c457d52" name="a5c8812f38413b29cdd7aae517c457d52"></a>
typedef <a class="elRef" href="../STL_Extension/classCGAL_1_1Iterator__range.html">Iterator_range</a>&lt; <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> &gt; </td><td class="memItemRight" valign="bottom"><b>Points</b></td></tr>
<tr class="memdesc:a5c8812f38413b29cdd7aae517c457d52"><td class="mdescLeft"> </td><td class="mdescRight">range type for iterating over the points of the finite vertices. <br></td></tr>
<tr class="separator:a5c8812f38413b29cdd7aae517c457d52"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0356538c3ef7d62280a7846c35a8abbb"><td class="memItemLeft" align="right" valign="top"><a id="a0356538c3ef7d62280a7846c35a8abbb" name="a0356538c3ef7d62280a7846c35a8abbb"></a>
typedef <a class="elRef" href="../STL_Extension/classCGAL_1_1Iterator__range.html">Iterator_range</a>&lt; <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> &gt; </td><td class="memItemRight" valign="bottom"><b>Segment_traverser_cell_handles</b></td></tr>
<tr class="memdesc:a0356538c3ef7d62280a7846c35a8abbb"><td class="mdescLeft"> </td><td class="mdescRight">range type for iterating over the cells intersected by a line segment. <br></td></tr>
<tr class="separator:a0356538c3ef7d62280a7846c35a8abbb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae4a0565708ab5c23639c90c47bbec7cc"><td class="memItemLeft" align="right" valign="top"><a id="ae4a0565708ab5c23639c90c47bbec7cc" name="ae4a0565708ab5c23639c90c47bbec7cc"></a>
typedef <a class="elRef" href="../STL_Extension/classCGAL_1_1Iterator__range.html">Iterator_range</a>&lt; <a class="el" href="classCGAL_1_1Triangulation__3.html#a822c7264ac03f629735cb85be4871e1f">Segment_simplex_iterator</a> &gt; </td><td class="memItemRight" valign="bottom"><b>Segment_traverser_simplices</b></td></tr>
<tr class="memdesc:ae4a0565708ab5c23639c90c47bbec7cc"><td class="mdescLeft"> </td><td class="mdescRight">range type for iterating over the simplices intersected by a line segment. <br></td></tr>
<tr class="separator:ae4a0565708ab5c23639c90c47bbec7cc"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Creation</h2></td></tr>
<tr class="memitem:a2378218ec06f4a4daec0102760da4d73"><td class="memItemLeft" align="right" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a2378218ec06f4a4daec0102760da4d73">Triangulation_3</a> (const <a class="el" href="classCGAL_1_1Triangulation__3.html#ab250045d0412b06d83977a0c2cf33ff9">Geom_traits</a> &amp;traits=<a class="el" href="classCGAL_1_1Triangulation__3.html#ab250045d0412b06d83977a0c2cf33ff9">Geom_traits</a>(), <a class="el" href="classCGAL_1_1Triangulation__3.html#a1f96730cb3b4cfd6c2893ecb7300ec90">Lock_data_structure</a> *lock_ds=nullptr)</td></tr>
<tr class="memdesc:a2378218ec06f4a4daec0102760da4d73"><td class="mdescLeft"> </td><td class="mdescRight">Introduces a triangulation <code>t</code> having only one vertex which is the infinite vertex.  <br></td></tr>
<tr class="separator:a2378218ec06f4a4daec0102760da4d73"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a43624064822f4553a51dbd159ecd1bdd"><td class="memItemLeft" align="right" valign="top"><a id="a43624064822f4553a51dbd159ecd1bdd" name="a43624064822f4553a51dbd159ecd1bdd"></a>
 </td><td class="memItemRight" valign="bottom"><b>Triangulation_3</b> (<a class="el" href="classCGAL_1_1Triangulation__3.html#a1f96730cb3b4cfd6c2893ecb7300ec90">Lock_data_structure</a> *lock_ds=nullptr, const <a class="el" href="classCGAL_1_1Triangulation__3.html#ab250045d0412b06d83977a0c2cf33ff9">Geom_traits</a> &amp;traits=<a class="el" href="classCGAL_1_1Triangulation__3.html#ab250045d0412b06d83977a0c2cf33ff9">Geom_traits</a>())</td></tr>
<tr class="memdesc:a43624064822f4553a51dbd159ecd1bdd"><td class="mdescLeft"> </td><td class="mdescRight">Same as the previous one, but with parameters in reverse order. <br></td></tr>
<tr class="separator:a43624064822f4553a51dbd159ecd1bdd"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7018c73a59388a6d005e8fea1b5c1c32"><td class="memItemLeft" align="right" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a7018c73a59388a6d005e8fea1b5c1c32">Triangulation_3</a> (const <a class="el" href="classCGAL_1_1Triangulation__3.html">Triangulation_3</a> &amp;tr)</td></tr>
<tr class="memdesc:a7018c73a59388a6d005e8fea1b5c1c32"><td class="mdescLeft"> </td><td class="mdescRight">Copy constructor.  <br></td></tr>
<tr class="separator:a7018c73a59388a6d005e8fea1b5c1c32"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a63f67cf6aaadcee14318cf56a36d247a"><td class="memTemplParams" colspan="2"><a id="a63f67cf6aaadcee14318cf56a36d247a" name="a63f67cf6aaadcee14318cf56a36d247a"></a>
template&lt;class <a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> &gt; </td></tr>
<tr class="memitem:a63f67cf6aaadcee14318cf56a36d247a"><td class="memTemplItemLeft" align="right" valign="top"> </td><td class="memTemplItemRight" valign="bottom"><b>Triangulation_3</b> (<a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> first, <a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> last, const <a class="el" href="classCGAL_1_1Triangulation__3.html#ab250045d0412b06d83977a0c2cf33ff9">Geom_traits</a> &amp;traits=<a class="el" href="classCGAL_1_1Triangulation__3.html#ab250045d0412b06d83977a0c2cf33ff9">Geom_traits</a>(), <a class="el" href="classCGAL_1_1Triangulation__3.html#a1f96730cb3b4cfd6c2893ecb7300ec90">Lock_data_structure</a> *lock_ds=nullptr)</td></tr>
<tr class="memdesc:a63f67cf6aaadcee14318cf56a36d247a"><td class="mdescLeft"> </td><td class="mdescRight">Equivalent to constructing an empty triangulation with the optional traits class argument and calling <code>insert(first,last)</code>. <br></td></tr>
<tr class="separator:a63f67cf6aaadcee14318cf56a36d247a"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Assignment</h2></td></tr>
<tr class="memitem:abc8aafe82c32f53203d8d97069ef838d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html">Triangulation_3</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#abc8aafe82c32f53203d8d97069ef838d">operator=</a> (const <a class="el" href="classCGAL_1_1Triangulation__3.html">Triangulation_3</a> &amp;tr)</td></tr>
<tr class="memdesc:abc8aafe82c32f53203d8d97069ef838d"><td class="mdescLeft"> </td><td class="mdescRight">The triangulation <code>tr</code> is duplicated, and modifying the copy after the duplication does not modify the original.  <br></td></tr>
<tr class="separator:abc8aafe82c32f53203d8d97069ef838d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a767066a964b4d7b14376e5f5d1a04b34"><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a767066a964b4d7b14376e5f5d1a04b34">swap</a> (<a class="el" href="classCGAL_1_1Triangulation__3.html">Triangulation_3</a> &amp;tr)</td></tr>
<tr class="memdesc:a767066a964b4d7b14376e5f5d1a04b34"><td class="mdescLeft"> </td><td class="mdescRight">The triangulations <code>tr</code> and <code>t</code> are swapped.  <br></td></tr>
<tr class="separator:a767066a964b4d7b14376e5f5d1a04b34"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0713863e5ff5ceb0a0eb290c4f6767c8"><td class="memItemLeft" align="right" valign="top"><a id="a0713863e5ff5ceb0a0eb290c4f6767c8" name="a0713863e5ff5ceb0a0eb290c4f6767c8"></a>
void </td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="memdesc:a0713863e5ff5ceb0a0eb290c4f6767c8"><td class="mdescLeft"> </td><td class="mdescRight">Deletes all finite vertices and all cells of <code>t</code>. <br></td></tr>
<tr class="separator:a0713863e5ff5ceb0a0eb290c4f6767c8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a20b6e473c9ba697893aed432ba3d9754"><td class="memTemplParams" colspan="2">template&lt;class GT , class Tds1 , class Tds2 &gt; </td></tr>
<tr class="memitem:a20b6e473c9ba697893aed432ba3d9754"><td class="memTemplItemLeft" align="right" valign="top">bool </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a20b6e473c9ba697893aed432ba3d9754">operator==</a> (const <a class="el" href="classCGAL_1_1Triangulation__3.html">Triangulation_3</a>&lt; GT, Tds1 &gt; &amp;t1, const <a class="el" href="classCGAL_1_1Triangulation__3.html">Triangulation_3</a>&lt; GT, Tds2 &gt; &amp;t2)</td></tr>
<tr class="memdesc:a20b6e473c9ba697893aed432ba3d9754"><td class="mdescLeft"> </td><td class="mdescRight">Equality operator.  <br></td></tr>
<tr class="separator:a20b6e473c9ba697893aed432ba3d9754"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afe3483443d5cc96aec2f0603095b95f5"><td class="memTemplParams" colspan="2"><a id="afe3483443d5cc96aec2f0603095b95f5" name="afe3483443d5cc96aec2f0603095b95f5"></a>
template&lt;class GT , class Tds1 , class Tds2 &gt; </td></tr>
<tr class="memitem:afe3483443d5cc96aec2f0603095b95f5"><td class="memTemplItemLeft" align="right" valign="top">bool </td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classCGAL_1_1Triangulation__3.html">Triangulation_3</a>&lt; GT, Tds1 &gt; &amp;t1, const <a class="el" href="classCGAL_1_1Triangulation__3.html">Triangulation_3</a>&lt; GT, Tds2 &gt; &amp;t2)</td></tr>
<tr class="memdesc:afe3483443d5cc96aec2f0603095b95f5"><td class="mdescLeft"> </td><td class="mdescRight">The opposite of <code>operator==</code>. <br></td></tr>
<tr class="separator:afe3483443d5cc96aec2f0603095b95f5"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Access Functions</h2></td></tr>
<tr class="memitem:a230ff1dd66791a699820d9865b5a8f4d"><td class="memItemLeft" align="right" valign="top"><a id="a230ff1dd66791a699820d9865b5a8f4d" name="a230ff1dd66791a699820d9865b5a8f4d"></a>
const <a class="el" href="classCGAL_1_1Triangulation__3.html#ab250045d0412b06d83977a0c2cf33ff9">Geom_traits</a> &amp; </td><td class="memItemRight" valign="bottom"><b>geom_traits</b> () const</td></tr>
<tr class="memdesc:a230ff1dd66791a699820d9865b5a8f4d"><td class="mdescLeft"> </td><td class="mdescRight">Returns a const reference to the geometric traits object. <br></td></tr>
<tr class="separator:a230ff1dd66791a699820d9865b5a8f4d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2caf4005a4dc8a221bfee2e4aeec569e"><td class="memItemLeft" align="right" valign="top"><a id="a2caf4005a4dc8a221bfee2e4aeec569e" name="a2caf4005a4dc8a221bfee2e4aeec569e"></a>
const <a class="el" href="classCGAL_1_1Triangulation__3.html#a142364d710a44fb68daf6cbd185861ce">Triangulation_data_structure</a> &amp; </td><td class="memItemRight" valign="bottom"><b>tds</b> () const</td></tr>
<tr class="memdesc:a2caf4005a4dc8a221bfee2e4aeec569e"><td class="mdescLeft"> </td><td class="mdescRight">Returns a const reference to the triangulation data structure. <br></td></tr>
<tr class="separator:a2caf4005a4dc8a221bfee2e4aeec569e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a951781437d62955aaae730b87c833498"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#a142364d710a44fb68daf6cbd185861ce">Triangulation_data_structure</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a951781437d62955aaae730b87c833498">tds</a> ()</td></tr>
<tr class="memdesc:a951781437d62955aaae730b87c833498"><td class="mdescLeft"> </td><td class="mdescRight">Returns a reference to the triangulation data structure.  <br></td></tr>
<tr class="separator:a951781437d62955aaae730b87c833498"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a80ba1634c96f534d18d2d2420f65561f"><td class="memItemLeft" align="right" valign="top"><a id="a80ba1634c96f534d18d2d2420f65561f" name="a80ba1634c96f534d18d2d2420f65561f"></a>
int </td><td class="memItemRight" valign="bottom"><b>dimension</b> () const</td></tr>
<tr class="memdesc:a80ba1634c96f534d18d2d2420f65561f"><td class="mdescLeft"> </td><td class="mdescRight">Returns the dimension of the affine hull. <br></td></tr>
<tr class="separator:a80ba1634c96f534d18d2d2420f65561f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a065228f3255a5d41d096fe782b61669f"><td class="memItemLeft" align="right" valign="top"><a id="a065228f3255a5d41d096fe782b61669f" name="a065228f3255a5d41d096fe782b61669f"></a>
<a class="el" href="classCGAL_1_1Triangulation__3.html#ab33c8cdfd6a571cf9635a531d2d261a0">size_type</a> </td><td class="memItemRight" valign="bottom"><b>number_of_vertices</b> () const</td></tr>
<tr class="memdesc:a065228f3255a5d41d096fe782b61669f"><td class="mdescLeft"> </td><td class="mdescRight">Returns the number of finite vertices. <br></td></tr>
<tr class="separator:a065228f3255a5d41d096fe782b61669f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2040b9c297817fb934d3d48908234d13"><td class="memItemLeft" align="right" valign="top"><a id="a2040b9c297817fb934d3d48908234d13" name="a2040b9c297817fb934d3d48908234d13"></a>
<a class="el" href="classCGAL_1_1Triangulation__3.html#ab33c8cdfd6a571cf9635a531d2d261a0">size_type</a> </td><td class="memItemRight" valign="bottom"><b>number_of_cells</b> () const</td></tr>
<tr class="memdesc:a2040b9c297817fb934d3d48908234d13"><td class="mdescLeft"> </td><td class="mdescRight">Returns the number of cells or 0 if <code>t.dimension() &lt; 3</code>. <br></td></tr>
<tr class="separator:a2040b9c297817fb934d3d48908234d13"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0dde82d53bcd9f705f3a676329c1df2d"><td class="memItemLeft" align="right" valign="top"><a id="a0dde82d53bcd9f705f3a676329c1df2d" name="a0dde82d53bcd9f705f3a676329c1df2d"></a>
<a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td><td class="memItemRight" valign="bottom"><b>infinite_vertex</b> ()</td></tr>
<tr class="memdesc:a0dde82d53bcd9f705f3a676329c1df2d"><td class="mdescLeft"> </td><td class="mdescRight">Returns the infinite vertex. <br></td></tr>
<tr class="separator:a0dde82d53bcd9f705f3a676329c1df2d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af50326c40f34f13a01bb0fd0935301f0"><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#af50326c40f34f13a01bb0fd0935301f0">set_infinite_vertex</a> (<a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> v)</td></tr>
<tr class="memdesc:af50326c40f34f13a01bb0fd0935301f0"><td class="mdescLeft"> </td><td class="mdescRight">This is an advanced function.  <br></td></tr>
<tr class="separator:af50326c40f34f13a01bb0fd0935301f0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4ef94a8a137601e4cb1905dcdad16c6c"><td class="memItemLeft" align="right" valign="top"><a id="a4ef94a8a137601e4cb1905dcdad16c6c" name="a4ef94a8a137601e4cb1905dcdad16c6c"></a>
<a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> </td><td class="memItemRight" valign="bottom"><b>infinite_cell</b> () const</td></tr>
<tr class="memdesc:a4ef94a8a137601e4cb1905dcdad16c6c"><td class="mdescLeft"> </td><td class="mdescRight">Returns a cell incident to the infinite vertex. <br></td></tr>
<tr class="separator:a4ef94a8a137601e4cb1905dcdad16c6c"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Non-Constant-Time Access Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>As previously said, the triangulation is a collection of cells that are either infinite or represent a finite tetrahedra, where an infinite cell is a cell incident to the infinite vertex.</p>
<p>Similarly we call an edge (resp. facet) <code>infinite</code> if it is incident to the infinite vertex. </p>
</td></tr>
<tr class="memitem:a014b6d2caf1747a3bf2865adb158cbb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#ab33c8cdfd6a571cf9635a531d2d261a0">size_type</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a014b6d2caf1747a3bf2865adb158cbb7">number_of_facets</a> () const</td></tr>
<tr class="memdesc:a014b6d2caf1747a3bf2865adb158cbb7"><td class="mdescLeft"> </td><td class="mdescRight">The number of facets.  <br></td></tr>
<tr class="separator:a014b6d2caf1747a3bf2865adb158cbb7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a05f820202e1348187eb69693b6ce3d44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#ab33c8cdfd6a571cf9635a531d2d261a0">size_type</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a05f820202e1348187eb69693b6ce3d44">number_of_edges</a> () const</td></tr>
<tr class="memdesc:a05f820202e1348187eb69693b6ce3d44"><td class="mdescLeft"> </td><td class="mdescRight">The number of edges.  <br></td></tr>
<tr class="separator:a05f820202e1348187eb69693b6ce3d44"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a584b3359337efc7f687513b7ef958b94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#ab33c8cdfd6a571cf9635a531d2d261a0">size_type</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a584b3359337efc7f687513b7ef958b94">number_of_finite_cells</a> () const</td></tr>
<tr class="memdesc:a584b3359337efc7f687513b7ef958b94"><td class="mdescLeft"> </td><td class="mdescRight">The number of finite cells.  <br></td></tr>
<tr class="separator:a584b3359337efc7f687513b7ef958b94"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af332a576da991acf508cbd4473249e0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#ab33c8cdfd6a571cf9635a531d2d261a0">size_type</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#af332a576da991acf508cbd4473249e0b">number_of_finite_facets</a> () const</td></tr>
<tr class="memdesc:af332a576da991acf508cbd4473249e0b"><td class="mdescLeft"> </td><td class="mdescRight">The number of finite facets.  <br></td></tr>
<tr class="separator:af332a576da991acf508cbd4473249e0b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a37efcac10647c16b7ea331e30493cb24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#ab33c8cdfd6a571cf9635a531d2d261a0">size_type</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a37efcac10647c16b7ea331e30493cb24">number_of_finite_edges</a> () const</td></tr>
<tr class="memdesc:a37efcac10647c16b7ea331e30493cb24"><td class="mdescLeft"> </td><td class="mdescRight">The number of finite edges.  <br></td></tr>
<tr class="separator:a37efcac10647c16b7ea331e30493cb24"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Geometric Access Functions</h2></td></tr>
<tr class="memitem:a83d347f8d914b78f17f6817fdb0b7a14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#aa88be907873b0469824cc3b2212f2eee">Tetrahedron</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a83d347f8d914b78f17f6817fdb0b7a14">tetrahedron</a> (<a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> c) const</td></tr>
<tr class="memdesc:a83d347f8d914b78f17f6817fdb0b7a14"><td class="mdescLeft"> </td><td class="mdescRight">Returns the tetrahedron formed by the four vertices of <code>c</code>.  <br></td></tr>
<tr class="separator:a83d347f8d914b78f17f6817fdb0b7a14"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac2efcfbc0dcef89c512f65e4d13d4563"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#adc409424d433ef56a79d5e71c02b8e15">Triangle</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac2efcfbc0dcef89c512f65e4d13d4563">triangle</a> (<a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> c, int i) const</td></tr>
<tr class="memdesc:ac2efcfbc0dcef89c512f65e4d13d4563"><td class="mdescLeft"> </td><td class="mdescRight">Returns the triangle formed by the three vertices of facet <code>(c,i)</code>.  <br></td></tr>
<tr class="separator:ac2efcfbc0dcef89c512f65e4d13d4563"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6f9a07c130cde8a27869944396ab09e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#adc409424d433ef56a79d5e71c02b8e15">Triangle</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a6f9a07c130cde8a27869944396ab09e7">triangle</a> (const <a class="el" href="classCGAL_1_1Triangulation__3.html#aa100228164b0cf78d5c2b1009c2df258">Facet</a> &amp;f) const</td></tr>
<tr class="memdesc:a6f9a07c130cde8a27869944396ab09e7"><td class="mdescLeft"> </td><td class="mdescRight">Same as the previous method for facet <code>f</code>.  <br></td></tr>
<tr class="separator:a6f9a07c130cde8a27869944396ab09e7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a22bb4874ea8dc28c07584f1f55628707"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#a2ee20454a8adb0ff5d6db5acabd10e05">Segment</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a22bb4874ea8dc28c07584f1f55628707">segment</a> (const <a class="el" href="classCGAL_1_1Triangulation__3.html#a0f355dbb38cf631f24d4df8abd7a942f">Edge</a> &amp;e) const</td></tr>
<tr class="memdesc:a22bb4874ea8dc28c07584f1f55628707"><td class="mdescLeft"> </td><td class="mdescRight">Returns the line segment formed by the vertices of <code>e</code>.  <br></td></tr>
<tr class="separator:a22bb4874ea8dc28c07584f1f55628707"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae28b76ae0e1f364fc55d1b67f5b57249"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#a2ee20454a8adb0ff5d6db5acabd10e05">Segment</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#ae28b76ae0e1f364fc55d1b67f5b57249">segment</a> (<a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> c, int i, int j) const</td></tr>
<tr class="memdesc:ae28b76ae0e1f364fc55d1b67f5b57249"><td class="mdescLeft"> </td><td class="mdescRight">Same as the previous method for edge <code>(c,i,j)</code>.  <br></td></tr>
<tr class="separator:ae28b76ae0e1f364fc55d1b67f5b57249"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad19deb77eb94761e9bf0934f39cb3fa5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#ad19deb77eb94761e9bf0934f39cb3fa5">point</a> (<a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> c, int i) const</td></tr>
<tr class="memdesc:ad19deb77eb94761e9bf0934f39cb3fa5"><td class="mdescLeft"> </td><td class="mdescRight">Returns the point given by vertex <code>i</code> of cell <code>c</code>.  <br></td></tr>
<tr class="separator:ad19deb77eb94761e9bf0934f39cb3fa5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a914f44aa77c5096630f94af46f98cab5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a914f44aa77c5096630f94af46f98cab5">point</a> (<a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> v) const</td></tr>
<tr class="memdesc:a914f44aa77c5096630f94af46f98cab5"><td class="mdescLeft"> </td><td class="mdescRight">Same as the previous method for vertex <code>v</code>.  <br></td></tr>
<tr class="separator:a914f44aa77c5096630f94af46f98cab5"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Tests for Finite and Infinite Vertices and Faces</h2></td></tr>
<tr class="memitem:a0a5aa10a1bb88f33b3f07d33f89dd5cc"><td class="memItemLeft" align="right" valign="top"><a id="a0a5aa10a1bb88f33b3f07d33f89dd5cc" name="a0a5aa10a1bb88f33b3f07d33f89dd5cc"></a>
bool </td><td class="memItemRight" valign="bottom"><b>is_infinite</b> (<a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> v) const</td></tr>
<tr class="memdesc:a0a5aa10a1bb88f33b3f07d33f89dd5cc"><td class="mdescLeft"> </td><td class="mdescRight"><code>true</code>, iff vertex <code>v</code> is the infinite vertex. <br></td></tr>
<tr class="separator:a0a5aa10a1bb88f33b3f07d33f89dd5cc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8bc2a0fa204265bf32f1e6dc103988b4"><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a8bc2a0fa204265bf32f1e6dc103988b4">is_infinite</a> (<a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> c) const</td></tr>
<tr class="memdesc:a8bc2a0fa204265bf32f1e6dc103988b4"><td class="mdescLeft"> </td><td class="mdescRight"><code>true</code>, iff <code>c</code> is incident to the infinite vertex.  <br></td></tr>
<tr class="separator:a8bc2a0fa204265bf32f1e6dc103988b4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad66e030d66fdf1ee66e4c280e8894c71"><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#ad66e030d66fdf1ee66e4c280e8894c71">is_infinite</a> (<a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> c, int i) const</td></tr>
<tr class="memdesc:ad66e030d66fdf1ee66e4c280e8894c71"><td class="mdescLeft"> </td><td class="mdescRight"><code>true</code>, iff the facet <code>i</code> of cell <code>c</code> is incident to the infinite vertex.  <br></td></tr>
<tr class="separator:ad66e030d66fdf1ee66e4c280e8894c71"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0ece46e036b7dabfd34fd4662973e221"><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a0ece46e036b7dabfd34fd4662973e221">is_infinite</a> (const <a class="el" href="classCGAL_1_1Triangulation__3.html#aa100228164b0cf78d5c2b1009c2df258">Facet</a> &amp;f) const</td></tr>
<tr class="memdesc:a0ece46e036b7dabfd34fd4662973e221"><td class="mdescLeft"> </td><td class="mdescRight"><code>true</code> iff facet <code>f</code> is incident to the infinite vertex.  <br></td></tr>
<tr class="separator:a0ece46e036b7dabfd34fd4662973e221"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab84793de9c9899d8ecc33cdac411d324"><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#ab84793de9c9899d8ecc33cdac411d324">is_infinite</a> (<a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> c, int i, int j) const</td></tr>
<tr class="memdesc:ab84793de9c9899d8ecc33cdac411d324"><td class="mdescLeft"> </td><td class="mdescRight"><code>true</code>, iff the edge <code>(i,j)</code> of cell <code>c</code> is incident to the infinite vertex.  <br></td></tr>
<tr class="separator:ab84793de9c9899d8ecc33cdac411d324"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6ca23f6bdd390ac23e7829e7f326efd5"><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a6ca23f6bdd390ac23e7829e7f326efd5">is_infinite</a> (const <a class="el" href="classCGAL_1_1Triangulation__3.html#a0f355dbb38cf631f24d4df8abd7a942f">Edge</a> &amp;e) const</td></tr>
<tr class="memdesc:a6ca23f6bdd390ac23e7829e7f326efd5"><td class="mdescLeft"> </td><td class="mdescRight"><code>true</code> iff edge <code>e</code> is incident to the infinite vertex.  <br></td></tr>
<tr class="separator:a6ca23f6bdd390ac23e7829e7f326efd5"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Queries</h2></td></tr>
<tr class="memitem:a5b45572c663e5d2c10f26e7be421e140"><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a5b45572c663e5d2c10f26e7be421e140">is_vertex</a> (const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp;p, <a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> &amp;v) const</td></tr>
<tr class="memdesc:a5b45572c663e5d2c10f26e7be421e140"><td class="mdescLeft"> </td><td class="mdescRight">Tests whether <code>p</code> is a vertex of <code>t</code> by locating <code>p</code> in the triangulation.  <br></td></tr>
<tr class="separator:a5b45572c663e5d2c10f26e7be421e140"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1d1c9daa1c2031a66c9acc0a958bdb8e"><td class="memItemLeft" align="right" valign="top"><a id="a1d1c9daa1c2031a66c9acc0a958bdb8e" name="a1d1c9daa1c2031a66c9acc0a958bdb8e"></a>
bool </td><td class="memItemRight" valign="bottom"><b>is_vertex</b> (<a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> v) const</td></tr>
<tr class="memdesc:a1d1c9daa1c2031a66c9acc0a958bdb8e"><td class="mdescLeft"> </td><td class="mdescRight">Tests whether <code>v</code> is a vertex of <code>t</code>. <br></td></tr>
<tr class="separator:a1d1c9daa1c2031a66c9acc0a958bdb8e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a55b3dd5c4161a2612bd8aa60d64fb4f1"><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a55b3dd5c4161a2612bd8aa60d64fb4f1">is_edge</a> (<a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> u, <a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> v, <a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> &amp;c, int &amp;i, int &amp;j) const</td></tr>
<tr class="memdesc:a55b3dd5c4161a2612bd8aa60d64fb4f1"><td class="mdescLeft"> </td><td class="mdescRight">Tests whether <code>(u,v)</code> is an edge of <code>t</code>.  <br></td></tr>
<tr class="separator:a55b3dd5c4161a2612bd8aa60d64fb4f1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aef7c688eb2a28c0aec936c41df46a172"><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#aef7c688eb2a28c0aec936c41df46a172">is_facet</a> (<a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> u, <a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> v, <a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> w, <a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> &amp;c, int &amp;i, int &amp;j, int &amp;k) const</td></tr>
<tr class="memdesc:aef7c688eb2a28c0aec936c41df46a172"><td class="mdescLeft"> </td><td class="mdescRight">Tests whether <code>(u,v,w)</code> is a facet of <code>t</code>.  <br></td></tr>
<tr class="separator:aef7c688eb2a28c0aec936c41df46a172"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0b9e348637a4c392f71fed0ef3ff2ad8"><td class="memItemLeft" align="right" valign="top"><a id="a0b9e348637a4c392f71fed0ef3ff2ad8" name="a0b9e348637a4c392f71fed0ef3ff2ad8"></a>
bool </td><td class="memItemRight" valign="bottom"><b>is_cell</b> (<a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> c) const</td></tr>
<tr class="memdesc:a0b9e348637a4c392f71fed0ef3ff2ad8"><td class="mdescLeft"> </td><td class="mdescRight">Tests whether <code>c</code> is a cell of <code>t</code>. <br></td></tr>
<tr class="separator:a0b9e348637a4c392f71fed0ef3ff2ad8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a24095561c8bd3390a58f7b7c9e45d4eb"><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a24095561c8bd3390a58f7b7c9e45d4eb">is_cell</a> (<a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> u, <a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> v, <a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> w, <a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> x, <a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> &amp;c, int &amp;i, int &amp;j, int &amp;k, int &amp;l) const</td></tr>
<tr class="memdesc:a24095561c8bd3390a58f7b7c9e45d4eb"><td class="mdescLeft"> </td><td class="mdescRight">Tests whether <code>(u,v,w,x)</code> is a cell of <code>t</code>.  <br></td></tr>
<tr class="separator:a24095561c8bd3390a58f7b7c9e45d4eb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8766c9a0c2a84203be31537e5e015646"><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a8766c9a0c2a84203be31537e5e015646">is_cell</a> (<a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> u, <a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> v, <a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> w, <a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> x, <a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> &amp;c) const</td></tr>
<tr class="memdesc:a8766c9a0c2a84203be31537e5e015646"><td class="mdescLeft"> </td><td class="mdescRight">Tests whether <code>(u,v,w,x)</code> is a cell of <code>t</code> and computes this cell <code>c</code>.  <br></td></tr>
<tr class="separator:a8766c9a0c2a84203be31537e5e015646"><td class="memSeparator" colspan="2"> </td></tr>
<tr><td class="ititle" colspan="2"><p>There is a method <code><a class="el" href="classCGAL_1_1Triangulation__3.html#a89a5c93d1e8a43cef317ef289f1d5482" title="If v is a vertex of f, then j is the index of v in the cell f.first, and the method returns true.">has_vertex()</a></code> in the cell class.</p>
<p>The analogous methods for facets are defined here. </p>
</td></tr>
<tr class="memitem:a89a5c93d1e8a43cef317ef289f1d5482"><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a89a5c93d1e8a43cef317ef289f1d5482">has_vertex</a> (const <a class="el" href="classCGAL_1_1Triangulation__3.html#aa100228164b0cf78d5c2b1009c2df258">Facet</a> &amp;f, <a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> v, int &amp;j) const</td></tr>
<tr class="memdesc:a89a5c93d1e8a43cef317ef289f1d5482"><td class="mdescLeft"> </td><td class="mdescRight">If <code>v</code> is a vertex of <code>f</code>, then <code>j</code> is the index of <code>v</code> in the cell <code>f.first</code>, and the method returns <code>true</code>.  <br></td></tr>
<tr class="separator:a89a5c93d1e8a43cef317ef289f1d5482"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abf51c96f47c1e295fb984ad521634229"><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#abf51c96f47c1e295fb984ad521634229">has_vertex</a> (<a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> c, int i, <a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> v, int &amp;j) const</td></tr>
<tr class="memdesc:abf51c96f47c1e295fb984ad521634229"><td class="mdescLeft"> </td><td class="mdescRight">Same for facet <code>(c,i)</code>.  <br></td></tr>
<tr class="separator:abf51c96f47c1e295fb984ad521634229"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a21e33ef0b19042320b461a0a7a0f4e36"><td class="memItemLeft" align="right" valign="top"><a id="a21e33ef0b19042320b461a0a7a0f4e36" name="a21e33ef0b19042320b461a0a7a0f4e36"></a>
bool </td><td class="memItemRight" valign="bottom"><b>has_vertex</b> (const <a class="el" href="classCGAL_1_1Triangulation__3.html#aa100228164b0cf78d5c2b1009c2df258">Facet</a> &amp;f, <a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> v) const</td></tr>
<tr class="separator:a21e33ef0b19042320b461a0a7a0f4e36"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9d997837c2cb5ecca65658ccf6dc3010"><td class="memItemLeft" align="right" valign="top"><a id="a9d997837c2cb5ecca65658ccf6dc3010" name="a9d997837c2cb5ecca65658ccf6dc3010"></a>
bool </td><td class="memItemRight" valign="bottom"><b>has_vertex</b> (<a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> c, int i, <a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> v) const</td></tr>
<tr class="memdesc:a9d997837c2cb5ecca65658ccf6dc3010"><td class="mdescLeft"> </td><td class="mdescRight">Same as the first two methods, but these two methods do not return the index of the vertex. <br></td></tr>
<tr class="separator:a9d997837c2cb5ecca65658ccf6dc3010"><td class="memSeparator" colspan="2"> </td></tr>
<tr><td class="ititle" colspan="2"><p>The following three methods test whether two facets have the same vertices. </p>
</td></tr>
<tr class="memitem:a04ae7357b56d2bc5bd18c657e5577f79"><td class="memItemLeft" align="right" valign="top"><a id="a04ae7357b56d2bc5bd18c657e5577f79" name="a04ae7357b56d2bc5bd18c657e5577f79"></a>
bool </td><td class="memItemRight" valign="bottom"><b>are_equal</b> (<a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> c, int i, <a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> n, int j) const</td></tr>
<tr class="separator:a04ae7357b56d2bc5bd18c657e5577f79"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0460db28850be85188a8dec7c2425c3d"><td class="memItemLeft" align="right" valign="top"><a id="a0460db28850be85188a8dec7c2425c3d" name="a0460db28850be85188a8dec7c2425c3d"></a>
bool </td><td class="memItemRight" valign="bottom"><b>are_equal</b> (const <a class="el" href="classCGAL_1_1Triangulation__3.html#aa100228164b0cf78d5c2b1009c2df258">Facet</a> &amp;f, const <a class="el" href="classCGAL_1_1Triangulation__3.html#aa100228164b0cf78d5c2b1009c2df258">Facet</a> &amp;g) const</td></tr>
<tr class="separator:a0460db28850be85188a8dec7c2425c3d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9f0c69f352b9e7fd325980807778b031"><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a9f0c69f352b9e7fd325980807778b031">are_equal</a> (const <a class="el" href="classCGAL_1_1Triangulation__3.html#aa100228164b0cf78d5c2b1009c2df258">Facet</a> &amp;f, <a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> n, int j) const</td></tr>
<tr class="memdesc:a9f0c69f352b9e7fd325980807778b031"><td class="mdescLeft"> </td><td class="mdescRight">For these three methods:  <br></td></tr>
<tr class="separator:a9f0c69f352b9e7fd325980807778b031"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Point Location</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>The class <code><a class="el" href="classCGAL_1_1Triangulation__3.html" title="The class Triangulation_3 represents a 3-dimensional tetrahedralization of points.">Triangulation_3</a></code> provides two functions to locate a given point with respect to a triangulation.</p>
<p>It provides also functions to test if a given point is inside a finite face or not. Note that the class <code><a class="el" href="classCGAL_1_1Delaunay__triangulation__3.html" title="The class Delaunay_triangulation_3 represents a three-dimensional Delaunay triangulation.">Delaunay_triangulation_3</a></code> also provides a <code>nearest_vertex()</code> function. </p>
</td></tr>
<tr class="memitem:a02a4a18074670282f3704f32b0901fad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a02a4a18074670282f3704f32b0901fad">locate</a> (const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp;query, <a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> start=<a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a>(), bool *could_lock_zone=nullptr) const</td></tr>
<tr class="memdesc:a02a4a18074670282f3704f32b0901fad"><td class="mdescLeft"> </td><td class="mdescRight">If the point <code>query</code> lies inside the convex hull of the points, the cell that contains the query in its interior is returned.  <br></td></tr>
<tr class="separator:a02a4a18074670282f3704f32b0901fad"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a573cd639a2fdb12f400c0074597a5adc"><td class="memItemLeft" align="right" valign="top"><a id="a573cd639a2fdb12f400c0074597a5adc" name="a573cd639a2fdb12f400c0074597a5adc"></a>
<a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> </td><td class="memItemRight" valign="bottom"><b>locate</b> (const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp;query, <a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> hint, bool *could_lock_zone=nullptr) const</td></tr>
<tr class="memdesc:a573cd639a2fdb12f400c0074597a5adc"><td class="mdescLeft"> </td><td class="mdescRight">Same as above but uses <code>hint</code> as the starting place for the search. <br></td></tr>
<tr class="separator:a573cd639a2fdb12f400c0074597a5adc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af33632f0d268cc25d0df2caa57f69609"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#af33632f0d268cc25d0df2caa57f69609">inexact_locate</a> (const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp;query, <a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> start=<a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a>()) const</td></tr>
<tr class="memdesc:af33632f0d268cc25d0df2caa57f69609"><td class="mdescLeft"> </td><td class="mdescRight">Same as <code><a class="el" href="classCGAL_1_1Triangulation__3.html#a02a4a18074670282f3704f32b0901fad" title="If the point query lies inside the convex hull of the points, the cell that contains the query in its...">locate()</a></code> but uses inexact predicates.  <br></td></tr>
<tr class="separator:af33632f0d268cc25d0df2caa57f69609"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a384e93b6ff4614ed3b35bcf8981520c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a384e93b6ff4614ed3b35bcf8981520c7">locate</a> (const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp;query, <a class="el" href="classCGAL_1_1Triangulation__3.html#a5bea7d3470854571f97c18a675daca75">Locate_type</a> &amp;lt, int &amp;li, int &amp;lj, <a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> start=<a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a>(), bool *could_lock_zone=nullptr) const</td></tr>
<tr class="memdesc:a384e93b6ff4614ed3b35bcf8981520c7"><td class="mdescLeft"> </td><td class="mdescRight">If <code>query</code> lies inside the affine hull of the points, the \( k\)-face (finite or infinite) that contains <code>query</code> in its interior is returned, by means of the cell returned together with <code>lt</code>, which is set to the locate type of the query (<code>VERTEX, EDGE, FACET, CELL</code>, or <code>OUTSIDE_CONVEX_HULL</code> if the cell is infinite and <code>query</code> lies strictly in it) and two indices <code>li</code> and <code>lj</code> that specify the \( k\)-face of the cell containing <code>query</code>.  <br></td></tr>
<tr class="separator:a384e93b6ff4614ed3b35bcf8981520c7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae26c070d4e465b8c6f95d63318080fe7"><td class="memItemLeft" align="right" valign="top"><a id="ae26c070d4e465b8c6f95d63318080fe7" name="ae26c070d4e465b8c6f95d63318080fe7"></a>
<a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> </td><td class="memItemRight" valign="bottom"><b>locate</b> (const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp;query, <a class="el" href="classCGAL_1_1Triangulation__3.html#a5bea7d3470854571f97c18a675daca75">Locate_type</a> &amp;lt, int &amp;li, int &amp;lj, <a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> hint, bool *could_lock_zone=nullptr) const</td></tr>
<tr class="memdesc:ae26c070d4e465b8c6f95d63318080fe7"><td class="mdescLeft"> </td><td class="mdescRight">Same as above but uses <code>hint</code> as the starting place for the search. <br></td></tr>
<tr class="separator:ae26c070d4e465b8c6f95d63318080fe7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0ad86d1f011118565cbef93ad35d673b"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="../Kernel_23/group__kernel__enums.html#gaf6030e89dadcc1f45369b0cdc5d9e111">Bounded_side</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a0ad86d1f011118565cbef93ad35d673b">side_of_cell</a> (const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp;p, <a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> c, <a class="el" href="classCGAL_1_1Triangulation__3.html#a5bea7d3470854571f97c18a675daca75">Locate_type</a> &amp;lt, int &amp;li, int &amp;lj) const</td></tr>
<tr class="memdesc:a0ad86d1f011118565cbef93ad35d673b"><td class="mdescLeft"> </td><td class="mdescRight">Returns a value indicating on which side of the oriented boundary of <code>c</code> the point <code>p</code> lies.  <br></td></tr>
<tr class="separator:a0ad86d1f011118565cbef93ad35d673b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6f26ad9ce68fbe3cb97ed211a68ab21f"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="../Kernel_23/group__kernel__enums.html#gaf6030e89dadcc1f45369b0cdc5d9e111">Bounded_side</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a6f26ad9ce68fbe3cb97ed211a68ab21f">side_of_facet</a> (const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp;p, const <a class="el" href="classCGAL_1_1Triangulation__3.html#aa100228164b0cf78d5c2b1009c2df258">Facet</a> &amp;f, <a class="el" href="classCGAL_1_1Triangulation__3.html#a5bea7d3470854571f97c18a675daca75">Locate_type</a> &amp;lt, int &amp;li, int &amp;lj) const</td></tr>
<tr class="memdesc:a6f26ad9ce68fbe3cb97ed211a68ab21f"><td class="mdescLeft"> </td><td class="mdescRight">Returns a value indicating on which side of the oriented boundary of <code>f</code> the point <code>p</code> lies:  <br></td></tr>
<tr class="separator:a6f26ad9ce68fbe3cb97ed211a68ab21f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4b2b97440867950f7a7723262bf93462"><td class="memItemLeft" align="right" valign="top"><a id="a4b2b97440867950f7a7723262bf93462" name="a4b2b97440867950f7a7723262bf93462"></a>
<a class="elRef" href="../Kernel_23/group__kernel__enums.html#gaf6030e89dadcc1f45369b0cdc5d9e111">Bounded_side</a> </td><td class="memItemRight" valign="bottom"><b>side_of_facet</b> (const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp;p, <a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> c, <a class="el" href="classCGAL_1_1Triangulation__3.html#a5bea7d3470854571f97c18a675daca75">Locate_type</a> &amp;lt, int &amp;li, int &amp;lj) const</td></tr>
<tr class="memdesc:a4b2b97440867950f7a7723262bf93462"><td class="mdescLeft"> </td><td class="mdescRight">Same as the previous method for the facet <code>(c,3)</code>. <br></td></tr>
<tr class="separator:a4b2b97440867950f7a7723262bf93462"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3155746fefa1a1f87a834b4d575c904b"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="../Kernel_23/group__kernel__enums.html#gaf6030e89dadcc1f45369b0cdc5d9e111">Bounded_side</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a3155746fefa1a1f87a834b4d575c904b">side_of_edge</a> (const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp;p, const <a class="el" href="classCGAL_1_1Triangulation__3.html#a0f355dbb38cf631f24d4df8abd7a942f">Edge</a> &amp;e, <a class="el" href="classCGAL_1_1Triangulation__3.html#a5bea7d3470854571f97c18a675daca75">Locate_type</a> &amp;lt, int &amp;li) const</td></tr>
<tr class="memdesc:a3155746fefa1a1f87a834b4d575c904b"><td class="mdescLeft"> </td><td class="mdescRight">Returns a value indicating on which side of the oriented boundary of <code>e</code> the point <code>p</code> lies:  <br></td></tr>
<tr class="separator:a3155746fefa1a1f87a834b4d575c904b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a60b867e74736abf01e8ce50e13c0aa9a"><td class="memItemLeft" align="right" valign="top"><a id="a60b867e74736abf01e8ce50e13c0aa9a" name="a60b867e74736abf01e8ce50e13c0aa9a"></a>
<a class="elRef" href="../Kernel_23/group__kernel__enums.html#gaf6030e89dadcc1f45369b0cdc5d9e111">Bounded_side</a> </td><td class="memItemRight" valign="bottom"><b>side_of_edge</b> (const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp;p, <a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> c, <a class="el" href="classCGAL_1_1Triangulation__3.html#a5bea7d3470854571f97c18a675daca75">Locate_type</a> &amp;lt, int &amp;li) const</td></tr>
<tr class="memdesc:a60b867e74736abf01e8ce50e13c0aa9a"><td class="mdescLeft"> </td><td class="mdescRight">Same as the previous method for edge \( (c,0,1)\). <br></td></tr>
<tr class="separator:a60b867e74736abf01e8ce50e13c0aa9a"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Flips</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Two kinds of flips exist for a three-dimensional triangulation.</p>
<p>They are reciprocal. To be flipped, an edge must be incident to three tetrahedra. During the flip, these three tetrahedra disappear and two tetrahedra appear. <a class="el" href="classCGAL_1_1Triangulation__3.html#fig__Triangulation3figflips">Figure 46.1</a> (left) shows the edge that is flipped as bold dashed, and one of its three incident facets is shaded. On the right, the facet shared by the two new tetrahedra is shaded. Flips are possible only under the following conditions: - the edge or facet to be flipped is not on the boundary of the convex hull of the triangulation - the five points involved are in convex position.</p>
<p><a class="anchor" id="fig__Triangulation3figflips"></a> </p><div class="image">
<img src="flips.png" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="classCGAL_1_1Triangulation__3.html#fig__Triangulation3figflips">Figure 46.1</a> Flips </p> </div> <p> <br>
</p>
<p>The following methods guarantee the validity of the resulting 3D triangulation. Flips for a 2d triangulation are not implemented yet. </p>
</td></tr>
<tr class="memitem:a883fed00b53cae9e85feb20230f54dd9"><td class="memItemLeft" align="right" valign="top"><a id="a883fed00b53cae9e85feb20230f54dd9" name="a883fed00b53cae9e85feb20230f54dd9"></a>
bool </td><td class="memItemRight" valign="bottom"><b>flip</b> (<a class="el" href="classCGAL_1_1Triangulation__3.html#a0f355dbb38cf631f24d4df8abd7a942f">Edge</a> e)</td></tr>
<tr class="separator:a883fed00b53cae9e85feb20230f54dd9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5dfdcfc38bf0bf30860d26d0fef7fdc7"><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a5dfdcfc38bf0bf30860d26d0fef7fdc7">flip</a> (<a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> c, int i, int j)</td></tr>
<tr class="memdesc:a5dfdcfc38bf0bf30860d26d0fef7fdc7"><td class="mdescLeft"> </td><td class="mdescRight">Before flipping, these methods check that edge <code>e=(c,i,j)</code> is flippable (which is quite expensive).  <br></td></tr>
<tr class="separator:a5dfdcfc38bf0bf30860d26d0fef7fdc7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a54b04cf190a4643d43dd67cd808b7fad"><td class="memItemLeft" align="right" valign="top"><a id="a54b04cf190a4643d43dd67cd808b7fad" name="a54b04cf190a4643d43dd67cd808b7fad"></a>
void </td><td class="memItemRight" valign="bottom"><b>flip_flippable</b> (<a class="el" href="classCGAL_1_1Triangulation__3.html#a0f355dbb38cf631f24d4df8abd7a942f">Edge</a> e)</td></tr>
<tr class="separator:a54b04cf190a4643d43dd67cd808b7fad"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac31682068c1ff25dc5ccd6f366fd1156"><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac31682068c1ff25dc5ccd6f366fd1156">flip_flippable</a> (<a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> c, int i, int j)</td></tr>
<tr class="memdesc:ac31682068c1ff25dc5ccd6f366fd1156"><td class="mdescLeft"> </td><td class="mdescRight">Should be preferred to the previous methods when the edge is known to be flippable.  <br></td></tr>
<tr class="separator:ac31682068c1ff25dc5ccd6f366fd1156"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a659e70e1b740a44b7d6b9886d323f571"><td class="memItemLeft" align="right" valign="top"><a id="a659e70e1b740a44b7d6b9886d323f571" name="a659e70e1b740a44b7d6b9886d323f571"></a>
bool </td><td class="memItemRight" valign="bottom"><b>flip</b> (<a class="el" href="classCGAL_1_1Triangulation__3.html#aa100228164b0cf78d5c2b1009c2df258">Facet</a> f)</td></tr>
<tr class="separator:a659e70e1b740a44b7d6b9886d323f571"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8050a0e63dcf0fed2e205ce69b0fa2fe"><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a8050a0e63dcf0fed2e205ce69b0fa2fe">flip</a> (<a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> c, int i)</td></tr>
<tr class="memdesc:a8050a0e63dcf0fed2e205ce69b0fa2fe"><td class="mdescLeft"> </td><td class="mdescRight">Before flipping, these methods check that facet <code>f=(c,i)</code> is flippable (which is quite expensive).  <br></td></tr>
<tr class="separator:a8050a0e63dcf0fed2e205ce69b0fa2fe"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2547de40ced9bfa49e16ff4ba2e1c52f"><td class="memItemLeft" align="right" valign="top"><a id="a2547de40ced9bfa49e16ff4ba2e1c52f" name="a2547de40ced9bfa49e16ff4ba2e1c52f"></a>
void </td><td class="memItemRight" valign="bottom"><b>flip_flippable</b> (<a class="el" href="classCGAL_1_1Triangulation__3.html#aa100228164b0cf78d5c2b1009c2df258">Facet</a> f)</td></tr>
<tr class="separator:a2547de40ced9bfa49e16ff4ba2e1c52f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1d8720ff50a61985bcbe474268d9d275"><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1d8720ff50a61985bcbe474268d9d275">flip_flippable</a> (<a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> c, int i)</td></tr>
<tr class="memdesc:a1d8720ff50a61985bcbe474268d9d275"><td class="mdescLeft"> </td><td class="mdescRight">Should be preferred to the previous methods when the facet is known to be flippable.  <br></td></tr>
<tr class="separator:a1d8720ff50a61985bcbe474268d9d275"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Insertions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>The following operations are guaranteed to lead to a valid triangulation when they are applied on a valid triangulation. </p>
</td></tr>
<tr class="memitem:ad8d7a1aa3b310ba8d86ede726746fcb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#ad8d7a1aa3b310ba8d86ede726746fcb3">insert</a> (const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp;p, <a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> start=<a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a>())</td></tr>
<tr class="memdesc:ad8d7a1aa3b310ba8d86ede726746fcb3"><td class="mdescLeft"> </td><td class="mdescRight">Inserts the point <code>p</code> in the triangulation and returns the corresponding vertex.  <br></td></tr>
<tr class="separator:ad8d7a1aa3b310ba8d86ede726746fcb3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a579619f972362fa8cd35d1de72dd677c"><td class="memItemLeft" align="right" valign="top"><a id="a579619f972362fa8cd35d1de72dd677c" name="a579619f972362fa8cd35d1de72dd677c"></a>
<a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td><td class="memItemRight" valign="bottom"><b>insert</b> (const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp;p, <a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> hint)</td></tr>
<tr class="memdesc:a579619f972362fa8cd35d1de72dd677c"><td class="mdescLeft"> </td><td class="mdescRight">Same as above but uses <code>hint</code> as the starting place for the search. <br></td></tr>
<tr class="separator:a579619f972362fa8cd35d1de72dd677c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af41ac521888fafda75100fcd36650aa4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#af41ac521888fafda75100fcd36650aa4">insert</a> (const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp;p, <a class="el" href="classCGAL_1_1Triangulation__3.html#a5bea7d3470854571f97c18a675daca75">Locate_type</a> lt, <a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> loc, int li, int lj)</td></tr>
<tr class="memdesc:af41ac521888fafda75100fcd36650aa4"><td class="mdescLeft"> </td><td class="mdescRight">Inserts the point <code>p</code> in the triangulation and returns the corresponding vertex.  <br></td></tr>
<tr class="separator:af41ac521888fafda75100fcd36650aa4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad3353128386bbb51f79d0263e7f67337"><td class="memTemplParams" colspan="2"><a id="ad3353128386bbb51f79d0263e7f67337" name="ad3353128386bbb51f79d0263e7f67337"></a>
template&lt;class PointInputIterator &gt; </td></tr>
<tr class="memitem:ad3353128386bbb51f79d0263e7f67337"><td class="memTemplItemLeft" align="right" valign="top">std::ptrdiff_t </td><td class="memTemplItemRight" valign="bottom"><b>insert</b> (PointInputIterator first, PointInputIterator last)</td></tr>
<tr class="memdesc:ad3353128386bbb51f79d0263e7f67337"><td class="mdescLeft"> </td><td class="mdescRight">Inserts the points in the range <code>[first,last)</code> in the given order, and returns the number of inserted points. <br></td></tr>
<tr class="separator:ad3353128386bbb51f79d0263e7f67337"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8aa85f88733d30aa3ec5385538e13ace"><td class="memTemplParams" colspan="2">template&lt;class PointWithInfoInputIterator &gt; </td></tr>
<tr class="memitem:a8aa85f88733d30aa3ec5385538e13ace"><td class="memTemplItemLeft" align="right" valign="top">std::ptrdiff_t </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a8aa85f88733d30aa3ec5385538e13ace">insert</a> (PointWithInfoInputIterator first, PointWithInfoInputIterator last)</td></tr>
<tr class="memdesc:a8aa85f88733d30aa3ec5385538e13ace"><td class="mdescLeft"> </td><td class="mdescRight">Inserts the points in the iterator range <code>[first,last)</code> in the given order, and returns the number of inserted points.  <br></td></tr>
<tr class="separator:a8aa85f88733d30aa3ec5385538e13ace"><td class="memSeparator" colspan="2"> </td></tr>
<tr><td class="ititle" colspan="2"><p>We also provide some other methods that can be used instead of <code>Triangulatation_3::insert()</code> when the place where the new point must be inserted is already known.</p>
<p>They are also guaranteed to lead to a valid triangulation when they are applied on a valid triangulation. </p>
</td></tr>
<tr class="memitem:aff8be2085c18e293f6d1a26c282acbc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#aff8be2085c18e293f6d1a26c282acbc7">insert_in_cell</a> (const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp;p, <a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> c)</td></tr>
<tr class="memdesc:aff8be2085c18e293f6d1a26c282acbc7"><td class="mdescLeft"> </td><td class="mdescRight">Inserts the point <code>p</code> in the cell <code>c</code>.  <br></td></tr>
<tr class="separator:aff8be2085c18e293f6d1a26c282acbc7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a80f8771ed8bca545ca451afae14b77ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a80f8771ed8bca545ca451afae14b77ed">insert_in_facet</a> (const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp;p, const <a class="el" href="classCGAL_1_1Triangulation__3.html#aa100228164b0cf78d5c2b1009c2df258">Facet</a> &amp;f)</td></tr>
<tr class="memdesc:a80f8771ed8bca545ca451afae14b77ed"><td class="mdescLeft"> </td><td class="mdescRight">Inserts the point <code>p</code> in the facet <code>f</code>.  <br></td></tr>
<tr class="separator:a80f8771ed8bca545ca451afae14b77ed"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa43e9ac9d97a9a2fa18ae18e21bb25b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#aa43e9ac9d97a9a2fa18ae18e21bb25b3">insert_in_facet</a> (const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp;p, <a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> c, int i)</td></tr>
<tr class="memdesc:aa43e9ac9d97a9a2fa18ae18e21bb25b3"><td class="mdescLeft"> </td><td class="mdescRight">As above, insertion in the facet <code>(c,i)</code>.  <br></td></tr>
<tr class="separator:aa43e9ac9d97a9a2fa18ae18e21bb25b3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5c1349d7fcffeac6f98cfc8b8febf564"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a5c1349d7fcffeac6f98cfc8b8febf564">insert_in_edge</a> (const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp;p, const <a class="el" href="classCGAL_1_1Triangulation__3.html#a0f355dbb38cf631f24d4df8abd7a942f">Edge</a> &amp;e)</td></tr>
<tr class="memdesc:a5c1349d7fcffeac6f98cfc8b8febf564"><td class="mdescLeft"> </td><td class="mdescRight">Inserts <code>p</code> in the edge <code>e</code>.  <br></td></tr>
<tr class="separator:a5c1349d7fcffeac6f98cfc8b8febf564"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a06ba9d64000edc9e5d595ae1c7595922"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a06ba9d64000edc9e5d595ae1c7595922">insert_in_edge</a> (const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp;p, <a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> c, int i, int j)</td></tr>
<tr class="memdesc:a06ba9d64000edc9e5d595ae1c7595922"><td class="mdescLeft"> </td><td class="mdescRight">As above, inserts <code>p</code> in the edge \( (i, j)\) of <code>c</code>.  <br></td></tr>
<tr class="separator:a06ba9d64000edc9e5d595ae1c7595922"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2798aa7502b4929ccaa8cab9bacbff18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a2798aa7502b4929ccaa8cab9bacbff18">insert_outside_convex_hull</a> (const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp;p, <a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> c)</td></tr>
<tr class="memdesc:a2798aa7502b4929ccaa8cab9bacbff18"><td class="mdescLeft"> </td><td class="mdescRight">The cell <code>c</code> must be an infinite cell containing <code>p</code>.  <br></td></tr>
<tr class="separator:a2798aa7502b4929ccaa8cab9bacbff18"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6f3e038498843f6ce7c0c70015ddaff9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a6f3e038498843f6ce7c0c70015ddaff9">insert_outside_affine_hull</a> (const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp;p)</td></tr>
<tr class="memdesc:a6f3e038498843f6ce7c0c70015ddaff9"><td class="mdescLeft"> </td><td class="mdescRight"><code>p</code> is linked to all the points, and the infinite vertex is linked to all the points (including <code>p</code>) to triangulate the new infinite face, so that all the points now belong to the boundary of the convex hull.  <br></td></tr>
<tr class="separator:a6f3e038498843f6ce7c0c70015ddaff9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4b298ac4b2d8585dec9e436bb9e65ff0"><td class="memTemplParams" colspan="2">template&lt;class CellIt &gt; </td></tr>
<tr class="memitem:a4b298ac4b2d8585dec9e436bb9e65ff0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a4b298ac4b2d8585dec9e436bb9e65ff0">insert_in_hole</a> (const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp;p, CellIt cell_begin, CellIt cell_end, <a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> begin, int i)</td></tr>
<tr class="memdesc:a4b298ac4b2d8585dec9e436bb9e65ff0"><td class="mdescLeft"> </td><td class="mdescRight">Creates a new vertex by starring a hole.  <br></td></tr>
<tr class="separator:a4b298ac4b2d8585dec9e436bb9e65ff0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad5f7bba4f49683befd2f70b35f2d7079"><td class="memTemplParams" colspan="2"><a id="ad5f7bba4f49683befd2f70b35f2d7079" name="ad5f7bba4f49683befd2f70b35f2d7079"></a>
template&lt;class CellIt &gt; </td></tr>
<tr class="memitem:ad5f7bba4f49683befd2f70b35f2d7079"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td><td class="memTemplItemRight" valign="bottom"><b>insert_in_hole</b> (const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp;p, CellIt cell_begin, CellIt cell_end, <a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> begin, int i, <a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> newv)</td></tr>
<tr class="memdesc:ad5f7bba4f49683befd2f70b35f2d7079"><td class="mdescLeft"> </td><td class="mdescRight">Same as above, except that <code>newv</code> will be used as the new vertex, which must have been allocated previously with e.g. <code>create_vertex</code>. <br></td></tr>
<tr class="separator:ad5f7bba4f49683befd2f70b35f2d7079"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Cell, Face, Edge and Vertex Iterators</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>The following iterators allow the user to visit cells, facets, edges and vertices of the triangulation.</p>
<p>These iterators are non-mutable, bidirectional and their value types are respectively <code>Cell</code>, <code>Facet</code>, <code>Edge</code> and <code>Vertex</code>. They are all invalidated by any change in the triangulation. </p>
</td></tr>
<tr class="memitem:af43b5f09e0fdcb9b8fff939133f2e814"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#af8d044953011cb5ff6a5ecf87e6f308e">Finite_vertices_iterator</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#af43b5f09e0fdcb9b8fff939133f2e814">finite_vertices_begin</a> () const</td></tr>
<tr class="memdesc:af43b5f09e0fdcb9b8fff939133f2e814"><td class="mdescLeft"> </td><td class="mdescRight">Starts at an arbitrary finite vertex.  <br></td></tr>
<tr class="separator:af43b5f09e0fdcb9b8fff939133f2e814"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6bff5471a8bd32d16c396948fdbc3495"><td class="memItemLeft" align="right" valign="top"><a id="a6bff5471a8bd32d16c396948fdbc3495" name="a6bff5471a8bd32d16c396948fdbc3495"></a>
<a class="el" href="classCGAL_1_1Triangulation__3.html#af8d044953011cb5ff6a5ecf87e6f308e">Finite_vertices_iterator</a> </td><td class="memItemRight" valign="bottom"><b>finite_vertices_end</b> () const</td></tr>
<tr class="memdesc:a6bff5471a8bd32d16c396948fdbc3495"><td class="mdescLeft"> </td><td class="mdescRight">Past-the-end iterator. <br></td></tr>
<tr class="separator:a6bff5471a8bd32d16c396948fdbc3495"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af682021f6f9be1437fe29be125ad14e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1c91aeb6128d5bf33995dca02398d330">Finite_edges_iterator</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#af682021f6f9be1437fe29be125ad14e8">finite_edges_begin</a> () const</td></tr>
<tr class="memdesc:af682021f6f9be1437fe29be125ad14e8"><td class="mdescLeft"> </td><td class="mdescRight">Starts at an arbitrary finite edge.  <br></td></tr>
<tr class="separator:af682021f6f9be1437fe29be125ad14e8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5455f4b903db664c1d57634ec15cd13a"><td class="memItemLeft" align="right" valign="top"><a id="a5455f4b903db664c1d57634ec15cd13a" name="a5455f4b903db664c1d57634ec15cd13a"></a>
<a class="el" href="classCGAL_1_1Triangulation__3.html#a1c91aeb6128d5bf33995dca02398d330">Finite_edges_iterator</a> </td><td class="memItemRight" valign="bottom"><b>finite_edges_end</b> () const</td></tr>
<tr class="memdesc:a5455f4b903db664c1d57634ec15cd13a"><td class="mdescLeft"> </td><td class="mdescRight">Past-the-end iterator. <br></td></tr>
<tr class="separator:a5455f4b903db664c1d57634ec15cd13a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adcb08049b8d50168079bbba248f3344d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#a6bc54bfb8362670059a4c1a416269994">Finite_facets_iterator</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#adcb08049b8d50168079bbba248f3344d">finite_facets_begin</a> () const</td></tr>
<tr class="memdesc:adcb08049b8d50168079bbba248f3344d"><td class="mdescLeft"> </td><td class="mdescRight">Starts at an arbitrary finite facet.  <br></td></tr>
<tr class="separator:adcb08049b8d50168079bbba248f3344d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aee05b9fc603428dfda9712b6c069e4e5"><td class="memItemLeft" align="right" valign="top"><a id="aee05b9fc603428dfda9712b6c069e4e5" name="aee05b9fc603428dfda9712b6c069e4e5"></a>
<a class="el" href="classCGAL_1_1Triangulation__3.html#a6bc54bfb8362670059a4c1a416269994">Finite_facets_iterator</a> </td><td class="memItemRight" valign="bottom"><b>finite_facets_end</b> () const</td></tr>
<tr class="memdesc:aee05b9fc603428dfda9712b6c069e4e5"><td class="mdescLeft"> </td><td class="mdescRight">Past-the-end iterator. <br></td></tr>
<tr class="separator:aee05b9fc603428dfda9712b6c069e4e5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a433fa868d7637f2719a40c251bd2ae65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#a6d1b83cb6fba001622452aa0f6592e02">Finite_cells_iterator</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a433fa868d7637f2719a40c251bd2ae65">finite_cells_begin</a> () const</td></tr>
<tr class="memdesc:a433fa868d7637f2719a40c251bd2ae65"><td class="mdescLeft"> </td><td class="mdescRight">Starts at an arbitrary finite cell.  <br></td></tr>
<tr class="separator:a433fa868d7637f2719a40c251bd2ae65"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3431b35584d93e305c1548228cf93110"><td class="memItemLeft" align="right" valign="top"><a id="a3431b35584d93e305c1548228cf93110" name="a3431b35584d93e305c1548228cf93110"></a>
<a class="el" href="classCGAL_1_1Triangulation__3.html#a6d1b83cb6fba001622452aa0f6592e02">Finite_cells_iterator</a> </td><td class="memItemRight" valign="bottom"><b>finite_cells_end</b> () const</td></tr>
<tr class="memdesc:a3431b35584d93e305c1548228cf93110"><td class="mdescLeft"> </td><td class="mdescRight">Past-the-end iterator. <br></td></tr>
<tr class="separator:a3431b35584d93e305c1548228cf93110"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aba04013896bdd4ea1398320869e2d886"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#ab930d6f34c8346b5191e93ab79475c70">All_vertices_iterator</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#aba04013896bdd4ea1398320869e2d886">all_vertices_begin</a> () const</td></tr>
<tr class="memdesc:aba04013896bdd4ea1398320869e2d886"><td class="mdescLeft"> </td><td class="mdescRight">Starts at an arbitrary vertex.  <br></td></tr>
<tr class="separator:aba04013896bdd4ea1398320869e2d886"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8f2932dc2d9c018421d195757d9c5ffa"><td class="memItemLeft" align="right" valign="top"><a id="a8f2932dc2d9c018421d195757d9c5ffa" name="a8f2932dc2d9c018421d195757d9c5ffa"></a>
<a class="el" href="classCGAL_1_1Triangulation__3.html#ab930d6f34c8346b5191e93ab79475c70">All_vertices_iterator</a> </td><td class="memItemRight" valign="bottom"><b>all_vertices_end</b> () const</td></tr>
<tr class="memdesc:a8f2932dc2d9c018421d195757d9c5ffa"><td class="mdescLeft"> </td><td class="mdescRight">Past-the-end iterator. <br></td></tr>
<tr class="separator:a8f2932dc2d9c018421d195757d9c5ffa"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af284c5406d004ea3316ed61f5a825887"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#a67ff0ee4eca14392f1fcb55acd5a6edc">All_edges_iterator</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#af284c5406d004ea3316ed61f5a825887">all_edges_begin</a> () const</td></tr>
<tr class="memdesc:af284c5406d004ea3316ed61f5a825887"><td class="mdescLeft"> </td><td class="mdescRight">Starts at an arbitrary edge.  <br></td></tr>
<tr class="separator:af284c5406d004ea3316ed61f5a825887"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2d4389833767a0ac0a469c6d3f1c2604"><td class="memItemLeft" align="right" valign="top"><a id="a2d4389833767a0ac0a469c6d3f1c2604" name="a2d4389833767a0ac0a469c6d3f1c2604"></a>
<a class="el" href="classCGAL_1_1Triangulation__3.html#a67ff0ee4eca14392f1fcb55acd5a6edc">All_edges_iterator</a> </td><td class="memItemRight" valign="bottom"><b>all_edges_end</b> () const</td></tr>
<tr class="memdesc:a2d4389833767a0ac0a469c6d3f1c2604"><td class="mdescLeft"> </td><td class="mdescRight">Past-the-end iterator. <br></td></tr>
<tr class="separator:a2d4389833767a0ac0a469c6d3f1c2604"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af412b76826082617ad5cd7a6428561b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#a086ed61d6d43a10f77f6a4d695a256fc">All_facets_iterator</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#af412b76826082617ad5cd7a6428561b0">all_facets_begin</a> () const</td></tr>
<tr class="memdesc:af412b76826082617ad5cd7a6428561b0"><td class="mdescLeft"> </td><td class="mdescRight">Starts at an arbitrary facet.  <br></td></tr>
<tr class="separator:af412b76826082617ad5cd7a6428561b0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2cf3371698886ce3d219ba98c0a2452b"><td class="memItemLeft" align="right" valign="top"><a id="a2cf3371698886ce3d219ba98c0a2452b" name="a2cf3371698886ce3d219ba98c0a2452b"></a>
<a class="el" href="classCGAL_1_1Triangulation__3.html#a086ed61d6d43a10f77f6a4d695a256fc">All_facets_iterator</a> </td><td class="memItemRight" valign="bottom"><b>all_facets_end</b> () const</td></tr>
<tr class="memdesc:a2cf3371698886ce3d219ba98c0a2452b"><td class="mdescLeft"> </td><td class="mdescRight">Past-the-end iterator. <br></td></tr>
<tr class="separator:a2cf3371698886ce3d219ba98c0a2452b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad20bfae1b250b357d8ae5bc48eef1f10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#aff2c019af34403770e6e922d616eaf0f">All_cells_iterator</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#ad20bfae1b250b357d8ae5bc48eef1f10">all_cells_begin</a> () const</td></tr>
<tr class="memdesc:ad20bfae1b250b357d8ae5bc48eef1f10"><td class="mdescLeft"> </td><td class="mdescRight">Starts at an arbitrary cell.  <br></td></tr>
<tr class="separator:ad20bfae1b250b357d8ae5bc48eef1f10"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aacfd26fa0d3b2a8b2d8008af3b08930a"><td class="memItemLeft" align="right" valign="top"><a id="aacfd26fa0d3b2a8b2d8008af3b08930a" name="aacfd26fa0d3b2a8b2d8008af3b08930a"></a>
<a class="el" href="classCGAL_1_1Triangulation__3.html#aff2c019af34403770e6e922d616eaf0f">All_cells_iterator</a> </td><td class="memItemRight" valign="bottom"><b>all_cells_end</b> () const</td></tr>
<tr class="memdesc:aacfd26fa0d3b2a8b2d8008af3b08930a"><td class="mdescLeft"> </td><td class="mdescRight">Past-the-end iterator. <br></td></tr>
<tr class="separator:aacfd26fa0d3b2a8b2d8008af3b08930a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a067b365119a53428aff40652e0ccb400"><td class="memItemLeft" align="right" valign="top"><a id="a067b365119a53428aff40652e0ccb400" name="a067b365119a53428aff40652e0ccb400"></a>
<a class="el" href="classCGAL_1_1Triangulation__3.html#a3ec38d2d1afffea88a760f5a50c4f9f0">Point_iterator</a> </td><td class="memItemRight" valign="bottom"><b>points_begin</b> () const</td></tr>
<tr class="memdesc:a067b365119a53428aff40652e0ccb400"><td class="mdescLeft"> </td><td class="mdescRight">Iterates over the points of the triangulation. <br></td></tr>
<tr class="separator:a067b365119a53428aff40652e0ccb400"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac69f365fe85f589224868cdfc859c078"><td class="memItemLeft" align="right" valign="top"><a id="ac69f365fe85f589224868cdfc859c078" name="ac69f365fe85f589224868cdfc859c078"></a>
<a class="el" href="classCGAL_1_1Triangulation__3.html#a3ec38d2d1afffea88a760f5a50c4f9f0">Point_iterator</a> </td><td class="memItemRight" valign="bottom"><b>points_end</b> () const</td></tr>
<tr class="memdesc:ac69f365fe85f589224868cdfc859c078"><td class="mdescLeft"> </td><td class="mdescRight">Past-the-end iterator. <br></td></tr>
<tr class="separator:ac69f365fe85f589224868cdfc859c078"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Ranges</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>In order to write C++ 11 <code>for</code>-loops we provide a range type and member functions to generate ranges.</p>
<p>Note that vertex and cell ranges are special. See Section <a class="el" href="index.html#Triangulation3secRanges">Iterators and Ranges</a> in the User Manual. </p>
</td></tr>
<tr class="memitem:a16e64be4b2c33a5e5442a07b771e3241"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#a0ffff120af16e255cee2ccc20be34775">All_cell_handles</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a16e64be4b2c33a5e5442a07b771e3241">all_cell_handles</a> () const</td></tr>
<tr class="memdesc:a16e64be4b2c33a5e5442a07b771e3241"><td class="mdescLeft"> </td><td class="mdescRight">returns a range of iterators over all cells (even the infinite cells).  <br></td></tr>
<tr class="separator:a16e64be4b2c33a5e5442a07b771e3241"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab15ab30eb9c54106a96916868f454eef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#abe601aa6506352a8df0877449bcf0dd3">All_facets</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#ab15ab30eb9c54106a96916868f454eef">all_facets</a> () const</td></tr>
<tr class="memdesc:ab15ab30eb9c54106a96916868f454eef"><td class="mdescLeft"> </td><td class="mdescRight">returns a range of iterators starting at an arbitrary facet.  <br></td></tr>
<tr class="separator:ab15ab30eb9c54106a96916868f454eef"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a67412622209344f2f8660b337a6d5e35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#a60c2dacc98d57951b9209f94dfcad921">All_edges</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a67412622209344f2f8660b337a6d5e35">all_edges</a> () const</td></tr>
<tr class="memdesc:a67412622209344f2f8660b337a6d5e35"><td class="mdescLeft"> </td><td class="mdescRight">returns a range of iterators starting at an arbitrary edge.  <br></td></tr>
<tr class="separator:a67412622209344f2f8660b337a6d5e35"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a61c04821ce4e5b41ce3fb95a22737a9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#ae53e08aa6f86bee125ef6ba075b0e973">All_vertex_handles</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a61c04821ce4e5b41ce3fb95a22737a9a">all_vertex_handles</a> () const</td></tr>
<tr class="memdesc:a61c04821ce4e5b41ce3fb95a22737a9a"><td class="mdescLeft"> </td><td class="mdescRight">returns a range of iterators over all vertices (even the infinite one).  <br></td></tr>
<tr class="separator:a61c04821ce4e5b41ce3fb95a22737a9a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab9584da45f55288fb2b9d0624250bbf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#a4c94face5ab29897bcb291f157f1635d">Finite_cell_handles</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#ab9584da45f55288fb2b9d0624250bbf3">finite_cell_handles</a> () const</td></tr>
<tr class="memdesc:ab9584da45f55288fb2b9d0624250bbf3"><td class="mdescLeft"> </td><td class="mdescRight">returns a range of iterators over finite cells.  <br></td></tr>
<tr class="separator:ab9584da45f55288fb2b9d0624250bbf3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a95e37032ae2a232c6ac42b114fd7c432"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#aa35974d42ec9564687ffbe5f664cb906">Finite_facets</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a95e37032ae2a232c6ac42b114fd7c432">finite_facets</a> () const</td></tr>
<tr class="memdesc:a95e37032ae2a232c6ac42b114fd7c432"><td class="mdescLeft"> </td><td class="mdescRight">returns a range of iterators starting at an arbitrary facet.  <br></td></tr>
<tr class="separator:a95e37032ae2a232c6ac42b114fd7c432"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afb40860f9602b54c62c0b7ad645278d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#a514f885323d414200cd13e8fa6e79e34">Finite_edges</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#afb40860f9602b54c62c0b7ad645278d3">finite_edges</a> () const</td></tr>
<tr class="memdesc:afb40860f9602b54c62c0b7ad645278d3"><td class="mdescLeft"> </td><td class="mdescRight">returns a range of iterators starting at an arbitrary edge.  <br></td></tr>
<tr class="separator:afb40860f9602b54c62c0b7ad645278d3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a33a4aa893719a091df83ee40ad63a49f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac59a8c8f173db4a1e72b537bb59e16a5">Finite_vertex_handles</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a33a4aa893719a091df83ee40ad63a49f">finite_vertex_handles</a> () const</td></tr>
<tr class="memdesc:a33a4aa893719a091df83ee40ad63a49f"><td class="mdescLeft"> </td><td class="mdescRight">returns a range of iterators over finite vertices.  <br></td></tr>
<tr class="separator:a33a4aa893719a091df83ee40ad63a49f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae0b4d6177ffbcbd6c6d58820df53b746"><td class="memItemLeft" align="right" valign="top"><a id="ae0b4d6177ffbcbd6c6d58820df53b746" name="ae0b4d6177ffbcbd6c6d58820df53b746"></a>
<a class="el" href="classCGAL_1_1Triangulation__3.html#a5c8812f38413b29cdd7aae517c457d52">Points</a> </td><td class="memItemRight" valign="bottom"><b>points</b> () const</td></tr>
<tr class="memdesc:ae0b4d6177ffbcbd6c6d58820df53b746"><td class="mdescLeft"> </td><td class="mdescRight">returns a range of iterators over the points of finite vertices. <br></td></tr>
<tr class="separator:ae0b4d6177ffbcbd6c6d58820df53b746"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a02faf334255e1ca8caa1a6f412533759"><td class="memItemLeft" align="right" valign="top"><a id="a02faf334255e1ca8caa1a6f412533759" name="a02faf334255e1ca8caa1a6f412533759"></a>
std::array&lt; <a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a>, 2 &gt; </td><td class="memItemRight" valign="bottom"><b>vertices</b> (const <a class="el" href="classCGAL_1_1Triangulation__3.html#a0f355dbb38cf631f24d4df8abd7a942f">Edge</a> &amp;e) const</td></tr>
<tr class="memdesc:a02faf334255e1ca8caa1a6f412533759"><td class="mdescLeft"> </td><td class="mdescRight">returns an array containing the vertices of <code>e</code>, in the order of their indices <code>e.second</code> and <code>e.third</code> in the cell <code>e.first</code>. <br></td></tr>
<tr class="separator:a02faf334255e1ca8caa1a6f412533759"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a539aa6bbb70ea430c787ee7e3600e064"><td class="memItemLeft" align="right" valign="top"><a id="a539aa6bbb70ea430c787ee7e3600e064" name="a539aa6bbb70ea430c787ee7e3600e064"></a>
std::array&lt; <a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a>, 3 &gt; </td><td class="memItemRight" valign="bottom"><b>vertices</b> (const <a class="el" href="classCGAL_1_1Triangulation__3.html#aa100228164b0cf78d5c2b1009c2df258">Facet</a> &amp;f) const</td></tr>
<tr class="memdesc:a539aa6bbb70ea430c787ee7e3600e064"><td class="mdescLeft"> </td><td class="mdescRight">returns an array containing the vertices of <code>f</code>, in counterclockwise order on the face of <code>f.first</code> opposite to vertex <code>f.first-&gt;vertex(f.second)</code>. <br></td></tr>
<tr class="separator:a539aa6bbb70ea430c787ee7e3600e064"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a32a502a7555b5c77967ea3004a0d5c1c"><td class="memItemLeft" align="right" valign="top"><a id="a32a502a7555b5c77967ea3004a0d5c1c" name="a32a502a7555b5c77967ea3004a0d5c1c"></a>
std::array&lt; <a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a>, 4 &gt; </td><td class="memItemRight" valign="bottom"><b>vertices</b> (const <a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> c) const</td></tr>
<tr class="memdesc:a32a502a7555b5c77967ea3004a0d5c1c"><td class="mdescLeft"> </td><td class="mdescRight">returns an array containing the vertices of <code>c</code>, in the same order as the indices in <code>c</code>. <br></td></tr>
<tr class="separator:a32a502a7555b5c77967ea3004a0d5c1c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7245a46ae480496e8e7e83fb2a1ebb43"><td class="memItemLeft" align="right" valign="top"><a id="a7245a46ae480496e8e7e83fb2a1ebb43" name="a7245a46ae480496e8e7e83fb2a1ebb43"></a>
<a class="el" href="classCGAL_1_1Triangulation__3.html#a0356538c3ef7d62280a7846c35a8abbb">Segment_traverser_cell_handles</a> </td><td class="memItemRight" valign="bottom"><b>segment_traverser_cell_handles</b> () const</td></tr>
<tr class="memdesc:a7245a46ae480496e8e7e83fb2a1ebb43"><td class="mdescLeft"> </td><td class="mdescRight">returns a range of iterators over the cells intersected by a line segment <br></td></tr>
<tr class="separator:a7245a46ae480496e8e7e83fb2a1ebb43"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5bb68143601dda95a446ee55cc7aa200"><td class="memItemLeft" align="right" valign="top"><a id="a5bb68143601dda95a446ee55cc7aa200" name="a5bb68143601dda95a446ee55cc7aa200"></a>
<a class="el" href="classCGAL_1_1Triangulation__3.html#ae4a0565708ab5c23639c90c47bbec7cc">Segment_traverser_simplices</a> </td><td class="memItemRight" valign="bottom"><b>segment_traverser_simplices</b> () const</td></tr>
<tr class="memdesc:a5bb68143601dda95a446ee55cc7aa200"><td class="mdescLeft"> </td><td class="mdescRight">returns a range of iterators over the simplices intersected by a line segment <br></td></tr>
<tr class="separator:a5bb68143601dda95a446ee55cc7aa200"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Segment Cell Iterator</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>The triangulation defines an iterator that visits cells intersected by a line segment.</p>
<p>Segment Cell <a class="elRef" href="../Manual/classIterator.html">Iterator</a> iterates over a sequence of cells which union contains the segment <code>[s,t]</code>. The sequence of cells is "minimal" (removing any cell would make the union of the renaming cells not entirely containing <code>[s,t]</code>) and sorted along <code>[s,t]</code>. The "minimality" of the sequence implies that in degenerate cases, only one cell incident to the traversed simplex will be reported.</p>
<p>The cells visited form a facet-connected region containing both source and target points of the line segment <code>[s,t]</code>. Each cell falls within one or more of the following categories:</p><ol type="1">
<li>a finite cell whose interior is intersected by <code>[s,t]</code>.</li>
<li>a finite cell with a facet <code>f</code> whose interior is intersected by <code>[s,t]</code> in a line segment. If such a cell is visited, its neighbor incident to <code>f</code> is not visited.</li>
<li>a finite cell with an edge <code>e</code> whose interior is intersected by <code>[s,t]</code> in a line segment. If such a cell is visited, none of the other cells incident to <code>e</code> are visited.</li>
<li>a finite cell with an edge <code>e</code> whose interior is intersected by <code>[s,t]</code> in a point. This cell forms a connected component together with the other cells incident to <code>e</code> that are visited. Exactly two of these visited cells also fall in category 1 or 2.</li>
<li>a finite cell with a vertex <code>v</code> that is an endpoint of <code>[s,t]</code>. This cell also fits in either category 1 or 2.</li>
<li>a finite cell with a vertex <code>v</code> that lies in the interior of <code>[s,t]</code>. This cell forms a connected component together with the other cells incident to <code>v</code> that are visited. Exactly two of these cells also fall in category 1 or 2.</li>
<li>an infinite cell with a finite facet whose interior is intersected by the interior of <code>[s,t]</code>.</li>
<li>an infinite cell with a finite edge <code>e</code> whose interior is intersected by the interior of <code>[s,t]</code>. If such a cell is visited, its infinite neighbor incident to <code>e</code> is not visited. Among the finite cells incident to <code>e</code> that are visited, exactly one also falls in category 1 or 2.</li>
<li>an infinite cell with a finite vertex <code>v</code> that lies in the interior of <code>[s,t]</code>. If such a cell is visited, none of the other infinite cells incident to <code>v</code> are visited. Among the finite cells incident to <code>v</code> that are visited, exactly one also falls in category 1, 2, or 3.</li>
<li>an infinite cell in the special case where the segment does not intersect any finite facet. In this case, exactly one infinite cell is visited. This cell shares a facet <code>f</code> with a finite cell <code>c</code> such that <code>f</code> is intersected by the line through the point <code>s</code> and the vertex of <code>c</code> opposite of <code>f</code>.</li>
</ol>
<p>Note that for categories 4 and 6, it is not predetermined which incident cells are visited. However, exactly two of the incident cells <code>c0,c1</code> visited also fall in category 1 or 2. The remaining incident cells visited make a facet-connected sequence connecting <code>c0</code> to <code>c1</code>.</p>
<p><code>Segment_cell_iterator</code> implements the concept <code><a class="elRef" href="../Manual/classForwardIterator.html">ForwardIterator</a></code> and is non-mutable. It is invalidated by any modification of one of the cells traversed.</p>
<p>Its <code>value_type</code> is <code>Cell_handle</code>. </p>
</td></tr>
<tr class="memitem:a7b020f2841ad9a6148e79ac0939b06ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#a39088e35d874ae7361d96a19acd572c7">Segment_cell_iterator</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a7b020f2841ad9a6148e79ac0939b06ec">segment_traverser_cells_begin</a> (<a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> vs, <a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> vt) const</td></tr>
<tr class="memdesc:a7b020f2841ad9a6148e79ac0939b06ec"><td class="mdescLeft"> </td><td class="mdescRight">returns the iterator that allows to visit the cells intersected by the line segment <code>[vs,vt]</code>.  <br></td></tr>
<tr class="separator:a7b020f2841ad9a6148e79ac0939b06ec"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a535b21fc57d175507facde8091852d3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#a39088e35d874ae7361d96a19acd572c7">Segment_cell_iterator</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a535b21fc57d175507facde8091852d3c">segment_traverser_cells_begin</a> (const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp;ps, const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp;pt, <a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> hint=<a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a>()) const</td></tr>
<tr class="memdesc:a535b21fc57d175507facde8091852d3c"><td class="mdescLeft"> </td><td class="mdescRight">returns the iterator that allows to visit the cells intersected by the line segment <code>[ps, pt]</code>.  <br></td></tr>
<tr class="separator:a535b21fc57d175507facde8091852d3c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adb5f31ae685c84289b0d39c2c1b3cf3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#a39088e35d874ae7361d96a19acd572c7">Segment_cell_iterator</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#adb5f31ae685c84289b0d39c2c1b3cf3b">segment_traverser_cells_end</a> () const</td></tr>
<tr class="memdesc:adb5f31ae685c84289b0d39c2c1b3cf3b"><td class="mdescLeft"> </td><td class="mdescRight">returns the past-the-end iterator over the intersected cells.  <br></td></tr>
<tr class="separator:adb5f31ae685c84289b0d39c2c1b3cf3b"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Segment Simplex Iterator</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>The triangulation defines an iterator that visits all the triangulation simplices (vertices, edges, facets and cells) intersected by a line segment.</p>
<p>The iterator traverses a connected sequence of simplices - possibly of all dimensions - intersected by the line segment <code>[s, t]</code>. In the degenerate case where the query segment goes exactly through a vertex (or along an edge, or along a facet), only one of the cells incident to that vertex (or edge, or facet) is returned by the iterator, and not all of them.</p>
<p>Each simplex falls within one or more of the following categories:</p><ol type="1">
<li>a finite cell whose interior is intersected by <code>[s,t]</code>,</li>
<li>a facet <code>f</code> whose interior is intersected by <code>[s,t]</code> in a point,</li>
<li>a facet <code>f</code> whose interior is intersected by <code>[s,t]</code> in a line segment,</li>
<li>an edge <code>e</code> whose interior is intersected by <code>[s,t]</code> in a point,</li>
<li>an edge <code>e</code> whose interior is intersected by <code>[s,t]</code> in a line segment,</li>
<li>a vertex <code>v</code> lying on <code>[s,t]</code>,</li>
<li>an infinite cell with a finite facet whose interior is intersected by the interior of <code>[s,t]</code>,</li>
<li>an infinite cell in the special case where the segment does not intersect any finite facet. In this case, exactly one infinite cell is visited. This cell shares a facet <code>f</code> with a finite cell <code>c</code> such that <code>f</code> is intersected by the line through the source of <code>[s,t]</code> and the vertex of <code>c</code> opposite of <code>f</code>.</li>
</ol>
<p><code>Segment_simplex_iterator</code> implements the concept <code><a class="elRef" href="../Manual/classForwardIterator.html">ForwardIterator</a></code> and is non-mutable. It is invalidated by any modification of one of the cells traversed.</p>
<p>Its <code>value_type</code> is <code><a class="el" href="classCGAL_1_1Triangulation__simplex__3.html" title="The class Triangulation_simplex_3 stores a simplex of any dimension defined by the Triangulation_3 cl...">Triangulation_simplex_3</a></code>. </p>
</td></tr>
<tr class="memitem:a31e80cca5efe64571de4017067299449"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#a822c7264ac03f629735cb85be4871e1f">Segment_simplex_iterator</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a31e80cca5efe64571de4017067299449">segment_traverser_simplices_begin</a> (<a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> vs, <a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> vt) const</td></tr>
<tr class="memdesc:a31e80cca5efe64571de4017067299449"><td class="mdescLeft"> </td><td class="mdescRight">returns the iterator that allows to visit the simplices intersected by the line segment <code>[vs,vt]</code>.  <br></td></tr>
<tr class="separator:a31e80cca5efe64571de4017067299449"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a12b4b5511ee276cc341b940971e4544e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#a822c7264ac03f629735cb85be4871e1f">Segment_simplex_iterator</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a12b4b5511ee276cc341b940971e4544e">segment_traverser_simplices_begin</a> (const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp;ps, const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp;pt, <a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> hint=<a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a>()) const</td></tr>
<tr class="memdesc:a12b4b5511ee276cc341b940971e4544e"><td class="mdescLeft"> </td><td class="mdescRight">returns the iterator that allows to visit the simplices intersected by the line segment <code>[ps,pt]</code>.  <br></td></tr>
<tr class="separator:a12b4b5511ee276cc341b940971e4544e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2e5c7f41baa13b4086fe30ddb90f2c19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#a822c7264ac03f629735cb85be4871e1f">Segment_simplex_iterator</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a2e5c7f41baa13b4086fe30ddb90f2c19">segment_traverser_simplices_end</a> () const</td></tr>
<tr class="memdesc:a2e5c7f41baa13b4086fe30ddb90f2c19"><td class="mdescLeft"> </td><td class="mdescRight">returns the past-the-end iterator over the intersected simplices.  <br></td></tr>
<tr class="separator:a2e5c7f41baa13b4086fe30ddb90f2c19"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Cell and Facet Circulators</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>The following circulators respectively visit all cells or all facets incident to a given edge.</p>
<p>They are non-mutable and bidirectional. They are invalidated by any modification of one of the cells traversed. </p>
</td></tr>
<tr class="memitem:a0741a861a6291131384529349cb994a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#a064fb43553690504ee55c4b9a74188e5">Cell_circulator</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a0741a861a6291131384529349cb994a4">incident_cells</a> (<a class="el" href="classCGAL_1_1Triangulation__3.html#a0f355dbb38cf631f24d4df8abd7a942f">Edge</a> e) const</td></tr>
<tr class="memdesc:a0741a861a6291131384529349cb994a4"><td class="mdescLeft"> </td><td class="mdescRight">Starts at an arbitrary cell incident to <code>e</code>.  <br></td></tr>
<tr class="separator:a0741a861a6291131384529349cb994a4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a49921c82183b7bfdb5fac1de73c8d941"><td class="memItemLeft" align="right" valign="top"><a id="a49921c82183b7bfdb5fac1de73c8d941" name="a49921c82183b7bfdb5fac1de73c8d941"></a>
<a class="el" href="classCGAL_1_1Triangulation__3.html#a064fb43553690504ee55c4b9a74188e5">Cell_circulator</a> </td><td class="memItemRight" valign="bottom"><b>incident_cells</b> (<a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> c, int i, int j) const</td></tr>
<tr class="memdesc:a49921c82183b7bfdb5fac1de73c8d941"><td class="mdescLeft"> </td><td class="mdescRight">As above for edge <code>(i,j)</code> of <code>c</code>. <br></td></tr>
<tr class="separator:a49921c82183b7bfdb5fac1de73c8d941"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a85d53f656ef4d67ccbf6eaed424e0a35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#a064fb43553690504ee55c4b9a74188e5">Cell_circulator</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a85d53f656ef4d67ccbf6eaed424e0a35">incident_cells</a> (<a class="el" href="classCGAL_1_1Triangulation__3.html#a0f355dbb38cf631f24d4df8abd7a942f">Edge</a> e, <a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> start) const</td></tr>
<tr class="memdesc:a85d53f656ef4d67ccbf6eaed424e0a35"><td class="mdescLeft"> </td><td class="mdescRight">Starts at cell <code>start</code>.  <br></td></tr>
<tr class="separator:a85d53f656ef4d67ccbf6eaed424e0a35"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afd3ed4f0381fdeefb8a9439caa435b2f"><td class="memItemLeft" align="right" valign="top"><a id="afd3ed4f0381fdeefb8a9439caa435b2f" name="afd3ed4f0381fdeefb8a9439caa435b2f"></a>
<a class="el" href="classCGAL_1_1Triangulation__3.html#a064fb43553690504ee55c4b9a74188e5">Cell_circulator</a> </td><td class="memItemRight" valign="bottom"><b>incident_cells</b> (<a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> c, int i, int j, <a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> start) const</td></tr>
<tr class="memdesc:afd3ed4f0381fdeefb8a9439caa435b2f"><td class="mdescLeft"> </td><td class="mdescRight">As above for edge <code>(i,j)</code> of <code>c</code>. <br></td></tr>
<tr class="separator:afd3ed4f0381fdeefb8a9439caa435b2f"><td class="memSeparator" colspan="2"> </td></tr>
<tr><td class="ititle" colspan="2"><p>The following circulators on facets are defined only in dimension 3, though facets are defined also in dimension 2: there are only two facets sharing an edge in dimension 2. </p>
</td></tr>
<tr class="memitem:a997be4328927428bce5aee9f775e5e55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1c904fc6cbfe189b2cb09f7175044b00">Facet_circulator</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a997be4328927428bce5aee9f775e5e55">incident_facets</a> (<a class="el" href="classCGAL_1_1Triangulation__3.html#a0f355dbb38cf631f24d4df8abd7a942f">Edge</a> e) const</td></tr>
<tr class="memdesc:a997be4328927428bce5aee9f775e5e55"><td class="mdescLeft"> </td><td class="mdescRight">Starts at an arbitrary facet incident to <code>e</code>.  <br></td></tr>
<tr class="separator:a997be4328927428bce5aee9f775e5e55"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abdf765a8077bfc18de39734fbe7ab012"><td class="memItemLeft" align="right" valign="top"><a id="abdf765a8077bfc18de39734fbe7ab012" name="abdf765a8077bfc18de39734fbe7ab012"></a>
<a class="el" href="classCGAL_1_1Triangulation__3.html#a1c904fc6cbfe189b2cb09f7175044b00">Facet_circulator</a> </td><td class="memItemRight" valign="bottom"><b>incident_facets</b> (<a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> c, int i, int j) const</td></tr>
<tr class="memdesc:abdf765a8077bfc18de39734fbe7ab012"><td class="mdescLeft"> </td><td class="mdescRight">As above for edge <code>(i,j)</code> of <code>c</code>. <br></td></tr>
<tr class="separator:abdf765a8077bfc18de39734fbe7ab012"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1cbaaed93e5d67671302649501585a98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1c904fc6cbfe189b2cb09f7175044b00">Facet_circulator</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1cbaaed93e5d67671302649501585a98">incident_facets</a> (<a class="el" href="classCGAL_1_1Triangulation__3.html#a0f355dbb38cf631f24d4df8abd7a942f">Edge</a> e, <a class="el" href="classCGAL_1_1Triangulation__3.html#aa100228164b0cf78d5c2b1009c2df258">Facet</a> start) const</td></tr>
<tr class="memdesc:a1cbaaed93e5d67671302649501585a98"><td class="mdescLeft"> </td><td class="mdescRight">Starts at facet <code>start</code>.  <br></td></tr>
<tr class="separator:a1cbaaed93e5d67671302649501585a98"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4cc635bb45ddcb7c1ab46f90592425d2"><td class="memItemLeft" align="right" valign="top"><a id="a4cc635bb45ddcb7c1ab46f90592425d2" name="a4cc635bb45ddcb7c1ab46f90592425d2"></a>
<a class="el" href="classCGAL_1_1Triangulation__3.html#a1c904fc6cbfe189b2cb09f7175044b00">Facet_circulator</a> </td><td class="memItemRight" valign="bottom"><b>incident_facets</b> (<a class="el" href="classCGAL_1_1Triangulation__3.html#a0f355dbb38cf631f24d4df8abd7a942f">Edge</a> e, <a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> start, int f) const</td></tr>
<tr class="memdesc:a4cc635bb45ddcb7c1ab46f90592425d2"><td class="mdescLeft"> </td><td class="mdescRight">Starts at facet of index <code>f</code> in <code>start</code>. <br></td></tr>
<tr class="separator:a4cc635bb45ddcb7c1ab46f90592425d2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5d41217a20ef2851d44315b5166eaf76"><td class="memItemLeft" align="right" valign="top"><a id="a5d41217a20ef2851d44315b5166eaf76" name="a5d41217a20ef2851d44315b5166eaf76"></a>
<a class="el" href="classCGAL_1_1Triangulation__3.html#a1c904fc6cbfe189b2cb09f7175044b00">Facet_circulator</a> </td><td class="memItemRight" valign="bottom"><b>incident_facets</b> (<a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> c, int i, int j, <a class="el" href="classCGAL_1_1Triangulation__3.html#aa100228164b0cf78d5c2b1009c2df258">Facet</a> start) const</td></tr>
<tr class="memdesc:a5d41217a20ef2851d44315b5166eaf76"><td class="mdescLeft"> </td><td class="mdescRight">As above for edge <code>(i,j)</code> of <code>c</code>. <br></td></tr>
<tr class="separator:a5d41217a20ef2851d44315b5166eaf76"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5d490167eab1facd3ef982613eb5d242"><td class="memItemLeft" align="right" valign="top"><a id="a5d490167eab1facd3ef982613eb5d242" name="a5d490167eab1facd3ef982613eb5d242"></a>
<a class="el" href="classCGAL_1_1Triangulation__3.html#a1c904fc6cbfe189b2cb09f7175044b00">Facet_circulator</a> </td><td class="memItemRight" valign="bottom"><b>incident_facets</b> (<a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> c, int i, int j, <a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> start, int f) const</td></tr>
<tr class="memdesc:a5d490167eab1facd3ef982613eb5d242"><td class="mdescLeft"> </td><td class="mdescRight">As above for edge <code>(i,j)</code> of <code>c</code> and facet <code>(start,f)</code>. <br></td></tr>
<tr class="separator:a5d490167eab1facd3ef982613eb5d242"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Traversal of the Incident Cells, Facets and Edges, and the Adjacent Vertices of a Given Vertex</h2></td></tr>
<tr class="memitem:ad9890c64030969cd74f35a007cb6b049"><td class="memTemplParams" colspan="2">template&lt;class <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> &gt; </td></tr>
<tr class="memitem:ad9890c64030969cd74f35a007cb6b049"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#ad9890c64030969cd74f35a007cb6b049">incident_cells</a> (<a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> v, <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> cells) const</td></tr>
<tr class="memdesc:ad9890c64030969cd74f35a007cb6b049"><td class="mdescLeft"> </td><td class="mdescRight">Copies the <code>Cell_handle</code>s of all cells incident to <code>v</code> to the output iterator <code>cells</code>.  <br></td></tr>
<tr class="separator:ad9890c64030969cd74f35a007cb6b049"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ace9dd63ba3a24d11d9b829198e514535"><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#ace9dd63ba3a24d11d9b829198e514535">try_lock_and_get_incident_cells</a> (<a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> v, std::vector&lt; <a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> &gt; &amp;cells) const</td></tr>
<tr class="memdesc:ace9dd63ba3a24d11d9b829198e514535"><td class="mdescLeft"> </td><td class="mdescRight">Try to lock and copy the <code>Cell_handle</code>s of all cells incident to <code>v</code> into <code>cells</code>.  <br></td></tr>
<tr class="separator:ace9dd63ba3a24d11d9b829198e514535"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af3ca792eed2f27ccb932d5f67ce4c6b9"><td class="memTemplParams" colspan="2">template&lt;class <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> &gt; </td></tr>
<tr class="memitem:af3ca792eed2f27ccb932d5f67ce4c6b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#af3ca792eed2f27ccb932d5f67ce4c6b9">finite_incident_cells</a> (<a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> v, <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> cells) const</td></tr>
<tr class="memdesc:af3ca792eed2f27ccb932d5f67ce4c6b9"><td class="mdescLeft"> </td><td class="mdescRight">Copies the <code>Cell_handle</code>s of all finite cells incident to <code>v</code> to the output iterator <code>cells</code>.  <br></td></tr>
<tr class="separator:af3ca792eed2f27ccb932d5f67ce4c6b9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2776f24c7e4cdefc0c511edebf1d3599"><td class="memTemplParams" colspan="2">template&lt;class <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> &gt; </td></tr>
<tr class="memitem:a2776f24c7e4cdefc0c511edebf1d3599"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a2776f24c7e4cdefc0c511edebf1d3599">incident_facets</a> (<a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> v, <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> facets) const</td></tr>
<tr class="memdesc:a2776f24c7e4cdefc0c511edebf1d3599"><td class="mdescLeft"> </td><td class="mdescRight">Copies all <code>Facet</code>s incident to <code>v</code> to the output iterator <code>facets</code>.  <br></td></tr>
<tr class="separator:a2776f24c7e4cdefc0c511edebf1d3599"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1a08f1fcb24e5cd713d862e339ff3f4d"><td class="memTemplParams" colspan="2">template&lt;class <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> &gt; </td></tr>
<tr class="memitem:a1a08f1fcb24e5cd713d862e339ff3f4d"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1a08f1fcb24e5cd713d862e339ff3f4d">finite_incident_facets</a> (<a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> v, <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> facets) const</td></tr>
<tr class="memdesc:a1a08f1fcb24e5cd713d862e339ff3f4d"><td class="mdescLeft"> </td><td class="mdescRight">Copies all finite <code>Facet</code>s incident to <code>v</code> to the output iterator <code>facets</code>.  <br></td></tr>
<tr class="separator:a1a08f1fcb24e5cd713d862e339ff3f4d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a81373c29a596ba2f1d6d93e62d1f0d79"><td class="memTemplParams" colspan="2">template&lt;class <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> &gt; </td></tr>
<tr class="memitem:a81373c29a596ba2f1d6d93e62d1f0d79"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a81373c29a596ba2f1d6d93e62d1f0d79">incident_edges</a> (<a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> v, <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> edges) const</td></tr>
<tr class="memdesc:a81373c29a596ba2f1d6d93e62d1f0d79"><td class="mdescLeft"> </td><td class="mdescRight">Copies all <code>Edge</code>s incident to <code>v</code> to the output iterator <code>edges</code>.  <br></td></tr>
<tr class="separator:a81373c29a596ba2f1d6d93e62d1f0d79"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab5b49dae39468e544c183142169208f1"><td class="memTemplParams" colspan="2">template&lt;class <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> &gt; </td></tr>
<tr class="memitem:ab5b49dae39468e544c183142169208f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#ab5b49dae39468e544c183142169208f1">finite_incident_edges</a> (<a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> v, <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> edges) const</td></tr>
<tr class="memdesc:ab5b49dae39468e544c183142169208f1"><td class="mdescLeft"> </td><td class="mdescRight">Copies all finite <code>Edge</code>s incident to <code>v</code> to the output iterator <code>edges</code>.  <br></td></tr>
<tr class="separator:ab5b49dae39468e544c183142169208f1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa9814b11ee0a6e024fd3cee4cff066c3"><td class="memTemplParams" colspan="2">template&lt;class <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> &gt; </td></tr>
<tr class="memitem:aa9814b11ee0a6e024fd3cee4cff066c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#aa9814b11ee0a6e024fd3cee4cff066c3">adjacent_vertices</a> (<a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> v, <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> <a class="el" href="classCGAL_1_1Triangulation__3.html#a02faf334255e1ca8caa1a6f412533759">vertices</a>) const</td></tr>
<tr class="memdesc:aa9814b11ee0a6e024fd3cee4cff066c3"><td class="mdescLeft"> </td><td class="mdescRight">Copies the <code>Vertex_handle</code>s of all vertices adjacent to <code>v</code> to the output iterator <code>vertices</code>.  <br></td></tr>
<tr class="separator:aa9814b11ee0a6e024fd3cee4cff066c3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af779084dce02eb4abba8bd1916891214"><td class="memTemplParams" colspan="2">template&lt;class <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> &gt; </td></tr>
<tr class="memitem:af779084dce02eb4abba8bd1916891214"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#af779084dce02eb4abba8bd1916891214">finite_adjacent_vertices</a> (<a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> v, <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> <a class="el" href="classCGAL_1_1Triangulation__3.html#a02faf334255e1ca8caa1a6f412533759">vertices</a>) const</td></tr>
<tr class="memdesc:af779084dce02eb4abba8bd1916891214"><td class="mdescLeft"> </td><td class="mdescRight">Copies the <code>Vertex_handle</code>s of all finite vertices adjacent to <code>v</code> to the output iterator <code>vertices</code>.  <br></td></tr>
<tr class="separator:af779084dce02eb4abba8bd1916891214"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a158716f1ea0f94c5f837a5ae244e2fe3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#ab33c8cdfd6a571cf9635a531d2d261a0">size_type</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a158716f1ea0f94c5f837a5ae244e2fe3">degree</a> (<a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> v) const</td></tr>
<tr class="memdesc:a158716f1ea0f94c5f837a5ae244e2fe3"><td class="mdescLeft"> </td><td class="mdescRight">Returns the degree of a vertex, that is, the number of incident vertices.  <br></td></tr>
<tr class="separator:a158716f1ea0f94c5f837a5ae244e2fe3"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Traversal Between Adjacent Cells</h2></td></tr>
<tr class="memitem:a74cfefe0ac5dbe8e734461cda606a189"><td class="memItemLeft" align="right" valign="top">int </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a74cfefe0ac5dbe8e734461cda606a189">mirror_index</a> (<a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> c, int i) const</td></tr>
<tr class="memdesc:a74cfefe0ac5dbe8e734461cda606a189"><td class="mdescLeft"> </td><td class="mdescRight">Returns the index of <code>c</code> in its \( i^{th}\) neighbor.  <br></td></tr>
<tr class="separator:a74cfefe0ac5dbe8e734461cda606a189"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a35ba5a05076bfeb5357ccdc182b12fee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a35ba5a05076bfeb5357ccdc182b12fee">mirror_vertex</a> (<a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> c, int i) const</td></tr>
<tr class="memdesc:a35ba5a05076bfeb5357ccdc182b12fee"><td class="mdescLeft"> </td><td class="mdescRight">Returns the vertex of the \( i^{th}\) neighbor of <code>c</code> that is opposite to <code>c</code>.  <br></td></tr>
<tr class="separator:a35ba5a05076bfeb5357ccdc182b12fee"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae443600f92d600b8e7d63a7fe2b5220c"><td class="memItemLeft" align="right" valign="top"><a id="ae443600f92d600b8e7d63a7fe2b5220c" name="ae443600f92d600b8e7d63a7fe2b5220c"></a>
<a class="el" href="classCGAL_1_1Triangulation__3.html#aa100228164b0cf78d5c2b1009c2df258">Facet</a> </td><td class="memItemRight" valign="bottom"><b>mirror_facet</b> (<a class="el" href="classCGAL_1_1Triangulation__3.html#aa100228164b0cf78d5c2b1009c2df258">Facet</a> f) const</td></tr>
<tr class="memdesc:ae443600f92d600b8e7d63a7fe2b5220c"><td class="mdescLeft"> </td><td class="mdescRight">Returns the same facet seen from the other adjacent cell. <br></td></tr>
<tr class="separator:ae443600f92d600b8e7d63a7fe2b5220c"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Checking</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>The responsibility of keeping a valid triangulation belongs to the user when using advanced operations allowing a direct manipulation of cells and vertices.</p>
<p>We provide the user with the following methods to help debugging. </p>
</td></tr>
<tr class="memitem:a76fa2f93b007c62d2c9d8deb09d8c5aa"><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a76fa2f93b007c62d2c9d8deb09d8c5aa">is_valid</a> (bool verbose=false) const</td></tr>
<tr class="memdesc:a76fa2f93b007c62d2c9d8deb09d8c5aa"><td class="mdescLeft"> </td><td class="mdescRight">This is a function for debugging purpose.  <br></td></tr>
<tr class="separator:a76fa2f93b007c62d2c9d8deb09d8c5aa"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a57226e0d36b9fb236a0d6711cda456d0"><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Triangulation__3.html#a57226e0d36b9fb236a0d6711cda456d0">is_valid</a> (<a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> c, bool verbose=false) const</td></tr>
<tr class="memdesc:a57226e0d36b9fb236a0d6711cda456d0"><td class="mdescLeft"> </td><td class="mdescRight">This is a function for debugging purpose.  <br></td></tr>
<tr class="separator:a57226e0d36b9fb236a0d6711cda456d0"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">I/O</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>The information in the <code>iostream</code> is: the dimension, the number of finite vertices, the non-combinatorial information about vertices (point, etc; note that the infinite vertex is numbered 0), the number of cells, the indices of the vertices of each cell, plus the non-combinatorial information about each cell, then the indices of the neighbors of each cell, where the index corresponds to the preceding list of cells.</p>
<p>When dimension \( &lt;\) 3, the same information is stored for faces of maximal dimension instead of cells. </p>
</td></tr>
<tr class="memitem:gaeea8fffe7fd436b5613b31b973f89563"><td class="memItemLeft" align="right" valign="top">istream &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__PkgIOTriangulation3.html#gaeea8fffe7fd436b5613b31b973f89563">operator&gt;&gt;</a> (istream &amp;is, <a class="el" href="classCGAL_1_1Triangulation__3.html">Triangulation_3</a> &amp;t)</td></tr>
<tr class="memdesc:gaeea8fffe7fd436b5613b31b973f89563"><td class="mdescLeft"> </td><td class="mdescRight">Reads the underlying combinatorial triangulation from <code>is</code> by calling the corresponding input operator of the triangulation data structure class (note that the infinite vertex is numbered 0), and the non-combinatorial information by calling the corresponding input operators of the vertex and the cell classes (such as point coordinates), which are provided by overloading the stream operators of the vertex and cell types.  <br></td></tr>
<tr class="separator:gaeea8fffe7fd436b5613b31b973f89563"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaf38f71bfe4880acf5f41844a5204997e"><td class="memItemLeft" align="right" valign="top">
ostream &amp; </td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (ostream &amp;os, const <a class="el" href="classCGAL_1_1Triangulation__3.html">Triangulation_3</a> &amp;t)</td></tr>
<tr class="memdesc:gaf38f71bfe4880acf5f41844a5204997e"><td class="mdescLeft"> </td><td class="mdescRight">Writes the triangulation <code>t</code> into <code>os</code>. <br></td></tr>
<tr class="separator:gaf38f71bfe4880acf5f41844a5204997e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga20493e5839004e16ccd5929397b2ec75"><td class="memTemplParams" colspan="2">template&lt;typename Tr_src , typename ConvertVertex , typename ConvertCell &gt; </td></tr>
<tr class="memitem:ga20493e5839004e16ccd5929397b2ec75"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__PkgIOTriangulation3.html#ga20493e5839004e16ccd5929397b2ec75">file_input</a> (std::istream &amp;is, ConvertVertex convert_vertex=ConvertVertex(), ConvertCell convert_cell=ConvertCell())</td></tr>
<tr class="memdesc:ga20493e5839004e16ccd5929397b2ec75"><td class="mdescLeft"> </td><td class="mdescRight">The triangulation streamed in <code>is</code>, of original type <code>Tr_src</code>, is written into the triangulation.  <br></td></tr>
<tr class="separator:ga20493e5839004e16ccd5929397b2ec75"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Concurrency</h2></td></tr>
<tr class="memitem:afba384e440c57f3bb0a71e4b4f7f9944"><td class="memItemLeft" align="right" valign="top"><a id="afba384e440c57f3bb0a71e4b4f7f9944" name="afba384e440c57f3bb0a71e4b4f7f9944"></a>
void </td><td class="memItemRight" valign="bottom"><b>set_lock_data_structure</b> (<a class="el" href="classCGAL_1_1Triangulation__3.html#a1f96730cb3b4cfd6c2893ecb7300ec90">Lock_data_structure</a> *lock_ds) const</td></tr>
<tr class="memdesc:afba384e440c57f3bb0a71e4b4f7f9944"><td class="mdescLeft"> </td><td class="mdescRight">Set the pointer to the lock data structure. <br></td></tr>
<tr class="separator:afba384e440c57f3bb0a71e4b4f7f9944"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_structCGAL_1_1Triangulation__utils__3"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_structCGAL_1_1Triangulation__utils__3')"><img src="closed.png" alt="-"> Static Public Member Functions inherited from <a class="el" href="../TDS_3/structCGAL_1_1Triangulation__utils__3.html">CGAL::Triangulation_utils_3</a></td></tr>
<tr class="memitem:a54bf42467e28dcbea13bfd022ef49217 inherit pub_static_methods_structCGAL_1_1Triangulation__utils__3"><td class="memItemLeft" align="right" valign="top"><a id="a54bf42467e28dcbea13bfd022ef49217" name="a54bf42467e28dcbea13bfd022ef49217"></a>
static unsigned int </td><td class="memItemRight" valign="bottom"><a class="elRef" href="../TDS_3/structCGAL_1_1Triangulation__utils__3.html#a54bf42467e28dcbea13bfd022ef49217">next_around_edge</a> (unsigned int i, unsigned int j)</td></tr>
<tr class="separator:a54bf42467e28dcbea13bfd022ef49217 inherit pub_static_methods_structCGAL_1_1Triangulation__utils__3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a71288c8c2833f954a73090336ed60054 inherit pub_static_methods_structCGAL_1_1Triangulation__utils__3"><td class="memItemLeft" align="right" valign="top"><a id="a71288c8c2833f954a73090336ed60054" name="a71288c8c2833f954a73090336ed60054"></a>
static int </td><td class="memItemRight" valign="bottom"><a class="elRef" href="../TDS_3/structCGAL_1_1Triangulation__utils__3.html#a71288c8c2833f954a73090336ed60054">vertex_triple_index</a> (const int i, const int j)</td></tr>
<tr class="separator:a71288c8c2833f954a73090336ed60054 inherit pub_static_methods_structCGAL_1_1Triangulation__utils__3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3e483dd7b1e45dd3bcce3dbc7f94bd70 inherit pub_static_methods_structCGAL_1_1Triangulation__utils__3"><td class="memItemLeft" align="right" valign="top"><a id="a3e483dd7b1e45dd3bcce3dbc7f94bd70" name="a3e483dd7b1e45dd3bcce3dbc7f94bd70"></a>
static unsigned int </td><td class="memItemRight" valign="bottom"><a class="elRef" href="../TDS_3/structCGAL_1_1Triangulation__utils__3.html#a3e483dd7b1e45dd3bcce3dbc7f94bd70">ccw</a> (unsigned int i)</td></tr>
<tr class="separator:a3e483dd7b1e45dd3bcce3dbc7f94bd70 inherit pub_static_methods_structCGAL_1_1Triangulation__utils__3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a39b8813b2f15dcb4446ff42b5c100529 inherit pub_static_methods_structCGAL_1_1Triangulation__utils__3"><td class="memItemLeft" align="right" valign="top"><a id="a39b8813b2f15dcb4446ff42b5c100529" name="a39b8813b2f15dcb4446ff42b5c100529"></a>
static unsigned int </td><td class="memItemRight" valign="bottom"><a class="elRef" href="../TDS_3/structCGAL_1_1Triangulation__utils__3.html#a39b8813b2f15dcb4446ff42b5c100529">cw</a> (unsigned int i)</td></tr>
<tr class="separator:a39b8813b2f15dcb4446ff42b5c100529 inherit pub_static_methods_structCGAL_1_1Triangulation__utils__3"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a39088e35d874ae7361d96a19acd572c7" name="a39088e35d874ae7361d96a19acd572c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39088e35d874ae7361d96a19acd572c7">◆ </a></span>Segment_cell_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::Segment_cell_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>iterator over cells intersected by a line segment. </p>
<p><code>Segment_cell_iterator</code> implements the concept <code><a class="elRef" href="../Manual/classForwardIterator.html">ForwardIterator</a></code> and is non-mutable. Its value type is <code>Cell_handle</code>. </p>

</div>
</div>
<a id="a822c7264ac03f629735cb85be4871e1f" name="a822c7264ac03f629735cb85be4871e1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a822c7264ac03f629735cb85be4871e1f">◆ </a></span>Segment_simplex_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::Segment_simplex_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>iterator over simplices intersected by a line segment. </p>
<p><code>Segment_simplex_iterator</code> implements the concept <code><a class="elRef" href="../Manual/classForwardIterator.html">ForwardIterator</a></code> and is non-mutable. Its value type is <code><a class="el" href="classCGAL_1_1Triangulation__simplex__3.html" title="The class Triangulation_simplex_3 stores a simplex of any dimension defined by the Triangulation_3 cl...">Triangulation_simplex_3</a></code>. </p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a5bea7d3470854571f97c18a675daca75" name="a5bea7d3470854571f97c18a675daca75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bea7d3470854571f97c18a675daca75">◆ </a></span>Locate_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classCGAL_1_1Triangulation__3.html#a5bea7d3470854571f97c18a675daca75">CGAL::Triangulation_3::Locate_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The enum <code>Locate_type</code> is defined by <code><a class="el" href="classCGAL_1_1Triangulation__3.html" title="The class Triangulation_3 represents a 3-dimensional tetrahedralization of points.">Triangulation_3</a></code> to specify which case occurs when locating a point in the triangulation. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5bea7d3470854571f97c18a675daca75a285953109776e1f27769b65bb7249994" name="a5bea7d3470854571f97c18a675daca75a285953109776e1f27769b65bb7249994"></a>VERTEX </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a5bea7d3470854571f97c18a675daca75a708387eea38c6e1ffbd7ef5ef695f2e1" name="a5bea7d3470854571f97c18a675daca75a708387eea38c6e1ffbd7ef5ef695f2e1"></a>EDGE </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a5bea7d3470854571f97c18a675daca75acb284e3051bc02bd4645aca6b2382b42" name="a5bea7d3470854571f97c18a675daca75acb284e3051bc02bd4645aca6b2382b42"></a>FACET </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a5bea7d3470854571f97c18a675daca75aa264f5df83d639caa57ea1def2f16f36" name="a5bea7d3470854571f97c18a675daca75aa264f5df83d639caa57ea1def2f16f36"></a>CELL </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a5bea7d3470854571f97c18a675daca75a4ed6b6faec7f4a57a66120b7c5c11471" name="a5bea7d3470854571f97c18a675daca75a4ed6b6faec7f4a57a66120b7c5c11471"></a>OUTSIDE_CONVEX_HULL </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a5bea7d3470854571f97c18a675daca75a922f153be5cccf0228b56f5160e47e6a" name="a5bea7d3470854571f97c18a675daca75a922f153be5cccf0228b56f5160e47e6a"></a>OUTSIDE_AFFINE_HULL </td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2378218ec06f4a4daec0102760da4d73" name="a2378218ec06f4a4daec0102760da4d73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2378218ec06f4a4daec0102760da4d73">◆ </a></span>Triangulation_3() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::Triangulation_3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__3.html#ab250045d0412b06d83977a0c2cf33ff9">Geom_traits</a> &amp; </td>
          <td class="paramname"><em>traits</em> = <code><a class="el" href="classCGAL_1_1Triangulation__3.html#ab250045d0412b06d83977a0c2cf33ff9">Geom_traits</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1f96730cb3b4cfd6c2893ecb7300ec90">Lock_data_structure</a> * </td>
          <td class="paramname"><em>lock_ds</em> = <code>nullptr</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Introduces a triangulation <code>t</code> having only one vertex which is the infinite vertex. </p>
<p><code>lock_ds</code> is an optional pointer to the lock data structure for parallel operations. It must be provided if concurrency is enabled. </p>

</div>
</div>
<a id="a7018c73a59388a6d005e8fea1b5c1c32" name="a7018c73a59388a6d005e8fea1b5c1c32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7018c73a59388a6d005e8fea1b5c1c32">◆ </a></span>Triangulation_3() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::Triangulation_3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__3.html">Triangulation_3</a>&lt; Traits, TDS, SLDS &gt; &amp; </td>
          <td class="paramname"><em>tr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>All vertices and faces are duplicated. The pointer to the lock data structure is not copied. Thus, the copy won't be concurrency-safe as long as the user has not call <code><a class="el" href="classCGAL_1_1Triangulation__3.html#afba384e440c57f3bb0a71e4b4f7f9944" title="Set the pointer to the lock data structure.">Triangulation_3::set_lock_data_structure</a></code>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa9814b11ee0a6e024fd3cee4cff066c3" name="aa9814b11ee0a6e024fd3cee4cff066c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9814b11ee0a6e024fd3cee4cff066c3">◆ </a></span>adjacent_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
<div class="memtemplate">
template&lt;class <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::adjacent_vertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> </td>
          <td class="paramname"><em>vertices</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the <code>Vertex_handle</code>s of all vertices adjacent to <code>v</code> to the output iterator <code>vertices</code>. </p>
<p>If <code>t.dimension() &lt; 0</code>, then do nothing. Returns the resulting output iterator. </p><dl class="section pre"><dt>Precondition</dt><dd><code>v != <a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19" title="handle to a vertex">Vertex_handle()</a></code>, <code>t.is_vertex(v)</code>. </dd></dl>

</div>
</div>
<a id="a16e64be4b2c33a5e5442a07b771e3241" name="a16e64be4b2c33a5e5442a07b771e3241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16e64be4b2c33a5e5442a07b771e3241">◆ </a></span>all_cell_handles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#a0ffff120af16e255cee2ccc20be34775">All_cell_handles</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::all_cell_handles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a range of iterators over all cells (even the infinite cells). </p>
<p>Returns an empty range when <code>t.number_of_cells() == 0</code>. </p><dl class="section note"><dt>Note</dt><dd>While the value type of <code>All_cells_iterator</code> is <code>Cell</code>, the value type of <code><a class="elRef" href="../STL_Extension/classCGAL_1_1Iterator__range.html#a1d3ce46c713f038f903619aff460f828">All_cell_handles::iterator</a></code> is <code>Cell_handle</code>. </dd></dl>

</div>
</div>
<a id="ad20bfae1b250b357d8ae5bc48eef1f10" name="ad20bfae1b250b357d8ae5bc48eef1f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad20bfae1b250b357d8ae5bc48eef1f10">◆ </a></span>all_cells_begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#aff2c019af34403770e6e922d616eaf0f">All_cells_iterator</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::all_cells_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts at an arbitrary cell. </p>
<p>Iterates over all cells (even infinite ones). Returns <code>cells_end()</code> when <code>t.dimension() &lt; 3</code>. </p>

</div>
</div>
<a id="a67412622209344f2f8660b337a6d5e35" name="a67412622209344f2f8660b337a6d5e35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67412622209344f2f8660b337a6d5e35">◆ </a></span>all_edges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#a60c2dacc98d57951b9209f94dfcad921">All_edges</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::all_edges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a range of iterators starting at an arbitrary edge. </p>
<p>Returns an empty range when <code>t.dimension() &lt; 2</code>. </p>

</div>
</div>
<a id="af284c5406d004ea3316ed61f5a825887" name="af284c5406d004ea3316ed61f5a825887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af284c5406d004ea3316ed61f5a825887">◆ </a></span>all_edges_begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#a67ff0ee4eca14392f1fcb55acd5a6edc">All_edges_iterator</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::all_edges_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts at an arbitrary edge. </p>
<p>Iterates over all edges (even infinite ones). Returns <code>edges_end()</code> when <code>t.dimension() &lt; 1</code>. </p>

</div>
</div>
<a id="ab15ab30eb9c54106a96916868f454eef" name="ab15ab30eb9c54106a96916868f454eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15ab30eb9c54106a96916868f454eef">◆ </a></span>all_facets()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#abe601aa6506352a8df0877449bcf0dd3">All_facets</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::all_facets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a range of iterators starting at an arbitrary facet. </p>
<p>Returns an empty range when <code>t.dimension() &lt; 2</code>. </p>

</div>
</div>
<a id="af412b76826082617ad5cd7a6428561b0" name="af412b76826082617ad5cd7a6428561b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af412b76826082617ad5cd7a6428561b0">◆ </a></span>all_facets_begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#a086ed61d6d43a10f77f6a4d695a256fc">All_facets_iterator</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::all_facets_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts at an arbitrary facet. </p>
<p>Iterates over all facets (even infinite ones). Returns <code>facets_end()</code> when <code>t.dimension() &lt; 2</code>. </p>

</div>
</div>
<a id="a61c04821ce4e5b41ce3fb95a22737a9a" name="a61c04821ce4e5b41ce3fb95a22737a9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61c04821ce4e5b41ce3fb95a22737a9a">◆ </a></span>all_vertex_handles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#ae53e08aa6f86bee125ef6ba075b0e973">All_vertex_handles</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::all_vertex_handles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a range of iterators over all vertices (even the infinite one). </p>
<dl class="section note"><dt>Note</dt><dd>While the value type of <code>All_vertices_iterator</code> is <code>Vertex</code>, the value type of <code><a class="elRef" href="../STL_Extension/classCGAL_1_1Iterator__range.html#a1d3ce46c713f038f903619aff460f828">All_vertex_handles::iterator</a></code> is <code>Vertex_handle</code>. </dd></dl>

</div>
</div>
<a id="aba04013896bdd4ea1398320869e2d886" name="aba04013896bdd4ea1398320869e2d886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba04013896bdd4ea1398320869e2d886">◆ </a></span>all_vertices_begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#ab930d6f34c8346b5191e93ab79475c70">All_vertices_iterator</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::all_vertices_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts at an arbitrary vertex. </p>
<p>Iterates over all vertices (even the infinite one). </p>

</div>
</div>
<a id="a9f0c69f352b9e7fd325980807778b031" name="a9f0c69f352b9e7fd325980807778b031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f0c69f352b9e7fd325980807778b031">◆ </a></span>are_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::are_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__3.html#aa100228164b0cf78d5c2b1009c2df258">Facet</a> &amp; </td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> </td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>j</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For these three methods: </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>t.dimension() == 3</code>. </dd></dl>

</div>
</div>
<a id="a158716f1ea0f94c5f837a5ae244e2fe3" name="a158716f1ea0f94c5f837a5ae244e2fe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a158716f1ea0f94c5f837a5ae244e2fe3">◆ </a></span>degree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#ab33c8cdfd6a571cf9635a531d2d261a0">size_type</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::degree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the degree of a vertex, that is, the number of incident vertices. </p>
<p>The infinite vertex is counted. </p><dl class="section pre"><dt>Precondition</dt><dd><code>v != <a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19" title="handle to a vertex">Vertex_handle()</a></code>, <code>t.is_vertex(v)</code>. </dd></dl>

</div>
</div>
<a id="af779084dce02eb4abba8bd1916891214" name="af779084dce02eb4abba8bd1916891214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af779084dce02eb4abba8bd1916891214">◆ </a></span>finite_adjacent_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
<div class="memtemplate">
template&lt;class <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::finite_adjacent_vertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> </td>
          <td class="paramname"><em>vertices</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the <code>Vertex_handle</code>s of all finite vertices adjacent to <code>v</code> to the output iterator <code>vertices</code>. </p>
<p>If <code>t.dimension() &lt; 0</code>, then do nothing. Returns the resulting output iterator. </p><dl class="section pre"><dt>Precondition</dt><dd><code>v != <a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19" title="handle to a vertex">Vertex_handle()</a></code>, <code>t.is_vertex(v)</code>. </dd></dl>

</div>
</div>
<a id="ab9584da45f55288fb2b9d0624250bbf3" name="ab9584da45f55288fb2b9d0624250bbf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9584da45f55288fb2b9d0624250bbf3">◆ </a></span>finite_cell_handles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#a4c94face5ab29897bcb291f157f1635d">Finite_cell_handles</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::finite_cell_handles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a range of iterators over finite cells. </p>
<p>Returns an empty range when <code>t.number_of_cells() == 0</code>. </p><dl class="section note"><dt>Note</dt><dd>While the value type of <code>Finite_cells_iterator</code> is <code>Cell</code>, the value type of <code><a class="elRef" href="../STL_Extension/classCGAL_1_1Iterator__range.html#a1d3ce46c713f038f903619aff460f828">Finite_cell_handles::iterator</a></code> is <code>Cell_handle</code>. </dd></dl>

</div>
</div>
<a id="a433fa868d7637f2719a40c251bd2ae65" name="a433fa868d7637f2719a40c251bd2ae65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a433fa868d7637f2719a40c251bd2ae65">◆ </a></span>finite_cells_begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#a6d1b83cb6fba001622452aa0f6592e02">Finite_cells_iterator</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::finite_cells_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts at an arbitrary finite cell. </p>
<p>Then <code>++</code> and <code>--</code> will iterate over finite cells. Returns <code><a class="el" href="classCGAL_1_1Triangulation__3.html#a3431b35584d93e305c1548228cf93110" title="Past-the-end iterator.">finite_cells_end()</a></code> when <code>t.dimension() &lt; 3</code>. </p>

</div>
</div>
<a id="afb40860f9602b54c62c0b7ad645278d3" name="afb40860f9602b54c62c0b7ad645278d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb40860f9602b54c62c0b7ad645278d3">◆ </a></span>finite_edges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#a514f885323d414200cd13e8fa6e79e34">Finite_edges</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::finite_edges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a range of iterators starting at an arbitrary edge. </p>
<p>Returns an empty range when <code>t.dimension() &lt; 2</code>. </p>

</div>
</div>
<a id="af682021f6f9be1437fe29be125ad14e8" name="af682021f6f9be1437fe29be125ad14e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af682021f6f9be1437fe29be125ad14e8">◆ </a></span>finite_edges_begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1c91aeb6128d5bf33995dca02398d330">Finite_edges_iterator</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::finite_edges_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts at an arbitrary finite edge. </p>
<p>Then <code>++</code> and <code>--</code> will iterate over finite edges. </p>

</div>
</div>
<a id="a95e37032ae2a232c6ac42b114fd7c432" name="a95e37032ae2a232c6ac42b114fd7c432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e37032ae2a232c6ac42b114fd7c432">◆ </a></span>finite_facets()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#aa35974d42ec9564687ffbe5f664cb906">Finite_facets</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::finite_facets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a range of iterators starting at an arbitrary facet. </p>
<p>Returns an empty range when <code>t.dimension() &lt; 2</code>. </p>

</div>
</div>
<a id="adcb08049b8d50168079bbba248f3344d" name="adcb08049b8d50168079bbba248f3344d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcb08049b8d50168079bbba248f3344d">◆ </a></span>finite_facets_begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#a6bc54bfb8362670059a4c1a416269994">Finite_facets_iterator</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::finite_facets_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts at an arbitrary finite facet. </p>
<p>Then <code>++</code> and <code>--</code> will iterate over finite facets. Returns <code><a class="el" href="classCGAL_1_1Triangulation__3.html#aee05b9fc603428dfda9712b6c069e4e5" title="Past-the-end iterator.">finite_facets_end()</a></code> when <code>t.dimension() &lt; 2</code>. </p>

</div>
</div>
<a id="af3ca792eed2f27ccb932d5f67ce4c6b9" name="af3ca792eed2f27ccb932d5f67ce4c6b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ca792eed2f27ccb932d5f67ce4c6b9">◆ </a></span>finite_incident_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
<div class="memtemplate">
template&lt;class <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::finite_incident_cells </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> </td>
          <td class="paramname"><em>cells</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the <code>Cell_handle</code>s of all finite cells incident to <code>v</code> to the output iterator <code>cells</code>. </p>
<p>Returns the resulting output iterator. </p><dl class="section pre"><dt>Precondition</dt><dd><code>t.dimension() == 3</code>, <code>v != <a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19" title="handle to a vertex">Vertex_handle()</a></code>, <code>t.is_vertex(v)</code>. </dd></dl>

</div>
</div>
<a id="ab5b49dae39468e544c183142169208f1" name="ab5b49dae39468e544c183142169208f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5b49dae39468e544c183142169208f1">◆ </a></span>finite_incident_edges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
<div class="memtemplate">
template&lt;class <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::finite_incident_edges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> </td>
          <td class="paramname"><em>edges</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies all finite <code>Edge</code>s incident to <code>v</code> to the output iterator <code>edges</code>. </p>
<p>Returns the resulting output iterator. </p><dl class="section pre"><dt>Precondition</dt><dd><code>t.dimension() &gt; 0</code>, <code>v != <a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19" title="handle to a vertex">Vertex_handle()</a></code>, <code>t.is_vertex(v)</code>. </dd></dl>

</div>
</div>
<a id="a1a08f1fcb24e5cd713d862e339ff3f4d" name="a1a08f1fcb24e5cd713d862e339ff3f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a08f1fcb24e5cd713d862e339ff3f4d">◆ </a></span>finite_incident_facets()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
<div class="memtemplate">
template&lt;class <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::finite_incident_facets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> </td>
          <td class="paramname"><em>facets</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies all finite <code>Facet</code>s incident to <code>v</code> to the output iterator <code>facets</code>. </p>
<p>Returns the resulting output iterator. </p><dl class="section pre"><dt>Precondition</dt><dd><code>t.dimension() &gt; 1</code>, <code>v != <a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19" title="handle to a vertex">Vertex_handle()</a></code>, <code>t.is_vertex(v)</code>. </dd></dl>

</div>
</div>
<a id="a33a4aa893719a091df83ee40ad63a49f" name="a33a4aa893719a091df83ee40ad63a49f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a4aa893719a091df83ee40ad63a49f">◆ </a></span>finite_vertex_handles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac59a8c8f173db4a1e72b537bb59e16a5">Finite_vertex_handles</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::finite_vertex_handles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a range of iterators over finite vertices. </p>
<dl class="section note"><dt>Note</dt><dd>While the value type of <code>Finite_vertices_iterator</code> is <code>Vertex</code>, the value type of <code><a class="elRef" href="../STL_Extension/classCGAL_1_1Iterator__range.html#a1d3ce46c713f038f903619aff460f828">Finite_vertex_handles::iterator</a></code> is <code>Vertex_handle</code>. </dd></dl>

</div>
</div>
<a id="af43b5f09e0fdcb9b8fff939133f2e814" name="af43b5f09e0fdcb9b8fff939133f2e814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af43b5f09e0fdcb9b8fff939133f2e814">◆ </a></span>finite_vertices_begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#af8d044953011cb5ff6a5ecf87e6f308e">Finite_vertices_iterator</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::finite_vertices_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts at an arbitrary finite vertex. </p>
<p>Then <code>++</code> and <code>--</code> will iterate over finite vertices. </p>

</div>
</div>
<a id="a8050a0e63dcf0fed2e205ce69b0fa2fe" name="a8050a0e63dcf0fed2e205ce69b0fa2fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8050a0e63dcf0fed2e205ce69b0fa2fe">◆ </a></span>flip() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::flip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> </td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>i</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Before flipping, these methods check that facet <code>f=(c,i)</code> is flippable (which is quite expensive). </p>
<p>They return <code>false</code> or <code>true</code> according to this test. </p>

</div>
</div>
<a id="a5dfdcfc38bf0bf30860d26d0fef7fdc7" name="a5dfdcfc38bf0bf30860d26d0fef7fdc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dfdcfc38bf0bf30860d26d0fef7fdc7">◆ </a></span>flip() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::flip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> </td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>j</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Before flipping, these methods check that edge <code>e=(c,i,j)</code> is flippable (which is quite expensive). </p>
<p>They return <code>false</code> or <code>true</code> according to this test. </p>

</div>
</div>
<a id="a1d8720ff50a61985bcbe474268d9d275" name="a1d8720ff50a61985bcbe474268d9d275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d8720ff50a61985bcbe474268d9d275">◆ </a></span>flip_flippable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::flip_flippable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> </td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>i</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Should be preferred to the previous methods when the facet is known to be flippable. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The facet is flippable. </dd></dl>

</div>
</div>
<a id="ac31682068c1ff25dc5ccd6f366fd1156" name="ac31682068c1ff25dc5ccd6f366fd1156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac31682068c1ff25dc5ccd6f366fd1156">◆ </a></span>flip_flippable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::flip_flippable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> </td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>j</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Should be preferred to the previous methods when the edge is known to be flippable. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The edge is flippable. </dd></dl>

</div>
</div>
<a id="abf51c96f47c1e295fb984ad521634229" name="abf51c96f47c1e295fb984ad521634229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf51c96f47c1e295fb984ad521634229">◆ </a></span>has_vertex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::has_vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> </td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp; </td>
          <td class="paramname"><em>j</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same for facet <code>(c,i)</code>. </p>
<p>Computes the index <code>j</code> of <code>v</code> in <code>c</code>. </p>

</div>
</div>
<a id="a89a5c93d1e8a43cef317ef289f1d5482" name="a89a5c93d1e8a43cef317ef289f1d5482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89a5c93d1e8a43cef317ef289f1d5482">◆ </a></span>has_vertex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::has_vertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__3.html#aa100228164b0cf78d5c2b1009c2df258">Facet</a> &amp; </td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp; </td>
          <td class="paramname"><em>j</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>v</code> is a vertex of <code>f</code>, then <code>j</code> is the index of <code>v</code> in the cell <code>f.first</code>, and the method returns <code>true</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>t.dimension() == 3</code> </dd></dl>

</div>
</div>
<a id="a0741a861a6291131384529349cb994a4" name="a0741a861a6291131384529349cb994a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0741a861a6291131384529349cb994a4">◆ </a></span>incident_cells() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#a064fb43553690504ee55c4b9a74188e5">Cell_circulator</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::incident_cells </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#a0f355dbb38cf631f24d4df8abd7a942f">Edge</a> </td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts at an arbitrary cell incident to <code>e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>t.dimension() == 3</code>. </dd></dl>

</div>
</div>
<a id="a85d53f656ef4d67ccbf6eaed424e0a35" name="a85d53f656ef4d67ccbf6eaed424e0a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d53f656ef4d67ccbf6eaed424e0a35">◆ </a></span>incident_cells() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#a064fb43553690504ee55c4b9a74188e5">Cell_circulator</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::incident_cells </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#a0f355dbb38cf631f24d4df8abd7a942f">Edge</a> </td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> </td>
          <td class="paramname"><em>start</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts at cell <code>start</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>t.dimension() == 3</code> and <code>start</code> is incident to <code>e</code>. </dd></dl>

</div>
</div>
<a id="ad9890c64030969cd74f35a007cb6b049" name="ad9890c64030969cd74f35a007cb6b049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9890c64030969cd74f35a007cb6b049">◆ </a></span>incident_cells() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
<div class="memtemplate">
template&lt;class <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::incident_cells </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> </td>
          <td class="paramname"><em>cells</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the <code>Cell_handle</code>s of all cells incident to <code>v</code> to the output iterator <code>cells</code>. </p>
<p>Returns the resulting output iterator. </p><dl class="section pre"><dt>Precondition</dt><dd><code>t.dimension() == 3</code>, <code>v != <a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19" title="handle to a vertex">Vertex_handle()</a></code>, <code>t.is_vertex(v)</code>. </dd></dl>

</div>
</div>
<a id="a81373c29a596ba2f1d6d93e62d1f0d79" name="a81373c29a596ba2f1d6d93e62d1f0d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81373c29a596ba2f1d6d93e62d1f0d79">◆ </a></span>incident_edges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
<div class="memtemplate">
template&lt;class <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::incident_edges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> </td>
          <td class="paramname"><em>edges</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies all <code>Edge</code>s incident to <code>v</code> to the output iterator <code>edges</code>. </p>
<p>Returns the resulting output iterator. </p><dl class="section pre"><dt>Precondition</dt><dd><code>t.dimension() &gt; 0</code>, <code>v != <a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19" title="handle to a vertex">Vertex_handle()</a></code>, <code>t.is_vertex(v)</code>. </dd></dl>

</div>
</div>
<a id="a997be4328927428bce5aee9f775e5e55" name="a997be4328927428bce5aee9f775e5e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a997be4328927428bce5aee9f775e5e55">◆ </a></span>incident_facets() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1c904fc6cbfe189b2cb09f7175044b00">Facet_circulator</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::incident_facets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#a0f355dbb38cf631f24d4df8abd7a942f">Edge</a> </td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts at an arbitrary facet incident to <code>e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>t.dimension() == 3</code> </dd></dl>

</div>
</div>
<a id="a1cbaaed93e5d67671302649501585a98" name="a1cbaaed93e5d67671302649501585a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cbaaed93e5d67671302649501585a98">◆ </a></span>incident_facets() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1c904fc6cbfe189b2cb09f7175044b00">Facet_circulator</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::incident_facets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#a0f355dbb38cf631f24d4df8abd7a942f">Edge</a> </td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#aa100228164b0cf78d5c2b1009c2df258">Facet</a> </td>
          <td class="paramname"><em>start</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts at facet <code>start</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>start</code> is incident to <code>e</code>. </dd></dl>

</div>
</div>
<a id="a2776f24c7e4cdefc0c511edebf1d3599" name="a2776f24c7e4cdefc0c511edebf1d3599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2776f24c7e4cdefc0c511edebf1d3599">◆ </a></span>incident_facets() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
<div class="memtemplate">
template&lt;class <a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::incident_facets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../Manual/classOutputIterator.html">OutputIterator</a> </td>
          <td class="paramname"><em>facets</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies all <code>Facet</code>s incident to <code>v</code> to the output iterator <code>facets</code>. </p>
<p>Returns the resulting output iterator. </p><dl class="section pre"><dt>Precondition</dt><dd><code>t.dimension() &gt; 1</code>, <code>v != <a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19" title="handle to a vertex">Vertex_handle()</a></code>, <code>t.is_vertex(v)</code>. </dd></dl>

</div>
</div>
<a id="af33632f0d268cc25d0df2caa57f69609" name="af33632f0d268cc25d0df2caa57f69609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af33632f0d268cc25d0df2caa57f69609">◆ </a></span>inexact_locate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::inexact_locate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp; </td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> </td>
          <td class="paramname"><em>start</em> = <code><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a>()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <code><a class="el" href="classCGAL_1_1Triangulation__3.html#a02a4a18074670282f3704f32b0901fad" title="If the point query lies inside the convex hull of the points, the cell that contains the query in its...">locate()</a></code> but uses inexact predicates. </p>
<p>This function returns a handle on a cell that is a good approximation of the exact location of <code>query</code>, while being faster. Note that it may return a handle on a cell whose interior does not contain <code>query</code>. When the triangulation has dimension smaller than 3, <code>start</code> is returned.</p>
<p>Note that this function is available only if the cartesian coordinates of <code>query</code> are accessible with functions <code>x()</code>, <code>y()</code> and <code>z()</code>. </p>

</div>
</div>
<a id="ad8d7a1aa3b310ba8d86ede726746fcb3" name="ad8d7a1aa3b310ba8d86ede726746fcb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d7a1aa3b310ba8d86ede726746fcb3">◆ </a></span>insert() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp; </td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> </td>
          <td class="paramname"><em>start</em> = <code><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a>()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the point <code>p</code> in the triangulation and returns the corresponding vertex. </p>
<p>If point <code>p</code> coincides with an already existing vertex, this vertex is returned and the triangulation remains unchanged.</p>
<p>If point <code>p</code> lies in the convex hull of the points, it is added naturally: if it lies inside a cell, the cell is split into four cells, if it lies on a facet, the two incident cells are split into three cells, if it lies on an edge, all the cells incident to this edge are split into two cells.</p>
<p>If point <code>p</code> is strictly outside the convex hull but in the affine hull, <code>p</code> is linked to all visible points on the convex hull to form the new triangulation. See Figure <a class="el" href="classCGAL_1_1Triangulation__3.html#Triangulation3figinsert_outside_convex_hull">Triangulation3figinsert_outside_convex_hull</a>.</p>
<p>If point <code>p</code> is outside the affine hull of the points, <code>p</code> is linked to all the points, and the dimension of the triangulation is incremented. All the points now belong to the boundary of the convex hull, so, the infinite vertex is linked to all the points to triangulate the new infinite face. See Figure <a class="el" href="classCGAL_1_1Triangulation__3.html#Triangulation3figinsert_outside_affine_hull">Triangulation3figinsert_outside_affine_hull</a>. The optional argument <code>start</code> is used as a starting place for the search. </p>

</div>
</div>
<a id="af41ac521888fafda75100fcd36650aa4" name="af41ac521888fafda75100fcd36650aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af41ac521888fafda75100fcd36650aa4">◆ </a></span>insert() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp; </td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#a5bea7d3470854571f97c18a675daca75">Locate_type</a> </td>
          <td class="paramname"><em>lt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> </td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>li</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>lj</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the point <code>p</code> in the triangulation and returns the corresponding vertex. </p>
<p>Similar to the above <code><a class="el" href="classCGAL_1_1Triangulation__3.html#ad8d7a1aa3b310ba8d86ede726746fcb3" title="Inserts the point p in the triangulation and returns the corresponding vertex.">insert()</a></code> function, but takes as additional parameter the return values of a previous location query. See description of <em><a class="el" href="classCGAL_1_1Triangulation__3.html#a02a4a18074670282f3704f32b0901fad" title="If the point query lies inside the convex hull of the points, the cell that contains the query in its...">locate()</a></em> above. </p>

</div>
</div>
<a id="a8aa85f88733d30aa3ec5385538e13ace" name="a8aa85f88733d30aa3ec5385538e13ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aa85f88733d30aa3ec5385538e13ace">◆ </a></span>insert() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
<div class="memtemplate">
template&lt;class PointWithInfoInputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ptrdiff_t <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">PointWithInfoInputIterator </td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointWithInfoInputIterator </td>
          <td class="paramname"><em>last</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the points in the iterator range <code>[first,last)</code> in the given order, and returns the number of inserted points. </p>
<p>Given a pair <code>(p,i)</code>, the vertex <code>v</code> storing <code>p</code> also stores <code>i</code>, that is <code>v.point() == p</code> and <code>v.info() == i</code>. If several pairs have the same point, only one vertex is created, and one of the objects of type <code>Vertex::Info</code> will be stored in the vertex. </p><dl class="section pre"><dt>Precondition</dt><dd><code>Vertex</code> must be model of the concept <code><a class="el" href="classTriangulationVertexBaseWithInfo__3.html" title="A type model of this concept can be used as vertex base by a triangulation and provides an additional...">TriangulationVertexBaseWithInfo_3</a></code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PointWithInfoInputIterator</td><td>must be an input iterator with the value type <code>std::pair&lt;Point,Vertex::Info&gt;</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff8be2085c18e293f6d1a26c282acbc7" name="aff8be2085c18e293f6d1a26c282acbc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff8be2085c18e293f6d1a26c282acbc7">◆ </a></span>insert_in_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::insert_in_cell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp; </td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> </td>
          <td class="paramname"><em>c</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the point <code>p</code> in the cell <code>c</code>. </p>
<p>The cell <code>c</code> is split into 4 tetrahedra. </p><dl class="section pre"><dt>Precondition</dt><dd><code>t.dimension() == 3</code> and <code>p</code> lies strictly inside cell <code>c</code>. </dd></dl>

</div>
</div>
<a id="a06ba9d64000edc9e5d595ae1c7595922" name="a06ba9d64000edc9e5d595ae1c7595922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06ba9d64000edc9e5d595ae1c7595922">◆ </a></span>insert_in_edge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::insert_in_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp; </td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> </td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>j</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>As above, inserts <code>p</code> in the edge \( (i, j)\) of <code>c</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>As above and \( i\neq j\). Moreover \( i,j \in\{0,1,2,3\}\) in dimension 3, \( i,j \in\{0,1,2\}\) in dimension 2, \( i,j \in\{0,1\}\) in dimension 1. </dd></dl>

</div>
</div>
<a id="a5c1349d7fcffeac6f98cfc8b8febf564" name="a5c1349d7fcffeac6f98cfc8b8febf564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c1349d7fcffeac6f98cfc8b8febf564">◆ </a></span>insert_in_edge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::insert_in_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp; </td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__3.html#a0f355dbb38cf631f24d4df8abd7a942f">Edge</a> &amp; </td>
          <td class="paramname"><em>e</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts <code>p</code> in the edge <code>e</code>. </p>
<p>In dimension 3, all the cells having this edge are split into 2 tetrahedra; in dimension 2, the 2 neighboring facets are split into 2 triangles; in dimension 1, the edge is split into 2 edges. </p><dl class="section pre"><dt>Precondition</dt><dd><code>t.dimension()</code> \( \geq1\) and <code>p</code> lies on edge <code>e</code>. </dd></dl>

</div>
</div>
<a id="aa43e9ac9d97a9a2fa18ae18e21bb25b3" name="aa43e9ac9d97a9a2fa18ae18e21bb25b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa43e9ac9d97a9a2fa18ae18e21bb25b3">◆ </a></span>insert_in_facet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::insert_in_facet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp; </td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> </td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>i</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>As above, insertion in the facet <code>(c,i)</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>As above and \( i \in\{0,1,2,3\}\) in dimension 3, \( i = 3\) in dimension 2. </dd></dl>

</div>
</div>
<a id="a80f8771ed8bca545ca451afae14b77ed" name="a80f8771ed8bca545ca451afae14b77ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80f8771ed8bca545ca451afae14b77ed">◆ </a></span>insert_in_facet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::insert_in_facet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp; </td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__3.html#aa100228164b0cf78d5c2b1009c2df258">Facet</a> &amp; </td>
          <td class="paramname"><em>f</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the point <code>p</code> in the facet <code>f</code>. </p>
<p>In dimension 3, the 2 neighboring cells are split into 3 tetrahedra; in dimension 2, the facet is split into 3 triangles. </p><dl class="section pre"><dt>Precondition</dt><dd><code>t.dimension()</code> \( \geq2\) and <code>p</code> lies strictly inside face <code>f</code>. </dd></dl>

</div>
</div>
<a id="a4b298ac4b2d8585dec9e436bb9e65ff0" name="a4b298ac4b2d8585dec9e436bb9e65ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b298ac4b2d8585dec9e436bb9e65ff0">◆ </a></span>insert_in_hole()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
<div class="memtemplate">
template&lt;class CellIt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::insert_in_hole </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp; </td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CellIt </td>
          <td class="paramname"><em>cell_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CellIt </td>
          <td class="paramname"><em>cell_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> </td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>i</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new vertex by starring a hole. </p>
<p>It takes an iterator range <code>[cell_begin,cell_end)</code> of <code>Cell_handle</code>s which specifies a hole: a set of connected cells (resp. facets in dimension 2) which is star-shaped wrt <code>p</code>. (<code>begin</code>, <code>i</code>) is a facet (resp. an edge) on the boundary of the hole, that is, <code>begin</code> belongs to the set of cells (resp. facets) previously described, and <code>begin-&gt;neighbor(i)</code> does not. Then this function deletes all the cells (resp. facets) describing the hole, creates a new vertex <code>v</code>, and for each facet (resp. edge) on the boundary of the hole, creates a new cell (resp. facet) with <code>v</code> as vertex. Then <code>v-&gt;set_point(p)</code> is called and <code>v</code> is returned.</p>
<p>This operation is equivalent to calling <code><a class="el" href="classCGAL_1_1Triangulation__3.html#a951781437d62955aaae730b87c833498" title="Returns a reference to the triangulation data structure.">tds()</a>.insert_in_hole(cell_begin, cell_end, begin, i); v-&gt;set_point(p)</code>. </p><dl class="section pre"><dt>Precondition</dt><dd><code>t.dimension()</code> \( \geq2\), the set of cells (resp. facets in dimension 2) is connected, its boundary is connected, and <code>p</code> lies inside the hole, which is star-shaped wrt <code>p</code>. </dd></dl>

</div>
</div>
<a id="a6f3e038498843f6ce7c0c70015ddaff9" name="a6f3e038498843f6ce7c0c70015ddaff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f3e038498843f6ce7c0c70015ddaff9">◆ </a></span>insert_outside_affine_hull()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::insert_outside_affine_hull </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp; </td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>p</code> is linked to all the points, and the infinite vertex is linked to all the points (including <code>p</code>) to triangulate the new infinite face, so that all the points now belong to the boundary of the convex hull. </p>
<p>See Figure <a class="el" href="classCGAL_1_1Triangulation__3.html#Triangulation3figinsert_outside_affine_hull">Triangulation3figinsert_outside_affine_hull</a>.</p>
<p>This method can be used to insert the first point in an empty triangulation. </p><dl class="section pre"><dt>Precondition</dt><dd><code>t.dimension() &lt; 3</code> and <code>p</code> lies outside the affine hull of the points.</dd></dl>
<p><a class="anchor" id="Triangulation3figinsert_outside_affine_hull"></a></p><div class="image">
<img src="insert_outside_affine_hull.png" alt="">
<div class="caption">
insert_outside_affine_hull() (2-dimensional case)</div></div>
  
</div>
</div>
<a id="a2798aa7502b4929ccaa8cab9bacbff18" name="a2798aa7502b4929ccaa8cab9bacbff18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2798aa7502b4929ccaa8cab9bacbff18">◆ </a></span>insert_outside_convex_hull()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::insert_outside_convex_hull </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp; </td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> </td>
          <td class="paramname"><em>c</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The cell <code>c</code> must be an infinite cell containing <code>p</code>. </p>
<p>Links <code>p</code> to all points in the triangulation that are visible from <code>p</code>. Updates consequently the infinite faces. See Figure <a class="el" href="classCGAL_1_1Triangulation__3.html#Triangulation3figinsert_outside_convex_hull">Triangulation3figinsert_outside_convex_hull</a>. </p><dl class="section pre"><dt>Precondition</dt><dd><code>t.dimension() &gt; 0</code>, <code>c</code>, and the \( k\)-face represented by <code>c</code> is infinite and contains <code>t</code>.</dd></dl>
<p><a class="anchor" id="Triangulation3figinsert_outside_convex_hull"></a></p><div class="image">
<img src="insert_outside_convex_hull.png" alt="">
<div class="caption">
insert_outside_convex_hull() (2-dimensional case)</div></div>
  
</div>
</div>
<a id="a8766c9a0c2a84203be31537e5e015646" name="a8766c9a0c2a84203be31537e5e015646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8766c9a0c2a84203be31537e5e015646">◆ </a></span>is_cell() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::is_cell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> &amp; </td>
          <td class="paramname"><em>c</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether <code>(u,v,w,x)</code> is a cell of <code>t</code> and computes this cell <code>c</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>u</code>, <code>v</code>, <code>w</code> and <code>x</code> are vertices of <code>t</code>. </dd></dl>

</div>
</div>
<a id="a24095561c8bd3390a58f7b7c9e45d4eb" name="a24095561c8bd3390a58f7b7c9e45d4eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24095561c8bd3390a58f7b7c9e45d4eb">◆ </a></span>is_cell() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::is_cell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> &amp; </td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp; </td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp; </td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp; </td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp; </td>
          <td class="paramname"><em>l</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether <code>(u,v,w,x)</code> is a cell of <code>t</code>. </p>
<p>If the cell <code>c</code> is found, the method computes the indices <code>i</code>, <code>j</code>, <code>k</code> and <code>l</code> of the vertices <code>u</code>, <code>v</code>, <code>w</code> and <code>x</code> in <code>c</code>, in this order. </p><dl class="section pre"><dt>Precondition</dt><dd><code>u</code>, <code>v</code>, <code>w</code> and <code>x</code> are vertices of <code>t</code>. </dd></dl>

</div>
</div>
<a id="a55b3dd5c4161a2612bd8aa60d64fb4f1" name="a55b3dd5c4161a2612bd8aa60d64fb4f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b3dd5c4161a2612bd8aa60d64fb4f1">◆ </a></span>is_edge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::is_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> &amp; </td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp; </td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp; </td>
          <td class="paramname"><em>j</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether <code>(u,v)</code> is an edge of <code>t</code>. </p>
<p>If the edge is found, it gives a cell <code>c</code> having this edge and the indices <code>i</code> and <code>j</code> of the vertices <code>u</code> and <code>v</code> in <code>c</code>, in this order. </p><dl class="section pre"><dt>Precondition</dt><dd><code>u</code> and <code>v</code> are vertices of <code>t</code>. </dd></dl>

</div>
</div>
<a id="aef7c688eb2a28c0aec936c41df46a172" name="aef7c688eb2a28c0aec936c41df46a172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef7c688eb2a28c0aec936c41df46a172">◆ </a></span>is_facet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::is_facet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> &amp; </td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp; </td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp; </td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp; </td>
          <td class="paramname"><em>k</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether <code>(u,v,w)</code> is a facet of <code>t</code>. </p>
<p>If the facet is found, it computes a cell <code>c</code> having this facet and the indices <code>i</code>, <code>j</code> and <code>k</code> of the vertices <code>u</code>, <code>v</code> and <code>w</code> in <code>c</code>, in this order. </p><dl class="section pre"><dt>Precondition</dt><dd><code>u</code>, <code>v</code> and <code>w</code> are vertices of <code>t</code>. </dd></dl>

</div>
</div>
<a id="a8bc2a0fa204265bf32f1e6dc103988b4" name="a8bc2a0fa204265bf32f1e6dc103988b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc2a0fa204265bf32f1e6dc103988b4">◆ </a></span>is_infinite() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::is_infinite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> </td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>true</code>, iff <code>c</code> is incident to the infinite vertex. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>t.dimension() == 3</code>. </dd></dl>

</div>
</div>
<a id="ad66e030d66fdf1ee66e4c280e8894c71" name="ad66e030d66fdf1ee66e4c280e8894c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad66e030d66fdf1ee66e4c280e8894c71">◆ </a></span>is_infinite() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::is_infinite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> </td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>i</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>true</code>, iff the facet <code>i</code> of cell <code>c</code> is incident to the infinite vertex. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>t.dimension()</code> \( \geq2\) and \( i\in\{0,1,2,3\}\) in dimension 3, \( i=3\) in dimension 2. </dd></dl>

</div>
</div>
<a id="ab84793de9c9899d8ecc33cdac411d324" name="ab84793de9c9899d8ecc33cdac411d324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab84793de9c9899d8ecc33cdac411d324">◆ </a></span>is_infinite() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::is_infinite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> </td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>j</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>true</code>, iff the edge <code>(i,j)</code> of cell <code>c</code> is incident to the infinite vertex. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>t.dimension()</code> \( \geq1\) and \( i\neq j\). Moreover \( i,j \in\{0,1,2,3\}\) in dimension 3, \( i,j \in\{0,1,2\}\) in dimension 2, \( i,j \in\{0,1\}\) in dimension 1. </dd></dl>

</div>
</div>
<a id="a6ca23f6bdd390ac23e7829e7f326efd5" name="a6ca23f6bdd390ac23e7829e7f326efd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ca23f6bdd390ac23e7829e7f326efd5">◆ </a></span>is_infinite() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::is_infinite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__3.html#a0f355dbb38cf631f24d4df8abd7a942f">Edge</a> &amp; </td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>true</code> iff edge <code>e</code> is incident to the infinite vertex. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>t.dimension()</code> \( \geq1\). </dd></dl>

</div>
</div>
<a id="a0ece46e036b7dabfd34fd4662973e221" name="a0ece46e036b7dabfd34fd4662973e221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ece46e036b7dabfd34fd4662973e221">◆ </a></span>is_infinite() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::is_infinite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__3.html#aa100228164b0cf78d5c2b1009c2df258">Facet</a> &amp; </td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>true</code> iff facet <code>f</code> is incident to the infinite vertex. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>t.dimension()</code> \( \geq2\). </dd></dl>

</div>
</div>
<a id="a76fa2f93b007c62d2c9d8deb09d8c5aa" name="a76fa2f93b007c62d2c9d8deb09d8c5aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76fa2f93b007c62d2c9d8deb09d8c5aa">◆ </a></span>is_valid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::is_valid </td>
          <td>(</td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>verbose</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a function for debugging purpose. </p>
 <div class="CGALDebug"> <div>Debugging Support</div> <p>Checks the combinatorial validity of the triangulation. Checks also the validity of its geometric embedding (see Section <a class="el" href="index.html#Triangulation3secintro">Representation</a>). When <code>verbose</code> is set to <code>true</code>, messages describing the first invalidity encountered are printed. </p> </div>  
</div>
</div>
<a id="a57226e0d36b9fb236a0d6711cda456d0" name="a57226e0d36b9fb236a0d6711cda456d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57226e0d36b9fb236a0d6711cda456d0">◆ </a></span>is_valid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::is_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> </td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>verbose</em> = <code>false</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a function for debugging purpose. </p>
 <div class="CGALDebug"> <div>Debugging Support</div> <p>Checks the combinatorial validity of the cell by calling the <code>is_valid</code> method of the cell class. Also checks the geometric validity of <code>c</code>, if <code>c</code> is finite. (See Section <a class="el" href="index.html#Triangulation3secintro">Representation</a>.)</p>
<p>When <code>verbose</code> is set to <code>true</code>, messages are printed to give a precise indication of the kind of invalidity encountered. </p> </div>  
</div>
</div>
<a id="a5b45572c663e5d2c10f26e7be421e140" name="a5b45572c663e5d2c10f26e7be421e140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b45572c663e5d2c10f26e7be421e140">◆ </a></span>is_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::is_vertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp; </td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> &amp; </td>
          <td class="paramname"><em>v</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether <code>p</code> is a vertex of <code>t</code> by locating <code>p</code> in the triangulation. </p>
<p>If <code>p</code> is found, the associated vertex <code>v</code> is given. </p>

</div>
</div>
<a id="a02a4a18074670282f3704f32b0901fad" name="a02a4a18074670282f3704f32b0901fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02a4a18074670282f3704f32b0901fad">◆ </a></span>locate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::locate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp; </td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> </td>
          <td class="paramname"><em>start</em> = <code><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool * </td>
          <td class="paramname"><em>could_lock_zone</em> = <code>nullptr</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the point <code>query</code> lies inside the convex hull of the points, the cell that contains the query in its interior is returned. </p>
<p>If <code>query</code> lies on a facet, an edge or on a vertex, one of the cells having <code>query</code> on its boundary is returned.</p>
<p>If the point <code>query</code> lies outside the convex hull of the points, an infinite cell with vertices \( \{ p, q, r, \infty\}\) is returned such that the tetrahedron \( ( p, q, r, query )\) is positively oriented (the rest of the triangulation lies on the other side of facet \( ( p, q, r )\)).</p>
<p>Note that locate works even in degenerate dimensions: in dimension 2 (resp. 1, 0) the <code>Cell_handle</code> returned is the one that represents the facet (resp. edge, vertex) containing the query point.</p>
<p>The optional argument <code>start</code> is used as a starting place for the search.</p>
<p>The optional argument <code>could_lock_zone</code> is used by the concurrency-safe version of the triangulation. When the pointer is not null, the locate will try to lock all the cells along the walk. If it succeeds, <code>*could_lock_zone</code> is <code>true</code>, otherwise it is false. In any case, the locked cells are not unlocked by <code>locate</code>, leaving this choice to the user. </p>

</div>
</div>
<a id="a384e93b6ff4614ed3b35bcf8981520c7" name="a384e93b6ff4614ed3b35bcf8981520c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a384e93b6ff4614ed3b35bcf8981520c7">◆ </a></span>locate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::locate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp; </td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#a5bea7d3470854571f97c18a675daca75">Locate_type</a> &amp; </td>
          <td class="paramname"><em>lt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp; </td>
          <td class="paramname"><em>li</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp; </td>
          <td class="paramname"><em>lj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> </td>
          <td class="paramname"><em>start</em> = <code><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool * </td>
          <td class="paramname"><em>could_lock_zone</em> = <code>nullptr</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <code>query</code> lies inside the affine hull of the points, the \( k\)-face (finite or infinite) that contains <code>query</code> in its interior is returned, by means of the cell returned together with <code>lt</code>, which is set to the locate type of the query (<code>VERTEX, EDGE, FACET, CELL</code>, or <code>OUTSIDE_CONVEX_HULL</code> if the cell is infinite and <code>query</code> lies strictly in it) and two indices <code>li</code> and <code>lj</code> that specify the \( k\)-face of the cell containing <code>query</code>. </p>
<p>If the \( k\)-face is a cell, <code>li</code> and <code>lj</code> have no meaning; if it is a facet (resp. vertex), <code>li</code> gives the index of the facet (resp. vertex) and <code>lj</code> has no meaning; if it is and edge, <code>li</code> and <code>lj</code> give the indices of its vertices.</p>
<p>If the point <code>query</code> lies outside the affine hull of the points, which can happen in case of degenerate dimensions, <code>lt</code> is set to <code>OUTSIDE_AFFINE_HULL</code>, and the cell returned has no meaning. As a particular case, if there is no finite vertex yet in the triangulation, <code>lt</code> is set to <code>OUTSIDE_AFFINE_HULL</code> and <em>locate</em> returns the default constructed handle.</p>
<p>The optional argument <code>start</code> is used as a starting place for the search.</p>
<p>The optional argument <code>could_lock_zone</code> is used by the concurrency-safe version of the triangulation. When the pointer is not null, the locate will try to lock all the cells along the walk. If it succeeds, <code>*could_lock_zone</code> is <code>true</code>, otherwise it is false. In any case, the locked cells are not unlocked by <code>locate</code>, leaving this choice to the user. </p>

</div>
</div>
<a id="a74cfefe0ac5dbe8e734461cda606a189" name="a74cfefe0ac5dbe8e734461cda606a189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74cfefe0ac5dbe8e734461cda606a189">◆ </a></span>mirror_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::mirror_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> </td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>i</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of <code>c</code> in its \( i^{th}\) neighbor. </p>
<dl class="section pre"><dt>Precondition</dt><dd>\( i \in\{0, 1, 2, 3\}\). </dd></dl>

</div>
</div>
<a id="a35ba5a05076bfeb5357ccdc182b12fee" name="a35ba5a05076bfeb5357ccdc182b12fee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35ba5a05076bfeb5357ccdc182b12fee">◆ </a></span>mirror_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::mirror_vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> </td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>i</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the vertex of the \( i^{th}\) neighbor of <code>c</code> that is opposite to <code>c</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>\( i \in\{0, 1, 2, 3\}\). </dd></dl>

</div>
</div>
<a id="a05f820202e1348187eb69693b6ce3d44" name="a05f820202e1348187eb69693b6ce3d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f820202e1348187eb69693b6ce3d44">◆ </a></span>number_of_edges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#ab33c8cdfd6a571cf9635a531d2d261a0">size_type</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::number_of_edges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of edges. </p>
<p>Returns 0 if <code>t.dimension() &lt; 1</code>. </p>

</div>
</div>
<a id="a014b6d2caf1747a3bf2865adb158cbb7" name="a014b6d2caf1747a3bf2865adb158cbb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a014b6d2caf1747a3bf2865adb158cbb7">◆ </a></span>number_of_facets()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#ab33c8cdfd6a571cf9635a531d2d261a0">size_type</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::number_of_facets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of facets. </p>
<p>Returns 0 if <code>t.dimension() &lt; 2</code>. </p>

</div>
</div>
<a id="a584b3359337efc7f687513b7ef958b94" name="a584b3359337efc7f687513b7ef958b94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a584b3359337efc7f687513b7ef958b94">◆ </a></span>number_of_finite_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#ab33c8cdfd6a571cf9635a531d2d261a0">size_type</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::number_of_finite_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of finite cells. </p>
<p>Returns 0 if <code>t.dimension() &lt; 3</code>. </p>

</div>
</div>
<a id="a37efcac10647c16b7ea331e30493cb24" name="a37efcac10647c16b7ea331e30493cb24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37efcac10647c16b7ea331e30493cb24">◆ </a></span>number_of_finite_edges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#ab33c8cdfd6a571cf9635a531d2d261a0">size_type</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::number_of_finite_edges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of finite edges. </p>
<p>Returns 0 if <code>t.dimension() &lt; 1</code>. </p>

</div>
</div>
<a id="af332a576da991acf508cbd4473249e0b" name="af332a576da991acf508cbd4473249e0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af332a576da991acf508cbd4473249e0b">◆ </a></span>number_of_finite_facets()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#ab33c8cdfd6a571cf9635a531d2d261a0">size_type</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::number_of_finite_facets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of finite facets. </p>
<p>Returns 0 if <code>t.dimension() &lt; 2</code>. </p>

</div>
</div>
<a id="abc8aafe82c32f53203d8d97069ef838d" name="abc8aafe82c32f53203d8d97069ef838d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc8aafe82c32f53203d8d97069ef838d">◆ </a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html">Triangulation_3</a> &amp; <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__3.html">Triangulation_3</a>&lt; Traits, TDS, SLDS &gt; &amp; </td>
          <td class="paramname"><em>tr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The triangulation <code>tr</code> is duplicated, and modifying the copy after the duplication does not modify the original. </p>
<p>The previous triangulation held by <code>t</code> is deleted. </p>

</div>
</div>
<a id="a20b6e473c9ba697893aed432ba3d9754" name="a20b6e473c9ba697893aed432ba3d9754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b6e473c9ba697893aed432ba3d9754">◆ </a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
<div class="memtemplate">
template&lt;class GT , class Tds1 , class Tds2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__3.html">Triangulation_3</a>&lt; GT, Tds1 &gt; &amp; </td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__3.html">Triangulation_3</a>&lt; GT, Tds2 &gt; &amp; </td>
          <td class="paramname"><em>t2</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equality operator. </p>
<p>Returns <code>true</code> iff there exist a bijection between the vertices of <code>t1</code> and those of <code>t2</code> and a bijection between the cells of <code>t1</code> and those of <code>t2</code>, which preserve the geometry of the triangulation, that is, the points of each corresponding pair of vertices are equal, and the tetrahedra corresponding to each pair of cells are equal (up to a permutation of their vertices). </p>

</div>
</div>
<a id="ad19deb77eb94761e9bf0934f39cb3fa5" name="ad19deb77eb94761e9bf0934f39cb3fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad19deb77eb94761e9bf0934f39cb3fa5">◆ </a></span>point() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp; <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::point </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> </td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>i</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the point given by vertex <code>i</code> of cell <code>c</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>t.dimension()</code> \( \geq0\) and \( i \in\{0,1,2,3\}\) in dimension 3, \( i \in\{0,1,2\}\) in dimension 2, \( i \in\{0,1\}\) in dimension 1, \( i = 0\) in dimension 0, and the vertex is finite. </dd></dl>

</div>
</div>
<a id="a914f44aa77c5096630f94af46f98cab5" name="a914f44aa77c5096630f94af46f98cab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a914f44aa77c5096630f94af46f98cab5">◆ </a></span>point() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp; <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::point </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as the previous method for vertex <code>v</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>t.dimension()</code> \( \geq0\) and the vertex is finite. </dd></dl>

</div>
</div>
<a id="ae28b76ae0e1f364fc55d1b67f5b57249" name="ae28b76ae0e1f364fc55d1b67f5b57249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae28b76ae0e1f364fc55d1b67f5b57249">◆ </a></span>segment() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#a2ee20454a8adb0ff5d6db5acabd10e05">Segment</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::segment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> </td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>j</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as the previous method for edge <code>(c,i,j)</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>As above and \( i\neq j\). Moreover \( i,j \in\{0,1,2,3\}\) in dimension 3, \( i,j \in\{0,1,2\}\) in dimension 2, \( i,j \in\{0,1\}\) in dimension 1, and the edge is finite. </dd></dl>

</div>
</div>
<a id="a22bb4874ea8dc28c07584f1f55628707" name="a22bb4874ea8dc28c07584f1f55628707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22bb4874ea8dc28c07584f1f55628707">◆ </a></span>segment() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#a2ee20454a8adb0ff5d6db5acabd10e05">Segment</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::segment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__3.html#a0f355dbb38cf631f24d4df8abd7a942f">Edge</a> &amp; </td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the line segment formed by the vertices of <code>e</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>t.dimension()</code> \( \geq1\) and <code>e</code> is finite. </dd></dl>

</div>
</div>
<a id="a535b21fc57d175507facde8091852d3c" name="a535b21fc57d175507facde8091852d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a535b21fc57d175507facde8091852d3c">◆ </a></span>segment_traverser_cells_begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#a39088e35d874ae7361d96a19acd572c7">Segment_cell_iterator</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::segment_traverser_cells_begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp; </td>
          <td class="paramname"><em>ps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp; </td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> </td>
          <td class="paramname"><em>hint</em> = <code><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a>()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the iterator that allows to visit the cells intersected by the line segment <code>[ps, pt]</code>. </p>
<p>If <code>[ps,pt]</code> entirely lies outside the convex hull, the iterator visits exactly one infinite cell.</p>
<p>The initial value of the iterator is the cell containing <code>ps</code>. If more than one cell contains <code>ps</code> (e.g. if <code>ps</code> lies on a vertex), the initial value is the cell intersected by the interior of the line segment <code>[ps,pt]</code>. If <code>ps</code> lies outside the convex hull and <code>pt</code> inside the convex full, the initial value is the infinite cell which finite facet is intersected by the interior of <code>[ps,pt]</code>.</p>
<p>The first cell containing <code>pt</code> is the last valid value of the iterator. It is followed by <code><a class="el" href="classCGAL_1_1Triangulation__3.html#adb5f31ae685c84289b0d39c2c1b3cf3b" title="returns the past-the-end iterator over the intersected cells.">segment_traverser_cells_end()</a></code>.</p>
<p>The optional argument <code>hint</code> can reduce the time to construct the iterator if it is geometrically close to <code>ps</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>ps</code> and <code>pt</code> must be different points. </dd>
<dd>
<code>triangulation.dimension() &gt;= 2</code>. If the dimension is 2, both <code>ps</code> and <code>pt</code> must lie in the affine hull. </dd></dl>

</div>
</div>
<a id="a7b020f2841ad9a6148e79ac0939b06ec" name="a7b020f2841ad9a6148e79ac0939b06ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b020f2841ad9a6148e79ac0939b06ec">◆ </a></span>segment_traverser_cells_begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#a39088e35d874ae7361d96a19acd572c7">Segment_cell_iterator</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::segment_traverser_cells_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td>
          <td class="paramname"><em>vs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td>
          <td class="paramname"><em>vt</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the iterator that allows to visit the cells intersected by the line segment <code>[vs,vt]</code>. </p>
<p>The initial value of the iterator is the cell containing <code>vs</code> and intersected by the line segment <code>[vs,vt]</code> in its interior.</p>
<p>The first cell incident to <code>vt</code> is the last valid value of the iterator. It is followed by <code><a class="el" href="classCGAL_1_1Triangulation__3.html#adb5f31ae685c84289b0d39c2c1b3cf3b" title="returns the past-the-end iterator over the intersected cells.">segment_traverser_cells_end()</a></code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>vs</code> and <code>vt</code> must be different vertices and neither can be the infinite vertex. </dd>
<dd>
<code>triangulation.dimension() &gt;= 2</code> </dd></dl>

</div>
</div>
<a id="adb5f31ae685c84289b0d39c2c1b3cf3b" name="adb5f31ae685c84289b0d39c2c1b3cf3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb5f31ae685c84289b0d39c2c1b3cf3b">◆ </a></span>segment_traverser_cells_end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#a39088e35d874ae7361d96a19acd572c7">Segment_cell_iterator</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::segment_traverser_cells_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the past-the-end iterator over the intersected cells. </p>
<p>This iterator cannot be dereferenced. It indicates when the <code>Segment_cell_iterator</code> has passed the target.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>triangulation.dimension() &gt;= 2</code> </dd></dl>

</div>
</div>
<a id="a12b4b5511ee276cc341b940971e4544e" name="a12b4b5511ee276cc341b940971e4544e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12b4b5511ee276cc341b940971e4544e">◆ </a></span>segment_traverser_simplices_begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#a822c7264ac03f629735cb85be4871e1f">Segment_simplex_iterator</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::segment_traverser_simplices_begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp; </td>
          <td class="paramname"><em>ps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp; </td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> </td>
          <td class="paramname"><em>hint</em> = <code><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a>()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the iterator that allows to visit the simplices intersected by the line segment <code>[ps,pt]</code>. </p>
<p>If <code>[ps,pt]</code> entirely lies outside the convex hull, the iterator visits exactly one infinite cell.</p>
<p>The initial value of the iterator is the lowest dimension simplex containing <code>ps</code>.</p>
<p>The iterator remains valid until the first simplex containing <code>pt</code> is passed.</p>
<p>The optional argument <code>hint</code> can reduce the time to construct the iterator if it is close to <code>ps</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>ps</code> and <code>pt</code> must be different points. </dd>
<dd>
<code>triangulation.dimension() &gt;= 2</code>. If the dimension is 2, both <code>ps</code> and <code>pt</code> must lie in the affine hull. </dd></dl>

</div>
</div>
<a id="a31e80cca5efe64571de4017067299449" name="a31e80cca5efe64571de4017067299449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31e80cca5efe64571de4017067299449">◆ </a></span>segment_traverser_simplices_begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#a822c7264ac03f629735cb85be4871e1f">Segment_simplex_iterator</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::segment_traverser_simplices_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td>
          <td class="paramname"><em>vs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td>
          <td class="paramname"><em>vt</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the iterator that allows to visit the simplices intersected by the line segment <code>[vs,vt]</code>. </p>
<p>The initial value of the iterator is <code>vs</code>. The iterator remains valid until <code>vt</code> is passed.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>vs</code> and <code>vt</code> must be different vertices and neither can be the infinite vertex. </dd>
<dd>
<code>triangulation.dimension() &gt;= 2</code> </dd></dl>

</div>
</div>
<a id="a2e5c7f41baa13b4086fe30ddb90f2c19" name="a2e5c7f41baa13b4086fe30ddb90f2c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e5c7f41baa13b4086fe30ddb90f2c19">◆ </a></span>segment_traverser_simplices_end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#a822c7264ac03f629735cb85be4871e1f">Segment_simplex_iterator</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::segment_traverser_simplices_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the past-the-end iterator over the intersected simplices. </p>
<p>This iterator cannot be dereferenced. It indicates when the <code>Segment_simplex_iterator</code> has passed the target.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>triangulation.dimension() &gt;= 2</code> </dd></dl>

</div>
</div>
<a id="af50326c40f34f13a01bb0fd0935301f0" name="af50326c40f34f13a01bb0fd0935301f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af50326c40f34f13a01bb0fd0935301f0">◆ </a></span>set_infinite_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::set_infinite_vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an advanced function. </p>
 <div class="CGALAdvanced"> <div>Advanced</div> <p>This method is meant to be used only if you have done a low-level operation on the underlying tds that invalidated the infinite vertex. Sets the infinite vertex. </p> </div>  
</div>
</div>
<a id="a0ad86d1f011118565cbef93ad35d673b" name="a0ad86d1f011118565cbef93ad35d673b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ad86d1f011118565cbef93ad35d673b">◆ </a></span>side_of_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="../Kernel_23/group__kernel__enums.html#gaf6030e89dadcc1f45369b0cdc5d9e111">Bounded_side</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::side_of_cell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp; </td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> </td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#a5bea7d3470854571f97c18a675daca75">Locate_type</a> &amp; </td>
          <td class="paramname"><em>lt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp; </td>
          <td class="paramname"><em>li</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp; </td>
          <td class="paramname"><em>lj</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a value indicating on which side of the oriented boundary of <code>c</code> the point <code>p</code> lies. </p>
<p>More precisely, it returns:</p>
<ul>
<li><code>ON_BOUNDED_SIDE</code> if <code>p</code> is inside the cell. For an infinite cell this means that <code>p</code> lies strictly in the half space limited by its finite facet and not containing any other point of the triangulation.</li>
<li><code>ON_BOUNDARY</code> if p on the boundary of the cell. For an infinite cell this means that <code>p</code> lies on the <em>finite</em> facet. Then <code>lt</code> together with <code>li</code> and <code>lj</code> give the precise location on the boundary. (See the descriptions of the <em>locate</em> methods.)</li>
<li><code>ON_UNBOUNDED_SIDE</code> if <code>p</code> lies outside the cell. For an infinite cell this means that <code>p</code> does not satisfy either of the two previous conditions. <dl class="section pre"><dt>Precondition</dt><dd><code>t.dimension() == 3</code> </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a3155746fefa1a1f87a834b4d575c904b" name="a3155746fefa1a1f87a834b4d575c904b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3155746fefa1a1f87a834b4d575c904b">◆ </a></span>side_of_edge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="../Kernel_23/group__kernel__enums.html#gaf6030e89dadcc1f45369b0cdc5d9e111">Bounded_side</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::side_of_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp; </td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__3.html#a0f355dbb38cf631f24d4df8abd7a942f">Edge</a> &amp; </td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#a5bea7d3470854571f97c18a675daca75">Locate_type</a> &amp; </td>
          <td class="paramname"><em>lt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp; </td>
          <td class="paramname"><em>li</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a value indicating on which side of the oriented boundary of <code>e</code> the point <code>p</code> lies: </p>
<ul>
<li><code>ON_BOUNDED_SIDE</code> if <code>p</code> is inside the edge. For an infinite edge this means that <code>p</code> lies in the half line defined by the vertex and not containing any other point of the triangulation.</li>
<li><code>ON_BOUNDARY</code> if <code>p</code> equals one of the vertices, <code>li</code> give the index of the vertex in the cell storing <code>e</code></li>
<li><code>ON_UNBOUNDED_SIDE</code> if <code>p</code> lies outside the edge. For an infinite edge this means that <code>p</code> lies on the other half line, which contains the other points of the triangulation. <dl class="section pre"><dt>Precondition</dt><dd><code>t.dimension() == 1</code> and <code>p</code> is collinear with the points of the triangulation. <code>e.second == 0</code> and <code>e.third</code> \( =1\) (in dimension 1 there is only one edge per cell). </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a6f26ad9ce68fbe3cb97ed211a68ab21f" name="a6f26ad9ce68fbe3cb97ed211a68ab21f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f26ad9ce68fbe3cb97ed211a68ab21f">◆ </a></span>side_of_facet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="../Kernel_23/group__kernel__enums.html#gaf6030e89dadcc1f45369b0cdc5d9e111">Bounded_side</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::side_of_facet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__3.html#a064de663ce02121ba3f0f4223547e064">Point</a> &amp; </td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__3.html#aa100228164b0cf78d5c2b1009c2df258">Facet</a> &amp; </td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#a5bea7d3470854571f97c18a675daca75">Locate_type</a> &amp; </td>
          <td class="paramname"><em>lt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp; </td>
          <td class="paramname"><em>li</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp; </td>
          <td class="paramname"><em>lj</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a value indicating on which side of the oriented boundary of <code>f</code> the point <code>p</code> lies: </p>
<ul>
<li><code>ON_BOUNDED_SIDE</code> if <code>p</code> is inside the facet. For an infinite facet this means that <code>p</code> lies strictly in the half plane limited by its finite edge and not containing any other point of the triangulation .</li>
<li><code>ON_BOUNDARY</code> if <code>p</code> is on the boundary of the facet. For an infinite facet this means that <code>p</code> lies on the finite edge. <code>lt</code>, <code>li</code> and <code>lj</code> give the precise location of <code>p</code> on the boundary of the facet. <code>li</code> and <code>lj</code> refer to indices in the degenerate cell <code>c</code> representing <code>f</code>.</li>
<li><code>ON_UNBOUNDED_SIDE</code> if <code>p</code> lies outside the facet. For an infinite facet this means that <code>p</code> does not satisfy either of the two previous conditions.</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd><code>t.dimension() == 2</code> and <code>p</code> lies in the plane containing the triangulation. <code>f.second</code> \( =3\) (in dimension 2 there is only one facet per cell). </dd></dl>

</div>
</div>
<a id="a767066a964b4d7b14376e5f5d1a04b34" name="a767066a964b4d7b14376e5f5d1a04b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a767066a964b4d7b14376e5f5d1a04b34">◆ </a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html">Triangulation_3</a>&lt; Traits, TDS, SLDS &gt; &amp; </td>
          <td class="paramname"><em>tr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The triangulations <code>tr</code> and <code>t</code> are swapped. </p>
<p><code>t.swap(tr)</code> should be preferred to <code>t = tr</code> or to <code>t(tr)</code> if <code>tr</code> is deleted after that. Indeed, there is no copy of cells and vertices, thus this method runs in constant time. </p>

</div>
</div>
<a id="a951781437d62955aaae730b87c833498" name="a951781437d62955aaae730b87c833498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a951781437d62955aaae730b87c833498">◆ </a></span>tds()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#a142364d710a44fb68daf6cbd185861ce">Triangulation_data_structure</a> &amp; <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::tds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the triangulation data structure. </p>
 <div class="CGALAdvanced"> <div>Advanced</div> <p>This method is mainly a help for users implementing their own triangulation algorithms. The responsibility of keeping a valid triangulation belongs to the user when using advanced operations allowing a direct manipulation of the <code>tds</code>. </p> </div>  
</div>
</div>
<a id="a83d347f8d914b78f17f6817fdb0b7a14" name="a83d347f8d914b78f17f6817fdb0b7a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83d347f8d914b78f17f6817fdb0b7a14">◆ </a></span>tetrahedron()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#aa88be907873b0469824cc3b2212f2eee">Tetrahedron</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::tetrahedron </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> </td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the tetrahedron formed by the four vertices of <code>c</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>t.dimension() == 3</code> and the cell is finite. </dd></dl>

</div>
</div>
<a id="ac2efcfbc0dcef89c512f65e4d13d4563" name="ac2efcfbc0dcef89c512f65e4d13d4563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2efcfbc0dcef89c512f65e4d13d4563">◆ </a></span>triangle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#adc409424d433ef56a79d5e71c02b8e15">Triangle</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::triangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> </td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>i</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the triangle formed by the three vertices of facet <code>(c,i)</code>. </p>
<p>The triangle is oriented so that its normal points to the inside of cell <code>c</code>. </p><dl class="section pre"><dt>Precondition</dt><dd><code>t.dimension()</code> \( \geq2\) and \( i \in\{0,1,2,3\}\) in dimension 3, \( i = 3\) in dimension 2, and the facet is finite. </dd></dl>

</div>
</div>
<a id="a6f9a07c130cde8a27869944396ab09e7" name="a6f9a07c130cde8a27869944396ab09e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f9a07c130cde8a27869944396ab09e7">◆ </a></span>triangle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Triangulation__3.html#adc409424d433ef56a79d5e71c02b8e15">Triangle</a> <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::triangle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Triangulation__3.html#aa100228164b0cf78d5c2b1009c2df258">Facet</a> &amp; </td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as the previous method for facet <code>f</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>t.dimension()</code> \( \geq2\) and the facet is finite. </dd></dl>

</div>
</div>
<a id="ace9dd63ba3a24d11d9b829198e514535" name="ace9dd63ba3a24d11d9b829198e514535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace9dd63ba3a24d11d9b829198e514535">◆ </a></span>try_lock_and_get_incident_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits , typename TDS , typename SLDS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Triangulation__3.html">CGAL::Triangulation_3</a>&lt; Traits, TDS, SLDS &gt;::try_lock_and_get_incident_cells </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19">Vertex_handle</a> </td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classCGAL_1_1Triangulation__3.html#ac076eb6ecdeeeb2b5bf678a21b3d23ee">Cell_handle</a> &gt; &amp; </td>
          <td class="paramname"><em>cells</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to lock and copy the <code>Cell_handle</code>s of all cells incident to <code>v</code> into <code>cells</code>. </p>
<p>Returns <code>true</code> in case of success. Otherwise, <code>cells</code> is emptied and the function returns false. In any case, the locked cells are not unlocked by <code><a class="el" href="classCGAL_1_1Triangulation__3.html#ace9dd63ba3a24d11d9b829198e514535" title="Try to lock and copy the Cell_handles of all cells incident to v into cells.">try_lock_and_get_incident_cells()</a></code>, leaving this choice to the user.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>t.dimension() == 3</code>, <code>v != <a class="el" href="classCGAL_1_1Triangulation__3.html#a1ba56e37b3a5acb1ba49a56d9d101a19" title="handle to a vertex">Vertex_handle()</a></code>, <code>t.is_vertex(v)</code>. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>CGAL</b></li><li class="navelem"><a class="el" href="classCGAL_1_1Triangulation__3.html">Triangulation_3</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"></a> 1.9.6 </li>
  </ul>
</div>
</div>
</body>




</html>
