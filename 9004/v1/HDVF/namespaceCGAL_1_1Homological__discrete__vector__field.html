<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/HDVF/namespaceCGAL_1_1Homological__discrete__vector__field.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=11">
<meta name="generator" content="Doxygen 1.9.6">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CGAL 6.2 - Homological Discrete Vector Fields: CGAL::Homological_discrete_vector_field Namespace Reference</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/doxygen.css" rel="stylesheet" type="text/css">
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      },
      equationNumbers: { autoNumber: "AMS" }
  }
}
);
MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
  var PARSE = MathJax.InputJax.TeX.Parse,
      TEXT = PARSE.prototype.InternalText;
  PARSE.Augment({
    InternalText: function (text,def) {
      text = text.replace(/\\/g,"");
      return TEXT.call(this,text,def);
    }
  });
});
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
      <span class="left">
         <span id="MSearchSelect" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"> 
        </span>
        <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
      </span>
      <span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.svg" alt=""></a>
      </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CGAL 6.2 - Homological Discrete Vector Fields
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search/",'.html');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespaceCGAL_1_1Homological__discrete__vector__field.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> |
<a href="#typedef-members">Typedefs</a> |
<a href="#enum-members">Enumerations</a> |
<a href="#func-members">Functions</a> |
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">CGAL::Homological_discrete_vector_field Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Abstract__simplicial__chain__complex.html">Abstract_simplicial_chain_complex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">The class <code><a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Abstract__simplicial__chain__complex.html" title="The class Abstract_simplicial_chain_complex represents (topological) chain complexes associated to ab...">Abstract_simplicial_chain_complex</a></code> represents (topological) chain complexes associated to abstract simplicial complexes.  <a href="classCGAL_1_1Homological__discrete__vector__field_1_1Abstract__simplicial__chain__complex.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structCGAL_1_1Homological__discrete__vector__field_1_1Cell__pair.html">Cell_pair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Structure to represent data for <a class="el" href="classHDVF.html" title="The concept HDVF describes the requirements for Homological Discrete Vector Fields (HDVF for short) ,...">HDVF</a> operations (pairs of cells).  <a href="structCGAL_1_1Homological__discrete__vector__field_1_1Cell__pair.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Cub__object__io.html">Cub_object_io</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">The class <code><a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Cub__object__io.html" title="The class Cub_object_io is an intermediate IO class, used to load binary volumes and produce cubical ...">Cub_object_io</a></code> is an intermediate <a class="el" href="namespaceCGAL_1_1IO.html">IO</a> class, used to load binary volumes and produce cubical complexes.  <a href="classCGAL_1_1Homological__discrete__vector__field_1_1Cub__object__io.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Cubical__chain__complex.html">Cubical_chain_complex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">The class <code><a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Cubical__chain__complex.html" title="The class Cubical_chain_complex represents (topological) chain complexes associated to cubical comple...">Cubical_chain_complex</a></code> represents (topological) chain complexes associated to cubical complexes.  <a href="classCGAL_1_1Homological__discrete__vector__field_1_1Cubical__chain__complex.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Duality__cubical__complex__tools.html">Duality_cubical_complex_tools</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">The class <code><a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Duality__cubical__complex__tools.html" title="The class Duality_cubical_complex_tools is dedicated to Alexander duality for 3D binary volumes.">Duality_cubical_complex_tools</a></code> is dedicated to Alexander duality for 3D binary volumes.  <a href="classCGAL_1_1Homological__discrete__vector__field_1_1Duality__cubical__complex__tools.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Duality__simplicial__complex__tools.html">Duality_simplicial_complex_tools</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">The class <code><a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Duality__simplicial__complex__tools.html" title="The class Duality_simplicial_complex_tools is dedicated to Alexander duality for 3D surface meshes.">Duality_simplicial_complex_tools</a></code> is dedicated to Alexander duality for 3D surface meshes.  <a href="classCGAL_1_1Homological__discrete__vector__field_1_1Duality__simplicial__complex__tools.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Filtration__core.html">Filtration_core</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">The class <code><a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Filtration__core.html" title="The class Filtration_core implements data structures and methods required by the Filtration concept.">Filtration_core</a></code> implements data structures and methods required by the <code><a class="el" href="classFiltration.html" title="The concept Filtration describes the requirements for persistent filtrations associated to persistent...">Filtration</a></code> concept.  <a href="classCGAL_1_1Homological__discrete__vector__field_1_1Filtration__core.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Filtration__lower__star.html">Filtration_lower_star</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">The class <code><a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Filtration__lower__star.html" title="The class Filtration_lower_star implements the lower star filtration on a given complex implementing ...">Filtration_lower_star</a></code> implements the lower star filtration on a given complex implementing the concept <code><a class="el" href="classAbstractChainComplex.html" title="The concept AbstractChainComplex describes the requirements for (topological) chain complexes associa...">AbstractChainComplex</a></code>.  <a href="classCGAL_1_1Homological__discrete__vector__field_1_1Filtration__lower__star.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Hdvf.html">Hdvf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">The class <code><a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Hdvf.html" title="The class Hdvf implements homology and cohomology computation via homological discrete vector fields ...">Hdvf</a></code> implements homology and cohomology computation via homological discrete vector fields (HDVF for short).  <a href="classCGAL_1_1Homological__discrete__vector__field_1_1Hdvf.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Hdvf__core.html">Hdvf_core</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">The class <code><a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Hdvf__core.html" title="The class Hdvf_core is the core implementation of homological discrete vector fields (HDVF for short)...">Hdvf_core</a></code> is the core implementation of homological discrete vector fields (<a class="el" href="classHDVF.html" title="The concept HDVF describes the requirements for Homological Discrete Vector Fields (HDVF for short) ,...">HDVF</a> for short).  <a href="classCGAL_1_1Homological__discrete__vector__field_1_1Hdvf__core.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Hdvf__duality.html">Hdvf_duality</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">The class <code><a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Hdvf__duality.html" title="The class Hdvf_duality is the implementation of homological discrete vector fields (HDVF for short) f...">Hdvf_duality</a></code> is the implementation of homological discrete vector fields (<a class="el" href="classHDVF.html" title="The concept HDVF describes the requirements for Homological Discrete Vector Fields (HDVF for short) ,...">HDVF</a> for short) for Alexander duality computation.  <a href="classCGAL_1_1Homological__discrete__vector__field_1_1Hdvf__duality.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Hdvf__persistence.html">Hdvf_persistence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">The class <code><a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Hdvf__persistence.html" title="The class Hdvf_persistence computes persistent homology using HDVFs (over a ring of coefficients whic...">Hdvf_persistence</a></code> computes persistent homology using HDVFs (over a ring of coefficients which should actually be a <b>field</b>).  <a href="classCGAL_1_1Homological__discrete__vector__field_1_1Hdvf__persistence.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structCGAL_1_1Homological__discrete__vector__field_1_1Hdvf__traits__2.html">Hdvf_traits_2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">The class <code><a class="el" href="structCGAL_1_1Homological__discrete__vector__field_1_1Hdvf__traits__2.html" title="The class Hdvf_traits_2 implements the HDVFTraits concept for 2D data, using a geometric kernel K.">Hdvf_traits_2</a></code> implements the <code><a class="el" href="classHDVFTraits.html" title="The concept HDVFTraits describes the requirements for geometric traits classes used in this package.">HDVFTraits</a></code> concept for 2D data, using a geometric kernel <code>K</code>.  <a href="structCGAL_1_1Homological__discrete__vector__field_1_1Hdvf__traits__2.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structCGAL_1_1Homological__discrete__vector__field_1_1Hdvf__traits__3.html">Hdvf_traits_3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">The class <code><a class="el" href="structCGAL_1_1Homological__discrete__vector__field_1_1Hdvf__traits__3.html" title="The class Hdvf_traits_3 implements the HDVFTraits concept for 3D data, using a geometric kernel K.">Hdvf_traits_3</a></code> implements the <code><a class="el" href="classHDVFTraits.html" title="The concept HDVFTraits describes the requirements for geometric traits classes used in this package.">HDVFTraits</a></code> concept for 3D data, using a geometric kernel <code>K</code>.  <a href="structCGAL_1_1Homological__discrete__vector__field_1_1Hdvf__traits__3.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structCGAL_1_1Homological__discrete__vector__field_1_1Hdvf__traits__d.html">Hdvf_traits_d</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">The class <code><a class="el" href="structCGAL_1_1Homological__discrete__vector__field_1_1Hdvf__traits__d.html" title="The class Hdvf_traits_d implements the HDVFTraits concept for dD data, using a geometric kernel K.">Hdvf_traits_d</a></code> implements the <code><a class="el" href="classHDVFTraits.html" title="The concept HDVFTraits describes the requirements for geometric traits classes used in this package.">HDVFTraits</a></code> concept for dD data, using a geometric kernel <code>K</code>.  <a href="structCGAL_1_1Homological__discrete__vector__field_1_1Hdvf__traits__d.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Icosphere__object__io.html">Icosphere_object_io</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Mesh__object__io.html">Mesh_object_io</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">The class <code><a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Mesh__object__io.html" title="The class Mesh_object_io is an intermediate IO class, used to load triangular/tetraedral meshes and p...">Mesh_object_io</a></code> is an intermediate <a class="el" href="namespaceCGAL_1_1IO.html">IO</a> class, used to load triangular/tetraedral meshes and produce simplicial complexes.  <a href="classCGAL_1_1Homological__discrete__vector__field_1_1Mesh__object__io.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Simplex.html">Simplex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">The class <code><a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Simplex.html" title="The class Simplex is used by the class Abstract_simplicial_chain_complex to implement the structure d...">Simplex</a></code> is used by the class <code><a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Abstract__simplicial__chain__complex.html" title="The class Abstract_simplicial_chain_complex represents (topological) chain complexes associated to ab...">Abstract_simplicial_chain_complex</a></code> to implement the structure de simplex (i.e. cells of a simplicial complex).  <a href="classCGAL_1_1Homological__discrete__vector__field_1_1Simplex.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Simplicial__chain__complex.html">Simplicial_chain_complex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">The class <code><a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Simplicial__chain__complex.html" title="The class Simplicial_chain_complex refines the Abstract_simplicial_chain_complex class by assigning c...">Simplicial_chain_complex</a></code> refines the <code><a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Abstract__simplicial__chain__complex.html" title="The class Abstract_simplicial_chain_complex represents (topological) chain complexes associated to ab...">Abstract_simplicial_chain_complex</a></code> class by assigning coordinates to vertices (i.e. 0-simplices).  <a href="classCGAL_1_1Homological__discrete__vector__field_1_1Simplicial__chain__complex.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Sub__chain__complex__mask.html">Sub_chain_complex_mask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">The class <code><a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Sub__chain__complex__mask.html" title="The class Sub_chain_complex_mask is a technical class implementing a sub chain complex.">Sub_chain_complex_mask</a></code> is a technical class implementing a sub chain complex.  <a href="classCGAL_1_1Homological__discrete__vector__field_1_1Sub__chain__complex__mask.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Surface__mesh__io.html">Surface_mesh_io</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">The class <code><a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Surface__mesh__io.html" title="The class Surface_mesh_io is an intermediate IO class, used to load a triangle mesh and produce simpl...">Surface_mesh_io</a></code> is an intermediate <a class="el" href="namespaceCGAL_1_1IO.html">IO</a> class, used to load a triangle mesh and produce simplicial complexes.  <a href="classCGAL_1_1Homological__discrete__vector__field_1_1Surface__mesh__io.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Tet__object__io.html">Tet_object_io</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Z2.html">Z2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">The class <code><a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Z2.html" title="The class Z2 implements the concept IntegralDomainWithoutDivision with the field .">Z2</a></code> implements the concept <code><a class="elRef" href="../Algebraic_foundations/classIntegralDomainWithoutDivision.html">IntegralDomainWithoutDivision</a></code> with the field \(\mathbb Z/2\mathbb Z\).  <a href="classCGAL_1_1Homological__discrete__vector__field_1_1Z2.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Zp.html">Zp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">The class <code><a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Zp.html" title="The class Zp implements the concept IntegralDomainWithoutDivision with the field .">Zp</a></code> implements the concept <code><a class="elRef" href="../Algebraic_foundations/classIntegralDomainWithoutDivision.html">IntegralDomainWithoutDivision</a></code> with the field \(\mathbb Z/p\mathbb Z\).  <a href="classCGAL_1_1Homological__discrete__vector__field_1_1Zp.html#details">More...</a><br></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aed96b4f784fcccaad0ddfadcd04892b5"><td class="memItemLeft" align="right" valign="top"><a id="aed96b4f784fcccaad0ddfadcd04892b5" name="aed96b4f784fcccaad0ddfadcd04892b5"></a>
typedef std::vector&lt; size_t &gt; </td><td class="memItemRight" valign="bottom"><b>IOCubCellType</b></td></tr>
<tr class="memdesc:aed96b4f784fcccaad0ddfadcd04892b5"><td class="mdescLeft"> </td><td class="mdescRight">Type of cells coordinates in <a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Cub__object__io.html" title="The class Cub_object_io is an intermediate IO class, used to load binary volumes and produce cubical ...">Cub_object_io</a> (Khalimsky or voxel coordinates) <br></td></tr>
<tr class="separator:aed96b4f784fcccaad0ddfadcd04892b5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8d828bf222e0370f33b961caa1ff188b"><td class="memItemLeft" align="right" valign="top"><a id="a8d828bf222e0370f33b961caa1ff188b" name="a8d828bf222e0370f33b961caa1ff188b"></a>
typedef std::vector&lt; <a class="el" href="namespaceCGAL_1_1Homological__discrete__vector__field.html#aed96b4f784fcccaad0ddfadcd04892b5">IOCubCellType</a> &gt; </td><td class="memItemRight" valign="bottom"><b>IOCubChainType</b></td></tr>
<tr class="memdesc:a8d828bf222e0370f33b961caa1ff188b"><td class="mdescLeft"> </td><td class="mdescRight">Type of pre-chains in <a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Cub__object__io.html" title="The class Cub_object_io is an intermediate IO class, used to load binary volumes and produce cubical ...">Cub_object_io</a> (list of cells without coefficients). <br></td></tr>
<tr class="separator:a8d828bf222e0370f33b961caa1ff188b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a535ba6105c9178d2de0c057002ea31b1"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; std::size_t, int &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCGAL_1_1Homological__discrete__vector__field.html#a535ba6105c9178d2de0c057002ea31b1">Cell</a></td></tr>
<tr class="memdesc:a535ba6105c9178d2de0c057002ea31b1"><td class="mdescLeft"> </td><td class="mdescRight">Type for indexing uniquely a cell.  <br></td></tr>
<tr class="separator:a535ba6105c9178d2de0c057002ea31b1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a257ac2e75821aad6478e91ea6e4d8577"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; size_t &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCGAL_1_1Homological__discrete__vector__field.html#a257ac2e75821aad6478e91ea6e4d8577">Io_cell_type</a></td></tr>
<tr class="memdesc:a257ac2e75821aad6478e91ea6e4d8577"><td class="mdescLeft"> </td><td class="mdescRight">Type of cells of <a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Mesh__object__io.html" title="The class Mesh_object_io is an intermediate IO class, used to load triangular/tetraedral meshes and p...">Mesh_object_io</a>.  <br></td></tr>
<tr class="separator:a257ac2e75821aad6478e91ea6e4d8577"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae8c8d46a023104b21982479f05228722"><td class="memItemLeft" align="right" valign="top"><a id="ae8c8d46a023104b21982479f05228722" name="ae8c8d46a023104b21982479f05228722"></a>
typedef std::vector&lt; <a class="el" href="namespaceCGAL_1_1Homological__discrete__vector__field.html#a257ac2e75821aad6478e91ea6e4d8577">Io_cell_type</a> &gt; </td><td class="memItemRight" valign="bottom"><b>Io_chain_type</b></td></tr>
<tr class="memdesc:ae8c8d46a023104b21982479f05228722"><td class="mdescLeft"> </td><td class="mdescRight">Type of pre-chains in <a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Mesh__object__io.html" title="The class Mesh_object_io is an intermediate IO class, used to load triangular/tetraedral meshes and p...">Mesh_object_io</a> (list of cells without coefficients). <br></td></tr>
<tr class="separator:ae8c8d46a023104b21982479f05228722"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aa38a2d87c6b086b5187018a0b91a5996"><td class="memItemLeft" align="right" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCGAL_1_1Homological__discrete__vector__field.html#aa38a2d87c6b086b5187018a0b91a5996">PSC_flag</a> { <a class="el" href="namespaceCGAL_1_1Homological__discrete__vector__field.html#aa38a2d87c6b086b5187018a0b91a5996ad82ed4c9294bf2715aa41a7d1f3703df">PRIMARY</a>
, <a class="el" href="namespaceCGAL_1_1Homological__discrete__vector__field.html#aa38a2d87c6b086b5187018a0b91a5996ac83f2a105b3758f88460cbb82f8aa64b">SECONDARY</a>
, <a class="el" href="namespaceCGAL_1_1Homological__discrete__vector__field.html#aa38a2d87c6b086b5187018a0b91a5996a9dcec8534bafb0cfac41e52b4c93c423">CRITICAL</a>
, <a class="el" href="namespaceCGAL_1_1Homological__discrete__vector__field.html#aa38a2d87c6b086b5187018a0b91a5996af236bef9ce0d6983cc98f9205537c475">NONE</a>
 }</td></tr>
<tr class="memdesc:aa38a2d87c6b086b5187018a0b91a5996"><td class="mdescLeft"> </td><td class="mdescRight"><a class="el" href="classHDVF.html" title="The concept HDVF describes the requirements for Homological Discrete Vector Fields (HDVF for short) ,...">HDVF</a> Enum for the label of cells.  <a href="namespaceCGAL_1_1Homological__discrete__vector__field.html#aa38a2d87c6b086b5187018a0b91a5996">More...</a><br></td></tr>
<tr class="separator:aa38a2d87c6b086b5187018a0b91a5996"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0aa614c35876ecc578a1d3be6f326788"><td class="memTemplParams" colspan="2"><a id="a0aa614c35876ecc578a1d3be6f326788" name="a0aa614c35876ecc578a1d3be6f326788"></a>
template&lt;typename CoefficientRing &gt; </td></tr>
<tr class="memitem:a0aa614c35876ecc578a1d3be6f326788"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp; </td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const <a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Abstract__simplicial__chain__complex.html">Abstract_simplicial_chain_complex</a>&lt; CoefficientRing &gt; &amp;complex)</td></tr>
<tr class="separator:a0aa614c35876ecc578a1d3be6f326788"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a47025684da695f73e2f3bf0c71dce319"><td class="memTemplParams" colspan="2"><a id="a47025684da695f73e2f3bf0c71dce319" name="a47025684da695f73e2f3bf0c71dce319"></a>
template&lt;typename CoefficientRing , typename Traits &gt; </td></tr>
<tr class="memitem:a47025684da695f73e2f3bf0c71dce319"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp; </td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const <a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Cubical__chain__complex.html">Cubical_chain_complex</a>&lt; CoefficientRing, Traits &gt; &amp;complex)</td></tr>
<tr class="separator:a47025684da695f73e2f3bf0c71dce319"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac36b2570cb4530fd29ef44aeffce62a3"><td class="memTemplParams" colspan="2"><a id="ac36b2570cb4530fd29ef44aeffce62a3" name="ac36b2570cb4530fd29ef44aeffce62a3"></a>
template&lt;typename ChainComplex , typename P &gt; </td></tr>
<tr class="memitem:ac36b2570cb4530fd29ef44aeffce62a3"><td class="memTemplItemLeft" align="right" valign="top">std::function&lt; double(size_t)&gt; </td><td class="memTemplItemRight" valign="bottom"><b>degree_function</b> (const ChainComplex &amp;complex, const std::function&lt; double(const P &amp;)&gt; &amp;f)</td></tr>
<tr class="memdesc:ac36b2570cb4530fd29ef44aeffce62a3"><td class="mdescLeft"> </td><td class="mdescRight">Degree function from a coordinates to scalar map. <br></td></tr>
<tr class="separator:ac36b2570cb4530fd29ef44aeffce62a3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afa8cf9ef68b4d83a987e3af3694a9df2"><td class="memItemLeft" align="right" valign="top"><a id="afa8cf9ef68b4d83a987e3af3694a9df2" name="afa8cf9ef68b4d83a987e3af3694a9df2"></a>
std::ostream &amp; </td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const std::vector&lt; <a class="el" href="structCGAL_1_1Homological__discrete__vector__field_1_1Cell__pair.html">Cell_pair</a> &gt; &amp;pairs)</td></tr>
<tr class="memdesc:afa8cf9ef68b4d83a987e3af3694a9df2"><td class="mdescLeft"> </td><td class="mdescRight">Overload of operator&lt;&lt; for <a class="el" href="structCGAL_1_1Homological__discrete__vector__field_1_1Cell__pair.html" title="Structure to represent data for HDVF operations (pairs of cells).">Cell_pair</a> type. <br></td></tr>
<tr class="separator:afa8cf9ef68b4d83a987e3af3694a9df2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab9d9ab38b5cf9b7ff341c1375f64c181"><td class="memTemplParams" colspan="2"><a id="ab9d9ab38b5cf9b7ff341c1375f64c181" name="ab9d9ab38b5cf9b7ff341c1375f64c181"></a>
template&lt;typename ChainComplex , typename Degree , typename Filtration_ &gt; </td></tr>
<tr class="memitem:ab9d9ab38b5cf9b7ff341c1375f64c181"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp; </td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out_stream, const typename <a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Hdvf__persistence.html">Hdvf_persistence</a>&lt; ChainComplex, Degree, Filtration_ &gt;::Persistent_interval &amp;hole)</td></tr>
<tr class="separator:ab9d9ab38b5cf9b7ff341c1375f64c181"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4a9f84b23a181823f8bee356378cea13"><td class="memItemLeft" align="right" valign="top"><a id="a4a9f84b23a181823f8bee356378cea13" name="a4a9f84b23a181823f8bee356378cea13"></a>
std::ostream &amp; </td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const <a class="el" href="structCGAL_1_1Homological__discrete__vector__field_1_1Cell__pair.html">Cell_pair</a> &amp;p)</td></tr>
<tr class="separator:a4a9f84b23a181823f8bee356378cea13"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a93590ed5c595b55a130cde5906f67213"><td class="memTemplParams" colspan="2">template&lt;typename ChainComplex &gt; </td></tr>
<tr class="memitem:a93590ed5c595b55a130cde5906f67213"><td class="memTemplItemLeft" align="right" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGAL_1_1Homological__discrete__vector__field.html#a93590ed5c595b55a130cde5906f67213">interaction_loop</a> (<a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Hdvf.html">Hdvf</a>&lt; ChainComplex &gt; &amp;hdvf, ChainComplex &amp;complex, const std::function&lt; void(<a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Hdvf.html">Hdvf</a>&lt; ChainComplex &gt; &amp;hdvf, ChainComplex &amp;complex)&gt; &amp;output_vtk)</td></tr>
<tr class="memdesc:a93590ed5c595b55a130cde5906f67213"><td class="mdescLeft"> </td><td class="mdescRight">Runs an interaction loop to iterated M, W or MW operations and export the results to vtk.  <br></td></tr>
<tr class="separator:a93590ed5c595b55a130cde5906f67213"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2b9d7a96013476ef5dd59de488f4ae5f"><td class="memItemLeft" align="right" valign="top"><a id="a2b9d7a96013476ef5dd59de488f4ae5f" name="a2b9d7a96013476ef5dd59de488f4ae5f"></a>
bool </td><td class="memItemRight" valign="bottom"><b>check_sanity_line</b> (const std::string &amp;line, const std::string &amp;file)</td></tr>
<tr class="separator:a2b9d7a96013476ef5dd59de488f4ae5f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2e8fad43792c5b28fc953b16b31b910c"><td class="memItemLeft" align="right" valign="top"><a id="a2e8fad43792c5b28fc953b16b31b910c" name="a2e8fad43792c5b28fc953b16b31b910c"></a>
bool </td><td class="memItemRight" valign="bottom"><b>get_next_uncommented_line</b> (std::ifstream &amp;infile, std::string &amp;result)</td></tr>
<tr class="separator:a2e8fad43792c5b28fc953b16b31b910c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac4d7af6def345198ec69c1535f60696f"><td class="memTemplParams" colspan="2">template&lt;typename Traits &gt; </td></tr>
<tr class="memitem:ac4d7af6def345198ec69c1535f60696f"><td class="memTemplItemLeft" align="right" valign="top">size_t </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGAL_1_1Homological__discrete__vector__field.html#ac4d7af6def345198ec69c1535f60696f">read_nodes</a> (const std::string &amp;filename, std::vector&lt; typename Traits::Point &gt; *nodes, bool adapt=false)</td></tr>
<tr class="memdesc:ac4d7af6def345198ec69c1535f60696f"><td class="mdescLeft"> </td><td class="mdescRight">Load nodes from a .nodes file.  <br></td></tr>
<tr class="separator:ac4d7af6def345198ec69c1535f60696f"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a852e10d642f8bd27614e39ab6639699d"><td class="memItemLeft" align="right" valign="top">std::function&lt; double(const std::vector&lt; double &gt; &amp;)&gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCGAL_1_1Homological__discrete__vector__field.html#a852e10d642f8bd27614e39ab6639699d">f_x</a></td></tr>
<tr class="memdesc:a852e10d642f8bd27614e39ab6639699d"><td class="mdescLeft"> </td><td class="mdescRight">For lower star filtration along x: function mapping coordinates to x.  <br></td></tr>
<tr class="separator:a852e10d642f8bd27614e39ab6639699d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5b201047136ecef00ed9244a21c4c39f"><td class="memItemLeft" align="right" valign="top">std::function&lt; double(const std::vector&lt; double &gt; &amp;)&gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCGAL_1_1Homological__discrete__vector__field.html#a5b201047136ecef00ed9244a21c4c39f">f_y</a></td></tr>
<tr class="memdesc:a5b201047136ecef00ed9244a21c4c39f"><td class="mdescLeft"> </td><td class="mdescRight">For lower star filtration along y: function mapping coordinates to y.  <br></td></tr>
<tr class="separator:a5b201047136ecef00ed9244a21c4c39f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a74e9038c38a9888309a37536c56453ed"><td class="memItemLeft" align="right" valign="top">std::function&lt; double(const std::vector&lt; double &gt; &amp;)&gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCGAL_1_1Homological__discrete__vector__field.html#a74e9038c38a9888309a37536c56453ed">f_z</a></td></tr>
<tr class="memdesc:a74e9038c38a9888309a37536c56453ed"><td class="mdescLeft"> </td><td class="mdescRight">For lower star filtration along z: function mapping coordinates to z.  <br></td></tr>
<tr class="separator:a74e9038c38a9888309a37536c56453ed"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af658fedcf3c88fc4470d4d0d1e3b43d5"><td class="memItemLeft" align="right" valign="top"><a id="af658fedcf3c88fc4470d4d0d1e3b43d5" name="af658fedcf3c88fc4470d4d0d1e3b43d5"></a>
const int </td><td class="memItemRight" valign="bottom"><b>OPT_BND</b> = 0b0001</td></tr>
<tr class="memdesc:af658fedcf3c88fc4470d4d0d1e3b43d5"><td class="mdescLeft"> </td><td class="mdescRight"><a class="el" href="classHDVF.html" title="The concept HDVF describes the requirements for Homological Discrete Vector Fields (HDVF for short) ,...">HDVF</a> option (compute only reduced boundary). <br></td></tr>
<tr class="separator:af658fedcf3c88fc4470d4d0d1e3b43d5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af50cc0a1cc64487f35ccaf912a5b2bb9"><td class="memItemLeft" align="right" valign="top"><a id="af50cc0a1cc64487f35ccaf912a5b2bb9" name="af50cc0a1cc64487f35ccaf912a5b2bb9"></a>
const int </td><td class="memItemRight" valign="bottom"><b>OPT_F</b> = 0b0010</td></tr>
<tr class="memdesc:af50cc0a1cc64487f35ccaf912a5b2bb9"><td class="mdescLeft"> </td><td class="mdescRight"><a class="el" href="classHDVF.html" title="The concept HDVF describes the requirements for Homological Discrete Vector Fields (HDVF for short) ,...">HDVF</a> option (compute only reduced boundary and f). <br></td></tr>
<tr class="separator:af50cc0a1cc64487f35ccaf912a5b2bb9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac66895f59ddf1c8eee5cb6ae75168b49"><td class="memItemLeft" align="right" valign="top"><a id="ac66895f59ddf1c8eee5cb6ae75168b49" name="ac66895f59ddf1c8eee5cb6ae75168b49"></a>
const int </td><td class="memItemRight" valign="bottom"><b>OPT_G</b> = 0b0100</td></tr>
<tr class="memdesc:ac66895f59ddf1c8eee5cb6ae75168b49"><td class="mdescLeft"> </td><td class="mdescRight"><a class="el" href="classHDVF.html" title="The concept HDVF describes the requirements for Homological Discrete Vector Fields (HDVF for short) ,...">HDVF</a> option (compute only reduced boundary and g). <br></td></tr>
<tr class="separator:ac66895f59ddf1c8eee5cb6ae75168b49"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1039cceaf10746a31c1820d34ee3e90d"><td class="memItemLeft" align="right" valign="top"><a id="a1039cceaf10746a31c1820d34ee3e90d" name="a1039cceaf10746a31c1820d34ee3e90d"></a>
const int </td><td class="memItemRight" valign="bottom"><b>OPT_FULL</b> = 0b1000</td></tr>
<tr class="memdesc:a1039cceaf10746a31c1820d34ee3e90d"><td class="mdescLeft"> </td><td class="mdescRight"><a class="el" href="classHDVF.html" title="The concept HDVF describes the requirements for Homological Discrete Vector Fields (HDVF for short) ,...">HDVF</a> option (compute full reduction). <br></td></tr>
<tr class="separator:a1039cceaf10746a31c1820d34ee3e90d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:acbdf5a08e928f85fa491da51b5b870ab"><td class="memItemLeft" align="right" valign="top"><a id="acbdf5a08e928f85fa491da51b5b870ab" name="acbdf5a08e928f85fa491da51b5b870ab"></a>
static std::vector&lt; size_t &gt; </td><td class="memItemRight" valign="bottom"><b>VTK_types_IO</b> = {1, 3, 5, 10}</td></tr>
<tr class="separator:acbdf5a08e928f85fa491da51b5b870ab"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a535ba6105c9178d2de0c057002ea31b1" name="a535ba6105c9178d2de0c057002ea31b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a535ba6105c9178d2de0c057002ea31b1">◆ </a></span>Cell</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;std::size_t, int&gt; <a class="el" href="namespaceCGAL_1_1Homological__discrete__vector__field.html#a535ba6105c9178d2de0c057002ea31b1">CGAL::Homological_discrete_vector_field::Cell</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for indexing uniquely a cell. </p>
<ul>
<li>First element of the pair: index of the cell.</li>
<li>Second element of the pair: dimension of the cell. </li>
</ul>

</div>
</div>
<a id="a257ac2e75821aad6478e91ea6e4d8577" name="a257ac2e75821aad6478e91ea6e4d8577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a257ac2e75821aad6478e91ea6e4d8577">◆ </a></span>Io_cell_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;size_t&gt; <a class="el" href="namespaceCGAL_1_1Homological__discrete__vector__field.html#a257ac2e75821aad6478e91ea6e4d8577">CGAL::Homological_discrete_vector_field::Io_cell_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of cells of <a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Mesh__object__io.html" title="The class Mesh_object_io is an intermediate IO class, used to load triangular/tetraedral meshes and p...">Mesh_object_io</a>. </p>
<p><em>Sorted</em> vector of the vertex indices. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aa38a2d87c6b086b5187018a0b91a5996" name="aa38a2d87c6b086b5187018a0b91a5996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa38a2d87c6b086b5187018a0b91a5996">◆ </a></span>PSC_flag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceCGAL_1_1Homological__discrete__vector__field.html#aa38a2d87c6b086b5187018a0b91a5996">CGAL::Homological_discrete_vector_field::PSC_flag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classHDVF.html" title="The concept HDVF describes the requirements for Homological Discrete Vector Fields (HDVF for short) ,...">HDVF</a> Enum for the label of cells. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa38a2d87c6b086b5187018a0b91a5996ad82ed4c9294bf2715aa41a7d1f3703df" name="aa38a2d87c6b086b5187018a0b91a5996ad82ed4c9294bf2715aa41a7d1f3703df"></a>PRIMARY </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa38a2d87c6b086b5187018a0b91a5996ac83f2a105b3758f88460cbb82f8aa64b" name="aa38a2d87c6b086b5187018a0b91a5996ac83f2a105b3758f88460cbb82f8aa64b"></a>SECONDARY </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa38a2d87c6b086b5187018a0b91a5996a9dcec8534bafb0cfac41e52b4c93c423" name="aa38a2d87c6b086b5187018a0b91a5996a9dcec8534bafb0cfac41e52b4c93c423"></a>CRITICAL </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa38a2d87c6b086b5187018a0b91a5996af236bef9ce0d6983cc98f9205537c475" name="aa38a2d87c6b086b5187018a0b91a5996af236bef9ce0d6983cc98f9205537c475"></a>NONE </td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a93590ed5c595b55a130cde5906f67213" name="a93590ed5c595b55a130cde5906f67213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93590ed5c595b55a130cde5906f67213">◆ </a></span>interaction_loop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChainComplex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CGAL::Homological_discrete_vector_field::interaction_loop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Hdvf.html">Hdvf</a>&lt; ChainComplex &gt; &amp; </td>
          <td class="paramname"><em>hdvf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ChainComplex &amp; </td>
          <td class="paramname"><em>complex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(<a class="el" href="classCGAL_1_1Homological__discrete__vector__field_1_1Hdvf.html">Hdvf</a>&lt; ChainComplex &gt; &amp;hdvf, ChainComplex &amp;complex)&gt; &amp; </td>
          <td class="paramname"><em>output_vtk</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs an interaction loop to iterated M, W or MW operations and export the results to vtk. </p>
<p>The loop runs until the key <code>Q</code> is pressed. Otherwise, the loop asks for an operation (M, W or MW) and a cell (index and dimension). Then all possible paired cells are listed and the user can chose one of them (or none). </p>

</div>
</div>
<a id="ac4d7af6def345198ec69c1535f60696f" name="ac4d7af6def345198ec69c1535f60696f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4d7af6def345198ec69c1535f60696f">◆ </a></span>read_nodes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t CGAL::Homological_discrete_vector_field::read_nodes </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp; </td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename Traits::Point &gt; * </td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>adapt</em> = <code>false</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load nodes from a .nodes file. </p>
<p>Load vertices coordinates from a .nodes file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Name of the input file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nodes</td><td>Pointer to a vector of points into which nodes are outputed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">adapt</td><td>If <code>fill</code> is false, nodes must have the same dimension as the traits Point, if true, nodes dimension can be lower (and missing coordinates are filled with zeros) or higher (and coordinates are truncated to the traits dimension). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a852e10d642f8bd27614e39ab6639699d" name="a852e10d642f8bd27614e39ab6639699d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a852e10d642f8bd27614e39ab6639699d">◆ </a></span>f_x</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;double(const std::vector&lt;double&gt;&amp;)&gt; CGAL::Homological_discrete_vector_field::f_x</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">const</span> std::vector&lt;double&gt;&amp; v)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> (v.at(0)) ;</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>For lower star filtration along x: function mapping coordinates to x. </p>

</div>
</div>
<a id="a5b201047136ecef00ed9244a21c4c39f" name="a5b201047136ecef00ed9244a21c4c39f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b201047136ecef00ed9244a21c4c39f">◆ </a></span>f_y</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;double(const std::vector&lt;double&gt;&amp;)&gt; CGAL::Homological_discrete_vector_field::f_y</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">const</span> std::vector&lt;double&gt;&amp; v)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> (v.at(1)) ;</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>For lower star filtration along y: function mapping coordinates to y. </p>

</div>
</div>
<a id="a74e9038c38a9888309a37536c56453ed" name="a74e9038c38a9888309a37536c56453ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74e9038c38a9888309a37536c56453ed">◆ </a></span>f_z</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;double(const std::vector&lt;double&gt;&amp;)&gt; CGAL::Homological_discrete_vector_field::f_z</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">const</span> std::vector&lt;double&gt;&amp; v)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> (v.at(2)) ;</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>For lower star filtration along z: function mapping coordinates to z. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>CGAL</b></li><li class="navelem"><a class="el" href="namespaceCGAL_1_1Homological__discrete__vector__field.html">Homological_discrete_vector_field</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"></a> 1.9.6 </li>
  </ul>
</div>
</div>
</body>


</html>
