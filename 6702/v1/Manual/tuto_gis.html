<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Manual/tuto_gis.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 5.6 - Manual: GIS (Geographic Information System)</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//&amp;lt;![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      }
  }
}
);
//]]&amp;gt;
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
          <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
          <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt="" /></a>
          </span>
        </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.6 - Manual
   </div>
  </td>
  <!-- We disable the search box because we have added it in the
  back-nav for stylistic reasons. -->
  <!-- <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td> -->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tuto_gis.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">GIS (Geographic Information System) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> </p><div id="autotoc" class="toc"></div> 
<dl class="section author"><dt>Author</dt><dd>Simon Giraudot</dd></dl>
<p>Many sensors used in GIS applications (for example LIDAR), generate dense point clouds. Such applications often take advantage of more advanced data structures: for example, Triangulated Irregular Networks (TIN) that can be the base for Digital Evelation Models (DEM) and in particular for the generation of Digital Terrain Models (DTM). Point clouds can also be enriched by classification information that segments the points into ground, vegetation and building points (or other user-defined labels).</p>
<p>The definitions of some data structures may vary according to different sources. We will use the following terms within this tutorial:</p>
<ul>
<li>TIN: <em>Triangulated Irregular Network</em>, a 2D triangulation structure that connects 3D points based on their projections on the horizontal plane.</li>
<li>DSM: <em>Digital Surface Model</em>, a model of the whole scanned surface including buildings and vegetation. We use a TIN to store the DSM.</li>
<li>DTM: <em>Digital Terrain Model</em>, a model of the bare ground surface without objects like buildings or vegetation. We both use a TIN and a raster to store a DTM.</li>
<li>DEM: <em>Digital Elevation Model</em>, a more general term that includes both DSM and DTM.</li>
</ul>
<p>This tutorial illustrates the following scenario. From an input point cloud, we first compute a DSM stored as a TIN. Then, we filter out overly large facets that correspond either to building facades or to vegetation noise. Large components corresponding to the ground are kept. Holes are filled and the obtained DEM is remeshed. A raster DEM and a set of contour polylines are generated from it. Finally, supervised 3-label classification is performed to segment vegetation, building and group points.</p>
<h1><a class="anchor" id="TutorialGIS_TIN"></a>
Triangulated Irregular Network (TIN)</h1>
<p>CGAL provides several triangulation data structures and algorithms. A TIN can be generated by combining the 2D Delaunay triangulation with projection traits: the triangulation structure is computed using the 2D positions of the points along a selected plane (usually, the XY-plane), while the 3D positions of the points are kept for visualization and measurements.</p>
<p>A TIN data structure can thus simply be defined the following way:</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keyword">using</span> Kernel = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div><div class="line"><span class="keyword">using</span> Projection_traits = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Projection__traits__xy__3.html">CGAL::Projection_traits_xy_3&lt;Kernel&gt;</a>;</div><div class="line"><span class="keyword">using</span> Point_2 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>;</div><div class="line"><span class="keyword">using</span> Point_3 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ae82b7f4be77dd5b8819ebe419e4ae753">Kernel::Point_3</a>;</div><div class="line"><span class="keyword">using</span> Segment_3 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#aa43a461b2027ef7d99b776a7b03ef230">Kernel::Segment_3</a>;</div><div class="line"></div><div class="line"><span class="comment">// Triangulated Irregular Network</span></div><div class="line"><span class="keyword">using</span> TIN = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2&lt;Projection_traits&gt;</a>;</div><div class="line"></div></div><!-- fragment --> <h1><a class="anchor" id="TutorialGIS_DSM"></a>
Digital Surface Model (DSM)</h1>
<p>Point clouds in many formats (XYZ, OFF, PLY, LAS) can be easily loaded into a <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3</a></code> structure, using the stream operator. Generating a DSM stored in TIN is then straightforward:</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="comment">// Read points</span></div><div class="line">  std::ifstream ifile (fname, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3&lt;Point_3&gt;</a> points;</div><div class="line">  ifile &gt;&gt; points;</div><div class="line">  std::cerr &lt;&lt; points.size() &lt;&lt; <span class="stringliteral">" point(s) read"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Create DSM</span></div><div class="line">  TIN dsm (points.points().begin(), points.points().end());</div><div class="line"></div></div><!-- fragment --><p> Because the Delaunay triangulation of CGAL is a model of <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/classFaceGraph.html">FaceGraph</a></code>, it is straightforward to convert the generated TIN into a mesh structure such as <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh</a></code> and be saved into whatever formats are supported by such structure:</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="keyword">using</span> Mesh = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point_3&gt;</a>;</div><div class="line"></div><div class="line">  Mesh dsm_mesh;</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#ga2682fb7d5f4ff4eb65607ae4118e31bc">CGAL::copy_face_graph</a> (dsm, dsm_mesh);</div><div class="line">  std::ofstream dsm_ofile (<span class="stringliteral">"dsm.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (dsm_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (dsm_ofile, dsm_mesh);</div><div class="line">  dsm_ofile.close();</div><div class="line"></div></div><!-- fragment --><p> An example of a DSM computed this way on the San Fransisco data set (see <a class="el" href="tuto_gis.html#TutorialGIS_Reference">References</a>) is given in <a class="el" href="tuto_gis.html#fig__TutorialGISFigTIN">Figure 0.1</a>.</p>
<p><a class="anchor" id="fig__TutorialGISFigTIN"></a></p><div class="image">
<img src="tin.jpg" alt="tin.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_gis.html#fig__TutorialGISFigTIN">Figure 0.1</a> Input point cloud and output DSM.  </div> <br /> 
<h1><a class="anchor" id="TutorialGIS_DTM"></a>
Digital Terrain Model (DTM)</h1>
<p>The generated DSM is used as a base for DTM computation, that is a representation of the ground as another TIN after filtering non-ground points.</p>
<p>We propose, as an example, a simple DTM estimation decomposed in the following steps:</p>
<ol type="1">
<li>Thresholding the height of the facets to remove brutal changes of elevation</li>
<li>Clustering the other facets into connected components</li>
<li>Filtering all components smaller than a user-defined threshold</li>
</ol>
<p>This algorithm relies on 2 parameters: a height threshold that corresponds to the minimum height of a building, and a perimeter threshold that corresponds to the maximum size of a building on the 2D projection.</p>
<h2><a class="anchor" id="TutorialGIS_DTM_info"></a>
TIN With Info</h2>
<p>Because it takes advantage of the flexible CGAL Delaunay triangulation API, our TIN can be enriched with information on vertices and/or on faces. In our case, each vertex keeps track of the index of the corresponding point in the input point cloud (which will allow to filter ground points afterwards), and each face is given the index of its connected component.</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="keyword">auto</span> idx_to_point_with_info</div><div class="line">    = [&amp;](<span class="keyword">const</span> Point_set::Index&amp; idx) -&gt; std::pair&lt;Point_3, Point_set::Index&gt;</div><div class="line">      {</div><div class="line">        <span class="keywordflow">return</span> std::make_pair (points.point(idx), idx);</div><div class="line">      };</div><div class="line"></div><div class="line">  TIN_with_info tin_with_info</div><div class="line">    (boost::make_transform_iterator (points.begin(), idx_to_point_with_info),</div><div class="line">     boost::make_transform_iterator (points.end(), idx_to_point_with_info));</div><div class="line"></div></div><!-- fragment --> <h2><a class="anchor" id="TutorialGIS_DTM_components"></a>
Identifying Connected Components</h2>
<p>Connected components are identified through a flooding algorithm: from a seed face, all incident faces are inserted in the current connected component unless their heights exceed the user-defined threshold.</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="keywordtype">double</span> spacing = CGAL::compute_average_spacing&lt;Concurrency_tag&gt;(points, 6);</div><div class="line">  spacing *= 2;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> face_height</div><div class="line">    = [&amp;](<span class="keyword">const</span> TIN_with_info::Face_handle fh) -&gt; <span class="keywordtype">double</span></div><div class="line">      {</div><div class="line">        <span class="keywordtype">double</span> out = 0.;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++ i)</div><div class="line">          out = (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/group__nt__util.html#gad7dbfa919e255b52f36ea1512a92cb78">std::max</a>) (out, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">CGAL::abs</a>(fh-&gt;vertex(i)-&gt;point().z() - fh-&gt;vertex((i+1)%3)-&gt;point().z()));</div><div class="line">        <span class="keywordflow">return</span> out;</div><div class="line">      };</div><div class="line"></div><div class="line">  <span class="comment">// Initialize faces info</span></div><div class="line">  <span class="keywordflow">for</span> (TIN_with_info::Face_handle fh : tin_with_info.all_face_handles())</div><div class="line">    <span class="keywordflow">if</span> (tin_with_info.is_infinite(fh) || face_height(fh) &gt; spacing) <span class="comment">// Filtered faces are given info() = -2</span></div><div class="line">      fh-&gt;info() = -2;</div><div class="line">    <span class="keywordflow">else</span> <span class="comment">// Pending faces are given info() = -1;</span></div><div class="line">      fh-&gt;info() = -1;</div><div class="line"></div><div class="line">  <span class="comment">// Flooding algorithm</span></div><div class="line">  std::vector&lt;int&gt; component_size;</div><div class="line">  <span class="keywordflow">for</span> (TIN_with_info::Face_handle fh : tin_with_info.finite_face_handles())</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (fh-&gt;info() != -1)</div><div class="line">      <span class="keywordflow">continue</span>;</div><div class="line"></div><div class="line">    std::queue&lt;TIN_with_info::Face_handle&gt; todo;</div><div class="line">    todo.push(fh);</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> size = 0;</div><div class="line">    <span class="keywordflow">while</span> (!todo.empty())</div><div class="line">    {</div><div class="line">      TIN_with_info::Face_handle current = todo.front();</div><div class="line">      todo.pop();</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (current-&gt;info() != -1)</div><div class="line">        <span class="keywordflow">continue</span>;</div><div class="line">      current-&gt;info() = int(component_size.size());</div><div class="line">      ++ size;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++ i)</div><div class="line">        todo.push (current-&gt;neighbor(i));</div><div class="line">    }</div><div class="line"></div><div class="line">    component_size.push_back (size);</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; component_size.size() &lt;&lt; <span class="stringliteral">" connected component(s) found"</span> &lt;&lt; std::endl;</div><div class="line"></div></div><!-- fragment --><p> This TIN enriched with connected component information can be saved as a colored mesh:</p>
<div class="fragment"><div class="line"></div><div class="line">  Mesh tin_colored_mesh;</div><div class="line"></div><div class="line">  Mesh::Property_map&lt;Mesh::Face_index, CGAL::IO::Color&gt;</div><div class="line">    color_map = tin_colored_mesh.add_property_map&lt;Mesh::Face_index, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a>&gt;(<span class="stringliteral">"f:color"</span>).first;</div><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#ga2682fb7d5f4ff4eb65607ae4118e31bc">CGAL::copy_face_graph</a> (tin_with_info, tin_colored_mesh,</div><div class="line">                         CGAL::parameters::face_to_face_output_iterator</div><div class="line">                         (boost::make_function_output_iterator</div><div class="line">                          ([&amp;](<span class="keyword">const</span> std::pair&lt;TIN_with_info::Face_handle, Mesh::Face_index&gt;&amp; ff)</div><div class="line">                           {</div><div class="line">                             <span class="comment">// Color unassigned faces gray</span></div><div class="line">                             <span class="keywordflow">if</span> (ff.first-&gt;info() &lt; 0)</div><div class="line">                               color_map[ff.second] = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a>(128, 128, 128);</div><div class="line">                             <span class="keywordflow">else</span></div><div class="line">                             {</div><div class="line">                               <span class="comment">// Random color seeded by the component ID</span></div><div class="line">                               <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Generator.tag:../Generator/" href="../Generator/classCGAL_1_1Random.html">CGAL::Random</a> r (ff.first-&gt;info());</div><div class="line">                               color_map[ff.second] = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a> (r.get_int(64, 192),</div><div class="line">                                                                   r.get_int(64, 192),</div><div class="line">                                                                   r.get_int(64, 192));</div><div class="line">                             }</div><div class="line">                           })));</div><div class="line"></div><div class="line">  std::ofstream tin_colored_ofile (<span class="stringliteral">"colored_tin.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (tin_colored_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (tin_colored_ofile, tin_colored_mesh);</div><div class="line">  tin_colored_ofile.close();</div><div class="line"></div></div><!-- fragment --><p> An example of a TIN colored by connected components is given in <a class="el" href="tuto_gis.html#fig__TutorialGISFigComponents">Figure 0.2</a>.</p>
<p><a class="anchor" id="fig__TutorialGISFigComponents"></a></p><div class="image">
<img src="components.jpg" alt="components.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_gis.html#fig__TutorialGISFigComponents">Figure 0.2</a> TIN colored by connected components. Faces above height threshold are not assigned to any component and are displayed in gray.  </div> <br /> 
<h2><a class="anchor" id="TutorialGIS_DTM_filtering"></a>
Filtering</h2>
<p>Components smaller than the largest building can be removed this way:</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="keywordtype">int</span> min_size = int(points.size() / 2);</div><div class="line"></div><div class="line">  std::vector&lt;TIN_with_info::Vertex_handle&gt; to_remove;</div><div class="line">  <span class="keywordflow">for</span> (TIN_with_info::Vertex_handle vh : tin_with_info.finite_vertex_handles())</div><div class="line">  {</div><div class="line">    TIN_with_info::Face_circulator circ = tin_with_info.incident_faces (vh),</div><div class="line">      start = circ;</div><div class="line"></div><div class="line">    <span class="comment">// Remove a vertex if it's only adjacent to components smaller than threshold</span></div><div class="line">    <span class="keywordtype">bool</span> keep = <span class="keyword">false</span>;</div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (circ-&gt;info() &gt;= 0 &amp;&amp; component_size[std::size_t(circ-&gt;info())] &gt; min_size)</div><div class="line">      {</div><div class="line">        keep = <span class="keyword">true</span>;</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">while</span> (++ circ != start);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (!keep)</div><div class="line">      to_remove.push_back (vh);</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; to_remove.size() &lt;&lt; <span class="stringliteral">" vertices(s) will be removed after filtering"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (TIN_with_info::Vertex_handle vh : to_remove)</div><div class="line">    tin_with_info.remove (vh);</div><div class="line"></div></div><!-- fragment --> <h2><a class="anchor" id="Tutorial_DTM_hole_filling"></a>
Hole Filling and Remeshing</h2>
<p>Because simply removing vertices in the large areas covered by buildings results in large Delaunay faces that offer a poor 3D representation of the DTM, an additional step can help producing better shaped meshes: faces larger than a threshold are removed and filled with a hole filling algorithm that triangulates, refines and fairs the holes.</p>
<p>The following snippet copies the TIN into a mesh while filtering out overly large faces, then identifies the holes and fills them all except for the largest one (which is the outer hull).</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="comment">// Copy and keep track of overly large faces</span></div><div class="line">  Mesh dtm_mesh;</div><div class="line"></div><div class="line">  std::vector&lt;Mesh::Face_index&gt; face_selection;</div><div class="line">  Mesh::Property_map&lt;Mesh::Face_index, bool&gt; face_selection_map</div><div class="line">   = dtm_mesh.add_property_map&lt;Mesh::Face_index, <span class="keywordtype">bool</span>&gt;(<span class="stringliteral">"is_selected"</span>, <span class="keyword">false</span>).first;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> limit = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga07001b5ddc5c43096c811c91a306be9a">CGAL::square</a> (5 * spacing);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#ga2682fb7d5f4ff4eb65607ae4118e31bc">CGAL::copy_face_graph</a> (tin_with_info, dtm_mesh,</div><div class="line">                         CGAL::parameters::face_to_face_output_iterator</div><div class="line">                         (boost::make_function_output_iterator</div><div class="line">                          ([&amp;](<span class="keyword">const</span> std::pair&lt;TIN_with_info::Face_handle, Mesh::Face_index&gt;&amp; ff)</div><div class="line">                           {</div><div class="line">                             <span class="keywordtype">double</span> longest_edge = 0.;</div><div class="line">                             <span class="keywordtype">bool</span> border = <span class="keyword">false</span>;</div><div class="line">                             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++ i)</div><div class="line">                             {</div><div class="line">                               longest_edge = (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/group__nt__util.html#gad7dbfa919e255b52f36ea1512a92cb78">std::max</a>)(longest_edge, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">CGAL::squared_distance</a></div><div class="line">                                                         (ff.first-&gt;vertex((i+1)%3)-&gt;point(),</div><div class="line">                                                          ff.first-&gt;vertex((i+2)%3)-&gt;point()));</div><div class="line"></div><div class="line">                               TIN_with_info::Face_circulator circ</div><div class="line">                                 = tin_with_info.incident_faces (ff.first-&gt;vertex(i)),</div><div class="line">                                 start = circ;</div><div class="line">                               <span class="keywordflow">do</span></div><div class="line">                               {</div><div class="line">                                 <span class="keywordflow">if</span> (tin_with_info.is_infinite (circ))</div><div class="line">                                 {</div><div class="line">                                   border = <span class="keyword">true</span>;</div><div class="line">                                   <span class="keywordflow">break</span>;</div><div class="line">                                 }</div><div class="line">                               }</div><div class="line">                               <span class="keywordflow">while</span> (++ circ != start);</div><div class="line"></div><div class="line">                               <span class="keywordflow">if</span> (border)</div><div class="line">                                 <span class="keywordflow">break</span>;</div><div class="line">                             }</div><div class="line"></div><div class="line">                             <span class="comment">// Select if face is too big AND it's not</span></div><div class="line">                             <span class="comment">// on the border (to have closed holes)</span></div><div class="line">                             <span class="keywordflow">if</span> (!border &amp;&amp; longest_edge &gt; limit)</div><div class="line">                             {</div><div class="line">                               face_selection_map[ff.second] = <span class="keyword">true</span>;</div><div class="line">                               face_selection.push_back (ff.second);</div><div class="line">                             }</div><div class="line">                           })));</div><div class="line"></div><div class="line">  <span class="comment">// Save original DTM</span></div><div class="line">  std::ofstream dtm_ofile (<span class="stringliteral">"dtm.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (dtm_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (dtm_ofile, dtm_mesh);</div><div class="line">  dtm_ofile.close();</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; face_selection.size() &lt;&lt; <span class="stringliteral">" face(s) are selected for removal"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Expand face selection to keep a well formed 2-manifold mesh after removal</span></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLSelectionFct.html#ga6f8d338df28c24bbf93677f24f7bcbbe">CGAL::expand_face_selection_for_removal</a> (face_selection, dtm_mesh, face_selection_map);</div><div class="line">  face_selection.clear();</div><div class="line">  <span class="keywordflow">for</span> (Mesh::Face_index fi : faces(dtm_mesh))</div><div class="line">    <span class="keywordflow">if</span> (face_selection_map[fi])</div><div class="line">      face_selection.push_back(fi);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; face_selection.size() &lt;&lt; <span class="stringliteral">" face(s) are selected for removal after expansion"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (Mesh::Face_index fi : face_selection)</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLEulerOperations.html#gacfae7ff8e782da55b941e4487e86c738">CGAL::Euler::remove_face</a> (halfedge(fi, dtm_mesh), dtm_mesh);</div><div class="line">  dtm_mesh.collect_garbage();</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (!dtm_mesh.is_valid())</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid mesh!"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save filtered DTM</span></div><div class="line">  std::ofstream dtm_holes_ofile (<span class="stringliteral">"dtm_with_holes.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (dtm_holes_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (dtm_holes_ofile, dtm_mesh);</div><div class="line">  dtm_holes_ofile.close();</div><div class="line"></div><div class="line">  <span class="comment">// Get all holes</span></div><div class="line">  std::vector&lt;Mesh::Halfedge_index&gt; holes;</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PkgPolygonMeshProcessingRef.html#gafa9b682528c5dc2a4821d01193518d14">CGAL::Polygon_mesh_processing::extract_boundary_cycles</a> (dtm_mesh, std::back_inserter (holes));</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; holes.size() &lt;&lt; <span class="stringliteral">" hole(s) identified"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Identify outer hull (hole with maximum size)</span></div><div class="line">  <span class="keywordtype">double</span> max_size = 0.;</div><div class="line">  Mesh::Halfedge_index outer_hull;</div><div class="line">  <span class="keywordflow">for</span> (Mesh::Halfedge_index hi : holes)</div><div class="line">  {</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html">CGAL::Bbox_3</a> hole_bbox;</div><div class="line">    <span class="keywordflow">for</span> (Mesh::Halfedge_index haf : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLIterators.html#ga37229df31508a78eb4acdaf907e637e5">CGAL::halfedges_around_face</a>(hi, dtm_mesh))</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> Point_3&amp; p = dtm_mesh.point(target(haf, dtm_mesh));</div><div class="line">      hole_bbox += p.bbox();</div><div class="line">    }</div><div class="line">    <span class="keywordtype">double</span> size = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">CGAL::squared_distance</a> (Point_2(hole_bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#aab574470a2591f187553ca1166e682e1">xmin</a>(), hole_bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a2088e16a1f0a20e011e5b94c2e9c222a">ymin</a>()),</div><div class="line">                                          Point_2(hole_bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a3f5e323700e1509624a02d151237cc4c">xmax</a>(), hole_bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a9d06f61bd89faa841e011ff53edf745f">ymax</a>()));</div><div class="line">    <span class="keywordflow">if</span> (size &gt; max_size)</div><div class="line">    {</div><div class="line">      max_size = size;</div><div class="line">      outer_hull = hi;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Fill all holes except the bigest (which is the outer hull of the mesh)</span></div><div class="line">  <span class="keywordflow">for</span> (Mesh::Halfedge_index hi : holes)</div><div class="line">    <span class="keywordflow">if</span> (hi != outer_hull)</div><div class="line">      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__hole__filling__grp.html#ga16473e4861b13d1241edee68f596b153">CGAL::Polygon_mesh_processing::triangulate_refine_and_fair_hole</a></div><div class="line">        (dtm_mesh, hi, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Emptyset__iterator.html">CGAL::Emptyset_iterator</a>(), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Emptyset__iterator.html">CGAL::Emptyset_iterator</a>());</div><div class="line"></div><div class="line">  <span class="comment">// Save DTM with holes filled</span></div><div class="line">  std::ofstream dtm_filled_ofile (<span class="stringliteral">"dtm_filled.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (dtm_filled_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (dtm_filled_ofile, dtm_mesh);</div><div class="line">  dtm_filled_ofile.close();</div><div class="line"></div></div><!-- fragment --><p> Isotropic remeshing can also be performed as a final step in order to produce a more regular mesh that is not constrained by the shape of 2D Delaunay faces.</p>
<div class="fragment"><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__meshing__grp.html#gaa5cc92275df27f0baab2472ecbc4ea3f">CGAL::Polygon_mesh_processing::isotropic_remeshing</a> (faces(dtm_mesh), spacing, dtm_mesh);</div><div class="line"></div><div class="line">  std::ofstream dtm_remeshed_ofile (<span class="stringliteral">"dtm_remeshed.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (dtm_remeshed_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (dtm_remeshed_ofile, dtm_mesh);</div><div class="line">  dtm_remeshed_ofile.close();</div><div class="line"></div></div><!-- fragment --><p> <a class="el" href="tuto_gis.html#fig__TutorialGISFigProc">Figure 0.3</a> shows how these different steps affect the output mesh and <a class="el" href="tuto_gis.html#fig__TutorialGISFigDTM">Figure 0.4</a> shows the DTM isotropic mesh.</p>
<p><a class="anchor" id="fig__TutorialGISFigProc"></a></p><div class="image">
<img src="dtm_proc.jpg" alt="dtm_proc.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_gis.html#fig__TutorialGISFigProc">Figure 0.3</a> Raw DTM and postprocessing  </div> <br /> 
<p><a class="anchor" id="fig__TutorialGISFigDTM"></a></p><div class="image">
<img src="dtm.jpg" alt="dtm.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_gis.html#fig__TutorialGISFigDTM">Figure 0.4</a> Final DTM.  </div> <br /> 
<h1><a class="anchor" id="TutorialGIS_Raster"></a>
Rastering</h1>
<p>The TIN data structure can be combined with barycentric coordinates in order to interpolate and thus rasterize a height map at any resolution needed the information embedded in the vertices.</p>
<p>Because the latest two steps (hole filling and remeshing) were performed on a 3D mesh, the hypothesis that our DTM is a 2.5D representation may no longer be valid. We thus first rebuild a TIN using the vertices of the isotropic DTM mesh lastly computed.</p>
<p>The following snippet generates a raster image of the height in the form of rainbow ramp PPM file (simple bitmap format):</p>
<div class="fragment"><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html">CGAL::Bbox_3</a> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PkgPolygonMeshProcessingRef.html#gaf633ec6397f5f065b01462fe42235d56">bbox</a> = CGAL::bbox_3 (points.points().begin(), points.points().end());</div><div class="line"></div><div class="line">  <span class="comment">// Generate raster image 1920-pixels large</span></div><div class="line">  std::size_t width = 1920;</div><div class="line">  std::size_t height = std::size_t((bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a9d06f61bd89faa841e011ff53edf745f">ymax</a>() - bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a2088e16a1f0a20e011e5b94c2e9c222a">ymin</a>()) * 1920 / (bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a3f5e323700e1509624a02d151237cc4c">xmax</a>() - bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#aab574470a2591f187553ca1166e682e1">xmin</a>()));</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Rastering with resolution "</span> &lt;&lt; width &lt;&lt; <span class="stringliteral">"x"</span> &lt;&lt; height &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Use PPM format (Portable PixMap) for simplicity</span></div><div class="line">  std::ofstream raster_ofile (<span class="stringliteral">"raster.ppm"</span>, std::ios_base::binary);</div><div class="line"></div><div class="line">  <span class="comment">// PPM header</span></div><div class="line">  raster_ofile &lt;&lt; <span class="stringliteral">"P6"</span> &lt;&lt; std::endl <span class="comment">// magic number</span></div><div class="line">               &lt;&lt; width &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; height &lt;&lt; std::endl <span class="comment">// dimensions of the image</span></div><div class="line">               &lt;&lt; 255 &lt;&lt; std::endl; <span class="comment">// maximum color value</span></div><div class="line"></div><div class="line">  <span class="comment">// Use rainbow color ramp output</span></div><div class="line">  Color_ramp color_ramp;</div><div class="line"></div><div class="line">  <span class="comment">// Keeping track of location from one point to its neighbor allows</span></div><div class="line">  <span class="comment">// for fast locate in DT</span></div><div class="line">  TIN::Face_handle location;</div><div class="line"></div><div class="line">  <span class="comment">// Query each pixel of the image</span></div><div class="line">  <span class="keywordflow">for</span> (std::size_t y = 0; y &lt; height; ++ y)</div><div class="line">    <span class="keywordflow">for</span> (std::size_t x = 0; x &lt; width; ++ x)</div><div class="line">    {</div><div class="line">      Point_3 query (bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#aab574470a2591f187553ca1166e682e1">xmin</a>() + x * (bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a3f5e323700e1509624a02d151237cc4c">xmax</a>() - bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#aab574470a2591f187553ca1166e682e1">xmin</a>()) / <span class="keywordtype">double</span>(width),</div><div class="line">                     bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a2088e16a1f0a20e011e5b94c2e9c222a">ymin</a>() + (height-y) * (bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a9d06f61bd89faa841e011ff53edf745f">ymax</a>() - bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a2088e16a1f0a20e011e5b94c2e9c222a">ymin</a>()) / <span class="keywordtype">double</span>(height),</div><div class="line">                     0); <span class="comment">// not relevant for location in 2D</span></div><div class="line"></div><div class="line">      location = dtm_clean.locate (query, location);</div><div class="line"></div><div class="line">      <span class="comment">// Points outside the convex hull will be colored black</span></div><div class="line">      std::array&lt;unsigned char, 3&gt; colors { 0, 0, 0 };</div><div class="line">      <span class="keywordflow">if</span> (!dtm_clean.is_infinite(location))</div><div class="line">      {</div><div class="line">        std::array&lt;double, 3&gt; <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#gadd9f94997d1963426d38305192345564">barycentric_coordinates</a></div><div class="line">          = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#gadd9f94997d1963426d38305192345564">CGAL::Polygon_mesh_processing::barycentric_coordinates</a></div><div class="line">          (Point_2 (location-&gt;vertex(0)-&gt;point().x(), location-&gt;vertex(0)-&gt;point().y()),</div><div class="line">           Point_2 (location-&gt;vertex(1)-&gt;point().x(), location-&gt;vertex(1)-&gt;point().y()),</div><div class="line">           Point_2 (location-&gt;vertex(2)-&gt;point().x(), location-&gt;vertex(2)-&gt;point().y()),</div><div class="line">           Point_2 (query.x(), query.y()),</div><div class="line">           Kernel());</div><div class="line"></div><div class="line">        <span class="keywordtype">double</span> height_at_query</div><div class="line">          = (barycentric_coordinates[0] * location-&gt;vertex(0)-&gt;point().z()</div><div class="line">             + barycentric_coordinates[1] * location-&gt;vertex(1)-&gt;point().z()</div><div class="line">             + barycentric_coordinates[2] * location-&gt;vertex(2)-&gt;point().z());</div><div class="line"></div><div class="line">        <span class="comment">// Color ramp generates a color depending on a value from 0 to 1</span></div><div class="line">        <span class="keywordtype">double</span> height_ratio = (height_at_query - bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a6c55430abc7fda54571cf1075c7f2f8b">zmin</a>()) / (bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a98def8b9515f31ded759d781969ddaf6">zmax</a>() - bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a6c55430abc7fda54571cf1075c7f2f8b">zmin</a>());</div><div class="line">        colors = color_ramp.get(height_ratio);</div><div class="line">      }</div><div class="line">      raster_ofile.write (reinterpret_cast&lt;char*&gt;(&amp;colors), 3);</div><div class="line">    }</div><div class="line"></div><div class="line">  raster_ofile.close();</div><div class="line"></div></div><!-- fragment --><p> An example of a raster image with a rainbow ramp representing height is given in <a class="el" href="tuto_gis.html#fig__TutorialGISFigRastering">Figure 0.5</a>.</p>
<p><a class="anchor" id="fig__TutorialGISFigRastering"></a></p><div class="image">
<img src="raster.jpg" alt="raster.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_gis.html#fig__TutorialGISFigRastering">Figure 0.5</a> Raster visualisation of height using a rainbow ramp, ranging from light blue for low values to dark red for high values.  </div> <br /> 
<h1><a class="anchor" id="TutorialGIS_Contour"></a>
Contouring</h1>
<p>Extracting isolevels of a function defined on a TIN is another application that can be done with CGAL. We demonstrate here how to extract isolevels of height to build a topographic map.</p>
<h2><a class="anchor" id="TutorialGIS_Contour_Extraction"></a>
Building a Contour Graph</h2>
<p>The first step is to extract, from all faces of the triangulation, the section of each isolevel that goes through that face, in the form of a segment. The following functions allow to test if one isovalue does cross a face, and to extract it then:</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keywordtype">bool</span> face_has_isovalue (TIN::Face_handle fh, <span class="keywordtype">double</span> isovalue)</div><div class="line">{</div><div class="line">  <span class="keywordtype">bool</span> above = <span class="keyword">false</span>, below = <span class="keyword">false</span>;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++ i)</div><div class="line">  {</div><div class="line">    <span class="comment">// Face has isovalue if one of its vertices is above and another</span></div><div class="line">    <span class="comment">// one below</span></div><div class="line">    <span class="keywordflow">if</span> (fh-&gt;vertex(i)-&gt;point().z() &gt; isovalue)</div><div class="line">      above = <span class="keyword">true</span>;</div><div class="line">    <span class="keywordflow">if</span> (fh-&gt;vertex(i)-&gt;point().z() &lt; isovalue)</div><div class="line">      below = <span class="keyword">true</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> (above &amp;&amp; below);</div><div class="line">}</div><div class="line"></div><div class="line">Segment_3 isocontour_in_face (TIN::Face_handle fh, <span class="keywordtype">double</span> isovalue)</div><div class="line">{</div><div class="line">  Point_3 source;</div><div class="line">  Point_3 target;</div><div class="line">  <span class="keywordtype">bool</span> source_found = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++ i)</div><div class="line">  {</div><div class="line">    Point_3 p0 = fh-&gt;vertex((i+1) % 3)-&gt;point();</div><div class="line">    Point_3 p1 = fh-&gt;vertex((i+2) % 3)-&gt;point();</div><div class="line"></div><div class="line">    <span class="comment">// Check if the isovalue crosses segment (p0,p1)</span></div><div class="line">    <span class="keywordflow">if</span> ((p0.z() - isovalue) * (p1.z() - isovalue) &gt; 0)</div><div class="line">      <span class="keywordflow">continue</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> zbottom = p0.z();</div><div class="line">    <span class="keywordtype">double</span> ztop = p1.z();</div><div class="line">    <span class="keywordflow">if</span> (zbottom &gt; ztop)</div><div class="line">    {</div><div class="line">      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polynomial.tag:../Polynomial/" href="../Polynomial/group__PkgPolynomialFunctions.html#gaa555a2d0a5bf3730c337f08f07356c07">std::swap</a> (zbottom, ztop);</div><div class="line">      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polynomial.tag:../Polynomial/" href="../Polynomial/group__PkgPolynomialFunctions.html#gaa555a2d0a5bf3730c337f08f07356c07">std::swap</a> (p0, p1);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Compute position of segment vertex</span></div><div class="line">    <span class="keywordtype">double</span> ratio = (isovalue - zbottom) / (ztop - zbottom);</div><div class="line">    Point_3 p = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__barycenter__grp.html#ga43dafb654e67589a55dcf5b13092966b">CGAL::barycenter</a> (p0, (1 - ratio), p1,ratio);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (source_found)</div><div class="line">      target = p;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      source = p;</div><div class="line">      source_found = <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> Segment_3 (source, target);</div><div class="line">}</div><div class="line"></div><div class="line"></div></div><!-- fragment --><p> From these functions, we can create a graph of segments to process later into a set of polylines. To do so, we use the <a href="https://www.boost.org/doc/libs/1_72_0/libs/graph/doc/adjacency_list.html">boost::adjacency_list</a> structure and keep track of a mapping from the positions of the end points to the vertices of the graph.</p>
<p>The following code computes 50 isovalues evenly distributed between the minimum and maximum heights of the point cloud and creates a graph containing all isolevels:</p>
<div class="fragment"><div class="line"></div><div class="line">  std::array&lt;double, 50&gt; isovalues; <span class="comment">// Contour 50 isovalues</span></div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; isovalues.size(); ++ i)</div><div class="line">    isovalues[i] = bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a6c55430abc7fda54571cf1075c7f2f8b">zmin</a>() + ((i+1) * (bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a98def8b9515f31ded759d781969ddaf6">zmax</a>() - bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a6c55430abc7fda54571cf1075c7f2f8b">zmin</a>()) / (isovalues.size() - 2));</div><div class="line"></div><div class="line">  <span class="comment">// First find on each face if they are crossed by some isovalues and</span></div><div class="line">  <span class="comment">// extract segments in a graph</span></div><div class="line">  <span class="keyword">using</span> Segment_graph = boost::adjacency_list&lt;boost::listS, boost::vecS, boost::undirectedS, Point_3&gt;;</div><div class="line">  Segment_graph graph;</div><div class="line">  <span class="keyword">using</span> Map_p2v = std::map&lt;Point_3, Segment_graph::vertex_descriptor&gt;;</div><div class="line">  Map_p2v map_p2v;</div><div class="line">  <span class="keywordflow">for</span> (TIN::Face_handle vh : dtm_clean.finite_face_handles())</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">double</span> iv : isovalues)</div><div class="line">      <span class="keywordflow">if</span> (face_has_isovalue (vh, iv))</div><div class="line">      {</div><div class="line">        Segment_3 segment = isocontour_in_face (vh, iv);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> Point_3&amp; p : { segment.source(), segment.target() })</div><div class="line">        {</div><div class="line">          <span class="comment">// Only insert end points of segments once to get a well connected graph</span></div><div class="line">          Map_p2v::iterator iter;</div><div class="line">          <span class="keywordtype">bool</span> inserted;</div><div class="line">          std::tie (iter, inserted) = map_p2v.insert (std::make_pair (p, Segment_graph::vertex_descriptor()));</div><div class="line">          <span class="keywordflow">if</span> (inserted)</div><div class="line">          {</div><div class="line">            iter-&gt;second = boost::add_vertex (graph);</div><div class="line">            graph[iter-&gt;second] = p;</div><div class="line">          }</div><div class="line">        }</div><div class="line">        <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLEulerOperations.html#ga4661f850bc60686efeae2fc9d2ec3e65">boost::add_edge</a> (map_p2v[segment.source()], map_p2v[segment.target()], graph);</div><div class="line">      }</div><div class="line"></div></div><!-- fragment --> <h2><a class="anchor" id="TutorialGIS_Contour_Splitting"></a>
Splitting Into Polylines</h2>
<p>Once the graph is created, splitting it into polylines is easily performed using the function <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLPartition.html#ga99ea6bf193f1194db5e523e713c82fb9"><code>CGAL::split_graph_into_polylines()</code> </a>:</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="comment">// Split segments into polylines</span></div><div class="line">  std::vector&lt;std::vector&lt;Point_3&gt; &gt; polylines;</div><div class="line">  Polylines_visitor&lt;Segment_graph&gt; visitor (graph, polylines);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLPartition.html#ga99ea6bf193f1194db5e523e713c82fb9">CGAL::split_graph_into_polylines</a> (graph, visitor);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; polylines.size() &lt;&lt; <span class="stringliteral">" polylines computed, with "</span></div><div class="line">            &lt;&lt; map_p2v.size() &lt;&lt; <span class="stringliteral">" vertices in total"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Output to WKT file</span></div><div class="line">  std::ofstream contour_ofile (<span class="stringliteral">"contour.wkt"</span>);</div><div class="line">  contour_ofile.precision(18);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsWKT.html#ga013d6cd500473657f41c44c9df43c511">CGAL::IO::write_multi_linestring_WKT</a> (contour_ofile, polylines);</div><div class="line">  contour_ofile.close();</div><div class="line"></div></div><!-- fragment --><p> This function requires a visitor which is called when starting a polyline, when adding a point to it and when ending it. Defining such a class is straightforward in our case:</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph&gt;</div><div class="line"><span class="keyword">class </span>Polylines_visitor</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">  std::vector&lt;std::vector&lt;Point_3&gt; &gt;&amp; polylines;</div><div class="line">  Graph&amp; graph;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">  Polylines_visitor (Graph&amp; graph, std::vector&lt;std::vector&lt;Point_3&gt; &gt;&amp; polylines)</div><div class="line">    : polylines (polylines), graph(graph) { }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> start_new_polyline()</div><div class="line">  {</div><div class="line">    polylines.push_back (std::vector&lt;Point_3&gt;());</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> add_node (<span class="keyword">typename</span> Graph::vertex_descriptor vd)</div><div class="line">  {</div><div class="line">    polylines.back().push_back (graph[vd]);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> end_polyline()</div><div class="line">  {</div><div class="line">    <span class="comment">// filter small polylines</span></div><div class="line">    <span class="keywordflow">if</span> (polylines.back().size() &lt; 50)</div><div class="line">      polylines.pop_back();</div><div class="line">  }</div><div class="line">};</div><div class="line"></div></div><!-- fragment --> <h2><a class="anchor" id="TutorialGIS_Contour_Simplifying"></a>
Simplifying</h2>
<p>Because the output is quite noisy, users may want to simplify the polylines. CGAL provides a polyline simplification algorithm that guarantees that two polylines won't intersect after simplification. This algorithm takes advantage of the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Constrained__triangulation__plus__2.html">CGAL::Constrained_triangulation_plus_2</a></code>, which embeds polylines as a set of constraints:</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keyword">namespace </span>PS = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polyline_simplification_2.tag:../Polyline_simplification_2/" href="../Polyline_simplification_2/namespaceCGAL_1_1Polyline__simplification__2.html">CGAL::Polyline_simplification_2</a>;</div><div class="line"><span class="keyword">using</span> CDT_vertex_base = PS::Vertex_base_2&lt;Projection_traits&gt;;</div><div class="line"><span class="keyword">using</span> CDT_face_base = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Constrained__triangulation__face__base__2.html">CGAL::Constrained_triangulation_face_base_2&lt;Projection_traits&gt;</a>;</div><div class="line"><span class="keyword">using</span> CDT_TDS = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/TDS_2.tag:../TDS_2/" href="../TDS_2/classCGAL_1_1Triangulation__data__structure__2.html">CGAL::Triangulation_data_structure_2&lt;CDT_vertex_base, CDT_face_base&gt;</a>;</div><div class="line"><span class="keyword">using</span> CDT = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Constrained__Delaunay__triangulation__2.html">CGAL::Constrained_Delaunay_triangulation_2&lt;Projection_traits, CDT_TDS&gt;</a>;</div><div class="line"><span class="keyword">using</span> CTP = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Constrained__triangulation__plus__2.html">CGAL::Constrained_triangulation_plus_2&lt;CDT&gt;</a>;</div><div class="line"></div></div><!-- fragment --><p> The following code simplifies the polyline set based on the squared distance to the original polylines, stopping when no more vertex can be removed without going farther than 4 times the average spacing.</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="comment">// Construct constrained Delaunay triangulation with polylines as constraints</span></div><div class="line">  CTP ctp;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> std::vector&lt;Point_3&gt;&amp; poly : polylines)</div><div class="line">    ctp.insert_constraint (poly.begin(), poly.end());</div><div class="line"></div><div class="line">  <span class="comment">// Simplification algorithm with limit on distance</span></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga5339b0f11fdc9babbc5ca0b33f4a982c">PS::simplify</a> (ctp, PS::Squared_distance_cost(), PS::Stop_above_cost_threshold (16 * spacing * spacing));</div><div class="line"></div><div class="line">  polylines.clear();</div><div class="line">  <span class="keywordflow">for</span> (CTP::Constraint_id cid : ctp.constraints())</div><div class="line">  {</div><div class="line">    polylines.push_back (std::vector&lt;Point_3&gt;());</div><div class="line">    polylines.back().reserve (ctp.vertices_in_constraint (cid).size());</div><div class="line">    <span class="keywordflow">for</span> (CTP::Vertex_handle vh : ctp.vertices_in_constraint(cid))</div><div class="line">      polylines.back().push_back (vh-&gt;point());</div><div class="line">  }</div><div class="line"></div><div class="line">  std::size_t nb_vertices</div><div class="line">    = std::accumulate (polylines.begin(), polylines.end(), std::size_t(0),</div><div class="line">                       [](std::size_t size, <span class="keyword">const</span> std::vector&lt;Point_3&gt;&amp; poly) -&gt; std::size_t</div><div class="line">                       { <span class="keywordflow">return</span> size + poly.size(); });</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; nb_vertices</div><div class="line">            &lt;&lt; <span class="stringliteral">" vertices remaining after simplification ("</span></div><div class="line">            &lt;&lt; 100. * (nb_vertices / double(map_p2v.size())) &lt;&lt; <span class="stringliteral">"%)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Output to WKT file</span></div><div class="line">  std::ofstream simplified_ofile (<span class="stringliteral">"simplified.wkt"</span>);</div><div class="line">  simplified_ofile.precision(18);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsWKT.html#ga013d6cd500473657f41c44c9df43c511">CGAL::IO::write_multi_linestring_WKT</a> (simplified_ofile, polylines);</div><div class="line">  simplified_ofile.close();</div><div class="line"></div></div><!-- fragment --><p> Examples of contours and simplifications are given in <a class="el" href="tuto_gis.html#fig__TutorialGISFigContours">Figure 0.6</a>.</p>
<p><a class="anchor" id="fig__TutorialGISFigContours"></a></p><div class="image">
<img src="contours.png" alt="contours.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_gis.html#fig__TutorialGISFigContours">Figure 0.6</a> Contouring using 50 isovalues evenly spaced. Top: original contouring using 148k vertices and simplification with a tolerance equal to the average spacing of the input point cloud (3.4% of the original polyline vertices remaining). Bottom: simplification with tolerance 4 times the average spacing (1.3% of vertices remaining) and with tolerance 10 times the average spacing (0.9% of vertices remaining). Polylines are intersection-free in all cases.  </div> <br /> 
<h1><a class="anchor" id="TutorialGIS_Classify"></a>
Classifying</h1>
<p>CGAL provides a package Classification which can be used to segment a point cloud into a user-defined label set. The state-of-the-art classifier currently available in CGAL is the random forest from ETHZ. As it is a supervised classifier, a training set is needed.</p>
<p>The following snippet shows how to use some manually selected training set to train a random forest classifier and compute a classification regularized by a graph cut algorithm:</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="comment">// Get training from input</span></div><div class="line">  Point_set::Property_map&lt;int&gt; training_map;</div><div class="line">  <span class="keywordtype">bool</span> training_found;</div><div class="line">  std::tie (training_map, training_found) = points.property_map&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">"training"</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (training_found)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Classifying ground/vegetation/building"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// Create labels</span></div><div class="line">    Classification::Label_set labels ({ <span class="stringliteral">"ground"</span>, <span class="stringliteral">"vegetation"</span>, <span class="stringliteral">"building"</span> });</div><div class="line"></div><div class="line">    <span class="comment">// Generate features</span></div><div class="line">    Classification::Feature_set <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Mesh_3.tag:../Mesh_3/" href="../Mesh_3/group__PkgMesh3Parameters.html#ga0a990b28d55157c62d4bfd2624d408af">features</a>;</div><div class="line">    Classification::Point_set_feature_generator&lt;Kernel, Point_set, Point_set::Point_map&gt;</div><div class="line">      generator (points, points.point_map(), 5); <span class="comment">// 5 scales</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef CGAL_LINKED_WITH_TBB</span></div><div class="line">    <span class="comment">// If TBB is used, features can be computed in parallel</span></div><div class="line">    features.begin_parallel_additions();</div><div class="line">    generator.generate_point_based_features (features);</div><div class="line">    features.end_parallel_additions();</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    generator.generate_point_based_features (features);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">    <span class="comment">// Train a random forest classifier</span></div><div class="line">    Classification::ETHZ::Random_forest_classifier classifier (labels, features);</div><div class="line">    classifier.train (points.range(training_map));</div><div class="line"></div><div class="line">    <span class="comment">// Classify with graphcut regularization</span></div><div class="line">    Point_set::Property_map&lt;int&gt; label_map = points.add_property_map&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">"labels"</span>).first;</div><div class="line">    Classification::classify_with_graphcut&lt;Concurrency_tag&gt;</div><div class="line">      (points, points.point_map(), labels, classifier,</div><div class="line">       generator.neighborhood().k_neighbor_query(12), <span class="comment">// regularize on 12-neighbors graph</span></div><div class="line">       0.5f, <span class="comment">// graphcut weight</span></div><div class="line">       12, <span class="comment">// Subdivide to speed-up process</span></div><div class="line">       label_map);</div><div class="line"></div><div class="line">    <span class="comment">// Evaluate</span></div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Mean IoU on training data = "</span></div><div class="line">              &lt;&lt; Classification::Evaluation(labels,</div><div class="line">                                            points.range(training_map),</div><div class="line">                                            points.range(label_map)).mean_intersection_over_union() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// Save the classified point set</span></div><div class="line">    std::ofstream classified_ofile (<span class="stringliteral">"classified.ply"</span>);</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (classified_ofile);</div><div class="line">    classified_ofile &lt;&lt; points;</div><div class="line">    classified_ofile.close();</div><div class="line">  }</div><div class="line"></div></div><!-- fragment --><p> An example of training set and resulting classification is given in <a class="el" href="tuto_gis.html#fig__TutorialGISFigClassif">Figure 0.7</a>.</p>
<p><a class="anchor" id="fig__TutorialGISFigClassif"></a></p><div class="image">
<img src="classif_tuto.jpg" alt="classif_tuto.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_gis.html#fig__TutorialGISFigClassif">Figure 0.7</a> Top: a slice of the point cloud classified by hand. Bottom: a classification regularized by graph cut after training on 3 manually classified slices.  </div> <br /> 
<h1><a class="anchor" id="TutorialGIS_Code"></a>
Full Code Example</h1>
<p>All the code snippets used in this tutorial can be assembled to create a full GIS pipeline (provided the correct <em>includes</em> are used). We give a full code example which achieves all the steps described in this tutorial.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Projection_traits_xy_3.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Delaunay_triangulation_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Triangulation_vertex_base_with_info_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Triangulation_face_base_with_info_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/graph_traits_Delaunay_triangulation_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/copy_face_graph.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3/IO.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/compute_average_spacing.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/locate.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/triangulate_hole.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/border.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/remesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/graph/adjacency_list.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/split_graph_into_polylines.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/WKT.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Constrained_Delaunay_triangulation_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Constrained_triangulation_plus_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyline_simplification_2/simplify.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyline_simplification_2/Squared_distance_cost.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Classification.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Random.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;queue&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "include/Color_ramp.h"</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">using</span> Kernel = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div><div class="line"><span class="keyword">using</span> Projection_traits = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Projection__traits__xy__3.html">CGAL::Projection_traits_xy_3&lt;Kernel&gt;</a>;</div><div class="line"><span class="keyword">using</span> Point_2 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>;</div><div class="line"><span class="keyword">using</span> Point_3 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ae82b7f4be77dd5b8819ebe419e4ae753">Kernel::Point_3</a>;</div><div class="line"><span class="keyword">using</span> Segment_3 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#aa43a461b2027ef7d99b776a7b03ef230">Kernel::Segment_3</a>;</div><div class="line"></div><div class="line"><span class="comment">// Triangulated Irregular Network</span></div><div class="line"><span class="keyword">using</span> TIN = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2&lt;Projection_traits&gt;</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Triangulated Irregular Network (with info)</span></div><div class="line"><span class="keyword">using</span> Point_set = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3&lt;Point_3&gt;</a>;</div><div class="line"><span class="keyword">using</span> Vbi = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Triangulation__vertex__base__with__info__2.html">CGAL::Triangulation_vertex_base_with_info_2 &lt;Point_set::Index, Projection_traits&gt;</a>;</div><div class="line"><span class="keyword">using</span> Fbi = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Triangulation__face__base__with__info__2.html">CGAL::Triangulation_face_base_with_info_2&lt;int, Projection_traits&gt;</a>;</div><div class="line"><span class="keyword">using</span> TDS = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/TDS_2.tag:../TDS_2/" href="../TDS_2/classCGAL_1_1Triangulation__data__structure__2.html">CGAL::Triangulation_data_structure_2&lt;Vbi, Fbi&gt;</a>;</div><div class="line"><span class="keyword">using</span> TIN_with_info = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2&lt;Projection_traits, TDS&gt;</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Classification = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Classification.tag:../Classification/" href="../Classification/namespaceCGAL_1_1Classification.html">CGAL::Classification</a>;</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef CGAL_LINKED_WITH_TBB</span></div><div class="line"><span class="keyword">using</span> Concurrency_tag = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__tag.html">CGAL::Parallel_tag</a>;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line"><span class="keyword">using</span> Concurrency_tag = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Sequential__tag.html">CGAL::Sequential_tag</a>;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> face_has_isovalue (TIN::Face_handle fh, <span class="keywordtype">double</span> isovalue)</div><div class="line">{</div><div class="line">  <span class="keywordtype">bool</span> above = <span class="keyword">false</span>, below = <span class="keyword">false</span>;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++ i)</div><div class="line">  {</div><div class="line">    <span class="comment">// Face has isovalue if one of its vertices is above and another</span></div><div class="line">    <span class="comment">// one below</span></div><div class="line">    <span class="keywordflow">if</span> (fh-&gt;vertex(i)-&gt;point().z() &gt; isovalue)</div><div class="line">      above = <span class="keyword">true</span>;</div><div class="line">    <span class="keywordflow">if</span> (fh-&gt;vertex(i)-&gt;point().z() &lt; isovalue)</div><div class="line">      below = <span class="keyword">true</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> (above &amp;&amp; below);</div><div class="line">}</div><div class="line"></div><div class="line">Segment_3 isocontour_in_face (TIN::Face_handle fh, <span class="keywordtype">double</span> isovalue)</div><div class="line">{</div><div class="line">  Point_3 source;</div><div class="line">  Point_3 target;</div><div class="line">  <span class="keywordtype">bool</span> source_found = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++ i)</div><div class="line">  {</div><div class="line">    Point_3 p0 = fh-&gt;vertex((i+1) % 3)-&gt;point();</div><div class="line">    Point_3 p1 = fh-&gt;vertex((i+2) % 3)-&gt;point();</div><div class="line"></div><div class="line">    <span class="comment">// Check if the isovalue crosses segment (p0,p1)</span></div><div class="line">    <span class="keywordflow">if</span> ((p0.z() - isovalue) * (p1.z() - isovalue) &gt; 0)</div><div class="line">      <span class="keywordflow">continue</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> zbottom = p0.z();</div><div class="line">    <span class="keywordtype">double</span> ztop = p1.z();</div><div class="line">    <span class="keywordflow">if</span> (zbottom &gt; ztop)</div><div class="line">    {</div><div class="line">      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polynomial.tag:../Polynomial/" href="../Polynomial/group__PkgPolynomialFunctions.html#gaa555a2d0a5bf3730c337f08f07356c07">std::swap</a> (zbottom, ztop);</div><div class="line">      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polynomial.tag:../Polynomial/" href="../Polynomial/group__PkgPolynomialFunctions.html#gaa555a2d0a5bf3730c337f08f07356c07">std::swap</a> (p0, p1);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Compute position of segment vertex</span></div><div class="line">    <span class="keywordtype">double</span> ratio = (isovalue - zbottom) / (ztop - zbottom);</div><div class="line">    Point_3 p = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__barycenter__grp.html#ga43dafb654e67589a55dcf5b13092966b">CGAL::barycenter</a> (p0, (1 - ratio), p1,ratio);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (source_found)</div><div class="line">      target = p;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      source = p;</div><div class="line">      source_found = <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> Segment_3 (source, target);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph&gt;</div><div class="line"><span class="keyword">class </span>Polylines_visitor</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">  std::vector&lt;std::vector&lt;Point_3&gt; &gt;&amp; polylines;</div><div class="line">  Graph&amp; graph;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">  Polylines_visitor (Graph&amp; graph, std::vector&lt;std::vector&lt;Point_3&gt; &gt;&amp; polylines)</div><div class="line">    : polylines (polylines), graph(graph) { }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> start_new_polyline()</div><div class="line">  {</div><div class="line">    polylines.push_back (std::vector&lt;Point_3&gt;());</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> add_node (<span class="keyword">typename</span> Graph::vertex_descriptor vd)</div><div class="line">  {</div><div class="line">    polylines.back().push_back (graph[vd]);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> end_polyline()</div><div class="line">  {</div><div class="line">    <span class="comment">// filter small polylines</span></div><div class="line">    <span class="keywordflow">if</span> (polylines.back().size() &lt; 50)</div><div class="line">      polylines.pop_back();</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>PS = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polyline_simplification_2.tag:../Polyline_simplification_2/" href="../Polyline_simplification_2/namespaceCGAL_1_1Polyline__simplification__2.html">CGAL::Polyline_simplification_2</a>;</div><div class="line"><span class="keyword">using</span> CDT_vertex_base = PS::Vertex_base_2&lt;Projection_traits&gt;;</div><div class="line"><span class="keyword">using</span> CDT_face_base = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Constrained__triangulation__face__base__2.html">CGAL::Constrained_triangulation_face_base_2&lt;Projection_traits&gt;</a>;</div><div class="line"><span class="keyword">using</span> CDT_TDS = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/TDS_2.tag:../TDS_2/" href="../TDS_2/classCGAL_1_1Triangulation__data__structure__2.html">CGAL::Triangulation_data_structure_2&lt;CDT_vertex_base, CDT_face_base&gt;</a>;</div><div class="line"><span class="keyword">using</span> CDT = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Constrained__Delaunay__triangulation__2.html">CGAL::Constrained_Delaunay_triangulation_2&lt;Projection_traits, CDT_TDS&gt;</a>;</div><div class="line"><span class="keyword">using</span> CTP = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Constrained__triangulation__plus__2.html">CGAL::Constrained_triangulation_plus_2&lt;CDT&gt;</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname = argc != 2 ? <a class="code" href="namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/b9_training.ply"</span>) : argv[1];</div><div class="line">  <span class="keywordflow">if</span> (argc != 2)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Usage: "</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">" points.ply"</span> &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Running with default value "</span> &lt;&lt; fname &lt;&lt; <span class="stringliteral">"\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Read points</span></div><div class="line">  std::ifstream ifile (fname, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3&lt;Point_3&gt;</a> points;</div><div class="line">  ifile &gt;&gt; points;</div><div class="line">  std::cerr &lt;&lt; points.size() &lt;&lt; <span class="stringliteral">" point(s) read"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Create DSM</span></div><div class="line">  TIN dsm (points.points().begin(), points.points().end());</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">using</span> Mesh = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point_3&gt;</a>;</div><div class="line"></div><div class="line">  Mesh dsm_mesh;</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#ga2682fb7d5f4ff4eb65607ae4118e31bc">CGAL::copy_face_graph</a> (dsm, dsm_mesh);</div><div class="line">  std::ofstream dsm_ofile (<span class="stringliteral">"dsm.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (dsm_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (dsm_ofile, dsm_mesh);</div><div class="line">  dsm_ofile.close();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">auto</span> idx_to_point_with_info</div><div class="line">    = [&amp;](<span class="keyword">const</span> Point_set::Index&amp; idx) -&gt; std::pair&lt;Point_3, Point_set::Index&gt;</div><div class="line">      {</div><div class="line">        <span class="keywordflow">return</span> std::make_pair (points.point(idx), idx);</div><div class="line">      };</div><div class="line"></div><div class="line">  TIN_with_info tin_with_info</div><div class="line">    (boost::make_transform_iterator (points.begin(), idx_to_point_with_info),</div><div class="line">     boost::make_transform_iterator (points.end(), idx_to_point_with_info));</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> spacing = CGAL::compute_average_spacing&lt;Concurrency_tag&gt;(points, 6);</div><div class="line">  spacing *= 2;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> face_height</div><div class="line">    = [&amp;](<span class="keyword">const</span> TIN_with_info::Face_handle fh) -&gt; <span class="keywordtype">double</span></div><div class="line">      {</div><div class="line">        <span class="keywordtype">double</span> out = 0.;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++ i)</div><div class="line">          out = (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/group__nt__util.html#gad7dbfa919e255b52f36ea1512a92cb78">std::max</a>) (out, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">CGAL::abs</a>(fh-&gt;vertex(i)-&gt;point().z() - fh-&gt;vertex((i+1)%3)-&gt;point().z()));</div><div class="line">        <span class="keywordflow">return</span> out;</div><div class="line">      };</div><div class="line"></div><div class="line">  <span class="comment">// Initialize faces info</span></div><div class="line">  <span class="keywordflow">for</span> (TIN_with_info::Face_handle fh : tin_with_info.all_face_handles())</div><div class="line">    <span class="keywordflow">if</span> (tin_with_info.is_infinite(fh) || face_height(fh) &gt; spacing) <span class="comment">// Filtered faces are given info() = -2</span></div><div class="line">      fh-&gt;info() = -2;</div><div class="line">    <span class="keywordflow">else</span> <span class="comment">// Pending faces are given info() = -1;</span></div><div class="line">      fh-&gt;info() = -1;</div><div class="line"></div><div class="line">  <span class="comment">// Flooding algorithm</span></div><div class="line">  std::vector&lt;int&gt; component_size;</div><div class="line">  <span class="keywordflow">for</span> (TIN_with_info::Face_handle fh : tin_with_info.finite_face_handles())</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (fh-&gt;info() != -1)</div><div class="line">      <span class="keywordflow">continue</span>;</div><div class="line"></div><div class="line">    std::queue&lt;TIN_with_info::Face_handle&gt; todo;</div><div class="line">    todo.push(fh);</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> size = 0;</div><div class="line">    <span class="keywordflow">while</span> (!todo.empty())</div><div class="line">    {</div><div class="line">      TIN_with_info::Face_handle current = todo.front();</div><div class="line">      todo.pop();</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (current-&gt;info() != -1)</div><div class="line">        <span class="keywordflow">continue</span>;</div><div class="line">      current-&gt;info() = int(component_size.size());</div><div class="line">      ++ size;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++ i)</div><div class="line">        todo.push (current-&gt;neighbor(i));</div><div class="line">    }</div><div class="line"></div><div class="line">    component_size.push_back (size);</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; component_size.size() &lt;&lt; <span class="stringliteral">" connected component(s) found"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  Mesh tin_colored_mesh;</div><div class="line"></div><div class="line">  Mesh::Property_map&lt;Mesh::Face_index, CGAL::IO::Color&gt;</div><div class="line">    color_map = tin_colored_mesh.add_property_map&lt;Mesh::Face_index, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a>&gt;(<span class="stringliteral">"f:color"</span>).first;</div><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#ga2682fb7d5f4ff4eb65607ae4118e31bc">CGAL::copy_face_graph</a> (tin_with_info, tin_colored_mesh,</div><div class="line">                         CGAL::parameters::face_to_face_output_iterator</div><div class="line">                         (boost::make_function_output_iterator</div><div class="line">                          ([&amp;](<span class="keyword">const</span> std::pair&lt;TIN_with_info::Face_handle, Mesh::Face_index&gt;&amp; ff)</div><div class="line">                           {</div><div class="line">                             <span class="comment">// Color unassigned faces gray</span></div><div class="line">                             <span class="keywordflow">if</span> (ff.first-&gt;info() &lt; 0)</div><div class="line">                               color_map[ff.second] = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a>(128, 128, 128);</div><div class="line">                             <span class="keywordflow">else</span></div><div class="line">                             {</div><div class="line">                               <span class="comment">// Random color seeded by the component ID</span></div><div class="line">                               <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Generator.tag:../Generator/" href="../Generator/classCGAL_1_1Random.html">CGAL::Random</a> r (ff.first-&gt;info());</div><div class="line">                               color_map[ff.second] = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a> (r.get_int(64, 192),</div><div class="line">                                                                   r.get_int(64, 192),</div><div class="line">                                                                   r.get_int(64, 192));</div><div class="line">                             }</div><div class="line">                           })));</div><div class="line"></div><div class="line">  std::ofstream tin_colored_ofile (<span class="stringliteral">"colored_tin.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (tin_colored_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (tin_colored_ofile, tin_colored_mesh);</div><div class="line">  tin_colored_ofile.close();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> min_size = int(points.size() / 2);</div><div class="line"></div><div class="line">  std::vector&lt;TIN_with_info::Vertex_handle&gt; to_remove;</div><div class="line">  <span class="keywordflow">for</span> (TIN_with_info::Vertex_handle vh : tin_with_info.finite_vertex_handles())</div><div class="line">  {</div><div class="line">    TIN_with_info::Face_circulator circ = tin_with_info.incident_faces (vh),</div><div class="line">      start = circ;</div><div class="line"></div><div class="line">    <span class="comment">// Remove a vertex if it's only adjacent to components smaller than threshold</span></div><div class="line">    <span class="keywordtype">bool</span> keep = <span class="keyword">false</span>;</div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (circ-&gt;info() &gt;= 0 &amp;&amp; component_size[std::size_t(circ-&gt;info())] &gt; min_size)</div><div class="line">      {</div><div class="line">        keep = <span class="keyword">true</span>;</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">while</span> (++ circ != start);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (!keep)</div><div class="line">      to_remove.push_back (vh);</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; to_remove.size() &lt;&lt; <span class="stringliteral">" vertices(s) will be removed after filtering"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (TIN_with_info::Vertex_handle vh : to_remove)</div><div class="line">    tin_with_info.remove (vh);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Copy and keep track of overly large faces</span></div><div class="line">  Mesh dtm_mesh;</div><div class="line"></div><div class="line">  std::vector&lt;Mesh::Face_index&gt; face_selection;</div><div class="line">  Mesh::Property_map&lt;Mesh::Face_index, bool&gt; face_selection_map</div><div class="line">   = dtm_mesh.add_property_map&lt;Mesh::Face_index, <span class="keywordtype">bool</span>&gt;(<span class="stringliteral">"is_selected"</span>, <span class="keyword">false</span>).first;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> limit = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga07001b5ddc5c43096c811c91a306be9a">CGAL::square</a> (5 * spacing);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#ga2682fb7d5f4ff4eb65607ae4118e31bc">CGAL::copy_face_graph</a> (tin_with_info, dtm_mesh,</div><div class="line">                         CGAL::parameters::face_to_face_output_iterator</div><div class="line">                         (boost::make_function_output_iterator</div><div class="line">                          ([&amp;](<span class="keyword">const</span> std::pair&lt;TIN_with_info::Face_handle, Mesh::Face_index&gt;&amp; ff)</div><div class="line">                           {</div><div class="line">                             <span class="keywordtype">double</span> longest_edge = 0.;</div><div class="line">                             <span class="keywordtype">bool</span> border = <span class="keyword">false</span>;</div><div class="line">                             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++ i)</div><div class="line">                             {</div><div class="line">                               longest_edge = (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/group__nt__util.html#gad7dbfa919e255b52f36ea1512a92cb78">std::max</a>)(longest_edge, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">CGAL::squared_distance</a></div><div class="line">                                                         (ff.first-&gt;vertex((i+1)%3)-&gt;point(),</div><div class="line">                                                          ff.first-&gt;vertex((i+2)%3)-&gt;point()));</div><div class="line"></div><div class="line">                               TIN_with_info::Face_circulator circ</div><div class="line">                                 = tin_with_info.incident_faces (ff.first-&gt;vertex(i)),</div><div class="line">                                 start = circ;</div><div class="line">                               <span class="keywordflow">do</span></div><div class="line">                               {</div><div class="line">                                 <span class="keywordflow">if</span> (tin_with_info.is_infinite (circ))</div><div class="line">                                 {</div><div class="line">                                   border = <span class="keyword">true</span>;</div><div class="line">                                   <span class="keywordflow">break</span>;</div><div class="line">                                 }</div><div class="line">                               }</div><div class="line">                               <span class="keywordflow">while</span> (++ circ != start);</div><div class="line"></div><div class="line">                               <span class="keywordflow">if</span> (border)</div><div class="line">                                 <span class="keywordflow">break</span>;</div><div class="line">                             }</div><div class="line"></div><div class="line">                             <span class="comment">// Select if face is too big AND it's not</span></div><div class="line">                             <span class="comment">// on the border (to have closed holes)</span></div><div class="line">                             <span class="keywordflow">if</span> (!border &amp;&amp; longest_edge &gt; limit)</div><div class="line">                             {</div><div class="line">                               face_selection_map[ff.second] = <span class="keyword">true</span>;</div><div class="line">                               face_selection.push_back (ff.second);</div><div class="line">                             }</div><div class="line">                           })));</div><div class="line"></div><div class="line">  <span class="comment">// Save original DTM</span></div><div class="line">  std::ofstream dtm_ofile (<span class="stringliteral">"dtm.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (dtm_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (dtm_ofile, dtm_mesh);</div><div class="line">  dtm_ofile.close();</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; face_selection.size() &lt;&lt; <span class="stringliteral">" face(s) are selected for removal"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Expand face selection to keep a well formed 2-manifold mesh after removal</span></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLSelectionFct.html#ga6f8d338df28c24bbf93677f24f7bcbbe">CGAL::expand_face_selection_for_removal</a> (face_selection, dtm_mesh, face_selection_map);</div><div class="line">  face_selection.clear();</div><div class="line">  <span class="keywordflow">for</span> (Mesh::Face_index fi : faces(dtm_mesh))</div><div class="line">    <span class="keywordflow">if</span> (face_selection_map[fi])</div><div class="line">      face_selection.push_back(fi);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; face_selection.size() &lt;&lt; <span class="stringliteral">" face(s) are selected for removal after expansion"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (Mesh::Face_index fi : face_selection)</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLEulerOperations.html#gacfae7ff8e782da55b941e4487e86c738">CGAL::Euler::remove_face</a> (halfedge(fi, dtm_mesh), dtm_mesh);</div><div class="line">  dtm_mesh.collect_garbage();</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (!dtm_mesh.is_valid())</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid mesh!"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save filtered DTM</span></div><div class="line">  std::ofstream dtm_holes_ofile (<span class="stringliteral">"dtm_with_holes.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (dtm_holes_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (dtm_holes_ofile, dtm_mesh);</div><div class="line">  dtm_holes_ofile.close();</div><div class="line"></div><div class="line">  <span class="comment">// Get all holes</span></div><div class="line">  std::vector&lt;Mesh::Halfedge_index&gt; holes;</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PkgPolygonMeshProcessingRef.html#gafa9b682528c5dc2a4821d01193518d14">CGAL::Polygon_mesh_processing::extract_boundary_cycles</a> (dtm_mesh, std::back_inserter (holes));</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; holes.size() &lt;&lt; <span class="stringliteral">" hole(s) identified"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Identify outer hull (hole with maximum size)</span></div><div class="line">  <span class="keywordtype">double</span> max_size = 0.;</div><div class="line">  Mesh::Halfedge_index outer_hull;</div><div class="line">  <span class="keywordflow">for</span> (Mesh::Halfedge_index hi : holes)</div><div class="line">  {</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html">CGAL::Bbox_3</a> hole_bbox;</div><div class="line">    <span class="keywordflow">for</span> (Mesh::Halfedge_index haf : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLIterators.html#ga37229df31508a78eb4acdaf907e637e5">CGAL::halfedges_around_face</a>(hi, dtm_mesh))</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> Point_3&amp; p = dtm_mesh.point(target(haf, dtm_mesh));</div><div class="line">      hole_bbox += p.bbox();</div><div class="line">    }</div><div class="line">    <span class="keywordtype">double</span> size = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">CGAL::squared_distance</a> (Point_2(hole_bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#aab574470a2591f187553ca1166e682e1">xmin</a>(), hole_bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a2088e16a1f0a20e011e5b94c2e9c222a">ymin</a>()),</div><div class="line">                                          Point_2(hole_bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a3f5e323700e1509624a02d151237cc4c">xmax</a>(), hole_bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a9d06f61bd89faa841e011ff53edf745f">ymax</a>()));</div><div class="line">    <span class="keywordflow">if</span> (size &gt; max_size)</div><div class="line">    {</div><div class="line">      max_size = size;</div><div class="line">      outer_hull = hi;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Fill all holes except the bigest (which is the outer hull of the mesh)</span></div><div class="line">  <span class="keywordflow">for</span> (Mesh::Halfedge_index hi : holes)</div><div class="line">    <span class="keywordflow">if</span> (hi != outer_hull)</div><div class="line">      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__hole__filling__grp.html#ga16473e4861b13d1241edee68f596b153">CGAL::Polygon_mesh_processing::triangulate_refine_and_fair_hole</a></div><div class="line">        (dtm_mesh, hi, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Emptyset__iterator.html">CGAL::Emptyset_iterator</a>(), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Emptyset__iterator.html">CGAL::Emptyset_iterator</a>());</div><div class="line"></div><div class="line">  <span class="comment">// Save DTM with holes filled</span></div><div class="line">  std::ofstream dtm_filled_ofile (<span class="stringliteral">"dtm_filled.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (dtm_filled_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (dtm_filled_ofile, dtm_mesh);</div><div class="line">  dtm_filled_ofile.close();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__meshing__grp.html#gaa5cc92275df27f0baab2472ecbc4ea3f">CGAL::Polygon_mesh_processing::isotropic_remeshing</a> (faces(dtm_mesh), spacing, dtm_mesh);</div><div class="line"></div><div class="line">  std::ofstream dtm_remeshed_ofile (<span class="stringliteral">"dtm_remeshed.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (dtm_remeshed_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (dtm_remeshed_ofile, dtm_mesh);</div><div class="line">  dtm_remeshed_ofile.close();</div><div class="line"></div><div class="line"></div><div class="line">  TIN dtm_clean (dtm_mesh.points().begin(), dtm_mesh.points().end());</div><div class="line"></div><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html">CGAL::Bbox_3</a> bbox = CGAL::bbox_3 (points.points().begin(), points.points().end());</div><div class="line"></div><div class="line">  <span class="comment">// Generate raster image 1920-pixels large</span></div><div class="line">  std::size_t width = 1920;</div><div class="line">  std::size_t height = std::size_t((bbox.ymax() - bbox.ymin()) * 1920 / (bbox.xmax() - bbox.xmin()));</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Rastering with resolution "</span> &lt;&lt; width &lt;&lt; <span class="stringliteral">"x"</span> &lt;&lt; height &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Use PPM format (Portable PixMap) for simplicity</span></div><div class="line">  std::ofstream raster_ofile (<span class="stringliteral">"raster.ppm"</span>, std::ios_base::binary);</div><div class="line"></div><div class="line">  <span class="comment">// PPM header</span></div><div class="line">  raster_ofile &lt;&lt; <span class="stringliteral">"P6"</span> &lt;&lt; std::endl <span class="comment">// magic number</span></div><div class="line">               &lt;&lt; width &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; height &lt;&lt; std::endl <span class="comment">// dimensions of the image</span></div><div class="line">               &lt;&lt; 255 &lt;&lt; std::endl; <span class="comment">// maximum color value</span></div><div class="line"></div><div class="line">  <span class="comment">// Use rainbow color ramp output</span></div><div class="line">  Color_ramp color_ramp;</div><div class="line"></div><div class="line">  <span class="comment">// Keeping track of location from one point to its neighbor allows</span></div><div class="line">  <span class="comment">// for fast locate in DT</span></div><div class="line">  TIN::Face_handle location;</div><div class="line"></div><div class="line">  <span class="comment">// Query each pixel of the image</span></div><div class="line">  <span class="keywordflow">for</span> (std::size_t y = 0; y &lt; height; ++ y)</div><div class="line">    <span class="keywordflow">for</span> (std::size_t x = 0; x &lt; width; ++ x)</div><div class="line">    {</div><div class="line">      Point_3 query (bbox.xmin() + x * (bbox.xmax() - bbox.xmin()) / <span class="keywordtype">double</span>(width),</div><div class="line">                     bbox.ymin() + (height-y) * (bbox.ymax() - bbox.ymin()) / <span class="keywordtype">double</span>(height),</div><div class="line">                     0); <span class="comment">// not relevant for location in 2D</span></div><div class="line"></div><div class="line">      location = dtm_clean.locate (query, location);</div><div class="line"></div><div class="line">      <span class="comment">// Points outside the convex hull will be colored black</span></div><div class="line">      std::array&lt;unsigned char, 3&gt; colors { 0, 0, 0 };</div><div class="line">      <span class="keywordflow">if</span> (!dtm_clean.is_infinite(location))</div><div class="line">      {</div><div class="line">        std::array&lt;double, 3&gt; barycentric_coordinates</div><div class="line">          = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#gadd9f94997d1963426d38305192345564">CGAL::Polygon_mesh_processing::barycentric_coordinates</a></div><div class="line">          (Point_2 (location-&gt;vertex(0)-&gt;point().x(), location-&gt;vertex(0)-&gt;point().y()),</div><div class="line">           Point_2 (location-&gt;vertex(1)-&gt;point().x(), location-&gt;vertex(1)-&gt;point().y()),</div><div class="line">           Point_2 (location-&gt;vertex(2)-&gt;point().x(), location-&gt;vertex(2)-&gt;point().y()),</div><div class="line">           Point_2 (query.x(), query.y()),</div><div class="line">           Kernel());</div><div class="line"></div><div class="line">        <span class="keywordtype">double</span> height_at_query</div><div class="line">          = (barycentric_coordinates[0] * location-&gt;vertex(0)-&gt;point().z()</div><div class="line">             + barycentric_coordinates[1] * location-&gt;vertex(1)-&gt;point().z()</div><div class="line">             + barycentric_coordinates[2] * location-&gt;vertex(2)-&gt;point().z());</div><div class="line"></div><div class="line">        <span class="comment">// Color ramp generates a color depending on a value from 0 to 1</span></div><div class="line">        <span class="keywordtype">double</span> height_ratio = (height_at_query - bbox.zmin()) / (bbox.zmax() - bbox.zmin());</div><div class="line">        colors = color_ramp.get(height_ratio);</div><div class="line">      }</div><div class="line">      raster_ofile.write (reinterpret_cast&lt;char*&gt;(&amp;colors), 3);</div><div class="line">    }</div><div class="line"></div><div class="line">  raster_ofile.close();</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Smooth heights with 5 successive Gaussian filters</span></div><div class="line">  <span class="keywordtype">double</span> gaussian_variance = 4 * spacing * spacing;</div><div class="line">  <span class="keywordflow">for</span> (TIN::Vertex_handle vh : dtm_clean.finite_vertex_handles())</div><div class="line">  {</div><div class="line">    <span class="keywordtype">double</span> z = vh-&gt;point().z();</div><div class="line">    <span class="keywordtype">double</span> total_weight = 1;</div><div class="line"></div><div class="line">    TIN::Vertex_circulator circ = dtm_clean.incident_vertices (vh),</div><div class="line">      start = circ;</div><div class="line"></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (!dtm_clean.is_infinite(circ))</div><div class="line">      {</div><div class="line">        <span class="keywordtype">double</span> sq_dist = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">CGAL::squared_distance</a> (vh-&gt;point(), circ-&gt;point());</div><div class="line"></div><div class="line">        <span class="keywordtype">double</span> weight = std::exp(- sq_dist / gaussian_variance);</div><div class="line">        z += weight * circ-&gt;point().z();</div><div class="line">        total_weight += weight;</div><div class="line">      }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">while</span> (++ circ != start);</div><div class="line"></div><div class="line">    z /= total_weight;</div><div class="line"></div><div class="line">    vh-&gt;point() = Point_3 (vh-&gt;point().x(), vh-&gt;point().y(), z);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  std::array&lt;double, 50&gt; isovalues; <span class="comment">// Contour 50 isovalues</span></div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; isovalues.size(); ++ i)</div><div class="line">    isovalues[i] = bbox.zmin() + ((i+1) * (bbox.zmax() - bbox.zmin()) / (isovalues.size() - 2));</div><div class="line"></div><div class="line">  <span class="comment">// First find on each face if they are crossed by some isovalues and</span></div><div class="line">  <span class="comment">// extract segments in a graph</span></div><div class="line">  <span class="keyword">using</span> Segment_graph = boost::adjacency_list&lt;boost::listS, boost::vecS, boost::undirectedS, Point_3&gt;;</div><div class="line">  Segment_graph graph;</div><div class="line">  <span class="keyword">using</span> Map_p2v = std::map&lt;Point_3, Segment_graph::vertex_descriptor&gt;;</div><div class="line">  Map_p2v map_p2v;</div><div class="line">  <span class="keywordflow">for</span> (TIN::Face_handle vh : dtm_clean.finite_face_handles())</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">double</span> iv : isovalues)</div><div class="line">      <span class="keywordflow">if</span> (face_has_isovalue (vh, iv))</div><div class="line">      {</div><div class="line">        Segment_3 segment = isocontour_in_face (vh, iv);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> Point_3&amp; p : { segment.source(), segment.target() })</div><div class="line">        {</div><div class="line">          <span class="comment">// Only insert end points of segments once to get a well connected graph</span></div><div class="line">          Map_p2v::iterator iter;</div><div class="line">          <span class="keywordtype">bool</span> inserted;</div><div class="line">          std::tie (iter, inserted) = map_p2v.insert (std::make_pair (p, Segment_graph::vertex_descriptor()));</div><div class="line">          <span class="keywordflow">if</span> (inserted)</div><div class="line">          {</div><div class="line">            iter-&gt;second = boost::add_vertex (graph);</div><div class="line">            graph[iter-&gt;second] = p;</div><div class="line">          }</div><div class="line">        }</div><div class="line">        <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLEulerOperations.html#ga4661f850bc60686efeae2fc9d2ec3e65">boost::add_edge</a> (map_p2v[segment.source()], map_p2v[segment.target()], graph);</div><div class="line">      }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Split segments into polylines</span></div><div class="line">  std::vector&lt;std::vector&lt;Point_3&gt; &gt; polylines;</div><div class="line">  Polylines_visitor&lt;Segment_graph&gt; visitor (graph, polylines);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLPartition.html#ga99ea6bf193f1194db5e523e713c82fb9">CGAL::split_graph_into_polylines</a> (graph, visitor);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; polylines.size() &lt;&lt; <span class="stringliteral">" polylines computed, with "</span></div><div class="line">            &lt;&lt; map_p2v.size() &lt;&lt; <span class="stringliteral">" vertices in total"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Output to WKT file</span></div><div class="line">  std::ofstream contour_ofile (<span class="stringliteral">"contour.wkt"</span>);</div><div class="line">  contour_ofile.precision(18);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsWKT.html#ga013d6cd500473657f41c44c9df43c511">CGAL::IO::write_multi_linestring_WKT</a> (contour_ofile, polylines);</div><div class="line">  contour_ofile.close();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Construct constrained Delaunay triangulation with polylines as constraints</span></div><div class="line">  CTP ctp;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> std::vector&lt;Point_3&gt;&amp; poly : polylines)</div><div class="line">    ctp.insert_constraint (poly.begin(), poly.end());</div><div class="line"></div><div class="line">  <span class="comment">// Simplification algorithm with limit on distance</span></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga5339b0f11fdc9babbc5ca0b33f4a982c">PS::simplify</a> (ctp, PS::Squared_distance_cost(), PS::Stop_above_cost_threshold (16 * spacing * spacing));</div><div class="line"></div><div class="line">  polylines.clear();</div><div class="line">  <span class="keywordflow">for</span> (CTP::Constraint_id cid : ctp.constraints())</div><div class="line">  {</div><div class="line">    polylines.push_back (std::vector&lt;Point_3&gt;());</div><div class="line">    polylines.back().reserve (ctp.vertices_in_constraint (cid).size());</div><div class="line">    <span class="keywordflow">for</span> (CTP::Vertex_handle vh : ctp.vertices_in_constraint(cid))</div><div class="line">      polylines.back().push_back (vh-&gt;point());</div><div class="line">  }</div><div class="line"></div><div class="line">  std::size_t nb_vertices</div><div class="line">    = std::accumulate (polylines.begin(), polylines.end(), std::size_t(0),</div><div class="line">                       [](std::size_t size, <span class="keyword">const</span> std::vector&lt;Point_3&gt;&amp; poly) -&gt; std::size_t</div><div class="line">                       { <span class="keywordflow">return</span> size + poly.size(); });</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; nb_vertices</div><div class="line">            &lt;&lt; <span class="stringliteral">" vertices remaining after simplification ("</span></div><div class="line">            &lt;&lt; 100. * (nb_vertices / double(map_p2v.size())) &lt;&lt; <span class="stringliteral">"%)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Output to WKT file</span></div><div class="line">  std::ofstream simplified_ofile (<span class="stringliteral">"simplified.wkt"</span>);</div><div class="line">  simplified_ofile.precision(18);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsWKT.html#ga013d6cd500473657f41c44c9df43c511">CGAL::IO::write_multi_linestring_WKT</a> (simplified_ofile, polylines);</div><div class="line">  simplified_ofile.close();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Get training from input</span></div><div class="line">  Point_set::Property_map&lt;int&gt; training_map;</div><div class="line">  <span class="keywordtype">bool</span> training_found;</div><div class="line">  std::tie (training_map, training_found) = points.property_map&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">"training"</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (training_found)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Classifying ground/vegetation/building"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// Create labels</span></div><div class="line">    Classification::Label_set labels ({ <span class="stringliteral">"ground"</span>, <span class="stringliteral">"vegetation"</span>, <span class="stringliteral">"building"</span> });</div><div class="line"></div><div class="line">    <span class="comment">// Generate features</span></div><div class="line">    Classification::Feature_set <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Mesh_3.tag:../Mesh_3/" href="../Mesh_3/group__PkgMesh3Parameters.html#ga0a990b28d55157c62d4bfd2624d408af">features</a>;</div><div class="line">    Classification::Point_set_feature_generator&lt;Kernel, Point_set, Point_set::Point_map&gt;</div><div class="line">      generator (points, points.point_map(), 5); <span class="comment">// 5 scales</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef CGAL_LINKED_WITH_TBB</span></div><div class="line">    <span class="comment">// If TBB is used, features can be computed in parallel</span></div><div class="line">    features.begin_parallel_additions();</div><div class="line">    generator.generate_point_based_features (features);</div><div class="line">    features.end_parallel_additions();</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    generator.generate_point_based_features (features);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">    <span class="comment">// Train a random forest classifier</span></div><div class="line">    Classification::ETHZ::Random_forest_classifier classifier (labels, features);</div><div class="line">    classifier.train (points.range(training_map));</div><div class="line"></div><div class="line">    <span class="comment">// Classify with graphcut regularization</span></div><div class="line">    Point_set::Property_map&lt;int&gt; label_map = points.add_property_map&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">"labels"</span>).first;</div><div class="line">    Classification::classify_with_graphcut&lt;Concurrency_tag&gt;</div><div class="line">      (points, points.point_map(), labels, classifier,</div><div class="line">       generator.neighborhood().k_neighbor_query(12), <span class="comment">// regularize on 12-neighbors graph</span></div><div class="line">       0.5f, <span class="comment">// graphcut weight</span></div><div class="line">       12, <span class="comment">// Subdivide to speed-up process</span></div><div class="line">       label_map);</div><div class="line"></div><div class="line">    <span class="comment">// Evaluate</span></div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Mean IoU on training data = "</span></div><div class="line">              &lt;&lt; Classification::Evaluation(labels,</div><div class="line">                                            points.range(training_map),</div><div class="line">                                            points.range(label_map)).mean_intersection_over_union() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// Save the classified point set</span></div><div class="line">    std::ofstream classified_ofile (<span class="stringliteral">"classified.ply"</span>);</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (classified_ofile);</div><div class="line">    classified_ofile &lt;&lt; points;</div><div class="line">    classified_ofile.close();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="TutorialGIS_Reference"></a>
References</h1>
<p>This tutorial is based on the following CGAL packages:</p>
<ul>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/group__PkgTriangulation2Ref.html">2D Triangulations Reference</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/group__PkgPointSet3Ref.html">3D Point Set Reference</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Ref.html">Point Set Processing Reference</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurface__mesh.html">Surface Mesh Reference</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLRef.html">CGAL and the Boost Graph Library Reference</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PkgPolygonMeshProcessingRef.html">Polygon Mesh Processing Reference</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polyline_simplification_2.tag:../Polyline_simplification_2/" href="../Polyline_simplification_2/group__PkgPolylineSimplification2Ref.html">2D Polyline Simplification Reference</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Classification.tag:../Classification/" href="../Classification/group__PkgClassificationRef.html">Classification Reference</a></li>
</ul>
<p>The data set used throughout this tutorial comes from the <a href="https://www.usgs.gov/">https://www.usgs.gov/</a> database, licensed under the <em>US Government Public Domain</em>. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jul 4 2022 13:24:47 for CGAL 5.6 - Manual by
    <a href="https://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>
</html><html xmlns="http://www.w3.org/1999/xhtml"><body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
          <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
          <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt="" /></a>
          </span>
        </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.6 - Manual
   </div>
  </td>
  <!-- We disable the search box because we have added it in the
  back-nav for stylistic reasons. -->
  <!-- <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td> -->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tuto_gis.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">GIS (Geographic Information System) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> </p><div id="autotoc" class="toc"></div> 
<dl class="section author"><dt>Author</dt><dd>Simon Giraudot</dd></dl>
<p>Many sensors used in GIS applications (for example LIDAR), generate dense point clouds. Such applications often take advantage of more advanced data structures: for example, Triangulated Irregular Networks (TIN) that can be the base for Digital Evelation Models (DEM) and in particular for the generation of Digital Terrain Models (DTM). Point clouds can also be enriched by classification information that segments the points into ground, vegetation and building points (or other user-defined labels).</p>
<p>The definitions of some data structures may vary according to different sources. We will use the following terms within this tutorial:</p>
<ul>
<li>TIN: <em>Triangulated Irregular Network</em>, a 2D triangulation structure that connects 3D points based on their projections on the horizontal plane.</li>
<li>DSM: <em>Digital Surface Model</em>, a model of the whole scanned surface including buildings and vegetation. We use a TIN to store the DSM.</li>
<li>DTM: <em>Digital Terrain Model</em>, a model of the bare ground surface without objects like buildings or vegetation. We both use a TIN and a raster to store a DTM.</li>
<li>DEM: <em>Digital Elevation Model</em>, a more general term that includes both DSM and DTM.</li>
</ul>
<p>This tutorial illustrates the following scenario. From an input point cloud, we first compute a DSM stored as a TIN. Then, we filter out overly large facets that correspond either to building facades or to vegetation noise. Large components corresponding to the ground are kept. Holes are filled and the obtained DEM is remeshed. A raster DEM and a set of contour polylines are generated from it. Finally, supervised 3-label classification is performed to segment vegetation, building and group points.</p>
<h1><a class="anchor" id="TutorialGIS_TIN"></a>
Triangulated Irregular Network (TIN)</h1>
<p>CGAL provides several triangulation data structures and algorithms. A TIN can be generated by combining the 2D Delaunay triangulation with projection traits: the triangulation structure is computed using the 2D positions of the points along a selected plane (usually, the XY-plane), while the 3D positions of the points are kept for visualization and measurements.</p>
<p>A TIN data structure can thus simply be defined the following way:</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keyword">using</span> Kernel = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div><div class="line"><span class="keyword">using</span> Projection_traits = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Projection__traits__xy__3.html">CGAL::Projection_traits_xy_3&lt;Kernel&gt;</a>;</div><div class="line"><span class="keyword">using</span> Point_2 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>;</div><div class="line"><span class="keyword">using</span> Point_3 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ae82b7f4be77dd5b8819ebe419e4ae753">Kernel::Point_3</a>;</div><div class="line"><span class="keyword">using</span> Segment_3 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#aa43a461b2027ef7d99b776a7b03ef230">Kernel::Segment_3</a>;</div><div class="line"></div><div class="line"><span class="comment">// Triangulated Irregular Network</span></div><div class="line"><span class="keyword">using</span> TIN = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2&lt;Projection_traits&gt;</a>;</div><div class="line"></div></div><!-- fragment --> <h1><a class="anchor" id="TutorialGIS_DSM"></a>
Digital Surface Model (DSM)</h1>
<p>Point clouds in many formats (XYZ, OFF, PLY, LAS) can be easily loaded into a <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3</a></code> structure, using the stream operator. Generating a DSM stored in TIN is then straightforward:</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="comment">// Read points</span></div><div class="line">  std::ifstream ifile (fname, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3&lt;Point_3&gt;</a> points;</div><div class="line">  ifile &gt;&gt; points;</div><div class="line">  std::cerr &lt;&lt; points.size() &lt;&lt; <span class="stringliteral">" point(s) read"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Create DSM</span></div><div class="line">  TIN dsm (points.points().begin(), points.points().end());</div><div class="line"></div></div><!-- fragment --><p> Because the Delaunay triangulation of CGAL is a model of <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/classFaceGraph.html">FaceGraph</a></code>, it is straightforward to convert the generated TIN into a mesh structure such as <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh</a></code> and be saved into whatever formats are supported by such structure:</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="keyword">using</span> Mesh = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point_3&gt;</a>;</div><div class="line"></div><div class="line">  Mesh dsm_mesh;</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#ga2682fb7d5f4ff4eb65607ae4118e31bc">CGAL::copy_face_graph</a> (dsm, dsm_mesh);</div><div class="line">  std::ofstream dsm_ofile (<span class="stringliteral">"dsm.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (dsm_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (dsm_ofile, dsm_mesh);</div><div class="line">  dsm_ofile.close();</div><div class="line"></div></div><!-- fragment --><p> An example of a DSM computed this way on the San Fransisco data set (see <a class="el" href="tuto_gis.html#TutorialGIS_Reference">References</a>) is given in <a class="el" href="tuto_gis.html#fig__TutorialGISFigTIN">Figure 0.1</a>.</p>
<p><a class="anchor" id="fig__TutorialGISFigTIN"></a></p><div class="image">
<img src="tin.jpg" alt="tin.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_gis.html#fig__TutorialGISFigTIN">Figure 0.1</a> Input point cloud and output DSM.  </div> <br /> 
<h1><a class="anchor" id="TutorialGIS_DTM"></a>
Digital Terrain Model (DTM)</h1>
<p>The generated DSM is used as a base for DTM computation, that is a representation of the ground as another TIN after filtering non-ground points.</p>
<p>We propose, as an example, a simple DTM estimation decomposed in the following steps:</p>
<ol type="1">
<li>Thresholding the height of the facets to remove brutal changes of elevation</li>
<li>Clustering the other facets into connected components</li>
<li>Filtering all components smaller than a user-defined threshold</li>
</ol>
<p>This algorithm relies on 2 parameters: a height threshold that corresponds to the minimum height of a building, and a perimeter threshold that corresponds to the maximum size of a building on the 2D projection.</p>
<h2><a class="anchor" id="TutorialGIS_DTM_info"></a>
TIN With Info</h2>
<p>Because it takes advantage of the flexible CGAL Delaunay triangulation API, our TIN can be enriched with information on vertices and/or on faces. In our case, each vertex keeps track of the index of the corresponding point in the input point cloud (which will allow to filter ground points afterwards), and each face is given the index of its connected component.</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="keyword">auto</span> idx_to_point_with_info</div><div class="line">    = [&amp;](<span class="keyword">const</span> Point_set::Index&amp; idx) -&gt; std::pair&lt;Point_3, Point_set::Index&gt;</div><div class="line">      {</div><div class="line">        <span class="keywordflow">return</span> std::make_pair (points.point(idx), idx);</div><div class="line">      };</div><div class="line"></div><div class="line">  TIN_with_info tin_with_info</div><div class="line">    (boost::make_transform_iterator (points.begin(), idx_to_point_with_info),</div><div class="line">     boost::make_transform_iterator (points.end(), idx_to_point_with_info));</div><div class="line"></div></div><!-- fragment --> <h2><a class="anchor" id="TutorialGIS_DTM_components"></a>
Identifying Connected Components</h2>
<p>Connected components are identified through a flooding algorithm: from a seed face, all incident faces are inserted in the current connected component unless their heights exceed the user-defined threshold.</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="keywordtype">double</span> spacing = CGAL::compute_average_spacing&lt;Concurrency_tag&gt;(points, 6);</div><div class="line">  spacing *= 2;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> face_height</div><div class="line">    = [&amp;](<span class="keyword">const</span> TIN_with_info::Face_handle fh) -&gt; <span class="keywordtype">double</span></div><div class="line">      {</div><div class="line">        <span class="keywordtype">double</span> out = 0.;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++ i)</div><div class="line">          out = (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/group__nt__util.html#gad7dbfa919e255b52f36ea1512a92cb78">std::max</a>) (out, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">CGAL::abs</a>(fh-&gt;vertex(i)-&gt;point().z() - fh-&gt;vertex((i+1)%3)-&gt;point().z()));</div><div class="line">        <span class="keywordflow">return</span> out;</div><div class="line">      };</div><div class="line"></div><div class="line">  <span class="comment">// Initialize faces info</span></div><div class="line">  <span class="keywordflow">for</span> (TIN_with_info::Face_handle fh : tin_with_info.all_face_handles())</div><div class="line">    <span class="keywordflow">if</span> (tin_with_info.is_infinite(fh) || face_height(fh) &gt; spacing) <span class="comment">// Filtered faces are given info() = -2</span></div><div class="line">      fh-&gt;info() = -2;</div><div class="line">    <span class="keywordflow">else</span> <span class="comment">// Pending faces are given info() = -1;</span></div><div class="line">      fh-&gt;info() = -1;</div><div class="line"></div><div class="line">  <span class="comment">// Flooding algorithm</span></div><div class="line">  std::vector&lt;int&gt; component_size;</div><div class="line">  <span class="keywordflow">for</span> (TIN_with_info::Face_handle fh : tin_with_info.finite_face_handles())</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (fh-&gt;info() != -1)</div><div class="line">      <span class="keywordflow">continue</span>;</div><div class="line"></div><div class="line">    std::queue&lt;TIN_with_info::Face_handle&gt; todo;</div><div class="line">    todo.push(fh);</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> size = 0;</div><div class="line">    <span class="keywordflow">while</span> (!todo.empty())</div><div class="line">    {</div><div class="line">      TIN_with_info::Face_handle current = todo.front();</div><div class="line">      todo.pop();</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (current-&gt;info() != -1)</div><div class="line">        <span class="keywordflow">continue</span>;</div><div class="line">      current-&gt;info() = int(component_size.size());</div><div class="line">      ++ size;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++ i)</div><div class="line">        todo.push (current-&gt;neighbor(i));</div><div class="line">    }</div><div class="line"></div><div class="line">    component_size.push_back (size);</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; component_size.size() &lt;&lt; <span class="stringliteral">" connected component(s) found"</span> &lt;&lt; std::endl;</div><div class="line"></div></div><!-- fragment --><p> This TIN enriched with connected component information can be saved as a colored mesh:</p>
<div class="fragment"><div class="line"></div><div class="line">  Mesh tin_colored_mesh;</div><div class="line"></div><div class="line">  Mesh::Property_map&lt;Mesh::Face_index, CGAL::IO::Color&gt;</div><div class="line">    color_map = tin_colored_mesh.add_property_map&lt;Mesh::Face_index, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a>&gt;(<span class="stringliteral">"f:color"</span>).first;</div><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#ga2682fb7d5f4ff4eb65607ae4118e31bc">CGAL::copy_face_graph</a> (tin_with_info, tin_colored_mesh,</div><div class="line">                         CGAL::parameters::face_to_face_output_iterator</div><div class="line">                         (boost::make_function_output_iterator</div><div class="line">                          ([&amp;](<span class="keyword">const</span> std::pair&lt;TIN_with_info::Face_handle, Mesh::Face_index&gt;&amp; ff)</div><div class="line">                           {</div><div class="line">                             <span class="comment">// Color unassigned faces gray</span></div><div class="line">                             <span class="keywordflow">if</span> (ff.first-&gt;info() &lt; 0)</div><div class="line">                               color_map[ff.second] = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a>(128, 128, 128);</div><div class="line">                             <span class="keywordflow">else</span></div><div class="line">                             {</div><div class="line">                               <span class="comment">// Random color seeded by the component ID</span></div><div class="line">                               <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Generator.tag:../Generator/" href="../Generator/classCGAL_1_1Random.html">CGAL::Random</a> r (ff.first-&gt;info());</div><div class="line">                               color_map[ff.second] = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a> (r.get_int(64, 192),</div><div class="line">                                                                   r.get_int(64, 192),</div><div class="line">                                                                   r.get_int(64, 192));</div><div class="line">                             }</div><div class="line">                           })));</div><div class="line"></div><div class="line">  std::ofstream tin_colored_ofile (<span class="stringliteral">"colored_tin.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (tin_colored_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (tin_colored_ofile, tin_colored_mesh);</div><div class="line">  tin_colored_ofile.close();</div><div class="line"></div></div><!-- fragment --><p> An example of a TIN colored by connected components is given in <a class="el" href="tuto_gis.html#fig__TutorialGISFigComponents">Figure 0.2</a>.</p>
<p><a class="anchor" id="fig__TutorialGISFigComponents"></a></p><div class="image">
<img src="components.jpg" alt="components.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_gis.html#fig__TutorialGISFigComponents">Figure 0.2</a> TIN colored by connected components. Faces above height threshold are not assigned to any component and are displayed in gray.  </div> <br /> 
<h2><a class="anchor" id="TutorialGIS_DTM_filtering"></a>
Filtering</h2>
<p>Components smaller than the largest building can be removed this way:</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="keywordtype">int</span> min_size = int(points.size() / 2);</div><div class="line"></div><div class="line">  std::vector&lt;TIN_with_info::Vertex_handle&gt; to_remove;</div><div class="line">  <span class="keywordflow">for</span> (TIN_with_info::Vertex_handle vh : tin_with_info.finite_vertex_handles())</div><div class="line">  {</div><div class="line">    TIN_with_info::Face_circulator circ = tin_with_info.incident_faces (vh),</div><div class="line">      start = circ;</div><div class="line"></div><div class="line">    <span class="comment">// Remove a vertex if it's only adjacent to components smaller than threshold</span></div><div class="line">    <span class="keywordtype">bool</span> keep = <span class="keyword">false</span>;</div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (circ-&gt;info() &gt;= 0 &amp;&amp; component_size[std::size_t(circ-&gt;info())] &gt; min_size)</div><div class="line">      {</div><div class="line">        keep = <span class="keyword">true</span>;</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">while</span> (++ circ != start);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (!keep)</div><div class="line">      to_remove.push_back (vh);</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; to_remove.size() &lt;&lt; <span class="stringliteral">" vertices(s) will be removed after filtering"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (TIN_with_info::Vertex_handle vh : to_remove)</div><div class="line">    tin_with_info.remove (vh);</div><div class="line"></div></div><!-- fragment --> <h2><a class="anchor" id="Tutorial_DTM_hole_filling"></a>
Hole Filling and Remeshing</h2>
<p>Because simply removing vertices in the large areas covered by buildings results in large Delaunay faces that offer a poor 3D representation of the DTM, an additional step can help producing better shaped meshes: faces larger than a threshold are removed and filled with a hole filling algorithm that triangulates, refines and fairs the holes.</p>
<p>The following snippet copies the TIN into a mesh while filtering out overly large faces, then identifies the holes and fills them all except for the largest one (which is the outer hull).</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="comment">// Copy and keep track of overly large faces</span></div><div class="line">  Mesh dtm_mesh;</div><div class="line"></div><div class="line">  std::vector&lt;Mesh::Face_index&gt; face_selection;</div><div class="line">  Mesh::Property_map&lt;Mesh::Face_index, bool&gt; face_selection_map</div><div class="line">   = dtm_mesh.add_property_map&lt;Mesh::Face_index, <span class="keywordtype">bool</span>&gt;(<span class="stringliteral">"is_selected"</span>, <span class="keyword">false</span>).first;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> limit = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga07001b5ddc5c43096c811c91a306be9a">CGAL::square</a> (5 * spacing);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#ga2682fb7d5f4ff4eb65607ae4118e31bc">CGAL::copy_face_graph</a> (tin_with_info, dtm_mesh,</div><div class="line">                         CGAL::parameters::face_to_face_output_iterator</div><div class="line">                         (boost::make_function_output_iterator</div><div class="line">                          ([&amp;](<span class="keyword">const</span> std::pair&lt;TIN_with_info::Face_handle, Mesh::Face_index&gt;&amp; ff)</div><div class="line">                           {</div><div class="line">                             <span class="keywordtype">double</span> longest_edge = 0.;</div><div class="line">                             <span class="keywordtype">bool</span> border = <span class="keyword">false</span>;</div><div class="line">                             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++ i)</div><div class="line">                             {</div><div class="line">                               longest_edge = (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/group__nt__util.html#gad7dbfa919e255b52f36ea1512a92cb78">std::max</a>)(longest_edge, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">CGAL::squared_distance</a></div><div class="line">                                                         (ff.first-&gt;vertex((i+1)%3)-&gt;point(),</div><div class="line">                                                          ff.first-&gt;vertex((i+2)%3)-&gt;point()));</div><div class="line"></div><div class="line">                               TIN_with_info::Face_circulator circ</div><div class="line">                                 = tin_with_info.incident_faces (ff.first-&gt;vertex(i)),</div><div class="line">                                 start = circ;</div><div class="line">                               <span class="keywordflow">do</span></div><div class="line">                               {</div><div class="line">                                 <span class="keywordflow">if</span> (tin_with_info.is_infinite (circ))</div><div class="line">                                 {</div><div class="line">                                   border = <span class="keyword">true</span>;</div><div class="line">                                   <span class="keywordflow">break</span>;</div><div class="line">                                 }</div><div class="line">                               }</div><div class="line">                               <span class="keywordflow">while</span> (++ circ != start);</div><div class="line"></div><div class="line">                               <span class="keywordflow">if</span> (border)</div><div class="line">                                 <span class="keywordflow">break</span>;</div><div class="line">                             }</div><div class="line"></div><div class="line">                             <span class="comment">// Select if face is too big AND it's not</span></div><div class="line">                             <span class="comment">// on the border (to have closed holes)</span></div><div class="line">                             <span class="keywordflow">if</span> (!border &amp;&amp; longest_edge &gt; limit)</div><div class="line">                             {</div><div class="line">                               face_selection_map[ff.second] = <span class="keyword">true</span>;</div><div class="line">                               face_selection.push_back (ff.second);</div><div class="line">                             }</div><div class="line">                           })));</div><div class="line"></div><div class="line">  <span class="comment">// Save original DTM</span></div><div class="line">  std::ofstream dtm_ofile (<span class="stringliteral">"dtm.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (dtm_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (dtm_ofile, dtm_mesh);</div><div class="line">  dtm_ofile.close();</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; face_selection.size() &lt;&lt; <span class="stringliteral">" face(s) are selected for removal"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Expand face selection to keep a well formed 2-manifold mesh after removal</span></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLSelectionFct.html#ga6f8d338df28c24bbf93677f24f7bcbbe">CGAL::expand_face_selection_for_removal</a> (face_selection, dtm_mesh, face_selection_map);</div><div class="line">  face_selection.clear();</div><div class="line">  <span class="keywordflow">for</span> (Mesh::Face_index fi : faces(dtm_mesh))</div><div class="line">    <span class="keywordflow">if</span> (face_selection_map[fi])</div><div class="line">      face_selection.push_back(fi);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; face_selection.size() &lt;&lt; <span class="stringliteral">" face(s) are selected for removal after expansion"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (Mesh::Face_index fi : face_selection)</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLEulerOperations.html#gacfae7ff8e782da55b941e4487e86c738">CGAL::Euler::remove_face</a> (halfedge(fi, dtm_mesh), dtm_mesh);</div><div class="line">  dtm_mesh.collect_garbage();</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (!dtm_mesh.is_valid())</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid mesh!"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save filtered DTM</span></div><div class="line">  std::ofstream dtm_holes_ofile (<span class="stringliteral">"dtm_with_holes.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (dtm_holes_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (dtm_holes_ofile, dtm_mesh);</div><div class="line">  dtm_holes_ofile.close();</div><div class="line"></div><div class="line">  <span class="comment">// Get all holes</span></div><div class="line">  std::vector&lt;Mesh::Halfedge_index&gt; holes;</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PkgPolygonMeshProcessingRef.html#gafa9b682528c5dc2a4821d01193518d14">CGAL::Polygon_mesh_processing::extract_boundary_cycles</a> (dtm_mesh, std::back_inserter (holes));</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; holes.size() &lt;&lt; <span class="stringliteral">" hole(s) identified"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Identify outer hull (hole with maximum size)</span></div><div class="line">  <span class="keywordtype">double</span> max_size = 0.;</div><div class="line">  Mesh::Halfedge_index outer_hull;</div><div class="line">  <span class="keywordflow">for</span> (Mesh::Halfedge_index hi : holes)</div><div class="line">  {</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html">CGAL::Bbox_3</a> hole_bbox;</div><div class="line">    <span class="keywordflow">for</span> (Mesh::Halfedge_index haf : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLIterators.html#ga37229df31508a78eb4acdaf907e637e5">CGAL::halfedges_around_face</a>(hi, dtm_mesh))</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> Point_3&amp; p = dtm_mesh.point(target(haf, dtm_mesh));</div><div class="line">      hole_bbox += p.bbox();</div><div class="line">    }</div><div class="line">    <span class="keywordtype">double</span> size = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">CGAL::squared_distance</a> (Point_2(hole_bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#aab574470a2591f187553ca1166e682e1">xmin</a>(), hole_bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a2088e16a1f0a20e011e5b94c2e9c222a">ymin</a>()),</div><div class="line">                                          Point_2(hole_bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a3f5e323700e1509624a02d151237cc4c">xmax</a>(), hole_bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a9d06f61bd89faa841e011ff53edf745f">ymax</a>()));</div><div class="line">    <span class="keywordflow">if</span> (size &gt; max_size)</div><div class="line">    {</div><div class="line">      max_size = size;</div><div class="line">      outer_hull = hi;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Fill all holes except the bigest (which is the outer hull of the mesh)</span></div><div class="line">  <span class="keywordflow">for</span> (Mesh::Halfedge_index hi : holes)</div><div class="line">    <span class="keywordflow">if</span> (hi != outer_hull)</div><div class="line">      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__hole__filling__grp.html#ga16473e4861b13d1241edee68f596b153">CGAL::Polygon_mesh_processing::triangulate_refine_and_fair_hole</a></div><div class="line">        (dtm_mesh, hi, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Emptyset__iterator.html">CGAL::Emptyset_iterator</a>(), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Emptyset__iterator.html">CGAL::Emptyset_iterator</a>());</div><div class="line"></div><div class="line">  <span class="comment">// Save DTM with holes filled</span></div><div class="line">  std::ofstream dtm_filled_ofile (<span class="stringliteral">"dtm_filled.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (dtm_filled_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (dtm_filled_ofile, dtm_mesh);</div><div class="line">  dtm_filled_ofile.close();</div><div class="line"></div></div><!-- fragment --><p> Isotropic remeshing can also be performed as a final step in order to produce a more regular mesh that is not constrained by the shape of 2D Delaunay faces.</p>
<div class="fragment"><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__meshing__grp.html#gaa5cc92275df27f0baab2472ecbc4ea3f">CGAL::Polygon_mesh_processing::isotropic_remeshing</a> (faces(dtm_mesh), spacing, dtm_mesh);</div><div class="line"></div><div class="line">  std::ofstream dtm_remeshed_ofile (<span class="stringliteral">"dtm_remeshed.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (dtm_remeshed_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (dtm_remeshed_ofile, dtm_mesh);</div><div class="line">  dtm_remeshed_ofile.close();</div><div class="line"></div></div><!-- fragment --><p> <a class="el" href="tuto_gis.html#fig__TutorialGISFigProc">Figure 0.3</a> shows how these different steps affect the output mesh and <a class="el" href="tuto_gis.html#fig__TutorialGISFigDTM">Figure 0.4</a> shows the DTM isotropic mesh.</p>
<p><a class="anchor" id="fig__TutorialGISFigProc"></a></p><div class="image">
<img src="dtm_proc.jpg" alt="dtm_proc.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_gis.html#fig__TutorialGISFigProc">Figure 0.3</a> Raw DTM and postprocessing  </div> <br /> 
<p><a class="anchor" id="fig__TutorialGISFigDTM"></a></p><div class="image">
<img src="dtm.jpg" alt="dtm.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_gis.html#fig__TutorialGISFigDTM">Figure 0.4</a> Final DTM.  </div> <br /> 
<h1><a class="anchor" id="TutorialGIS_Raster"></a>
Rastering</h1>
<p>The TIN data structure can be combined with barycentric coordinates in order to interpolate and thus rasterize a height map at any resolution needed the information embedded in the vertices.</p>
<p>Because the latest two steps (hole filling and remeshing) were performed on a 3D mesh, the hypothesis that our DTM is a 2.5D representation may no longer be valid. We thus first rebuild a TIN using the vertices of the isotropic DTM mesh lastly computed.</p>
<p>The following snippet generates a raster image of the height in the form of rainbow ramp PPM file (simple bitmap format):</p>
<div class="fragment"><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html">CGAL::Bbox_3</a> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PkgPolygonMeshProcessingRef.html#gaf633ec6397f5f065b01462fe42235d56">bbox</a> = CGAL::bbox_3 (points.points().begin(), points.points().end());</div><div class="line"></div><div class="line">  <span class="comment">// Generate raster image 1920-pixels large</span></div><div class="line">  std::size_t width = 1920;</div><div class="line">  std::size_t height = std::size_t((bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a9d06f61bd89faa841e011ff53edf745f">ymax</a>() - bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a2088e16a1f0a20e011e5b94c2e9c222a">ymin</a>()) * 1920 / (bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a3f5e323700e1509624a02d151237cc4c">xmax</a>() - bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#aab574470a2591f187553ca1166e682e1">xmin</a>()));</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Rastering with resolution "</span> &lt;&lt; width &lt;&lt; <span class="stringliteral">"x"</span> &lt;&lt; height &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Use PPM format (Portable PixMap) for simplicity</span></div><div class="line">  std::ofstream raster_ofile (<span class="stringliteral">"raster.ppm"</span>, std::ios_base::binary);</div><div class="line"></div><div class="line">  <span class="comment">// PPM header</span></div><div class="line">  raster_ofile &lt;&lt; <span class="stringliteral">"P6"</span> &lt;&lt; std::endl <span class="comment">// magic number</span></div><div class="line">               &lt;&lt; width &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; height &lt;&lt; std::endl <span class="comment">// dimensions of the image</span></div><div class="line">               &lt;&lt; 255 &lt;&lt; std::endl; <span class="comment">// maximum color value</span></div><div class="line"></div><div class="line">  <span class="comment">// Use rainbow color ramp output</span></div><div class="line">  Color_ramp color_ramp;</div><div class="line"></div><div class="line">  <span class="comment">// Keeping track of location from one point to its neighbor allows</span></div><div class="line">  <span class="comment">// for fast locate in DT</span></div><div class="line">  TIN::Face_handle location;</div><div class="line"></div><div class="line">  <span class="comment">// Query each pixel of the image</span></div><div class="line">  <span class="keywordflow">for</span> (std::size_t y = 0; y &lt; height; ++ y)</div><div class="line">    <span class="keywordflow">for</span> (std::size_t x = 0; x &lt; width; ++ x)</div><div class="line">    {</div><div class="line">      Point_3 query (bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#aab574470a2591f187553ca1166e682e1">xmin</a>() + x * (bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a3f5e323700e1509624a02d151237cc4c">xmax</a>() - bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#aab574470a2591f187553ca1166e682e1">xmin</a>()) / <span class="keywordtype">double</span>(width),</div><div class="line">                     bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a2088e16a1f0a20e011e5b94c2e9c222a">ymin</a>() + (height-y) * (bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a9d06f61bd89faa841e011ff53edf745f">ymax</a>() - bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a2088e16a1f0a20e011e5b94c2e9c222a">ymin</a>()) / <span class="keywordtype">double</span>(height),</div><div class="line">                     0); <span class="comment">// not relevant for location in 2D</span></div><div class="line"></div><div class="line">      location = dtm_clean.locate (query, location);</div><div class="line"></div><div class="line">      <span class="comment">// Points outside the convex hull will be colored black</span></div><div class="line">      std::array&lt;unsigned char, 3&gt; colors { 0, 0, 0 };</div><div class="line">      <span class="keywordflow">if</span> (!dtm_clean.is_infinite(location))</div><div class="line">      {</div><div class="line">        std::array&lt;double, 3&gt; <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#gadd9f94997d1963426d38305192345564">barycentric_coordinates</a></div><div class="line">          = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#gadd9f94997d1963426d38305192345564">CGAL::Polygon_mesh_processing::barycentric_coordinates</a></div><div class="line">          (Point_2 (location-&gt;vertex(0)-&gt;point().x(), location-&gt;vertex(0)-&gt;point().y()),</div><div class="line">           Point_2 (location-&gt;vertex(1)-&gt;point().x(), location-&gt;vertex(1)-&gt;point().y()),</div><div class="line">           Point_2 (location-&gt;vertex(2)-&gt;point().x(), location-&gt;vertex(2)-&gt;point().y()),</div><div class="line">           Point_2 (query.x(), query.y()),</div><div class="line">           Kernel());</div><div class="line"></div><div class="line">        <span class="keywordtype">double</span> height_at_query</div><div class="line">          = (barycentric_coordinates[0] * location-&gt;vertex(0)-&gt;point().z()</div><div class="line">             + barycentric_coordinates[1] * location-&gt;vertex(1)-&gt;point().z()</div><div class="line">             + barycentric_coordinates[2] * location-&gt;vertex(2)-&gt;point().z());</div><div class="line"></div><div class="line">        <span class="comment">// Color ramp generates a color depending on a value from 0 to 1</span></div><div class="line">        <span class="keywordtype">double</span> height_ratio = (height_at_query - bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a6c55430abc7fda54571cf1075c7f2f8b">zmin</a>()) / (bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a98def8b9515f31ded759d781969ddaf6">zmax</a>() - bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a6c55430abc7fda54571cf1075c7f2f8b">zmin</a>());</div><div class="line">        colors = color_ramp.get(height_ratio);</div><div class="line">      }</div><div class="line">      raster_ofile.write (reinterpret_cast&lt;char*&gt;(&amp;colors), 3);</div><div class="line">    }</div><div class="line"></div><div class="line">  raster_ofile.close();</div><div class="line"></div></div><!-- fragment --><p> An example of a raster image with a rainbow ramp representing height is given in <a class="el" href="tuto_gis.html#fig__TutorialGISFigRastering">Figure 0.5</a>.</p>
<p><a class="anchor" id="fig__TutorialGISFigRastering"></a></p><div class="image">
<img src="raster.jpg" alt="raster.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_gis.html#fig__TutorialGISFigRastering">Figure 0.5</a> Raster visualisation of height using a rainbow ramp, ranging from light blue for low values to dark red for high values.  </div> <br /> 
<h1><a class="anchor" id="TutorialGIS_Contour"></a>
Contouring</h1>
<p>Extracting isolevels of a function defined on a TIN is another application that can be done with CGAL. We demonstrate here how to extract isolevels of height to build a topographic map.</p>
<h2><a class="anchor" id="TutorialGIS_Contour_Extraction"></a>
Building a Contour Graph</h2>
<p>The first step is to extract, from all faces of the triangulation, the section of each isolevel that goes through that face, in the form of a segment. The following functions allow to test if one isovalue does cross a face, and to extract it then:</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keywordtype">bool</span> face_has_isovalue (TIN::Face_handle fh, <span class="keywordtype">double</span> isovalue)</div><div class="line">{</div><div class="line">  <span class="keywordtype">bool</span> above = <span class="keyword">false</span>, below = <span class="keyword">false</span>;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++ i)</div><div class="line">  {</div><div class="line">    <span class="comment">// Face has isovalue if one of its vertices is above and another</span></div><div class="line">    <span class="comment">// one below</span></div><div class="line">    <span class="keywordflow">if</span> (fh-&gt;vertex(i)-&gt;point().z() &gt; isovalue)</div><div class="line">      above = <span class="keyword">true</span>;</div><div class="line">    <span class="keywordflow">if</span> (fh-&gt;vertex(i)-&gt;point().z() &lt; isovalue)</div><div class="line">      below = <span class="keyword">true</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> (above &amp;&amp; below);</div><div class="line">}</div><div class="line"></div><div class="line">Segment_3 isocontour_in_face (TIN::Face_handle fh, <span class="keywordtype">double</span> isovalue)</div><div class="line">{</div><div class="line">  Point_3 source;</div><div class="line">  Point_3 target;</div><div class="line">  <span class="keywordtype">bool</span> source_found = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++ i)</div><div class="line">  {</div><div class="line">    Point_3 p0 = fh-&gt;vertex((i+1) % 3)-&gt;point();</div><div class="line">    Point_3 p1 = fh-&gt;vertex((i+2) % 3)-&gt;point();</div><div class="line"></div><div class="line">    <span class="comment">// Check if the isovalue crosses segment (p0,p1)</span></div><div class="line">    <span class="keywordflow">if</span> ((p0.z() - isovalue) * (p1.z() - isovalue) &gt; 0)</div><div class="line">      <span class="keywordflow">continue</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> zbottom = p0.z();</div><div class="line">    <span class="keywordtype">double</span> ztop = p1.z();</div><div class="line">    <span class="keywordflow">if</span> (zbottom &gt; ztop)</div><div class="line">    {</div><div class="line">      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polynomial.tag:../Polynomial/" href="../Polynomial/group__PkgPolynomialFunctions.html#gaa555a2d0a5bf3730c337f08f07356c07">std::swap</a> (zbottom, ztop);</div><div class="line">      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polynomial.tag:../Polynomial/" href="../Polynomial/group__PkgPolynomialFunctions.html#gaa555a2d0a5bf3730c337f08f07356c07">std::swap</a> (p0, p1);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Compute position of segment vertex</span></div><div class="line">    <span class="keywordtype">double</span> ratio = (isovalue - zbottom) / (ztop - zbottom);</div><div class="line">    Point_3 p = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__barycenter__grp.html#ga43dafb654e67589a55dcf5b13092966b">CGAL::barycenter</a> (p0, (1 - ratio), p1,ratio);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (source_found)</div><div class="line">      target = p;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      source = p;</div><div class="line">      source_found = <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> Segment_3 (source, target);</div><div class="line">}</div><div class="line"></div><div class="line"></div></div><!-- fragment --><p> From these functions, we can create a graph of segments to process later into a set of polylines. To do so, we use the <a href="https://www.boost.org/doc/libs/1_72_0/libs/graph/doc/adjacency_list.html">boost::adjacency_list</a> structure and keep track of a mapping from the positions of the end points to the vertices of the graph.</p>
<p>The following code computes 50 isovalues evenly distributed between the minimum and maximum heights of the point cloud and creates a graph containing all isolevels:</p>
<div class="fragment"><div class="line"></div><div class="line">  std::array&lt;double, 50&gt; isovalues; <span class="comment">// Contour 50 isovalues</span></div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; isovalues.size(); ++ i)</div><div class="line">    isovalues[i] = bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a6c55430abc7fda54571cf1075c7f2f8b">zmin</a>() + ((i+1) * (bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a98def8b9515f31ded759d781969ddaf6">zmax</a>() - bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a6c55430abc7fda54571cf1075c7f2f8b">zmin</a>()) / (isovalues.size() - 2));</div><div class="line"></div><div class="line">  <span class="comment">// First find on each face if they are crossed by some isovalues and</span></div><div class="line">  <span class="comment">// extract segments in a graph</span></div><div class="line">  <span class="keyword">using</span> Segment_graph = boost::adjacency_list&lt;boost::listS, boost::vecS, boost::undirectedS, Point_3&gt;;</div><div class="line">  Segment_graph graph;</div><div class="line">  <span class="keyword">using</span> Map_p2v = std::map&lt;Point_3, Segment_graph::vertex_descriptor&gt;;</div><div class="line">  Map_p2v map_p2v;</div><div class="line">  <span class="keywordflow">for</span> (TIN::Face_handle vh : dtm_clean.finite_face_handles())</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">double</span> iv : isovalues)</div><div class="line">      <span class="keywordflow">if</span> (face_has_isovalue (vh, iv))</div><div class="line">      {</div><div class="line">        Segment_3 segment = isocontour_in_face (vh, iv);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> Point_3&amp; p : { segment.source(), segment.target() })</div><div class="line">        {</div><div class="line">          <span class="comment">// Only insert end points of segments once to get a well connected graph</span></div><div class="line">          Map_p2v::iterator iter;</div><div class="line">          <span class="keywordtype">bool</span> inserted;</div><div class="line">          std::tie (iter, inserted) = map_p2v.insert (std::make_pair (p, Segment_graph::vertex_descriptor()));</div><div class="line">          <span class="keywordflow">if</span> (inserted)</div><div class="line">          {</div><div class="line">            iter-&gt;second = boost::add_vertex (graph);</div><div class="line">            graph[iter-&gt;second] = p;</div><div class="line">          }</div><div class="line">        }</div><div class="line">        <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLEulerOperations.html#ga4661f850bc60686efeae2fc9d2ec3e65">boost::add_edge</a> (map_p2v[segment.source()], map_p2v[segment.target()], graph);</div><div class="line">      }</div><div class="line"></div></div><!-- fragment --> <h2><a class="anchor" id="TutorialGIS_Contour_Splitting"></a>
Splitting Into Polylines</h2>
<p>Once the graph is created, splitting it into polylines is easily performed using the function <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLPartition.html#ga99ea6bf193f1194db5e523e713c82fb9"><code>CGAL::split_graph_into_polylines()</code> </a>:</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="comment">// Split segments into polylines</span></div><div class="line">  std::vector&lt;std::vector&lt;Point_3&gt; &gt; polylines;</div><div class="line">  Polylines_visitor&lt;Segment_graph&gt; visitor (graph, polylines);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLPartition.html#ga99ea6bf193f1194db5e523e713c82fb9">CGAL::split_graph_into_polylines</a> (graph, visitor);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; polylines.size() &lt;&lt; <span class="stringliteral">" polylines computed, with "</span></div><div class="line">            &lt;&lt; map_p2v.size() &lt;&lt; <span class="stringliteral">" vertices in total"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Output to WKT file</span></div><div class="line">  std::ofstream contour_ofile (<span class="stringliteral">"contour.wkt"</span>);</div><div class="line">  contour_ofile.precision(18);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsWKT.html#ga013d6cd500473657f41c44c9df43c511">CGAL::IO::write_multi_linestring_WKT</a> (contour_ofile, polylines);</div><div class="line">  contour_ofile.close();</div><div class="line"></div></div><!-- fragment --><p> This function requires a visitor which is called when starting a polyline, when adding a point to it and when ending it. Defining such a class is straightforward in our case:</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph&gt;</div><div class="line"><span class="keyword">class </span>Polylines_visitor</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">  std::vector&lt;std::vector&lt;Point_3&gt; &gt;&amp; polylines;</div><div class="line">  Graph&amp; graph;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">  Polylines_visitor (Graph&amp; graph, std::vector&lt;std::vector&lt;Point_3&gt; &gt;&amp; polylines)</div><div class="line">    : polylines (polylines), graph(graph) { }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> start_new_polyline()</div><div class="line">  {</div><div class="line">    polylines.push_back (std::vector&lt;Point_3&gt;());</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> add_node (<span class="keyword">typename</span> Graph::vertex_descriptor vd)</div><div class="line">  {</div><div class="line">    polylines.back().push_back (graph[vd]);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> end_polyline()</div><div class="line">  {</div><div class="line">    <span class="comment">// filter small polylines</span></div><div class="line">    <span class="keywordflow">if</span> (polylines.back().size() &lt; 50)</div><div class="line">      polylines.pop_back();</div><div class="line">  }</div><div class="line">};</div><div class="line"></div></div><!-- fragment --> <h2><a class="anchor" id="TutorialGIS_Contour_Simplifying"></a>
Simplifying</h2>
<p>Because the output is quite noisy, users may want to simplify the polylines. CGAL provides a polyline simplification algorithm that guarantees that two polylines won't intersect after simplification. This algorithm takes advantage of the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Constrained__triangulation__plus__2.html">CGAL::Constrained_triangulation_plus_2</a></code>, which embeds polylines as a set of constraints:</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keyword">namespace </span>PS = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polyline_simplification_2.tag:../Polyline_simplification_2/" href="../Polyline_simplification_2/namespaceCGAL_1_1Polyline__simplification__2.html">CGAL::Polyline_simplification_2</a>;</div><div class="line"><span class="keyword">using</span> CDT_vertex_base = PS::Vertex_base_2&lt;Projection_traits&gt;;</div><div class="line"><span class="keyword">using</span> CDT_face_base = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Constrained__triangulation__face__base__2.html">CGAL::Constrained_triangulation_face_base_2&lt;Projection_traits&gt;</a>;</div><div class="line"><span class="keyword">using</span> CDT_TDS = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/TDS_2.tag:../TDS_2/" href="../TDS_2/classCGAL_1_1Triangulation__data__structure__2.html">CGAL::Triangulation_data_structure_2&lt;CDT_vertex_base, CDT_face_base&gt;</a>;</div><div class="line"><span class="keyword">using</span> CDT = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Constrained__Delaunay__triangulation__2.html">CGAL::Constrained_Delaunay_triangulation_2&lt;Projection_traits, CDT_TDS&gt;</a>;</div><div class="line"><span class="keyword">using</span> CTP = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Constrained__triangulation__plus__2.html">CGAL::Constrained_triangulation_plus_2&lt;CDT&gt;</a>;</div><div class="line"></div></div><!-- fragment --><p> The following code simplifies the polyline set based on the squared distance to the original polylines, stopping when no more vertex can be removed without going farther than 4 times the average spacing.</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="comment">// Construct constrained Delaunay triangulation with polylines as constraints</span></div><div class="line">  CTP ctp;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> std::vector&lt;Point_3&gt;&amp; poly : polylines)</div><div class="line">    ctp.insert_constraint (poly.begin(), poly.end());</div><div class="line"></div><div class="line">  <span class="comment">// Simplification algorithm with limit on distance</span></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga5339b0f11fdc9babbc5ca0b33f4a982c">PS::simplify</a> (ctp, PS::Squared_distance_cost(), PS::Stop_above_cost_threshold (16 * spacing * spacing));</div><div class="line"></div><div class="line">  polylines.clear();</div><div class="line">  <span class="keywordflow">for</span> (CTP::Constraint_id cid : ctp.constraints())</div><div class="line">  {</div><div class="line">    polylines.push_back (std::vector&lt;Point_3&gt;());</div><div class="line">    polylines.back().reserve (ctp.vertices_in_constraint (cid).size());</div><div class="line">    <span class="keywordflow">for</span> (CTP::Vertex_handle vh : ctp.vertices_in_constraint(cid))</div><div class="line">      polylines.back().push_back (vh-&gt;point());</div><div class="line">  }</div><div class="line"></div><div class="line">  std::size_t nb_vertices</div><div class="line">    = std::accumulate (polylines.begin(), polylines.end(), std::size_t(0),</div><div class="line">                       [](std::size_t size, <span class="keyword">const</span> std::vector&lt;Point_3&gt;&amp; poly) -&gt; std::size_t</div><div class="line">                       { <span class="keywordflow">return</span> size + poly.size(); });</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; nb_vertices</div><div class="line">            &lt;&lt; <span class="stringliteral">" vertices remaining after simplification ("</span></div><div class="line">            &lt;&lt; 100. * (nb_vertices / double(map_p2v.size())) &lt;&lt; <span class="stringliteral">"%)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Output to WKT file</span></div><div class="line">  std::ofstream simplified_ofile (<span class="stringliteral">"simplified.wkt"</span>);</div><div class="line">  simplified_ofile.precision(18);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsWKT.html#ga013d6cd500473657f41c44c9df43c511">CGAL::IO::write_multi_linestring_WKT</a> (simplified_ofile, polylines);</div><div class="line">  simplified_ofile.close();</div><div class="line"></div></div><!-- fragment --><p> Examples of contours and simplifications are given in <a class="el" href="tuto_gis.html#fig__TutorialGISFigContours">Figure 0.6</a>.</p>
<p><a class="anchor" id="fig__TutorialGISFigContours"></a></p><div class="image">
<img src="contours.png" alt="contours.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_gis.html#fig__TutorialGISFigContours">Figure 0.6</a> Contouring using 50 isovalues evenly spaced. Top: original contouring using 148k vertices and simplification with a tolerance equal to the average spacing of the input point cloud (3.4% of the original polyline vertices remaining). Bottom: simplification with tolerance 4 times the average spacing (1.3% of vertices remaining) and with tolerance 10 times the average spacing (0.9% of vertices remaining). Polylines are intersection-free in all cases.  </div> <br /> 
<h1><a class="anchor" id="TutorialGIS_Classify"></a>
Classifying</h1>
<p>CGAL provides a package Classification which can be used to segment a point cloud into a user-defined label set. The state-of-the-art classifier currently available in CGAL is the random forest from ETHZ. As it is a supervised classifier, a training set is needed.</p>
<p>The following snippet shows how to use some manually selected training set to train a random forest classifier and compute a classification regularized by a graph cut algorithm:</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="comment">// Get training from input</span></div><div class="line">  Point_set::Property_map&lt;int&gt; training_map;</div><div class="line">  <span class="keywordtype">bool</span> training_found;</div><div class="line">  std::tie (training_map, training_found) = points.property_map&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">"training"</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (training_found)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Classifying ground/vegetation/building"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// Create labels</span></div><div class="line">    Classification::Label_set labels ({ <span class="stringliteral">"ground"</span>, <span class="stringliteral">"vegetation"</span>, <span class="stringliteral">"building"</span> });</div><div class="line"></div><div class="line">    <span class="comment">// Generate features</span></div><div class="line">    Classification::Feature_set <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Mesh_3.tag:../Mesh_3/" href="../Mesh_3/group__PkgMesh3Parameters.html#ga0a990b28d55157c62d4bfd2624d408af">features</a>;</div><div class="line">    Classification::Point_set_feature_generator&lt;Kernel, Point_set, Point_set::Point_map&gt;</div><div class="line">      generator (points, points.point_map(), 5); <span class="comment">// 5 scales</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef CGAL_LINKED_WITH_TBB</span></div><div class="line">    <span class="comment">// If TBB is used, features can be computed in parallel</span></div><div class="line">    features.begin_parallel_additions();</div><div class="line">    generator.generate_point_based_features (features);</div><div class="line">    features.end_parallel_additions();</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    generator.generate_point_based_features (features);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">    <span class="comment">// Train a random forest classifier</span></div><div class="line">    Classification::ETHZ::Random_forest_classifier classifier (labels, features);</div><div class="line">    classifier.train (points.range(training_map));</div><div class="line"></div><div class="line">    <span class="comment">// Classify with graphcut regularization</span></div><div class="line">    Point_set::Property_map&lt;int&gt; label_map = points.add_property_map&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">"labels"</span>).first;</div><div class="line">    Classification::classify_with_graphcut&lt;Concurrency_tag&gt;</div><div class="line">      (points, points.point_map(), labels, classifier,</div><div class="line">       generator.neighborhood().k_neighbor_query(12), <span class="comment">// regularize on 12-neighbors graph</span></div><div class="line">       0.5f, <span class="comment">// graphcut weight</span></div><div class="line">       12, <span class="comment">// Subdivide to speed-up process</span></div><div class="line">       label_map);</div><div class="line"></div><div class="line">    <span class="comment">// Evaluate</span></div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Mean IoU on training data = "</span></div><div class="line">              &lt;&lt; Classification::Evaluation(labels,</div><div class="line">                                            points.range(training_map),</div><div class="line">                                            points.range(label_map)).mean_intersection_over_union() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// Save the classified point set</span></div><div class="line">    std::ofstream classified_ofile (<span class="stringliteral">"classified.ply"</span>);</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (classified_ofile);</div><div class="line">    classified_ofile &lt;&lt; points;</div><div class="line">    classified_ofile.close();</div><div class="line">  }</div><div class="line"></div></div><!-- fragment --><p> An example of training set and resulting classification is given in <a class="el" href="tuto_gis.html#fig__TutorialGISFigClassif">Figure 0.7</a>.</p>
<p><a class="anchor" id="fig__TutorialGISFigClassif"></a></p><div class="image">
<img src="classif_tuto.jpg" alt="classif_tuto.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_gis.html#fig__TutorialGISFigClassif">Figure 0.7</a> Top: a slice of the point cloud classified by hand. Bottom: a classification regularized by graph cut after training on 3 manually classified slices.  </div> <br /> 
<h1><a class="anchor" id="TutorialGIS_Code"></a>
Full Code Example</h1>
<p>All the code snippets used in this tutorial can be assembled to create a full GIS pipeline (provided the correct <em>includes</em> are used). We give a full code example which achieves all the steps described in this tutorial.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Projection_traits_xy_3.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Delaunay_triangulation_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Triangulation_vertex_base_with_info_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Triangulation_face_base_with_info_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/graph_traits_Delaunay_triangulation_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/copy_face_graph.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3/IO.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/compute_average_spacing.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/locate.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/triangulate_hole.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/border.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/remesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/graph/adjacency_list.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/split_graph_into_polylines.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/WKT.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Constrained_Delaunay_triangulation_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Constrained_triangulation_plus_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyline_simplification_2/simplify.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyline_simplification_2/Squared_distance_cost.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Classification.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Random.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;queue&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "include/Color_ramp.h"</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">using</span> Kernel = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div><div class="line"><span class="keyword">using</span> Projection_traits = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Projection__traits__xy__3.html">CGAL::Projection_traits_xy_3&lt;Kernel&gt;</a>;</div><div class="line"><span class="keyword">using</span> Point_2 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>;</div><div class="line"><span class="keyword">using</span> Point_3 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ae82b7f4be77dd5b8819ebe419e4ae753">Kernel::Point_3</a>;</div><div class="line"><span class="keyword">using</span> Segment_3 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#aa43a461b2027ef7d99b776a7b03ef230">Kernel::Segment_3</a>;</div><div class="line"></div><div class="line"><span class="comment">// Triangulated Irregular Network</span></div><div class="line"><span class="keyword">using</span> TIN = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2&lt;Projection_traits&gt;</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Triangulated Irregular Network (with info)</span></div><div class="line"><span class="keyword">using</span> Point_set = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3&lt;Point_3&gt;</a>;</div><div class="line"><span class="keyword">using</span> Vbi = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Triangulation__vertex__base__with__info__2.html">CGAL::Triangulation_vertex_base_with_info_2 &lt;Point_set::Index, Projection_traits&gt;</a>;</div><div class="line"><span class="keyword">using</span> Fbi = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Triangulation__face__base__with__info__2.html">CGAL::Triangulation_face_base_with_info_2&lt;int, Projection_traits&gt;</a>;</div><div class="line"><span class="keyword">using</span> TDS = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/TDS_2.tag:../TDS_2/" href="../TDS_2/classCGAL_1_1Triangulation__data__structure__2.html">CGAL::Triangulation_data_structure_2&lt;Vbi, Fbi&gt;</a>;</div><div class="line"><span class="keyword">using</span> TIN_with_info = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2&lt;Projection_traits, TDS&gt;</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Classification = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Classification.tag:../Classification/" href="../Classification/namespaceCGAL_1_1Classification.html">CGAL::Classification</a>;</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef CGAL_LINKED_WITH_TBB</span></div><div class="line"><span class="keyword">using</span> Concurrency_tag = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__tag.html">CGAL::Parallel_tag</a>;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line"><span class="keyword">using</span> Concurrency_tag = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Sequential__tag.html">CGAL::Sequential_tag</a>;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> face_has_isovalue (TIN::Face_handle fh, <span class="keywordtype">double</span> isovalue)</div><div class="line">{</div><div class="line">  <span class="keywordtype">bool</span> above = <span class="keyword">false</span>, below = <span class="keyword">false</span>;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++ i)</div><div class="line">  {</div><div class="line">    <span class="comment">// Face has isovalue if one of its vertices is above and another</span></div><div class="line">    <span class="comment">// one below</span></div><div class="line">    <span class="keywordflow">if</span> (fh-&gt;vertex(i)-&gt;point().z() &gt; isovalue)</div><div class="line">      above = <span class="keyword">true</span>;</div><div class="line">    <span class="keywordflow">if</span> (fh-&gt;vertex(i)-&gt;point().z() &lt; isovalue)</div><div class="line">      below = <span class="keyword">true</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> (above &amp;&amp; below);</div><div class="line">}</div><div class="line"></div><div class="line">Segment_3 isocontour_in_face (TIN::Face_handle fh, <span class="keywordtype">double</span> isovalue)</div><div class="line">{</div><div class="line">  Point_3 source;</div><div class="line">  Point_3 target;</div><div class="line">  <span class="keywordtype">bool</span> source_found = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++ i)</div><div class="line">  {</div><div class="line">    Point_3 p0 = fh-&gt;vertex((i+1) % 3)-&gt;point();</div><div class="line">    Point_3 p1 = fh-&gt;vertex((i+2) % 3)-&gt;point();</div><div class="line"></div><div class="line">    <span class="comment">// Check if the isovalue crosses segment (p0,p1)</span></div><div class="line">    <span class="keywordflow">if</span> ((p0.z() - isovalue) * (p1.z() - isovalue) &gt; 0)</div><div class="line">      <span class="keywordflow">continue</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> zbottom = p0.z();</div><div class="line">    <span class="keywordtype">double</span> ztop = p1.z();</div><div class="line">    <span class="keywordflow">if</span> (zbottom &gt; ztop)</div><div class="line">    {</div><div class="line">      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polynomial.tag:../Polynomial/" href="../Polynomial/group__PkgPolynomialFunctions.html#gaa555a2d0a5bf3730c337f08f07356c07">std::swap</a> (zbottom, ztop);</div><div class="line">      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polynomial.tag:../Polynomial/" href="../Polynomial/group__PkgPolynomialFunctions.html#gaa555a2d0a5bf3730c337f08f07356c07">std::swap</a> (p0, p1);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Compute position of segment vertex</span></div><div class="line">    <span class="keywordtype">double</span> ratio = (isovalue - zbottom) / (ztop - zbottom);</div><div class="line">    Point_3 p = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__barycenter__grp.html#ga43dafb654e67589a55dcf5b13092966b">CGAL::barycenter</a> (p0, (1 - ratio), p1,ratio);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (source_found)</div><div class="line">      target = p;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      source = p;</div><div class="line">      source_found = <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> Segment_3 (source, target);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph&gt;</div><div class="line"><span class="keyword">class </span>Polylines_visitor</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">  std::vector&lt;std::vector&lt;Point_3&gt; &gt;&amp; polylines;</div><div class="line">  Graph&amp; graph;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">  Polylines_visitor (Graph&amp; graph, std::vector&lt;std::vector&lt;Point_3&gt; &gt;&amp; polylines)</div><div class="line">    : polylines (polylines), graph(graph) { }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> start_new_polyline()</div><div class="line">  {</div><div class="line">    polylines.push_back (std::vector&lt;Point_3&gt;());</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> add_node (<span class="keyword">typename</span> Graph::vertex_descriptor vd)</div><div class="line">  {</div><div class="line">    polylines.back().push_back (graph[vd]);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> end_polyline()</div><div class="line">  {</div><div class="line">    <span class="comment">// filter small polylines</span></div><div class="line">    <span class="keywordflow">if</span> (polylines.back().size() &lt; 50)</div><div class="line">      polylines.pop_back();</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>PS = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polyline_simplification_2.tag:../Polyline_simplification_2/" href="../Polyline_simplification_2/namespaceCGAL_1_1Polyline__simplification__2.html">CGAL::Polyline_simplification_2</a>;</div><div class="line"><span class="keyword">using</span> CDT_vertex_base = PS::Vertex_base_2&lt;Projection_traits&gt;;</div><div class="line"><span class="keyword">using</span> CDT_face_base = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Constrained__triangulation__face__base__2.html">CGAL::Constrained_triangulation_face_base_2&lt;Projection_traits&gt;</a>;</div><div class="line"><span class="keyword">using</span> CDT_TDS = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/TDS_2.tag:../TDS_2/" href="../TDS_2/classCGAL_1_1Triangulation__data__structure__2.html">CGAL::Triangulation_data_structure_2&lt;CDT_vertex_base, CDT_face_base&gt;</a>;</div><div class="line"><span class="keyword">using</span> CDT = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Constrained__Delaunay__triangulation__2.html">CGAL::Constrained_Delaunay_triangulation_2&lt;Projection_traits, CDT_TDS&gt;</a>;</div><div class="line"><span class="keyword">using</span> CTP = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Constrained__triangulation__plus__2.html">CGAL::Constrained_triangulation_plus_2&lt;CDT&gt;</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname = argc != 2 ? <a class="code" href="namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/b9_training.ply"</span>) : argv[1];</div><div class="line">  <span class="keywordflow">if</span> (argc != 2)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Usage: "</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">" points.ply"</span> &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Running with default value "</span> &lt;&lt; fname &lt;&lt; <span class="stringliteral">"\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Read points</span></div><div class="line">  std::ifstream ifile (fname, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3&lt;Point_3&gt;</a> points;</div><div class="line">  ifile &gt;&gt; points;</div><div class="line">  std::cerr &lt;&lt; points.size() &lt;&lt; <span class="stringliteral">" point(s) read"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Create DSM</span></div><div class="line">  TIN dsm (points.points().begin(), points.points().end());</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">using</span> Mesh = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point_3&gt;</a>;</div><div class="line"></div><div class="line">  Mesh dsm_mesh;</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#ga2682fb7d5f4ff4eb65607ae4118e31bc">CGAL::copy_face_graph</a> (dsm, dsm_mesh);</div><div class="line">  std::ofstream dsm_ofile (<span class="stringliteral">"dsm.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (dsm_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (dsm_ofile, dsm_mesh);</div><div class="line">  dsm_ofile.close();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">auto</span> idx_to_point_with_info</div><div class="line">    = [&amp;](<span class="keyword">const</span> Point_set::Index&amp; idx) -&gt; std::pair&lt;Point_3, Point_set::Index&gt;</div><div class="line">      {</div><div class="line">        <span class="keywordflow">return</span> std::make_pair (points.point(idx), idx);</div><div class="line">      };</div><div class="line"></div><div class="line">  TIN_with_info tin_with_info</div><div class="line">    (boost::make_transform_iterator (points.begin(), idx_to_point_with_info),</div><div class="line">     boost::make_transform_iterator (points.end(), idx_to_point_with_info));</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> spacing = CGAL::compute_average_spacing&lt;Concurrency_tag&gt;(points, 6);</div><div class="line">  spacing *= 2;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> face_height</div><div class="line">    = [&amp;](<span class="keyword">const</span> TIN_with_info::Face_handle fh) -&gt; <span class="keywordtype">double</span></div><div class="line">      {</div><div class="line">        <span class="keywordtype">double</span> out = 0.;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++ i)</div><div class="line">          out = (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/group__nt__util.html#gad7dbfa919e255b52f36ea1512a92cb78">std::max</a>) (out, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">CGAL::abs</a>(fh-&gt;vertex(i)-&gt;point().z() - fh-&gt;vertex((i+1)%3)-&gt;point().z()));</div><div class="line">        <span class="keywordflow">return</span> out;</div><div class="line">      };</div><div class="line"></div><div class="line">  <span class="comment">// Initialize faces info</span></div><div class="line">  <span class="keywordflow">for</span> (TIN_with_info::Face_handle fh : tin_with_info.all_face_handles())</div><div class="line">    <span class="keywordflow">if</span> (tin_with_info.is_infinite(fh) || face_height(fh) &gt; spacing) <span class="comment">// Filtered faces are given info() = -2</span></div><div class="line">      fh-&gt;info() = -2;</div><div class="line">    <span class="keywordflow">else</span> <span class="comment">// Pending faces are given info() = -1;</span></div><div class="line">      fh-&gt;info() = -1;</div><div class="line"></div><div class="line">  <span class="comment">// Flooding algorithm</span></div><div class="line">  std::vector&lt;int&gt; component_size;</div><div class="line">  <span class="keywordflow">for</span> (TIN_with_info::Face_handle fh : tin_with_info.finite_face_handles())</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (fh-&gt;info() != -1)</div><div class="line">      <span class="keywordflow">continue</span>;</div><div class="line"></div><div class="line">    std::queue&lt;TIN_with_info::Face_handle&gt; todo;</div><div class="line">    todo.push(fh);</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> size = 0;</div><div class="line">    <span class="keywordflow">while</span> (!todo.empty())</div><div class="line">    {</div><div class="line">      TIN_with_info::Face_handle current = todo.front();</div><div class="line">      todo.pop();</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (current-&gt;info() != -1)</div><div class="line">        <span class="keywordflow">continue</span>;</div><div class="line">      current-&gt;info() = int(component_size.size());</div><div class="line">      ++ size;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++ i)</div><div class="line">        todo.push (current-&gt;neighbor(i));</div><div class="line">    }</div><div class="line"></div><div class="line">    component_size.push_back (size);</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; component_size.size() &lt;&lt; <span class="stringliteral">" connected component(s) found"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  Mesh tin_colored_mesh;</div><div class="line"></div><div class="line">  Mesh::Property_map&lt;Mesh::Face_index, CGAL::IO::Color&gt;</div><div class="line">    color_map = tin_colored_mesh.add_property_map&lt;Mesh::Face_index, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a>&gt;(<span class="stringliteral">"f:color"</span>).first;</div><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#ga2682fb7d5f4ff4eb65607ae4118e31bc">CGAL::copy_face_graph</a> (tin_with_info, tin_colored_mesh,</div><div class="line">                         CGAL::parameters::face_to_face_output_iterator</div><div class="line">                         (boost::make_function_output_iterator</div><div class="line">                          ([&amp;](<span class="keyword">const</span> std::pair&lt;TIN_with_info::Face_handle, Mesh::Face_index&gt;&amp; ff)</div><div class="line">                           {</div><div class="line">                             <span class="comment">// Color unassigned faces gray</span></div><div class="line">                             <span class="keywordflow">if</span> (ff.first-&gt;info() &lt; 0)</div><div class="line">                               color_map[ff.second] = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a>(128, 128, 128);</div><div class="line">                             <span class="keywordflow">else</span></div><div class="line">                             {</div><div class="line">                               <span class="comment">// Random color seeded by the component ID</span></div><div class="line">                               <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Generator.tag:../Generator/" href="../Generator/classCGAL_1_1Random.html">CGAL::Random</a> r (ff.first-&gt;info());</div><div class="line">                               color_map[ff.second] = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a> (r.get_int(64, 192),</div><div class="line">                                                                   r.get_int(64, 192),</div><div class="line">                                                                   r.get_int(64, 192));</div><div class="line">                             }</div><div class="line">                           })));</div><div class="line"></div><div class="line">  std::ofstream tin_colored_ofile (<span class="stringliteral">"colored_tin.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (tin_colored_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (tin_colored_ofile, tin_colored_mesh);</div><div class="line">  tin_colored_ofile.close();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> min_size = int(points.size() / 2);</div><div class="line"></div><div class="line">  std::vector&lt;TIN_with_info::Vertex_handle&gt; to_remove;</div><div class="line">  <span class="keywordflow">for</span> (TIN_with_info::Vertex_handle vh : tin_with_info.finite_vertex_handles())</div><div class="line">  {</div><div class="line">    TIN_with_info::Face_circulator circ = tin_with_info.incident_faces (vh),</div><div class="line">      start = circ;</div><div class="line"></div><div class="line">    <span class="comment">// Remove a vertex if it's only adjacent to components smaller than threshold</span></div><div class="line">    <span class="keywordtype">bool</span> keep = <span class="keyword">false</span>;</div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (circ-&gt;info() &gt;= 0 &amp;&amp; component_size[std::size_t(circ-&gt;info())] &gt; min_size)</div><div class="line">      {</div><div class="line">        keep = <span class="keyword">true</span>;</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">while</span> (++ circ != start);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (!keep)</div><div class="line">      to_remove.push_back (vh);</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; to_remove.size() &lt;&lt; <span class="stringliteral">" vertices(s) will be removed after filtering"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (TIN_with_info::Vertex_handle vh : to_remove)</div><div class="line">    tin_with_info.remove (vh);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Copy and keep track of overly large faces</span></div><div class="line">  Mesh dtm_mesh;</div><div class="line"></div><div class="line">  std::vector&lt;Mesh::Face_index&gt; face_selection;</div><div class="line">  Mesh::Property_map&lt;Mesh::Face_index, bool&gt; face_selection_map</div><div class="line">   = dtm_mesh.add_property_map&lt;Mesh::Face_index, <span class="keywordtype">bool</span>&gt;(<span class="stringliteral">"is_selected"</span>, <span class="keyword">false</span>).first;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> limit = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga07001b5ddc5c43096c811c91a306be9a">CGAL::square</a> (5 * spacing);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#ga2682fb7d5f4ff4eb65607ae4118e31bc">CGAL::copy_face_graph</a> (tin_with_info, dtm_mesh,</div><div class="line">                         CGAL::parameters::face_to_face_output_iterator</div><div class="line">                         (boost::make_function_output_iterator</div><div class="line">                          ([&amp;](<span class="keyword">const</span> std::pair&lt;TIN_with_info::Face_handle, Mesh::Face_index&gt;&amp; ff)</div><div class="line">                           {</div><div class="line">                             <span class="keywordtype">double</span> longest_edge = 0.;</div><div class="line">                             <span class="keywordtype">bool</span> border = <span class="keyword">false</span>;</div><div class="line">                             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++ i)</div><div class="line">                             {</div><div class="line">                               longest_edge = (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/group__nt__util.html#gad7dbfa919e255b52f36ea1512a92cb78">std::max</a>)(longest_edge, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">CGAL::squared_distance</a></div><div class="line">                                                         (ff.first-&gt;vertex((i+1)%3)-&gt;point(),</div><div class="line">                                                          ff.first-&gt;vertex((i+2)%3)-&gt;point()));</div><div class="line"></div><div class="line">                               TIN_with_info::Face_circulator circ</div><div class="line">                                 = tin_with_info.incident_faces (ff.first-&gt;vertex(i)),</div><div class="line">                                 start = circ;</div><div class="line">                               <span class="keywordflow">do</span></div><div class="line">                               {</div><div class="line">                                 <span class="keywordflow">if</span> (tin_with_info.is_infinite (circ))</div><div class="line">                                 {</div><div class="line">                                   border = <span class="keyword">true</span>;</div><div class="line">                                   <span class="keywordflow">break</span>;</div><div class="line">                                 }</div><div class="line">                               }</div><div class="line">                               <span class="keywordflow">while</span> (++ circ != start);</div><div class="line"></div><div class="line">                               <span class="keywordflow">if</span> (border)</div><div class="line">                                 <span class="keywordflow">break</span>;</div><div class="line">                             }</div><div class="line"></div><div class="line">                             <span class="comment">// Select if face is too big AND it's not</span></div><div class="line">                             <span class="comment">// on the border (to have closed holes)</span></div><div class="line">                             <span class="keywordflow">if</span> (!border &amp;&amp; longest_edge &gt; limit)</div><div class="line">                             {</div><div class="line">                               face_selection_map[ff.second] = <span class="keyword">true</span>;</div><div class="line">                               face_selection.push_back (ff.second);</div><div class="line">                             }</div><div class="line">                           })));</div><div class="line"></div><div class="line">  <span class="comment">// Save original DTM</span></div><div class="line">  std::ofstream dtm_ofile (<span class="stringliteral">"dtm.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (dtm_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (dtm_ofile, dtm_mesh);</div><div class="line">  dtm_ofile.close();</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; face_selection.size() &lt;&lt; <span class="stringliteral">" face(s) are selected for removal"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Expand face selection to keep a well formed 2-manifold mesh after removal</span></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLSelectionFct.html#ga6f8d338df28c24bbf93677f24f7bcbbe">CGAL::expand_face_selection_for_removal</a> (face_selection, dtm_mesh, face_selection_map);</div><div class="line">  face_selection.clear();</div><div class="line">  <span class="keywordflow">for</span> (Mesh::Face_index fi : faces(dtm_mesh))</div><div class="line">    <span class="keywordflow">if</span> (face_selection_map[fi])</div><div class="line">      face_selection.push_back(fi);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; face_selection.size() &lt;&lt; <span class="stringliteral">" face(s) are selected for removal after expansion"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (Mesh::Face_index fi : face_selection)</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLEulerOperations.html#gacfae7ff8e782da55b941e4487e86c738">CGAL::Euler::remove_face</a> (halfedge(fi, dtm_mesh), dtm_mesh);</div><div class="line">  dtm_mesh.collect_garbage();</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (!dtm_mesh.is_valid())</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid mesh!"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save filtered DTM</span></div><div class="line">  std::ofstream dtm_holes_ofile (<span class="stringliteral">"dtm_with_holes.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (dtm_holes_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (dtm_holes_ofile, dtm_mesh);</div><div class="line">  dtm_holes_ofile.close();</div><div class="line"></div><div class="line">  <span class="comment">// Get all holes</span></div><div class="line">  std::vector&lt;Mesh::Halfedge_index&gt; holes;</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PkgPolygonMeshProcessingRef.html#gafa9b682528c5dc2a4821d01193518d14">CGAL::Polygon_mesh_processing::extract_boundary_cycles</a> (dtm_mesh, std::back_inserter (holes));</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; holes.size() &lt;&lt; <span class="stringliteral">" hole(s) identified"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Identify outer hull (hole with maximum size)</span></div><div class="line">  <span class="keywordtype">double</span> max_size = 0.;</div><div class="line">  Mesh::Halfedge_index outer_hull;</div><div class="line">  <span class="keywordflow">for</span> (Mesh::Halfedge_index hi : holes)</div><div class="line">  {</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html">CGAL::Bbox_3</a> hole_bbox;</div><div class="line">    <span class="keywordflow">for</span> (Mesh::Halfedge_index haf : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLIterators.html#ga37229df31508a78eb4acdaf907e637e5">CGAL::halfedges_around_face</a>(hi, dtm_mesh))</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> Point_3&amp; p = dtm_mesh.point(target(haf, dtm_mesh));</div><div class="line">      hole_bbox += p.bbox();</div><div class="line">    }</div><div class="line">    <span class="keywordtype">double</span> size = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">CGAL::squared_distance</a> (Point_2(hole_bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#aab574470a2591f187553ca1166e682e1">xmin</a>(), hole_bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a2088e16a1f0a20e011e5b94c2e9c222a">ymin</a>()),</div><div class="line">                                          Point_2(hole_bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a3f5e323700e1509624a02d151237cc4c">xmax</a>(), hole_bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a9d06f61bd89faa841e011ff53edf745f">ymax</a>()));</div><div class="line">    <span class="keywordflow">if</span> (size &gt; max_size)</div><div class="line">    {</div><div class="line">      max_size = size;</div><div class="line">      outer_hull = hi;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Fill all holes except the bigest (which is the outer hull of the mesh)</span></div><div class="line">  <span class="keywordflow">for</span> (Mesh::Halfedge_index hi : holes)</div><div class="line">    <span class="keywordflow">if</span> (hi != outer_hull)</div><div class="line">      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__hole__filling__grp.html#ga16473e4861b13d1241edee68f596b153">CGAL::Polygon_mesh_processing::triangulate_refine_and_fair_hole</a></div><div class="line">        (dtm_mesh, hi, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Emptyset__iterator.html">CGAL::Emptyset_iterator</a>(), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Emptyset__iterator.html">CGAL::Emptyset_iterator</a>());</div><div class="line"></div><div class="line">  <span class="comment">// Save DTM with holes filled</span></div><div class="line">  std::ofstream dtm_filled_ofile (<span class="stringliteral">"dtm_filled.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (dtm_filled_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (dtm_filled_ofile, dtm_mesh);</div><div class="line">  dtm_filled_ofile.close();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__meshing__grp.html#gaa5cc92275df27f0baab2472ecbc4ea3f">CGAL::Polygon_mesh_processing::isotropic_remeshing</a> (faces(dtm_mesh), spacing, dtm_mesh);</div><div class="line"></div><div class="line">  std::ofstream dtm_remeshed_ofile (<span class="stringliteral">"dtm_remeshed.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (dtm_remeshed_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (dtm_remeshed_ofile, dtm_mesh);</div><div class="line">  dtm_remeshed_ofile.close();</div><div class="line"></div><div class="line"></div><div class="line">  TIN dtm_clean (dtm_mesh.points().begin(), dtm_mesh.points().end());</div><div class="line"></div><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html">CGAL::Bbox_3</a> bbox = CGAL::bbox_3 (points.points().begin(), points.points().end());</div><div class="line"></div><div class="line">  <span class="comment">// Generate raster image 1920-pixels large</span></div><div class="line">  std::size_t width = 1920;</div><div class="line">  std::size_t height = std::size_t((bbox.ymax() - bbox.ymin()) * 1920 / (bbox.xmax() - bbox.xmin()));</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Rastering with resolution "</span> &lt;&lt; width &lt;&lt; <span class="stringliteral">"x"</span> &lt;&lt; height &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Use PPM format (Portable PixMap) for simplicity</span></div><div class="line">  std::ofstream raster_ofile (<span class="stringliteral">"raster.ppm"</span>, std::ios_base::binary);</div><div class="line"></div><div class="line">  <span class="comment">// PPM header</span></div><div class="line">  raster_ofile &lt;&lt; <span class="stringliteral">"P6"</span> &lt;&lt; std::endl <span class="comment">// magic number</span></div><div class="line">               &lt;&lt; width &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; height &lt;&lt; std::endl <span class="comment">// dimensions of the image</span></div><div class="line">               &lt;&lt; 255 &lt;&lt; std::endl; <span class="comment">// maximum color value</span></div><div class="line"></div><div class="line">  <span class="comment">// Use rainbow color ramp output</span></div><div class="line">  Color_ramp color_ramp;</div><div class="line"></div><div class="line">  <span class="comment">// Keeping track of location from one point to its neighbor allows</span></div><div class="line">  <span class="comment">// for fast locate in DT</span></div><div class="line">  TIN::Face_handle location;</div><div class="line"></div><div class="line">  <span class="comment">// Query each pixel of the image</span></div><div class="line">  <span class="keywordflow">for</span> (std::size_t y = 0; y &lt; height; ++ y)</div><div class="line">    <span class="keywordflow">for</span> (std::size_t x = 0; x &lt; width; ++ x)</div><div class="line">    {</div><div class="line">      Point_3 query (bbox.xmin() + x * (bbox.xmax() - bbox.xmin()) / <span class="keywordtype">double</span>(width),</div><div class="line">                     bbox.ymin() + (height-y) * (bbox.ymax() - bbox.ymin()) / <span class="keywordtype">double</span>(height),</div><div class="line">                     0); <span class="comment">// not relevant for location in 2D</span></div><div class="line"></div><div class="line">      location = dtm_clean.locate (query, location);</div><div class="line"></div><div class="line">      <span class="comment">// Points outside the convex hull will be colored black</span></div><div class="line">      std::array&lt;unsigned char, 3&gt; colors { 0, 0, 0 };</div><div class="line">      <span class="keywordflow">if</span> (!dtm_clean.is_infinite(location))</div><div class="line">      {</div><div class="line">        std::array&lt;double, 3&gt; barycentric_coordinates</div><div class="line">          = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#gadd9f94997d1963426d38305192345564">CGAL::Polygon_mesh_processing::barycentric_coordinates</a></div><div class="line">          (Point_2 (location-&gt;vertex(0)-&gt;point().x(), location-&gt;vertex(0)-&gt;point().y()),</div><div class="line">           Point_2 (location-&gt;vertex(1)-&gt;point().x(), location-&gt;vertex(1)-&gt;point().y()),</div><div class="line">           Point_2 (location-&gt;vertex(2)-&gt;point().x(), location-&gt;vertex(2)-&gt;point().y()),</div><div class="line">           Point_2 (query.x(), query.y()),</div><div class="line">           Kernel());</div><div class="line"></div><div class="line">        <span class="keywordtype">double</span> height_at_query</div><div class="line">          = (barycentric_coordinates[0] * location-&gt;vertex(0)-&gt;point().z()</div><div class="line">             + barycentric_coordinates[1] * location-&gt;vertex(1)-&gt;point().z()</div><div class="line">             + barycentric_coordinates[2] * location-&gt;vertex(2)-&gt;point().z());</div><div class="line"></div><div class="line">        <span class="comment">// Color ramp generates a color depending on a value from 0 to 1</span></div><div class="line">        <span class="keywordtype">double</span> height_ratio = (height_at_query - bbox.zmin()) / (bbox.zmax() - bbox.zmin());</div><div class="line">        colors = color_ramp.get(height_ratio);</div><div class="line">      }</div><div class="line">      raster_ofile.write (reinterpret_cast&lt;char*&gt;(&amp;colors), 3);</div><div class="line">    }</div><div class="line"></div><div class="line">  raster_ofile.close();</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Smooth heights with 5 successive Gaussian filters</span></div><div class="line">  <span class="keywordtype">double</span> gaussian_variance = 4 * spacing * spacing;</div><div class="line">  <span class="keywordflow">for</span> (TIN::Vertex_handle vh : dtm_clean.finite_vertex_handles())</div><div class="line">  {</div><div class="line">    <span class="keywordtype">double</span> z = vh-&gt;point().z();</div><div class="line">    <span class="keywordtype">double</span> total_weight = 1;</div><div class="line"></div><div class="line">    TIN::Vertex_circulator circ = dtm_clean.incident_vertices (vh),</div><div class="line">      start = circ;</div><div class="line"></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (!dtm_clean.is_infinite(circ))</div><div class="line">      {</div><div class="line">        <span class="keywordtype">double</span> sq_dist = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">CGAL::squared_distance</a> (vh-&gt;point(), circ-&gt;point());</div><div class="line"></div><div class="line">        <span class="keywordtype">double</span> weight = std::exp(- sq_dist / gaussian_variance);</div><div class="line">        z += weight * circ-&gt;point().z();</div><div class="line">        total_weight += weight;</div><div class="line">      }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">while</span> (++ circ != start);</div><div class="line"></div><div class="line">    z /= total_weight;</div><div class="line"></div><div class="line">    vh-&gt;point() = Point_3 (vh-&gt;point().x(), vh-&gt;point().y(), z);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  std::array&lt;double, 50&gt; isovalues; <span class="comment">// Contour 50 isovalues</span></div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; isovalues.size(); ++ i)</div><div class="line">    isovalues[i] = bbox.zmin() + ((i+1) * (bbox.zmax() - bbox.zmin()) / (isovalues.size() - 2));</div><div class="line"></div><div class="line">  <span class="comment">// First find on each face if they are crossed by some isovalues and</span></div><div class="line">  <span class="comment">// extract segments in a graph</span></div><div class="line">  <span class="keyword">using</span> Segment_graph = boost::adjacency_list&lt;boost::listS, boost::vecS, boost::undirectedS, Point_3&gt;;</div><div class="line">  Segment_graph graph;</div><div class="line">  <span class="keyword">using</span> Map_p2v = std::map&lt;Point_3, Segment_graph::vertex_descriptor&gt;;</div><div class="line">  Map_p2v map_p2v;</div><div class="line">  <span class="keywordflow">for</span> (TIN::Face_handle vh : dtm_clean.finite_face_handles())</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">double</span> iv : isovalues)</div><div class="line">      <span class="keywordflow">if</span> (face_has_isovalue (vh, iv))</div><div class="line">      {</div><div class="line">        Segment_3 segment = isocontour_in_face (vh, iv);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> Point_3&amp; p : { segment.source(), segment.target() })</div><div class="line">        {</div><div class="line">          <span class="comment">// Only insert end points of segments once to get a well connected graph</span></div><div class="line">          Map_p2v::iterator iter;</div><div class="line">          <span class="keywordtype">bool</span> inserted;</div><div class="line">          std::tie (iter, inserted) = map_p2v.insert (std::make_pair (p, Segment_graph::vertex_descriptor()));</div><div class="line">          <span class="keywordflow">if</span> (inserted)</div><div class="line">          {</div><div class="line">            iter-&gt;second = boost::add_vertex (graph);</div><div class="line">            graph[iter-&gt;second] = p;</div><div class="line">          }</div><div class="line">        }</div><div class="line">        <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLEulerOperations.html#ga4661f850bc60686efeae2fc9d2ec3e65">boost::add_edge</a> (map_p2v[segment.source()], map_p2v[segment.target()], graph);</div><div class="line">      }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Split segments into polylines</span></div><div class="line">  std::vector&lt;std::vector&lt;Point_3&gt; &gt; polylines;</div><div class="line">  Polylines_visitor&lt;Segment_graph&gt; visitor (graph, polylines);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLPartition.html#ga99ea6bf193f1194db5e523e713c82fb9">CGAL::split_graph_into_polylines</a> (graph, visitor);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; polylines.size() &lt;&lt; <span class="stringliteral">" polylines computed, with "</span></div><div class="line">            &lt;&lt; map_p2v.size() &lt;&lt; <span class="stringliteral">" vertices in total"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Output to WKT file</span></div><div class="line">  std::ofstream contour_ofile (<span class="stringliteral">"contour.wkt"</span>);</div><div class="line">  contour_ofile.precision(18);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsWKT.html#ga013d6cd500473657f41c44c9df43c511">CGAL::IO::write_multi_linestring_WKT</a> (contour_ofile, polylines);</div><div class="line">  contour_ofile.close();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Construct constrained Delaunay triangulation with polylines as constraints</span></div><div class="line">  CTP ctp;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> std::vector&lt;Point_3&gt;&amp; poly : polylines)</div><div class="line">    ctp.insert_constraint (poly.begin(), poly.end());</div><div class="line"></div><div class="line">  <span class="comment">// Simplification algorithm with limit on distance</span></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga5339b0f11fdc9babbc5ca0b33f4a982c">PS::simplify</a> (ctp, PS::Squared_distance_cost(), PS::Stop_above_cost_threshold (16 * spacing * spacing));</div><div class="line"></div><div class="line">  polylines.clear();</div><div class="line">  <span class="keywordflow">for</span> (CTP::Constraint_id cid : ctp.constraints())</div><div class="line">  {</div><div class="line">    polylines.push_back (std::vector&lt;Point_3&gt;());</div><div class="line">    polylines.back().reserve (ctp.vertices_in_constraint (cid).size());</div><div class="line">    <span class="keywordflow">for</span> (CTP::Vertex_handle vh : ctp.vertices_in_constraint(cid))</div><div class="line">      polylines.back().push_back (vh-&gt;point());</div><div class="line">  }</div><div class="line"></div><div class="line">  std::size_t nb_vertices</div><div class="line">    = std::accumulate (polylines.begin(), polylines.end(), std::size_t(0),</div><div class="line">                       [](std::size_t size, <span class="keyword">const</span> std::vector&lt;Point_3&gt;&amp; poly) -&gt; std::size_t</div><div class="line">                       { <span class="keywordflow">return</span> size + poly.size(); });</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; nb_vertices</div><div class="line">            &lt;&lt; <span class="stringliteral">" vertices remaining after simplification ("</span></div><div class="line">            &lt;&lt; 100. * (nb_vertices / double(map_p2v.size())) &lt;&lt; <span class="stringliteral">"%)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Output to WKT file</span></div><div class="line">  std::ofstream simplified_ofile (<span class="stringliteral">"simplified.wkt"</span>);</div><div class="line">  simplified_ofile.precision(18);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsWKT.html#ga013d6cd500473657f41c44c9df43c511">CGAL::IO::write_multi_linestring_WKT</a> (simplified_ofile, polylines);</div><div class="line">  simplified_ofile.close();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Get training from input</span></div><div class="line">  Point_set::Property_map&lt;int&gt; training_map;</div><div class="line">  <span class="keywordtype">bool</span> training_found;</div><div class="line">  std::tie (training_map, training_found) = points.property_map&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">"training"</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (training_found)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Classifying ground/vegetation/building"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// Create labels</span></div><div class="line">    Classification::Label_set labels ({ <span class="stringliteral">"ground"</span>, <span class="stringliteral">"vegetation"</span>, <span class="stringliteral">"building"</span> });</div><div class="line"></div><div class="line">    <span class="comment">// Generate features</span></div><div class="line">    Classification::Feature_set <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Mesh_3.tag:../Mesh_3/" href="../Mesh_3/group__PkgMesh3Parameters.html#ga0a990b28d55157c62d4bfd2624d408af">features</a>;</div><div class="line">    Classification::Point_set_feature_generator&lt;Kernel, Point_set, Point_set::Point_map&gt;</div><div class="line">      generator (points, points.point_map(), 5); <span class="comment">// 5 scales</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef CGAL_LINKED_WITH_TBB</span></div><div class="line">    <span class="comment">// If TBB is used, features can be computed in parallel</span></div><div class="line">    features.begin_parallel_additions();</div><div class="line">    generator.generate_point_based_features (features);</div><div class="line">    features.end_parallel_additions();</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    generator.generate_point_based_features (features);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">    <span class="comment">// Train a random forest classifier</span></div><div class="line">    Classification::ETHZ::Random_forest_classifier classifier (labels, features);</div><div class="line">    classifier.train (points.range(training_map));</div><div class="line"></div><div class="line">    <span class="comment">// Classify with graphcut regularization</span></div><div class="line">    Point_set::Property_map&lt;int&gt; label_map = points.add_property_map&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">"labels"</span>).first;</div><div class="line">    Classification::classify_with_graphcut&lt;Concurrency_tag&gt;</div><div class="line">      (points, points.point_map(), labels, classifier,</div><div class="line">       generator.neighborhood().k_neighbor_query(12), <span class="comment">// regularize on 12-neighbors graph</span></div><div class="line">       0.5f, <span class="comment">// graphcut weight</span></div><div class="line">       12, <span class="comment">// Subdivide to speed-up process</span></div><div class="line">       label_map);</div><div class="line"></div><div class="line">    <span class="comment">// Evaluate</span></div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Mean IoU on training data = "</span></div><div class="line">              &lt;&lt; Classification::Evaluation(labels,</div><div class="line">                                            points.range(training_map),</div><div class="line">                                            points.range(label_map)).mean_intersection_over_union() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// Save the classified point set</span></div><div class="line">    std::ofstream classified_ofile (<span class="stringliteral">"classified.ply"</span>);</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (classified_ofile);</div><div class="line">    classified_ofile &lt;&lt; points;</div><div class="line">    classified_ofile.close();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="TutorialGIS_Reference"></a>
References</h1>
<p>This tutorial is based on the following CGAL packages:</p>
<ul>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/group__PkgTriangulation2Ref.html">2D Triangulations Reference</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/group__PkgPointSet3Ref.html">3D Point Set Reference</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Ref.html">Point Set Processing Reference</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurface__mesh.html">Surface Mesh Reference</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLRef.html">CGAL and the Boost Graph Library Reference</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PkgPolygonMeshProcessingRef.html">Polygon Mesh Processing Reference</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polyline_simplification_2.tag:../Polyline_simplification_2/" href="../Polyline_simplification_2/group__PkgPolylineSimplification2Ref.html">2D Polyline Simplification Reference</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Classification.tag:../Classification/" href="../Classification/group__PkgClassificationRef.html">Classification Reference</a></li>
</ul>
<p>The data set used throughout this tutorial comes from the <a href="https://www.usgs.gov/">https://www.usgs.gov/</a> database, licensed under the <em>US Government Public Domain</em>. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jul 4 2022 13:24:47 for CGAL 5.6 - Manual by
    <a href="https://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>
</html>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
          <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
          <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt="" /></a>
          </span>
        </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.6 - Manual
   </div>
  </td>
  <!-- We disable the search box because we have added it in the
  back-nav for stylistic reasons. -->
  <!-- <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td> -->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tuto_gis.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">GIS (Geographic Information System) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> </p><div id="autotoc" class="toc"></div> 
<dl class="section author"><dt>Author</dt><dd>Simon Giraudot</dd></dl>
<p>Many sensors used in GIS applications (for example LIDAR), generate dense point clouds. Such applications often take advantage of more advanced data structures: for example, Triangulated Irregular Networks (TIN) that can be the base for Digital Evelation Models (DEM) and in particular for the generation of Digital Terrain Models (DTM). Point clouds can also be enriched by classification information that segments the points into ground, vegetation and building points (or other user-defined labels).</p>
<p>The definitions of some data structures may vary according to different sources. We will use the following terms within this tutorial:</p>
<ul>
<li>TIN: <em>Triangulated Irregular Network</em>, a 2D triangulation structure that connects 3D points based on their projections on the horizontal plane.</li>
<li>DSM: <em>Digital Surface Model</em>, a model of the whole scanned surface including buildings and vegetation. We use a TIN to store the DSM.</li>
<li>DTM: <em>Digital Terrain Model</em>, a model of the bare ground surface without objects like buildings or vegetation. We both use a TIN and a raster to store a DTM.</li>
<li>DEM: <em>Digital Elevation Model</em>, a more general term that includes both DSM and DTM.</li>
</ul>
<p>This tutorial illustrates the following scenario. From an input point cloud, we first compute a DSM stored as a TIN. Then, we filter out overly large facets that correspond either to building facades or to vegetation noise. Large components corresponding to the ground are kept. Holes are filled and the obtained DEM is remeshed. A raster DEM and a set of contour polylines are generated from it. Finally, supervised 3-label classification is performed to segment vegetation, building and group points.</p>
<h1><a class="anchor" id="TutorialGIS_TIN"></a>
Triangulated Irregular Network (TIN)</h1>
<p>CGAL provides several triangulation data structures and algorithms. A TIN can be generated by combining the 2D Delaunay triangulation with projection traits: the triangulation structure is computed using the 2D positions of the points along a selected plane (usually, the XY-plane), while the 3D positions of the points are kept for visualization and measurements.</p>
<p>A TIN data structure can thus simply be defined the following way:</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keyword">using</span> Kernel = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div><div class="line"><span class="keyword">using</span> Projection_traits = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Projection__traits__xy__3.html">CGAL::Projection_traits_xy_3&lt;Kernel&gt;</a>;</div><div class="line"><span class="keyword">using</span> Point_2 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>;</div><div class="line"><span class="keyword">using</span> Point_3 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ae82b7f4be77dd5b8819ebe419e4ae753">Kernel::Point_3</a>;</div><div class="line"><span class="keyword">using</span> Segment_3 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#aa43a461b2027ef7d99b776a7b03ef230">Kernel::Segment_3</a>;</div><div class="line"></div><div class="line"><span class="comment">// Triangulated Irregular Network</span></div><div class="line"><span class="keyword">using</span> TIN = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2&lt;Projection_traits&gt;</a>;</div><div class="line"></div></div><!-- fragment --> <h1><a class="anchor" id="TutorialGIS_DSM"></a>
Digital Surface Model (DSM)</h1>
<p>Point clouds in many formats (XYZ, OFF, PLY, LAS) can be easily loaded into a <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3</a></code> structure, using the stream operator. Generating a DSM stored in TIN is then straightforward:</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="comment">// Read points</span></div><div class="line">  std::ifstream ifile (fname, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3&lt;Point_3&gt;</a> points;</div><div class="line">  ifile &gt;&gt; points;</div><div class="line">  std::cerr &lt;&lt; points.size() &lt;&lt; <span class="stringliteral">" point(s) read"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Create DSM</span></div><div class="line">  TIN dsm (points.points().begin(), points.points().end());</div><div class="line"></div></div><!-- fragment --><p> Because the Delaunay triangulation of CGAL is a model of <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/classFaceGraph.html">FaceGraph</a></code>, it is straightforward to convert the generated TIN into a mesh structure such as <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh</a></code> and be saved into whatever formats are supported by such structure:</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="keyword">using</span> Mesh = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point_3&gt;</a>;</div><div class="line"></div><div class="line">  Mesh dsm_mesh;</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#ga2682fb7d5f4ff4eb65607ae4118e31bc">CGAL::copy_face_graph</a> (dsm, dsm_mesh);</div><div class="line">  std::ofstream dsm_ofile (<span class="stringliteral">"dsm.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (dsm_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (dsm_ofile, dsm_mesh);</div><div class="line">  dsm_ofile.close();</div><div class="line"></div></div><!-- fragment --><p> An example of a DSM computed this way on the San Fransisco data set (see <a class="el" href="tuto_gis.html#TutorialGIS_Reference">References</a>) is given in <a class="el" href="tuto_gis.html#fig__TutorialGISFigTIN">Figure 0.1</a>.</p>
<p><a class="anchor" id="fig__TutorialGISFigTIN"></a></p><div class="image">
<img src="tin.jpg" alt="tin.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_gis.html#fig__TutorialGISFigTIN">Figure 0.1</a> Input point cloud and output DSM.  </div> <br /> 
<h1><a class="anchor" id="TutorialGIS_DTM"></a>
Digital Terrain Model (DTM)</h1>
<p>The generated DSM is used as a base for DTM computation, that is a representation of the ground as another TIN after filtering non-ground points.</p>
<p>We propose, as an example, a simple DTM estimation decomposed in the following steps:</p>
<ol type="1">
<li>Thresholding the height of the facets to remove brutal changes of elevation</li>
<li>Clustering the other facets into connected components</li>
<li>Filtering all components smaller than a user-defined threshold</li>
</ol>
<p>This algorithm relies on 2 parameters: a height threshold that corresponds to the minimum height of a building, and a perimeter threshold that corresponds to the maximum size of a building on the 2D projection.</p>
<h2><a class="anchor" id="TutorialGIS_DTM_info"></a>
TIN With Info</h2>
<p>Because it takes advantage of the flexible CGAL Delaunay triangulation API, our TIN can be enriched with information on vertices and/or on faces. In our case, each vertex keeps track of the index of the corresponding point in the input point cloud (which will allow to filter ground points afterwards), and each face is given the index of its connected component.</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="keyword">auto</span> idx_to_point_with_info</div><div class="line">    = [&amp;](<span class="keyword">const</span> Point_set::Index&amp; idx) -&gt; std::pair&lt;Point_3, Point_set::Index&gt;</div><div class="line">      {</div><div class="line">        <span class="keywordflow">return</span> std::make_pair (points.point(idx), idx);</div><div class="line">      };</div><div class="line"></div><div class="line">  TIN_with_info tin_with_info</div><div class="line">    (boost::make_transform_iterator (points.begin(), idx_to_point_with_info),</div><div class="line">     boost::make_transform_iterator (points.end(), idx_to_point_with_info));</div><div class="line"></div></div><!-- fragment --> <h2><a class="anchor" id="TutorialGIS_DTM_components"></a>
Identifying Connected Components</h2>
<p>Connected components are identified through a flooding algorithm: from a seed face, all incident faces are inserted in the current connected component unless their heights exceed the user-defined threshold.</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="keywordtype">double</span> spacing = CGAL::compute_average_spacing&lt;Concurrency_tag&gt;(points, 6);</div><div class="line">  spacing *= 2;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> face_height</div><div class="line">    = [&amp;](<span class="keyword">const</span> TIN_with_info::Face_handle fh) -&gt; <span class="keywordtype">double</span></div><div class="line">      {</div><div class="line">        <span class="keywordtype">double</span> out = 0.;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++ i)</div><div class="line">          out = (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/group__nt__util.html#gad7dbfa919e255b52f36ea1512a92cb78">std::max</a>) (out, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">CGAL::abs</a>(fh-&gt;vertex(i)-&gt;point().z() - fh-&gt;vertex((i+1)%3)-&gt;point().z()));</div><div class="line">        <span class="keywordflow">return</span> out;</div><div class="line">      };</div><div class="line"></div><div class="line">  <span class="comment">// Initialize faces info</span></div><div class="line">  <span class="keywordflow">for</span> (TIN_with_info::Face_handle fh : tin_with_info.all_face_handles())</div><div class="line">    <span class="keywordflow">if</span> (tin_with_info.is_infinite(fh) || face_height(fh) &gt; spacing) <span class="comment">// Filtered faces are given info() = -2</span></div><div class="line">      fh-&gt;info() = -2;</div><div class="line">    <span class="keywordflow">else</span> <span class="comment">// Pending faces are given info() = -1;</span></div><div class="line">      fh-&gt;info() = -1;</div><div class="line"></div><div class="line">  <span class="comment">// Flooding algorithm</span></div><div class="line">  std::vector&lt;int&gt; component_size;</div><div class="line">  <span class="keywordflow">for</span> (TIN_with_info::Face_handle fh : tin_with_info.finite_face_handles())</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (fh-&gt;info() != -1)</div><div class="line">      <span class="keywordflow">continue</span>;</div><div class="line"></div><div class="line">    std::queue&lt;TIN_with_info::Face_handle&gt; todo;</div><div class="line">    todo.push(fh);</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> size = 0;</div><div class="line">    <span class="keywordflow">while</span> (!todo.empty())</div><div class="line">    {</div><div class="line">      TIN_with_info::Face_handle current = todo.front();</div><div class="line">      todo.pop();</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (current-&gt;info() != -1)</div><div class="line">        <span class="keywordflow">continue</span>;</div><div class="line">      current-&gt;info() = int(component_size.size());</div><div class="line">      ++ size;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++ i)</div><div class="line">        todo.push (current-&gt;neighbor(i));</div><div class="line">    }</div><div class="line"></div><div class="line">    component_size.push_back (size);</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; component_size.size() &lt;&lt; <span class="stringliteral">" connected component(s) found"</span> &lt;&lt; std::endl;</div><div class="line"></div></div><!-- fragment --><p> This TIN enriched with connected component information can be saved as a colored mesh:</p>
<div class="fragment"><div class="line"></div><div class="line">  Mesh tin_colored_mesh;</div><div class="line"></div><div class="line">  Mesh::Property_map&lt;Mesh::Face_index, CGAL::IO::Color&gt;</div><div class="line">    color_map = tin_colored_mesh.add_property_map&lt;Mesh::Face_index, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a>&gt;(<span class="stringliteral">"f:color"</span>).first;</div><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#ga2682fb7d5f4ff4eb65607ae4118e31bc">CGAL::copy_face_graph</a> (tin_with_info, tin_colored_mesh,</div><div class="line">                         CGAL::parameters::face_to_face_output_iterator</div><div class="line">                         (boost::make_function_output_iterator</div><div class="line">                          ([&amp;](<span class="keyword">const</span> std::pair&lt;TIN_with_info::Face_handle, Mesh::Face_index&gt;&amp; ff)</div><div class="line">                           {</div><div class="line">                             <span class="comment">// Color unassigned faces gray</span></div><div class="line">                             <span class="keywordflow">if</span> (ff.first-&gt;info() &lt; 0)</div><div class="line">                               color_map[ff.second] = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a>(128, 128, 128);</div><div class="line">                             <span class="keywordflow">else</span></div><div class="line">                             {</div><div class="line">                               <span class="comment">// Random color seeded by the component ID</span></div><div class="line">                               <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Generator.tag:../Generator/" href="../Generator/classCGAL_1_1Random.html">CGAL::Random</a> r (ff.first-&gt;info());</div><div class="line">                               color_map[ff.second] = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a> (r.get_int(64, 192),</div><div class="line">                                                                   r.get_int(64, 192),</div><div class="line">                                                                   r.get_int(64, 192));</div><div class="line">                             }</div><div class="line">                           })));</div><div class="line"></div><div class="line">  std::ofstream tin_colored_ofile (<span class="stringliteral">"colored_tin.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (tin_colored_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (tin_colored_ofile, tin_colored_mesh);</div><div class="line">  tin_colored_ofile.close();</div><div class="line"></div></div><!-- fragment --><p> An example of a TIN colored by connected components is given in <a class="el" href="tuto_gis.html#fig__TutorialGISFigComponents">Figure 0.2</a>.</p>
<p><a class="anchor" id="fig__TutorialGISFigComponents"></a></p><div class="image">
<img src="components.jpg" alt="components.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_gis.html#fig__TutorialGISFigComponents">Figure 0.2</a> TIN colored by connected components. Faces above height threshold are not assigned to any component and are displayed in gray.  </div> <br /> 
<h2><a class="anchor" id="TutorialGIS_DTM_filtering"></a>
Filtering</h2>
<p>Components smaller than the largest building can be removed this way:</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="keywordtype">int</span> min_size = int(points.size() / 2);</div><div class="line"></div><div class="line">  std::vector&lt;TIN_with_info::Vertex_handle&gt; to_remove;</div><div class="line">  <span class="keywordflow">for</span> (TIN_with_info::Vertex_handle vh : tin_with_info.finite_vertex_handles())</div><div class="line">  {</div><div class="line">    TIN_with_info::Face_circulator circ = tin_with_info.incident_faces (vh),</div><div class="line">      start = circ;</div><div class="line"></div><div class="line">    <span class="comment">// Remove a vertex if it's only adjacent to components smaller than threshold</span></div><div class="line">    <span class="keywordtype">bool</span> keep = <span class="keyword">false</span>;</div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (circ-&gt;info() &gt;= 0 &amp;&amp; component_size[std::size_t(circ-&gt;info())] &gt; min_size)</div><div class="line">      {</div><div class="line">        keep = <span class="keyword">true</span>;</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">while</span> (++ circ != start);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (!keep)</div><div class="line">      to_remove.push_back (vh);</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; to_remove.size() &lt;&lt; <span class="stringliteral">" vertices(s) will be removed after filtering"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (TIN_with_info::Vertex_handle vh : to_remove)</div><div class="line">    tin_with_info.remove (vh);</div><div class="line"></div></div><!-- fragment --> <h2><a class="anchor" id="Tutorial_DTM_hole_filling"></a>
Hole Filling and Remeshing</h2>
<p>Because simply removing vertices in the large areas covered by buildings results in large Delaunay faces that offer a poor 3D representation of the DTM, an additional step can help producing better shaped meshes: faces larger than a threshold are removed and filled with a hole filling algorithm that triangulates, refines and fairs the holes.</p>
<p>The following snippet copies the TIN into a mesh while filtering out overly large faces, then identifies the holes and fills them all except for the largest one (which is the outer hull).</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="comment">// Copy and keep track of overly large faces</span></div><div class="line">  Mesh dtm_mesh;</div><div class="line"></div><div class="line">  std::vector&lt;Mesh::Face_index&gt; face_selection;</div><div class="line">  Mesh::Property_map&lt;Mesh::Face_index, bool&gt; face_selection_map</div><div class="line">   = dtm_mesh.add_property_map&lt;Mesh::Face_index, <span class="keywordtype">bool</span>&gt;(<span class="stringliteral">"is_selected"</span>, <span class="keyword">false</span>).first;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> limit = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga07001b5ddc5c43096c811c91a306be9a">CGAL::square</a> (5 * spacing);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#ga2682fb7d5f4ff4eb65607ae4118e31bc">CGAL::copy_face_graph</a> (tin_with_info, dtm_mesh,</div><div class="line">                         CGAL::parameters::face_to_face_output_iterator</div><div class="line">                         (boost::make_function_output_iterator</div><div class="line">                          ([&amp;](<span class="keyword">const</span> std::pair&lt;TIN_with_info::Face_handle, Mesh::Face_index&gt;&amp; ff)</div><div class="line">                           {</div><div class="line">                             <span class="keywordtype">double</span> longest_edge = 0.;</div><div class="line">                             <span class="keywordtype">bool</span> border = <span class="keyword">false</span>;</div><div class="line">                             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++ i)</div><div class="line">                             {</div><div class="line">                               longest_edge = (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/group__nt__util.html#gad7dbfa919e255b52f36ea1512a92cb78">std::max</a>)(longest_edge, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">CGAL::squared_distance</a></div><div class="line">                                                         (ff.first-&gt;vertex((i+1)%3)-&gt;point(),</div><div class="line">                                                          ff.first-&gt;vertex((i+2)%3)-&gt;point()));</div><div class="line"></div><div class="line">                               TIN_with_info::Face_circulator circ</div><div class="line">                                 = tin_with_info.incident_faces (ff.first-&gt;vertex(i)),</div><div class="line">                                 start = circ;</div><div class="line">                               <span class="keywordflow">do</span></div><div class="line">                               {</div><div class="line">                                 <span class="keywordflow">if</span> (tin_with_info.is_infinite (circ))</div><div class="line">                                 {</div><div class="line">                                   border = <span class="keyword">true</span>;</div><div class="line">                                   <span class="keywordflow">break</span>;</div><div class="line">                                 }</div><div class="line">                               }</div><div class="line">                               <span class="keywordflow">while</span> (++ circ != start);</div><div class="line"></div><div class="line">                               <span class="keywordflow">if</span> (border)</div><div class="line">                                 <span class="keywordflow">break</span>;</div><div class="line">                             }</div><div class="line"></div><div class="line">                             <span class="comment">// Select if face is too big AND it's not</span></div><div class="line">                             <span class="comment">// on the border (to have closed holes)</span></div><div class="line">                             <span class="keywordflow">if</span> (!border &amp;&amp; longest_edge &gt; limit)</div><div class="line">                             {</div><div class="line">                               face_selection_map[ff.second] = <span class="keyword">true</span>;</div><div class="line">                               face_selection.push_back (ff.second);</div><div class="line">                             }</div><div class="line">                           })));</div><div class="line"></div><div class="line">  <span class="comment">// Save original DTM</span></div><div class="line">  std::ofstream dtm_ofile (<span class="stringliteral">"dtm.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (dtm_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (dtm_ofile, dtm_mesh);</div><div class="line">  dtm_ofile.close();</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; face_selection.size() &lt;&lt; <span class="stringliteral">" face(s) are selected for removal"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Expand face selection to keep a well formed 2-manifold mesh after removal</span></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLSelectionFct.html#ga6f8d338df28c24bbf93677f24f7bcbbe">CGAL::expand_face_selection_for_removal</a> (face_selection, dtm_mesh, face_selection_map);</div><div class="line">  face_selection.clear();</div><div class="line">  <span class="keywordflow">for</span> (Mesh::Face_index fi : faces(dtm_mesh))</div><div class="line">    <span class="keywordflow">if</span> (face_selection_map[fi])</div><div class="line">      face_selection.push_back(fi);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; face_selection.size() &lt;&lt; <span class="stringliteral">" face(s) are selected for removal after expansion"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (Mesh::Face_index fi : face_selection)</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLEulerOperations.html#gacfae7ff8e782da55b941e4487e86c738">CGAL::Euler::remove_face</a> (halfedge(fi, dtm_mesh), dtm_mesh);</div><div class="line">  dtm_mesh.collect_garbage();</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (!dtm_mesh.is_valid())</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid mesh!"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save filtered DTM</span></div><div class="line">  std::ofstream dtm_holes_ofile (<span class="stringliteral">"dtm_with_holes.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (dtm_holes_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (dtm_holes_ofile, dtm_mesh);</div><div class="line">  dtm_holes_ofile.close();</div><div class="line"></div><div class="line">  <span class="comment">// Get all holes</span></div><div class="line">  std::vector&lt;Mesh::Halfedge_index&gt; holes;</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PkgPolygonMeshProcessingRef.html#gafa9b682528c5dc2a4821d01193518d14">CGAL::Polygon_mesh_processing::extract_boundary_cycles</a> (dtm_mesh, std::back_inserter (holes));</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; holes.size() &lt;&lt; <span class="stringliteral">" hole(s) identified"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Identify outer hull (hole with maximum size)</span></div><div class="line">  <span class="keywordtype">double</span> max_size = 0.;</div><div class="line">  Mesh::Halfedge_index outer_hull;</div><div class="line">  <span class="keywordflow">for</span> (Mesh::Halfedge_index hi : holes)</div><div class="line">  {</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html">CGAL::Bbox_3</a> hole_bbox;</div><div class="line">    <span class="keywordflow">for</span> (Mesh::Halfedge_index haf : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLIterators.html#ga37229df31508a78eb4acdaf907e637e5">CGAL::halfedges_around_face</a>(hi, dtm_mesh))</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> Point_3&amp; p = dtm_mesh.point(target(haf, dtm_mesh));</div><div class="line">      hole_bbox += p.bbox();</div><div class="line">    }</div><div class="line">    <span class="keywordtype">double</span> size = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">CGAL::squared_distance</a> (Point_2(hole_bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#aab574470a2591f187553ca1166e682e1">xmin</a>(), hole_bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a2088e16a1f0a20e011e5b94c2e9c222a">ymin</a>()),</div><div class="line">                                          Point_2(hole_bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a3f5e323700e1509624a02d151237cc4c">xmax</a>(), hole_bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a9d06f61bd89faa841e011ff53edf745f">ymax</a>()));</div><div class="line">    <span class="keywordflow">if</span> (size &gt; max_size)</div><div class="line">    {</div><div class="line">      max_size = size;</div><div class="line">      outer_hull = hi;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Fill all holes except the bigest (which is the outer hull of the mesh)</span></div><div class="line">  <span class="keywordflow">for</span> (Mesh::Halfedge_index hi : holes)</div><div class="line">    <span class="keywordflow">if</span> (hi != outer_hull)</div><div class="line">      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__hole__filling__grp.html#ga16473e4861b13d1241edee68f596b153">CGAL::Polygon_mesh_processing::triangulate_refine_and_fair_hole</a></div><div class="line">        (dtm_mesh, hi, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Emptyset__iterator.html">CGAL::Emptyset_iterator</a>(), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Emptyset__iterator.html">CGAL::Emptyset_iterator</a>());</div><div class="line"></div><div class="line">  <span class="comment">// Save DTM with holes filled</span></div><div class="line">  std::ofstream dtm_filled_ofile (<span class="stringliteral">"dtm_filled.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (dtm_filled_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (dtm_filled_ofile, dtm_mesh);</div><div class="line">  dtm_filled_ofile.close();</div><div class="line"></div></div><!-- fragment --><p> Isotropic remeshing can also be performed as a final step in order to produce a more regular mesh that is not constrained by the shape of 2D Delaunay faces.</p>
<div class="fragment"><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__meshing__grp.html#gaa5cc92275df27f0baab2472ecbc4ea3f">CGAL::Polygon_mesh_processing::isotropic_remeshing</a> (faces(dtm_mesh), spacing, dtm_mesh);</div><div class="line"></div><div class="line">  std::ofstream dtm_remeshed_ofile (<span class="stringliteral">"dtm_remeshed.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (dtm_remeshed_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (dtm_remeshed_ofile, dtm_mesh);</div><div class="line">  dtm_remeshed_ofile.close();</div><div class="line"></div></div><!-- fragment --><p> <a class="el" href="tuto_gis.html#fig__TutorialGISFigProc">Figure 0.3</a> shows how these different steps affect the output mesh and <a class="el" href="tuto_gis.html#fig__TutorialGISFigDTM">Figure 0.4</a> shows the DTM isotropic mesh.</p>
<p><a class="anchor" id="fig__TutorialGISFigProc"></a></p><div class="image">
<img src="dtm_proc.jpg" alt="dtm_proc.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_gis.html#fig__TutorialGISFigProc">Figure 0.3</a> Raw DTM and postprocessing  </div> <br /> 
<p><a class="anchor" id="fig__TutorialGISFigDTM"></a></p><div class="image">
<img src="dtm.jpg" alt="dtm.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_gis.html#fig__TutorialGISFigDTM">Figure 0.4</a> Final DTM.  </div> <br /> 
<h1><a class="anchor" id="TutorialGIS_Raster"></a>
Rastering</h1>
<p>The TIN data structure can be combined with barycentric coordinates in order to interpolate and thus rasterize a height map at any resolution needed the information embedded in the vertices.</p>
<p>Because the latest two steps (hole filling and remeshing) were performed on a 3D mesh, the hypothesis that our DTM is a 2.5D representation may no longer be valid. We thus first rebuild a TIN using the vertices of the isotropic DTM mesh lastly computed.</p>
<p>The following snippet generates a raster image of the height in the form of rainbow ramp PPM file (simple bitmap format):</p>
<div class="fragment"><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html">CGAL::Bbox_3</a> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PkgPolygonMeshProcessingRef.html#gaf633ec6397f5f065b01462fe42235d56">bbox</a> = CGAL::bbox_3 (points.points().begin(), points.points().end());</div><div class="line"></div><div class="line">  <span class="comment">// Generate raster image 1920-pixels large</span></div><div class="line">  std::size_t width = 1920;</div><div class="line">  std::size_t height = std::size_t((bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a9d06f61bd89faa841e011ff53edf745f">ymax</a>() - bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a2088e16a1f0a20e011e5b94c2e9c222a">ymin</a>()) * 1920 / (bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a3f5e323700e1509624a02d151237cc4c">xmax</a>() - bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#aab574470a2591f187553ca1166e682e1">xmin</a>()));</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Rastering with resolution "</span> &lt;&lt; width &lt;&lt; <span class="stringliteral">"x"</span> &lt;&lt; height &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Use PPM format (Portable PixMap) for simplicity</span></div><div class="line">  std::ofstream raster_ofile (<span class="stringliteral">"raster.ppm"</span>, std::ios_base::binary);</div><div class="line"></div><div class="line">  <span class="comment">// PPM header</span></div><div class="line">  raster_ofile &lt;&lt; <span class="stringliteral">"P6"</span> &lt;&lt; std::endl <span class="comment">// magic number</span></div><div class="line">               &lt;&lt; width &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; height &lt;&lt; std::endl <span class="comment">// dimensions of the image</span></div><div class="line">               &lt;&lt; 255 &lt;&lt; std::endl; <span class="comment">// maximum color value</span></div><div class="line"></div><div class="line">  <span class="comment">// Use rainbow color ramp output</span></div><div class="line">  Color_ramp color_ramp;</div><div class="line"></div><div class="line">  <span class="comment">// Keeping track of location from one point to its neighbor allows</span></div><div class="line">  <span class="comment">// for fast locate in DT</span></div><div class="line">  TIN::Face_handle location;</div><div class="line"></div><div class="line">  <span class="comment">// Query each pixel of the image</span></div><div class="line">  <span class="keywordflow">for</span> (std::size_t y = 0; y &lt; height; ++ y)</div><div class="line">    <span class="keywordflow">for</span> (std::size_t x = 0; x &lt; width; ++ x)</div><div class="line">    {</div><div class="line">      Point_3 query (bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#aab574470a2591f187553ca1166e682e1">xmin</a>() + x * (bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a3f5e323700e1509624a02d151237cc4c">xmax</a>() - bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#aab574470a2591f187553ca1166e682e1">xmin</a>()) / <span class="keywordtype">double</span>(width),</div><div class="line">                     bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a2088e16a1f0a20e011e5b94c2e9c222a">ymin</a>() + (height-y) * (bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a9d06f61bd89faa841e011ff53edf745f">ymax</a>() - bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a2088e16a1f0a20e011e5b94c2e9c222a">ymin</a>()) / <span class="keywordtype">double</span>(height),</div><div class="line">                     0); <span class="comment">// not relevant for location in 2D</span></div><div class="line"></div><div class="line">      location = dtm_clean.locate (query, location);</div><div class="line"></div><div class="line">      <span class="comment">// Points outside the convex hull will be colored black</span></div><div class="line">      std::array&lt;unsigned char, 3&gt; colors { 0, 0, 0 };</div><div class="line">      <span class="keywordflow">if</span> (!dtm_clean.is_infinite(location))</div><div class="line">      {</div><div class="line">        std::array&lt;double, 3&gt; <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#gadd9f94997d1963426d38305192345564">barycentric_coordinates</a></div><div class="line">          = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#gadd9f94997d1963426d38305192345564">CGAL::Polygon_mesh_processing::barycentric_coordinates</a></div><div class="line">          (Point_2 (location-&gt;vertex(0)-&gt;point().x(), location-&gt;vertex(0)-&gt;point().y()),</div><div class="line">           Point_2 (location-&gt;vertex(1)-&gt;point().x(), location-&gt;vertex(1)-&gt;point().y()),</div><div class="line">           Point_2 (location-&gt;vertex(2)-&gt;point().x(), location-&gt;vertex(2)-&gt;point().y()),</div><div class="line">           Point_2 (query.x(), query.y()),</div><div class="line">           Kernel());</div><div class="line"></div><div class="line">        <span class="keywordtype">double</span> height_at_query</div><div class="line">          = (barycentric_coordinates[0] * location-&gt;vertex(0)-&gt;point().z()</div><div class="line">             + barycentric_coordinates[1] * location-&gt;vertex(1)-&gt;point().z()</div><div class="line">             + barycentric_coordinates[2] * location-&gt;vertex(2)-&gt;point().z());</div><div class="line"></div><div class="line">        <span class="comment">// Color ramp generates a color depending on a value from 0 to 1</span></div><div class="line">        <span class="keywordtype">double</span> height_ratio = (height_at_query - bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a6c55430abc7fda54571cf1075c7f2f8b">zmin</a>()) / (bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a98def8b9515f31ded759d781969ddaf6">zmax</a>() - bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a6c55430abc7fda54571cf1075c7f2f8b">zmin</a>());</div><div class="line">        colors = color_ramp.get(height_ratio);</div><div class="line">      }</div><div class="line">      raster_ofile.write (reinterpret_cast&lt;char*&gt;(&amp;colors), 3);</div><div class="line">    }</div><div class="line"></div><div class="line">  raster_ofile.close();</div><div class="line"></div></div><!-- fragment --><p> An example of a raster image with a rainbow ramp representing height is given in <a class="el" href="tuto_gis.html#fig__TutorialGISFigRastering">Figure 0.5</a>.</p>
<p><a class="anchor" id="fig__TutorialGISFigRastering"></a></p><div class="image">
<img src="raster.jpg" alt="raster.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_gis.html#fig__TutorialGISFigRastering">Figure 0.5</a> Raster visualisation of height using a rainbow ramp, ranging from light blue for low values to dark red for high values.  </div> <br /> 
<h1><a class="anchor" id="TutorialGIS_Contour"></a>
Contouring</h1>
<p>Extracting isolevels of a function defined on a TIN is another application that can be done with CGAL. We demonstrate here how to extract isolevels of height to build a topographic map.</p>
<h2><a class="anchor" id="TutorialGIS_Contour_Extraction"></a>
Building a Contour Graph</h2>
<p>The first step is to extract, from all faces of the triangulation, the section of each isolevel that goes through that face, in the form of a segment. The following functions allow to test if one isovalue does cross a face, and to extract it then:</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keywordtype">bool</span> face_has_isovalue (TIN::Face_handle fh, <span class="keywordtype">double</span> isovalue)</div><div class="line">{</div><div class="line">  <span class="keywordtype">bool</span> above = <span class="keyword">false</span>, below = <span class="keyword">false</span>;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++ i)</div><div class="line">  {</div><div class="line">    <span class="comment">// Face has isovalue if one of its vertices is above and another</span></div><div class="line">    <span class="comment">// one below</span></div><div class="line">    <span class="keywordflow">if</span> (fh-&gt;vertex(i)-&gt;point().z() &gt; isovalue)</div><div class="line">      above = <span class="keyword">true</span>;</div><div class="line">    <span class="keywordflow">if</span> (fh-&gt;vertex(i)-&gt;point().z() &lt; isovalue)</div><div class="line">      below = <span class="keyword">true</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> (above &amp;&amp; below);</div><div class="line">}</div><div class="line"></div><div class="line">Segment_3 isocontour_in_face (TIN::Face_handle fh, <span class="keywordtype">double</span> isovalue)</div><div class="line">{</div><div class="line">  Point_3 source;</div><div class="line">  Point_3 target;</div><div class="line">  <span class="keywordtype">bool</span> source_found = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++ i)</div><div class="line">  {</div><div class="line">    Point_3 p0 = fh-&gt;vertex((i+1) % 3)-&gt;point();</div><div class="line">    Point_3 p1 = fh-&gt;vertex((i+2) % 3)-&gt;point();</div><div class="line"></div><div class="line">    <span class="comment">// Check if the isovalue crosses segment (p0,p1)</span></div><div class="line">    <span class="keywordflow">if</span> ((p0.z() - isovalue) * (p1.z() - isovalue) &gt; 0)</div><div class="line">      <span class="keywordflow">continue</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> zbottom = p0.z();</div><div class="line">    <span class="keywordtype">double</span> ztop = p1.z();</div><div class="line">    <span class="keywordflow">if</span> (zbottom &gt; ztop)</div><div class="line">    {</div><div class="line">      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polynomial.tag:../Polynomial/" href="../Polynomial/group__PkgPolynomialFunctions.html#gaa555a2d0a5bf3730c337f08f07356c07">std::swap</a> (zbottom, ztop);</div><div class="line">      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polynomial.tag:../Polynomial/" href="../Polynomial/group__PkgPolynomialFunctions.html#gaa555a2d0a5bf3730c337f08f07356c07">std::swap</a> (p0, p1);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Compute position of segment vertex</span></div><div class="line">    <span class="keywordtype">double</span> ratio = (isovalue - zbottom) / (ztop - zbottom);</div><div class="line">    Point_3 p = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__barycenter__grp.html#ga43dafb654e67589a55dcf5b13092966b">CGAL::barycenter</a> (p0, (1 - ratio), p1,ratio);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (source_found)</div><div class="line">      target = p;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      source = p;</div><div class="line">      source_found = <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> Segment_3 (source, target);</div><div class="line">}</div><div class="line"></div><div class="line"></div></div><!-- fragment --><p> From these functions, we can create a graph of segments to process later into a set of polylines. To do so, we use the <a href="https://www.boost.org/doc/libs/1_72_0/libs/graph/doc/adjacency_list.html">boost::adjacency_list</a> structure and keep track of a mapping from the positions of the end points to the vertices of the graph.</p>
<p>The following code computes 50 isovalues evenly distributed between the minimum and maximum heights of the point cloud and creates a graph containing all isolevels:</p>
<div class="fragment"><div class="line"></div><div class="line">  std::array&lt;double, 50&gt; isovalues; <span class="comment">// Contour 50 isovalues</span></div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; isovalues.size(); ++ i)</div><div class="line">    isovalues[i] = bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a6c55430abc7fda54571cf1075c7f2f8b">zmin</a>() + ((i+1) * (bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a98def8b9515f31ded759d781969ddaf6">zmax</a>() - bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a6c55430abc7fda54571cf1075c7f2f8b">zmin</a>()) / (isovalues.size() - 2));</div><div class="line"></div><div class="line">  <span class="comment">// First find on each face if they are crossed by some isovalues and</span></div><div class="line">  <span class="comment">// extract segments in a graph</span></div><div class="line">  <span class="keyword">using</span> Segment_graph = boost::adjacency_list&lt;boost::listS, boost::vecS, boost::undirectedS, Point_3&gt;;</div><div class="line">  Segment_graph graph;</div><div class="line">  <span class="keyword">using</span> Map_p2v = std::map&lt;Point_3, Segment_graph::vertex_descriptor&gt;;</div><div class="line">  Map_p2v map_p2v;</div><div class="line">  <span class="keywordflow">for</span> (TIN::Face_handle vh : dtm_clean.finite_face_handles())</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">double</span> iv : isovalues)</div><div class="line">      <span class="keywordflow">if</span> (face_has_isovalue (vh, iv))</div><div class="line">      {</div><div class="line">        Segment_3 segment = isocontour_in_face (vh, iv);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> Point_3&amp; p : { segment.source(), segment.target() })</div><div class="line">        {</div><div class="line">          <span class="comment">// Only insert end points of segments once to get a well connected graph</span></div><div class="line">          Map_p2v::iterator iter;</div><div class="line">          <span class="keywordtype">bool</span> inserted;</div><div class="line">          std::tie (iter, inserted) = map_p2v.insert (std::make_pair (p, Segment_graph::vertex_descriptor()));</div><div class="line">          <span class="keywordflow">if</span> (inserted)</div><div class="line">          {</div><div class="line">            iter-&gt;second = boost::add_vertex (graph);</div><div class="line">            graph[iter-&gt;second] = p;</div><div class="line">          }</div><div class="line">        }</div><div class="line">        <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLEulerOperations.html#ga4661f850bc60686efeae2fc9d2ec3e65">boost::add_edge</a> (map_p2v[segment.source()], map_p2v[segment.target()], graph);</div><div class="line">      }</div><div class="line"></div></div><!-- fragment --> <h2><a class="anchor" id="TutorialGIS_Contour_Splitting"></a>
Splitting Into Polylines</h2>
<p>Once the graph is created, splitting it into polylines is easily performed using the function <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLPartition.html#ga99ea6bf193f1194db5e523e713c82fb9"><code>CGAL::split_graph_into_polylines()</code> </a>:</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="comment">// Split segments into polylines</span></div><div class="line">  std::vector&lt;std::vector&lt;Point_3&gt; &gt; polylines;</div><div class="line">  Polylines_visitor&lt;Segment_graph&gt; visitor (graph, polylines);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLPartition.html#ga99ea6bf193f1194db5e523e713c82fb9">CGAL::split_graph_into_polylines</a> (graph, visitor);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; polylines.size() &lt;&lt; <span class="stringliteral">" polylines computed, with "</span></div><div class="line">            &lt;&lt; map_p2v.size() &lt;&lt; <span class="stringliteral">" vertices in total"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Output to WKT file</span></div><div class="line">  std::ofstream contour_ofile (<span class="stringliteral">"contour.wkt"</span>);</div><div class="line">  contour_ofile.precision(18);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsWKT.html#ga013d6cd500473657f41c44c9df43c511">CGAL::IO::write_multi_linestring_WKT</a> (contour_ofile, polylines);</div><div class="line">  contour_ofile.close();</div><div class="line"></div></div><!-- fragment --><p> This function requires a visitor which is called when starting a polyline, when adding a point to it and when ending it. Defining such a class is straightforward in our case:</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph&gt;</div><div class="line"><span class="keyword">class </span>Polylines_visitor</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">  std::vector&lt;std::vector&lt;Point_3&gt; &gt;&amp; polylines;</div><div class="line">  Graph&amp; graph;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">  Polylines_visitor (Graph&amp; graph, std::vector&lt;std::vector&lt;Point_3&gt; &gt;&amp; polylines)</div><div class="line">    : polylines (polylines), graph(graph) { }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> start_new_polyline()</div><div class="line">  {</div><div class="line">    polylines.push_back (std::vector&lt;Point_3&gt;());</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> add_node (<span class="keyword">typename</span> Graph::vertex_descriptor vd)</div><div class="line">  {</div><div class="line">    polylines.back().push_back (graph[vd]);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> end_polyline()</div><div class="line">  {</div><div class="line">    <span class="comment">// filter small polylines</span></div><div class="line">    <span class="keywordflow">if</span> (polylines.back().size() &lt; 50)</div><div class="line">      polylines.pop_back();</div><div class="line">  }</div><div class="line">};</div><div class="line"></div></div><!-- fragment --> <h2><a class="anchor" id="TutorialGIS_Contour_Simplifying"></a>
Simplifying</h2>
<p>Because the output is quite noisy, users may want to simplify the polylines. CGAL provides a polyline simplification algorithm that guarantees that two polylines won't intersect after simplification. This algorithm takes advantage of the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Constrained__triangulation__plus__2.html">CGAL::Constrained_triangulation_plus_2</a></code>, which embeds polylines as a set of constraints:</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keyword">namespace </span>PS = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polyline_simplification_2.tag:../Polyline_simplification_2/" href="../Polyline_simplification_2/namespaceCGAL_1_1Polyline__simplification__2.html">CGAL::Polyline_simplification_2</a>;</div><div class="line"><span class="keyword">using</span> CDT_vertex_base = PS::Vertex_base_2&lt;Projection_traits&gt;;</div><div class="line"><span class="keyword">using</span> CDT_face_base = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Constrained__triangulation__face__base__2.html">CGAL::Constrained_triangulation_face_base_2&lt;Projection_traits&gt;</a>;</div><div class="line"><span class="keyword">using</span> CDT_TDS = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/TDS_2.tag:../TDS_2/" href="../TDS_2/classCGAL_1_1Triangulation__data__structure__2.html">CGAL::Triangulation_data_structure_2&lt;CDT_vertex_base, CDT_face_base&gt;</a>;</div><div class="line"><span class="keyword">using</span> CDT = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Constrained__Delaunay__triangulation__2.html">CGAL::Constrained_Delaunay_triangulation_2&lt;Projection_traits, CDT_TDS&gt;</a>;</div><div class="line"><span class="keyword">using</span> CTP = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Constrained__triangulation__plus__2.html">CGAL::Constrained_triangulation_plus_2&lt;CDT&gt;</a>;</div><div class="line"></div></div><!-- fragment --><p> The following code simplifies the polyline set based on the squared distance to the original polylines, stopping when no more vertex can be removed without going farther than 4 times the average spacing.</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="comment">// Construct constrained Delaunay triangulation with polylines as constraints</span></div><div class="line">  CTP ctp;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> std::vector&lt;Point_3&gt;&amp; poly : polylines)</div><div class="line">    ctp.insert_constraint (poly.begin(), poly.end());</div><div class="line"></div><div class="line">  <span class="comment">// Simplification algorithm with limit on distance</span></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga5339b0f11fdc9babbc5ca0b33f4a982c">PS::simplify</a> (ctp, PS::Squared_distance_cost(), PS::Stop_above_cost_threshold (16 * spacing * spacing));</div><div class="line"></div><div class="line">  polylines.clear();</div><div class="line">  <span class="keywordflow">for</span> (CTP::Constraint_id cid : ctp.constraints())</div><div class="line">  {</div><div class="line">    polylines.push_back (std::vector&lt;Point_3&gt;());</div><div class="line">    polylines.back().reserve (ctp.vertices_in_constraint (cid).size());</div><div class="line">    <span class="keywordflow">for</span> (CTP::Vertex_handle vh : ctp.vertices_in_constraint(cid))</div><div class="line">      polylines.back().push_back (vh-&gt;point());</div><div class="line">  }</div><div class="line"></div><div class="line">  std::size_t nb_vertices</div><div class="line">    = std::accumulate (polylines.begin(), polylines.end(), std::size_t(0),</div><div class="line">                       [](std::size_t size, <span class="keyword">const</span> std::vector&lt;Point_3&gt;&amp; poly) -&gt; std::size_t</div><div class="line">                       { <span class="keywordflow">return</span> size + poly.size(); });</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; nb_vertices</div><div class="line">            &lt;&lt; <span class="stringliteral">" vertices remaining after simplification ("</span></div><div class="line">            &lt;&lt; 100. * (nb_vertices / double(map_p2v.size())) &lt;&lt; <span class="stringliteral">"%)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Output to WKT file</span></div><div class="line">  std::ofstream simplified_ofile (<span class="stringliteral">"simplified.wkt"</span>);</div><div class="line">  simplified_ofile.precision(18);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsWKT.html#ga013d6cd500473657f41c44c9df43c511">CGAL::IO::write_multi_linestring_WKT</a> (simplified_ofile, polylines);</div><div class="line">  simplified_ofile.close();</div><div class="line"></div></div><!-- fragment --><p> Examples of contours and simplifications are given in <a class="el" href="tuto_gis.html#fig__TutorialGISFigContours">Figure 0.6</a>.</p>
<p><a class="anchor" id="fig__TutorialGISFigContours"></a></p><div class="image">
<img src="contours.png" alt="contours.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_gis.html#fig__TutorialGISFigContours">Figure 0.6</a> Contouring using 50 isovalues evenly spaced. Top: original contouring using 148k vertices and simplification with a tolerance equal to the average spacing of the input point cloud (3.4% of the original polyline vertices remaining). Bottom: simplification with tolerance 4 times the average spacing (1.3% of vertices remaining) and with tolerance 10 times the average spacing (0.9% of vertices remaining). Polylines are intersection-free in all cases.  </div> <br /> 
<h1><a class="anchor" id="TutorialGIS_Classify"></a>
Classifying</h1>
<p>CGAL provides a package Classification which can be used to segment a point cloud into a user-defined label set. The state-of-the-art classifier currently available in CGAL is the random forest from ETHZ. As it is a supervised classifier, a training set is needed.</p>
<p>The following snippet shows how to use some manually selected training set to train a random forest classifier and compute a classification regularized by a graph cut algorithm:</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="comment">// Get training from input</span></div><div class="line">  Point_set::Property_map&lt;int&gt; training_map;</div><div class="line">  <span class="keywordtype">bool</span> training_found;</div><div class="line">  std::tie (training_map, training_found) = points.property_map&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">"training"</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (training_found)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Classifying ground/vegetation/building"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// Create labels</span></div><div class="line">    Classification::Label_set labels ({ <span class="stringliteral">"ground"</span>, <span class="stringliteral">"vegetation"</span>, <span class="stringliteral">"building"</span> });</div><div class="line"></div><div class="line">    <span class="comment">// Generate features</span></div><div class="line">    Classification::Feature_set <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Mesh_3.tag:../Mesh_3/" href="../Mesh_3/group__PkgMesh3Parameters.html#ga0a990b28d55157c62d4bfd2624d408af">features</a>;</div><div class="line">    Classification::Point_set_feature_generator&lt;Kernel, Point_set, Point_set::Point_map&gt;</div><div class="line">      generator (points, points.point_map(), 5); <span class="comment">// 5 scales</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef CGAL_LINKED_WITH_TBB</span></div><div class="line">    <span class="comment">// If TBB is used, features can be computed in parallel</span></div><div class="line">    features.begin_parallel_additions();</div><div class="line">    generator.generate_point_based_features (features);</div><div class="line">    features.end_parallel_additions();</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    generator.generate_point_based_features (features);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">    <span class="comment">// Train a random forest classifier</span></div><div class="line">    Classification::ETHZ::Random_forest_classifier classifier (labels, features);</div><div class="line">    classifier.train (points.range(training_map));</div><div class="line"></div><div class="line">    <span class="comment">// Classify with graphcut regularization</span></div><div class="line">    Point_set::Property_map&lt;int&gt; label_map = points.add_property_map&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">"labels"</span>).first;</div><div class="line">    Classification::classify_with_graphcut&lt;Concurrency_tag&gt;</div><div class="line">      (points, points.point_map(), labels, classifier,</div><div class="line">       generator.neighborhood().k_neighbor_query(12), <span class="comment">// regularize on 12-neighbors graph</span></div><div class="line">       0.5f, <span class="comment">// graphcut weight</span></div><div class="line">       12, <span class="comment">// Subdivide to speed-up process</span></div><div class="line">       label_map);</div><div class="line"></div><div class="line">    <span class="comment">// Evaluate</span></div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Mean IoU on training data = "</span></div><div class="line">              &lt;&lt; Classification::Evaluation(labels,</div><div class="line">                                            points.range(training_map),</div><div class="line">                                            points.range(label_map)).mean_intersection_over_union() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// Save the classified point set</span></div><div class="line">    std::ofstream classified_ofile (<span class="stringliteral">"classified.ply"</span>);</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (classified_ofile);</div><div class="line">    classified_ofile &lt;&lt; points;</div><div class="line">    classified_ofile.close();</div><div class="line">  }</div><div class="line"></div></div><!-- fragment --><p> An example of training set and resulting classification is given in <a class="el" href="tuto_gis.html#fig__TutorialGISFigClassif">Figure 0.7</a>.</p>
<p><a class="anchor" id="fig__TutorialGISFigClassif"></a></p><div class="image">
<img src="classif_tuto.jpg" alt="classif_tuto.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_gis.html#fig__TutorialGISFigClassif">Figure 0.7</a> Top: a slice of the point cloud classified by hand. Bottom: a classification regularized by graph cut after training on 3 manually classified slices.  </div> <br /> 
<h1><a class="anchor" id="TutorialGIS_Code"></a>
Full Code Example</h1>
<p>All the code snippets used in this tutorial can be assembled to create a full GIS pipeline (provided the correct <em>includes</em> are used). We give a full code example which achieves all the steps described in this tutorial.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Projection_traits_xy_3.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Delaunay_triangulation_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Triangulation_vertex_base_with_info_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Triangulation_face_base_with_info_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/graph_traits_Delaunay_triangulation_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/copy_face_graph.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3/IO.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/compute_average_spacing.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/locate.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/triangulate_hole.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/border.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/remesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/graph/adjacency_list.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/split_graph_into_polylines.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/WKT.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Constrained_Delaunay_triangulation_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Constrained_triangulation_plus_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyline_simplification_2/simplify.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyline_simplification_2/Squared_distance_cost.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Classification.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Random.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;queue&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "include/Color_ramp.h"</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">using</span> Kernel = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div><div class="line"><span class="keyword">using</span> Projection_traits = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Projection__traits__xy__3.html">CGAL::Projection_traits_xy_3&lt;Kernel&gt;</a>;</div><div class="line"><span class="keyword">using</span> Point_2 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>;</div><div class="line"><span class="keyword">using</span> Point_3 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ae82b7f4be77dd5b8819ebe419e4ae753">Kernel::Point_3</a>;</div><div class="line"><span class="keyword">using</span> Segment_3 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#aa43a461b2027ef7d99b776a7b03ef230">Kernel::Segment_3</a>;</div><div class="line"></div><div class="line"><span class="comment">// Triangulated Irregular Network</span></div><div class="line"><span class="keyword">using</span> TIN = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2&lt;Projection_traits&gt;</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Triangulated Irregular Network (with info)</span></div><div class="line"><span class="keyword">using</span> Point_set = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3&lt;Point_3&gt;</a>;</div><div class="line"><span class="keyword">using</span> Vbi = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Triangulation__vertex__base__with__info__2.html">CGAL::Triangulation_vertex_base_with_info_2 &lt;Point_set::Index, Projection_traits&gt;</a>;</div><div class="line"><span class="keyword">using</span> Fbi = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Triangulation__face__base__with__info__2.html">CGAL::Triangulation_face_base_with_info_2&lt;int, Projection_traits&gt;</a>;</div><div class="line"><span class="keyword">using</span> TDS = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/TDS_2.tag:../TDS_2/" href="../TDS_2/classCGAL_1_1Triangulation__data__structure__2.html">CGAL::Triangulation_data_structure_2&lt;Vbi, Fbi&gt;</a>;</div><div class="line"><span class="keyword">using</span> TIN_with_info = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2&lt;Projection_traits, TDS&gt;</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Classification = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Classification.tag:../Classification/" href="../Classification/namespaceCGAL_1_1Classification.html">CGAL::Classification</a>;</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef CGAL_LINKED_WITH_TBB</span></div><div class="line"><span class="keyword">using</span> Concurrency_tag = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__tag.html">CGAL::Parallel_tag</a>;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line"><span class="keyword">using</span> Concurrency_tag = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Sequential__tag.html">CGAL::Sequential_tag</a>;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> face_has_isovalue (TIN::Face_handle fh, <span class="keywordtype">double</span> isovalue)</div><div class="line">{</div><div class="line">  <span class="keywordtype">bool</span> above = <span class="keyword">false</span>, below = <span class="keyword">false</span>;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++ i)</div><div class="line">  {</div><div class="line">    <span class="comment">// Face has isovalue if one of its vertices is above and another</span></div><div class="line">    <span class="comment">// one below</span></div><div class="line">    <span class="keywordflow">if</span> (fh-&gt;vertex(i)-&gt;point().z() &gt; isovalue)</div><div class="line">      above = <span class="keyword">true</span>;</div><div class="line">    <span class="keywordflow">if</span> (fh-&gt;vertex(i)-&gt;point().z() &lt; isovalue)</div><div class="line">      below = <span class="keyword">true</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> (above &amp;&amp; below);</div><div class="line">}</div><div class="line"></div><div class="line">Segment_3 isocontour_in_face (TIN::Face_handle fh, <span class="keywordtype">double</span> isovalue)</div><div class="line">{</div><div class="line">  Point_3 source;</div><div class="line">  Point_3 target;</div><div class="line">  <span class="keywordtype">bool</span> source_found = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++ i)</div><div class="line">  {</div><div class="line">    Point_3 p0 = fh-&gt;vertex((i+1) % 3)-&gt;point();</div><div class="line">    Point_3 p1 = fh-&gt;vertex((i+2) % 3)-&gt;point();</div><div class="line"></div><div class="line">    <span class="comment">// Check if the isovalue crosses segment (p0,p1)</span></div><div class="line">    <span class="keywordflow">if</span> ((p0.z() - isovalue) * (p1.z() - isovalue) &gt; 0)</div><div class="line">      <span class="keywordflow">continue</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> zbottom = p0.z();</div><div class="line">    <span class="keywordtype">double</span> ztop = p1.z();</div><div class="line">    <span class="keywordflow">if</span> (zbottom &gt; ztop)</div><div class="line">    {</div><div class="line">      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polynomial.tag:../Polynomial/" href="../Polynomial/group__PkgPolynomialFunctions.html#gaa555a2d0a5bf3730c337f08f07356c07">std::swap</a> (zbottom, ztop);</div><div class="line">      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polynomial.tag:../Polynomial/" href="../Polynomial/group__PkgPolynomialFunctions.html#gaa555a2d0a5bf3730c337f08f07356c07">std::swap</a> (p0, p1);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Compute position of segment vertex</span></div><div class="line">    <span class="keywordtype">double</span> ratio = (isovalue - zbottom) / (ztop - zbottom);</div><div class="line">    Point_3 p = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__barycenter__grp.html#ga43dafb654e67589a55dcf5b13092966b">CGAL::barycenter</a> (p0, (1 - ratio), p1,ratio);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (source_found)</div><div class="line">      target = p;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      source = p;</div><div class="line">      source_found = <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> Segment_3 (source, target);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph&gt;</div><div class="line"><span class="keyword">class </span>Polylines_visitor</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">  std::vector&lt;std::vector&lt;Point_3&gt; &gt;&amp; polylines;</div><div class="line">  Graph&amp; graph;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">  Polylines_visitor (Graph&amp; graph, std::vector&lt;std::vector&lt;Point_3&gt; &gt;&amp; polylines)</div><div class="line">    : polylines (polylines), graph(graph) { }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> start_new_polyline()</div><div class="line">  {</div><div class="line">    polylines.push_back (std::vector&lt;Point_3&gt;());</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> add_node (<span class="keyword">typename</span> Graph::vertex_descriptor vd)</div><div class="line">  {</div><div class="line">    polylines.back().push_back (graph[vd]);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> end_polyline()</div><div class="line">  {</div><div class="line">    <span class="comment">// filter small polylines</span></div><div class="line">    <span class="keywordflow">if</span> (polylines.back().size() &lt; 50)</div><div class="line">      polylines.pop_back();</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>PS = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polyline_simplification_2.tag:../Polyline_simplification_2/" href="../Polyline_simplification_2/namespaceCGAL_1_1Polyline__simplification__2.html">CGAL::Polyline_simplification_2</a>;</div><div class="line"><span class="keyword">using</span> CDT_vertex_base = PS::Vertex_base_2&lt;Projection_traits&gt;;</div><div class="line"><span class="keyword">using</span> CDT_face_base = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Constrained__triangulation__face__base__2.html">CGAL::Constrained_triangulation_face_base_2&lt;Projection_traits&gt;</a>;</div><div class="line"><span class="keyword">using</span> CDT_TDS = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/TDS_2.tag:../TDS_2/" href="../TDS_2/classCGAL_1_1Triangulation__data__structure__2.html">CGAL::Triangulation_data_structure_2&lt;CDT_vertex_base, CDT_face_base&gt;</a>;</div><div class="line"><span class="keyword">using</span> CDT = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Constrained__Delaunay__triangulation__2.html">CGAL::Constrained_Delaunay_triangulation_2&lt;Projection_traits, CDT_TDS&gt;</a>;</div><div class="line"><span class="keyword">using</span> CTP = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Constrained__triangulation__plus__2.html">CGAL::Constrained_triangulation_plus_2&lt;CDT&gt;</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname = argc != 2 ? <a class="code" href="namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/b9_training.ply"</span>) : argv[1];</div><div class="line">  <span class="keywordflow">if</span> (argc != 2)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Usage: "</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">" points.ply"</span> &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Running with default value "</span> &lt;&lt; fname &lt;&lt; <span class="stringliteral">"\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Read points</span></div><div class="line">  std::ifstream ifile (fname, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3&lt;Point_3&gt;</a> points;</div><div class="line">  ifile &gt;&gt; points;</div><div class="line">  std::cerr &lt;&lt; points.size() &lt;&lt; <span class="stringliteral">" point(s) read"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Create DSM</span></div><div class="line">  TIN dsm (points.points().begin(), points.points().end());</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">using</span> Mesh = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point_3&gt;</a>;</div><div class="line"></div><div class="line">  Mesh dsm_mesh;</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#ga2682fb7d5f4ff4eb65607ae4118e31bc">CGAL::copy_face_graph</a> (dsm, dsm_mesh);</div><div class="line">  std::ofstream dsm_ofile (<span class="stringliteral">"dsm.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (dsm_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (dsm_ofile, dsm_mesh);</div><div class="line">  dsm_ofile.close();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">auto</span> idx_to_point_with_info</div><div class="line">    = [&amp;](<span class="keyword">const</span> Point_set::Index&amp; idx) -&gt; std::pair&lt;Point_3, Point_set::Index&gt;</div><div class="line">      {</div><div class="line">        <span class="keywordflow">return</span> std::make_pair (points.point(idx), idx);</div><div class="line">      };</div><div class="line"></div><div class="line">  TIN_with_info tin_with_info</div><div class="line">    (boost::make_transform_iterator (points.begin(), idx_to_point_with_info),</div><div class="line">     boost::make_transform_iterator (points.end(), idx_to_point_with_info));</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> spacing = CGAL::compute_average_spacing&lt;Concurrency_tag&gt;(points, 6);</div><div class="line">  spacing *= 2;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> face_height</div><div class="line">    = [&amp;](<span class="keyword">const</span> TIN_with_info::Face_handle fh) -&gt; <span class="keywordtype">double</span></div><div class="line">      {</div><div class="line">        <span class="keywordtype">double</span> out = 0.;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++ i)</div><div class="line">          out = (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/group__nt__util.html#gad7dbfa919e255b52f36ea1512a92cb78">std::max</a>) (out, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">CGAL::abs</a>(fh-&gt;vertex(i)-&gt;point().z() - fh-&gt;vertex((i+1)%3)-&gt;point().z()));</div><div class="line">        <span class="keywordflow">return</span> out;</div><div class="line">      };</div><div class="line"></div><div class="line">  <span class="comment">// Initialize faces info</span></div><div class="line">  <span class="keywordflow">for</span> (TIN_with_info::Face_handle fh : tin_with_info.all_face_handles())</div><div class="line">    <span class="keywordflow">if</span> (tin_with_info.is_infinite(fh) || face_height(fh) &gt; spacing) <span class="comment">// Filtered faces are given info() = -2</span></div><div class="line">      fh-&gt;info() = -2;</div><div class="line">    <span class="keywordflow">else</span> <span class="comment">// Pending faces are given info() = -1;</span></div><div class="line">      fh-&gt;info() = -1;</div><div class="line"></div><div class="line">  <span class="comment">// Flooding algorithm</span></div><div class="line">  std::vector&lt;int&gt; component_size;</div><div class="line">  <span class="keywordflow">for</span> (TIN_with_info::Face_handle fh : tin_with_info.finite_face_handles())</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (fh-&gt;info() != -1)</div><div class="line">      <span class="keywordflow">continue</span>;</div><div class="line"></div><div class="line">    std::queue&lt;TIN_with_info::Face_handle&gt; todo;</div><div class="line">    todo.push(fh);</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> size = 0;</div><div class="line">    <span class="keywordflow">while</span> (!todo.empty())</div><div class="line">    {</div><div class="line">      TIN_with_info::Face_handle current = todo.front();</div><div class="line">      todo.pop();</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (current-&gt;info() != -1)</div><div class="line">        <span class="keywordflow">continue</span>;</div><div class="line">      current-&gt;info() = int(component_size.size());</div><div class="line">      ++ size;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++ i)</div><div class="line">        todo.push (current-&gt;neighbor(i));</div><div class="line">    }</div><div class="line"></div><div class="line">    component_size.push_back (size);</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; component_size.size() &lt;&lt; <span class="stringliteral">" connected component(s) found"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  Mesh tin_colored_mesh;</div><div class="line"></div><div class="line">  Mesh::Property_map&lt;Mesh::Face_index, CGAL::IO::Color&gt;</div><div class="line">    color_map = tin_colored_mesh.add_property_map&lt;Mesh::Face_index, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a>&gt;(<span class="stringliteral">"f:color"</span>).first;</div><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#ga2682fb7d5f4ff4eb65607ae4118e31bc">CGAL::copy_face_graph</a> (tin_with_info, tin_colored_mesh,</div><div class="line">                         CGAL::parameters::face_to_face_output_iterator</div><div class="line">                         (boost::make_function_output_iterator</div><div class="line">                          ([&amp;](<span class="keyword">const</span> std::pair&lt;TIN_with_info::Face_handle, Mesh::Face_index&gt;&amp; ff)</div><div class="line">                           {</div><div class="line">                             <span class="comment">// Color unassigned faces gray</span></div><div class="line">                             <span class="keywordflow">if</span> (ff.first-&gt;info() &lt; 0)</div><div class="line">                               color_map[ff.second] = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a>(128, 128, 128);</div><div class="line">                             <span class="keywordflow">else</span></div><div class="line">                             {</div><div class="line">                               <span class="comment">// Random color seeded by the component ID</span></div><div class="line">                               <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Generator.tag:../Generator/" href="../Generator/classCGAL_1_1Random.html">CGAL::Random</a> r (ff.first-&gt;info());</div><div class="line">                               color_map[ff.second] = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a> (r.get_int(64, 192),</div><div class="line">                                                                   r.get_int(64, 192),</div><div class="line">                                                                   r.get_int(64, 192));</div><div class="line">                             }</div><div class="line">                           })));</div><div class="line"></div><div class="line">  std::ofstream tin_colored_ofile (<span class="stringliteral">"colored_tin.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (tin_colored_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (tin_colored_ofile, tin_colored_mesh);</div><div class="line">  tin_colored_ofile.close();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> min_size = int(points.size() / 2);</div><div class="line"></div><div class="line">  std::vector&lt;TIN_with_info::Vertex_handle&gt; to_remove;</div><div class="line">  <span class="keywordflow">for</span> (TIN_with_info::Vertex_handle vh : tin_with_info.finite_vertex_handles())</div><div class="line">  {</div><div class="line">    TIN_with_info::Face_circulator circ = tin_with_info.incident_faces (vh),</div><div class="line">      start = circ;</div><div class="line"></div><div class="line">    <span class="comment">// Remove a vertex if it's only adjacent to components smaller than threshold</span></div><div class="line">    <span class="keywordtype">bool</span> keep = <span class="keyword">false</span>;</div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (circ-&gt;info() &gt;= 0 &amp;&amp; component_size[std::size_t(circ-&gt;info())] &gt; min_size)</div><div class="line">      {</div><div class="line">        keep = <span class="keyword">true</span>;</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">while</span> (++ circ != start);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (!keep)</div><div class="line">      to_remove.push_back (vh);</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; to_remove.size() &lt;&lt; <span class="stringliteral">" vertices(s) will be removed after filtering"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (TIN_with_info::Vertex_handle vh : to_remove)</div><div class="line">    tin_with_info.remove (vh);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Copy and keep track of overly large faces</span></div><div class="line">  Mesh dtm_mesh;</div><div class="line"></div><div class="line">  std::vector&lt;Mesh::Face_index&gt; face_selection;</div><div class="line">  Mesh::Property_map&lt;Mesh::Face_index, bool&gt; face_selection_map</div><div class="line">   = dtm_mesh.add_property_map&lt;Mesh::Face_index, <span class="keywordtype">bool</span>&gt;(<span class="stringliteral">"is_selected"</span>, <span class="keyword">false</span>).first;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> limit = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga07001b5ddc5c43096c811c91a306be9a">CGAL::square</a> (5 * spacing);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#ga2682fb7d5f4ff4eb65607ae4118e31bc">CGAL::copy_face_graph</a> (tin_with_info, dtm_mesh,</div><div class="line">                         CGAL::parameters::face_to_face_output_iterator</div><div class="line">                         (boost::make_function_output_iterator</div><div class="line">                          ([&amp;](<span class="keyword">const</span> std::pair&lt;TIN_with_info::Face_handle, Mesh::Face_index&gt;&amp; ff)</div><div class="line">                           {</div><div class="line">                             <span class="keywordtype">double</span> longest_edge = 0.;</div><div class="line">                             <span class="keywordtype">bool</span> border = <span class="keyword">false</span>;</div><div class="line">                             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++ i)</div><div class="line">                             {</div><div class="line">                               longest_edge = (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/group__nt__util.html#gad7dbfa919e255b52f36ea1512a92cb78">std::max</a>)(longest_edge, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">CGAL::squared_distance</a></div><div class="line">                                                         (ff.first-&gt;vertex((i+1)%3)-&gt;point(),</div><div class="line">                                                          ff.first-&gt;vertex((i+2)%3)-&gt;point()));</div><div class="line"></div><div class="line">                               TIN_with_info::Face_circulator circ</div><div class="line">                                 = tin_with_info.incident_faces (ff.first-&gt;vertex(i)),</div><div class="line">                                 start = circ;</div><div class="line">                               <span class="keywordflow">do</span></div><div class="line">                               {</div><div class="line">                                 <span class="keywordflow">if</span> (tin_with_info.is_infinite (circ))</div><div class="line">                                 {</div><div class="line">                                   border = <span class="keyword">true</span>;</div><div class="line">                                   <span class="keywordflow">break</span>;</div><div class="line">                                 }</div><div class="line">                               }</div><div class="line">                               <span class="keywordflow">while</span> (++ circ != start);</div><div class="line"></div><div class="line">                               <span class="keywordflow">if</span> (border)</div><div class="line">                                 <span class="keywordflow">break</span>;</div><div class="line">                             }</div><div class="line"></div><div class="line">                             <span class="comment">// Select if face is too big AND it's not</span></div><div class="line">                             <span class="comment">// on the border (to have closed holes)</span></div><div class="line">                             <span class="keywordflow">if</span> (!border &amp;&amp; longest_edge &gt; limit)</div><div class="line">                             {</div><div class="line">                               face_selection_map[ff.second] = <span class="keyword">true</span>;</div><div class="line">                               face_selection.push_back (ff.second);</div><div class="line">                             }</div><div class="line">                           })));</div><div class="line"></div><div class="line">  <span class="comment">// Save original DTM</span></div><div class="line">  std::ofstream dtm_ofile (<span class="stringliteral">"dtm.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (dtm_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (dtm_ofile, dtm_mesh);</div><div class="line">  dtm_ofile.close();</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; face_selection.size() &lt;&lt; <span class="stringliteral">" face(s) are selected for removal"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Expand face selection to keep a well formed 2-manifold mesh after removal</span></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLSelectionFct.html#ga6f8d338df28c24bbf93677f24f7bcbbe">CGAL::expand_face_selection_for_removal</a> (face_selection, dtm_mesh, face_selection_map);</div><div class="line">  face_selection.clear();</div><div class="line">  <span class="keywordflow">for</span> (Mesh::Face_index fi : faces(dtm_mesh))</div><div class="line">    <span class="keywordflow">if</span> (face_selection_map[fi])</div><div class="line">      face_selection.push_back(fi);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; face_selection.size() &lt;&lt; <span class="stringliteral">" face(s) are selected for removal after expansion"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (Mesh::Face_index fi : face_selection)</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLEulerOperations.html#gacfae7ff8e782da55b941e4487e86c738">CGAL::Euler::remove_face</a> (halfedge(fi, dtm_mesh), dtm_mesh);</div><div class="line">  dtm_mesh.collect_garbage();</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (!dtm_mesh.is_valid())</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid mesh!"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save filtered DTM</span></div><div class="line">  std::ofstream dtm_holes_ofile (<span class="stringliteral">"dtm_with_holes.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (dtm_holes_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (dtm_holes_ofile, dtm_mesh);</div><div class="line">  dtm_holes_ofile.close();</div><div class="line"></div><div class="line">  <span class="comment">// Get all holes</span></div><div class="line">  std::vector&lt;Mesh::Halfedge_index&gt; holes;</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PkgPolygonMeshProcessingRef.html#gafa9b682528c5dc2a4821d01193518d14">CGAL::Polygon_mesh_processing::extract_boundary_cycles</a> (dtm_mesh, std::back_inserter (holes));</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; holes.size() &lt;&lt; <span class="stringliteral">" hole(s) identified"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Identify outer hull (hole with maximum size)</span></div><div class="line">  <span class="keywordtype">double</span> max_size = 0.;</div><div class="line">  Mesh::Halfedge_index outer_hull;</div><div class="line">  <span class="keywordflow">for</span> (Mesh::Halfedge_index hi : holes)</div><div class="line">  {</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html">CGAL::Bbox_3</a> hole_bbox;</div><div class="line">    <span class="keywordflow">for</span> (Mesh::Halfedge_index haf : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLIterators.html#ga37229df31508a78eb4acdaf907e637e5">CGAL::halfedges_around_face</a>(hi, dtm_mesh))</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> Point_3&amp; p = dtm_mesh.point(target(haf, dtm_mesh));</div><div class="line">      hole_bbox += p.bbox();</div><div class="line">    }</div><div class="line">    <span class="keywordtype">double</span> size = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">CGAL::squared_distance</a> (Point_2(hole_bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#aab574470a2591f187553ca1166e682e1">xmin</a>(), hole_bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a2088e16a1f0a20e011e5b94c2e9c222a">ymin</a>()),</div><div class="line">                                          Point_2(hole_bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a3f5e323700e1509624a02d151237cc4c">xmax</a>(), hole_bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a9d06f61bd89faa841e011ff53edf745f">ymax</a>()));</div><div class="line">    <span class="keywordflow">if</span> (size &gt; max_size)</div><div class="line">    {</div><div class="line">      max_size = size;</div><div class="line">      outer_hull = hi;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Fill all holes except the bigest (which is the outer hull of the mesh)</span></div><div class="line">  <span class="keywordflow">for</span> (Mesh::Halfedge_index hi : holes)</div><div class="line">    <span class="keywordflow">if</span> (hi != outer_hull)</div><div class="line">      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__hole__filling__grp.html#ga16473e4861b13d1241edee68f596b153">CGAL::Polygon_mesh_processing::triangulate_refine_and_fair_hole</a></div><div class="line">        (dtm_mesh, hi, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Emptyset__iterator.html">CGAL::Emptyset_iterator</a>(), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Emptyset__iterator.html">CGAL::Emptyset_iterator</a>());</div><div class="line"></div><div class="line">  <span class="comment">// Save DTM with holes filled</span></div><div class="line">  std::ofstream dtm_filled_ofile (<span class="stringliteral">"dtm_filled.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (dtm_filled_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (dtm_filled_ofile, dtm_mesh);</div><div class="line">  dtm_filled_ofile.close();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__meshing__grp.html#gaa5cc92275df27f0baab2472ecbc4ea3f">CGAL::Polygon_mesh_processing::isotropic_remeshing</a> (faces(dtm_mesh), spacing, dtm_mesh);</div><div class="line"></div><div class="line">  std::ofstream dtm_remeshed_ofile (<span class="stringliteral">"dtm_remeshed.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (dtm_remeshed_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (dtm_remeshed_ofile, dtm_mesh);</div><div class="line">  dtm_remeshed_ofile.close();</div><div class="line"></div><div class="line"></div><div class="line">  TIN dtm_clean (dtm_mesh.points().begin(), dtm_mesh.points().end());</div><div class="line"></div><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html">CGAL::Bbox_3</a> bbox = CGAL::bbox_3 (points.points().begin(), points.points().end());</div><div class="line"></div><div class="line">  <span class="comment">// Generate raster image 1920-pixels large</span></div><div class="line">  std::size_t width = 1920;</div><div class="line">  std::size_t height = std::size_t((bbox.ymax() - bbox.ymin()) * 1920 / (bbox.xmax() - bbox.xmin()));</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Rastering with resolution "</span> &lt;&lt; width &lt;&lt; <span class="stringliteral">"x"</span> &lt;&lt; height &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Use PPM format (Portable PixMap) for simplicity</span></div><div class="line">  std::ofstream raster_ofile (<span class="stringliteral">"raster.ppm"</span>, std::ios_base::binary);</div><div class="line"></div><div class="line">  <span class="comment">// PPM header</span></div><div class="line">  raster_ofile &lt;&lt; <span class="stringliteral">"P6"</span> &lt;&lt; std::endl <span class="comment">// magic number</span></div><div class="line">               &lt;&lt; width &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; height &lt;&lt; std::endl <span class="comment">// dimensions of the image</span></div><div class="line">               &lt;&lt; 255 &lt;&lt; std::endl; <span class="comment">// maximum color value</span></div><div class="line"></div><div class="line">  <span class="comment">// Use rainbow color ramp output</span></div><div class="line">  Color_ramp color_ramp;</div><div class="line"></div><div class="line">  <span class="comment">// Keeping track of location from one point to its neighbor allows</span></div><div class="line">  <span class="comment">// for fast locate in DT</span></div><div class="line">  TIN::Face_handle location;</div><div class="line"></div><div class="line">  <span class="comment">// Query each pixel of the image</span></div><div class="line">  <span class="keywordflow">for</span> (std::size_t y = 0; y &lt; height; ++ y)</div><div class="line">    <span class="keywordflow">for</span> (std::size_t x = 0; x &lt; width; ++ x)</div><div class="line">    {</div><div class="line">      Point_3 query (bbox.xmin() + x * (bbox.xmax() - bbox.xmin()) / <span class="keywordtype">double</span>(width),</div><div class="line">                     bbox.ymin() + (height-y) * (bbox.ymax() - bbox.ymin()) / <span class="keywordtype">double</span>(height),</div><div class="line">                     0); <span class="comment">// not relevant for location in 2D</span></div><div class="line"></div><div class="line">      location = dtm_clean.locate (query, location);</div><div class="line"></div><div class="line">      <span class="comment">// Points outside the convex hull will be colored black</span></div><div class="line">      std::array&lt;unsigned char, 3&gt; colors { 0, 0, 0 };</div><div class="line">      <span class="keywordflow">if</span> (!dtm_clean.is_infinite(location))</div><div class="line">      {</div><div class="line">        std::array&lt;double, 3&gt; barycentric_coordinates</div><div class="line">          = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#gadd9f94997d1963426d38305192345564">CGAL::Polygon_mesh_processing::barycentric_coordinates</a></div><div class="line">          (Point_2 (location-&gt;vertex(0)-&gt;point().x(), location-&gt;vertex(0)-&gt;point().y()),</div><div class="line">           Point_2 (location-&gt;vertex(1)-&gt;point().x(), location-&gt;vertex(1)-&gt;point().y()),</div><div class="line">           Point_2 (location-&gt;vertex(2)-&gt;point().x(), location-&gt;vertex(2)-&gt;point().y()),</div><div class="line">           Point_2 (query.x(), query.y()),</div><div class="line">           Kernel());</div><div class="line"></div><div class="line">        <span class="keywordtype">double</span> height_at_query</div><div class="line">          = (barycentric_coordinates[0] * location-&gt;vertex(0)-&gt;point().z()</div><div class="line">             + barycentric_coordinates[1] * location-&gt;vertex(1)-&gt;point().z()</div><div class="line">             + barycentric_coordinates[2] * location-&gt;vertex(2)-&gt;point().z());</div><div class="line"></div><div class="line">        <span class="comment">// Color ramp generates a color depending on a value from 0 to 1</span></div><div class="line">        <span class="keywordtype">double</span> height_ratio = (height_at_query - bbox.zmin()) / (bbox.zmax() - bbox.zmin());</div><div class="line">        colors = color_ramp.get(height_ratio);</div><div class="line">      }</div><div class="line">      raster_ofile.write (reinterpret_cast&lt;char*&gt;(&amp;colors), 3);</div><div class="line">    }</div><div class="line"></div><div class="line">  raster_ofile.close();</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Smooth heights with 5 successive Gaussian filters</span></div><div class="line">  <span class="keywordtype">double</span> gaussian_variance = 4 * spacing * spacing;</div><div class="line">  <span class="keywordflow">for</span> (TIN::Vertex_handle vh : dtm_clean.finite_vertex_handles())</div><div class="line">  {</div><div class="line">    <span class="keywordtype">double</span> z = vh-&gt;point().z();</div><div class="line">    <span class="keywordtype">double</span> total_weight = 1;</div><div class="line"></div><div class="line">    TIN::Vertex_circulator circ = dtm_clean.incident_vertices (vh),</div><div class="line">      start = circ;</div><div class="line"></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (!dtm_clean.is_infinite(circ))</div><div class="line">      {</div><div class="line">        <span class="keywordtype">double</span> sq_dist = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">CGAL::squared_distance</a> (vh-&gt;point(), circ-&gt;point());</div><div class="line"></div><div class="line">        <span class="keywordtype">double</span> weight = std::exp(- sq_dist / gaussian_variance);</div><div class="line">        z += weight * circ-&gt;point().z();</div><div class="line">        total_weight += weight;</div><div class="line">      }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">while</span> (++ circ != start);</div><div class="line"></div><div class="line">    z /= total_weight;</div><div class="line"></div><div class="line">    vh-&gt;point() = Point_3 (vh-&gt;point().x(), vh-&gt;point().y(), z);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  std::array&lt;double, 50&gt; isovalues; <span class="comment">// Contour 50 isovalues</span></div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; isovalues.size(); ++ i)</div><div class="line">    isovalues[i] = bbox.zmin() + ((i+1) * (bbox.zmax() - bbox.zmin()) / (isovalues.size() - 2));</div><div class="line"></div><div class="line">  <span class="comment">// First find on each face if they are crossed by some isovalues and</span></div><div class="line">  <span class="comment">// extract segments in a graph</span></div><div class="line">  <span class="keyword">using</span> Segment_graph = boost::adjacency_list&lt;boost::listS, boost::vecS, boost::undirectedS, Point_3&gt;;</div><div class="line">  Segment_graph graph;</div><div class="line">  <span class="keyword">using</span> Map_p2v = std::map&lt;Point_3, Segment_graph::vertex_descriptor&gt;;</div><div class="line">  Map_p2v map_p2v;</div><div class="line">  <span class="keywordflow">for</span> (TIN::Face_handle vh : dtm_clean.finite_face_handles())</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">double</span> iv : isovalues)</div><div class="line">      <span class="keywordflow">if</span> (face_has_isovalue (vh, iv))</div><div class="line">      {</div><div class="line">        Segment_3 segment = isocontour_in_face (vh, iv);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> Point_3&amp; p : { segment.source(), segment.target() })</div><div class="line">        {</div><div class="line">          <span class="comment">// Only insert end points of segments once to get a well connected graph</span></div><div class="line">          Map_p2v::iterator iter;</div><div class="line">          <span class="keywordtype">bool</span> inserted;</div><div class="line">          std::tie (iter, inserted) = map_p2v.insert (std::make_pair (p, Segment_graph::vertex_descriptor()));</div><div class="line">          <span class="keywordflow">if</span> (inserted)</div><div class="line">          {</div><div class="line">            iter-&gt;second = boost::add_vertex (graph);</div><div class="line">            graph[iter-&gt;second] = p;</div><div class="line">          }</div><div class="line">        }</div><div class="line">        <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLEulerOperations.html#ga4661f850bc60686efeae2fc9d2ec3e65">boost::add_edge</a> (map_p2v[segment.source()], map_p2v[segment.target()], graph);</div><div class="line">      }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Split segments into polylines</span></div><div class="line">  std::vector&lt;std::vector&lt;Point_3&gt; &gt; polylines;</div><div class="line">  Polylines_visitor&lt;Segment_graph&gt; visitor (graph, polylines);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLPartition.html#ga99ea6bf193f1194db5e523e713c82fb9">CGAL::split_graph_into_polylines</a> (graph, visitor);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; polylines.size() &lt;&lt; <span class="stringliteral">" polylines computed, with "</span></div><div class="line">            &lt;&lt; map_p2v.size() &lt;&lt; <span class="stringliteral">" vertices in total"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Output to WKT file</span></div><div class="line">  std::ofstream contour_ofile (<span class="stringliteral">"contour.wkt"</span>);</div><div class="line">  contour_ofile.precision(18);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsWKT.html#ga013d6cd500473657f41c44c9df43c511">CGAL::IO::write_multi_linestring_WKT</a> (contour_ofile, polylines);</div><div class="line">  contour_ofile.close();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Construct constrained Delaunay triangulation with polylines as constraints</span></div><div class="line">  CTP ctp;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> std::vector&lt;Point_3&gt;&amp; poly : polylines)</div><div class="line">    ctp.insert_constraint (poly.begin(), poly.end());</div><div class="line"></div><div class="line">  <span class="comment">// Simplification algorithm with limit on distance</span></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga5339b0f11fdc9babbc5ca0b33f4a982c">PS::simplify</a> (ctp, PS::Squared_distance_cost(), PS::Stop_above_cost_threshold (16 * spacing * spacing));</div><div class="line"></div><div class="line">  polylines.clear();</div><div class="line">  <span class="keywordflow">for</span> (CTP::Constraint_id cid : ctp.constraints())</div><div class="line">  {</div><div class="line">    polylines.push_back (std::vector&lt;Point_3&gt;());</div><div class="line">    polylines.back().reserve (ctp.vertices_in_constraint (cid).size());</div><div class="line">    <span class="keywordflow">for</span> (CTP::Vertex_handle vh : ctp.vertices_in_constraint(cid))</div><div class="line">      polylines.back().push_back (vh-&gt;point());</div><div class="line">  }</div><div class="line"></div><div class="line">  std::size_t nb_vertices</div><div class="line">    = std::accumulate (polylines.begin(), polylines.end(), std::size_t(0),</div><div class="line">                       [](std::size_t size, <span class="keyword">const</span> std::vector&lt;Point_3&gt;&amp; poly) -&gt; std::size_t</div><div class="line">                       { <span class="keywordflow">return</span> size + poly.size(); });</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; nb_vertices</div><div class="line">            &lt;&lt; <span class="stringliteral">" vertices remaining after simplification ("</span></div><div class="line">            &lt;&lt; 100. * (nb_vertices / double(map_p2v.size())) &lt;&lt; <span class="stringliteral">"%)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Output to WKT file</span></div><div class="line">  std::ofstream simplified_ofile (<span class="stringliteral">"simplified.wkt"</span>);</div><div class="line">  simplified_ofile.precision(18);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsWKT.html#ga013d6cd500473657f41c44c9df43c511">CGAL::IO::write_multi_linestring_WKT</a> (simplified_ofile, polylines);</div><div class="line">  simplified_ofile.close();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Get training from input</span></div><div class="line">  Point_set::Property_map&lt;int&gt; training_map;</div><div class="line">  <span class="keywordtype">bool</span> training_found;</div><div class="line">  std::tie (training_map, training_found) = points.property_map&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">"training"</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (training_found)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Classifying ground/vegetation/building"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// Create labels</span></div><div class="line">    Classification::Label_set labels ({ <span class="stringliteral">"ground"</span>, <span class="stringliteral">"vegetation"</span>, <span class="stringliteral">"building"</span> });</div><div class="line"></div><div class="line">    <span class="comment">// Generate features</span></div><div class="line">    Classification::Feature_set <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Mesh_3.tag:../Mesh_3/" href="../Mesh_3/group__PkgMesh3Parameters.html#ga0a990b28d55157c62d4bfd2624d408af">features</a>;</div><div class="line">    Classification::Point_set_feature_generator&lt;Kernel, Point_set, Point_set::Point_map&gt;</div><div class="line">      generator (points, points.point_map(), 5); <span class="comment">// 5 scales</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef CGAL_LINKED_WITH_TBB</span></div><div class="line">    <span class="comment">// If TBB is used, features can be computed in parallel</span></div><div class="line">    features.begin_parallel_additions();</div><div class="line">    generator.generate_point_based_features (features);</div><div class="line">    features.end_parallel_additions();</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    generator.generate_point_based_features (features);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">    <span class="comment">// Train a random forest classifier</span></div><div class="line">    Classification::ETHZ::Random_forest_classifier classifier (labels, features);</div><div class="line">    classifier.train (points.range(training_map));</div><div class="line"></div><div class="line">    <span class="comment">// Classify with graphcut regularization</span></div><div class="line">    Point_set::Property_map&lt;int&gt; label_map = points.add_property_map&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">"labels"</span>).first;</div><div class="line">    Classification::classify_with_graphcut&lt;Concurrency_tag&gt;</div><div class="line">      (points, points.point_map(), labels, classifier,</div><div class="line">       generator.neighborhood().k_neighbor_query(12), <span class="comment">// regularize on 12-neighbors graph</span></div><div class="line">       0.5f, <span class="comment">// graphcut weight</span></div><div class="line">       12, <span class="comment">// Subdivide to speed-up process</span></div><div class="line">       label_map);</div><div class="line"></div><div class="line">    <span class="comment">// Evaluate</span></div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Mean IoU on training data = "</span></div><div class="line">              &lt;&lt; Classification::Evaluation(labels,</div><div class="line">                                            points.range(training_map),</div><div class="line">                                            points.range(label_map)).mean_intersection_over_union() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// Save the classified point set</span></div><div class="line">    std::ofstream classified_ofile (<span class="stringliteral">"classified.ply"</span>);</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (classified_ofile);</div><div class="line">    classified_ofile &lt;&lt; points;</div><div class="line">    classified_ofile.close();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="TutorialGIS_Reference"></a>
References</h1>
<p>This tutorial is based on the following CGAL packages:</p>
<ul>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/group__PkgTriangulation2Ref.html">2D Triangulations Reference</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/group__PkgPointSet3Ref.html">3D Point Set Reference</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Ref.html">Point Set Processing Reference</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurface__mesh.html">Surface Mesh Reference</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLRef.html">CGAL and the Boost Graph Library Reference</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PkgPolygonMeshProcessingRef.html">Polygon Mesh Processing Reference</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polyline_simplification_2.tag:../Polyline_simplification_2/" href="../Polyline_simplification_2/group__PkgPolylineSimplification2Ref.html">2D Polyline Simplification Reference</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Classification.tag:../Classification/" href="../Classification/group__PkgClassificationRef.html">Classification Reference</a></li>
</ul>
<p>The data set used throughout this tutorial comes from the <a href="https://www.usgs.gov/">https://www.usgs.gov/</a> database, licensed under the <em>US Government Public Domain</em>. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jul 4 2022 13:24:47 for CGAL 5.6 - Manual by
    <a href="https://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>
</html><html xmlns="http://www.w3.org/1999/xhtml"><body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
          <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
          <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt="" /></a>
          </span>
        </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.6 - Manual
   </div>
  </td>
  <!-- We disable the search box because we have added it in the
  back-nav for stylistic reasons. -->
  <!-- <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td> -->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tuto_gis.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">GIS (Geographic Information System) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> </p><div id="autotoc" class="toc"></div> 
<dl class="section author"><dt>Author</dt><dd>Simon Giraudot</dd></dl>
<p>Many sensors used in GIS applications (for example LIDAR), generate dense point clouds. Such applications often take advantage of more advanced data structures: for example, Triangulated Irregular Networks (TIN) that can be the base for Digital Evelation Models (DEM) and in particular for the generation of Digital Terrain Models (DTM). Point clouds can also be enriched by classification information that segments the points into ground, vegetation and building points (or other user-defined labels).</p>
<p>The definitions of some data structures may vary according to different sources. We will use the following terms within this tutorial:</p>
<ul>
<li>TIN: <em>Triangulated Irregular Network</em>, a 2D triangulation structure that connects 3D points based on their projections on the horizontal plane.</li>
<li>DSM: <em>Digital Surface Model</em>, a model of the whole scanned surface including buildings and vegetation. We use a TIN to store the DSM.</li>
<li>DTM: <em>Digital Terrain Model</em>, a model of the bare ground surface without objects like buildings or vegetation. We both use a TIN and a raster to store a DTM.</li>
<li>DEM: <em>Digital Elevation Model</em>, a more general term that includes both DSM and DTM.</li>
</ul>
<p>This tutorial illustrates the following scenario. From an input point cloud, we first compute a DSM stored as a TIN. Then, we filter out overly large facets that correspond either to building facades or to vegetation noise. Large components corresponding to the ground are kept. Holes are filled and the obtained DEM is remeshed. A raster DEM and a set of contour polylines are generated from it. Finally, supervised 3-label classification is performed to segment vegetation, building and group points.</p>
<h1><a class="anchor" id="TutorialGIS_TIN"></a>
Triangulated Irregular Network (TIN)</h1>
<p>CGAL provides several triangulation data structures and algorithms. A TIN can be generated by combining the 2D Delaunay triangulation with projection traits: the triangulation structure is computed using the 2D positions of the points along a selected plane (usually, the XY-plane), while the 3D positions of the points are kept for visualization and measurements.</p>
<p>A TIN data structure can thus simply be defined the following way:</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keyword">using</span> Kernel = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div><div class="line"><span class="keyword">using</span> Projection_traits = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Projection__traits__xy__3.html">CGAL::Projection_traits_xy_3&lt;Kernel&gt;</a>;</div><div class="line"><span class="keyword">using</span> Point_2 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>;</div><div class="line"><span class="keyword">using</span> Point_3 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ae82b7f4be77dd5b8819ebe419e4ae753">Kernel::Point_3</a>;</div><div class="line"><span class="keyword">using</span> Segment_3 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#aa43a461b2027ef7d99b776a7b03ef230">Kernel::Segment_3</a>;</div><div class="line"></div><div class="line"><span class="comment">// Triangulated Irregular Network</span></div><div class="line"><span class="keyword">using</span> TIN = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2&lt;Projection_traits&gt;</a>;</div><div class="line"></div></div><!-- fragment --> <h1><a class="anchor" id="TutorialGIS_DSM"></a>
Digital Surface Model (DSM)</h1>
<p>Point clouds in many formats (XYZ, OFF, PLY, LAS) can be easily loaded into a <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3</a></code> structure, using the stream operator. Generating a DSM stored in TIN is then straightforward:</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="comment">// Read points</span></div><div class="line">  std::ifstream ifile (fname, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3&lt;Point_3&gt;</a> points;</div><div class="line">  ifile &gt;&gt; points;</div><div class="line">  std::cerr &lt;&lt; points.size() &lt;&lt; <span class="stringliteral">" point(s) read"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Create DSM</span></div><div class="line">  TIN dsm (points.points().begin(), points.points().end());</div><div class="line"></div></div><!-- fragment --><p> Because the Delaunay triangulation of CGAL is a model of <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/classFaceGraph.html">FaceGraph</a></code>, it is straightforward to convert the generated TIN into a mesh structure such as <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh</a></code> and be saved into whatever formats are supported by such structure:</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="keyword">using</span> Mesh = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point_3&gt;</a>;</div><div class="line"></div><div class="line">  Mesh dsm_mesh;</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#ga2682fb7d5f4ff4eb65607ae4118e31bc">CGAL::copy_face_graph</a> (dsm, dsm_mesh);</div><div class="line">  std::ofstream dsm_ofile (<span class="stringliteral">"dsm.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (dsm_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (dsm_ofile, dsm_mesh);</div><div class="line">  dsm_ofile.close();</div><div class="line"></div></div><!-- fragment --><p> An example of a DSM computed this way on the San Fransisco data set (see <a class="el" href="tuto_gis.html#TutorialGIS_Reference">References</a>) is given in <a class="el" href="tuto_gis.html#fig__TutorialGISFigTIN">Figure 0.1</a>.</p>
<p><a class="anchor" id="fig__TutorialGISFigTIN"></a></p><div class="image">
<img src="tin.jpg" alt="tin.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_gis.html#fig__TutorialGISFigTIN">Figure 0.1</a> Input point cloud and output DSM.  </div> <br /> 
<h1><a class="anchor" id="TutorialGIS_DTM"></a>
Digital Terrain Model (DTM)</h1>
<p>The generated DSM is used as a base for DTM computation, that is a representation of the ground as another TIN after filtering non-ground points.</p>
<p>We propose, as an example, a simple DTM estimation decomposed in the following steps:</p>
<ol type="1">
<li>Thresholding the height of the facets to remove brutal changes of elevation</li>
<li>Clustering the other facets into connected components</li>
<li>Filtering all components smaller than a user-defined threshold</li>
</ol>
<p>This algorithm relies on 2 parameters: a height threshold that corresponds to the minimum height of a building, and a perimeter threshold that corresponds to the maximum size of a building on the 2D projection.</p>
<h2><a class="anchor" id="TutorialGIS_DTM_info"></a>
TIN With Info</h2>
<p>Because it takes advantage of the flexible CGAL Delaunay triangulation API, our TIN can be enriched with information on vertices and/or on faces. In our case, each vertex keeps track of the index of the corresponding point in the input point cloud (which will allow to filter ground points afterwards), and each face is given the index of its connected component.</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="keyword">auto</span> idx_to_point_with_info</div><div class="line">    = [&amp;](<span class="keyword">const</span> Point_set::Index&amp; idx) -&gt; std::pair&lt;Point_3, Point_set::Index&gt;</div><div class="line">      {</div><div class="line">        <span class="keywordflow">return</span> std::make_pair (points.point(idx), idx);</div><div class="line">      };</div><div class="line"></div><div class="line">  TIN_with_info tin_with_info</div><div class="line">    (boost::make_transform_iterator (points.begin(), idx_to_point_with_info),</div><div class="line">     boost::make_transform_iterator (points.end(), idx_to_point_with_info));</div><div class="line"></div></div><!-- fragment --> <h2><a class="anchor" id="TutorialGIS_DTM_components"></a>
Identifying Connected Components</h2>
<p>Connected components are identified through a flooding algorithm: from a seed face, all incident faces are inserted in the current connected component unless their heights exceed the user-defined threshold.</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="keywordtype">double</span> spacing = CGAL::compute_average_spacing&lt;Concurrency_tag&gt;(points, 6);</div><div class="line">  spacing *= 2;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> face_height</div><div class="line">    = [&amp;](<span class="keyword">const</span> TIN_with_info::Face_handle fh) -&gt; <span class="keywordtype">double</span></div><div class="line">      {</div><div class="line">        <span class="keywordtype">double</span> out = 0.;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++ i)</div><div class="line">          out = (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/group__nt__util.html#gad7dbfa919e255b52f36ea1512a92cb78">std::max</a>) (out, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">CGAL::abs</a>(fh-&gt;vertex(i)-&gt;point().z() - fh-&gt;vertex((i+1)%3)-&gt;point().z()));</div><div class="line">        <span class="keywordflow">return</span> out;</div><div class="line">      };</div><div class="line"></div><div class="line">  <span class="comment">// Initialize faces info</span></div><div class="line">  <span class="keywordflow">for</span> (TIN_with_info::Face_handle fh : tin_with_info.all_face_handles())</div><div class="line">    <span class="keywordflow">if</span> (tin_with_info.is_infinite(fh) || face_height(fh) &gt; spacing) <span class="comment">// Filtered faces are given info() = -2</span></div><div class="line">      fh-&gt;info() = -2;</div><div class="line">    <span class="keywordflow">else</span> <span class="comment">// Pending faces are given info() = -1;</span></div><div class="line">      fh-&gt;info() = -1;</div><div class="line"></div><div class="line">  <span class="comment">// Flooding algorithm</span></div><div class="line">  std::vector&lt;int&gt; component_size;</div><div class="line">  <span class="keywordflow">for</span> (TIN_with_info::Face_handle fh : tin_with_info.finite_face_handles())</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (fh-&gt;info() != -1)</div><div class="line">      <span class="keywordflow">continue</span>;</div><div class="line"></div><div class="line">    std::queue&lt;TIN_with_info::Face_handle&gt; todo;</div><div class="line">    todo.push(fh);</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> size = 0;</div><div class="line">    <span class="keywordflow">while</span> (!todo.empty())</div><div class="line">    {</div><div class="line">      TIN_with_info::Face_handle current = todo.front();</div><div class="line">      todo.pop();</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (current-&gt;info() != -1)</div><div class="line">        <span class="keywordflow">continue</span>;</div><div class="line">      current-&gt;info() = int(component_size.size());</div><div class="line">      ++ size;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++ i)</div><div class="line">        todo.push (current-&gt;neighbor(i));</div><div class="line">    }</div><div class="line"></div><div class="line">    component_size.push_back (size);</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; component_size.size() &lt;&lt; <span class="stringliteral">" connected component(s) found"</span> &lt;&lt; std::endl;</div><div class="line"></div></div><!-- fragment --><p> This TIN enriched with connected component information can be saved as a colored mesh:</p>
<div class="fragment"><div class="line"></div><div class="line">  Mesh tin_colored_mesh;</div><div class="line"></div><div class="line">  Mesh::Property_map&lt;Mesh::Face_index, CGAL::IO::Color&gt;</div><div class="line">    color_map = tin_colored_mesh.add_property_map&lt;Mesh::Face_index, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a>&gt;(<span class="stringliteral">"f:color"</span>).first;</div><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#ga2682fb7d5f4ff4eb65607ae4118e31bc">CGAL::copy_face_graph</a> (tin_with_info, tin_colored_mesh,</div><div class="line">                         CGAL::parameters::face_to_face_output_iterator</div><div class="line">                         (boost::make_function_output_iterator</div><div class="line">                          ([&amp;](<span class="keyword">const</span> std::pair&lt;TIN_with_info::Face_handle, Mesh::Face_index&gt;&amp; ff)</div><div class="line">                           {</div><div class="line">                             <span class="comment">// Color unassigned faces gray</span></div><div class="line">                             <span class="keywordflow">if</span> (ff.first-&gt;info() &lt; 0)</div><div class="line">                               color_map[ff.second] = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a>(128, 128, 128);</div><div class="line">                             <span class="keywordflow">else</span></div><div class="line">                             {</div><div class="line">                               <span class="comment">// Random color seeded by the component ID</span></div><div class="line">                               <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Generator.tag:../Generator/" href="../Generator/classCGAL_1_1Random.html">CGAL::Random</a> r (ff.first-&gt;info());</div><div class="line">                               color_map[ff.second] = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a> (r.get_int(64, 192),</div><div class="line">                                                                   r.get_int(64, 192),</div><div class="line">                                                                   r.get_int(64, 192));</div><div class="line">                             }</div><div class="line">                           })));</div><div class="line"></div><div class="line">  std::ofstream tin_colored_ofile (<span class="stringliteral">"colored_tin.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (tin_colored_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (tin_colored_ofile, tin_colored_mesh);</div><div class="line">  tin_colored_ofile.close();</div><div class="line"></div></div><!-- fragment --><p> An example of a TIN colored by connected components is given in <a class="el" href="tuto_gis.html#fig__TutorialGISFigComponents">Figure 0.2</a>.</p>
<p><a class="anchor" id="fig__TutorialGISFigComponents"></a></p><div class="image">
<img src="components.jpg" alt="components.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_gis.html#fig__TutorialGISFigComponents">Figure 0.2</a> TIN colored by connected components. Faces above height threshold are not assigned to any component and are displayed in gray.  </div> <br /> 
<h2><a class="anchor" id="TutorialGIS_DTM_filtering"></a>
Filtering</h2>
<p>Components smaller than the largest building can be removed this way:</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="keywordtype">int</span> min_size = int(points.size() / 2);</div><div class="line"></div><div class="line">  std::vector&lt;TIN_with_info::Vertex_handle&gt; to_remove;</div><div class="line">  <span class="keywordflow">for</span> (TIN_with_info::Vertex_handle vh : tin_with_info.finite_vertex_handles())</div><div class="line">  {</div><div class="line">    TIN_with_info::Face_circulator circ = tin_with_info.incident_faces (vh),</div><div class="line">      start = circ;</div><div class="line"></div><div class="line">    <span class="comment">// Remove a vertex if it's only adjacent to components smaller than threshold</span></div><div class="line">    <span class="keywordtype">bool</span> keep = <span class="keyword">false</span>;</div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (circ-&gt;info() &gt;= 0 &amp;&amp; component_size[std::size_t(circ-&gt;info())] &gt; min_size)</div><div class="line">      {</div><div class="line">        keep = <span class="keyword">true</span>;</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">while</span> (++ circ != start);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (!keep)</div><div class="line">      to_remove.push_back (vh);</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; to_remove.size() &lt;&lt; <span class="stringliteral">" vertices(s) will be removed after filtering"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (TIN_with_info::Vertex_handle vh : to_remove)</div><div class="line">    tin_with_info.remove (vh);</div><div class="line"></div></div><!-- fragment --> <h2><a class="anchor" id="Tutorial_DTM_hole_filling"></a>
Hole Filling and Remeshing</h2>
<p>Because simply removing vertices in the large areas covered by buildings results in large Delaunay faces that offer a poor 3D representation of the DTM, an additional step can help producing better shaped meshes: faces larger than a threshold are removed and filled with a hole filling algorithm that triangulates, refines and fairs the holes.</p>
<p>The following snippet copies the TIN into a mesh while filtering out overly large faces, then identifies the holes and fills them all except for the largest one (which is the outer hull).</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="comment">// Copy and keep track of overly large faces</span></div><div class="line">  Mesh dtm_mesh;</div><div class="line"></div><div class="line">  std::vector&lt;Mesh::Face_index&gt; face_selection;</div><div class="line">  Mesh::Property_map&lt;Mesh::Face_index, bool&gt; face_selection_map</div><div class="line">   = dtm_mesh.add_property_map&lt;Mesh::Face_index, <span class="keywordtype">bool</span>&gt;(<span class="stringliteral">"is_selected"</span>, <span class="keyword">false</span>).first;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> limit = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga07001b5ddc5c43096c811c91a306be9a">CGAL::square</a> (5 * spacing);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#ga2682fb7d5f4ff4eb65607ae4118e31bc">CGAL::copy_face_graph</a> (tin_with_info, dtm_mesh,</div><div class="line">                         CGAL::parameters::face_to_face_output_iterator</div><div class="line">                         (boost::make_function_output_iterator</div><div class="line">                          ([&amp;](<span class="keyword">const</span> std::pair&lt;TIN_with_info::Face_handle, Mesh::Face_index&gt;&amp; ff)</div><div class="line">                           {</div><div class="line">                             <span class="keywordtype">double</span> longest_edge = 0.;</div><div class="line">                             <span class="keywordtype">bool</span> border = <span class="keyword">false</span>;</div><div class="line">                             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++ i)</div><div class="line">                             {</div><div class="line">                               longest_edge = (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/group__nt__util.html#gad7dbfa919e255b52f36ea1512a92cb78">std::max</a>)(longest_edge, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">CGAL::squared_distance</a></div><div class="line">                                                         (ff.first-&gt;vertex((i+1)%3)-&gt;point(),</div><div class="line">                                                          ff.first-&gt;vertex((i+2)%3)-&gt;point()));</div><div class="line"></div><div class="line">                               TIN_with_info::Face_circulator circ</div><div class="line">                                 = tin_with_info.incident_faces (ff.first-&gt;vertex(i)),</div><div class="line">                                 start = circ;</div><div class="line">                               <span class="keywordflow">do</span></div><div class="line">                               {</div><div class="line">                                 <span class="keywordflow">if</span> (tin_with_info.is_infinite (circ))</div><div class="line">                                 {</div><div class="line">                                   border = <span class="keyword">true</span>;</div><div class="line">                                   <span class="keywordflow">break</span>;</div><div class="line">                                 }</div><div class="line">                               }</div><div class="line">                               <span class="keywordflow">while</span> (++ circ != start);</div><div class="line"></div><div class="line">                               <span class="keywordflow">if</span> (border)</div><div class="line">                                 <span class="keywordflow">break</span>;</div><div class="line">                             }</div><div class="line"></div><div class="line">                             <span class="comment">// Select if face is too big AND it's not</span></div><div class="line">                             <span class="comment">// on the border (to have closed holes)</span></div><div class="line">                             <span class="keywordflow">if</span> (!border &amp;&amp; longest_edge &gt; limit)</div><div class="line">                             {</div><div class="line">                               face_selection_map[ff.second] = <span class="keyword">true</span>;</div><div class="line">                               face_selection.push_back (ff.second);</div><div class="line">                             }</div><div class="line">                           })));</div><div class="line"></div><div class="line">  <span class="comment">// Save original DTM</span></div><div class="line">  std::ofstream dtm_ofile (<span class="stringliteral">"dtm.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (dtm_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (dtm_ofile, dtm_mesh);</div><div class="line">  dtm_ofile.close();</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; face_selection.size() &lt;&lt; <span class="stringliteral">" face(s) are selected for removal"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Expand face selection to keep a well formed 2-manifold mesh after removal</span></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLSelectionFct.html#ga6f8d338df28c24bbf93677f24f7bcbbe">CGAL::expand_face_selection_for_removal</a> (face_selection, dtm_mesh, face_selection_map);</div><div class="line">  face_selection.clear();</div><div class="line">  <span class="keywordflow">for</span> (Mesh::Face_index fi : faces(dtm_mesh))</div><div class="line">    <span class="keywordflow">if</span> (face_selection_map[fi])</div><div class="line">      face_selection.push_back(fi);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; face_selection.size() &lt;&lt; <span class="stringliteral">" face(s) are selected for removal after expansion"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (Mesh::Face_index fi : face_selection)</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLEulerOperations.html#gacfae7ff8e782da55b941e4487e86c738">CGAL::Euler::remove_face</a> (halfedge(fi, dtm_mesh), dtm_mesh);</div><div class="line">  dtm_mesh.collect_garbage();</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (!dtm_mesh.is_valid())</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid mesh!"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save filtered DTM</span></div><div class="line">  std::ofstream dtm_holes_ofile (<span class="stringliteral">"dtm_with_holes.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (dtm_holes_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (dtm_holes_ofile, dtm_mesh);</div><div class="line">  dtm_holes_ofile.close();</div><div class="line"></div><div class="line">  <span class="comment">// Get all holes</span></div><div class="line">  std::vector&lt;Mesh::Halfedge_index&gt; holes;</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PkgPolygonMeshProcessingRef.html#gafa9b682528c5dc2a4821d01193518d14">CGAL::Polygon_mesh_processing::extract_boundary_cycles</a> (dtm_mesh, std::back_inserter (holes));</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; holes.size() &lt;&lt; <span class="stringliteral">" hole(s) identified"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Identify outer hull (hole with maximum size)</span></div><div class="line">  <span class="keywordtype">double</span> max_size = 0.;</div><div class="line">  Mesh::Halfedge_index outer_hull;</div><div class="line">  <span class="keywordflow">for</span> (Mesh::Halfedge_index hi : holes)</div><div class="line">  {</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html">CGAL::Bbox_3</a> hole_bbox;</div><div class="line">    <span class="keywordflow">for</span> (Mesh::Halfedge_index haf : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLIterators.html#ga37229df31508a78eb4acdaf907e637e5">CGAL::halfedges_around_face</a>(hi, dtm_mesh))</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> Point_3&amp; p = dtm_mesh.point(target(haf, dtm_mesh));</div><div class="line">      hole_bbox += p.bbox();</div><div class="line">    }</div><div class="line">    <span class="keywordtype">double</span> size = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">CGAL::squared_distance</a> (Point_2(hole_bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#aab574470a2591f187553ca1166e682e1">xmin</a>(), hole_bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a2088e16a1f0a20e011e5b94c2e9c222a">ymin</a>()),</div><div class="line">                                          Point_2(hole_bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a3f5e323700e1509624a02d151237cc4c">xmax</a>(), hole_bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a9d06f61bd89faa841e011ff53edf745f">ymax</a>()));</div><div class="line">    <span class="keywordflow">if</span> (size &gt; max_size)</div><div class="line">    {</div><div class="line">      max_size = size;</div><div class="line">      outer_hull = hi;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Fill all holes except the bigest (which is the outer hull of the mesh)</span></div><div class="line">  <span class="keywordflow">for</span> (Mesh::Halfedge_index hi : holes)</div><div class="line">    <span class="keywordflow">if</span> (hi != outer_hull)</div><div class="line">      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__hole__filling__grp.html#ga16473e4861b13d1241edee68f596b153">CGAL::Polygon_mesh_processing::triangulate_refine_and_fair_hole</a></div><div class="line">        (dtm_mesh, hi, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Emptyset__iterator.html">CGAL::Emptyset_iterator</a>(), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Emptyset__iterator.html">CGAL::Emptyset_iterator</a>());</div><div class="line"></div><div class="line">  <span class="comment">// Save DTM with holes filled</span></div><div class="line">  std::ofstream dtm_filled_ofile (<span class="stringliteral">"dtm_filled.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (dtm_filled_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (dtm_filled_ofile, dtm_mesh);</div><div class="line">  dtm_filled_ofile.close();</div><div class="line"></div></div><!-- fragment --><p> Isotropic remeshing can also be performed as a final step in order to produce a more regular mesh that is not constrained by the shape of 2D Delaunay faces.</p>
<div class="fragment"><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__meshing__grp.html#gaa5cc92275df27f0baab2472ecbc4ea3f">CGAL::Polygon_mesh_processing::isotropic_remeshing</a> (faces(dtm_mesh), spacing, dtm_mesh);</div><div class="line"></div><div class="line">  std::ofstream dtm_remeshed_ofile (<span class="stringliteral">"dtm_remeshed.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (dtm_remeshed_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (dtm_remeshed_ofile, dtm_mesh);</div><div class="line">  dtm_remeshed_ofile.close();</div><div class="line"></div></div><!-- fragment --><p> <a class="el" href="tuto_gis.html#fig__TutorialGISFigProc">Figure 0.3</a> shows how these different steps affect the output mesh and <a class="el" href="tuto_gis.html#fig__TutorialGISFigDTM">Figure 0.4</a> shows the DTM isotropic mesh.</p>
<p><a class="anchor" id="fig__TutorialGISFigProc"></a></p><div class="image">
<img src="dtm_proc.jpg" alt="dtm_proc.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_gis.html#fig__TutorialGISFigProc">Figure 0.3</a> Raw DTM and postprocessing  </div> <br /> 
<p><a class="anchor" id="fig__TutorialGISFigDTM"></a></p><div class="image">
<img src="dtm.jpg" alt="dtm.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_gis.html#fig__TutorialGISFigDTM">Figure 0.4</a> Final DTM.  </div> <br /> 
<h1><a class="anchor" id="TutorialGIS_Raster"></a>
Rastering</h1>
<p>The TIN data structure can be combined with barycentric coordinates in order to interpolate and thus rasterize a height map at any resolution needed the information embedded in the vertices.</p>
<p>Because the latest two steps (hole filling and remeshing) were performed on a 3D mesh, the hypothesis that our DTM is a 2.5D representation may no longer be valid. We thus first rebuild a TIN using the vertices of the isotropic DTM mesh lastly computed.</p>
<p>The following snippet generates a raster image of the height in the form of rainbow ramp PPM file (simple bitmap format):</p>
<div class="fragment"><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html">CGAL::Bbox_3</a> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PkgPolygonMeshProcessingRef.html#gaf633ec6397f5f065b01462fe42235d56">bbox</a> = CGAL::bbox_3 (points.points().begin(), points.points().end());</div><div class="line"></div><div class="line">  <span class="comment">// Generate raster image 1920-pixels large</span></div><div class="line">  std::size_t width = 1920;</div><div class="line">  std::size_t height = std::size_t((bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a9d06f61bd89faa841e011ff53edf745f">ymax</a>() - bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a2088e16a1f0a20e011e5b94c2e9c222a">ymin</a>()) * 1920 / (bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a3f5e323700e1509624a02d151237cc4c">xmax</a>() - bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#aab574470a2591f187553ca1166e682e1">xmin</a>()));</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Rastering with resolution "</span> &lt;&lt; width &lt;&lt; <span class="stringliteral">"x"</span> &lt;&lt; height &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Use PPM format (Portable PixMap) for simplicity</span></div><div class="line">  std::ofstream raster_ofile (<span class="stringliteral">"raster.ppm"</span>, std::ios_base::binary);</div><div class="line"></div><div class="line">  <span class="comment">// PPM header</span></div><div class="line">  raster_ofile &lt;&lt; <span class="stringliteral">"P6"</span> &lt;&lt; std::endl <span class="comment">// magic number</span></div><div class="line">               &lt;&lt; width &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; height &lt;&lt; std::endl <span class="comment">// dimensions of the image</span></div><div class="line">               &lt;&lt; 255 &lt;&lt; std::endl; <span class="comment">// maximum color value</span></div><div class="line"></div><div class="line">  <span class="comment">// Use rainbow color ramp output</span></div><div class="line">  Color_ramp color_ramp;</div><div class="line"></div><div class="line">  <span class="comment">// Keeping track of location from one point to its neighbor allows</span></div><div class="line">  <span class="comment">// for fast locate in DT</span></div><div class="line">  TIN::Face_handle location;</div><div class="line"></div><div class="line">  <span class="comment">// Query each pixel of the image</span></div><div class="line">  <span class="keywordflow">for</span> (std::size_t y = 0; y &lt; height; ++ y)</div><div class="line">    <span class="keywordflow">for</span> (std::size_t x = 0; x &lt; width; ++ x)</div><div class="line">    {</div><div class="line">      Point_3 query (bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#aab574470a2591f187553ca1166e682e1">xmin</a>() + x * (bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a3f5e323700e1509624a02d151237cc4c">xmax</a>() - bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#aab574470a2591f187553ca1166e682e1">xmin</a>()) / <span class="keywordtype">double</span>(width),</div><div class="line">                     bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a2088e16a1f0a20e011e5b94c2e9c222a">ymin</a>() + (height-y) * (bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a9d06f61bd89faa841e011ff53edf745f">ymax</a>() - bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a2088e16a1f0a20e011e5b94c2e9c222a">ymin</a>()) / <span class="keywordtype">double</span>(height),</div><div class="line">                     0); <span class="comment">// not relevant for location in 2D</span></div><div class="line"></div><div class="line">      location = dtm_clean.locate (query, location);</div><div class="line"></div><div class="line">      <span class="comment">// Points outside the convex hull will be colored black</span></div><div class="line">      std::array&lt;unsigned char, 3&gt; colors { 0, 0, 0 };</div><div class="line">      <span class="keywordflow">if</span> (!dtm_clean.is_infinite(location))</div><div class="line">      {</div><div class="line">        std::array&lt;double, 3&gt; <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#gadd9f94997d1963426d38305192345564">barycentric_coordinates</a></div><div class="line">          = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#gadd9f94997d1963426d38305192345564">CGAL::Polygon_mesh_processing::barycentric_coordinates</a></div><div class="line">          (Point_2 (location-&gt;vertex(0)-&gt;point().x(), location-&gt;vertex(0)-&gt;point().y()),</div><div class="line">           Point_2 (location-&gt;vertex(1)-&gt;point().x(), location-&gt;vertex(1)-&gt;point().y()),</div><div class="line">           Point_2 (location-&gt;vertex(2)-&gt;point().x(), location-&gt;vertex(2)-&gt;point().y()),</div><div class="line">           Point_2 (query.x(), query.y()),</div><div class="line">           Kernel());</div><div class="line"></div><div class="line">        <span class="keywordtype">double</span> height_at_query</div><div class="line">          = (barycentric_coordinates[0] * location-&gt;vertex(0)-&gt;point().z()</div><div class="line">             + barycentric_coordinates[1] * location-&gt;vertex(1)-&gt;point().z()</div><div class="line">             + barycentric_coordinates[2] * location-&gt;vertex(2)-&gt;point().z());</div><div class="line"></div><div class="line">        <span class="comment">// Color ramp generates a color depending on a value from 0 to 1</span></div><div class="line">        <span class="keywordtype">double</span> height_ratio = (height_at_query - bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a6c55430abc7fda54571cf1075c7f2f8b">zmin</a>()) / (bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a98def8b9515f31ded759d781969ddaf6">zmax</a>() - bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a6c55430abc7fda54571cf1075c7f2f8b">zmin</a>());</div><div class="line">        colors = color_ramp.get(height_ratio);</div><div class="line">      }</div><div class="line">      raster_ofile.write (reinterpret_cast&lt;char*&gt;(&amp;colors), 3);</div><div class="line">    }</div><div class="line"></div><div class="line">  raster_ofile.close();</div><div class="line"></div></div><!-- fragment --><p> An example of a raster image with a rainbow ramp representing height is given in <a class="el" href="tuto_gis.html#fig__TutorialGISFigRastering">Figure 0.5</a>.</p>
<p><a class="anchor" id="fig__TutorialGISFigRastering"></a></p><div class="image">
<img src="raster.jpg" alt="raster.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_gis.html#fig__TutorialGISFigRastering">Figure 0.5</a> Raster visualisation of height using a rainbow ramp, ranging from light blue for low values to dark red for high values.  </div> <br /> 
<h1><a class="anchor" id="TutorialGIS_Contour"></a>
Contouring</h1>
<p>Extracting isolevels of a function defined on a TIN is another application that can be done with CGAL. We demonstrate here how to extract isolevels of height to build a topographic map.</p>
<h2><a class="anchor" id="TutorialGIS_Contour_Extraction"></a>
Building a Contour Graph</h2>
<p>The first step is to extract, from all faces of the triangulation, the section of each isolevel that goes through that face, in the form of a segment. The following functions allow to test if one isovalue does cross a face, and to extract it then:</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keywordtype">bool</span> face_has_isovalue (TIN::Face_handle fh, <span class="keywordtype">double</span> isovalue)</div><div class="line">{</div><div class="line">  <span class="keywordtype">bool</span> above = <span class="keyword">false</span>, below = <span class="keyword">false</span>;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++ i)</div><div class="line">  {</div><div class="line">    <span class="comment">// Face has isovalue if one of its vertices is above and another</span></div><div class="line">    <span class="comment">// one below</span></div><div class="line">    <span class="keywordflow">if</span> (fh-&gt;vertex(i)-&gt;point().z() &gt; isovalue)</div><div class="line">      above = <span class="keyword">true</span>;</div><div class="line">    <span class="keywordflow">if</span> (fh-&gt;vertex(i)-&gt;point().z() &lt; isovalue)</div><div class="line">      below = <span class="keyword">true</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> (above &amp;&amp; below);</div><div class="line">}</div><div class="line"></div><div class="line">Segment_3 isocontour_in_face (TIN::Face_handle fh, <span class="keywordtype">double</span> isovalue)</div><div class="line">{</div><div class="line">  Point_3 source;</div><div class="line">  Point_3 target;</div><div class="line">  <span class="keywordtype">bool</span> source_found = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++ i)</div><div class="line">  {</div><div class="line">    Point_3 p0 = fh-&gt;vertex((i+1) % 3)-&gt;point();</div><div class="line">    Point_3 p1 = fh-&gt;vertex((i+2) % 3)-&gt;point();</div><div class="line"></div><div class="line">    <span class="comment">// Check if the isovalue crosses segment (p0,p1)</span></div><div class="line">    <span class="keywordflow">if</span> ((p0.z() - isovalue) * (p1.z() - isovalue) &gt; 0)</div><div class="line">      <span class="keywordflow">continue</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> zbottom = p0.z();</div><div class="line">    <span class="keywordtype">double</span> ztop = p1.z();</div><div class="line">    <span class="keywordflow">if</span> (zbottom &gt; ztop)</div><div class="line">    {</div><div class="line">      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polynomial.tag:../Polynomial/" href="../Polynomial/group__PkgPolynomialFunctions.html#gaa555a2d0a5bf3730c337f08f07356c07">std::swap</a> (zbottom, ztop);</div><div class="line">      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polynomial.tag:../Polynomial/" href="../Polynomial/group__PkgPolynomialFunctions.html#gaa555a2d0a5bf3730c337f08f07356c07">std::swap</a> (p0, p1);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Compute position of segment vertex</span></div><div class="line">    <span class="keywordtype">double</span> ratio = (isovalue - zbottom) / (ztop - zbottom);</div><div class="line">    Point_3 p = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__barycenter__grp.html#ga43dafb654e67589a55dcf5b13092966b">CGAL::barycenter</a> (p0, (1 - ratio), p1,ratio);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (source_found)</div><div class="line">      target = p;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      source = p;</div><div class="line">      source_found = <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> Segment_3 (source, target);</div><div class="line">}</div><div class="line"></div><div class="line"></div></div><!-- fragment --><p> From these functions, we can create a graph of segments to process later into a set of polylines. To do so, we use the <a href="https://www.boost.org/doc/libs/1_72_0/libs/graph/doc/adjacency_list.html">boost::adjacency_list</a> structure and keep track of a mapping from the positions of the end points to the vertices of the graph.</p>
<p>The following code computes 50 isovalues evenly distributed between the minimum and maximum heights of the point cloud and creates a graph containing all isolevels:</p>
<div class="fragment"><div class="line"></div><div class="line">  std::array&lt;double, 50&gt; isovalues; <span class="comment">// Contour 50 isovalues</span></div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; isovalues.size(); ++ i)</div><div class="line">    isovalues[i] = bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a6c55430abc7fda54571cf1075c7f2f8b">zmin</a>() + ((i+1) * (bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a98def8b9515f31ded759d781969ddaf6">zmax</a>() - bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a6c55430abc7fda54571cf1075c7f2f8b">zmin</a>()) / (isovalues.size() - 2));</div><div class="line"></div><div class="line">  <span class="comment">// First find on each face if they are crossed by some isovalues and</span></div><div class="line">  <span class="comment">// extract segments in a graph</span></div><div class="line">  <span class="keyword">using</span> Segment_graph = boost::adjacency_list&lt;boost::listS, boost::vecS, boost::undirectedS, Point_3&gt;;</div><div class="line">  Segment_graph graph;</div><div class="line">  <span class="keyword">using</span> Map_p2v = std::map&lt;Point_3, Segment_graph::vertex_descriptor&gt;;</div><div class="line">  Map_p2v map_p2v;</div><div class="line">  <span class="keywordflow">for</span> (TIN::Face_handle vh : dtm_clean.finite_face_handles())</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">double</span> iv : isovalues)</div><div class="line">      <span class="keywordflow">if</span> (face_has_isovalue (vh, iv))</div><div class="line">      {</div><div class="line">        Segment_3 segment = isocontour_in_face (vh, iv);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> Point_3&amp; p : { segment.source(), segment.target() })</div><div class="line">        {</div><div class="line">          <span class="comment">// Only insert end points of segments once to get a well connected graph</span></div><div class="line">          Map_p2v::iterator iter;</div><div class="line">          <span class="keywordtype">bool</span> inserted;</div><div class="line">          std::tie (iter, inserted) = map_p2v.insert (std::make_pair (p, Segment_graph::vertex_descriptor()));</div><div class="line">          <span class="keywordflow">if</span> (inserted)</div><div class="line">          {</div><div class="line">            iter-&gt;second = boost::add_vertex (graph);</div><div class="line">            graph[iter-&gt;second] = p;</div><div class="line">          }</div><div class="line">        }</div><div class="line">        <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLEulerOperations.html#ga4661f850bc60686efeae2fc9d2ec3e65">boost::add_edge</a> (map_p2v[segment.source()], map_p2v[segment.target()], graph);</div><div class="line">      }</div><div class="line"></div></div><!-- fragment --> <h2><a class="anchor" id="TutorialGIS_Contour_Splitting"></a>
Splitting Into Polylines</h2>
<p>Once the graph is created, splitting it into polylines is easily performed using the function <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLPartition.html#ga99ea6bf193f1194db5e523e713c82fb9"><code>CGAL::split_graph_into_polylines()</code> </a>:</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="comment">// Split segments into polylines</span></div><div class="line">  std::vector&lt;std::vector&lt;Point_3&gt; &gt; polylines;</div><div class="line">  Polylines_visitor&lt;Segment_graph&gt; visitor (graph, polylines);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLPartition.html#ga99ea6bf193f1194db5e523e713c82fb9">CGAL::split_graph_into_polylines</a> (graph, visitor);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; polylines.size() &lt;&lt; <span class="stringliteral">" polylines computed, with "</span></div><div class="line">            &lt;&lt; map_p2v.size() &lt;&lt; <span class="stringliteral">" vertices in total"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Output to WKT file</span></div><div class="line">  std::ofstream contour_ofile (<span class="stringliteral">"contour.wkt"</span>);</div><div class="line">  contour_ofile.precision(18);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsWKT.html#ga013d6cd500473657f41c44c9df43c511">CGAL::IO::write_multi_linestring_WKT</a> (contour_ofile, polylines);</div><div class="line">  contour_ofile.close();</div><div class="line"></div></div><!-- fragment --><p> This function requires a visitor which is called when starting a polyline, when adding a point to it and when ending it. Defining such a class is straightforward in our case:</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph&gt;</div><div class="line"><span class="keyword">class </span>Polylines_visitor</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">  std::vector&lt;std::vector&lt;Point_3&gt; &gt;&amp; polylines;</div><div class="line">  Graph&amp; graph;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">  Polylines_visitor (Graph&amp; graph, std::vector&lt;std::vector&lt;Point_3&gt; &gt;&amp; polylines)</div><div class="line">    : polylines (polylines), graph(graph) { }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> start_new_polyline()</div><div class="line">  {</div><div class="line">    polylines.push_back (std::vector&lt;Point_3&gt;());</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> add_node (<span class="keyword">typename</span> Graph::vertex_descriptor vd)</div><div class="line">  {</div><div class="line">    polylines.back().push_back (graph[vd]);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> end_polyline()</div><div class="line">  {</div><div class="line">    <span class="comment">// filter small polylines</span></div><div class="line">    <span class="keywordflow">if</span> (polylines.back().size() &lt; 50)</div><div class="line">      polylines.pop_back();</div><div class="line">  }</div><div class="line">};</div><div class="line"></div></div><!-- fragment --> <h2><a class="anchor" id="TutorialGIS_Contour_Simplifying"></a>
Simplifying</h2>
<p>Because the output is quite noisy, users may want to simplify the polylines. CGAL provides a polyline simplification algorithm that guarantees that two polylines won't intersect after simplification. This algorithm takes advantage of the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Constrained__triangulation__plus__2.html">CGAL::Constrained_triangulation_plus_2</a></code>, which embeds polylines as a set of constraints:</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keyword">namespace </span>PS = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polyline_simplification_2.tag:../Polyline_simplification_2/" href="../Polyline_simplification_2/namespaceCGAL_1_1Polyline__simplification__2.html">CGAL::Polyline_simplification_2</a>;</div><div class="line"><span class="keyword">using</span> CDT_vertex_base = PS::Vertex_base_2&lt;Projection_traits&gt;;</div><div class="line"><span class="keyword">using</span> CDT_face_base = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Constrained__triangulation__face__base__2.html">CGAL::Constrained_triangulation_face_base_2&lt;Projection_traits&gt;</a>;</div><div class="line"><span class="keyword">using</span> CDT_TDS = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/TDS_2.tag:../TDS_2/" href="../TDS_2/classCGAL_1_1Triangulation__data__structure__2.html">CGAL::Triangulation_data_structure_2&lt;CDT_vertex_base, CDT_face_base&gt;</a>;</div><div class="line"><span class="keyword">using</span> CDT = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Constrained__Delaunay__triangulation__2.html">CGAL::Constrained_Delaunay_triangulation_2&lt;Projection_traits, CDT_TDS&gt;</a>;</div><div class="line"><span class="keyword">using</span> CTP = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Constrained__triangulation__plus__2.html">CGAL::Constrained_triangulation_plus_2&lt;CDT&gt;</a>;</div><div class="line"></div></div><!-- fragment --><p> The following code simplifies the polyline set based on the squared distance to the original polylines, stopping when no more vertex can be removed without going farther than 4 times the average spacing.</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="comment">// Construct constrained Delaunay triangulation with polylines as constraints</span></div><div class="line">  CTP ctp;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> std::vector&lt;Point_3&gt;&amp; poly : polylines)</div><div class="line">    ctp.insert_constraint (poly.begin(), poly.end());</div><div class="line"></div><div class="line">  <span class="comment">// Simplification algorithm with limit on distance</span></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga5339b0f11fdc9babbc5ca0b33f4a982c">PS::simplify</a> (ctp, PS::Squared_distance_cost(), PS::Stop_above_cost_threshold (16 * spacing * spacing));</div><div class="line"></div><div class="line">  polylines.clear();</div><div class="line">  <span class="keywordflow">for</span> (CTP::Constraint_id cid : ctp.constraints())</div><div class="line">  {</div><div class="line">    polylines.push_back (std::vector&lt;Point_3&gt;());</div><div class="line">    polylines.back().reserve (ctp.vertices_in_constraint (cid).size());</div><div class="line">    <span class="keywordflow">for</span> (CTP::Vertex_handle vh : ctp.vertices_in_constraint(cid))</div><div class="line">      polylines.back().push_back (vh-&gt;point());</div><div class="line">  }</div><div class="line"></div><div class="line">  std::size_t nb_vertices</div><div class="line">    = std::accumulate (polylines.begin(), polylines.end(), std::size_t(0),</div><div class="line">                       [](std::size_t size, <span class="keyword">const</span> std::vector&lt;Point_3&gt;&amp; poly) -&gt; std::size_t</div><div class="line">                       { <span class="keywordflow">return</span> size + poly.size(); });</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; nb_vertices</div><div class="line">            &lt;&lt; <span class="stringliteral">" vertices remaining after simplification ("</span></div><div class="line">            &lt;&lt; 100. * (nb_vertices / double(map_p2v.size())) &lt;&lt; <span class="stringliteral">"%)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Output to WKT file</span></div><div class="line">  std::ofstream simplified_ofile (<span class="stringliteral">"simplified.wkt"</span>);</div><div class="line">  simplified_ofile.precision(18);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsWKT.html#ga013d6cd500473657f41c44c9df43c511">CGAL::IO::write_multi_linestring_WKT</a> (simplified_ofile, polylines);</div><div class="line">  simplified_ofile.close();</div><div class="line"></div></div><!-- fragment --><p> Examples of contours and simplifications are given in <a class="el" href="tuto_gis.html#fig__TutorialGISFigContours">Figure 0.6</a>.</p>
<p><a class="anchor" id="fig__TutorialGISFigContours"></a></p><div class="image">
<img src="contours.png" alt="contours.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_gis.html#fig__TutorialGISFigContours">Figure 0.6</a> Contouring using 50 isovalues evenly spaced. Top: original contouring using 148k vertices and simplification with a tolerance equal to the average spacing of the input point cloud (3.4% of the original polyline vertices remaining). Bottom: simplification with tolerance 4 times the average spacing (1.3% of vertices remaining) and with tolerance 10 times the average spacing (0.9% of vertices remaining). Polylines are intersection-free in all cases.  </div> <br /> 
<h1><a class="anchor" id="TutorialGIS_Classify"></a>
Classifying</h1>
<p>CGAL provides a package Classification which can be used to segment a point cloud into a user-defined label set. The state-of-the-art classifier currently available in CGAL is the random forest from ETHZ. As it is a supervised classifier, a training set is needed.</p>
<p>The following snippet shows how to use some manually selected training set to train a random forest classifier and compute a classification regularized by a graph cut algorithm:</p>
<div class="fragment"><div class="line"></div><div class="line">  <span class="comment">// Get training from input</span></div><div class="line">  Point_set::Property_map&lt;int&gt; training_map;</div><div class="line">  <span class="keywordtype">bool</span> training_found;</div><div class="line">  std::tie (training_map, training_found) = points.property_map&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">"training"</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (training_found)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Classifying ground/vegetation/building"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// Create labels</span></div><div class="line">    Classification::Label_set labels ({ <span class="stringliteral">"ground"</span>, <span class="stringliteral">"vegetation"</span>, <span class="stringliteral">"building"</span> });</div><div class="line"></div><div class="line">    <span class="comment">// Generate features</span></div><div class="line">    Classification::Feature_set <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Mesh_3.tag:../Mesh_3/" href="../Mesh_3/group__PkgMesh3Parameters.html#ga0a990b28d55157c62d4bfd2624d408af">features</a>;</div><div class="line">    Classification::Point_set_feature_generator&lt;Kernel, Point_set, Point_set::Point_map&gt;</div><div class="line">      generator (points, points.point_map(), 5); <span class="comment">// 5 scales</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef CGAL_LINKED_WITH_TBB</span></div><div class="line">    <span class="comment">// If TBB is used, features can be computed in parallel</span></div><div class="line">    features.begin_parallel_additions();</div><div class="line">    generator.generate_point_based_features (features);</div><div class="line">    features.end_parallel_additions();</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    generator.generate_point_based_features (features);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">    <span class="comment">// Train a random forest classifier</span></div><div class="line">    Classification::ETHZ::Random_forest_classifier classifier (labels, features);</div><div class="line">    classifier.train (points.range(training_map));</div><div class="line"></div><div class="line">    <span class="comment">// Classify with graphcut regularization</span></div><div class="line">    Point_set::Property_map&lt;int&gt; label_map = points.add_property_map&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">"labels"</span>).first;</div><div class="line">    Classification::classify_with_graphcut&lt;Concurrency_tag&gt;</div><div class="line">      (points, points.point_map(), labels, classifier,</div><div class="line">       generator.neighborhood().k_neighbor_query(12), <span class="comment">// regularize on 12-neighbors graph</span></div><div class="line">       0.5f, <span class="comment">// graphcut weight</span></div><div class="line">       12, <span class="comment">// Subdivide to speed-up process</span></div><div class="line">       label_map);</div><div class="line"></div><div class="line">    <span class="comment">// Evaluate</span></div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Mean IoU on training data = "</span></div><div class="line">              &lt;&lt; Classification::Evaluation(labels,</div><div class="line">                                            points.range(training_map),</div><div class="line">                                            points.range(label_map)).mean_intersection_over_union() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// Save the classified point set</span></div><div class="line">    std::ofstream classified_ofile (<span class="stringliteral">"classified.ply"</span>);</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (classified_ofile);</div><div class="line">    classified_ofile &lt;&lt; points;</div><div class="line">    classified_ofile.close();</div><div class="line">  }</div><div class="line"></div></div><!-- fragment --><p> An example of training set and resulting classification is given in <a class="el" href="tuto_gis.html#fig__TutorialGISFigClassif">Figure 0.7</a>.</p>
<p><a class="anchor" id="fig__TutorialGISFigClassif"></a></p><div class="image">
<img src="classif_tuto.jpg" alt="classif_tuto.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="tuto_gis.html#fig__TutorialGISFigClassif">Figure 0.7</a> Top: a slice of the point cloud classified by hand. Bottom: a classification regularized by graph cut after training on 3 manually classified slices.  </div> <br /> 
<h1><a class="anchor" id="TutorialGIS_Code"></a>
Full Code Example</h1>
<p>All the code snippets used in this tutorial can be assembled to create a full GIS pipeline (provided the correct <em>includes</em> are used). We give a full code example which achieves all the steps described in this tutorial.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Projection_traits_xy_3.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Delaunay_triangulation_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Triangulation_vertex_base_with_info_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Triangulation_face_base_with_info_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/graph_traits_Delaunay_triangulation_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/copy_face_graph.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3/IO.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/compute_average_spacing.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/locate.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/triangulate_hole.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/border.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polygon_mesh_processing/remesh.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/graph/adjacency_list.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/boost/graph/split_graph_into_polylines.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/WKT.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Constrained_Delaunay_triangulation_2.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Constrained_triangulation_plus_2.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyline_simplification_2/simplify.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Polyline_simplification_2/Squared_distance_cost.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Classification.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Random.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;queue&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include "include/Color_ramp.h"</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">using</span> Kernel = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div><div class="line"><span class="keyword">using</span> Projection_traits = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Projection__traits__xy__3.html">CGAL::Projection_traits_xy_3&lt;Kernel&gt;</a>;</div><div class="line"><span class="keyword">using</span> Point_2 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ada7ccf9efead4df158c2317406e5fa6c">Kernel::Point_2</a>;</div><div class="line"><span class="keyword">using</span> Point_3 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ae82b7f4be77dd5b8819ebe419e4ae753">Kernel::Point_3</a>;</div><div class="line"><span class="keyword">using</span> Segment_3 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#aa43a461b2027ef7d99b776a7b03ef230">Kernel::Segment_3</a>;</div><div class="line"></div><div class="line"><span class="comment">// Triangulated Irregular Network</span></div><div class="line"><span class="keyword">using</span> TIN = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2&lt;Projection_traits&gt;</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Triangulated Irregular Network (with info)</span></div><div class="line"><span class="keyword">using</span> Point_set = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3&lt;Point_3&gt;</a>;</div><div class="line"><span class="keyword">using</span> Vbi = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Triangulation__vertex__base__with__info__2.html">CGAL::Triangulation_vertex_base_with_info_2 &lt;Point_set::Index, Projection_traits&gt;</a>;</div><div class="line"><span class="keyword">using</span> Fbi = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Triangulation__face__base__with__info__2.html">CGAL::Triangulation_face_base_with_info_2&lt;int, Projection_traits&gt;</a>;</div><div class="line"><span class="keyword">using</span> TDS = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/TDS_2.tag:../TDS_2/" href="../TDS_2/classCGAL_1_1Triangulation__data__structure__2.html">CGAL::Triangulation_data_structure_2&lt;Vbi, Fbi&gt;</a>;</div><div class="line"><span class="keyword">using</span> TIN_with_info = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2&lt;Projection_traits, TDS&gt;</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Classification = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Classification.tag:../Classification/" href="../Classification/namespaceCGAL_1_1Classification.html">CGAL::Classification</a>;</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef CGAL_LINKED_WITH_TBB</span></div><div class="line"><span class="keyword">using</span> Concurrency_tag = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__tag.html">CGAL::Parallel_tag</a>;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line"><span class="keyword">using</span> Concurrency_tag = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Sequential__tag.html">CGAL::Sequential_tag</a>;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> face_has_isovalue (TIN::Face_handle fh, <span class="keywordtype">double</span> isovalue)</div><div class="line">{</div><div class="line">  <span class="keywordtype">bool</span> above = <span class="keyword">false</span>, below = <span class="keyword">false</span>;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++ i)</div><div class="line">  {</div><div class="line">    <span class="comment">// Face has isovalue if one of its vertices is above and another</span></div><div class="line">    <span class="comment">// one below</span></div><div class="line">    <span class="keywordflow">if</span> (fh-&gt;vertex(i)-&gt;point().z() &gt; isovalue)</div><div class="line">      above = <span class="keyword">true</span>;</div><div class="line">    <span class="keywordflow">if</span> (fh-&gt;vertex(i)-&gt;point().z() &lt; isovalue)</div><div class="line">      below = <span class="keyword">true</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> (above &amp;&amp; below);</div><div class="line">}</div><div class="line"></div><div class="line">Segment_3 isocontour_in_face (TIN::Face_handle fh, <span class="keywordtype">double</span> isovalue)</div><div class="line">{</div><div class="line">  Point_3 source;</div><div class="line">  Point_3 target;</div><div class="line">  <span class="keywordtype">bool</span> source_found = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++ i)</div><div class="line">  {</div><div class="line">    Point_3 p0 = fh-&gt;vertex((i+1) % 3)-&gt;point();</div><div class="line">    Point_3 p1 = fh-&gt;vertex((i+2) % 3)-&gt;point();</div><div class="line"></div><div class="line">    <span class="comment">// Check if the isovalue crosses segment (p0,p1)</span></div><div class="line">    <span class="keywordflow">if</span> ((p0.z() - isovalue) * (p1.z() - isovalue) &gt; 0)</div><div class="line">      <span class="keywordflow">continue</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> zbottom = p0.z();</div><div class="line">    <span class="keywordtype">double</span> ztop = p1.z();</div><div class="line">    <span class="keywordflow">if</span> (zbottom &gt; ztop)</div><div class="line">    {</div><div class="line">      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polynomial.tag:../Polynomial/" href="../Polynomial/group__PkgPolynomialFunctions.html#gaa555a2d0a5bf3730c337f08f07356c07">std::swap</a> (zbottom, ztop);</div><div class="line">      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polynomial.tag:../Polynomial/" href="../Polynomial/group__PkgPolynomialFunctions.html#gaa555a2d0a5bf3730c337f08f07356c07">std::swap</a> (p0, p1);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Compute position of segment vertex</span></div><div class="line">    <span class="keywordtype">double</span> ratio = (isovalue - zbottom) / (ztop - zbottom);</div><div class="line">    Point_3 p = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__barycenter__grp.html#ga43dafb654e67589a55dcf5b13092966b">CGAL::barycenter</a> (p0, (1 - ratio), p1,ratio);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (source_found)</div><div class="line">      target = p;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      source = p;</div><div class="line">      source_found = <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> Segment_3 (source, target);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph&gt;</div><div class="line"><span class="keyword">class </span>Polylines_visitor</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">  std::vector&lt;std::vector&lt;Point_3&gt; &gt;&amp; polylines;</div><div class="line">  Graph&amp; graph;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line"></div><div class="line">  Polylines_visitor (Graph&amp; graph, std::vector&lt;std::vector&lt;Point_3&gt; &gt;&amp; polylines)</div><div class="line">    : polylines (polylines), graph(graph) { }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> start_new_polyline()</div><div class="line">  {</div><div class="line">    polylines.push_back (std::vector&lt;Point_3&gt;());</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> add_node (<span class="keyword">typename</span> Graph::vertex_descriptor vd)</div><div class="line">  {</div><div class="line">    polylines.back().push_back (graph[vd]);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> end_polyline()</div><div class="line">  {</div><div class="line">    <span class="comment">// filter small polylines</span></div><div class="line">    <span class="keywordflow">if</span> (polylines.back().size() &lt; 50)</div><div class="line">      polylines.pop_back();</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>PS = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polyline_simplification_2.tag:../Polyline_simplification_2/" href="../Polyline_simplification_2/namespaceCGAL_1_1Polyline__simplification__2.html">CGAL::Polyline_simplification_2</a>;</div><div class="line"><span class="keyword">using</span> CDT_vertex_base = PS::Vertex_base_2&lt;Projection_traits&gt;;</div><div class="line"><span class="keyword">using</span> CDT_face_base = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Constrained__triangulation__face__base__2.html">CGAL::Constrained_triangulation_face_base_2&lt;Projection_traits&gt;</a>;</div><div class="line"><span class="keyword">using</span> CDT_TDS = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/TDS_2.tag:../TDS_2/" href="../TDS_2/classCGAL_1_1Triangulation__data__structure__2.html">CGAL::Triangulation_data_structure_2&lt;CDT_vertex_base, CDT_face_base&gt;</a>;</div><div class="line"><span class="keyword">using</span> CDT = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Constrained__Delaunay__triangulation__2.html">CGAL::Constrained_Delaunay_triangulation_2&lt;Projection_traits, CDT_TDS&gt;</a>;</div><div class="line"><span class="keyword">using</span> CTP = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/classCGAL_1_1Constrained__triangulation__plus__2.html">CGAL::Constrained_triangulation_plus_2&lt;CDT&gt;</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname = argc != 2 ? <a class="code" href="namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/b9_training.ply"</span>) : argv[1];</div><div class="line">  <span class="keywordflow">if</span> (argc != 2)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Usage: "</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">" points.ply"</span> &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Running with default value "</span> &lt;&lt; fname &lt;&lt; <span class="stringliteral">"\n"</span>;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Read points</span></div><div class="line">  std::ifstream ifile (fname, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/classCGAL_1_1Point__set__3.html">CGAL::Point_set_3&lt;Point_3&gt;</a> points;</div><div class="line">  ifile &gt;&gt; points;</div><div class="line">  std::cerr &lt;&lt; points.size() &lt;&lt; <span class="stringliteral">" point(s) read"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Create DSM</span></div><div class="line">  TIN dsm (points.points().begin(), points.points().end());</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">using</span> Mesh = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/classCGAL_1_1Surface__mesh.html">CGAL::Surface_mesh&lt;Point_3&gt;</a>;</div><div class="line"></div><div class="line">  Mesh dsm_mesh;</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#ga2682fb7d5f4ff4eb65607ae4118e31bc">CGAL::copy_face_graph</a> (dsm, dsm_mesh);</div><div class="line">  std::ofstream dsm_ofile (<span class="stringliteral">"dsm.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (dsm_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (dsm_ofile, dsm_mesh);</div><div class="line">  dsm_ofile.close();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">auto</span> idx_to_point_with_info</div><div class="line">    = [&amp;](<span class="keyword">const</span> Point_set::Index&amp; idx) -&gt; std::pair&lt;Point_3, Point_set::Index&gt;</div><div class="line">      {</div><div class="line">        <span class="keywordflow">return</span> std::make_pair (points.point(idx), idx);</div><div class="line">      };</div><div class="line"></div><div class="line">  TIN_with_info tin_with_info</div><div class="line">    (boost::make_transform_iterator (points.begin(), idx_to_point_with_info),</div><div class="line">     boost::make_transform_iterator (points.end(), idx_to_point_with_info));</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> spacing = CGAL::compute_average_spacing&lt;Concurrency_tag&gt;(points, 6);</div><div class="line">  spacing *= 2;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> face_height</div><div class="line">    = [&amp;](<span class="keyword">const</span> TIN_with_info::Face_handle fh) -&gt; <span class="keywordtype">double</span></div><div class="line">      {</div><div class="line">        <span class="keywordtype">double</span> out = 0.;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++ i)</div><div class="line">          out = (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/group__nt__util.html#gad7dbfa919e255b52f36ea1512a92cb78">std::max</a>) (out, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga1d5106cf8be16adb4c4dc8b1ec3a5a92">CGAL::abs</a>(fh-&gt;vertex(i)-&gt;point().z() - fh-&gt;vertex((i+1)%3)-&gt;point().z()));</div><div class="line">        <span class="keywordflow">return</span> out;</div><div class="line">      };</div><div class="line"></div><div class="line">  <span class="comment">// Initialize faces info</span></div><div class="line">  <span class="keywordflow">for</span> (TIN_with_info::Face_handle fh : tin_with_info.all_face_handles())</div><div class="line">    <span class="keywordflow">if</span> (tin_with_info.is_infinite(fh) || face_height(fh) &gt; spacing) <span class="comment">// Filtered faces are given info() = -2</span></div><div class="line">      fh-&gt;info() = -2;</div><div class="line">    <span class="keywordflow">else</span> <span class="comment">// Pending faces are given info() = -1;</span></div><div class="line">      fh-&gt;info() = -1;</div><div class="line"></div><div class="line">  <span class="comment">// Flooding algorithm</span></div><div class="line">  std::vector&lt;int&gt; component_size;</div><div class="line">  <span class="keywordflow">for</span> (TIN_with_info::Face_handle fh : tin_with_info.finite_face_handles())</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (fh-&gt;info() != -1)</div><div class="line">      <span class="keywordflow">continue</span>;</div><div class="line"></div><div class="line">    std::queue&lt;TIN_with_info::Face_handle&gt; todo;</div><div class="line">    todo.push(fh);</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> size = 0;</div><div class="line">    <span class="keywordflow">while</span> (!todo.empty())</div><div class="line">    {</div><div class="line">      TIN_with_info::Face_handle current = todo.front();</div><div class="line">      todo.pop();</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (current-&gt;info() != -1)</div><div class="line">        <span class="keywordflow">continue</span>;</div><div class="line">      current-&gt;info() = int(component_size.size());</div><div class="line">      ++ size;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++ i)</div><div class="line">        todo.push (current-&gt;neighbor(i));</div><div class="line">    }</div><div class="line"></div><div class="line">    component_size.push_back (size);</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; component_size.size() &lt;&lt; <span class="stringliteral">" connected component(s) found"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  Mesh tin_colored_mesh;</div><div class="line"></div><div class="line">  Mesh::Property_map&lt;Mesh::Face_index, CGAL::IO::Color&gt;</div><div class="line">    color_map = tin_colored_mesh.add_property_map&lt;Mesh::Face_index, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a>&gt;(<span class="stringliteral">"f:color"</span>).first;</div><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#ga2682fb7d5f4ff4eb65607ae4118e31bc">CGAL::copy_face_graph</a> (tin_with_info, tin_colored_mesh,</div><div class="line">                         CGAL::parameters::face_to_face_output_iterator</div><div class="line">                         (boost::make_function_output_iterator</div><div class="line">                          ([&amp;](<span class="keyword">const</span> std::pair&lt;TIN_with_info::Face_handle, Mesh::Face_index&gt;&amp; ff)</div><div class="line">                           {</div><div class="line">                             <span class="comment">// Color unassigned faces gray</span></div><div class="line">                             <span class="keywordflow">if</span> (ff.first-&gt;info() &lt; 0)</div><div class="line">                               color_map[ff.second] = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a>(128, 128, 128);</div><div class="line">                             <span class="keywordflow">else</span></div><div class="line">                             {</div><div class="line">                               <span class="comment">// Random color seeded by the component ID</span></div><div class="line">                               <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Generator.tag:../Generator/" href="../Generator/classCGAL_1_1Random.html">CGAL::Random</a> r (ff.first-&gt;info());</div><div class="line">                               color_map[ff.second] = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1IO_1_1Color.html">CGAL::IO::Color</a> (r.get_int(64, 192),</div><div class="line">                                                                   r.get_int(64, 192),</div><div class="line">                                                                   r.get_int(64, 192));</div><div class="line">                             }</div><div class="line">                           })));</div><div class="line"></div><div class="line">  std::ofstream tin_colored_ofile (<span class="stringliteral">"colored_tin.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (tin_colored_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (tin_colored_ofile, tin_colored_mesh);</div><div class="line">  tin_colored_ofile.close();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> min_size = int(points.size() / 2);</div><div class="line"></div><div class="line">  std::vector&lt;TIN_with_info::Vertex_handle&gt; to_remove;</div><div class="line">  <span class="keywordflow">for</span> (TIN_with_info::Vertex_handle vh : tin_with_info.finite_vertex_handles())</div><div class="line">  {</div><div class="line">    TIN_with_info::Face_circulator circ = tin_with_info.incident_faces (vh),</div><div class="line">      start = circ;</div><div class="line"></div><div class="line">    <span class="comment">// Remove a vertex if it's only adjacent to components smaller than threshold</span></div><div class="line">    <span class="keywordtype">bool</span> keep = <span class="keyword">false</span>;</div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (circ-&gt;info() &gt;= 0 &amp;&amp; component_size[std::size_t(circ-&gt;info())] &gt; min_size)</div><div class="line">      {</div><div class="line">        keep = <span class="keyword">true</span>;</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">while</span> (++ circ != start);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (!keep)</div><div class="line">      to_remove.push_back (vh);</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; to_remove.size() &lt;&lt; <span class="stringliteral">" vertices(s) will be removed after filtering"</span> &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (TIN_with_info::Vertex_handle vh : to_remove)</div><div class="line">    tin_with_info.remove (vh);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Copy and keep track of overly large faces</span></div><div class="line">  Mesh dtm_mesh;</div><div class="line"></div><div class="line">  std::vector&lt;Mesh::Face_index&gt; face_selection;</div><div class="line">  Mesh::Property_map&lt;Mesh::Face_index, bool&gt; face_selection_map</div><div class="line">   = dtm_mesh.add_property_map&lt;Mesh::Face_index, <span class="keywordtype">bool</span>&gt;(<span class="stringliteral">"is_selected"</span>, <span class="keyword">false</span>).first;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> limit = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga07001b5ddc5c43096c811c91a306be9a">CGAL::square</a> (5 * spacing);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLHelperFct.html#ga2682fb7d5f4ff4eb65607ae4118e31bc">CGAL::copy_face_graph</a> (tin_with_info, dtm_mesh,</div><div class="line">                         CGAL::parameters::face_to_face_output_iterator</div><div class="line">                         (boost::make_function_output_iterator</div><div class="line">                          ([&amp;](<span class="keyword">const</span> std::pair&lt;TIN_with_info::Face_handle, Mesh::Face_index&gt;&amp; ff)</div><div class="line">                           {</div><div class="line">                             <span class="keywordtype">double</span> longest_edge = 0.;</div><div class="line">                             <span class="keywordtype">bool</span> border = <span class="keyword">false</span>;</div><div class="line">                             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++ i)</div><div class="line">                             {</div><div class="line">                               longest_edge = (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Number_types.tag:../Number_types/" href="../Number_types/group__nt__util.html#gad7dbfa919e255b52f36ea1512a92cb78">std::max</a>)(longest_edge, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">CGAL::squared_distance</a></div><div class="line">                                                         (ff.first-&gt;vertex((i+1)%3)-&gt;point(),</div><div class="line">                                                          ff.first-&gt;vertex((i+2)%3)-&gt;point()));</div><div class="line"></div><div class="line">                               TIN_with_info::Face_circulator circ</div><div class="line">                                 = tin_with_info.incident_faces (ff.first-&gt;vertex(i)),</div><div class="line">                                 start = circ;</div><div class="line">                               <span class="keywordflow">do</span></div><div class="line">                               {</div><div class="line">                                 <span class="keywordflow">if</span> (tin_with_info.is_infinite (circ))</div><div class="line">                                 {</div><div class="line">                                   border = <span class="keyword">true</span>;</div><div class="line">                                   <span class="keywordflow">break</span>;</div><div class="line">                                 }</div><div class="line">                               }</div><div class="line">                               <span class="keywordflow">while</span> (++ circ != start);</div><div class="line"></div><div class="line">                               <span class="keywordflow">if</span> (border)</div><div class="line">                                 <span class="keywordflow">break</span>;</div><div class="line">                             }</div><div class="line"></div><div class="line">                             <span class="comment">// Select if face is too big AND it's not</span></div><div class="line">                             <span class="comment">// on the border (to have closed holes)</span></div><div class="line">                             <span class="keywordflow">if</span> (!border &amp;&amp; longest_edge &gt; limit)</div><div class="line">                             {</div><div class="line">                               face_selection_map[ff.second] = <span class="keyword">true</span>;</div><div class="line">                               face_selection.push_back (ff.second);</div><div class="line">                             }</div><div class="line">                           })));</div><div class="line"></div><div class="line">  <span class="comment">// Save original DTM</span></div><div class="line">  std::ofstream dtm_ofile (<span class="stringliteral">"dtm.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (dtm_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (dtm_ofile, dtm_mesh);</div><div class="line">  dtm_ofile.close();</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; face_selection.size() &lt;&lt; <span class="stringliteral">" face(s) are selected for removal"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Expand face selection to keep a well formed 2-manifold mesh after removal</span></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLSelectionFct.html#ga6f8d338df28c24bbf93677f24f7bcbbe">CGAL::expand_face_selection_for_removal</a> (face_selection, dtm_mesh, face_selection_map);</div><div class="line">  face_selection.clear();</div><div class="line">  <span class="keywordflow">for</span> (Mesh::Face_index fi : faces(dtm_mesh))</div><div class="line">    <span class="keywordflow">if</span> (face_selection_map[fi])</div><div class="line">      face_selection.push_back(fi);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; face_selection.size() &lt;&lt; <span class="stringliteral">" face(s) are selected for removal after expansion"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (Mesh::Face_index fi : face_selection)</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLEulerOperations.html#gacfae7ff8e782da55b941e4487e86c738">CGAL::Euler::remove_face</a> (halfedge(fi, dtm_mesh), dtm_mesh);</div><div class="line">  dtm_mesh.collect_garbage();</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (!dtm_mesh.is_valid())</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid mesh!"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Save filtered DTM</span></div><div class="line">  std::ofstream dtm_holes_ofile (<span class="stringliteral">"dtm_with_holes.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (dtm_holes_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (dtm_holes_ofile, dtm_mesh);</div><div class="line">  dtm_holes_ofile.close();</div><div class="line"></div><div class="line">  <span class="comment">// Get all holes</span></div><div class="line">  std::vector&lt;Mesh::Halfedge_index&gt; holes;</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PkgPolygonMeshProcessingRef.html#gafa9b682528c5dc2a4821d01193518d14">CGAL::Polygon_mesh_processing::extract_boundary_cycles</a> (dtm_mesh, std::back_inserter (holes));</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; holes.size() &lt;&lt; <span class="stringliteral">" hole(s) identified"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Identify outer hull (hole with maximum size)</span></div><div class="line">  <span class="keywordtype">double</span> max_size = 0.;</div><div class="line">  Mesh::Halfedge_index outer_hull;</div><div class="line">  <span class="keywordflow">for</span> (Mesh::Halfedge_index hi : holes)</div><div class="line">  {</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html">CGAL::Bbox_3</a> hole_bbox;</div><div class="line">    <span class="keywordflow">for</span> (Mesh::Halfedge_index haf : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLIterators.html#ga37229df31508a78eb4acdaf907e637e5">CGAL::halfedges_around_face</a>(hi, dtm_mesh))</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> Point_3&amp; p = dtm_mesh.point(target(haf, dtm_mesh));</div><div class="line">      hole_bbox += p.bbox();</div><div class="line">    }</div><div class="line">    <span class="keywordtype">double</span> size = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">CGAL::squared_distance</a> (Point_2(hole_bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#aab574470a2591f187553ca1166e682e1">xmin</a>(), hole_bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a2088e16a1f0a20e011e5b94c2e9c222a">ymin</a>()),</div><div class="line">                                          Point_2(hole_bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a3f5e323700e1509624a02d151237cc4c">xmax</a>(), hole_bbox.<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html#a9d06f61bd89faa841e011ff53edf745f">ymax</a>()));</div><div class="line">    <span class="keywordflow">if</span> (size &gt; max_size)</div><div class="line">    {</div><div class="line">      max_size = size;</div><div class="line">      outer_hull = hi;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Fill all holes except the bigest (which is the outer hull of the mesh)</span></div><div class="line">  <span class="keywordflow">for</span> (Mesh::Halfedge_index hi : holes)</div><div class="line">    <span class="keywordflow">if</span> (hi != outer_hull)</div><div class="line">      <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__hole__filling__grp.html#ga16473e4861b13d1241edee68f596b153">CGAL::Polygon_mesh_processing::triangulate_refine_and_fair_hole</a></div><div class="line">        (dtm_mesh, hi, <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Emptyset__iterator.html">CGAL::Emptyset_iterator</a>(), <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Emptyset__iterator.html">CGAL::Emptyset_iterator</a>());</div><div class="line"></div><div class="line">  <span class="comment">// Save DTM with holes filled</span></div><div class="line">  std::ofstream dtm_filled_ofile (<span class="stringliteral">"dtm_filled.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (dtm_filled_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (dtm_filled_ofile, dtm_mesh);</div><div class="line">  dtm_filled_ofile.close();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__meshing__grp.html#gaa5cc92275df27f0baab2472ecbc4ea3f">CGAL::Polygon_mesh_processing::isotropic_remeshing</a> (faces(dtm_mesh), spacing, dtm_mesh);</div><div class="line"></div><div class="line">  std::ofstream dtm_remeshed_ofile (<span class="stringliteral">"dtm_remeshed.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (dtm_remeshed_ofile);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurfaceMeshIOFuncPLY.html#ga50f0e9f2b293855d2c7f1a62939cbe8d">CGAL::IO::write_PLY</a> (dtm_remeshed_ofile, dtm_mesh);</div><div class="line">  dtm_remeshed_ofile.close();</div><div class="line"></div><div class="line"></div><div class="line">  TIN dtm_clean (dtm_mesh.points().begin(), dtm_mesh.points().end());</div><div class="line"></div><div class="line"></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Bbox__3.html">CGAL::Bbox_3</a> bbox = CGAL::bbox_3 (points.points().begin(), points.points().end());</div><div class="line"></div><div class="line">  <span class="comment">// Generate raster image 1920-pixels large</span></div><div class="line">  std::size_t width = 1920;</div><div class="line">  std::size_t height = std::size_t((bbox.ymax() - bbox.ymin()) * 1920 / (bbox.xmax() - bbox.xmin()));</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Rastering with resolution "</span> &lt;&lt; width &lt;&lt; <span class="stringliteral">"x"</span> &lt;&lt; height &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Use PPM format (Portable PixMap) for simplicity</span></div><div class="line">  std::ofstream raster_ofile (<span class="stringliteral">"raster.ppm"</span>, std::ios_base::binary);</div><div class="line"></div><div class="line">  <span class="comment">// PPM header</span></div><div class="line">  raster_ofile &lt;&lt; <span class="stringliteral">"P6"</span> &lt;&lt; std::endl <span class="comment">// magic number</span></div><div class="line">               &lt;&lt; width &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; height &lt;&lt; std::endl <span class="comment">// dimensions of the image</span></div><div class="line">               &lt;&lt; 255 &lt;&lt; std::endl; <span class="comment">// maximum color value</span></div><div class="line"></div><div class="line">  <span class="comment">// Use rainbow color ramp output</span></div><div class="line">  Color_ramp color_ramp;</div><div class="line"></div><div class="line">  <span class="comment">// Keeping track of location from one point to its neighbor allows</span></div><div class="line">  <span class="comment">// for fast locate in DT</span></div><div class="line">  TIN::Face_handle location;</div><div class="line"></div><div class="line">  <span class="comment">// Query each pixel of the image</span></div><div class="line">  <span class="keywordflow">for</span> (std::size_t y = 0; y &lt; height; ++ y)</div><div class="line">    <span class="keywordflow">for</span> (std::size_t x = 0; x &lt; width; ++ x)</div><div class="line">    {</div><div class="line">      Point_3 query (bbox.xmin() + x * (bbox.xmax() - bbox.xmin()) / <span class="keywordtype">double</span>(width),</div><div class="line">                     bbox.ymin() + (height-y) * (bbox.ymax() - bbox.ymin()) / <span class="keywordtype">double</span>(height),</div><div class="line">                     0); <span class="comment">// not relevant for location in 2D</span></div><div class="line"></div><div class="line">      location = dtm_clean.locate (query, location);</div><div class="line"></div><div class="line">      <span class="comment">// Points outside the convex hull will be colored black</span></div><div class="line">      std::array&lt;unsigned char, 3&gt; colors { 0, 0, 0 };</div><div class="line">      <span class="keywordflow">if</span> (!dtm_clean.is_infinite(location))</div><div class="line">      {</div><div class="line">        std::array&lt;double, 3&gt; barycentric_coordinates</div><div class="line">          = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PMP__locate__grp.html#gadd9f94997d1963426d38305192345564">CGAL::Polygon_mesh_processing::barycentric_coordinates</a></div><div class="line">          (Point_2 (location-&gt;vertex(0)-&gt;point().x(), location-&gt;vertex(0)-&gt;point().y()),</div><div class="line">           Point_2 (location-&gt;vertex(1)-&gt;point().x(), location-&gt;vertex(1)-&gt;point().y()),</div><div class="line">           Point_2 (location-&gt;vertex(2)-&gt;point().x(), location-&gt;vertex(2)-&gt;point().y()),</div><div class="line">           Point_2 (query.x(), query.y()),</div><div class="line">           Kernel());</div><div class="line"></div><div class="line">        <span class="keywordtype">double</span> height_at_query</div><div class="line">          = (barycentric_coordinates[0] * location-&gt;vertex(0)-&gt;point().z()</div><div class="line">             + barycentric_coordinates[1] * location-&gt;vertex(1)-&gt;point().z()</div><div class="line">             + barycentric_coordinates[2] * location-&gt;vertex(2)-&gt;point().z());</div><div class="line"></div><div class="line">        <span class="comment">// Color ramp generates a color depending on a value from 0 to 1</span></div><div class="line">        <span class="keywordtype">double</span> height_ratio = (height_at_query - bbox.zmin()) / (bbox.zmax() - bbox.zmin());</div><div class="line">        colors = color_ramp.get(height_ratio);</div><div class="line">      }</div><div class="line">      raster_ofile.write (reinterpret_cast&lt;char*&gt;(&amp;colors), 3);</div><div class="line">    }</div><div class="line"></div><div class="line">  raster_ofile.close();</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Smooth heights with 5 successive Gaussian filters</span></div><div class="line">  <span class="keywordtype">double</span> gaussian_variance = 4 * spacing * spacing;</div><div class="line">  <span class="keywordflow">for</span> (TIN::Vertex_handle vh : dtm_clean.finite_vertex_handles())</div><div class="line">  {</div><div class="line">    <span class="keywordtype">double</span> z = vh-&gt;point().z();</div><div class="line">    <span class="keywordtype">double</span> total_weight = 1;</div><div class="line"></div><div class="line">    TIN::Vertex_circulator circ = dtm_clean.incident_vertices (vh),</div><div class="line">      start = circ;</div><div class="line"></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (!dtm_clean.is_infinite(circ))</div><div class="line">      {</div><div class="line">        <span class="keywordtype">double</span> sq_dist = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">CGAL::squared_distance</a> (vh-&gt;point(), circ-&gt;point());</div><div class="line"></div><div class="line">        <span class="keywordtype">double</span> weight = std::exp(- sq_dist / gaussian_variance);</div><div class="line">        z += weight * circ-&gt;point().z();</div><div class="line">        total_weight += weight;</div><div class="line">      }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">while</span> (++ circ != start);</div><div class="line"></div><div class="line">    z /= total_weight;</div><div class="line"></div><div class="line">    vh-&gt;point() = Point_3 (vh-&gt;point().x(), vh-&gt;point().y(), z);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  std::array&lt;double, 50&gt; isovalues; <span class="comment">// Contour 50 isovalues</span></div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; isovalues.size(); ++ i)</div><div class="line">    isovalues[i] = bbox.zmin() + ((i+1) * (bbox.zmax() - bbox.zmin()) / (isovalues.size() - 2));</div><div class="line"></div><div class="line">  <span class="comment">// First find on each face if they are crossed by some isovalues and</span></div><div class="line">  <span class="comment">// extract segments in a graph</span></div><div class="line">  <span class="keyword">using</span> Segment_graph = boost::adjacency_list&lt;boost::listS, boost::vecS, boost::undirectedS, Point_3&gt;;</div><div class="line">  Segment_graph graph;</div><div class="line">  <span class="keyword">using</span> Map_p2v = std::map&lt;Point_3, Segment_graph::vertex_descriptor&gt;;</div><div class="line">  Map_p2v map_p2v;</div><div class="line">  <span class="keywordflow">for</span> (TIN::Face_handle vh : dtm_clean.finite_face_handles())</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">double</span> iv : isovalues)</div><div class="line">      <span class="keywordflow">if</span> (face_has_isovalue (vh, iv))</div><div class="line">      {</div><div class="line">        Segment_3 segment = isocontour_in_face (vh, iv);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> Point_3&amp; p : { segment.source(), segment.target() })</div><div class="line">        {</div><div class="line">          <span class="comment">// Only insert end points of segments once to get a well connected graph</span></div><div class="line">          Map_p2v::iterator iter;</div><div class="line">          <span class="keywordtype">bool</span> inserted;</div><div class="line">          std::tie (iter, inserted) = map_p2v.insert (std::make_pair (p, Segment_graph::vertex_descriptor()));</div><div class="line">          <span class="keywordflow">if</span> (inserted)</div><div class="line">          {</div><div class="line">            iter-&gt;second = boost::add_vertex (graph);</div><div class="line">            graph[iter-&gt;second] = p;</div><div class="line">          }</div><div class="line">        }</div><div class="line">        <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLEulerOperations.html#ga4661f850bc60686efeae2fc9d2ec3e65">boost::add_edge</a> (map_p2v[segment.source()], map_p2v[segment.target()], graph);</div><div class="line">      }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Split segments into polylines</span></div><div class="line">  std::vector&lt;std::vector&lt;Point_3&gt; &gt; polylines;</div><div class="line">  Polylines_visitor&lt;Segment_graph&gt; visitor (graph, polylines);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLPartition.html#ga99ea6bf193f1194db5e523e713c82fb9">CGAL::split_graph_into_polylines</a> (graph, visitor);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; polylines.size() &lt;&lt; <span class="stringliteral">" polylines computed, with "</span></div><div class="line">            &lt;&lt; map_p2v.size() &lt;&lt; <span class="stringliteral">" vertices in total"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Output to WKT file</span></div><div class="line">  std::ofstream contour_ofile (<span class="stringliteral">"contour.wkt"</span>);</div><div class="line">  contour_ofile.precision(18);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsWKT.html#ga013d6cd500473657f41c44c9df43c511">CGAL::IO::write_multi_linestring_WKT</a> (contour_ofile, polylines);</div><div class="line">  contour_ofile.close();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Construct constrained Delaunay triangulation with polylines as constraints</span></div><div class="line">  CTP ctp;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> std::vector&lt;Point_3&gt;&amp; poly : polylines)</div><div class="line">    ctp.insert_constraint (poly.begin(), poly.end());</div><div class="line"></div><div class="line">  <span class="comment">// Simplification algorithm with limit on distance</span></div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Algebraic_foundations.tag:../Algebraic_foundations/" href="../Algebraic_foundations/group__PkgAlgebraicFoundationsRef.html#ga5339b0f11fdc9babbc5ca0b33f4a982c">PS::simplify</a> (ctp, PS::Squared_distance_cost(), PS::Stop_above_cost_threshold (16 * spacing * spacing));</div><div class="line"></div><div class="line">  polylines.clear();</div><div class="line">  <span class="keywordflow">for</span> (CTP::Constraint_id cid : ctp.constraints())</div><div class="line">  {</div><div class="line">    polylines.push_back (std::vector&lt;Point_3&gt;());</div><div class="line">    polylines.back().reserve (ctp.vertices_in_constraint (cid).size());</div><div class="line">    <span class="keywordflow">for</span> (CTP::Vertex_handle vh : ctp.vertices_in_constraint(cid))</div><div class="line">      polylines.back().push_back (vh-&gt;point());</div><div class="line">  }</div><div class="line"></div><div class="line">  std::size_t nb_vertices</div><div class="line">    = std::accumulate (polylines.begin(), polylines.end(), std::size_t(0),</div><div class="line">                       [](std::size_t size, <span class="keyword">const</span> std::vector&lt;Point_3&gt;&amp; poly) -&gt; std::size_t</div><div class="line">                       { <span class="keywordflow">return</span> size + poly.size(); });</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; nb_vertices</div><div class="line">            &lt;&lt; <span class="stringliteral">" vertices remaining after simplification ("</span></div><div class="line">            &lt;&lt; 100. * (nb_vertices / double(map_p2v.size())) &lt;&lt; <span class="stringliteral">"%)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Output to WKT file</span></div><div class="line">  std::ofstream simplified_ofile (<span class="stringliteral">"simplified.wkt"</span>);</div><div class="line">  simplified_ofile.precision(18);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportIoFuncsWKT.html#ga013d6cd500473657f41c44c9df43c511">CGAL::IO::write_multi_linestring_WKT</a> (simplified_ofile, polylines);</div><div class="line">  simplified_ofile.close();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Get training from input</span></div><div class="line">  Point_set::Property_map&lt;int&gt; training_map;</div><div class="line">  <span class="keywordtype">bool</span> training_found;</div><div class="line">  std::tie (training_map, training_found) = points.property_map&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">"training"</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (training_found)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Classifying ground/vegetation/building"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// Create labels</span></div><div class="line">    Classification::Label_set labels ({ <span class="stringliteral">"ground"</span>, <span class="stringliteral">"vegetation"</span>, <span class="stringliteral">"building"</span> });</div><div class="line"></div><div class="line">    <span class="comment">// Generate features</span></div><div class="line">    Classification::Feature_set <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Mesh_3.tag:../Mesh_3/" href="../Mesh_3/group__PkgMesh3Parameters.html#ga0a990b28d55157c62d4bfd2624d408af">features</a>;</div><div class="line">    Classification::Point_set_feature_generator&lt;Kernel, Point_set, Point_set::Point_map&gt;</div><div class="line">      generator (points, points.point_map(), 5); <span class="comment">// 5 scales</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef CGAL_LINKED_WITH_TBB</span></div><div class="line">    <span class="comment">// If TBB is used, features can be computed in parallel</span></div><div class="line">    features.begin_parallel_additions();</div><div class="line">    generator.generate_point_based_features (features);</div><div class="line">    features.end_parallel_additions();</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    generator.generate_point_based_features (features);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">    <span class="comment">// Train a random forest classifier</span></div><div class="line">    Classification::ETHZ::Random_forest_classifier classifier (labels, features);</div><div class="line">    classifier.train (points.range(training_map));</div><div class="line"></div><div class="line">    <span class="comment">// Classify with graphcut regularization</span></div><div class="line">    Point_set::Property_map&lt;int&gt; label_map = points.add_property_map&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">"labels"</span>).first;</div><div class="line">    Classification::classify_with_graphcut&lt;Concurrency_tag&gt;</div><div class="line">      (points, points.point_map(), labels, classifier,</div><div class="line">       generator.neighborhood().k_neighbor_query(12), <span class="comment">// regularize on 12-neighbors graph</span></div><div class="line">       0.5f, <span class="comment">// graphcut weight</span></div><div class="line">       12, <span class="comment">// Subdivide to speed-up process</span></div><div class="line">       label_map);</div><div class="line"></div><div class="line">    <span class="comment">// Evaluate</span></div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Mean IoU on training data = "</span></div><div class="line">              &lt;&lt; Classification::Evaluation(labels,</div><div class="line">                                            points.range(training_map),</div><div class="line">                                            points.range(label_map)).mean_intersection_over_union() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// Save the classified point set</span></div><div class="line">    std::ofstream classified_ofile (<span class="stringliteral">"classified.ply"</span>);</div><div class="line">    <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a> (classified_ofile);</div><div class="line">    classified_ofile &lt;&lt; points;</div><div class="line">    classified_ofile.close();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="TutorialGIS_Reference"></a>
References</h1>
<p>This tutorial is based on the following CGAL packages:</p>
<ul>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Triangulation_2.tag:../Triangulation_2/" href="../Triangulation_2/group__PkgTriangulation2Ref.html">2D Triangulations Reference</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_3.tag:../Point_set_3/" href="../Point_set_3/group__PkgPointSet3Ref.html">3D Point Set Reference</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Point_set_processing_3.tag:../Point_set_processing_3/" href="../Point_set_processing_3/group__PkgPointSetProcessing3Ref.html">Point Set Processing Reference</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Surface_mesh.tag:../Surface_mesh/" href="../Surface_mesh/group__PkgSurface__mesh.html">Surface Mesh Reference</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__PkgBGLRef.html">CGAL and the Boost Graph Library Reference</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polygon_mesh_processing.tag:../Polygon_mesh_processing/" href="../Polygon_mesh_processing/group__PkgPolygonMeshProcessingRef.html">Polygon Mesh Processing Reference</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Polyline_simplification_2.tag:../Polyline_simplification_2/" href="../Polyline_simplification_2/group__PkgPolylineSimplification2Ref.html">2D Polyline Simplification Reference</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Classification.tag:../Classification/" href="../Classification/group__PkgClassificationRef.html">Classification Reference</a></li>
</ul>
<p>The data set used throughout this tutorial comes from the <a href="https://www.usgs.gov/">https://www.usgs.gov/</a> database, licensed under the <em>US Government Public Domain</em>. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jul 4 2022 13:24:47 for CGAL 5.6 - Manual by
    <a href="https://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>
</html>

</html>
