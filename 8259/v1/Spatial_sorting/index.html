<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Spatial_sorting/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=11">
<meta name="generator" content="Doxygen 1.9.6">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CGAL 6.1 - Spatial Sorting: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/doxygen.css" rel="stylesheet" type="text/css">
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      },
      equationNumbers: { autoNumber: "AMS" }
  }
}
);
MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
  var PARSE = MathJax.InputJax.TeX.Parse,
      TEXT = PARSE.prototype.InternalText;
  PARSE.Augment({
    InternalText: function (text,def) {
      text = text.replace(/\\/g,"");
      return TEXT.call(this,text,def);
    }
  });
});
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
      <span class="left">
         <span id="MSearchSelect" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()">Â 
        </span>
        <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
      </span>
      <span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.svg" alt=""></a>
      </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CGAL 6.1 - Spatial Sorting
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search/",'.html');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">User Manual </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Spatial_Sorting"></a><a class="anchor" id="chapspatial_sorting"></a></p> <div id="autotoc" class="toc"></div> <dl class="section author"><dt>Authors</dt><dd>Christophe Delage and Olivier Devillers</dd></dl>
<h1><a class="anchor" id="Spatial_sortingIntroduction"></a>
Introduction</h1>
<p>Many geometric algorithms implemented in CGAL are incremental, and thus their speed is dependent on the order of insertion. This package provides sorting algorithms that may considerably improve running times of such algorithms.</p>
<p>The rationale is to sort objects along a space-filling curve so that two objects close geometrically will be close in the insertion order with high probability. That way, parts of a data structure that will be looked at during an insertion will probably have been looked at in a recent insertion, and thus probably will be in cache memory instead of main memory. As another side-effect, these sorting functions usually improve memory locality of the data structures produced by incremental algorithms, sometimes leading to speed ups in other algorithm using these data structures.</p>
<p>Some algorithms have a good complexity under randomized hypotheses which contradicts the idea of sorting the input using any sorting criterion. In such a case, it is possible to introduce just a bit of randomness to be able to combine the good randomized complexity and the good effects of locality <a class="el" href="citelist.html#CITEREF_acr-icb-03">[1]</a>.</p>
<p>The predicates used by this package are comparisons between coordinates, thus there is no robustness issue involved here, for example to choose the arithmetic of the kernel.</p>
<h1><a class="anchor" id="sechilbert_sorting"></a>
Hilbert Sorting</h1>
<p>In 2D, one can construct a space filling curve, that is a mapping \( f\) of \( [0,1]\) to the unit square \( [0,1]^2\), such that \( f(0)=(0,0)\) and \( f(1)=(1,0)\) in the following way: the unit square is subdivided in four such that</p>
<dl class="section user"><dt></dt><dd>\( f([0,\frac{1}{4}])=[0,\frac{1}{2}]^2\), \( f([\frac{1}{4},\frac{1}{2}])=[0,\frac{1}{2}]\times[\frac{1}{2},1]\), \( f([\frac{1}{2},\frac{3}{4}])=[\frac{1}{2},1]^2\), and \( f([\frac{3}{4},1])=[\frac{1}{2},1]\times[0,\frac{1}{2}].\) <br>
 \( f(\frac{1}{4})=(0,\frac{1}{2})\), \( f(\frac{1}{2})=(\frac{1}{2},\frac{1}{2})\), and \( f(\frac{3}{4})=(1,\frac{1}{2})\).</dd></dl>
<p>Then each square is subdivided in the same way recursively. <a class="el" href="index.html#fig__Spatial_sorting_fig_Hilbert8">Figure 98.1</a> illustrates this process.</p>
<p><a class="anchor" id="fig__Spatial_sorting_fig_Hilbert8"></a> </p><div class="image">
<img src="Hilbert8.png" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__Spatial_sorting_fig_Hilbert8">Figure 98.1</a> Hilbert mapping </p> </div> <p> <br>
</p>
<p>Now given a set of 2D points, they can be sorted in the order they have on such a space filling curve. Note that at each step, we split a square exactly at its center; we call this subdivision policy: <em>middle</em> policy (see <a class="el" href="index.html#fig__Spatial_sorting_fig_Hilbert_middle">Figure 98.2</a>).</p>
<p><a class="anchor" id="fig__Spatial_sorting_fig_Hilbert_middle"></a> </p><div class="image">
<img src="Hilbert-middle.png" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__Spatial_sorting_fig_Hilbert_middle">Figure 98.2</a> Hilbert sort with middle policy </p> </div> <p> <br>
</p>
<p>If instead of subdividing the square in a fixed way at its center, as above, we subdivide it by splitting at the median point (in \( x\) or \( y\) directions alternating), we construct a 2-d tree adapted to the point set. This tree can be visited in a similar manner and we get also a suitable ordering of the points; we call this subdivision policy: <em>median</em> policy (see <a class="el" href="index.html#fig__Spatial_sorting_fig_Hilbert_median">Figure 98.3</a>).</p>
<p><a class="anchor" id="fig__Spatial_sorting_fig_Hilbert_median"></a> </p><div class="image">
<img src="Hilbert-median.png" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__Spatial_sorting_fig_Hilbert_median">Figure 98.3</a> Hilbert sort with median policy </p> </div> <p> <br>
</p>
<p>The middle policy is easier to analyze, and is interesting in practice for well distributed set of points in small dimension (if the number of points is really larger than \( 2^d\)). The median policy should be preferred for high dimension or if the point set distribution is not regular (or unknown). Since the median policy cannot be much worse than the middle policy, while the converse can happen, the median policy is the default behavior. Most theoretical results are using the middle policy <a class="el" href="citelist.html#CITEREF_acr-icb-03">[1]</a>, <a class="el" href="citelist.html#CITEREF_bg-sfche-89">[2]</a>, <a class="el" href="citelist.html#CITEREF_b-aahsf-71">[3]</a>, <a class="el" href="citelist.html#CITEREF_pb-scpts-89">[4]</a>.</p>
<p>CGAL provides Hilbert sorting for points in 2D, 3D and higher dimensions, in the middle and the median policies.</p>
<p>We also consider space filling curves on a given sphere. The method is described for the unit sphere below; it works on any sphere by an affine transformation. The points to be sorted are supposed to be close to the sphere.</p>
<p>Actually, we approximate a space filling curve on the unit sphere by a space filling curve on a cube (with facets at \(x, y, z = \pm 1/\sqrt{3}\)). Roughly speaking, we split the original set of points in six subsets corresponding to the six facets of the cube. The subset corresponding to a facet \(f\) is the set of points that lie in the half-space defined by the supporting plane of \(f\) that does not contain the origin. And then we basically use the 2D Hilbert sort with its corresponding policy, as explained above for the projection of the points in each subset on its corresponding facet of the cube. The axes orientation on each facet is chosen so that the space filling curve covers the whole cube without any jump; see <a class="el" href="index.html#fig__Spatial_sorting_fig_Faces_orientations">Figure 98.4</a>. A point can lie in more than one such half-plane, so, we give a priority for each facet of the cube. The priority order is: first, the facet of the cube at \(x = 1/\sqrt{3}\); second, the facet of the cube at \(y = 1/\sqrt{3}\); third, the facet of the cube at \( x = -1/\sqrt{3}\); fourth, the facet of the cube at \( z = 1/\sqrt{3}\); fifth, the facet of the cube at \( y = -1/\sqrt{3}\); and, sixth, the facet of the cube at \( z = -1/\sqrt{3}\).</p>
<p>If points are not close to the sphere, they are still sorted the same way, however there is no guarantee that such an order is good anymore.</p>
<p><a class="anchor" id="fig__Spatial_sorting_fig_Faces_orientations"></a> </p><div class="image">
<img src="HilbertOnSphere.png" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__Spatial_sorting_fig_Faces_orientations">Figure 98.4</a> A 2D Hilbert sort for each facet of the cube </p> </div> <p> <br>
</p>
<p>Points sorted on the sphere according to the description above are depicted in <a class="el" href="index.html#fig__Spatial_sorting_fig_Hilbert_on_sphere">Figure 98.5</a>.</p>
<p><a class="anchor" id="fig__Spatial_sorting_fig_Hilbert_on_sphere"></a> </p><div class="image">
<img src="HilbertOnSphereIllustration.png" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__Spatial_sorting_fig_Hilbert_on_sphere">Figure 98.5</a> Hilbert sort on the sphere </p> </div> <p> <br>
</p>
<h2><a class="anchor" id="Spatial_sortingExamples"></a>
Examples</h2>
<p>The code to use Hilbert sort is as simple as the following example:</p>
<p><br>
<b>File</b> <a class="el" href="Spatial_sorting_2hilbert_8cpp-example.html">Spatial_sorting/hilbert.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/point_generators_2.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/hilbert_sort.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div>
<div class="line"><span class="keyword">typedef</span> K::Point_2                                          Point;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../STL_Extension/classCGAL_1_1Creator__uniform__2.html">CGAL::Creator_uniform_2&lt;double,Point&gt;</a>               Creator;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main ()</div>
<div class="line">{</div>
<div class="line">  std::size_t size = 16;</div>
<div class="line">  std::vector&lt;Point&gt; v; v.reserve(size);</div>
<div class="line">  CGAL::points_on_square_grid_2(3.0, size,            <span class="comment">// generate points</span></div>
<div class="line">                                std::back_inserter(v), Creator());</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="group__PkgSpatialSortingFunctions.html#ga9da67204747ac19dff65f9c9ff2fca9e">CGAL::hilbert_sort</a> (v.begin(), v.end());            <span class="comment">// sort</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span>(std::size_t i=0; i&lt;size; ++i)std::cout&lt;&lt;v[i]&lt;&lt;std::endl;<span class="comment">//output</span></div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassCGAL_1_1Creator__uniform__2_html"><div class="ttname"><a href="../STL_Extension/classCGAL_1_1Creator__uniform__2.html">CGAL::Creator_uniform_2</a></div></div>
<div class="ttc" id="aclassCGAL_1_1Exact__predicates__inexact__constructions__kernel_html"><div class="ttname"><a href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a></div></div>
<div class="ttc" id="agroup__PkgSpatialSortingFunctions_html_ga9da67204747ac19dff65f9c9ff2fca9e"><div class="ttname"><a href="group__PkgSpatialSortingFunctions.html#ga9da67204747ac19dff65f9c9ff2fca9e">CGAL::hilbert_sort</a></div><div class="ttdeci">void hilbert_sort(InputPointIterator begin, InputPointIterator end, const Traits &amp;traits=Default_traits, PolicyTag policy=Default_policy)</div><div class="ttdoc">The function hilbert_sort() sorts an iterator range of points along a Hilbert curve.</div></div>
</div><!-- fragment --><p>The following example shows how to perform a Hilbert sort on a sphere.</p>
<p><br>
<b>File</b> <a class="el" href="Spatial_sorting_2hilbert_sort_on_sphere_8cpp-example.html">Spatial_sorting/hilbert_sort_on_sphere.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/point_generators_3.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/hilbert_sort_on_sphere.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>     K;</div>
<div class="line"><span class="keyword">typedef</span> K::Point_3                                              Point;</div>
<div class="line"><span class="keyword">typedef</span> K::Vector_3                                             Vector;</div>
<div class="line"><span class="keyword">typedef</span> K::Sphere_3                                             Sphere;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../STL_Extension/classCGAL_1_1Creator__uniform__3.html">CGAL::Creator_uniform_3&lt;double,Point&gt;</a>                   Creator_3;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main ()</div>
<div class="line">{</div>
<div class="line">  std::size_t size = 32;</div>
<div class="line">  CGAL::Random random (42);</div>
<div class="line">  std::vector&lt;Point&gt; v;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// unit sphere</span></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"UNIT SPHERE: "</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  v.reserve(size);</div>
<div class="line"> </div>
<div class="line">  CGAL::Random_points_on_sphere_3&lt;Point&gt; unit_sphere(1.0, random);  <span class="comment">// generate points</span></div>
<div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; size; ++i) v.push_back(*unit_sphere++);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="group__PkgSpatialSortingFunctions.html#gac49755d15b5ae3141a90b827780f4f91">CGAL::hilbert_sort_on_sphere</a>(v.begin(), v.end());                 <span class="comment">// sort</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span>(std::size_t i=0; i&lt;size; ++i) std::cout &lt;&lt; v[i] &lt;&lt; std::endl; <span class="comment">//output</span></div>
<div class="line"> </div>
<div class="line">  v.clear();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// given sphere</span></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"GIVEN SPHERE: "</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  v.reserve(size);</div>
<div class="line"> </div>
<div class="line">  Vector trans = Vector(3,4,5);</div>
<div class="line">  Sphere sphere = Sphere(<a class="code hl_variableRef" href="../Kernel_23/group__kernel__enums.html#ga9d272a8e3a8080b851741b6d3a44afdc">CGAL::ORIGIN</a> + trans, 4);</div>
<div class="line">  CGAL::Random_points_on_sphere_3&lt;Point&gt; given_sphere(2.0, random);  <span class="comment">// generate points</span></div>
<div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; size; ++i) v.push_back(*given_sphere++ + trans);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="group__PkgSpatialSortingFunctions.html#gac49755d15b5ae3141a90b827780f4f91">CGAL::hilbert_sort_on_sphere</a>(v.begin(), v.end(),                   <span class="comment">// sort</span></div>
<div class="line">    sphere.squared_radius(), sphere.center());</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span>(std::size_t i=0; i&lt;size; ++i) std::cout &lt;&lt; v[i] &lt;&lt; std::endl; <span class="comment">//output</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassCGAL_1_1Creator__uniform__3_html"><div class="ttname"><a href="../STL_Extension/classCGAL_1_1Creator__uniform__3.html">CGAL::Creator_uniform_3</a></div></div>
<div class="ttc" id="agroup__PkgSpatialSortingFunctions_html_gac49755d15b5ae3141a90b827780f4f91"><div class="ttname"><a href="group__PkgSpatialSortingFunctions.html#gac49755d15b5ae3141a90b827780f4f91">CGAL::hilbert_sort_on_sphere</a></div><div class="ttdeci">void hilbert_sort_on_sphere(InputPointIterator begin, InputPointIterator end, const Traits &amp;traits=Default_traits, PolicyTag policy=Default_policy, double sqr_radius=1.0, const Traits::Point_3 &amp;center=Default_center)</div><div class="ttdoc">The function hilbert_sort_on_sphere() sorts an iterator range of points that are supposed to be close...</div></div>
<div class="ttc" id="agroup__kernel__enums_html_ga9d272a8e3a8080b851741b6d3a44afdc"><div class="ttname"><a href="../Kernel_23/group__kernel__enums.html#ga9d272a8e3a8080b851741b6d3a44afdc">CGAL::ORIGIN</a></div><div class="ttdeci">const CGAL::Origin ORIGIN</div></div>
</div><!-- fragment --><p>This other example illustrates the use of the two different policies</p>
<p><br>
<b>File</b> <a class="el" href="Spatial_sorting_2hilbert_policies_8cpp-example.html">Spatial_sorting/hilbert_policies.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/hilbert_sort.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div>
<div class="line"><span class="keyword">typedef</span> K::Point_2                                          Point;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main ()</div>
<div class="line">{</div>
<div class="line">  std::vector&lt;Point&gt; v; v.reserve(4);</div>
<div class="line">  v.push_back( Point(0.0,0.0)) ;</div>
<div class="line">  v.push_back( Point(1.0,1.0)) ;</div>
<div class="line">  v.push_back( Point(0.1,0.1)) ;</div>
<div class="line">  v.push_back( Point(0.2,0.8)) ;</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Hilbert sort (middle policy)."</span> &lt;&lt; std::endl;</div>
<div class="line">  <a class="code hl_function" href="group__PkgSpatialSortingFunctions.html#ga9da67204747ac19dff65f9c9ff2fca9e">CGAL::hilbert_sort</a> (v.begin(), v.end(), K(), <a class="code hl_struct" href="structCGAL_1_1Hilbert__policy.html">CGAL::Hilbert_sort_middle_policy</a>());</div>
<div class="line">  std::cout&lt;&lt;v[0]&lt;&lt;<span class="stringliteral">"; "</span>&lt;&lt;v[1]&lt;&lt;<span class="stringliteral">"; "</span>&lt;&lt;v[2]&lt;&lt;<span class="stringliteral">"; "</span>&lt;&lt;v[3]&lt;&lt;<span class="stringliteral">"; "</span>&lt;&lt;std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Hilbert sort (median policy)."</span> &lt;&lt; std::endl;</div>
<div class="line">  <a class="code hl_function" href="group__PkgSpatialSortingFunctions.html#ga9da67204747ac19dff65f9c9ff2fca9e">CGAL::hilbert_sort</a> (v.begin(), v.end(), K(), <a class="code hl_struct" href="structCGAL_1_1Hilbert__policy.html">CGAL::Hilbert_sort_median_policy</a>());</div>
<div class="line">  std::cout&lt;&lt;v[0]&lt;&lt;<span class="stringliteral">"; "</span>&lt;&lt;v[1]&lt;&lt;<span class="stringliteral">"; "</span>&lt;&lt;v[2]&lt;&lt;<span class="stringliteral">"; "</span>&lt;&lt;v[3]&lt;&lt;<span class="stringliteral">"; "</span>&lt;&lt;std::endl;</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="astructCGAL_1_1Hilbert__policy_html"><div class="ttname"><a href="structCGAL_1_1Hilbert__policy.html">CGAL::Hilbert_policy</a></div><div class="ttdoc">Hilbert_policy is a policy class which can be used to parameterize a strategy policy in order to spec...</div><div class="ttdef"><b>Definition:</b> Hilbert_policy_tags.h:56</div></div>
</div><!-- fragment --><h1><a class="anchor" id="secspatial_sorting"></a>
Spatial Sorting</h1>
<p>Hilbert sort cannot be used directly before feeding a randomized algorithm. Thus, the trick is to organize the point set in random buckets of increasing sizes, Hilbert sort being used only inside a bucket.</p>
<p>It has been proved, in the context of Delaunay triangulation, that such an order provides enough randomness to combine the advantages of a random order and a space filling curve order <a class="el" href="citelist.html#CITEREF_acr-icb-03">[1]</a>.</p>
<p>CGAL provides spatial sorting for points in 2D, 3D and higher dimensions, with the middle and the median policies for Hilbert sort in the buckets.</p>
<h2><a class="anchor" id="Spatial_sortingBasicExample"></a>
Basic Example</h2>
<p>The following example shows that, on particular input, spatial sort runs much faster than a bad order or than Hilbert sort (below results with release mode compilation on a 1.8GHz processor). </p><div class="fragment"><div class="line">$ ./small_example_delaunay_2</div>
<div class="line">10000 points on a parabola</div>
<div class="line">Delaunay without spatial sort... done in 6.33443 seconds.</div>
<div class="line">Delaunay with median hilbert sort... done in 0.822975 seconds.</div>
<div class="line">Delaunay with median spatial sort... done in 0.022415 seconds.</div>
</div><!-- fragment --><p><br>
<b>File</b> <a class="el" href="Spatial_sorting_2small_example_delaunay_2_8cpp-example.html">Spatial_sorting/small_example_delaunay_2.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Delaunay_triangulation_2.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/spatial_sort.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Timer.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div>
<div class="line"><span class="keyword">typedef</span> CGAL::Delaunay_triangulation_2&lt;K&gt; DT;</div>
<div class="line"><span class="keywordtype">void</span> compute_delaunay(std::vector&lt;K::Point_2&gt;::iterator it,</div>
<div class="line">                        std::vector&lt;K::Point_2&gt;::iterator e){</div>
<div class="line">    DT dt;</div>
<div class="line">    DT::Face_handle hint;</div>
<div class="line">    <span class="keywordflow">for</span>( ;it!=e; ++it)  hint = dt.insert(*it, hint)-&gt;face();</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">int</span> main ()</div>
<div class="line">{   <span class="keywordtype">int</span> size = 1000;</div>
<div class="line">    std::vector&lt;K::Point_2&gt; v;</div>
<div class="line">    v.reserve(size);</div>
<div class="line">    CGAL::Timer cost;</div>
<div class="line">    std::cout &lt;&lt;size&lt;&lt; <span class="stringliteral">" points on a parabola"</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt; size; ++i) {</div>
<div class="line">      <span class="keywordtype">double</span> x= -size +i;</div>
<div class="line">      v.push_back( K::Point_2( x, x*x ));</div>
<div class="line">    }</div>
<div class="line">    cost.reset();cost.start();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">"  Delaunay without spatial sort... "</span>&lt;&lt; std::flush;</div>
<div class="line">    compute_delaunay(v.begin(),v.end());cost.stop();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">"done in "</span>&lt;&lt;cost.time()&lt;&lt;<span class="stringliteral">" seconds."</span> &lt;&lt; std::endl;</div>
<div class="line">    cost.reset();cost.start();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">"  Delaunay with Hilbert sort...    "</span> &lt;&lt; std::flush;</div>
<div class="line">    <a class="code hl_function" href="group__PkgSpatialSortingFunctions.html#ga9da67204747ac19dff65f9c9ff2fca9e">CGAL::hilbert_sort</a>(v.begin(),v.end());</div>
<div class="line">    compute_delaunay(v.begin(),v.end());cost.stop();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">"done in "</span>&lt;&lt;cost.time()&lt;&lt;<span class="stringliteral">" seconds."</span> &lt;&lt; std::endl;</div>
<div class="line">    cost.reset();cost.start();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">"  Delaunay with spatial sort...    "</span> &lt;&lt; std::flush;</div>
<div class="line">    <a class="code hl_function" href="group__PkgSpatialSortingFunctions.html#ga7c597c11a3b3859234ff68526cead84d">CGAL::spatial_sort</a>(v.begin(),v.end());</div>
<div class="line">    compute_delaunay(v.begin(),v.end());cost.stop();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">"done in "</span>&lt;&lt;cost.time()&lt;&lt;<span class="stringliteral">" seconds."</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__PkgSpatialSortingFunctions_html_ga7c597c11a3b3859234ff68526cead84d"><div class="ttname"><a href="group__PkgSpatialSortingFunctions.html#ga7c597c11a3b3859234ff68526cead84d">CGAL::spatial_sort</a></div><div class="ttdeci">void spatial_sort(InputPointIterator begin, InputPointIterator end, const Traits &amp;traits=Default_traits, PolicyTag policy=Default_policy, std::ptrdiff_t threshold_hilbert=default, std::ptrdiff_t threshold_multiscale=default, double ratio=default)</div><div class="ttdoc">The function spatial_sort() sorts an iterator range of points in a way that improves space locality.</div></div>
</div><!-- fragment --><p>Spatial sort can be performed on the sphere as well, as shown in the following example.</p>
<p><br>
<b>File</b> <a class="el" href="Spatial_sorting_2spatial_sort_on_sphere_8cpp-example.html">Spatial_sorting/spatial_sort_on_sphere.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/point_generators_3.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/spatial_sort_on_sphere.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>     K;</div>
<div class="line"><span class="keyword">typedef</span> K::Point_3                                              Point;</div>
<div class="line"><span class="keyword">typedef</span> K::Vector_3                                             Vector;</div>
<div class="line"><span class="keyword">typedef</span> K::Sphere_3                                             Sphere;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../STL_Extension/classCGAL_1_1Creator__uniform__3.html">CGAL::Creator_uniform_3&lt;double,Point&gt;</a>                   Creator_3;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main ()</div>
<div class="line">{</div>
<div class="line">  std::size_t size = 32;</div>
<div class="line">  CGAL::Random random (42);</div>
<div class="line">  std::vector&lt;Point&gt; v;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// unit sphere</span></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"UNIT SPHERE: "</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  v.reserve(size);</div>
<div class="line"> </div>
<div class="line">  CGAL::Random_points_on_sphere_3&lt;Point&gt; unit_sphere(1.0, random);  <span class="comment">// generate points</span></div>
<div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; size; ++i) v.push_back(*unit_sphere++);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="group__PkgSpatialSortingFunctions.html#ga521df3e9f10c07ea128e292401233bcc">CGAL::spatial_sort_on_sphere</a>(v.begin(), v.end());                 <span class="comment">// sort</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span>(std::size_t i=0; i&lt;size; ++i) std::cout &lt;&lt; v[i] &lt;&lt; std::endl; <span class="comment">//output</span></div>
<div class="line"> </div>
<div class="line">  v.clear();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// given sphere</span></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"GIVEN SPHERE: "</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  v.reserve(size);</div>
<div class="line"> </div>
<div class="line">  Vector trans = Vector(3,4,5);</div>
<div class="line">  Sphere sphere = Sphere(<a class="code hl_variableRef" href="../Kernel_23/group__kernel__enums.html#ga9d272a8e3a8080b851741b6d3a44afdc">CGAL::ORIGIN</a> + trans, 4);</div>
<div class="line">  CGAL::Random_points_on_sphere_3&lt;Point&gt; given_sphere(2.0, random);  <span class="comment">// generate points</span></div>
<div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; size; ++i) v.push_back(*given_sphere++ + trans);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="group__PkgSpatialSortingFunctions.html#ga521df3e9f10c07ea128e292401233bcc">CGAL::spatial_sort_on_sphere</a>(v.begin(), v.end(),                   <span class="comment">// sort</span></div>
<div class="line">    sphere.squared_radius(), sphere.center());</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span>(std::size_t i=0; i&lt;size; ++i) std::cout &lt;&lt; v[i] &lt;&lt; std::endl; <span class="comment">//output</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__PkgSpatialSortingFunctions_html_ga521df3e9f10c07ea128e292401233bcc"><div class="ttname"><a href="group__PkgSpatialSortingFunctions.html#ga521df3e9f10c07ea128e292401233bcc">CGAL::spatial_sort_on_sphere</a></div><div class="ttdeci">void spatial_sort_on_sphere(InputPointIterator begin, InputPointIterator end, const Traits &amp;traits=Default_traits, PolicyTag policy=Default_policy, double sqr_radius=1.0, const Traits::Point_3 &amp;center=Default_center, std::ptrdiff_t threshold_hilbert=default, std::ptrdiff_t threshold_multiscale=default, double ratio=default)</div><div class="ttdoc">The function spatial_sort_on_sphere() sorts an iterator range of points in a way that improves space ...</div></div>
</div><!-- fragment --><h2><a class="anchor" id="Spatial_sortingUsingYourOwnPointType"></a>
Using Your Own Point Type</h2>
<p>If you want to sort points of your own point type, you only have to provide functors that compare the <code>x</code> and <code>y</code> coordinates of your points. Note that in case you simply want to associate an extra information to your point you might consider the example of Section <a class="el" href="index.html#secsort_any_type_2">Sorting Using Pairs of Points and Integers</a> as an alternative.</p>
<p><br>
<b>File</b> <a class="el" href="Spatial_sorting_2myPoint_8cpp-example.html">Spatial_sorting/myPoint.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/spatial_sort.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>MyPoint {</div>
<div class="line">  <span class="keywordtype">double</span> x,y;</div>
<div class="line">  <span class="keywordtype">int</span> color;</div>
<div class="line">  MyPoint()</div>
<div class="line">    : x(0), y(0),color(0)</div>
<div class="line">  {}</div>
<div class="line"> </div>
<div class="line">  MyPoint(<span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y, <span class="keywordtype">int</span> color=0)</div>
<div class="line">    : x(x), y(y), color(color)</div>
<div class="line">  {}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>MyLessX {</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> MyPoint&amp; p, <span class="keyword">const</span> MyPoint&amp; q)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keywordflow">return</span> p.x &lt; q.x;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>MyLessY {</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> MyPoint&amp; p, <span class="keyword">const</span> MyPoint&amp; q)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keywordflow">return</span> p.y &lt; q.y;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>MySpatialSortingTraits {</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">typedef</span> MyPoint Point_2;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">typedef</span> MyLessX Less_x_2;</div>
<div class="line">  <span class="keyword">typedef</span> MyLessY Less_y_2;</div>
<div class="line"> </div>
<div class="line">  Less_x_2 less_x_2_object()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keywordflow">return</span> Less_x_2();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  Less_y_2 less_y_2_object()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keywordflow">return</span> Less_y_2();</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  std::vector&lt; MyPoint &gt; points;</div>
<div class="line"> </div>
<div class="line">  points.push_back(MyPoint(14,12, 3));</div>
<div class="line">  points.push_back(MyPoint(1,2  , 0));</div>
<div class="line">  points.push_back(MyPoint(414,2, 5));</div>
<div class="line">  points.push_back(MyPoint(4,21 , 1));</div>
<div class="line">  points.push_back(MyPoint(7,74 , 2));</div>
<div class="line">  points.push_back(MyPoint(74,4 , 4));</div>
<div class="line"> </div>
<div class="line">  MySpatialSortingTraits sst;</div>
<div class="line">  <a class="code hl_function" href="group__PkgSpatialSortingFunctions.html#ga7c597c11a3b3859234ff68526cead84d">CGAL::spatial_sort</a>(points.begin(), points.end(), sst);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (std::vector&lt; MyPoint &gt;::iterator it=points.begin();it!=points.end();++it)</div>
<div class="line">    std::cout &lt;&lt; it-&gt;color &lt;&lt; <span class="stringliteral">" "</span>;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"\n"</span>;</div>
<div class="line"> </div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"done"</span> &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="secsort_any_type"></a>
Sorting Arbitrary Types</h2>
<p>The spatial sorting traits class provides a point type and functors for comparing, for example, the <code>x</code>-coordinates of two points. If you want to sort something else than just points, for example a sequence of tuples containing a point, or a sequence of indices in a vector of points, you need another level of indirection. We provide the spatial sorting traits class adapters which are templated by another spatial sorting traits class, and a <a href="https://www.boost.org/doc/libs/release/libs/property_map/index.html">property map</a>. which allows to obtain a point from whatever you want to sort.</p>
<p>The following examples illustrate the usage of these traits class adapters.</p>
<h2><a class="anchor" id="secsort_any_type_2"></a>
Sorting Using Pairs of Points and Integers</h2>
<p>In this example program, the sorted sequence of points is retrieved using a vector of pairs of points and integers. <br>
<b>File</b> <a class="el" href="Spatial_sorting_2sp_sort_using_property_map_2_8cpp-example.html">Spatial_sorting/sp_sort_using_property_map_2.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/spatial_sort.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Spatial_sort_traits_adapter_2.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_structRef" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>      <a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a>                     Point_2;</div>
<div class="line"><span class="keyword">typedef</span> std::pair&lt;Point_2,int&gt;              Point_with_info;</div>
<div class="line"><span class="keyword">typedef</span> std::vector&lt; Point_with_info &gt;      Data_vector;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classCGAL_1_1Spatial__sort__traits__adapter__2.html">CGAL::Spatial_sort_traits_adapter_2</a>&lt;<a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>,</div>
<div class="line">  CGAL::First_of_pair_property_map&lt;Point_with_info&gt;</div>
<div class="line">&gt; Search_traits_2;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  Data_vector points;</div>
<div class="line">  points.push_back(std::make_pair(Point_2(14,12) , 3));</div>
<div class="line">  points.push_back(std::make_pair(Point_2(1,2)   , 0));</div>
<div class="line">  points.push_back(std::make_pair(Point_2(414,2) , 5));</div>
<div class="line">  points.push_back(std::make_pair(Point_2(4,21)  , 1));</div>
<div class="line">  points.push_back(std::make_pair(Point_2(7,74)  , 2));</div>
<div class="line">  points.push_back(std::make_pair(Point_2(74,4)  , 4));</div>
<div class="line"> </div>
<div class="line">  Search_traits_2 traits;</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Order using default policy (median)\n"</span>;</div>
<div class="line">  <a class="code hl_function" href="group__PkgSpatialSortingFunctions.html#ga7c597c11a3b3859234ff68526cead84d">CGAL::spatial_sort</a>(points.begin(), points.end(), traits);</div>
<div class="line">  <span class="keywordflow">for</span> (Data_vector::iterator it=points.begin();it!=points.end();++it)</div>
<div class="line">    std::cout &lt;&lt; it-&gt;second &lt;&lt; <span class="stringliteral">" "</span>;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"\n"</span>;</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Order using middle policy\n"</span>;</div>
<div class="line">  <a class="code hl_function" href="group__PkgSpatialSortingFunctions.html#ga7c597c11a3b3859234ff68526cead84d">CGAL::spatial_sort</a>(points.begin(), points.end(), traits, <a class="code hl_struct" href="structCGAL_1_1Hilbert__policy.html">CGAL::Hilbert_sort_middle_policy</a>());</div>
<div class="line">  <span class="keywordflow">for</span> (Data_vector::iterator it=points.begin();it!=points.end();++it)</div>
<div class="line">    std::cout &lt;&lt; it-&gt;second &lt;&lt; <span class="stringliteral">" "</span>;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"\n"</span>;</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"done"</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassCGAL_1_1Spatial__sort__traits__adapter__2_html"><div class="ttname"><a href="classCGAL_1_1Spatial__sort__traits__adapter__2.html">CGAL::Spatial_sort_traits_adapter_2</a></div><div class="ttdoc">Given a property map associating a key to a point, the class Spatial_sort_traits_adapter_2 induces a ...</div><div class="ttdef"><b>Definition:</b> Spatial_sort_traits_adapter_2.h:19</div></div>
<div class="ttc" id="aclassKernel_1_1Point__2_html"><div class="ttname"><a href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a></div></div>
<div class="ttc" id="anamespaceKernel_html"><div class="ttname"><a href="../Kernel_23/namespaceKernel.html">Kernel</a></div></div>
<div class="ttc" id="astructCGAL_1_1Simple__cartesian_html"><div class="ttname"><a href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="Spatial_sortingSortingUsingIndicesofPoints"></a>
Sorting Using Indices of Points</h2>
<p>In this example program, the sorted sequence of points is retrieved using the indices of the points in a vector of points. <br>
<b>File</b> <a class="el" href="Spatial_sorting_2sp_sort_using_property_map_3_8cpp-example.html">Spatial_sorting/sp_sort_using_property_map_3.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/spatial_sort.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Spatial_sort_traits_adapter_3.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/boost/iterator/counting_iterator.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_structRef" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>                  <a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                                 Point_3;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classCGAL_1_1Spatial__sort__traits__adapter__3.html">CGAL::Spatial_sort_traits_adapter_3</a>&lt;<a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>,</div>
<div class="line">          CGAL::Pointer_property_map&lt;Point_3&gt;::type &gt; Search_traits_3;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  std::vector&lt;Point_3&gt; points;</div>
<div class="line">  points.push_back(Point_3(1,3,11));</div>
<div class="line">  points.push_back(Point_3(14,34,46));</div>
<div class="line">  points.push_back(Point_3(414,34,4));</div>
<div class="line">  points.push_back(Point_3(4,2,56));</div>
<div class="line">  points.push_back(Point_3(744,4154,43));</div>
<div class="line">  points.push_back(Point_3(74,44,1));</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;std::size_t&gt; indices;</div>
<div class="line">  indices.reserve(points.size());</div>
<div class="line"> </div>
<div class="line">  std::copy(boost::counting_iterator&lt;std::size_t&gt;(0),</div>
<div class="line">            boost::counting_iterator&lt;std::size_t&gt;(points.size()),</div>
<div class="line">            std::back_inserter(indices));</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Order using default policy (median)\n"</span>;</div>
<div class="line">  <a class="code hl_function" href="group__PkgSpatialSortingFunctions.html#ga7c597c11a3b3859234ff68526cead84d">CGAL::spatial_sort</a>( indices.begin(),</div>
<div class="line">                      indices.end(),</div>
<div class="line">                      Search_traits_3(CGAL::make_property_map(points)) );</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (std::size_t i : indices)</div>
<div class="line">    std::cout &lt;&lt; points[i] &lt;&lt; <span class="stringliteral">"\n"</span>;</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Order using middle policy\n"</span>;</div>
<div class="line">  <a class="code hl_function" href="group__PkgSpatialSortingFunctions.html#ga7c597c11a3b3859234ff68526cead84d">CGAL::spatial_sort</a>( indices.begin(),</div>
<div class="line">                      indices.end(),</div>
<div class="line">                      Search_traits_3(CGAL::make_property_map(points)),</div>
<div class="line">                      <a class="code hl_struct" href="structCGAL_1_1Hilbert__policy.html">CGAL::Hilbert_sort_middle_policy</a>());</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (std::size_t i : indices)</div>
<div class="line">    std::cout &lt;&lt; points[i] &lt;&lt; <span class="stringliteral">"\n"</span>;</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"done"</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassCGAL_1_1Spatial__sort__traits__adapter__3_html"><div class="ttname"><a href="classCGAL_1_1Spatial__sort__traits__adapter__3.html">CGAL::Spatial_sort_traits_adapter_3</a></div><div class="ttdoc">Given a property map associating a key to a point, the class Spatial_sort_traits_adapter_3 induces a ...</div><div class="ttdef"><b>Definition:</b> Spatial_sort_traits_adapter_3.h:20</div></div>
<div class="ttc" id="aclassKernel_1_1Point__3_html"><div class="ttname"><a href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="Spatial_sortingSortingUsingIndicesofPairs"></a>
Sorting Using Indices of Pairs of Points and Integers</h2>
<p>In this example program, the sorted sequence of points is retrieved using the indices of the points in a vector of pairs of points and integers. <br>
<b>File</b> <a class="el" href="Spatial_sorting_2sp_sort_using_property_map_d_8cpp-example.html">Spatial_sorting/sp_sort_using_property_map_d.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian_d.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/spatial_sort.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Spatial_sort_traits_adapter_d.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/boost/iterator/counting_iterator.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> CGAL::Cartesian_d&lt;double&gt;           <a class="code hl_namespaceRef" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div>
<div class="line"><span class="keyword">typedef</span> Kernel::Point_d                     Point_d;</div>
<div class="line"><span class="keyword">typedef</span> std::pair&lt;Point_d,int&gt;              Point_with_info;</div>
<div class="line"><span class="keyword">typedef</span> std::vector&lt; Point_with_info &gt;      Data_vector;</div>
<div class="line"> </div>
<div class="line"><span class="comment">//property map and get as friend</span></div>
<div class="line"><span class="comment">// to be allowed to use private member</span></div>
<div class="line"><span class="keyword">class </span>Vect_ppmap{</div>
<div class="line">  <span class="keyword">const</span> Data_vector&amp; points;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="comment">//classical typedefs</span></div>
<div class="line">  <span class="keyword">typedef</span> Data_vector::size_type key_type;</div>
<div class="line">  <span class="keyword">typedef</span> Point_d value_type;</div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type&amp; reference;</div>
<div class="line">  <span class="keyword">typedef</span> boost::readable_property_map_tag category;</div>
<div class="line"> </div>
<div class="line">  Vect_ppmap(<span class="keyword">const</span> Data_vector&amp; points_):points(points_){}</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">friend</span> reference get(<span class="keyword">const</span> Vect_ppmap&amp; vmap, key_type i) {</div>
<div class="line">    <span class="keywordflow">return</span> vmap.points[i].first;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="classCGAL_1_1Spatial__sort__traits__adapter__d.html">CGAL::Spatial_sort_traits_adapter_d&lt;Kernel,Vect_ppmap&gt;</a>   Search_traits_d;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">double</span> coords[] ={ 1.0, 1.0, 1.0, 1.0,</div>
<div class="line">                     2.0, 2.0, 2.0, 2.0 };</div>
<div class="line"> </div>
<div class="line">  Data_vector points;</div>
<div class="line">  points.push_back(std::make_pair(Point_d(4,coords  ,coords+4) , 1));</div>
<div class="line">  points.push_back(std::make_pair(Point_d(4,coords+4,coords+8) , 2));</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;Vect_ppmap::key_type&gt; indices;</div>
<div class="line">  indices.reserve(points.size());</div>
<div class="line"> </div>
<div class="line">  std::copy(</div>
<div class="line">    boost::counting_iterator&lt;Vect_ppmap::key_type&gt;(0),</div>
<div class="line">    boost::counting_iterator&lt;Vect_ppmap::key_type&gt;(points.size()),</div>
<div class="line">    std::back_inserter(indices) );</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Order using default policy (median)\n"</span>;</div>
<div class="line">  <a class="code hl_function" href="group__PkgSpatialSortingFunctions.html#ga7c597c11a3b3859234ff68526cead84d">CGAL::spatial_sort</a>(</div>
<div class="line">    indices.begin(),</div>
<div class="line">    indices.end(),</div>
<div class="line">    Search_traits_d(Vect_ppmap(points))</div>
<div class="line">   );</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> i : indices)</div>
<div class="line">    std::cout &lt;&lt; points[i].second &lt;&lt; <span class="stringliteral">" "</span>;</div>
<div class="line">  std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Order using middle policy\n"</span>;</div>
<div class="line">  <a class="code hl_function" href="group__PkgSpatialSortingFunctions.html#ga7c597c11a3b3859234ff68526cead84d">CGAL::spatial_sort</a>(</div>
<div class="line">    indices.begin(),</div>
<div class="line">    indices.end(),</div>
<div class="line">    Search_traits_d(Vect_ppmap(points)),</div>
<div class="line">    <a class="code hl_struct" href="structCGAL_1_1Hilbert__policy.html">CGAL::Hilbert_sort_middle_policy</a>()</div>
<div class="line">   );</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> i : indices)</div>
<div class="line">    std::cout &lt;&lt; points[i].second &lt;&lt; <span class="stringliteral">" "</span>;</div>
<div class="line">  std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"done"</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassCGAL_1_1Spatial__sort__traits__adapter__d_html"><div class="ttname"><a href="classCGAL_1_1Spatial__sort__traits__adapter__d.html">CGAL::Spatial_sort_traits_adapter_d</a></div><div class="ttdoc">Given a property map associating a key to a point, the class Spatial_sort_traits_adapter_d induces a ...</div><div class="ttdef"><b>Definition:</b> Spatial_sort_traits_adapter_d.h:20</div></div>
</div><!-- fragment --><h1><a class="anchor" id="Spatial_sortingParallel"></a>
Parallel Spatial Sorting</h1>
<p>In 2D (3D), Hilbert or spatial sorting recursively subdivides the input range in four (eight) subranges. Therefore, a natural way to parallelize the sorting algorithm is to split the initial range in four (eight) subranges, and let a single thread handle any further subdivision and sorting for a given subrange. This parallel algorithm is only available when the median strategy policy is being used (this is the case by default), as this policy ensures balance between all subranges. This is not necessarily the case with the middle strategy, where the subrange sizes can greatly vary.</p>
<p>The parallel version of the algorithm is enabled by specifying the template parameter <code><a class="elRef" href="../STL_Extension/structCGAL_1_1Parallel__tag.html">CGAL::Parallel_tag</a></code>. In case it is not sure whether TBB is available and linked with CGAL, <code><a class="elRef" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a></code> can be used. By default, the sequential version is used.</p>
<p><br>
<b>File</b> <a class="el" href="Spatial_sorting_2parallel_spatial_sort_3_8cpp-example.html">Spatial_sorting/parallel_spatial_sort_3.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/point_generators_3.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Random.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/spatial_sort.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>       K;</div>
<div class="line"><span class="keyword">typedef</span> K::Point_3                                                Point_3;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../STL_Extension/classCGAL_1_1Creator__uniform__3.html">CGAL::Creator_uniform_3&lt;double,Point_3&gt;</a>                   Creator_3;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  std::size_t pt_nb = 10000;</div>
<div class="line">  std::vector&lt;Point_3&gt; points;</div>
<div class="line">  points.reserve(pt_nb);</div>
<div class="line"> </div>
<div class="line">  CGAL::Random_points_in_cube_3&lt;Point_3&gt; gen(1.0);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span>(std::size_t i=0; i&lt;pt_nb; ++i)</div>
<div class="line">    points.push_back(*gen++);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// By default sequential</span></div>
<div class="line">  <a class="code hl_function" href="group__PkgSpatialSortingFunctions.html#ga7c597c11a3b3859234ff68526cead84d">CGAL::spatial_sort</a>(points.begin(),points.end());</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Add the template argument to switch on parallelism if available</span></div>
<div class="line">  <span class="comment">// You can also use Parallel_tag if you know that TBB is enabled</span></div>
<div class="line">  CGAL::spatial_sort&lt;CGAL::Parallel_if_available_tag&gt;(points.begin(), points.end());</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="Spatial_sortingDesign"></a>
Design and Implementation History</h1>
<p>The first implementation of Hilbert and spatial sorting (2D and 3D) in CGAL was done by Cristophe Delage. Olivier Devillers improved its design, and implemented its multidimensional version.</p>
<p>Pedro Machado Manhaes de Castro and Olivier Devillers added Hilbert sorting on the sphere.</p>
<p>Andreas Fabri added a parallel version of Hilbert and spatial sorting. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"></a> 1.9.6 </li>
  </ul>
</div>
</div>
</body>


</html>
