<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Bounding_volumes/classCGAL_1_1Min__ellipse__2.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=11">
<meta name="generator" content="Doxygen 1.9.6">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CGAL 6.2 - Bounding Volumes: CGAL::Min_ellipse_2&lt; Traits &gt; Class Template Reference</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/doxygen.css" rel="stylesheet" type="text/css">
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      },
      equationNumbers: { autoNumber: "AMS" }
  }
}
);
MathJax.Hub.Register.StartupHook("TeX Jax Ready",function () {
  var PARSE = MathJax.InputJax.TeX.Parse,
      TEXT = PARSE.prototype.InternalText;
  PARSE.Augment({
    InternalText: function (text,def) {
      text = text.replace(/\\/g,"");
      return TEXT.call(this,text,def);
    }
  });
});
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
      <span class="left">
         <span id="MSearchSelect" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"> 
        </span>
        <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
      </span>
      <span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.svg" alt=""></a>
      </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CGAL 6.2 - Bounding Volumes
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search/",'.html');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classCGAL_1_1Min__ellipse__2.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="classCGAL_1_1Min__ellipse__2-members.html">List of all members</a> |
<a href="#related">Related Functions</a>  </div>
  <div class="headertitle"><div class="title">CGAL::Min_ellipse_2&lt; Traits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__PkgBoundingVolumesRef.html">Reference Manual</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;CGAL/Min_ellipse_2.h&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Traits&gt;<br>
class CGAL::Min_ellipse_2&lt; Traits &gt;</div><p>An object of the class <code><a class="el" href="classCGAL_1_1Min__ellipse__2.html" title="An object of the class Min_ellipse_2 is the unique ellipse of smallest area enclosing a finite (multi...">Min_ellipse_2</a></code> is the unique ellipse of smallest area enclosing a finite (multi)set of points in two-dimensional Euclidean space \( \E^2\). </p>
<p>For a point set \( P\) we denote by \( me(P)\) the smallest ellipse that contains all points of \( P\). Note that \( me(P)\) can be degenerate, i.e. \( me(P)=\emptyset\) if \( P=\emptyset\), \( me(P)=\{p\}\) if \( P=\{p\}\), and <span class="mbox"> \( me(P) = \{ (1-\lambda)p + \lambda q \mid 0 \leq \lambda \leq 1 \}\)</span> if \( P=\{p,q\}\).</p>
<p>An inclusion-minimal subset \( S\) of \( P\) with \( me(S)=me(P)\) is called a <em>support set</em>, the points in \( S\) are the <em>support points</em>. A support set has size at most five, and all its points lie on the boundary of \( me(P)\). In general, neither the support set nor its size are necessarily unique.</p>
<p>The underlying algorithm can cope with all kinds of input, e.g. \( P\) may be empty or points may occur more than once. The algorithm computes a support set \( S\) which remains fixed until the next insert or clear operation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Traits</td><td>must be a model for <code><a class="el" href="classMinEllipse2Traits.html" title="This concept defines the requirements for traits classes of CGAL::Min_ellipse_2&lt;Traits&gt;.">MinEllipse2Traits</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<p>We provide the model <code><a class="el" href="classCGAL_1_1Min__ellipse__2__traits__2.html" title="The class Min_ellipse_2_traits_2 is a traits class for CGAL::Min_ellipse_2&lt;Traits&gt; using the two-dime...">CGAL::Min_ellipse_2_traits_2</a>&lt;K&gt;</code> using the two-dimensional CGAL kernel.</p>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="classCGAL_1_1Min__circle__2.html" title="An object of the class Min_circle_2 is the unique circle of smallest area enclosing a finite (multi)s...">CGAL::Min_circle_2</a>&lt;Traits&gt;</code> </dd>
<dd>
<code><a class="el" href="classCGAL_1_1Min__ellipse__2__traits__2.html" title="The class Min_ellipse_2_traits_2 is a traits class for CGAL::Min_ellipse_2&lt;Traits&gt; using the two-dime...">CGAL::Min_ellipse_2_traits_2</a>&lt;K&gt;</code> </dd>
<dd>
<code><a class="el" href="classMinEllipse2Traits.html" title="This concept defines the requirements for traits classes of CGAL::Min_ellipse_2&lt;Traits&gt;.">MinEllipse2Traits</a></code></dd></dl>
<p><b>Implementation</b><br>
</p>
<p>We implement the incremental algorithm of Welzl, with move-to-front heuristic <a class="el" href="citelist.html#CITEREF_w-sedbe-91a">[16]</a>, using the primitives as described in <a class="el" href="citelist.html#CITEREF_gs-epsee-97">[4]</a>, <a class="el" href="citelist.html#CITEREF_cgal:gs-seefe-97a">[3]</a>. The whole implementation is described in <a class="el" href="citelist.html#CITEREF_cgal:gs-seeeg-98">[6]</a>.</p>
<p>If randomization is chosen, the creation time is almost always linear in the number of points. Access functions and predicates take constant time, inserting a point might take up to linear time, but substantially less than computing the new smallest enclosing ellipse from scratch. The clear operation and the check for validity each takes linear time.</p>
<p><b>Example</b><br>
</p>
<p>To illustrate the usage of <code><a class="el" href="classCGAL_1_1Min__ellipse__2.html" title="An object of the class Min_ellipse_2 is the unique ellipse of smallest area enclosing a finite (multi...">Min_ellipse_2</a></code> and to show that randomization can be useful in certain cases, we give an example. The example also shows how the coefficients of the constructed ellipse can be accessed.</p>
<p><br>
<b>File</b> <a class="el" href="Min_ellipse_2_2min_ellipse_2_8cpp-example.html">Min_ellipse_2/min_ellipse_2.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Min_ellipse_2.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Min_ellipse_2_traits_2.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="codeRef" href="../Number_types/Exact__rational_8h.html">CGAL/Exact_rational.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;array&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span>  <a class="code hl_classRef" href="../Manual/classunspecified__type.html">CGAL::Exact_rational</a>             NT;</div>
<div class="line"><span class="keyword">typedef</span>  <a class="code hl_structRef" href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian&lt;NT&gt;</a>              K;</div>
<div class="line"><span class="keyword">typedef</span>  <a class="code hl_classRef" href="../Kernel_23/classCGAL_1_1Point__2.html">CGAL::Point_2&lt;K&gt;</a>                 <a class="code hl_typedef" href="classCGAL_1_1Min__ellipse__2.html#a85d7523e566c0be7444fdbc057d4ec8b">Point</a>;</div>
<div class="line"><span class="keyword">typedef</span>  <a class="code hl_class" href="classCGAL_1_1Min__ellipse__2__traits__2.html">CGAL::Min_ellipse_2_traits_2&lt;K&gt;</a>  Traits;</div>
<div class="line"><span class="keyword">typedef</span>  <a class="code hl_class" href="classCGAL_1_1Min__ellipse__2.html">CGAL::Min_ellipse_2&lt;Traits&gt;</a>      Min_ellipse;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main( <span class="keywordtype">int</span>, <span class="keywordtype">char</span>**)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> n = 200;</div>
<div class="line">    std::array&lt;Point, n&gt;     P;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt; n; ++i)</div>
<div class="line">        P.at(i) = <a class="code hl_typedef" href="classCGAL_1_1Min__ellipse__2.html#a85d7523e566c0be7444fdbc057d4ec8b">Point</a>( i % 2 ? i : -i , 0);</div>
<div class="line">    <span class="comment">// (0,0), (-1,0), (2,0), (-3,0)</span></div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Computing ellipse (without randomization)..."</span>;</div>
<div class="line">    std::cout.flush();</div>
<div class="line">    Min_ellipse  me1( P.begin(), P.end(), <span class="keyword">false</span>);    <span class="comment">// very slow</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">"done."</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Computing ellipse (with randomization)..."</span>;</div>
<div class="line">    std::cout.flush();</div>
<div class="line">    Min_ellipse  me2( P.begin(), P.end(), <span class="keyword">true</span>);     <span class="comment">// fast</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">"done."</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// because all input points are collinear, the ellipse is</span></div>
<div class="line">    <span class="comment">// degenerate and equals a line segment; the ellipse has</span></div>
<div class="line">    <span class="comment">// two support points</span></div>
<div class="line">    assert(me2.is_degenerate());</div>
<div class="line">    assert(me2.number_of_support_points()==2);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// prettyprinting</span></div>
<div class="line">    <a class="code hl_functionRef" href="../Stream_support/group__PkgStreamSupportRef.html#ga2cbb865dd83eedd780f4a452635b1d28">CGAL::IO::set_pretty_mode</a>( std::cout);</div>
<div class="line">    std::cout &lt;&lt; me2;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// in general, the ellipse is not explicitly representable</span></div>
<div class="line">    <span class="comment">// over the input number type NT; when you use the default</span></div>
<div class="line">    <span class="comment">// traits class CGAL::Min_ellipse_2_traits_2&lt;K&gt;, you can</span></div>
<div class="line">    <span class="comment">// get double approximations for the coefficients of the</span></div>
<div class="line">    <span class="comment">// underlying conic curve. NOTE: this curve only exists</span></div>
<div class="line">    <span class="comment">// in the nondegenerate case!</span></div>
<div class="line"> </div>
<div class="line">    me2.insert(<a class="code hl_typedef" href="classCGAL_1_1Min__ellipse__2.html#a85d7523e566c0be7444fdbc057d4ec8b">Point</a>(0,1)); <span class="comment">// resolves the degeneracy</span></div>
<div class="line">    assert(!me2.is_degenerate());</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// get the coefficients</span></div>
<div class="line">    <span class="keywordtype">double</span> r,s,t,u,v,w;</div>
<div class="line">    me2.ellipse().double_coefficients( r, s, t, u, v, w);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">"ellipse has the equation "</span> &lt;&lt;</div>
<div class="line">      r &lt;&lt; <span class="stringliteral">" x^2 + "</span> &lt;&lt;</div>
<div class="line">      s &lt;&lt; <span class="stringliteral">" y^2 + "</span> &lt;&lt;</div>
<div class="line">      t &lt;&lt; <span class="stringliteral">" xy + "</span> &lt;&lt;</div>
<div class="line">      u &lt;&lt; <span class="stringliteral">" x + "</span> &lt;&lt;</div>
<div class="line">      v &lt;&lt; <span class="stringliteral">" y + "</span> &lt;&lt;</div>
<div class="line">      w &lt;&lt; <span class="stringliteral">" = 0."</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="ttc" id="aExact__rational_8h_html"><div class="ttname"><a href="../Number_types/Exact__rational_8h.html">Exact_rational.h</a></div></div>
<div class="ttc" id="aclassCGAL_1_1Min__ellipse__2__traits__2_html"><div class="ttname"><a href="classCGAL_1_1Min__ellipse__2__traits__2.html">CGAL::Min_ellipse_2_traits_2</a></div><div class="ttdoc">The class Min_ellipse_2_traits_2 is a traits class for CGAL::Min_ellipse_2&lt;Traits&gt; using the two-dime...</div><div class="ttdef"><b>Definition:</b> Min_ellipse_2_traits_2.h:19</div></div>
<div class="ttc" id="aclassCGAL_1_1Min__ellipse__2_html"><div class="ttname"><a href="classCGAL_1_1Min__ellipse__2.html">CGAL::Min_ellipse_2</a></div><div class="ttdoc">An object of the class Min_ellipse_2 is the unique ellipse of smallest area enclosing a finite (multi...</div><div class="ttdef"><b>Definition:</b> Min_ellipse_2.h:59</div></div>
<div class="ttc" id="aclassCGAL_1_1Min__ellipse__2_html_a85d7523e566c0be7444fdbc057d4ec8b"><div class="ttname"><a href="classCGAL_1_1Min__ellipse__2.html#a85d7523e566c0be7444fdbc057d4ec8b">CGAL::Min_ellipse_2::Point</a></div><div class="ttdeci">unspecified_type Point</div><div class="ttdoc">Typedef to Traits::Point.</div><div class="ttdef"><b>Definition:</b> Min_ellipse_2.h:68</div></div>
<div class="ttc" id="aclassCGAL_1_1Point__2_html"><div class="ttname"><a href="../Kernel_23/classCGAL_1_1Point__2.html">CGAL::Point_2</a></div></div>
<div class="ttc" id="aclassunspecified__type_html"><div class="ttname"><a href="../Manual/classunspecified__type.html">unspecified_type</a></div></div>
<div class="ttc" id="agroup__PkgStreamSupportRef_html_ga2cbb865dd83eedd780f4a452635b1d28"><div class="ttname"><a href="../Stream_support/group__PkgStreamSupportRef.html#ga2cbb865dd83eedd780f4a452635b1d28">CGAL::IO::set_pretty_mode</a></div><div class="ttdeci">Mode set_pretty_mode(std::ios &amp;s)</div></div>
<div class="ttc" id="astructCGAL_1_1Cartesian_html"><div class="ttname"><a href="../Kernel_23/structCGAL_1_1Cartesian.html">CGAL::Cartesian</a></div></div>
</div><!-- fragment --> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Min_ellipse_2_2min_ellipse_2_8cpp-example.html#_a4">Min_ellipse_2/min_ellipse_2.cpp</a>.</dd>
</dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:af7c0fb64d240921356e6a4e818592e42"><td class="memItemLeft" align="right" valign="top">std::ostream &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Min__ellipse__2.html#af7c0fb64d240921356e6a4e818592e42">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classCGAL_1_1Min__ellipse__2.html">Min_ellipse_2</a>&lt; Traits &gt; &amp;min_ellipse)</td></tr>
<tr class="memdesc:af7c0fb64d240921356e6a4e818592e42"><td class="mdescLeft"> </td><td class="mdescRight">writes <code>min_ellipse</code> to output stream <code>os</code>.  <br></td></tr>
<tr class="separator:af7c0fb64d240921356e6a4e818592e42"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a13acc6b8559f5210d49e60513eaaf7b6"><td class="memItemLeft" align="right" valign="top">std::istream &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Min__ellipse__2.html#a13acc6b8559f5210d49e60513eaaf7b6">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classCGAL_1_1Min__ellipse__2.html">Min_ellipse_2</a>&lt; Traits &gt; min_ellipse &amp;)</td></tr>
<tr class="memdesc:a13acc6b8559f5210d49e60513eaaf7b6"><td class="mdescLeft"> </td><td class="mdescRight">reads <code>min_ellipse</code> from input stream <code>is</code>.  <br></td></tr>
<tr class="separator:a13acc6b8559f5210d49e60513eaaf7b6"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Types</h2></td></tr>
<tr class="memitem:a85d7523e566c0be7444fdbc057d4ec8b"><td class="memItemLeft" align="right" valign="top"><a id="a85d7523e566c0be7444fdbc057d4ec8b" name="a85d7523e566c0be7444fdbc057d4ec8b"></a>
typedef <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> </td><td class="memItemRight" valign="bottom"><b>Point</b></td></tr>
<tr class="memdesc:a85d7523e566c0be7444fdbc057d4ec8b"><td class="mdescLeft"> </td><td class="mdescRight">Typedef to <code>Traits::Point</code>. <br></td></tr>
<tr class="separator:a85d7523e566c0be7444fdbc057d4ec8b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:acd1b1aa7a496bc993dd231548192f1fc"><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Min__ellipse__2.html#acd1b1aa7a496bc993dd231548192f1fc">Ellipse</a></td></tr>
<tr class="memdesc:acd1b1aa7a496bc993dd231548192f1fc"><td class="mdescLeft"> </td><td class="mdescRight">Typedef to <code>Traits::Ellipse</code>.  <br></td></tr>
<tr class="separator:acd1b1aa7a496bc993dd231548192f1fc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8179f6ba721e4fae0e56a04e08e5dd11"><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Min__ellipse__2.html#a8179f6ba721e4fae0e56a04e08e5dd11">Point_iterator</a></td></tr>
<tr class="memdesc:a8179f6ba721e4fae0e56a04e08e5dd11"><td class="mdescLeft"> </td><td class="mdescRight">Non-mutable model of the STL concept <em><a class="elRef" href="../Manual/classBidirectionalIterator.html">BidirectionalIterator</a></em> with value type <code>Point</code>.  <br></td></tr>
<tr class="separator:a8179f6ba721e4fae0e56a04e08e5dd11"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aff8d704d738a232b81fa99c82c7cb5df"><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Min__ellipse__2.html#aff8d704d738a232b81fa99c82c7cb5df">Support_point_iterator</a></td></tr>
<tr class="memdesc:aff8d704d738a232b81fa99c82c7cb5df"><td class="mdescLeft"> </td><td class="mdescRight">Non-mutable model of the STL concept <em><a class="elRef" href="../Manual/classRandomAccessIterator.html">RandomAccessIterator</a></em> with value type <code>Point</code>.  <br></td></tr>
<tr class="separator:aff8d704d738a232b81fa99c82c7cb5df"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Creation</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>A <code><a class="el" href="classCGAL_1_1Min__ellipse__2.html" title="An object of the class Min_ellipse_2 is the unique ellipse of smallest area enclosing a finite (multi...">Min_ellipse_2</a></code> object can be created from an arbitrary point set \( P\) and by specialized construction methods expecting no, one, two, three, four or five points as arguments.</p>
<p>The latter methods can be useful for reconstructing \( me(P)\) from a given support set \( S\) of \( P\). </p>
</td></tr>
<tr class="memitem:a077e61fca4c81442bbcc3c8f3814c74f"><td class="memTemplParams" colspan="2">template&lt;class <a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> &gt; </td></tr>
<tr class="memitem:a077e61fca4c81442bbcc3c8f3814c74f"><td class="memTemplItemLeft" align="right" valign="top"> </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Min__ellipse__2.html#a077e61fca4c81442bbcc3c8f3814c74f">Min_Ellipse_2</a> (<a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> first, <a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> last, bool randomize, Random &amp;random=get_default_random(), const Traits &amp;<a class="el" href="classCGAL_1_1Min__ellipse__2.html#adfb3289a1c1204f72a590bdc6010c073">traits</a>=Traits())</td></tr>
<tr class="memdesc:a077e61fca4c81442bbcc3c8f3814c74f"><td class="mdescLeft"> </td><td class="mdescRight">initializes <code>min_ellipse</code> to \( me(P)\) with \( P\) being the set of points in the range [<code>first</code>,<code>last</code>).  <br></td></tr>
<tr class="separator:a077e61fca4c81442bbcc3c8f3814c74f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5e7e882ef3be97366345e617b3b7b4de"><td class="memItemLeft" align="right" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Min__ellipse__2.html#a5e7e882ef3be97366345e617b3b7b4de">Min_ellipse_2</a> (const Traits &amp;<a class="el" href="classCGAL_1_1Min__ellipse__2.html#adfb3289a1c1204f72a590bdc6010c073">traits</a>=Traits())</td></tr>
<tr class="memdesc:a5e7e882ef3be97366345e617b3b7b4de"><td class="mdescLeft"> </td><td class="mdescRight">creates a variable <code>min_ellipse</code> of type <code><a class="el" href="classCGAL_1_1Min__ellipse__2.html" title="An object of the class Min_ellipse_2 is the unique ellipse of smallest area enclosing a finite (multi...">Min_ellipse_2</a></code>.  <br></td></tr>
<tr class="separator:a5e7e882ef3be97366345e617b3b7b4de"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3c1fb4d1d73003f55bc28809d85e38dc"><td class="memItemLeft" align="right" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Min__ellipse__2.html#a3c1fb4d1d73003f55bc28809d85e38dc">Min_ellipse_2</a> (const <a class="el" href="classCGAL_1_1Min__ellipse__2.html#a85d7523e566c0be7444fdbc057d4ec8b">Point</a> &amp;p, const Traits &amp;<a class="el" href="classCGAL_1_1Min__ellipse__2.html#adfb3289a1c1204f72a590bdc6010c073">traits</a>=Traits())</td></tr>
<tr class="memdesc:a3c1fb4d1d73003f55bc28809d85e38dc"><td class="mdescLeft"> </td><td class="mdescRight">initializes <code>min_ellipse</code> to \( me(\{p\})\), the set \( \{p\}\).  <br></td></tr>
<tr class="separator:a3c1fb4d1d73003f55bc28809d85e38dc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a49947e7016b29a1a6656aeeaf7045614"><td class="memItemLeft" align="right" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Min__ellipse__2.html#a49947e7016b29a1a6656aeeaf7045614">Min_ellipse_2</a> (const <a class="el" href="classCGAL_1_1Min__ellipse__2.html#a85d7523e566c0be7444fdbc057d4ec8b">Point</a> &amp;p, const <a class="el" href="classCGAL_1_1Min__ellipse__2.html#a85d7523e566c0be7444fdbc057d4ec8b">Point</a> &amp;q, const Traits &amp;<a class="el" href="classCGAL_1_1Min__ellipse__2.html#adfb3289a1c1204f72a590bdc6010c073">traits</a>=Traits())</td></tr>
<tr class="memdesc:a49947e7016b29a1a6656aeeaf7045614"><td class="mdescLeft"> </td><td class="mdescRight">initializes <code>min_ellipse</code> to \( me(\{p,q\})\), the set \( \{ (1-\lambda) p + \lambda q \mid 0 \leq \lambda \leq 1 \}\)  <br></td></tr>
<tr class="separator:a49947e7016b29a1a6656aeeaf7045614"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae91ed5467a6f9b719a64f7d17cb30308"><td class="memItemLeft" align="right" valign="top"><a id="ae91ed5467a6f9b719a64f7d17cb30308" name="ae91ed5467a6f9b719a64f7d17cb30308"></a>
 </td><td class="memItemRight" valign="bottom"><b>Min_ellipse_2</b> (const <a class="el" href="classCGAL_1_1Min__ellipse__2.html#a85d7523e566c0be7444fdbc057d4ec8b">Point</a> &amp;p1, const <a class="el" href="classCGAL_1_1Min__ellipse__2.html#a85d7523e566c0be7444fdbc057d4ec8b">Point</a> &amp;p2, const <a class="el" href="classCGAL_1_1Min__ellipse__2.html#a85d7523e566c0be7444fdbc057d4ec8b">Point</a> &amp;p3, const Traits &amp;<a class="el" href="classCGAL_1_1Min__ellipse__2.html#adfb3289a1c1204f72a590bdc6010c073">traits</a>=Traits())</td></tr>
<tr class="memdesc:ae91ed5467a6f9b719a64f7d17cb30308"><td class="mdescLeft"> </td><td class="mdescRight">initializes <code>min_ellipse</code> to \( me(\{p1,p2,p3\})\). <br></td></tr>
<tr class="separator:ae91ed5467a6f9b719a64f7d17cb30308"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a23a7d4d8371623bb9741a63f1d29d041"><td class="memItemLeft" align="right" valign="top"><a id="a23a7d4d8371623bb9741a63f1d29d041" name="a23a7d4d8371623bb9741a63f1d29d041"></a>
 </td><td class="memItemRight" valign="bottom"><b>Min_ellipse_2</b> (const <a class="el" href="classCGAL_1_1Min__ellipse__2.html#a85d7523e566c0be7444fdbc057d4ec8b">Point</a> &amp;p1, const <a class="el" href="classCGAL_1_1Min__ellipse__2.html#a85d7523e566c0be7444fdbc057d4ec8b">Point</a> &amp;p2, const <a class="el" href="classCGAL_1_1Min__ellipse__2.html#a85d7523e566c0be7444fdbc057d4ec8b">Point</a> &amp;p3, const <a class="el" href="classCGAL_1_1Min__ellipse__2.html#a85d7523e566c0be7444fdbc057d4ec8b">Point</a> &amp;p4, const Traits &amp;<a class="el" href="classCGAL_1_1Min__ellipse__2.html#adfb3289a1c1204f72a590bdc6010c073">traits</a>=Traits())</td></tr>
<tr class="memdesc:a23a7d4d8371623bb9741a63f1d29d041"><td class="mdescLeft"> </td><td class="mdescRight">initializes <code>min_ellipse</code> to \( me(\{p1,p2,p3,p4\})\). <br></td></tr>
<tr class="separator:a23a7d4d8371623bb9741a63f1d29d041"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0428f8b9a5a58ad1c16196b94262ad9a"><td class="memItemLeft" align="right" valign="top"><a id="a0428f8b9a5a58ad1c16196b94262ad9a" name="a0428f8b9a5a58ad1c16196b94262ad9a"></a>
 </td><td class="memItemRight" valign="bottom"><b>Min_ellipse_2</b> (const <a class="el" href="classCGAL_1_1Min__ellipse__2.html#a85d7523e566c0be7444fdbc057d4ec8b">Point</a> &amp;p1, const <a class="el" href="classCGAL_1_1Min__ellipse__2.html#a85d7523e566c0be7444fdbc057d4ec8b">Point</a> &amp;p2, const <a class="el" href="classCGAL_1_1Min__ellipse__2.html#a85d7523e566c0be7444fdbc057d4ec8b">Point</a> &amp;p3, const <a class="el" href="classCGAL_1_1Min__ellipse__2.html#a85d7523e566c0be7444fdbc057d4ec8b">Point</a> &amp;p4, const <a class="el" href="classCGAL_1_1Min__ellipse__2.html#a85d7523e566c0be7444fdbc057d4ec8b">Point</a> &amp;p5, const Traits &amp;<a class="el" href="classCGAL_1_1Min__ellipse__2.html#adfb3289a1c1204f72a590bdc6010c073">traits</a>=Traits())</td></tr>
<tr class="memdesc:a0428f8b9a5a58ad1c16196b94262ad9a"><td class="mdescLeft"> </td><td class="mdescRight">initializes <code>min_ellipse</code> to \( me(\{p1,p2,p3,p4,p5\})\). <br></td></tr>
<tr class="separator:a0428f8b9a5a58ad1c16196b94262ad9a"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Access Functions</h2></td></tr>
<tr class="memitem:adda843c9b668a7df4d43e087c55f44ef"><td class="memItemLeft" align="right" valign="top"><a id="adda843c9b668a7df4d43e087c55f44ef" name="adda843c9b668a7df4d43e087c55f44ef"></a>
int </td><td class="memItemRight" valign="bottom"><b>number_of_points</b> () const</td></tr>
<tr class="memdesc:adda843c9b668a7df4d43e087c55f44ef"><td class="mdescLeft"> </td><td class="mdescRight">returns the number of points of <code>min_ellipse</code>, i.e. \( |P|\). <br></td></tr>
<tr class="separator:adda843c9b668a7df4d43e087c55f44ef"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a57a229ca573b9eb958b48e580b17318a"><td class="memItemLeft" align="right" valign="top"><a id="a57a229ca573b9eb958b48e580b17318a" name="a57a229ca573b9eb958b48e580b17318a"></a>
int </td><td class="memItemRight" valign="bottom"><b>number_of_support_points</b> () const</td></tr>
<tr class="memdesc:a57a229ca573b9eb958b48e580b17318a"><td class="mdescLeft"> </td><td class="mdescRight">returns the number of support points of <code>min_ellipse</code>, i.e. \( |S|\). <br></td></tr>
<tr class="separator:a57a229ca573b9eb958b48e580b17318a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1dddfc673f54a1b6050553999cc0a400"><td class="memItemLeft" align="right" valign="top"><a id="a1dddfc673f54a1b6050553999cc0a400" name="a1dddfc673f54a1b6050553999cc0a400"></a>
<a class="el" href="classCGAL_1_1Min__ellipse__2.html#a8179f6ba721e4fae0e56a04e08e5dd11">Point_iterator</a> </td><td class="memItemRight" valign="bottom"><b>points_begin</b> () const</td></tr>
<tr class="memdesc:a1dddfc673f54a1b6050553999cc0a400"><td class="mdescLeft"> </td><td class="mdescRight">returns an iterator referring to the first point of <code>min_ellipse</code>. <br></td></tr>
<tr class="separator:a1dddfc673f54a1b6050553999cc0a400"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abbd618de1cd53057ab4880be7ec7f99a"><td class="memItemLeft" align="right" valign="top"><a id="abbd618de1cd53057ab4880be7ec7f99a" name="abbd618de1cd53057ab4880be7ec7f99a"></a>
<a class="el" href="classCGAL_1_1Min__ellipse__2.html#a8179f6ba721e4fae0e56a04e08e5dd11">Point_iterator</a> </td><td class="memItemRight" valign="bottom"><b>points_end</b> () const</td></tr>
<tr class="memdesc:abbd618de1cd53057ab4880be7ec7f99a"><td class="mdescLeft"> </td><td class="mdescRight">returns the corresponding past-the-end iterator. <br></td></tr>
<tr class="separator:abbd618de1cd53057ab4880be7ec7f99a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af778c1c16dae49ad9fc01681be5b4674"><td class="memItemLeft" align="right" valign="top"><a id="af778c1c16dae49ad9fc01681be5b4674" name="af778c1c16dae49ad9fc01681be5b4674"></a>
<a class="el" href="classCGAL_1_1Min__ellipse__2.html#aff8d704d738a232b81fa99c82c7cb5df">Support_point_iterator</a> </td><td class="memItemRight" valign="bottom"><b>support_points_begin</b> () const</td></tr>
<tr class="memdesc:af778c1c16dae49ad9fc01681be5b4674"><td class="mdescLeft"> </td><td class="mdescRight">returns an iterator referring to the first support point of <code>min_ellipse</code>. <br></td></tr>
<tr class="separator:af778c1c16dae49ad9fc01681be5b4674"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab7b13e07ab190b99fa9385c06e9d7a7b"><td class="memItemLeft" align="right" valign="top"><a id="ab7b13e07ab190b99fa9385c06e9d7a7b" name="ab7b13e07ab190b99fa9385c06e9d7a7b"></a>
<a class="el" href="classCGAL_1_1Min__ellipse__2.html#aff8d704d738a232b81fa99c82c7cb5df">Support_point_iterator</a> </td><td class="memItemRight" valign="bottom"><b>support_points_end</b> () const</td></tr>
<tr class="memdesc:ab7b13e07ab190b99fa9385c06e9d7a7b"><td class="mdescLeft"> </td><td class="mdescRight">returns the corresponding past-the-end iterator. <br></td></tr>
<tr class="separator:ab7b13e07ab190b99fa9385c06e9d7a7b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a039654b38c2fa49ffb66ac6f9e9465cf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classCGAL_1_1Min__ellipse__2.html#a85d7523e566c0be7444fdbc057d4ec8b">Point</a> &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Min__ellipse__2.html#a039654b38c2fa49ffb66ac6f9e9465cf">support_point</a> (int i) const</td></tr>
<tr class="memdesc:a039654b38c2fa49ffb66ac6f9e9465cf"><td class="mdescLeft"> </td><td class="mdescRight">returns the <code>i</code>-th support point of <code>min_ellipse</code>.  <br></td></tr>
<tr class="separator:a039654b38c2fa49ffb66ac6f9e9465cf"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8e409d48ee6822f036911ec4893b9b17"><td class="memItemLeft" align="right" valign="top"><a id="a8e409d48ee6822f036911ec4893b9b17" name="a8e409d48ee6822f036911ec4893b9b17"></a>
const <a class="el" href="classCGAL_1_1Min__ellipse__2.html#acd1b1aa7a496bc993dd231548192f1fc">Ellipse</a> &amp; </td><td class="memItemRight" valign="bottom"><b>ellipse</b> () const</td></tr>
<tr class="memdesc:a8e409d48ee6822f036911ec4893b9b17"><td class="mdescLeft"> </td><td class="mdescRight">returns the current ellipse of <code>min_ellipse</code>. <br></td></tr>
<tr class="separator:a8e409d48ee6822f036911ec4893b9b17"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Predicates</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>By definition, an empty <code><a class="el" href="classCGAL_1_1Min__ellipse__2.html" title="An object of the class Min_ellipse_2 is the unique ellipse of smallest area enclosing a finite (multi...">Min_ellipse_2</a></code> has no boundary and no bounded side, i.e. its unbounded side equals the whole space \(
\E^2\). </p>
</td></tr>
<tr class="memitem:a965651e0633d4820cd206e498ae655fc"><td class="memItemLeft" align="right" valign="top"><a id="a965651e0633d4820cd206e498ae655fc" name="a965651e0633d4820cd206e498ae655fc"></a>
<a class="elRef" href="../Kernel_23/group__kernel__enums.html#gaf6030e89dadcc1f45369b0cdc5d9e111">CGAL::Bounded_side</a> </td><td class="memItemRight" valign="bottom"><b>bounded_side</b> (const <a class="el" href="classCGAL_1_1Min__ellipse__2.html#a85d7523e566c0be7444fdbc057d4ec8b">Point</a> &amp;p) const</td></tr>
<tr class="memdesc:a965651e0633d4820cd206e498ae655fc"><td class="mdescLeft"> </td><td class="mdescRight">returns <code><a class="elRef" href="../Kernel_23/group__kernel__enums.html#ggaf6030e89dadcc1f45369b0cdc5d9e111ad8333d35d4801c08b3a5ae9e94d7cabe">CGAL::ON_BOUNDED_SIDE</a></code>, <code><a class="elRef" href="../Kernel_23/group__kernel__enums.html#ggaf6030e89dadcc1f45369b0cdc5d9e111a060193157c0875fb2e6445a648f3ac1f">CGAL::ON_BOUNDARY</a></code>, or <code><a class="elRef" href="../Kernel_23/group__kernel__enums.html#ggaf6030e89dadcc1f45369b0cdc5d9e111a3a96e6da84164cc8300c9e130be23f71">CGAL::ON_UNBOUNDED_SIDE</a></code> iff <code>p</code> lies properly inside, on the boundary of, or properly outside of <code>min_ellipse</code>, resp. <br></td></tr>
<tr class="separator:a965651e0633d4820cd206e498ae655fc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3992583c7aa438c5b0fb1b2753ffca98"><td class="memItemLeft" align="right" valign="top"><a id="a3992583c7aa438c5b0fb1b2753ffca98" name="a3992583c7aa438c5b0fb1b2753ffca98"></a>
bool </td><td class="memItemRight" valign="bottom"><b>has_on_bounded_side</b> (const <a class="el" href="classCGAL_1_1Min__ellipse__2.html#a85d7523e566c0be7444fdbc057d4ec8b">Point</a> &amp;p) const</td></tr>
<tr class="memdesc:a3992583c7aa438c5b0fb1b2753ffca98"><td class="mdescLeft"> </td><td class="mdescRight">returns <code>true</code>, iff <code>p</code> lies properly inside <code>min_ellipse</code>. <br></td></tr>
<tr class="separator:a3992583c7aa438c5b0fb1b2753ffca98"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2a47110a544ae513d3d2d0e225637705"><td class="memItemLeft" align="right" valign="top"><a id="a2a47110a544ae513d3d2d0e225637705" name="a2a47110a544ae513d3d2d0e225637705"></a>
bool </td><td class="memItemRight" valign="bottom"><b>has_on_boundary</b> (const <a class="el" href="classCGAL_1_1Min__ellipse__2.html#a85d7523e566c0be7444fdbc057d4ec8b">Point</a> &amp;p) const</td></tr>
<tr class="memdesc:a2a47110a544ae513d3d2d0e225637705"><td class="mdescLeft"> </td><td class="mdescRight">returns <code>true</code>, iff <code>p</code> lies on the boundary of <code>min_ellipse</code>. <br></td></tr>
<tr class="separator:a2a47110a544ae513d3d2d0e225637705"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afd9664f3ff624fef94eab667c900d0b7"><td class="memItemLeft" align="right" valign="top"><a id="afd9664f3ff624fef94eab667c900d0b7" name="afd9664f3ff624fef94eab667c900d0b7"></a>
bool </td><td class="memItemRight" valign="bottom"><b>has_on_unbounded_side</b> (const <a class="el" href="classCGAL_1_1Min__ellipse__2.html#a85d7523e566c0be7444fdbc057d4ec8b">Point</a> &amp;p) const</td></tr>
<tr class="memdesc:afd9664f3ff624fef94eab667c900d0b7"><td class="mdescLeft"> </td><td class="mdescRight">returns <code>true</code>, iff <code>p</code> lies properly outside of <code>min_ellipse</code>. <br></td></tr>
<tr class="separator:afd9664f3ff624fef94eab667c900d0b7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a459566c59c3151ea81d6b91036ebba48"><td class="memItemLeft" align="right" valign="top"><a id="a459566c59c3151ea81d6b91036ebba48" name="a459566c59c3151ea81d6b91036ebba48"></a>
bool </td><td class="memItemRight" valign="bottom"><b>is_empty</b> () const</td></tr>
<tr class="memdesc:a459566c59c3151ea81d6b91036ebba48"><td class="mdescLeft"> </td><td class="mdescRight">returns <code>true</code>, iff <code>min_ellipse</code> is empty (this implies degeneracy). <br></td></tr>
<tr class="separator:a459566c59c3151ea81d6b91036ebba48"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1d4af8eaa19991c91d7f863cb55a8eb3"><td class="memItemLeft" align="right" valign="top"><a id="a1d4af8eaa19991c91d7f863cb55a8eb3" name="a1d4af8eaa19991c91d7f863cb55a8eb3"></a>
bool </td><td class="memItemRight" valign="bottom"><b>is_degenerate</b> () const</td></tr>
<tr class="memdesc:a1d4af8eaa19991c91d7f863cb55a8eb3"><td class="mdescLeft"> </td><td class="mdescRight">returns <code>true</code>, iff <code>min_ellipse</code> is degenerate, i.e. if <code>min_ellipse</code> is empty, equal to a single point or equal to a segment, equivalently if the number of support points is less than 3. <br></td></tr>
<tr class="separator:a1d4af8eaa19991c91d7f863cb55a8eb3"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Modifiers</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>New points can be added to an existing <code>min_ellipse</code>, allowing to build \( me(P)\) incrementally, e.g.</p>
<p>if \( P\) is not known in advance. Compared to the direct creation of \( me(P)\), this is not much slower, because the construction method is incremental itself. </p>
</td></tr>
<tr class="memitem:a4318cb3457f776bf16af436aedd800d5"><td class="memItemLeft" align="right" valign="top"><a id="a4318cb3457f776bf16af436aedd800d5" name="a4318cb3457f776bf16af436aedd800d5"></a>
void </td><td class="memItemRight" valign="bottom"><b>insert</b> (const <a class="el" href="classCGAL_1_1Min__ellipse__2.html#a85d7523e566c0be7444fdbc057d4ec8b">Point</a> &amp;p)</td></tr>
<tr class="memdesc:a4318cb3457f776bf16af436aedd800d5"><td class="mdescLeft"> </td><td class="mdescRight">inserts <code>p</code> into <code>min_ellipse</code> and recomputes the smallest enclosing ellipse. <br></td></tr>
<tr class="separator:a4318cb3457f776bf16af436aedd800d5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac2e25c8cd331a432ecb9940e0b90587f"><td class="memTemplParams" colspan="2">template&lt;class <a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> &gt; </td></tr>
<tr class="memitem:ac2e25c8cd331a432ecb9940e0b90587f"><td class="memTemplItemLeft" align="right" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Min__ellipse__2.html#ac2e25c8cd331a432ecb9940e0b90587f">insert</a> (<a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> first, <a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> last)</td></tr>
<tr class="memdesc:ac2e25c8cd331a432ecb9940e0b90587f"><td class="mdescLeft"> </td><td class="mdescRight">inserts the points in the range [<code>first</code>,<code>last</code>) into <code>min_ellipse</code> and recomputes the smallest enclosing ellipse by calling <code>insert(p)</code> for each point <code>p</code> in [<code>first</code>,<code>last</code>).  <br></td></tr>
<tr class="separator:ac2e25c8cd331a432ecb9940e0b90587f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae9e4a669bf02a62d491fb6c8234388d0"><td class="memItemLeft" align="right" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Min__ellipse__2.html#ae9e4a669bf02a62d491fb6c8234388d0">clear</a> ()</td></tr>
<tr class="memdesc:ae9e4a669bf02a62d491fb6c8234388d0"><td class="mdescLeft"> </td><td class="mdescRight">deletes all points in <code>min_ellipse</code> and sets <code>min_ellipse</code> to the empty set.  <br></td></tr>
<tr class="separator:ae9e4a669bf02a62d491fb6c8234388d0"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Validity Check</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>An object <code>min_ellipse</code> is valid, iff</p>
<ul>
<li>
<code>min_ellipse</code> contains all points of its defining set \( P\), </li>
<li>
<code>min_ellipse</code> is the smallest ellipse spanned by its support set \( S\), and </li>
<li>
\( S\) is minimal, i.e. no support point is redundant. </li>
</ul>
<p><em>Note:</em> In this release only the first item is considered by the validity check. </p>
</td></tr>
<tr class="memitem:af6a28f682d260c010fae1731946646cf"><td class="memItemLeft" align="right" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Min__ellipse__2.html#af6a28f682d260c010fae1731946646cf">is_valid</a> (bool verbose=false, int level=0) const</td></tr>
<tr class="memdesc:af6a28f682d260c010fae1731946646cf"><td class="mdescLeft"> </td><td class="mdescRight">returns <code>true</code>, iff <code>min_ellipse</code> contains all points of its defining set \( P\).  <br></td></tr>
<tr class="separator:af6a28f682d260c010fae1731946646cf"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Miscellaneous</h2></td></tr>
<tr class="memitem:adfb3289a1c1204f72a590bdc6010c073"><td class="memItemLeft" align="right" valign="top"><a id="adfb3289a1c1204f72a590bdc6010c073" name="adfb3289a1c1204f72a590bdc6010c073"></a>
const Traits &amp; </td><td class="memItemRight" valign="bottom"><b>traits</b> () const</td></tr>
<tr class="memdesc:adfb3289a1c1204f72a590bdc6010c073"><td class="mdescLeft"> </td><td class="mdescRight">returns a const reference to the traits class object. <br></td></tr>
<tr class="separator:adfb3289a1c1204f72a590bdc6010c073"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="acd1b1aa7a496bc993dd231548192f1fc" name="acd1b1aa7a496bc993dd231548192f1fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd1b1aa7a496bc993dd231548192f1fc">◆ </a></span>Ellipse</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> <a class="el" href="classCGAL_1_1Min__ellipse__2.html">CGAL::Min_ellipse_2</a>&lt; Traits &gt;<a class="el" href="classEllipse.html">::Ellipse</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef to <code>Traits::Ellipse</code>. </p>
<p>If you are using the predefined traits class <code><a class="el" href="classCGAL_1_1Min__ellipse__2__traits__2.html" title="The class Min_ellipse_2_traits_2 is a traits class for CGAL::Min_ellipse_2&lt;Traits&gt; using the two-dime...">CGAL::Min_ellipse_2_traits_2</a>&lt;K&gt;</code>, you can access the coefficients of the ellipse, see the documentation of <code><a class="el" href="classCGAL_1_1Min__ellipse__2__traits__2.html" title="The class Min_ellipse_2_traits_2 is a traits class for CGAL::Min_ellipse_2&lt;Traits&gt; using the two-dime...">CGAL::Min_ellipse_2_traits_2</a>&lt;K&gt;</code> and the example below. </p>

</div>
</div>
<a id="a8179f6ba721e4fae0e56a04e08e5dd11" name="a8179f6ba721e4fae0e56a04e08e5dd11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8179f6ba721e4fae0e56a04e08e5dd11">◆ </a></span>Point_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> <a class="el" href="classCGAL_1_1Min__ellipse__2.html">CGAL::Min_ellipse_2</a>&lt; Traits &gt;::Point_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Non-mutable model of the STL concept <em><a class="elRef" href="../Manual/classBidirectionalIterator.html">BidirectionalIterator</a></em> with value type <code>Point</code>. </p>
<p>Used to access the points of the smallest enclosing ellipse. </p>

</div>
</div>
<a id="aff8d704d738a232b81fa99c82c7cb5df" name="aff8d704d738a232b81fa99c82c7cb5df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff8d704d738a232b81fa99c82c7cb5df">◆ </a></span>Support_point_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="elRef" href="../Manual/classunspecified__type.html">unspecified_type</a> <a class="el" href="classCGAL_1_1Min__ellipse__2.html">CGAL::Min_ellipse_2</a>&lt; Traits &gt;::Support_point_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Non-mutable model of the STL concept <em><a class="elRef" href="../Manual/classRandomAccessIterator.html">RandomAccessIterator</a></em> with value type <code>Point</code>. </p>
<p>Used to access the support points of the smallest enclosing ellipse. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5e7e882ef3be97366345e617b3b7b4de" name="a5e7e882ef3be97366345e617b3b7b4de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e7e882ef3be97366345e617b3b7b4de">◆ </a></span>Min_ellipse_2() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Min__ellipse__2.html">CGAL::Min_ellipse_2</a>&lt; Traits &gt;::Min_ellipse_2 </td>
          <td>(</td>
          <td class="paramtype">const Traits &amp; </td>
          <td class="paramname"><em>traits</em> = <code>Traits()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a variable <code>min_ellipse</code> of type <code><a class="el" href="classCGAL_1_1Min__ellipse__2.html" title="An object of the class Min_ellipse_2 is the unique ellipse of smallest area enclosing a finite (multi...">Min_ellipse_2</a></code>. </p>
<p>It is initialized to \( me(\emptyset)\), the empty set. </p><dl class="section post"><dt>Postcondition</dt><dd><code>min_ellipse.is_empty()</code> = <code>true</code>. </dd></dl>

</div>
</div>
<a id="a3c1fb4d1d73003f55bc28809d85e38dc" name="a3c1fb4d1d73003f55bc28809d85e38dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c1fb4d1d73003f55bc28809d85e38dc">◆ </a></span>Min_ellipse_2() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Min__ellipse__2.html">CGAL::Min_ellipse_2</a>&lt; Traits &gt;::Min_ellipse_2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Min__ellipse__2.html#a85d7523e566c0be7444fdbc057d4ec8b">Point</a> &amp; </td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Traits &amp; </td>
          <td class="paramname"><em>traits</em> = <code>Traits()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>initializes <code>min_ellipse</code> to \( me(\{p\})\), the set \( \{p\}\). </p>
<dl class="section post"><dt>Postcondition</dt><dd><code>min_ellipse.is_degenerate()</code> = <code>true</code>. </dd></dl>

</div>
</div>
<a id="a49947e7016b29a1a6656aeeaf7045614" name="a49947e7016b29a1a6656aeeaf7045614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49947e7016b29a1a6656aeeaf7045614">◆ </a></span>Min_ellipse_2() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Min__ellipse__2.html">CGAL::Min_ellipse_2</a>&lt; Traits &gt;::Min_ellipse_2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Min__ellipse__2.html#a85d7523e566c0be7444fdbc057d4ec8b">Point</a> &amp; </td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Min__ellipse__2.html#a85d7523e566c0be7444fdbc057d4ec8b">Point</a> &amp; </td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Traits &amp; </td>
          <td class="paramname"><em>traits</em> = <code>Traits()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>initializes <code>min_ellipse</code> to \( me(\{p,q\})\), the set \( \{ (1-\lambda) p + \lambda q \mid 0 \leq \lambda \leq 1 \}\) </p>
<dl class="section post"><dt>Postcondition</dt><dd><code>min_ellipse.is_degenerate()</code> = <code>true</code>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae9e4a669bf02a62d491fb6c8234388d0" name="ae9e4a669bf02a62d491fb6c8234388d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e4a669bf02a62d491fb6c8234388d0">◆ </a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCGAL_1_1Min__ellipse__2.html">CGAL::Min_ellipse_2</a>&lt; Traits &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>deletes all points in <code>min_ellipse</code> and sets <code>min_ellipse</code> to the empty set. </p>
<dl class="section post"><dt>Postcondition</dt><dd><code>min_ellipse.is_empty()</code> = <code>true</code>. </dd></dl>

</div>
</div>
<a id="ac2e25c8cd331a432ecb9940e0b90587f" name="ac2e25c8cd331a432ecb9940e0b90587f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e25c8cd331a432ecb9940e0b90587f">◆ </a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<div class="memtemplate">
template&lt;class <a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCGAL_1_1Min__ellipse__2.html">CGAL::Min_ellipse_2</a>&lt; Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> </td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> </td>
          <td class="paramname"><em>last</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>inserts the points in the range [<code>first</code>,<code>last</code>) into <code>min_ellipse</code> and recomputes the smallest enclosing ellipse by calling <code>insert(p)</code> for each point <code>p</code> in [<code>first</code>,<code>last</code>). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a></td><td>is a model of <code><a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a></code> with <code>Point</code> as value type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6a28f682d260c010fae1731946646cf" name="af6a28f682d260c010fae1731946646cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6a28f682d260c010fae1731946646cf">◆ </a></span>is_valid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Min__ellipse__2.html">CGAL::Min_ellipse_2</a>&lt; Traits &gt;::is_valid </td>
          <td>(</td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>verbose</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>level</em> = <code>0</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns <code>true</code>, iff <code>min_ellipse</code> contains all points of its defining set \( P\). </p>
<p>If <code>verbose</code> is <code>true</code>, some messages concerning the performed checks are written to standard error stream. The second parameter <code>level</code> is not used, we provide it only for consistency with interfaces of other classes. </p>

</div>
</div>
<a id="a077e61fca4c81442bbcc3c8f3814c74f" name="a077e61fca4c81442bbcc3c8f3814c74f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a077e61fca4c81442bbcc3c8f3814c74f">◆ </a></span>Min_Ellipse_2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<div class="memtemplate">
template&lt;class <a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Min__ellipse__2.html">CGAL::Min_ellipse_2</a>&lt; Traits &gt;::Min_Ellipse_2 </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> </td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a> </td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>randomize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Random &amp; </td>
          <td class="paramname"><em>random</em> = <code>get_default_random()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Traits &amp; </td>
          <td class="paramname"><em>traits</em> = <code>Traits()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>initializes <code>min_ellipse</code> to \( me(P)\) with \( P\) being the set of points in the range [<code>first</code>,<code>last</code>). </p>
<p>If <code>randomize</code> is <code>true</code>, a random permutation of \( P\) is computed in advance, using the random numbers generator <code>random</code>. Usually, this will not be necessary, however, the algorithm's efficiency depends on the order in which the points are processed, and a bad order might lead to extremely poor performance (see example below). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a></td><td>is a model of <code><a class="elRef" href="../Manual/classInputIterator.html">InputIterator</a></code> with <code>Point</code> as value type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a039654b38c2fa49ffb66ac6f9e9465cf" name="a039654b38c2fa49ffb66ac6f9e9465cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a039654b38c2fa49ffb66ac6f9e9465cf">◆ </a></span>support_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classCGAL_1_1Min__ellipse__2.html#a85d7523e566c0be7444fdbc057d4ec8b">Point</a> &amp; <a class="el" href="classCGAL_1_1Min__ellipse__2.html">CGAL::Min_ellipse_2</a>&lt; Traits &gt;::support_point </td>
          <td>(</td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the <code>i</code>-th support point of <code>min_ellipse</code>. </p>
<p>Between two modifying operations (see below) any call to <code>min_ellipse.support_point(i)</code> with the same <code>i</code> returns the same point. </p><dl class="section pre"><dt>Precondition</dt><dd>\( 0 \leq i&lt;\) <code>min_ellipse.number_of_support_points()</code>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="af7c0fb64d240921356e6a4e818592e42" name="af7c0fb64d240921356e6a4e818592e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7c0fb64d240921356e6a4e818592e42">◆ </a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp; </td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Min__ellipse__2.html">Min_ellipse_2</a>&lt; Traits &gt; &amp; </td>
          <td class="paramname"><em>min_ellipse</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>writes <code>min_ellipse</code> to output stream <code>os</code>. </p>
<p>An overload of <code>operator&lt;&lt;</code> must be defined for <code>Point</code> (and for <code><a class="el" href="classEllipse.html" title="An object ellipse of the class Ellipse is an ellipse in two-dimensional Euclidean plane ....">Ellipse</a></code>, if pretty printing is used). </p>

</div>
</div>
<a id="a13acc6b8559f5210d49e60513eaaf7b6" name="a13acc6b8559f5210d49e60513eaaf7b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13acc6b8559f5210d49e60513eaaf7b6">◆ </a></span>operator&gt;&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp; </td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Min__ellipse__2.html">Min_ellipse_2</a>&lt; Traits &gt; min_ellipse &amp; </td>
          <td class="paramname"> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reads <code>min_ellipse</code> from input stream <code>is</code>. </p>
<p>An overload of <code>operator&gt;&gt;</code> must be defined for <code>Point</code>. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>CGAL</b></li><li class="navelem"><a class="el" href="classCGAL_1_1Min__ellipse__2.html">Min_ellipse_2</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"></a> 1.9.6 </li>
  </ul>
</div>
</div>
</body>



</html>
