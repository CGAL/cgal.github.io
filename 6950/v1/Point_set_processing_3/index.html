<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="https://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Point_set_processing_3/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=9" />
<meta name="generator" content="Doxygen 1.8.13" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CGAL 5.6 - Point Set Processing: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//&amp;lt;![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      }
  }
}
);
//]]&amp;gt;
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.6 - Point Set Processing
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Point_Set_Processing"></a><a class="anchor" id="chappoint_set_processing_3"></a>  </p><div id="autotoc" class="toc"></div> 
<dl class="section author"><dt>Authors</dt><dd>Pierre Alliez, Simon Giraudot, Clément Jamin, Florent Lafarge, Quentin Mérigot, Jocelyn Meyron, Laurent Saboret, Nader Salman, Shihao Wu, Necip Fazil Yildiran</dd></dl>
<h1><a class="anchor" id="Point_set_processing_3Introduction"></a>
Introduction</h1>
<p>This CGAL component implements methods to analyze and process 3D point sets. The input is an unorganized 3D point set, possibly with normal attributes (unoriented or oriented). The input point set can be analyzed to measure geometric properties such as average spacing between the points and their <code>k</code> nearest neighbors. It can be processed with functions devoted to the simplification, regularization, upsampling, outlier removal, smoothing, normal estimation and normal orientation. The processing of point sets is often needed in applications dealing with measurement data, such as surface reconstruction from laser scanned data (see <a class="el" href="index.html#fig__Point_set_processing_3figintroduction">Figure 80.1</a>).</p>
<p><a class="anchor" id="fig__Point_set_processing_3figintroduction"></a></p><div class="image">
<img src="introduction.jpg" alt="introduction.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figintroduction">Figure 80.1</a> Point set processing. Left: 275K points sampled on the statue of an elephant with a Minolta laser scanner. Right: point set after outlier removal, denoising and simplification to 17K points.  </div> <br /> 
<p>In the context of surface reconstruction we can position the elements of this component along the common surface reconstruction pipeline (<a class="el" href="index.html#fig__Point_set_processing_3figpipeline">Figure 80.2</a>) which involves the following steps:</p><ol type="1">
<li>Scanning and scan registration to produce a set of points or points with normals;</li>
<li>Outlier removal;</li>
<li>Simplification to reduce the number of input points;</li>
<li>Smoothing to reduce noise in the input data;</li>
<li>Normal estimation and orientation when the normals are not already provided by the acquisition device; and</li>
<li>Surface reconstruction. Chapter <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Poisson_surface_reconstruction_3.tag:../Poisson_surface_reconstruction_3/" href="../Poisson_surface_reconstruction_3/index.html#Chapter_Poisson_Surface_Reconstruction">Poisson Surface Reconstruction</a> deals with surface reconstruction from point sets with normal attributes.</li>
</ol>
<p><a class="anchor" id="fig__Point_set_processing_3figpipeline"></a></p><div class="image">
<img src="pipeline.jpg" alt="pipeline.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figpipeline">Figure 80.2</a> Point set processing pipeline for surface reconstruction. The algorithms listed in gray are available from other <a class="el" href="namespaceCGAL.html">CGAL</a> components (bounding volumes and principal component analysis).  </div> <br /> 
<h1><a class="anchor" id="Point_set_processing_3API"></a>
API</h1>
<p>The algorithms of this component take as input parameters ranges of 3D points, or of 3D points with normals. They can be adapted to the user's data structures and make extensive use of <a class="el" href="index.html#Point_set_processing_3NamedParameters">named parameters</a> and of <a class="el" href="index.html#Point_set_processing_3PropertyMaps">property maps</a>:</p>
<div class="fragment"><div class="line">std::vector&lt;PointVectorPair&gt; points;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a> Point_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a> Vector_map;</div><div class="line"></div><div class="line"><a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga078e25209373cab0e1f3524202489771">CGAL::jet_estimate_normals</a></div><div class="line">&lt;<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__tag.html">CGAL::Parallel_tag</a>&gt;           <span class="comment">// concurrency tag</span></div><div class="line">  (points,                     <span class="comment">// input range of points</span></div><div class="line">   12,                         <span class="comment">// parameter: number of neighbors</span></div><div class="line">   <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL_1_1parameters.html">CGAL::parameters</a>::          <span class="comment">// named parameters:</span></div><div class="line">   point_map (Point_map()).    <span class="comment">//  * point map</span></div><div class="line">   normal_map (Vector_map())); <span class="comment">//  * normal map</span></div></div><!-- fragment --><p>This API was introduced in CGAL 4.12. Please refer to the <a class="el" href="index.html#Point_set_processing_3Outdated">dedicated section</a> on how to upgrade from the outdated API.</p>
<h2><a class="anchor" id="Point_set_processing_3NamedParameters"></a>
Named Parameters</h2>
<p>Named parameters are used to deal with optional parameters. The page <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/index.html#BGLNamedParameters">Named Parameters</a> explains the rationale and API in general. The page <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__bgl__namedparameters.html">Named Parameters</a> describes their usage.</p>
<h2><a class="anchor" id="Point_set_processing_3PropertyMaps"></a>
Property Maps</h2>
<p>The property maps are used to access the point or normal information from the input data, so as to let the user decide upon the implementation of a point with normal. The latter can be represented as, e.g., a class derived from the CGAL 3D point, or as a <code>std::pair&lt;<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__3.html">Point_3</a>&lt;K&gt;, <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Vector__3.html">Vector_3</a>&lt;K&gt;&gt;</code>, or as a <code>boost::tuple&lt;..,<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__3.html">Point_3</a>&lt;K&gt;, ..., <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Vector__3.html">Vector_3</a>&lt;K&gt; &gt;</code>.</p>
<p>The following classes described in Chapter <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgPropertyMap">CGAL and Boost Property Maps</a> provide property maps for the implementations of points with normals listed above:</p>
<ul>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Identity__property__map.html">Identity_property_map</a>&lt;T&gt;</code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">First_of_pair_property_map</a>&lt;Pair&gt;</code> and <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">Second_of_pair_property_map</a>&lt;Pair&gt;</code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">Nth_of_tuple_property_map</a>&lt;N, Tuple&gt;</code></li>
</ul>
<p><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Identity__property__map.html">Identity_property_map</a>&lt;<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__3.html">Point_3</a>&gt;</code> is the default value of the position property map expected by all functions in this component.</p>
<p>See below examples using pair and tuple property maps.</p>
<p>Users of this package may use other types to represent positions and normals if they implement the corresponding property maps.</p>
<p>Points and normals can even be stored in separate containers and accessed by their index, as any built-in vector is also a property map.</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2grid_simplify_indices_8cpp-example.html">Point_set_processing_3/grid_simplify_indices.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/grid_simplify_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/fin90_with_PCA_normals.xyz"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Reads a .xyz point set file in points[].</span></div><div class="line">  std::vector&lt;Point&gt; points;</div><div class="line">  std::vector&lt;Vector&gt; normals;</div><div class="line">  std::ifstream stream(fname);</div><div class="line">  Point p;</div><div class="line">  Vector v;</div><div class="line">  <span class="keywordflow">while</span>(stream &gt;&gt; p &gt;&gt; v)</div><div class="line">  {</div><div class="line">    points.push_back(p);</div><div class="line">    normals.push_back(v);</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; points.size() &lt;&lt; <span class="stringliteral">" input points"</span> &lt;&lt; std::endl;</div><div class="line">  std::vector&lt;std::size_t&gt; indices(points.size());</div><div class="line">  <span class="keywordflow">for</span>(std::size_t i = 0; i &lt; points.size(); ++i){</div><div class="line">    indices[i] = i;</div><div class="line">  }</div><div class="line">  <span class="comment">// simplification by clustering using erase-remove idiom</span></div><div class="line">  <span class="keywordtype">double</span> cell_size = 0.05;</div><div class="line">  std::vector&lt;std::size_t&gt;::iterator end;</div><div class="line">  end = <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga7757ef9b3900e42fde26f5a0ac56e20f">CGAL::grid_simplify_point_set</a>(indices,</div><div class="line">                                      cell_size,</div><div class="line">                                      CGAL::parameters::point_map (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/group__PkgPropertyMapRef.html#ga44ae71cce5987f3970443868a129752a">CGAL::make_property_map</a>(points)));</div><div class="line"></div><div class="line">  std::size_t k = end - indices.begin();</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Keep "</span> &lt;&lt; k &lt;&lt; <span class="stringliteral">" of "</span> &lt;&lt; indices.size() &lt;&lt;  <span class="stringliteral">" indices"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  {</div><div class="line">    std::vector&lt;Point&gt; tmp_points(k);</div><div class="line">    std::vector&lt;Vector&gt; tmp_normals(k);</div><div class="line">    <span class="keywordflow">for</span>(std::size_t i=0; i&lt;k; ++i){</div><div class="line">      tmp_points[i] = points[indices[i]];</div><div class="line">      tmp_normals[i] = normals[indices[i]];</div><div class="line">    }</div><div class="line">    points.swap(tmp_points);</div><div class="line">    normals.swap(tmp_normals);</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; points.size() &lt;&lt; <span class="stringliteral">" points after the simplification"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h2><a class="anchor" id="Point_set_processing_3Outdated"></a>
Upgrading from pre-CGAL 4.12 API</h2>
<p>The current API based on ranges and named parameters was introduced in CGAL 4.12. The old API that used pairs of iterators along with usual C++ parameters (with some default values and overloads to handle optional parameters) has been removed in CGAL 5.0.</p>
<p>Translating your pre-CGAL 4.12 code using Point Set Processing to the current API is easy. For example, consider this code using the old API:</p>
<div class="fragment"><div class="line">std::vector&lt;PointVectorPair&gt; points;</div><div class="line"></div><div class="line"><span class="comment">// Old pre-CGAL 4.12 API</span></div><div class="line">CGAL::jet_estimate_normals&lt;Concurrency_tag&gt;</div><div class="line">  (points.begin(), points.end(),</div><div class="line">   <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>(),</div><div class="line">   <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>(),</div><div class="line">   12); <span class="comment">// Number of neighbors</span></div></div><!-- fragment --><p>The pair of iterators is replaced by a range and the optional parameters (than can be deduced automatically in simple cases) are moved to the end of the function in a single named parameter object (see <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/index.html#BGLNamedParameters">Named Parameters</a>). The code translated to the current API becomes:</p>
<div class="fragment"><div class="line">std::vector&lt;PointVectorPair&gt; points;</div><div class="line"></div><div class="line"><span class="comment">// New API</span></div><div class="line">CGAL::jet_estimate_normals&lt;Concurrency_tag&gt;</div><div class="line">  (points,</div><div class="line">   12, <span class="comment">// Number of neighbors</span></div><div class="line">   CGAL::parameters::point_map (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>()).</div><div class="line">   normal_map (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>()));</div></div><!-- fragment --><p>Please refer to the <a class="el" href="group__PkgPointSetProcessing3Ref.html">Reference Manual</a> for the detailed API of the Point Set Processing functions.</p>
<h1><a class="anchor" id="Point_set_processing_3InputOutput"></a>
Input/Output</h1>
<h2><a class="anchor" id="Point_set_processing_3Points_io"></a>
Points And Normals</h2>
<p>CGAL provides functions to read and write sets of points (possibly with normals) from the following file formats:</p>
<ul>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/IOStreamSupportedFileFormats.html#IOStreamXYZ">XYZ </a> (ASCII file three point coordinates <code>x y z</code> per line or three point coordinates and three normal vector coordinates <code>x y z nx ny nz</code> per line)</li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/IOStreamSupportedFileFormats.html#IOStreamOFF">OFF (Object File Format) </a> – <a class="el" href="citelist.html#CITEREF_cgal:p-gmgv16-96">[11]</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/IOStreamSupportedFileFormats.html#IOStreamPLY">PLY (Polygon File Format) </a> – <a class="el" href="citelist.html#CITEREF_cgal:b-ply-11">[12]</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/IOStreamSupportedFileFormats.html#IOStreamLAS">LAS (Lidar Format) </a> – <a class="el" href="citelist.html#CITEREF_cgal:asprs-lasf-13">[1]</a> This format does not handle normals and requires the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartyLASlib">LASlib</a> library.</li>
</ul>
<p>All of the functions in <a class="el" href="group__PkgPointSetProcessing3IO.html">I/O Functions</a> (with the exception of the LAS format) can read and write either points alone or points with normals (depending on whether the <code>normal_map</code> named parameter is used by the user or not). Note that the PLY format handles both ASCII and binary formats. In addition, PLY and LAS are extensible formats that can embed additional properties. These can also be read by CGAL (see Section <a class="el" href="index.html#Point_set_processing_3Properties_io">Points With Properties</a>).</p>
<h3><a class="anchor" id="Point_set_processing_3Example_io"></a>
Example</h3>
<p>The following example reads a point set from an input file and writes it to a file, both in the XYZ format. Positions and normals are stored in pairs and accessed through property maps. <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2read_write_xyz_point_set_example_8cpp-example.html">Point_set_processing_3/read_write_xyz_point_set_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_xyz_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_xyz_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span> <span class="comment">// defines std::pair</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"></div><div class="line"><span class="comment">// Point with normal vector stored as a std::pair.</span></div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Point, Vector&gt; Pwn;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/oni.pwn"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Reads a .xyz point set file in points[].</span></div><div class="line">  <span class="comment">// Note: read_points() requires an output iterator</span></div><div class="line">  <span class="comment">// over points and as well as property maps to access each</span></div><div class="line">  <span class="comment">// point position and normal.</span></div><div class="line">  std::vector&lt;Pwn&gt; points;</div><div class="line">  <span class="keywordflow">if</span>(!CGAL::IO::read_XYZ(fname,</div><div class="line">                         std::back_inserter(points),</div><div class="line">                         CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Pwn&gt;</a>())</div><div class="line">                                          .normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;Pwn&gt;</a>())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Saves point set.</span></div><div class="line">  <span class="comment">// Note: write_XYZ() requires property maps to access each</span></div><div class="line">  <span class="comment">// point position and normal.</span></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IOXyz.html#ga1991ab8d312de62ddd907f81890ed039">CGAL::IO::write_XYZ</a>(<span class="stringliteral">"oni_copy.xyz"</span>, points,</div><div class="line">                          CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Pwn&gt;</a>())</div><div class="line">                                           .normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;Pwn&gt;</a>())</div><div class="line">                                           .stream_precision(17)))</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Point_set_processing_3Properties_io"></a>
Points With Properties</h2>
<p>PLY files are designed to embed an arbitrary number of additional attributes. More specifically, point sets may contain visibility vectors, RGB colors, intensity, etc. As it is not possible to provide dedicated functions to every possible combination of PLY properties, CGAL provides a simple way to read PLY properties and store them in any structure the user needs. Handling of LAS files works similarly with the difference that the property names and types are fixed and defined by the LAS standard.</p>
<p>Functions <code><a class="el" href="group__PkgPointSetProcessing3IOPly.html#gad9785e7191ba94d81fac841798aa1ddb" title="reads user-selected points properties from a .ply stream (ASCII or binary). ">read_PLY_with_properties()</a></code> and <code><a class="el" href="group__PkgPointSetProcessing3IOLas.html#ga5187fc18430a5e3c811f75da57a057ad" title="reads user-selected points properties from a .las or .laz stream. ">read_LAS_with_properties()</a></code> allow the user to read any property needed. The user must provide a set of property handlers that are used to instantiate number types and complex objects from PLY/LAS properties. This handlers are either:</p>
<ul>
<li>a pair consisting of a property map and of a single PLY/LAS property descriptor</li>
<li>a tuple consisting of a property map, a functor to construct the objects wanted and multiple PLY/LAS property descriptors</li>
</ul>
<p>Output functions <code><a class="el" href="group__PkgPointSetProcessing3IOPly.html#gac1fd90a9d5266e631c68cb31bfe31516" title="writes the range of points with properties using Polygon File Format (PLY). ">write_PLY_with_properties()</a></code> and <code><a class="el" href="group__PkgPointSetProcessing3IOLas.html#gafaeb3b48279532412ec422c90a7f05fc" title="writes the range of points with properties to a .las stream. ">write_LAS_with_properties()</a></code> work similarly.</p>
<h3><a class="anchor" id="Point_set_processing_3Example_ply_write"></a>
PLY Writing Example</h3>
<p>The following example shows how to call <code><a class="el" href="group__PkgPointSetProcessing3IOPly.html#gac1fd90a9d5266e631c68cb31bfe31516" title="writes the range of points with properties using Polygon File Format (PLY). ">write_PLY_with_properties()</a></code> to write a point set with points, RGB colors and intensity. Notice that in order to write a complex object, users need to provide an overload of <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1Output__rep.html">CGAL::Output_rep</a></code>.</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2write_ply_points_example_8cpp-example.html">Point_set_processing_3/write_ply_points_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_ply_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"><span class="keyword">typedef</span> std::array&lt;unsigned char, 4&gt; Color;</div><div class="line"></div><div class="line"><span class="comment">// Point with normal, color and intensity</span></div><div class="line"><span class="keyword">typedef</span> std::tuple&lt;Point, Color, int&gt; PCI;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;0, PCI&gt;</a> Point_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;1, PCI&gt;</a> Color_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;2, PCI&gt;</a> Intensity_map;</div><div class="line"></div><div class="line"><span class="comment">// Define how a color should be stored</span></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceCGAL.html">CGAL</a> {</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> F &gt;</div><div class="line"><span class="keyword">struct </span>Output_rep&lt; ::Color, F &gt; {</div><div class="line">  const ::Color&amp; c;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_specialized = <span class="keyword">true</span>;</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1Output__rep.html#a3ecfc0ce6d2e5db55ad05d08c549ce27">Output_rep</a> (const ::Color&amp; c) : c(c)</div><div class="line">  { }</div><div class="line">  std::ostream&amp; <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1Output__rep.html#a022b1af6b20bcd6957908d70b3c9136b">operator() </a>(std::ostream&amp; out)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">if</span> (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#gaf145cf5cbf5e27ebb907a8260002a5f3">IO::is_ascii</a>(out))</div><div class="line">      out &lt;&lt; int(c[0]) &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; int(c[1]) &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; int(c[2]) &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; int(c[3]);</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      out.write(reinterpret_cast&lt;const char*&gt;(&amp;c), <span class="keyword">sizeof</span>(c));</div><div class="line">    <span class="keywordflow">return</span> out;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line">} <span class="comment">// namespace CGAL</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>**)</div><div class="line">{</div><div class="line">  std::vector&lt;PCI&gt; points; <span class="comment">// store points</span></div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 10; ++ i)</div><div class="line">    points.push_back (std::make_tuple (Point (i / 10., i / 20., i / 30.),</div><div class="line">                                               <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__PkgSTLExtensionRef.html#ga6b9a3534a37aeb7d3095ec08801931d7">CGAL::make_array</a> (static_cast&lt;unsigned char&gt;(255 / (i + 1)),</div><div class="line">                                                                 static_cast&lt;unsigned char&gt;(192 / (i + 1)),</div><div class="line">                                                                 static_cast&lt;unsigned char&gt;(128 / (i + 1)),</div><div class="line">                                                                 static_cast&lt;unsigned char&gt;(64 / (i + 1))),</div><div class="line">                                               i));</div><div class="line"></div><div class="line">  std::ofstream f(<span class="stringliteral">"out.ply"</span>, std::ios::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a>(f); <span class="comment">// The PLY file will be written in the binary format</span></div><div class="line"></div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3IOPly.html#gac1fd90a9d5266e631c68cb31bfe31516">CGAL::IO::write_PLY_with_properties</a>(f, points,</div><div class="line">                                      <a class="code" href="group__PkgPointSetProcessing3IOPly.html#ga241c6df9d93e26ec7254ef6366cb7e5b">CGAL::make_ply_point_writer</a> (Point_map()),</div><div class="line">                                      std::make_tuple(Color_map(),</div><div class="line">                                                      <a class="code" href="structCGAL_1_1IO_1_1PLY__property.html">CGAL::IO::PLY_property&lt;unsigned char&gt;</a>(<span class="stringliteral">"red"</span>),</div><div class="line">                                                      <a class="code" href="structCGAL_1_1IO_1_1PLY__property.html">CGAL::IO::PLY_property&lt;unsigned char&gt;</a>(<span class="stringliteral">"green"</span>),</div><div class="line">                                                      <a class="code" href="structCGAL_1_1IO_1_1PLY__property.html">CGAL::IO::PLY_property&lt;unsigned char&gt;</a>(<span class="stringliteral">"blue"</span>),</div><div class="line">                                                      <a class="code" href="structCGAL_1_1IO_1_1PLY__property.html">CGAL::IO::PLY_property&lt;unsigned char&gt;</a>(<span class="stringliteral">"alpha"</span>)),</div><div class="line">                                  std::make_pair(Intensity_map(), <a class="code" href="structCGAL_1_1IO_1_1PLY__property.html">CGAL::IO::PLY_property&lt;int&gt;</a>(<span class="stringliteral">"intensity"</span>)));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="Point_set_processing_3Example_ply_read"></a>
PLY Reading Example</h3>
<p>The following example shows how to call <code><a class="el" href="group__PkgPointSetProcessing3IOPly.html#gad9785e7191ba94d81fac841798aa1ddb" title="reads user-selected points properties from a .ply stream (ASCII or binary). ">read_PLY_with_properties()</a></code> to read a point set with points, normals, RGB colors and intensity and stores these attributes in a user-defined container.</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2read_ply_points_with_colors_example_8cpp-example.html">Point_set_processing_3/read_ply_points_with_colors_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_ply_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"><span class="keyword">typedef</span> std::array&lt;unsigned char, 3&gt; Color;</div><div class="line"></div><div class="line"><span class="comment">// Point with normal, color and intensity</span></div><div class="line"><span class="keyword">typedef</span> std::tuple&lt;Point, Vector, Color, int&gt; PNCI;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;0, PNCI&gt;</a> Point_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;1, PNCI&gt;</a> Normal_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;2, PNCI&gt;</a> Color_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;3, PNCI&gt;</a> Intensity_map;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/colors.ply"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Reads a .ply point set file with normal vectors and colors</span></div><div class="line">  std::vector&lt;PNCI&gt; points; <span class="comment">// store points</span></div><div class="line">  std::ifstream in(fname);</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IOPly.html#gad9785e7191ba94d81fac841798aa1ddb">CGAL::IO::read_PLY_with_properties</a>(in, std::back_inserter(points),</div><div class="line">                                         <a class="code" href="group__PkgPointSetProcessing3IOPly.html#ga3a744d1f9a1c46955cf58866286166ff">CGAL::make_ply_point_reader</a>(Point_map()),</div><div class="line">                                         std::make_pair(Intensity_map(), CGAL::PLY_property&lt;int&gt;(<span class="stringliteral">"intensity"</span>)),</div><div class="line">                                         std::make_tuple(Color_map(),</div><div class="line">                                                         <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Construct__array.html">CGAL::Construct_array</a>(),</div><div class="line">                                                         <a class="code" href="structCGAL_1_1IO_1_1PLY__property.html">CGAL::IO::PLY_property&lt;unsigned char&gt;</a>(<span class="stringliteral">"red"</span>),</div><div class="line">                                                         <a class="code" href="structCGAL_1_1IO_1_1PLY__property.html">CGAL::IO::PLY_property&lt;unsigned char&gt;</a>(<span class="stringliteral">"green"</span>),</div><div class="line">                                                         <a class="code" href="structCGAL_1_1IO_1_1PLY__property.html">CGAL::IO::PLY_property&lt;unsigned char&gt;</a>(<span class="stringliteral">"blue"</span>)),</div><div class="line">                                         <a class="code" href="group__PkgPointSetProcessing3IOPly.html#gaab9a3f1eba6de91187b82af3087afe67">CGAL::IO::make_ply_normal_reader</a>(Normal_map())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Display points read</span></div><div class="line">  <span class="keywordflow">for</span>(std::size_t i = 0; i &lt; points.size (); ++ i)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> Point&amp; p = get&lt;0&gt;(points[i]);</div><div class="line">    <span class="keyword">const</span> Vector&amp; n = get&lt;1&gt;(points[i]);</div><div class="line">    <span class="keyword">const</span> Color&amp; c = get&lt;2&gt;(points[i]);</div><div class="line">    <span class="keywordtype">int</span> I = get&lt;3&gt;(points[i]);</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Point ("</span> &lt;&lt; p</div><div class="line">              &lt;&lt; <span class="stringliteral">") with normal ("</span> &lt;&lt; n</div><div class="line">              &lt;&lt; <span class="stringliteral">"), color ("</span> &lt;&lt; int(c[0]) &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; int(c[1]) &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; int(c[2])</div><div class="line">              &lt;&lt; <span class="stringliteral">") and intensity "</span> &lt;&lt; I &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="Point_set_processing_3Example_las_read"></a>
LAS Reading Example</h3>
<p>The following example shows how to call <code><a class="el" href="group__PkgPointSetProcessing3IOLas.html#ga5187fc18430a5e3c811f75da57a057ad" title="reads user-selected points properties from a .las or .laz stream. ">read_LAS_with_properties()</a></code> to read a point set with points and RGBI colors and stores these attributes in a user-defined container.</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2read_las_example_8cpp-example.html">Point_set_processing_3/read_las_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_las_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> std::array&lt;unsigned short, 4&gt; Color;</div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Point, Color&gt; PointWithColor;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* fname = (argc&gt;1) ? argv[1] : <span class="stringliteral">"data/pig_points.las"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Reads a .las point set file with normal vectors and colors</span></div><div class="line">  std::ifstream in(fname, std::ios_base::binary);</div><div class="line">  std::vector&lt;PointWithColor&gt; points; <span class="comment">// store points</span></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IOLas.html#ga5187fc18430a5e3c811f75da57a057ad">CGAL::IO::read_LAS_with_properties</a>(in, std::back_inserter (points),</div><div class="line">                                         <a class="code" href="group__PkgPointSetProcessing3IOLas.html#gac807a7bbde008f9707a1cf697e3eb64c">CGAL::IO::make_las_point_reader</a>(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointWithColor&gt;</a>()),</div><div class="line">                                         std::make_tuple(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointWithColor&gt;</a>(),</div><div class="line">                                                         <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Construct__array.html">CGAL::Construct_array</a>(),</div><div class="line">                                                         CGAL::IO::LAS_property::R(),</div><div class="line">                                                         CGAL::IO::LAS_property::G(),</div><div class="line">                                                         CGAL::IO::LAS_property::B(),</div><div class="line">                                                         CGAL::IO::LAS_property::I())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(std::size_t i = 0; i &lt; points.size(); ++ i)</div><div class="line">    std::cout &lt;&lt; points[i].first &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/index.html#IOstreamPointSetIO">Point Set IO</a></dd></dl>
<h1><a class="anchor" id="Point_set_processing_3Spacing"></a>
Average Spacing</h1>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga8b330397a3fb68176c851fd7d214b513" title="Computes average spacing from k nearest neighbors. ">compute_average_spacing()</a></code> computes the average spacing of all input points to their <code>k</code> nearest neighbor points, <code>k</code> being specified by the user. As it provides an order of a point set density, this function is used downstream the surface reconstruction pipeline to automatically determine some parameters such as output mesh sizing for surface reconstruction.</p>
<h2><a class="anchor" id="Point_set_processing_3Example_average_spacing"></a>
Example</h2>
<p>The following example reads a point set in the <code>xyz</code> format and computes the average spacing. <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classIndex.html">Index</a>, position and color are stored in a tuple and accessed through property maps. <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2average_spacing_example_8cpp-example.html">Point_set_processing_3/average_spacing_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/compute_average_spacing.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/tuple/tuple.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"></div><div class="line"><span class="comment">// Data type := index, followed by the point, followed by three integers that</span></div><div class="line"><span class="comment">// define the Red Green Blue color of the point.</span></div><div class="line"><span class="keyword">typedef</span> boost::tuple&lt;int, Point, int, int, int&gt; IndexedPointWithColorTuple;</div><div class="line"></div><div class="line"><span class="comment">// Concurrency</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a> Concurrency_tag;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname = (argc&gt;1)?argv[1]:<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/sphere_20k.xyz"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Reads a file in points.</span></div><div class="line">  <span class="comment">// As the point is the second element of the tuple (that is with index 1)</span></div><div class="line">  <span class="comment">// we use a property map that accesses the 1st element of the tuple.</span></div><div class="line"></div><div class="line">  std::vector&lt;IndexedPointWithColorTuple&gt; points;</div><div class="line">  <span class="keywordflow">if</span> (!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname, std::back_inserter(points),</div><div class="line">                             CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;1, IndexedPointWithColorTuple&gt;</a>())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Initialize index and RGB color fields in tuple.</span></div><div class="line">  <span class="comment">// As the index and RGB color are respectively the first and third-fifth elements</span></div><div class="line">  <span class="comment">// of the tuple we use a get function from the property map that accesses the 0</span></div><div class="line">  <span class="comment">// and 2-4th elements of the tuple.</span></div><div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; points.size(); i++)</div><div class="line">  {</div><div class="line">    points[i].get&lt;0&gt;() = i; <span class="comment">// set index value of tuple to i</span></div><div class="line"></div><div class="line">    points[i].get&lt;2&gt;() = 0; <span class="comment">// set RGB color to black</span></div><div class="line">    points[i].get&lt;3&gt;() = 0;</div><div class="line">    points[i].get&lt;4&gt;() = 0;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Computes average spacing.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nb_neighbors = 6; <span class="comment">// 1 ring</span></div><div class="line">  FT average_spacing = CGAL::compute_average_spacing&lt;Concurrency_tag&gt;(</div><div class="line">                         points, nb_neighbors,</div><div class="line">                         CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;1,IndexedPointWithColorTuple&gt;</a>()));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Average spacing: "</span> &lt;&lt; average_spacing &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>Note that other functions such as centroid or bounding volumes are found in other CGAL components:</p>
<ul>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__centroid__grp.html#gacc395064255dfefdb1420309db234210">centroid()</a></code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Principal_component_analysis.tag:../Principal_component_analysis/" href="../Principal_component_analysis/group__PkgPrincipalComponentAnalysisDbb.html#ga7674a40dcf2ee64bebc89d97bf801c1d">bounding_box()</a></code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Bounding_volumes.tag:../Bounding_volumes/" href="../Bounding_volumes/classCGAL_1_1Min__sphere__of__spheres__d.html">Min_sphere_of_spheres_d</a>&lt;Traits&gt;</code></li>
</ul>
<h1><a class="anchor" id="Point_set_processing_3Scale"></a>
Automatic Scale Estimation</h1>
<p>Point sets are often used to sample objects with a higher dimension, typically a curve in 2D or a surface in 3D. In such cases, finding the scale of the object is crucial, that is to say finding the minimal number of points (or the minimal local range) such that the subset of points has the appearance of a curve in 2D or a surface in 3D <a class="el" href="citelist.html#CITEREF_cgal:gcsa-nasr-13">[2]</a>.</p>
<p>CGAL provides two functions that automatically estimate the scale of a 2D point set sampling a curve or a 3D point set sampling a surface:</p>
<ul>
<li><code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga8c6af1df54e336bd0b9a2de6b909bccf" title="Estimates the global scale in a K nearest neighbors sense. ">estimate_global_k_neighbor_scale()</a></code></li>
<li><code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga28fe6443638647be0874b283085eb2cd" title="Estimates the global scale in a range sense. ">estimate_global_range_scale()</a></code></li>
</ul>
<p>Functions such as <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga7757ef9b3900e42fde26f5a0ac56e20f" title="Merges points which belong to the same cell of a grid of cell size = epsilon. ">grid_simplify_point_set()</a></code> require a range scale while <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga078e25209373cab0e1f3524202489771" title="Estimates normal directions of the range of points using jet fitting on the nearest neighbors...">jet_estimate_normals()</a></code>, <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga50c708584a8219847ce04f636dcad4b3" title="Removes outliers: ">remove_outliers()</a></code> or <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gaab0fd78ef3e46c4256e9a1145a9d118e" title="Estimates normal directions of the range of points using the Voronoi Covariance Measure with a radius...">vcm_estimate_normals()</a></code> are examples of functions that accepts both a K neighbor scale or a range scale.</p>
<p>In some specific cases, the scale of a point set might not be homogeneous (for example if the point set contains variable noise). CGAL also provides two functions that automatically estimate the scales of a point set at a set of user-defined query points:</p>
<ul>
<li><code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga6e2493a424482f07d766f12fedefedd0" title="Estimates the local scale in a K nearest neighbors sense on a set of user-defined query points...">estimate_local_k_neighbor_scales()</a></code></li>
<li><code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gaf45220685eff6649d29f600eb66fb6c1" title="Estimates the local scale in a range sense on a set of user-defined query points. ...">estimate_local_range_scales()</a></code></li>
</ul>
<p>The 4 functions presented here work both with 2D points and 3D points and they shouldn't be used if the point sets do not sample a curve in 2D or a surface in 3D.</p>
<h2><a class="anchor" id="Point_set_processing_3Example_scale_estimation_global"></a>
Global Scale Example</h2>
<p>The following example reads a 3D point set in the <code>xyz</code> format and:</p>
<ul>
<li>Estimates the K neighbor global scale</li>
<li>Uses it to smooth the point set</li>
<li>Estimates the range global scale</li>
<li>Uses it to simplify the point set</li>
</ul>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2scale_estimation_example_8cpp-example.html">Point_set_processing_3/scale_estimation_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/estimate_scale.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/jet_smooth_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/grid_simplify_point_set.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Timer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Memory_sizer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Concurrency</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a> Concurrency_tag;</div><div class="line"></div><div class="line"><span class="comment">// Types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point_3;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname = (argc&gt;1)?argv[1]:<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/sphere_20k.xyz"</span>);</div><div class="line"></div><div class="line">  CGAL::Timer task_timer;</div><div class="line"></div><div class="line">  <span class="comment">// read input</span></div><div class="line">  std::vector&lt;Point_3&gt; points;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname, std::back_inserter(points)))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: can't read input file"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// estimate k scale</span></div><div class="line">  task_timer.start();</div><div class="line">  std::size_t k_scale = <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga8c6af1df54e336bd0b9a2de6b909bccf">CGAL::estimate_global_k_neighbor_scale</a> (points);</div><div class="line">  task_timer.stop();</div><div class="line"></div><div class="line">  <span class="comment">// Example: use estimated k as scale for jet smoothing</span></div><div class="line">  CGAL::jet_smooth_point_set&lt;Concurrency_tag&gt;(points, <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(k_scale));</div><div class="line"></div><div class="line">  <span class="comment">// estimate range scale</span></div><div class="line">  task_timer.start();</div><div class="line">  FT range_scale = <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga28fe6443638647be0874b283085eb2cd">CGAL::estimate_global_range_scale</a> (points);</div><div class="line">  task_timer.stop();</div><div class="line"></div><div class="line">  <span class="comment">// Example: use estimated range for grid simplification</span></div><div class="line">  points.erase(<a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga7757ef9b3900e42fde26f5a0ac56e20f">CGAL::grid_simplify_point_set</a>(points, range_scale), points.end());</div><div class="line"></div><div class="line">  <span class="comment">// print some information on runtime</span></div><div class="line">  std::size_t memory = CGAL::Memory_sizer().virtual_size();</div><div class="line">  <span class="keywordtype">double</span> time = task_timer.time();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Scales computed in "</span> &lt;&lt; time &lt;&lt; <span class="stringliteral">" second(s) using "</span></div><div class="line">            &lt;&lt; (memory&gt;&gt;20) &lt;&lt; <span class="stringliteral">" MiB of memory:"</span> &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">" * Global K scale: "</span> &lt;&lt; k_scale &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">" * Global range scale: "</span> &lt;&lt; range_scale &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h2><a class="anchor" id="Point_set_processing_3Example_scale_estimation_local"></a>
Local Scales Example</h2>
<p>This second example generates a 2D point set sampling a circle with variable noise. It then estimates the scale at 3 different query points in the domain.</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2scale_estimation_2d_example_8cpp-example.html">Point_set_processing_3/scale_estimation_2d_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/estimate_scale.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Random.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a> Point_2;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span>, <span class="keywordtype">char</span>**)</div><div class="line">{</div><div class="line">  std::vector&lt;Point_2&gt; samples;</div><div class="line">  samples.reserve (100000);</div><div class="line"></div><div class="line">  <span class="comment">// Generate circle with gradually variable noise</span></div><div class="line">  <span class="comment">//  - noise-free for points with x close to (-1)</span></div><div class="line">  <span class="comment">//  - noisy for points with x close to (+1)</span></div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; 100000; ++ i)</div><div class="line">    {</div><div class="line">      FT theta = CGAL::get_default_random().get_double(0, 2. * CGAL_PI);</div><div class="line">      FT noise = 0.5 * (std::cos(theta) + 1.) * CGAL::get_default_random().get_double(0., 0.2);</div><div class="line">      <span class="keywordtype">int</span> mult = (CGAL::get_default_random().get_bool() ? 1 : -1);</div><div class="line">      samples.push_back (Point_2 (std::cos(theta) * (1. + mult * noise * noise),</div><div class="line">                                  std::sin(theta) * (1. + mult * noise * noise)));</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="comment">// Search for local scales on 3 different locations</span></div><div class="line">  std::vector&lt;Point_2&gt; queries;</div><div class="line">  queries.reserve (3);</div><div class="line">  queries.push_back (Point_2 (-1., 0.));</div><div class="line">  queries.push_back (Point_2 (0., 1.));</div><div class="line">  queries.push_back (Point_2 (1., 0.));</div><div class="line"></div><div class="line">  std::vector&lt;std::size_t&gt; k_scales;</div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga6e2493a424482f07d766f12fedefedd0">CGAL::estimate_local_k_neighbor_scales</a> (samples,</div><div class="line">                                          queries,</div><div class="line">                                          std::back_inserter (k_scales));</div><div class="line"></div><div class="line">  <span class="comment">// Display results</span></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"K-Scales found:"</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">" - On noise-free region: "</span> &lt;&lt; k_scales[0] &lt;&lt; std::endl <span class="comment">// Should be small</span></div><div class="line">            &lt;&lt; <span class="stringliteral">" - On moderately noisy region: "</span> &lt;&lt; k_scales[1] &lt;&lt; std::endl <span class="comment">// Should be higher</span></div><div class="line">            &lt;&lt; <span class="stringliteral">" - On very noisy region: "</span> &lt;&lt; k_scales[2] &lt;&lt; std::endl; <span class="comment">// Should be even higher</span></div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h1><a class="anchor" id="Point_set_processing_3Registration"></a>
Registration</h1>
<p>CGAL provides two functions as wrapper for the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartyOpenGR">OpenGR</a> library <a class="el" href="citelist.html#CITEREF_cgal:m-ogr-17">[7]</a>, and two functions as wrapper for the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartylibpointmatcher">PointMatcher</a> library :</p>
<ul>
<li><code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga1a077db2cedb624e4b4b0ed492598db0" title="Computes the registration of point_set_2 with respect to point_set_1 and returns the corresponding af...">CGAL::OpenGR::compute_registration_transformation()</a></code> computes the registration of one point set w.r.t. another in the form of a <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Aff__transformation__3.html">CGAL::Aff_transformation_3</a></code> object, using the Super4PCS algorithm <a class="el" href="citelist.html#CITEREF_cgal:mam-sffgp-14">[8]</a>;</li>
<li><code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga2d2e21a8a49472a5ed1254f42978608e" title="Computes the registration of point_set_2 with respect to point_set_1 and applies it. ">CGAL::OpenGR::register_point_sets()</a></code> computes the registration of one point set w.r.t. another and directly aligns it to it;</li>
<li><code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga365997b9b06c6576452ec6493b743f52" title="Computes the registration of point_set_2 with respect to point_set_1 and returns the corresponding af...">CGAL::pointmatcher::compute_registration_transformation()</a></code> computes the registration of one point set w.r.t. another in the form of a <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Aff__transformation__3.html">CGAL::Aff_transformation_3</a></code> object, using the ICP (Iterative Closest Point) algorithm;</li>
<li><code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gaa849870cbc74cee3f2f536c70aadf976" title="Computes the registration of point_set_2 with respect to point_set_1 and applies it. ">CGAL::pointmatcher::register_point_sets()</a></code> computes the registration of one point set w.r.t. another and directly aligns it to it.</li>
</ul>
<h2><a class="anchor" id="Point_set_processing_3Examples_registration_OpenGR"></a>
OpenGR Example</h2>
<p>The following example reads two point sets and aligns them using the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartyOpenGR">OpenGR</a> library, using the Super4PCS algorithm: <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2registration_with_OpenGR_8cpp-example.html">Point_set_processing_3/registration_with_OpenGR.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/OpenGR/compute_registration_transformation.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/OpenGR/register_point_sets.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> K;</div><div class="line"><span class="keyword">typedef</span> K::Point_3 Point_3;</div><div class="line"><span class="keyword">typedef</span> K::Vector_3 Vector_3;</div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Point_3, Vector_3&gt; Pwn;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Pwn&gt;</a> Point_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;Pwn&gt;</a> Normal_map;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>params = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL_1_1parameters.html">CGAL::parameters</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname1 = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/hippo1.ply"</span>);</div><div class="line">  <span class="keyword">const</span> std::string fname2 = (argc&gt;2) ? argv[2] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/hippo2.ply"</span>);</div><div class="line"></div><div class="line">  std::vector&lt;Pwn&gt; pwns1, pwns2;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname1, std::back_inserter(pwns1),</div><div class="line">                            CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Pwn&gt;</a>())</div><div class="line">                                             .normal_map(Normal_map())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname1 &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname2, std::back_inserter(pwns2),</div><div class="line">                            CGAL::parameters::point_map(Point_map())</div><div class="line">                                             .normal_map(Normal_map())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname2 &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// EITHER call the registration method Super4PCS from OpenGR to get the transformation to apply to pwns2</span></div><div class="line">  <span class="comment">// std::pair&lt;K::Aff_transformation_3, double&gt; res =</span></div><div class="line">    <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga1a077db2cedb624e4b4b0ed492598db0">CGAL::OpenGR::compute_registration_transformation</a>(pwns1, pwns2,</div><div class="line">                                                      params::point_map(Point_map())</div><div class="line">                                                             .normal_map(Normal_map())</div><div class="line">                                                             .number_of_samples(200)</div><div class="line">                                                             .maximum_running_time(60)</div><div class="line">                                                             .accuracy(0.01),</div><div class="line">                                                      params::point_map(Point_map())</div><div class="line">                                                             .normal_map(Normal_map()));</div><div class="line"></div><div class="line">  <span class="comment">// OR call the registration method Super4PCS from OpenGR and apply the transformation to pwn2</span></div><div class="line">  <span class="keywordtype">double</span> score =</div><div class="line">    <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga2d2e21a8a49472a5ed1254f42978608e">CGAL::OpenGR::register_point_sets</a>(pwns1, pwns2,</div><div class="line">                                      params::point_map(Point_map())</div><div class="line">                                             .normal_map(Normal_map())</div><div class="line">                                             .number_of_samples(200)</div><div class="line">                                             .maximum_running_time(60)</div><div class="line">                                             .accuracy(0.01),</div><div class="line">                                      params::point_map(Point_map())</div><div class="line">                                             .normal_map(Normal_map()));</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga5822feba4449f0492363611620b877c0">CGAL::IO::write_points</a>(<span class="stringliteral">"pwns2_aligned.ply"</span>, pwns2,</div><div class="line">                             CGAL::parameters::point_map(Point_map())</div><div class="line">                                              .normal_map(Normal_map())</div><div class="line">                                              .stream_precision(17)))</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Registration score: "</span> &lt;&lt; score &lt;&lt; <span class="stringliteral">".\n"</span></div><div class="line">            &lt;&lt; <span class="stringliteral">"Transformed version of "</span> &lt;&lt; fname2</div><div class="line">            &lt;&lt; <span class="stringliteral">" written to pwn2_aligned.ply.\n"</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><p><a class="el" href="index.html#fig__Point_set_processing_3tableRegistrationRegistration_visualization_table">Figure 80.4</a> demonstrates visualization of a scan data before and after different registration methods are applied, including the OpenGR registration method. To obtain the results for OpenGR registration in the visualization table, above-mentioned example was used.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_OpenGR_parameter_number_of_samples"></a>
Parameter: number_of_samples</h3>
<p>Input clouds are sub-sampled prior exploration, to ensure fast computations. Super4PCS has a linear complexity w.r.t. the number of input samples, allowing to use larger values than 4PCS. Simple geometry with large overlap can be matched with only 200 samples. However, with Super4PCS, smaller details can be used during the process by using up to thousands of points. There is no theoretical limit to this parameter; however, using too large values leads to very a large congruent set, which requires more time and memory to be explored.</p>
<p>Using a large number of samples is recommended when:</p>
<ul>
<li>geometrical details are required to perform the matching, for instance to disambiguate between several similar configurations,</li>
<li>the clouds have a very low overlap: using a too sparse sampling can result in an empty overlapping area, causing the algorithm to fail,</li>
<li>the clouds are very noisy, and require a dense sampling.</li>
</ul>
<p>Note that Super4PCS is a global registration algorithm, which finds a good approximate of the rigid transformation aligning two clouds. Increasing the number of samples in order to get a fine registration is not optimal: it is usually faster to use fewer samples, and refine the transformation using a local algorithm, like the ICP, or its variant SparseICP.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_OpenGR_parameter_accuracy"></a>
Parameter: accuracy</h3>
<p>This parameter controls the registration accuracy: setting a small value means that the two clouds need to be very close to be considered as well aligned. It is expressed in scene units.</p>
<p>A simple way to understand its impact is to consider the computation of the Largest Common Pointset (LCP), the metric used to verify how aligned the clouds are. For each transformation matrix produced by Super4PCS, <a class="el" href="namespaceCGAL_1_1OpenGR.html">OpenGR</a> computes the LCP measure by considering a shell around the reference cloud, and count the percentage of points of the target cloud lying in the shell. The thickness of the shell is defined by the parameter delta (accuracy).</p>
<p>Using too wide values will slow down the algorithm by increasing the size of the congruent set, while using to small values prevents to find a solution. This parameter impacts other steps of the algorithm, see the paper <a class="el" href="citelist.html#CITEREF_cgal:mam-sffgp-14">[8]</a> for more details.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_OpenGR_parameter_normal"></a>
Parameter: maximum normal deviation</h3>
<p>This parameter sets an angle threshold above which two pairs of points are discarded as candidates for matching. It is expressed in degrees.</p>
<p>The default value is 90° (no filtering). Decreasing this value allows to decrease the computation time by being more selective on candidates. Using too small values might result in ignoring candidates that should indeed have been matched and may thus result in a quality decrease.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_OpenGR_parameter_overlap"></a>
Parameter: overlap</h3>
<p>Ratio of expected overlap between the two point sets: it is ranging between 0 (no overlap) to 1 (100% overlap).</p>
<p>The overlap parameter controls the size of the basis used for registration, as shown below:</p>
<p><a class="anchor" id="fig__Point_set_processing_3figOpenGR_parameter_overlap"></a></p><div class="image">
<img src="super4PCS_overlap.png" alt="super4PCS_overlap.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figOpenGR_parameter_overlap">Figure 80.3</a> The effect of varying overlap parameter on the size of the basis used for registration. The overlap is smaller for left (a) than right (b).  </div> <br /> 
<p>Usually, the larger the overlap, the faster the algorithm. When the overlap is unknown, a simple way to set this parameter is to start from 100% overlap, and decrease the value until obtaining a good result. Using too small values will slow down the algorithm, and reduce the accuracy of the result.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_OpenGR_parameter_maximum_running_time"></a>
Parameter: maximum_running_time</h3>
<p>Maximum number of seconds after which the algorithm stops. Super4PCS explores the transformation space to align the two input clouds. Since the exploration is performed randomly, it is recommended to use a large time value to explore the whole space.</p>
<h2><a class="anchor" id="Point_set_processing_3Examples_registration_PointMatcher"></a>
PointMatcher Example</h2>
<p>The following example reads two point sets and aligns them using the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartylibpointmatcher">PointMatcher</a> library, using the ICP algorithm. It also shows how to customize ICP algorithm by using possible configurations: <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2registration_with_pointmatcher_8cpp-example.html">Point_set_processing_3/registration_with_pointmatcher.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Aff_transformation_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/aff_transformation_tags.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/pointmatcher/compute_registration_transformation.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/pointmatcher/register_point_sets.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> K;</div><div class="line"><span class="keyword">typedef</span> K::Point_3 Point_3;</div><div class="line"><span class="keyword">typedef</span> K::Vector_3 Vector_3;</div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Point_3, Vector_3&gt; Pwn;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Pwn&gt;</a> Point_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;Pwn&gt;</a> Normal_map;</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Weight_map</div><div class="line">{</div><div class="line">  <span class="keyword">typedef</span> Pwn key_type;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> K::FT value_type;</div><div class="line">  <span class="keyword">typedef</span> value_type reference;</div><div class="line">  <span class="keyword">typedef</span> boost::readable_property_map_tag category;</div><div class="line"></div><div class="line">  <span class="keyword">typedef</span> Weight_map Self;</div><div class="line">  <span class="keyword">friend</span> reference <span class="keyword">get</span>(<span class="keyword">const</span> Self&amp;, <span class="keyword">const</span> key_type&amp;) { <span class="keywordflow">return</span> value_type(1); }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>params = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL_1_1parameters.html">CGAL::parameters</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname1 = (argc&gt;1)?argv[1]:<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/hippo1.ply"</span>);</div><div class="line">  <span class="keyword">const</span> std::string fname2 = (argc&gt;2)?argv[2]:<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/hippo2.ply"</span>);</div><div class="line"></div><div class="line">  std::vector&lt;Pwn&gt; pwns1, pwns2;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname1, std::back_inserter(pwns1),</div><div class="line">                            CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Pwn&gt;</a>())</div><div class="line">                                             .normal_map(Normal_map())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname1 &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname2, std::back_inserter(pwns2),</div><div class="line">                            CGAL::parameters::point_map(Point_map())</div><div class="line">                                             .normal_map(Normal_map())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname2 &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="comment">// Prepare ICP config</span></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="keyword">using</span> <a class="code" href="structCGAL_1_1pointmatcher_1_1ICP__config.html">CGAL::pointmatcher::ICP_config</a>;</div><div class="line"></div><div class="line">  <span class="comment">// Possible config modules/components: https://libpointmatcher.readthedocs.io/en/latest/Configuration/#configuration-of-an-icp-chain</span></div><div class="line">  <span class="comment">// See documentation of optional named parameters for CGAL PM ICP configuration / pointmatcher config module mapping</span></div><div class="line"></div><div class="line">  <span class="comment">// Prepare point set 1 filters (PM::ReferenceDataPointsFilters)</span></div><div class="line">  std::vector&lt;ICP_config&gt; point_set_1_filters;</div><div class="line">  point_set_1_filters.push_back( ICP_config { <span class="comment">/*.name=*/</span><span class="stringliteral">"MinDistDataPointsFilter"</span>       , <span class="comment">/*.params=*/</span>{ {<span class="stringliteral">"minDist"</span>, <span class="stringliteral">"0.5"</span> }}  } );</div><div class="line">  point_set_1_filters.push_back( ICP_config { <span class="comment">/*.name=*/</span><span class="stringliteral">"RandomSamplingDataPointsFilter"</span>, <span class="comment">/*.params=*/</span>{ {<span class="stringliteral">"prob"</span>   , <span class="stringliteral">"0.05"</span>}}  } );</div><div class="line"></div><div class="line">  <span class="comment">// Prepare point set 2 filters (PM::ReadingDataPointsFilters)</span></div><div class="line">  std::vector&lt;ICP_config&gt; point_set_2_filters;</div><div class="line">  point_set_2_filters.push_back( ICP_config { <span class="comment">/*.name=*/</span><span class="stringliteral">"MinDistDataPointsFilter"</span>       , <span class="comment">/*.params=*/</span>{ {<span class="stringliteral">"minDist"</span>, <span class="stringliteral">"0.5"</span> }}  } );</div><div class="line">  point_set_2_filters.push_back( ICP_config { <span class="comment">/*.name=*/</span><span class="stringliteral">"RandomSamplingDataPointsFilter"</span>, <span class="comment">/*.params=*/</span>{ {<span class="stringliteral">"prob"</span>   , <span class="stringliteral">"0.05"</span>}}  } );</div><div class="line"></div><div class="line">  <span class="comment">// Prepare matcher function</span></div><div class="line">  ICP_config matcher { <span class="comment">/*.name=*/</span><span class="stringliteral">"KDTreeMatcher"</span>, <span class="comment">/*.params=*/</span>{ {<span class="stringliteral">"knn"</span>, <span class="stringliteral">"1"</span>}, {<span class="stringliteral">"epsilon"</span>, <span class="stringliteral">"3.16"</span>} } };</div><div class="line"></div><div class="line">  <span class="comment">// Prepare outlier filters</span></div><div class="line">  <span class="comment">// NOTE: `GenericDescriptorOutlierFilter` supports only one `descName` that is `weights`!</span></div><div class="line">  std::vector&lt;ICP_config&gt; outlier_filters;</div><div class="line">  outlier_filters.push_back( ICP_config { <span class="comment">/*.name=*/</span><span class="stringliteral">"TrimmedDistOutlierFilter"</span>, <span class="comment">/*.params=*/</span>{ {<span class="stringliteral">"ratio"</span>, <span class="stringliteral">"0.75"</span> }}  } );</div><div class="line">  outlier_filters.push_back( ICP_config { <span class="comment">/*.name=*/</span><span class="stringliteral">"GenericDescriptorOutlierFilter"</span>, <span class="comment">/*.params=*/</span>{ {<span class="stringliteral">"descName"</span>, <span class="stringliteral">"weights"</span> }}  } );</div><div class="line"></div><div class="line">  <span class="comment">// Prepare error minimizer</span></div><div class="line">  ICP_config error_minimizer { <span class="comment">/*.name=*/</span><span class="stringliteral">"PointToPointErrorMinimizer"</span>, <span class="comment">/*.params=*/</span>{ } };</div><div class="line"></div><div class="line">  <span class="comment">// Prepare transformation checker</span></div><div class="line">  std::vector&lt;ICP_config&gt; transformation_checkers;</div><div class="line">  transformation_checkers.push_back( ICP_config { <span class="comment">/*.name=*/</span><span class="stringliteral">"CounterTransformationChecker"</span>, <span class="comment">/*.params=*/</span>{ {<span class="stringliteral">"maxIterationCount"</span>, <span class="stringliteral">"150"</span> }}  } );</div><div class="line">  transformation_checkers.push_back( ICP_config { <span class="comment">/*.name=*/</span><span class="stringliteral">"DifferentialTransformationChecker"</span>, <span class="comment">/*.params=*/</span>{ {<span class="stringliteral">"minDiffRotErr"</span>  , <span class="stringliteral">"0.001"</span> },</div><div class="line">                                                                                                       {<span class="stringliteral">"minDiffTransErr"</span>, <span class="stringliteral">"0.01"</span>  },</div><div class="line">                                                                                                       {<span class="stringliteral">"smoothLength"</span>   , <span class="stringliteral">"4"</span>     } }</div><div class="line">                                                } );</div><div class="line">  <span class="comment">// Prepare inspector</span></div><div class="line">  ICP_config inspector { <span class="comment">/*.name=*/</span><span class="stringliteral">"NullInspector"</span>, <span class="comment">/*.params=*/</span>{ } };</div><div class="line"></div><div class="line">  <span class="comment">// Prepare logger</span></div><div class="line">  ICP_config logger { <span class="comment">/*.name=*/</span><span class="stringliteral">"FileLogger"</span>, <span class="comment">/*.params=*/</span>{ } };</div><div class="line"></div><div class="line">  <span class="keyword">const</span> K::Aff_transformation_3 identity_transform = K::Aff_transformation_3(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Identity__transformation.html">CGAL::Identity_transformation</a>());</div><div class="line"></div><div class="line">  <span class="comment">// EITHER call the ICP registration method pointmatcher to get the transformation to apply to pwns2</span></div><div class="line">  std::pair&lt;K::Aff_transformation_3, bool&gt; res =</div><div class="line">    <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga365997b9b06c6576452ec6493b743f52">CGAL::pointmatcher::compute_registration_transformation</a></div><div class="line">      (pwns1, pwns2,</div><div class="line">       params::point_map(Point_map()).normal_map(Normal_map()).scalar_map(Weight_map())</div><div class="line">                                     .point_set_filters(point_set_1_filters)</div><div class="line">                                     .matcher(matcher)</div><div class="line">                                     .outlier_filters(outlier_filters)</div><div class="line">                                     .error_minimizer(error_minimizer)</div><div class="line">                                     .transformation_checkers(transformation_checkers)</div><div class="line">                                     .inspector(inspector)</div><div class="line">                                     .logger(logger),</div><div class="line">       params::point_map(Point_map()).normal_map(Normal_map()).scalar_map(Weight_map())</div><div class="line">                                     .point_set_filters(point_set_2_filters)</div><div class="line">                                     .transformation(identity_transform) <span class="comment">/* initial transform for pwns2.</span></div><div class="line"><span class="comment">                                                                          * default value is already identity transform.</span></div><div class="line"><span class="comment">                                                                          * a proper initial transform could be given, for example,</span></div><div class="line"><span class="comment">                                                                          * a transform returned from a coarse registration algorithm.</span></div><div class="line"><span class="comment">                                                                          * */</span></div><div class="line">       );</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> converged = <span class="keyword">false</span>;</div><div class="line">  <span class="keywordflow">do</span></div><div class="line">  {</div><div class="line">    <span class="comment">// OR call the ICP registration method from pointmatcher and apply the transformation to pwn2</span></div><div class="line">    converged =</div><div class="line">      <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#gaa849870cbc74cee3f2f536c70aadf976">CGAL::pointmatcher::register_point_sets</a></div><div class="line">      (pwns1, pwns2,</div><div class="line">       params::point_map(Point_map()).normal_map(Normal_map())</div><div class="line">       .point_set_filters(point_set_1_filters)</div><div class="line">       .matcher(matcher)</div><div class="line">       .outlier_filters(outlier_filters)</div><div class="line">       .error_minimizer(error_minimizer)</div><div class="line">       .transformation_checkers(transformation_checkers)</div><div class="line">       .inspector(inspector)</div><div class="line">       .logger(logger),</div><div class="line">       params::point_map(Point_map()).normal_map(Normal_map())</div><div class="line">       .point_set_filters(point_set_2_filters)</div><div class="line">       .transformation(res.first) <span class="comment">/* pass the above computed transformation as initial transformation.</span></div><div class="line"><span class="comment">                                   * as a result, the registration will require less iterations to converge.</span></div><div class="line"><span class="comment">                                   * */</span></div><div class="line">        );</div><div class="line"></div><div class="line">    <span class="comment">// Algorithm may randomly not converge, repeat until it does</span></div><div class="line">    <span class="keywordflow">if</span> (converged)</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">"Success"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">"Did not converge, try again"</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">while</span> (!converged);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga5822feba4449f0492363611620b877c0">CGAL::IO::write_points</a>(<span class="stringliteral">"pwns2_aligned.ply"</span>, pwns2,</div><div class="line">                             CGAL::parameters::point_map(Point_map()).normal_map(Normal_map())))</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Transformed version of "</span> &lt;&lt; fname2 &lt;&lt; <span class="stringliteral">" written to pwn2_aligned.ply.\n"</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><p><a class="el" href="index.html#fig__Point_set_processing_3tableRegistrationRegistration_visualization_table">Figure 80.4</a> demonstrates visualization of a scan data before and after different registration methods are applied, including the PointMatcher registration method. To obtain the results for PointMatcher registration in the visualization table, above-mentioned example was used.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_PointMatcher_parameter_point_set_filters"></a>
Parameter: point_set_filters</h3>
<p>The chain of filters to be applied to the point cloud. The point cloud is processed into an intermediate point cloud with the given chain of filters to be used in the alignment procedure. The chain is organized with the forward traversal order of the point set filters range.</p>
<p>The chain of point set filters are applied only once at the beginning of the ICP procedure, i.e., before the first iteration of the ICP algorithm.</p>
<p>The filters can have several purposes, including but not limited to:</p>
<ul>
<li>removal of noisy points which render alignment of point clouds difficult,</li>
<li>removal of redundant points so as to speed up alignment,</li>
<li>addition of descriptive information to the points such as a surface normal vector or the direction from the point to the sensor.</li>
</ul>
<p>In registration, there are two point clouds in consideration, one of which is the reference point cloud while the other one is the point cloud to register. The point set filters corresponds to <code>readingDataPointsFilters</code> configuration module of <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartylibpointmatcher">PointMatcher</a> library while it corresponds to the <code>referenceDataPointsFilters</code> for the other point cloud. The filters should be chosen and set from possible components of those configuration modules.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_PointMatcher_parameter_matcher"></a>
Parameter: matcher</h3>
<p>The method used for matching (linking) the points from to the points in the reference cloud.</p>
<p>Corresponds to <code>matcher</code> configuration module of <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartylibpointmatcher">PointMatcher</a> library. The matcher should be chosen and set from possible components of the <code>matcher</code> configuration module. See <a href="https://libpointmatcher.readthedocs.io/en/latest/Configuration/#configuration-of-an-icp-chain">libpointmatcher documentation</a> for possible configurations.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_PointMatcher_parameter_outlier_filters"></a>
Parameter: outlier_filters</h3>
<p>The chain of filters to be applied to the matched (linked) point clouds after each processing iteration of the ICP algorithm to remove the links which do not correspond to true point correspondences. The outliers are rejected. Points with no link are ignored in the subsequent error minimization step. The chain is organized with the forward traversal order of the outlier filters range.</p>
<p>Corresponds to <code>outlierFilters</code> configuration module of <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartylibpointmatcher">PointMatcher</a> library. The filters should be chosen and set from possible components of the <code>outlierFilters</code> configuration module. See <a href="https://libpointmatcher.readthedocs.io/en/latest/Configuration/#configuration-of-an-icp-chain">libpointmatcher documentation</a> for possible configurations.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_PointMatcher_parameter_error_minimizer"></a>
Parameter: error_minimizer</h3>
<p>The error minimizer that computes a transformation matrix such as to minimize the error between the point sets.</p>
<p>Corresponds to <code>errorMinimizer</code> configuration module of <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartylibpointmatcher">PointMatcher</a> library. The error minimizer should be chosen and set from possible components of the <code>errorMinimizer</code> configuration module. See <a href="https://libpointmatcher.readthedocs.io/en/latest/Configuration/#configuration-of-an-icp-chain">libpointmatcher documentation</a> for possible configurations.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_PointMatcher_parameter_inspector"></a>
Parameter: inspector</h3>
<p>The inspector allows to log data at different steps for analysis. Inspectors typically provide deeper scrutiny than the logger.</p>
<p>Corresponds to <code>inspector</code> configuration module of <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartylibpointmatcher">PointMatcher</a> library. The inspector should be chosen and set from possible components of the <code>inspector</code> configuration module. See <a href="https://libpointmatcher.readthedocs.io/en/latest/Configuration/#configuration-of-an-icp-chain">libpointmatcher documentation</a> for possible configurations.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_PointMatcher_parameter_logger"></a>
Parameter: logger</h3>
<p>The method for logging information regarding the registration process outputted by <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartylibpointmatcher">PointMatcher</a> library. The logs generated by <a class="el" href="namespaceCGAL.html">CGAL</a> library does not get effected by this configuration.</p>
<p>Corresponds to <code>logger</code> configuration module of <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartylibpointmatcher">PointMatcher</a> library. The logger should be chosen and set from possible components of the <code>logger</code> configuration module. See <a href="https://libpointmatcher.readthedocs.io/en/latest/Configuration/#configuration-of-an-icp-chain">libpointmatcher documentation</a> for possible configurations.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_PointMatcher_parameter_transformation"></a>
Parameter: transformation</h3>
<p>The affine transformation that is used as the initial transformation for the reference point cloud.</p>
<h2><a class="anchor" id="Point_set_processing_3Examples_registration_OpenGR_PointMatcher_Pipeline"></a>
OpenGR/PointMatcher Pipeline Example</h2>
<p>The following example reads two point sets and aligns them by using both <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartyOpenGR">OpenGR</a> and <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartylibpointmatcher">PointMatcher</a> libraries, respectively. It depicts a use case where a coarse estimation of a registration transformation is done using the Super4PCS algorithm. Then, a fine registration from this coarse registration using the ICP algorithm. <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2registration_with_opengr_pointmatcher_pipeline_8cpp-example.html">Point_set_processing_3/registration_with_opengr_pointmatcher_pipeline.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Aff_transformation_3.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/pointmatcher/register_point_sets.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/OpenGR/compute_registration_transformation.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> K;</div><div class="line"><span class="keyword">typedef</span> K::Point_3 Point_3;</div><div class="line"><span class="keyword">typedef</span> K::Vector_3 Vector_3;</div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Point_3, Vector_3&gt; Pwn;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Pwn&gt;</a> Point_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;Pwn&gt;</a> Normal_map;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>params = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL_1_1parameters.html">CGAL::parameters</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname1 = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/hippo1.ply"</span>);</div><div class="line">  <span class="keyword">const</span> std::string fname2 = (argc&gt;2) ? argv[2] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/hippo2.ply"</span>);</div><div class="line"></div><div class="line">  std::vector&lt;Pwn&gt; pwns1, pwns2;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname1, std::back_inserter(pwns1),</div><div class="line">                            CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Pwn&gt;</a>())</div><div class="line">                                             .normal_map (Normal_map())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname1 &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname2, std::back_inserter(pwns2),</div><div class="line">                            CGAL::parameters::point_map(Point_map())</div><div class="line">                                             .normal_map(Normal_map())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname2 &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Computing registration transformation using OpenGR Super4PCS.."</span> &lt;&lt; std::endl;</div><div class="line">  <span class="comment">// First, compute registration transformation using OpenGR Super4PCS</span></div><div class="line">  K::Aff_transformation_3 res =</div><div class="line">    std::get&lt;0&gt;( <span class="comment">// get first of pair, which is the transformation</span></div><div class="line">      <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga1a077db2cedb624e4b4b0ed492598db0">CGAL::OpenGR::compute_registration_transformation</a></div><div class="line">        (pwns1, pwns2,</div><div class="line">         params::point_map(Point_map()).normal_map(Normal_map()),</div><div class="line">         params::point_map(Point_map()).normal_map(Normal_map())));</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Computing registration transformation using PointMatcher ICP, "</span></div><div class="line">            &lt;&lt; <span class="stringliteral">"taking transformation computed by OpenGR Super4PCS as initial transformation.."</span> &lt;&lt; std::endl;</div><div class="line">  <span class="comment">// Then, compute registration transformation using PointMatcher ICP, taking transformation computed</span></div><div class="line">  <span class="comment">// by OpenGR as initial transformation, and apply the transformation to pwns2</span></div><div class="line">  <span class="comment">// bool converged =</span></div><div class="line">    <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#gaa849870cbc74cee3f2f536c70aadf976">CGAL::pointmatcher::register_point_sets</a></div><div class="line">      (pwns1, pwns2,</div><div class="line">       params::point_map(Point_map()).normal_map(Normal_map()),</div><div class="line">       params::point_map(Point_map()).normal_map(Normal_map()).transformation(res));</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga5822feba4449f0492363611620b877c0">CGAL::IO::write_points</a>(<span class="stringliteral">"pwns2_aligned.ply"</span>, pwns2,</div><div class="line">                             CGAL::parameters::point_map(Point_map())</div><div class="line">                                              .normal_map(Normal_map())))</div><div class="line">  {</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Transformed version of "</span> &lt;&lt; fname2</div><div class="line">            &lt;&lt; <span class="stringliteral">" written to pwn2_aligned.ply.\n"</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><p><a class="el" href="index.html#fig__Point_set_processing_3tableRegistrationRegistration_visualization_table">Figure 80.4</a> demonstrates visualization of a scan data before and after different registration methods are applied, including the pipeline of OpenGR and PointMatcher registration methods. To obtain the results for the pipeline of OpenGR and PointMatcher registration methods in the visualization table, above-mentioned example was used.</p>
<p><a class="anchor" id="fig__Point_set_processing_3tableRegistrationRegistration_visualization_table"></a></p><table class="doxtable">
<tr>
<th></th><th>Scan 1  </th><th>Scan 1 (possibly transformed, green) and Scan 2 (the reference, red)  </th></tr>
<tr>
<th>Unregistered </th><td><a class="anchor" id="fig__Point_set_processing_3figRegistrationUnregistered_hippo2_view1"></a><div class="image">
<img src="registration_view1_hippo2_unregistered.png" alt="registration_view1_hippo2_unregistered.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figRegistrationUnregistered_hippo2_view1">Figure 80.5</a>  </div> <br />   </td><td><a class="anchor" id="fig__Point_set_processing_3figRegistrationUnregistered_hippo1_hippo2_view1"></a><div class="image">
<img src="registration_view1_hippo1_hippo2_unregistered.png" alt="registration_view1_hippo1_hippo2_unregistered.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figRegistrationUnregistered_hippo1_hippo2_view1">Figure 80.6</a>  </div> <br />    </td></tr>
<tr>
<th>Registered using OpenGR  </th><td><a class="anchor" id="fig__Point_set_processing_3figRegistrationOpenGR_hippo2_view1"></a><div class="image">
<img src="registration_view1_hippo2_opengr.png" alt="registration_view1_hippo2_opengr.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figRegistrationOpenGR_hippo2_view1">Figure 80.7</a>  </div> <br />   </td><td><a class="anchor" id="fig__Point_set_processing_3figRegistrationOpenGR_hippo1_hippo2_view1"></a><div class="image">
<img src="registration_view1_hippo1_hippo2_opengr.png" alt="registration_view1_hippo1_hippo2_opengr.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figRegistrationOpenGR_hippo1_hippo2_view1">Figure 80.8</a>  </div> <br />    </td></tr>
<tr>
<th>Registered using PointMatcher  </th><td><a class="anchor" id="fig__Point_set_processing_3figRegistrationPointMatcher_hippo2_view1"></a><div class="image">
<img src="registration_view1_hippo2_pointmatcher.png" alt="registration_view1_hippo2_pointmatcher.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figRegistrationPointMatcher_hippo2_view1">Figure 80.9</a>  </div> <br />   </td><td><a class="anchor" id="fig__Point_set_processing_3figRegistrationPointMatcher_hippo1_hippo2_view1"></a><div class="image">
<img src="registration_view1_hippo1_hippo2_pointmatcher.png" alt="registration_view1_hippo1_hippo2_pointmatcher.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figRegistrationPointMatcher_hippo1_hippo2_view1">Figure 80.10</a>  </div> <br />    </td></tr>
<tr>
<th>Registered using OpenGR+PointMatcher Pipeline  </th><td><a class="anchor" id="fig__Point_set_processing_3figRegistrationPipeline_hippo2_view1"></a><div class="image">
<img src="registration_view1_hippo2_opengr_pointmatcher_pipeline.png" alt="registration_view1_hippo2_opengr_pointmatcher_pipeline.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figRegistrationPipeline_hippo2_view1">Figure 80.11</a>  </div> <br />   </td><td><a class="anchor" id="fig__Point_set_processing_3figRegistrationPipeline_hippo1_hippo2_view1"></a><div class="image">
<img src="registration_view1_hippo1_hippo2_opengr_pointmatcher_pipeline.png" alt="registration_view1_hippo1_hippo2_opengr_pointmatcher_pipeline.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figRegistrationPipeline_hippo1_hippo2_view1">Figure 80.12</a>  </div> <br />    </td></tr>
</table>
<p> </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3tableRegistrationRegistration_visualization_table">Figure 80.4</a> Visualization of registered hippo scans with different registration methods. Two scans are used: red as the reference, green as the one for which the transformation is computed and applied. To obtain the results, the example code given in <a class="el" href="index.html#Point_set_processing_3Examples_registration_OpenGR">OpenGR Example</a> , <a class="el" href="index.html#Point_set_processing_3Examples_registration_PointMatcher">PointMatcher Example</a> , <a class="el" href="index.html#Point_set_processing_3Examples_registration_OpenGR_PointMatcher_Pipeline">OpenGR/PointMatcher Pipeline Example</a> were applied, respectively. The parameters of the algorithms used to obtain those results are not optimized for the shown scans; therefore, better parameter choice might result in better results in terms of registration accuracy for each algorithm individually.  </div> <br /> 
<h1><a class="anchor" id="Point_set_processing_3Clustering"></a>
Clustering</h1>
<p>If an input point set represents several objects which are spatially separated, a clustering algorithm can be applied to identify connected components on a nearest neighbor graph built using a query sphere of fixed radius centered on each point.</p>
<p>The clustering is stored in a cluster map which associates each input point with the index of the cluster it belongs to: users can then use this map however they find it relevant to their use case, for example segmenting the input point set into one point set per cluster. <a class="el" href="index.html#fig__Point_set_processing_3figclustering">Figure 80.13</a> shows different clustering outputs.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figclustering"></a></p><div class="image">
<img src="clustering.png" alt="clustering.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figclustering">Figure 80.13</a> Point Set Clustering outputs (one color per cluster). Top: input point set and clustering using a neighbor radius of 1.5 (147 clusters extracted). Bottom: clustering with neighbor radius 3.0 (37 clusters extracted), and with neighbor radius 6.0 (5 clusters extracted).  </div> <br /> 
<h2><a class="anchor" id="Point_set_processing_3Example_clustering"></a>
Example</h2>
<p>In the following example, clusters (and adjacencies between them) are computed and stored as colors in a PLY file:</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2clustering_example_8cpp-example.html">Point_set_processing_3/clustering_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3/IO.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/cluster_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/compute_average_spacing.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Random.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> Kernel = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div><div class="line"><span class="keyword">using</span> Point_3 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ae82b7f4be77dd5b8819ebe419e4ae753">Kernel::Point_3</a>;</div><div class="line"><span class="keyword">using</span> Point_set = CGAL::Point_set_3&lt;Point_3&gt;;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="comment">// Read input file</span></div><div class="line">  std::ifstream ifile((argc &gt; 1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/hippo1.ply"</span>), std::ios_base::binary);</div><div class="line">  Point_set points;</div><div class="line">  ifile &gt;&gt; points;</div><div class="line"></div><div class="line">  <span class="comment">// Add a cluster map</span></div><div class="line">  Point_set::Property_map&lt;int&gt; cluster_map = points.add_property_map&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">"cluster"</span>, -1).first;</div><div class="line"></div><div class="line">  <span class="comment">// Compute average spacing</span></div><div class="line">  <span class="keywordtype">double</span> spacing = CGAL::compute_average_spacing&lt;CGAL::Parallel_if_available_tag&gt; (points, 12);</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Spacing = "</span> &lt;&lt; spacing &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Adjacencies stored in vector</span></div><div class="line">  std::vector&lt;std::pair&lt;std::size_t, std::size_t&gt; &gt; adjacencies;</div><div class="line"></div><div class="line">  <span class="comment">// Compute clusters</span></div><div class="line">  CGAL::Real_timer t;</div><div class="line">  t.start();</div><div class="line">  std::size_t nb_clusters</div><div class="line">    = <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga2531a1366bea67edef99e87d6b8819ec">CGAL::cluster_point_set</a>(points, cluster_map,</div><div class="line">                              points.parameters().neighbor_radius(spacing)</div><div class="line">                                                 .adjacencies(std::back_inserter(adjacencies)));</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Found "</span> &lt;&lt; nb_clusters &lt;&lt; <span class="stringliteral">" clusters with "</span> &lt;&lt; adjacencies.size()</div><div class="line">            &lt;&lt; <span class="stringliteral">" adjacencies in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" seconds"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Output a colored PLY file</span></div><div class="line">  Point_set::Property_map&lt;unsigned char&gt; red = points.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"red"</span>, 0).first;</div><div class="line">  Point_set::Property_map&lt;unsigned char&gt; green = points.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"green"</span>, 0).first;</div><div class="line">  Point_set::Property_map&lt;unsigned char&gt; blue = points.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"blue"</span>, 0).first;</div><div class="line">  <span class="keywordflow">for</span>(Point_set::Index idx : points)</div><div class="line">  {</div><div class="line">    <span class="comment">// One color per cluster</span></div><div class="line">    CGAL::Random rand (cluster_map[idx]);</div><div class="line">    red[idx] = rand.get_int(64, 192);</div><div class="line">    green[idx] = rand.get_int(64, 192);</div><div class="line">    blue[idx] = rand.get_int(64, 192);</div><div class="line">  }</div><div class="line"></div><div class="line">  std::ofstream ofile(<span class="stringliteral">"out.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a>(ofile);</div><div class="line">  ofile &lt;&lt; points;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Point_set_processing_3OutlierRemoval"></a>
Outlier Removal</h1>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga50c708584a8219847ce04f636dcad4b3" title="Removes outliers: ">remove_outliers()</a></code> deletes a user-specified fraction of outliers from an input point set. More specifically, it partitions the input points with respect to the average squared distances to their nearest neighbors and deletes the points with largest value, either partitioning with a threshold or removing a fixed percentage. The user can either specify a fixed number of nearest neighbors or a fixed spherical neighborhood radius.</p>
<h2><a class="anchor" id="Point_set_processing_3Example_outlier_removal"></a>
Example</h2>
<p>The following example reads a point set and removes 5% of the points. It uses the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Identity__property__map.html">Identity_property_map</a>&lt;<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__3.html">Point_3</a>&gt;</code> property map (optional as it is the default position property map of all functions in this component.) <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2remove_outliers_example_8cpp-example.html">Point_set_processing_3/remove_outliers_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/compute_average_spacing.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/remove_outliers.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname = (argc&gt;1)?argv[1]:<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/oni.pwn"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Reads a point set file in points[].</span></div><div class="line">  <span class="comment">// The Identity_property_map property map can be omitted here as it is the default value.</span></div><div class="line">  std::vector&lt;Point&gt; points;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname, std::back_inserter(points),</div><div class="line">                            CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map&lt;Point&gt;</a>())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Removes outliers using erase-remove idiom.</span></div><div class="line">  <span class="comment">// The Identity_property_map property map can be omitted here as it is the default value.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_neighbors = 24; <span class="comment">// considers 24 nearest neighbor points</span></div><div class="line"></div><div class="line">  <span class="comment">// Estimate scale of the point set with average spacing</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> average_spacing = CGAL::compute_average_spacing&lt;CGAL::Sequential_tag&gt;(points, nb_neighbors);</div><div class="line"></div><div class="line">  <span class="comment">// FIRST OPTION //</span></div><div class="line">  <span class="comment">// I don't know the ratio of outliers present in the point set</span></div><div class="line">  std::vector&lt;Point&gt;::iterator first_to_remove</div><div class="line">    = CGAL::remove_outliers&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (points,</div><div class="line">     nb_neighbors,</div><div class="line">     CGAL::parameters::threshold_percent (100.). <span class="comment">// No limit on the number of outliers to remove</span></div><div class="line">     threshold_distance (2. * average_spacing)); <span class="comment">// Point with distance above 2*average_spacing are considered outliers</span></div><div class="line"></div><div class="line">  std::cerr &lt;&lt; (100. * std::distance(first_to_remove, points.end()) / static_cast&lt;double&gt;(points.size()))</div><div class="line">            &lt;&lt; <span class="stringliteral">"% of the points are considered outliers when using a distance threshold of "</span></div><div class="line">            &lt;&lt; 2. * average_spacing &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// SECOND OPTION //</span></div><div class="line">  <span class="comment">// I know the ratio of outliers present in the point set</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> removed_percentage = 5.0; <span class="comment">// percentage of points to remove</span></div><div class="line"></div><div class="line">  points.erase(CGAL::remove_outliers&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">               (points,</div><div class="line">                nb_neighbors,</div><div class="line">                CGAL::parameters::threshold_percent(removed_percentage). <span class="comment">// Minimum percentage to remove</span></div><div class="line">                threshold_distance(0.)), <span class="comment">// No distance threshold (can be omitted)</span></div><div class="line">               points.end());</div><div class="line"></div><div class="line">  <span class="comment">// Optional: after erase(), use Scott Meyer's "swap trick" to trim excess capacity</span></div><div class="line">  std::vector&lt;Point&gt;(points).swap(points);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Point_set_processing_3Simplification"></a>
Simplification</h1>
<p>Four simplification functions are devised to reduce an input point set.</p>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga4be2d94f1791d24b8ba0107bc33ad6dc" title="Randomly deletes a user-specified fraction of the input points. ">random_simplify_point_set()</a></code> randomly deletes a user-specified fraction of points from the input point set. This algorithm is the fastest.</p>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga7757ef9b3900e42fde26f5a0ac56e20f" title="Merges points which belong to the same cell of a grid of cell size = epsilon. ">grid_simplify_point_set()</a></code> considers a regular grid covering the bounding box of the input point set, and clusters all points sharing the same cell of the grid by picking as representative one arbitrarily chosen point: representatives may only be retained in cells that have more than a user-defined minimum number of points in order to also filter out low density areas and outliers. This algorithm is still fast, although slower than <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga4be2d94f1791d24b8ba0107bc33ad6dc" title="Randomly deletes a user-specified fraction of the input points. ">random_simplify_point_set()</a></code>.</p>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga3420351b6d3fad079d13f894f42e9d03" title="Recursively split the point set in smaller clusters until the clusters have fewer than size elements ...">hierarchy_simplify_point_set()</a></code> provides an adaptive simplification of the point set through local clusters <a class="el" href="citelist.html#CITEREF_cgal:pgk-esops-02">[10]</a>. The size of the clusters is either directly selected by the user or it automatically adapts to the local variation of the point set.</p>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga79ee6fb524ec53b9b85eb32e7ae56ca8" title="This is an implementation of the Weighted Locally Optimal Projection (WLOP) simplification algorithm...">wlop_simplify_and_regularize_point_set()</a></code> not only simplifies, but also regularizes downsampled points. This is an implementation of the Weighted Locally Optimal Projection (WLOP) algorithm <a class="el" href="citelist.html#CITEREF_wlop-2009">[4]</a>.</p>
<h2><a class="anchor" id="Point_set_processing_3Example_grid_simplification"></a>
Grid Simplification Example</h2>
<p>The following example reads a point set and simplifies it by clustering. To filter out outliers, at least 3 points must lie in a cell so that a point from this cell is kept. <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2grid_simplification_example_8cpp-example.html">Point_set_processing_3/grid_simplification_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/grid_simplify_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/oni.pwn"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Reads a point set file in points[].</span></div><div class="line">  std::vector&lt;Point&gt; points;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname, std::back_inserter(points)))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// simplification by clustering using erase-remove idiom</span></div><div class="line">  <span class="keywordtype">double</span> cell_size = 0.03;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> min_points_per_cell = 3;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> iterator_to_first_to_remove</div><div class="line">    = <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga7757ef9b3900e42fde26f5a0ac56e20f">CGAL::grid_simplify_point_set</a></div><div class="line">    (points, cell_size,</div><div class="line">     CGAL::parameters::min_points_per_cell(min_points_per_cell)); <span class="comment">// optional</span></div><div class="line"></div><div class="line">  points.erase(iterator_to_first_to_remove, points.end());</div><div class="line"></div><div class="line">  <span class="comment">// Optional: after erase(), shrink_to_fit to trim excess capacity</span></div><div class="line">  points.shrink_to_fit();</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="fig__Point_set_processing_3figgrid_simplification"></a></p><div class="image">
<img src="grid_simplification.jpg" alt="grid_simplification.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figgrid_simplification">Figure 80.14</a> Point set simplification through grid-based clustering. Removed points are depicted in red. Notice how low-density areas (in green) are not simplified.  </div> <br /> 
<h2><a class="anchor" id="Point_set_processing_3Example_hierarchy_simplication"></a>
Hierarchy Simplification Example</h2>
<p>The following example reads a point set and produces a set of clusters.</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2hierarchy_simplification_example_8cpp-example.html">Point_set_processing_3/hierarchy_simplification_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/hierarchy_simplify_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Memory_sizer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/oni.pwn"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Reads a point set file in points[].</span></div><div class="line">  std::vector&lt;Point&gt; points;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname, std::back_inserter(points)))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Read "</span> &lt;&lt; points.size () &lt;&lt; <span class="stringliteral">" point(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  CGAL::Timer task_timer; task_timer.start();</div><div class="line"></div><div class="line">  <span class="comment">// simplification by clustering using erase-remove idiom</span></div><div class="line">  points.erase(<a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga3420351b6d3fad079d13f894f42e9d03">CGAL::hierarchy_simplify_point_set</a>(points,</div><div class="line">                                                  CGAL::parameters::size(100)<span class="comment">// Max cluster size</span></div><div class="line">                                                                   .maximum_variation(0.01)), <span class="comment">// Max surface variation</span></div><div class="line">               points.end());</div><div class="line"></div><div class="line">  std::size_t memory = CGAL::Memory_sizer().virtual_size();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; points.size () &lt;&lt; <span class="stringliteral">" point(s) kept, computed in "</span></div><div class="line">            &lt;&lt; task_timer.time() &lt;&lt; <span class="stringliteral">" seconds, "</span></div><div class="line">            &lt;&lt; (memory&gt;&gt;20) &lt;&lt; <span class="stringliteral">" Mib allocated."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3IO.html#ga5822feba4449f0492363611620b877c0">CGAL::IO::write_points</a>(<span class="stringliteral">"out.xyz"</span>, points, CGAL::parameters::stream_precision(17));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h3><a class="anchor" id="Point_set_processing_3Hierarchy_simplification_parameter_size"></a>
Parameter: size</h3>
<p>The hierarchy simplification algorithm recursively split the point set in two until each cluster's size is less than the parameter <code>size</code>.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figHierarchy_simplification_size"></a></p><div class="image">
<img src="hierarchical_clustering_size.jpg" alt="hierarchical_clustering_size.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figHierarchy_simplification_size">Figure 80.15</a> Input point set and hierarchy simplification with different <code>size</code> parameter: \(10\), \(100\) and \(1000\). In the 3 cases, <code>var_max</code> \(=1/3\). </div> <br /> 
<h3><a class="anchor" id="Point_set_processing_3Hierarchy_simplification_parameter_var_max"></a>
Parameter: var_max</h3>
<p>In addition to the size parameter, a variation parameter allows to increase simplification in monotonous regions. For each cluster, a surface variation measure is computed using the sorted eigenvalues of the covariance matrix: </p><p class="formulaDsp">
\[ \sigma(p) = \frac{\lambda_0}{\lambda_0 + \lambda_1 + \lambda_2}. \]
</p>
<p>This function goes from \(0\) if the cluster is coplanar to \(1/3\) if it is fully isotropic. If a cluster's variation is above <code>var_max</code>, it is split. If <code>var_max</code> is equal to \(1/3\), this parameter has no effect and the clustering is regular on the whole point set.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figHierarchical_clustering_var_max"></a></p><div class="image">
<img src="hierarchical_clustering_var_max.jpg" alt="hierarchical_clustering_var_max.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figHierarchical_clustering_var_max">Figure 80.16</a> Input point set and hierarchy simplification with different <code>var_max</code> parameter: \(0.00001\), \(0.001\) and \(0.1\). In the 3 cases, <code>size</code> \(=1000\). </div> <br /> 
<h2><a class="anchor" id="Point_set_processing_3Example_wlop"></a>
WLOP Simplification Example</h2>
<p>The following example reads a point set, simplifies and regularizes it by WLOP.</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2wlop_simplify_and_regularize_point_set_example_8cpp-example.html">Point_set_processing_3/wlop_simplify_and_regularize_point_set_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/wlop_simplify_and_regularize_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"></div><div class="line"><span class="comment">// Concurrency</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a> Concurrency_tag;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string input_filename = (argc&gt;1)?argv[1]:<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/sphere_20k.xyz"</span>);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* output_filename = (argc&gt;2)?argv[2]:<span class="stringliteral">"data/sphere_20k_WLOPED.xyz"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Reads a .xyz point set file in points[]</span></div><div class="line">  std::vector&lt;Point&gt; points;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(input_filename, std::back_inserter(points)))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; input_filename  &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::vector&lt;Point&gt; output;</div><div class="line"></div><div class="line">  <span class="comment">//parameters</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> retain_percentage = 2;   <span class="comment">// percentage of points to retain.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> neighbor_radius = 0.5;   <span class="comment">// neighbors size.</span></div><div class="line"></div><div class="line">  CGAL::wlop_simplify_and_regularize_point_set&lt;Concurrency_tag&gt;</div><div class="line">    (points, std::back_inserter(output),</div><div class="line">     CGAL::parameters::select_percentage(retain_percentage).</div><div class="line">     neighbor_radius (neighbor_radius));</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga5822feba4449f0492363611620b877c0">CGAL::IO::write_points</a>(output_filename, output, CGAL::parameters::stream_precision(17)))</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="fig__Point_set_processing_3figsimplification_comparison"></a></p><div class="image">
<img src="simplification_comparison.jpg" alt="simplification_comparison.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figsimplification_comparison">Figure 80.17</a> Comparison for three simplification methods: Left: Random simplification result. Middle: Grid simplification result. Right: WLOP simplification result.  </div> <br /> 
<h3><a class="anchor" id="Point_set_processing_3WLOP_Parameter"></a>
Parameter: require_uniform_sampling</h3>
<p>Computing density weights for each point is an optional preprocessing. For example, as shown in the following figure, when require_uniform_sampling is set to false, WLOP preserves the intrinsic non-uniform sampling of the original points; if require_uniform_sampling is set to true, WLOP is resilient to non-uniform sampling and generates sample points with more uniform distribution, at the expense of computational time.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figWLOP_parameter_density"></a></p><div class="image">
<img src="WLOP_parameter_density.jpg" alt="WLOP_parameter_density.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figWLOP_parameter_density">Figure 80.18</a> Comparison between with and without density: Left: input. Middle: <code>require_uniform_sampling = false</code>. Right: <code>require_uniform_sampling=true</code>.  </div> <br /> 
<h3><a class="anchor" id="Point_set_processing_3WLOP_parameter_neighborhood_size"></a>
Parameter: neighbor_radius</h3>
<p>Usually, the neighborhood of sample points should include at least two rings of neighboring sample points. Using a small neighborhood size may not be able to generate regularized result, while using big neighborhood size will make the sample points shrink into the interior of the local surface (under-fitting). The function will use a neighborhood size estimation if this parameter value is set to default or smaller that zero.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figWLOP_parameter_neighborhood_size"></a></p><div class="image">
<img src="WLOP_parameter_neighborhood_size.jpg" alt="WLOP_parameter_neighborhood_size.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figWLOP_parameter_neighborhood_size">Figure 80.19</a> Comparison between different sizes of neighbor radius.  </div> <br /> 
<h3><a class="anchor" id="Point_set_processing_3WLOP_parallel_performance"></a>
Parallel Performance</h3>
<p>A parallel version of WLOP is provided and requires the executable to be linked against the <a href="https://github.com/oneapi-src/oneTBB">Intel TBB library</a>. To control the number of threads used, the user may use the tbb::task_scheduler_init class. See the <a href="https://software.intel.com/content/www/us/en/develop/documentation/onetbb-documentation/top.html">TBB documentation</a> for more details. We provide below a speed-up chart generated using the parallel version of the WLOP algorithm. The machine used is a PC running Windows 7 64-bits with a 4-core <a href="#" onclick="location.href='mai'+'lto:'+'i7-'+'47'+'00H'+'Q@'+'2.4'+'0G'+'Hz'; return false;">i7-47<span style="display: none;">.nosp@m.</span>00HQ<span style="display: none;">.nosp@m.</span>@2.40<span style="display: none;">.nosp@m.</span>GHz</a> CPU with 8GB of RAM.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figWLOP_parallel_performance"></a></p><div class="image">
<img src="parallel_WLOP_performance.jpg" alt="parallel_WLOP_performance.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figWLOP_parallel_performance">Figure 80.20</a> Parallel WLOP speed-up, compared to the sequential version of the algorithm.  </div> <br /> 
<h1><a class="anchor" id="Point_set_processing_3Smoothing"></a>
Smoothing</h1>
<p>Two smoothing functions are devised to smooth an input point set.</p>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga96a3738be3b2b9bd1587af78ae10e67a" title="Smoothes the range of points using jet fitting on the nearest neighbors and reprojection onto the jet...">jet_smooth_point_set()</a></code> smooths the input point set by projecting each point onto a smooth parametric surface patch (so-called jet surface) fitted over its nearest neighbors.</p>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga01192a227578fee0c5676ba6a5e88931" title="This function smooths an input point set by iteratively projecting each point onto the implicit surfa...">bilateral_smooth_point_set()</a></code> smooths the input point set by iteratively projecting each point onto the implicit surface patch fitted over its nearest neighbors. Bilateral projection preserves sharp features according to the normal (gradient) information. Normals are thus required as input. For more details, see section 4 of <a class="el" href="citelist.html#CITEREF_ear-2013">[5]</a>.</p>
<p>For both functions, the user can either specify a fixed number of nearest neighbors or a fixed spherical neighborhood radius.</p>
<h2><a class="anchor" id="Point_set_processing_3Example_jet_smoothing"></a>
Jet Smoothing Example</h2>
<p>The following example generates a set of 9 points close to the <code>xy</code> plane and smooths them using 8 nearest neighbors: <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2jet_smoothing_example_8cpp-example.html">Point_set_processing_3/jet_smoothing_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/jet_smooth_point_set.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"></div><div class="line"><span class="comment">// Concurrency</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a> Concurrency_tag;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">  <span class="comment">// generate point set</span></div><div class="line">  std::vector&lt;Point&gt; points;</div><div class="line">  points.push_back(Point( 0.0, 0.0, 0.001));</div><div class="line">  points.push_back(Point(-0.1,-0.1, 0.002));</div><div class="line">  points.push_back(Point(-0.1,-0.2, 0.001));</div><div class="line">  points.push_back(Point(-0.1, 0.1, 0.002));</div><div class="line">  points.push_back(Point( 0.1,-0.1, 0.000));</div><div class="line">  points.push_back(Point( 0.1, 0.2, 0.001));</div><div class="line">  points.push_back(Point( 0.2, 0.0, 0.002));</div><div class="line">  points.push_back(Point( 0.2, 0.1, 0.000));</div><div class="line">  points.push_back(Point( 0.0,-0.1, 0.001));</div><div class="line"></div><div class="line">  <span class="comment">// Smoothing.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nb_neighbors = 8; <span class="comment">// default is 24 for real-life point sets</span></div><div class="line">  CGAL::jet_smooth_point_set&lt;Concurrency_tag&gt;(points, nb_neighbors);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Point_set_processing_3Example_bilateral_smoothing"></a>
Bilateral Smoothing Example</h2>
<p>The following example reads a set of points with normals and smooths them via bilateral smoothing: <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2bilateral_smooth_point_set_example_8cpp-example.html">Point_set_processing_3/bilateral_smooth_point_set_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/bilateral_smooth_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/tags.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span> <span class="comment">// defines std::pair</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"></div><div class="line"><span class="comment">// Point with normal vector stored in a std::pair.</span></div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Point, Vector&gt; PointVectorPair;</div><div class="line"></div><div class="line"><span class="comment">// Concurrency</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a> Concurrency_tag;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string input_filename = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/fin90_with_PCA_normals.xyz"</span>);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* output_filename = (argc&gt;2) ? argv[2] : <span class="stringliteral">"data/fin90_with_PCA_normals_bilateral_smoothed.xyz"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Reads a point set file in points[] * with normals *.</span></div><div class="line">  std::vector&lt;PointVectorPair&gt; points;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(input_filename, std::back_inserter(points),</div><div class="line">                            CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                                             .normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>())))</div><div class="line">  {</div><div class="line">     std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; input_filename &lt;&lt; std::endl;</div><div class="line">     <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Algorithm parameters</span></div><div class="line">  <span class="keywordtype">int</span> k = 120;                 <span class="comment">// size of neighborhood. The bigger the smoother the result will be.</span></div><div class="line">                               <span class="comment">// This value should bigger than 1.</span></div><div class="line">  <span class="keywordtype">double</span> sharpness_angle = 25; <span class="comment">// control sharpness of the result.</span></div><div class="line">                               <span class="comment">// The bigger the smoother the result will be</span></div><div class="line">  <span class="keywordtype">int</span> iter_number = 3;         <span class="comment">// number of times the projection is applied</span></div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; iter_number; ++i)</div><div class="line">  {</div><div class="line">    <span class="comment">/* double error = */</span></div><div class="line">    CGAL::bilateral_smooth_point_set &lt;Concurrency_tag&gt;(</div><div class="line">      points,</div><div class="line">      k,</div><div class="line">      CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                       .normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                       .sharpness_angle(sharpness_angle));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IOXyz.html#ga1991ab8d312de62ddd907f81890ed039">CGAL::IO::write_XYZ</a>(output_filename, points,</div><div class="line">                          CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                                           .normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                                           .stream_precision(17)))</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p><a class="anchor" id="fig__Point_set_processing_3figsmoothing_comparison"></a></p><div class="image">
<img src="smoothing_comparison.jpg" alt="smoothing_comparison.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figsmoothing_comparison">Figure 80.21</a> Comparison for two smoothing methods: Left: Input, 250K points, normal-color mapping. Middle: Jet smoothing result, 197 seconds. Right: Bilateral smoothing result, 110 seconds.  </div> <br /> 
<h3><a class="anchor" id="Point_set_processing_3Bilateral_smoothing_parallel_performance"></a>
Parallel</h3>
<p>Performance: A parallel version of bilateral smoothing is provided and requires the executable to be linked against the <a href="https://github.com/oneapi-src/oneTBB">Intel TBB library</a>. The number of threads used is controlled through the tbb::task_scheduler_init class. See the <a href="https://software.intel.com/content/www/us/en/develop/documentation/onetbb-documentation/top.html">TBB documentation</a> for more details. We provide below a speed-up chart generated using the parallel version of the bilateral smoothing algorithm. The machine used is a PC running Windows 7 64-bits with a 4-core <a href="#" onclick="location.href='mai'+'lto:'+'i7-'+'47'+'00H'+'Q@'+'2.4'+'0G'+'Hz'; return false;">i7-47<span style="display: none;">.nosp@m.</span>00HQ<span style="display: none;">.nosp@m.</span>@2.40<span style="display: none;">.nosp@m.</span>GHz</a> CPU with 8GB of RAM.</p>
<p><a class="anchor" id="fig__Point_set_processing_3Bilateral_smoothing_parallel_performance"></a></p><div class="image">
<img src="parallel_bilateral_smooth_point_set_performance.jpg" alt="parallel_bilateral_smooth_point_set_performance.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3Bilateral_smoothing_parallel_performance">Figure 80.22</a> Parallel bilateral smoothing speed-up, compared to the sequential version of the algorithm.  </div> <br /> 
<h1><a class="anchor" id="Point_set_processing_3NormalEstimation"></a>
Normal Estimation</h1>
<p>Assuming a point set sampled over an inferred surface <b>S</b>, two functions provide an estimate of the normal to <b>S</b> at each point. The result is an unoriented normal vector for each input point.</p>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga078e25209373cab0e1f3524202489771" title="Estimates normal directions of the range of points using jet fitting on the nearest neighbors...">jet_estimate_normals()</a></code> estimates the normal direction at each point from the input set by fitting a jet surface over its nearest neighbors. The default jet is a quadric surface. This algorithm is well suited to point sets scattered over curved surfaces.</p>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga721aeb7af4b2d31e08e75bc5d53303cf" title="Estimates normal directions of the range of points by linear least squares fitting of a plane over th...">pca_estimate_normals()</a></code> estimates the normal direction at each point from the set by linear least squares fitting of a plane over its nearest neighbors. This algorithm is simpler and faster than <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga078e25209373cab0e1f3524202489771" title="Estimates normal directions of the range of points using jet fitting on the nearest neighbors...">jet_estimate_normals()</a></code>.</p>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gaab0fd78ef3e46c4256e9a1145a9d118e" title="Estimates normal directions of the range of points using the Voronoi Covariance Measure with a radius...">vcm_estimate_normals()</a></code> estimates the normal direction at each point from the set by using the Voronoi Covariance Measure of the point set. This algorithm is more complex and slower than the previous algorithms. It is based on the article <a class="el" href="citelist.html#CITEREF_cgal:mog-vbcfe-11">[9]</a>.</p>
<p>For these three functions, the user can either specify a fixed number of nearest neighbors or a fixed spherical neighborhood radius.</p>
<h1><a class="anchor" id="Point_set_processing_3NormalOrientation"></a>
Normal Orientation</h1>
<h2><a class="anchor" id="Point_set_processing_3Mst_orient_normals"></a>
Minimum Spanning Tree</h2>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga17c3c558c3799b65bd23fba971a82a5c" title="Orients the normals of the range of points using the propagation of a seed orientation through a mini...">mst_orient_normals()</a></code> orients the normals of a set of points with unoriented normals using the method described by Hoppe et al. in <em>Surface reconstruction from unorganized points</em> <a class="el" href="citelist.html#CITEREF_cgal:hddms-srup-92">[3]</a>. More specifically, this method constructs a Riemannian graph over the input points (the graph of the nearest neighbor points) and propagates a seed normal orientation within a minimum spanning tree computed over this graph. The result is an oriented normal vector for each input unoriented normal, except for the normals which cannot be successfully oriented.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figmst_orient_normals"></a></p><div class="image">
<img src="mst_orient_normals.jpg" alt="mst_orient_normals.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figmst_orient_normals">Figure 80.23</a> Normal orientation of a sampled cube surface. Left: unoriented normals. Right: orientation of right face normals is propagated to bottom face.  </div> <br /> 
<h3><a class="anchor" id="Point_set_processing_3Example_normals"></a>
Example</h3>
<p>The following example reads a point set from a file, estimates the normals through PCA (either over the 18 nearest neighbors or using a spherical neighborhood radius of twice the average spacing) and orients the normals: <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2normals_example_8cpp-example.html">Point_set_processing_3/normals_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/compute_average_spacing.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/pca_estimate_normals.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/mst_orient_normals.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span> <span class="comment">// defines std::pair</span></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"></div><div class="line"><span class="comment">// Point with normal vector stored in a std::pair.</span></div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Point, Vector&gt; PointVectorPair;</div><div class="line"></div><div class="line"><span class="comment">// Concurrency</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a> Concurrency_tag;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/sphere_1k.xyz"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Reads a point set file in points[].</span></div><div class="line">  std::list&lt;PointVectorPair&gt; points;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname,</div><div class="line">                            std::back_inserter(points),</div><div class="line">                            CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname&lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Estimates normals direction.</span></div><div class="line">  <span class="comment">// Note: pca_estimate_normals() requiresa range of points</span></div><div class="line">  <span class="comment">// as well as property maps to access each point's position and normal.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_neighbors = 18; <span class="comment">// K-nearest neighbors = 3 rings</span></div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 2 &amp;&amp; std::strcmp(argv[2], <span class="stringliteral">"-r"</span>) == 0) <span class="comment">// Use a fixed neighborhood radius</span></div><div class="line">  {</div><div class="line">    <span class="comment">// First compute a spacing using the K parameter</span></div><div class="line">    <span class="keywordtype">double</span> spacing</div><div class="line">        = CGAL::compute_average_spacing&lt;Concurrency_tag&gt;</div><div class="line">          (points, nb_neighbors,</div><div class="line">           CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>()));</div><div class="line"></div><div class="line">    <span class="comment">// Then, estimate normals with a fixed radius</span></div><div class="line">    CGAL::pca_estimate_normals&lt;Concurrency_tag&gt;</div><div class="line">        (points,</div><div class="line">         0, <span class="comment">// when using a neighborhood radius, K=0 means no limit on the number of neighbors returns</span></div><div class="line">         CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                          .normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                          .neighbor_radius(2. * spacing)); <span class="comment">// use 2*spacing as neighborhood radius</span></div><div class="line">  }</div><div class="line">  <span class="keywordflow">else</span> <span class="comment">// Use a fixed number of neighbors</span></div><div class="line">  {</div><div class="line">    CGAL::pca_estimate_normals&lt;Concurrency_tag&gt;</div><div class="line">        (points, nb_neighbors,</div><div class="line">         CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                          .normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>()));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Orients normals.</span></div><div class="line">  <span class="comment">// Note: mst_orient_normals() requires a range of points</span></div><div class="line">  <span class="comment">// as well as property maps to access each point's position and normal.</span></div><div class="line">  std::list&lt;PointVectorPair&gt;::iterator unoriented_points_begin =</div><div class="line">      <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga17c3c558c3799b65bd23fba971a82a5c">CGAL::mst_orient_normals</a>(points, nb_neighbors,</div><div class="line">                               CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                                                .normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>()));</div><div class="line"></div><div class="line">  <span class="comment">// Optional: delete points with an unoriented normal</span></div><div class="line">  <span class="comment">// if you plan to call a reconstruction algorithm that expects oriented normals.</span></div><div class="line">  points.erase(unoriented_points_begin, points.end());</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Point_set_processing_3Scanline_orient_normals"></a>
Scanline</h2>
<p>The minimum spanning tree results can give suboptimal results on point clouds with many sharp features and occlusions, which typically happens on airborne acquired urban datasets.</p>
<p><code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gafc3627234666e1fb458e9387e9d5f3c6" title="orients the normals of the range of points by estimating a line of sight and checking its consistency...">scanline_orient_normals()</a></code> is an alternative method specialized for point sets which are ordered in scanline aligned on the XY-plane. It can take advantage of LAS properties provided by some LIDAR scanner and is the best choice of normal orientation when dealing with 2.5D urban scenes.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figmst_scanline_orient_normals"></a></p><div class="image">
<img src="scanline_orient_normals.png" alt="scanline_orient_normals.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figmst_scanline_orient_normals">Figure 80.24</a> Normal orientation of a LIDAR scanline. The point cloud is a typical airborne LIDAR input, sampling a building without normal information and with many occlusions (especially on vertical walls).  </div> <br /> 
<h3><a class="anchor" id="Point_set_processing_3Example_scanline_normals"></a>
Example</h3>
<p>The following example reads a point set from a LAS file, estimates the normals through Jet Fitting and outputs in PLY format the orientation results of all the variants of <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gafc3627234666e1fb458e9387e9d5f3c6" title="orients the normals of the range of points by estimating a line of sight and checking its consistency...">scanline_orient_normals()</a></code>:</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2orient_scanlines_example_8cpp-example.html">Point_set_processing_3/orient_scanlines_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_las_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_ply_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/jet_estimate_normals.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/scanline_orient_normals.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> Kernel = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> Point_3 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ae82b7f4be77dd5b8819ebe419e4ae753">Kernel::Point_3</a>;</div><div class="line"><span class="keyword">using</span> Vector_3 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a39fb0222695ae5e7e32f4e570ea28225">Kernel::Vector_3</a>;</div><div class="line"><span class="keyword">using</span> Point_with_info = std::tuple&lt;Point_3, Vector_3, float, unsigned char&gt;;</div><div class="line"><span class="keyword">using</span> Point_map = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;0, Point_with_info&gt;</a>;</div><div class="line"><span class="keyword">using</span> Normal_map = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;1, Point_with_info&gt;</a>;</div><div class="line"><span class="keyword">using</span> Scan_angle_map = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;2, Point_with_info&gt;</a>;</div><div class="line"><span class="keyword">using</span> Scanline_id_map = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;3, Point_with_info&gt;</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> dump (<span class="keyword">const</span> <span class="keywordtype">char</span>* filename, <span class="keyword">const</span> std::vector&lt;Point_with_info&gt;&amp; points)</div><div class="line">{</div><div class="line">  std::ofstream ofile (filename, std::ios::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a>(ofile);</div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3IOPly.html#ga615f4420ce82b5ceb1b584b506d714ad">CGAL::IO::write_PLY</a></div><div class="line">    (ofile, points,</div><div class="line">     CGAL::parameters::point_map (Point_map()).</div><div class="line">     normal_map (Normal_map()));</div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::string fname (argc &gt; 1 ? argv[1] : <span class="stringliteral">"data/urban.las"</span>);</div><div class="line"></div><div class="line">  std::vector&lt;Point_with_info&gt; points;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Reading input file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">  std::ifstream ifile (fname, std::ios::binary);</div><div class="line">  <span class="keywordflow">if</span> (!ifile ||</div><div class="line">      !<a class="code" href="group__PkgPointSetProcessing3IOLas.html#ga5187fc18430a5e3c811f75da57a057ad">CGAL::IO::read_LAS_with_properties</a></div><div class="line">      (ifile, std::back_inserter (points),</div><div class="line">       <a class="code" href="group__PkgPointSetProcessing3IOLas.html#gac807a7bbde008f9707a1cf697e3eb64c">CGAL::IO::make_las_point_reader</a> (Point_map()),</div><div class="line">       std::make_pair (Scan_angle_map(),</div><div class="line">                       CGAL::IO::LAS_property::Scan_angle()),</div><div class="line">       std::make_pair (Scanline_id_map(),</div><div class="line">                       CGAL::IO::LAS_property::Scan_direction_flag())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Can't read "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Estimating normals"</span> &lt;&lt; std::endl;</div><div class="line">  CGAL::jet_estimate_normals&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (points, 12,</div><div class="line">     CGAL::parameters::point_map (Point_map()).</div><div class="line">     normal_map (Normal_map()));</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Orienting normals using scan angle and direction flag"</span> &lt;&lt; std::endl;</div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#gafc3627234666e1fb458e9387e9d5f3c6">CGAL::scanline_orient_normals</a></div><div class="line">    (points,</div><div class="line">     CGAL::parameters::point_map (Point_map()).</div><div class="line">     normal_map (Normal_map()).</div><div class="line">     scan_angle_map (Scan_angle_map()).</div><div class="line">     scanline_id_map (Scanline_id_map()));</div><div class="line">  dump(<span class="stringliteral">"out_angle_and_flag.ply"</span>, points);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Orienting normals using scan direction flag only"</span> &lt;&lt; std::endl;</div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#gafc3627234666e1fb458e9387e9d5f3c6">CGAL::scanline_orient_normals</a></div><div class="line">    (points,</div><div class="line">     CGAL::parameters::point_map (Point_map()).</div><div class="line">     normal_map (Normal_map()).</div><div class="line">     scanline_id_map (Scanline_id_map()));</div><div class="line">  dump(<span class="stringliteral">"out_flag.ply"</span>, points);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Orienting normals using scan angle only"</span> &lt;&lt; std::endl;</div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#gafc3627234666e1fb458e9387e9d5f3c6">CGAL::scanline_orient_normals</a></div><div class="line">    (points,</div><div class="line">     CGAL::parameters::point_map (Point_map()).</div><div class="line">     normal_map (Normal_map()).</div><div class="line">     scan_angle_map (Scan_angle_map()));</div><div class="line">  dump(<span class="stringliteral">"out_angle.ply"</span>, points);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Orienting normals using no additional info"</span> &lt;&lt; std::endl;</div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#gafc3627234666e1fb458e9387e9d5f3c6">CGAL::scanline_orient_normals</a></div><div class="line">    (points,</div><div class="line">     CGAL::parameters::point_map (Point_map()).</div><div class="line">     normal_map (Normal_map()));</div><div class="line">  dump(<span class="stringliteral">"out_nothing.ply"</span>, points);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Point_set_processing_3Upsampling"></a>
Upsampling</h1>
<p>The function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga8712cbc64f1cfd4dd2f61049a24b90f4" title="This method progressively upsamples the point set while approaching the edge singularities (detected ...">edge_aware_upsample_point_set()</a></code> generates a denser point set from an input point set. This has applications in point-based rendering, hole filling, and sparse surface reconstruction. The algorithm can progressively upsample the point set while approaching the edge singularities. See <a class="el" href="citelist.html#CITEREF_ear-2013">[5]</a> for more details.</p>
<h2><a class="anchor" id="Point_set_processing_3Example_upsampling"></a>
Example</h2>
<p>The following example reads a point set from a file, upsamples it to get a denser result.</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2edge_aware_upsample_point_set_example_8cpp-example.html">Point_set_processing_3/edge_aware_upsample_point_set_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/edge_aware_upsample_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"></div><div class="line"><span class="comment">// Point with normal vector stored in a std::pair.</span></div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Point, Vector&gt; PointVectorPair;</div><div class="line"></div><div class="line"><span class="comment">// Concurrency</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a> Concurrency_tag;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string input_filename = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/before_upsample.xyz"</span>);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* output_filename = (argc&gt;2) ? argv[2] : <span class="stringliteral">"data/before_upsample_UPSAMPLED.xyz"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Reads a .xyz point set file in points[], *with normals*.</span></div><div class="line">  std::vector&lt;PointVectorPair&gt; points;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(input_filename,</div><div class="line">                            std::back_inserter(points),</div><div class="line">                            CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                                             .normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; input_filename &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">//Algorithm parameters</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> sharpness_angle = 25;   <span class="comment">// control sharpness of the result.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> edge_sensitivity = 0;    <span class="comment">// higher values will sample more points near the edges</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> neighbor_radius = 0.25;  <span class="comment">// initial size of neighborhood.</span></div><div class="line">  <span class="keyword">const</span> std::size_t number_of_output_points = points.size() * 4;</div><div class="line"></div><div class="line">   <span class="comment">//Run algorithm</span></div><div class="line">  CGAL::edge_aware_upsample_point_set&lt;Concurrency_tag&gt;(</div><div class="line">    points,</div><div class="line">    std::back_inserter(points),</div><div class="line">    CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>()).</div><div class="line">    normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>()).</div><div class="line">    sharpness_angle(sharpness_angle).</div><div class="line">    edge_sensitivity(edge_sensitivity).</div><div class="line">    neighbor_radius(neighbor_radius).</div><div class="line">    number_of_output_points(number_of_output_points));</div><div class="line"></div><div class="line">  <span class="comment">// Saves point set.</span></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga5822feba4449f0492363611620b877c0">CGAL::IO::write_points</a>(output_filename, points,</div><div class="line">                             CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                                              .normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                                              .stream_precision(17)))</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="Point_set_processing_3Upsample_Parameter1"></a>
Parameter: edge_sensitivity</h3>
<p>This parameter controls where the new points are inserted. Larger values of edge-sensitivity give higher priority to inserting points along the sharp features. For example, as shown in the following figure, high value is preferable when one wants to insert more points on sharp features, where the local gradient is high, e.g., darts, cusps, creases and corners. In contrast, points are evenly inserted when edge_sensitivity is set to 0. The range of possible value is [0, 1].</p>
<p><a class="anchor" id="fig__Point_set_processing_3figUpsample_edge_sensitivity"></a></p><div class="image">
<img src="upsample_edge_sensitivity.jpg" alt="upsample_edge_sensitivity.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figUpsample_edge_sensitivity">Figure 80.25</a> Upsampling for different edge-sensitivity parameter values. The input containing 850 points is upsampled to 1,500 points in all cases depicted.  </div> <br /> 
<h3><a class="anchor" id="Point_set_processing_3Upsample_Parameter2"></a>
Parameter: sharpness_angle</h3>
<p>This parameter controls the preservation of sharp features.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figUpsample_sharpness_angle"></a></p><div class="image">
<img src="upsample_sharpness_angle.jpg" alt="upsample_sharpness_angle.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figUpsample_sharpness_angle">Figure 80.26</a> Upsampling for different sharpness_angle parameter values. The input containing 850 points is upsampled to 425K points in all cases depicted.  </div> <br /> 
<h3><a class="anchor" id="Point_set_processing_3upsample_neighborhood_size"></a>
Parameter: neighbor_radius</h3>
<p>Usually, the neighborhood of sample points should include at least one ring of neighboring sample points. Using small neighborhood size may not be able to insert new points. Using big neighborhood size can fill small holes, but points inserted on the edges could be irregular. The function will use a neighborhood size estimation if this parameter value is set to default or smaller than zero.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figupsample_neighborhood_size"></a></p><div class="image">
<img src="upsample_neighborhood_size.jpg" alt="upsample_neighborhood_size.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figupsample_neighborhood_size">Figure 80.27</a> Comparison between different sizes of neighbor radius.  </div> <br /> 
<h1><a class="anchor" id="Point_set_processing_3FeaturesEstimation"></a>
Feature Edges Estimation</h1>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gac57ce53e3249a66e4c19e85f439ff01e" title="determines if a point is on a sharp feature edge from a point set for which the Voronoi covariance Me...">vcm_is_on_feature_edge()</a></code> indicates if a points belong to a feature edges of the point set using its Voronoi Covariance Measure. It is based on the article <a class="el" href="citelist.html#CITEREF_cgal:mog-vbcfe-11">[9]</a>.</p>
<p>It first computes the VCM of the points set using <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga258a9b3a40d10533f8f01d64b4e91eca" title="computes the Voronoi Covariance Measure (VCM) of a point cloud, a construction that can be used for n...">compute_vcm()</a></code>. Then, it estimates which points belong to a sharp edge by testing if a ratio of eigenvalues is greater than a given threshold.</p>
<h2><a class="anchor" id="Point_set_processing_3Example_sharp_edges"></a>
Example</h2>
<p>The following example reads a point set from a file, estimates the points that are on sharp edges: <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2edges_example_8cpp-example.html">Point_set_processing_3/edges_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/vcm_estimate_edges.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span> <span class="comment">// defines std::pair</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"></div><div class="line"><span class="comment">// Point with normal vector stored in a std::pair.</span></div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Point, Vector&gt; PointVectorPair;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;PointVectorPair&gt; PointList;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::array&lt;double,6&gt; Covariance;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> , <span class="keywordtype">char</span>**)</div><div class="line">{</div><div class="line">  <span class="comment">// Reads a polygon mesh file in points[].</span></div><div class="line">  std::list&lt;PointVectorPair&gt; points;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/fandisk_large.off"</span>),</div><div class="line">                            std::back_inserter(points),</div><div class="line">                            CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file data/fandisk_large.off"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Estimates covariance matrices per points.</span></div><div class="line">  <span class="keywordtype">double</span> R = 0.2,</div><div class="line">         r = 0.1;</div><div class="line">  std::vector&lt;Covariance&gt; cov;</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a> point_map;</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga258a9b3a40d10533f8f01d64b4e91eca">CGAL::compute_vcm</a>(points, cov, R, r,</div><div class="line">                    CGAL::parameters::point_map (point_map).geom_traits (Kernel()));</div><div class="line"></div><div class="line">  <span class="comment">// Find the points on the edges.</span></div><div class="line">  <span class="comment">// Note that this step is not expensive and can be done several time to get better results</span></div><div class="line">  <span class="keywordtype">double</span> threshold = 0.16;</div><div class="line">  std::ofstream output(<span class="stringliteral">"points_on_edges.xyz"</span>);</div><div class="line">  <span class="keywordtype">int</span> i = 0;</div><div class="line">  <span class="keywordflow">for</span>(<span class="keyword">const</span> PointVectorPair&amp; p : points)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__PkgPointSetProcessing3Algorithms.html#gac57ce53e3249a66e4c19e85f439ff01e">CGAL::vcm_is_on_feature_edge</a>(cov[i], threshold))</div><div class="line">      output &lt;&lt; p.first &lt;&lt; <span class="stringliteral">"\n"</span>;</div><div class="line">    ++i;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h1><a class="anchor" id="Point_set_processing_3Structuring"></a>
Structuring</h1>
<p>The function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gaebbc04909dfd575a94f932c8d3bacdce" title="This is an implementation of the Point Set Structuring algorithm. ">structure_point_set()</a></code> generates a structured version of the input point set assigned to a set of planes. Such an input can be produced by a shape detection algorithm (see <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/group__PkgShapeDetectionRef.html">Shape Detection Reference</a>). Point set structuring is based on the article <a class="el" href="citelist.html#CITEREF_cgal:la-srpss-13">[6]</a>.</p>
<ul>
<li><b>Planes</b>: inliers of each detected plane are replaced by sets of noise-free points sampled at the vertices of a regular grid: this is achieved by filling an occupancy grid aligned on the principal components of the inlier sets with a spacing lower than \(\sqrt{2}\) times the user-defined tolerance.</li>
<li><b>Creases</b>: adjacencies between 2 planes are detected and regularly resampled on an occupancy array along the edge with a spacing equal to twice the user-defined tolerance.</li>
<li><b>Corners</b>: 3-cycles are detected from the primitive adjacency graph and sampled using the exact intersection point of the 3 planes (provided it exists and remains in the given tolerance). These corners are also locally clustered to former corners of degree higher than 3.</li>
</ul>
<p>This algorithm is well suited to point sets sampled on surfaces with planar sections and sharp edges.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figstructuring"></a></p><div class="image">
<img src="structuring.png" alt="structuring.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figstructuring">Figure 80.28</a> Point set structuring. Left: input raw point set. Right: structured point set.  </div> <br /> 
<p>Structure information of points can be used to perform feature preserving reconstruction (see <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Advancing_front_surface_reconstruction.tag:../Advancing_front_surface_reconstruction/" href="../Advancing_front_surface_reconstruction/index.html#AFSR_Example_sharp_features">Advancing Front Surface Reconstruction</a> for example). More specifically, the class storing a point set with structure provides the user with a method <code><a class="el" href="classCGAL_1_1Point__set__with__structure.html#ae8890334744d8d7efd17917c62fc1513" title="Computes the coherence of a facet between the 3 points indexed by f with respect to the underlying st...">Point_set_with_structure::facet_coherence()</a></code> that estimates if a triplet of points form a coherent facet.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figstructuring_coherence"></a></p><div class="image">
<img src="structuring_coherence.png" alt="structuring_coherence.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figstructuring_coherence">Figure 80.29</a> (a) Input point set (and structured output); (b) output with many incoherent facets; (c) output with all facets coherent. i, j and k each corresponds to a primitive index.  </div> <br /> 
<h2><a class="anchor" id="Point_set_processing_3Example_9"></a>
Example</h2>
<p>The following example applies shape detection followed by structuring to a point set: <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2structuring_example_8cpp-example.html">Point_set_processing_3/structuring_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Shape_detection/Efficient_RANSAC.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/structure_point_set.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Type declarations</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>  Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                                      Point;</div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Kernel::Point_3, Kernel::Vector_3&gt;         Point_with_normal;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point_with_normal&gt;                       Pwn_vector;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Point_with_normal&gt;</a>  Point_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;Point_with_normal&gt;</a> Normal_map;</div><div class="line"></div><div class="line"><span class="comment">// Efficient RANSAC types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/structCGAL_1_1Shape__detection_1_1Efficient__RANSAC__traits.html">CGAL::Shape_detection::Efficient_RANSAC_traits</a></div><div class="line">  &lt;Kernel, Pwn_vector, Point_map, Normal_map&gt;              Traits;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Efficient__RANSAC.html">CGAL::Shape_detection::Efficient_RANSAC&lt;Traits&gt;</a>    Efficient_ransac;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Plane.html">CGAL::Shape_detection::Plane&lt;Traits&gt;</a>               Plane;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string filename = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/cube.pwn"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Points with normals.</span></div><div class="line">  Pwn_vector points;</div><div class="line"></div><div class="line">  <span class="comment">// Loading point set from a file.</span></div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(filename, std::back_inserter(points),</div><div class="line">                            CGAL::parameters::point_map(Point_map())</div><div class="line">                                             .normal_map(Normal_map())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file cube.pwn"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; points.size() &lt;&lt; <span class="stringliteral">" point(s) read."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Shape detection</span></div><div class="line">  Efficient_ransac ransac;</div><div class="line">  ransac.set_input(points);</div><div class="line">  ransac.add_shape_factory&lt;Plane&gt;();</div><div class="line">  ransac.detect();</div><div class="line"></div><div class="line">  Efficient_ransac::Plane_range planes = ransac.planes();</div><div class="line"></div><div class="line">  Pwn_vector structured_pts;</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#gaebbc04909dfd575a94f932c8d3bacdce">CGAL::structure_point_set</a>(points,</div><div class="line">                            planes,</div><div class="line">                            std::back_inserter(structured_pts),</div><div class="line">                            0.015, <span class="comment">// epsilon for structuring points</span></div><div class="line">                            CGAL::parameters::point_map(Point_map())</div><div class="line">                                             .normal_map(Normal_map())</div><div class="line">                                             .plane_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Plane__map.html">CGAL::Shape_detection::Plane_map&lt;Traits&gt;</a>())</div><div class="line">                                             .plane_index_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Point__to__shape__index__map.html">CGAL::Shape_detection::Point_to_shape_index_map&lt;Traits&gt;</a>(points, planes)));</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; structured_pts.size ()</div><div class="line">            &lt;&lt; <span class="stringliteral">" structured point(s) generated."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3IO.html#ga5822feba4449f0492363611620b877c0">CGAL::IO::write_points</a>(<span class="stringliteral">"out.pwn"</span>, structured_pts,</div><div class="line">                         CGAL::parameters::point_map(Point_map())</div><div class="line">                                          .normal_map(Normal_map())</div><div class="line">                                          .stream_precision(17));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Point_set_processing_3Callbacks"></a>
Callbacks</h1>
<p>Several functions of this package provide a callback mechanism that enables the user to track the progress of the algorithms and to interrupt them if needed. A callback, in this package, is an instance of <code>std::function&lt;bool(double)&gt;</code> that takes the advancement as a parameter (between 0. when the algorithm begins to 1. when the algorithm is completed) and that returns <code>true</code> if the algorithm should carry on, <code>false</code> otherwise. It is passed as a named parameter with an empty function as default.</p>
<p>Algorithms that support this mechanism are detailed in the <a class="el" href="group__PkgPointSetProcessing3Ref.html">Reference Manual</a>, along with the effect that an early interruption has on the output.</p>
<h2><a class="anchor" id="Point_set_processing_3Example_callbacks"></a>
Example</h2>
<p>The following example defines a callback that displays the name of the current algorithm along with the progress (as a percentage) updated every \(1/10th\) of a second. While the algorithm is running, the console output will typically look like this:</p>
<div class="fragment"><div class="line">Computing average spacing: 100%</div><div class="line">Grid simplification: 100%</div><div class="line">Jet smoothing: 54%</div></div><!-- fragment --><p>Thanks to the carriage return character <code>\r</code>, the lines are overwritten and the user sees the percentage increasing on each line.</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2callback_example_8cpp-example.html">Point_set_processing_3/callback_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/point_generators_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/compute_average_spacing.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/grid_simplify_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/jet_smooth_point_set.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/lexical_cast.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> CGAL::Random_points_on_sphere_3&lt;Point&gt; Generator;</div><div class="line"></div><div class="line"><span class="comment">// Concurrency</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a> Concurrency_tag;</div><div class="line"></div><div class="line"><span class="comment">// instance of std::function&lt;bool(double)&gt;</span></div><div class="line"><span class="keyword">struct </span>Progress_to_std_cerr_callback</div><div class="line">{</div><div class="line">  <span class="keyword">mutable</span> std::size_t nb;</div><div class="line">  CGAL::Real_timer timer;</div><div class="line">  <span class="keywordtype">double</span> t_start;</div><div class="line">  <span class="keyword">mutable</span> <span class="keywordtype">double</span> t_latest;</div><div class="line">  <span class="keyword">const</span> std::string name;</div><div class="line"></div><div class="line">  Progress_to_std_cerr_callback (<span class="keyword">const</span> <span class="keywordtype">char</span>* name)</div><div class="line">    : name (name)</div><div class="line">  {</div><div class="line">    timer.start();</div><div class="line">    t_start = timer.time();</div><div class="line">    t_latest = t_start;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> operator()(<span class="keywordtype">double</span> advancement)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="comment">// Avoid calling time() at every single iteration, which could</span></div><div class="line">    <span class="comment">// impact performances very badly</span></div><div class="line">    ++ nb;</div><div class="line">    <span class="keywordflow">if</span> (advancement != 1 &amp;&amp; nb % 100 != 0)</div><div class="line">      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> t = timer.time();</div><div class="line">    <span class="keywordflow">if</span> (advancement == 1 || (t - t_latest) &gt; 0.1) <span class="comment">// Update every 1/10th of second</span></div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">"\r"</span> <span class="comment">// Return at the beginning of same line and overwrite</span></div><div class="line">                &lt;&lt; name &lt;&lt; <span class="stringliteral">": "</span> &lt;&lt; int(advancement * 100) &lt;&lt; <span class="stringliteral">"%"</span>;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (advancement == 1)</div><div class="line">        std::cerr &lt;&lt; std::endl;</div><div class="line">      t_latest = t;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">  <span class="keywordtype">int</span> N = (argc &gt; 1) ? boost::lexical_cast&lt;int&gt;(argv[1]) : 1000;</div><div class="line"></div><div class="line">  <span class="comment">// Generate N points on a sphere of radius 100.</span></div><div class="line">  std::vector&lt;Point&gt; points;</div><div class="line">  points.reserve(N);</div><div class="line">  Generator generator(100.);</div><div class="line">  std::copy_n(generator, N, std::back_inserter(points));</div><div class="line"></div><div class="line">  <span class="comment">// Compute average spacing</span></div><div class="line">  FT average_spacing = CGAL::compute_average_spacing&lt;Concurrency_tag&gt;</div><div class="line">    (points, 6,</div><div class="line">     CGAL::parameters::callback(Progress_to_std_cerr_callback(<span class="stringliteral">"Computing average spacing"</span>)));</div><div class="line"></div><div class="line">  <span class="comment">// Simplify on a grid with a size of twice the average spacing</span></div><div class="line">  points.erase(<a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga7757ef9b3900e42fde26f5a0ac56e20f">CGAL::grid_simplify_point_set</a>(points, 2. * average_spacing,</div><div class="line">                                             CGAL::parameters::callback(Progress_to_std_cerr_callback(<span class="stringliteral">"Grid simplification"</span>))),</div><div class="line">               points.end());</div><div class="line"></div><div class="line">  <span class="comment">// Smooth simplified point set</span></div><div class="line">  CGAL::jet_smooth_point_set&lt;Concurrency_tag&gt;(points, 6,</div><div class="line">                                              CGAL::parameters::callback(Progress_to_std_cerr_callback(<span class="stringliteral">"Jet smoothing"</span>)));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h1><a class="anchor" id="Point_set_processing_3ImplementationHistory"></a>
Implementation History</h1>
<p>Pierre Alliez and Laurent Saboret contributed the initial component. Nader Salman contributed the grid simplification. Started from GSoC'2013, three new algorithms were implemented by Shihao Wu and Clément Jamin: WLOP, bilateral smoothing and upsampling. Started from GSoC'2014, Jocelyn Meyron with the help of Quentin Mérigot introduced the computation of the Voronoi covariance measure of a point set, as well as the normal and feature edge estimation functions based on it. Florent Lafarge with the help of Simon Giraudot contributed the point set structuring algorithm. Started from GSoC'2019, Necip Fazil Yildiran with the help of Nicolas Mellado and Simon Giraudot introduced the wrappers for <a class="el" href="namespaceCGAL_1_1OpenGR.html">OpenGR</a> and PointMatcher libraries that perform registration on two point sets. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jan 30 2023 13:47:22 for CGAL 5.6 - Point Set Processing by
    <a href="https://www.doxygen.nl/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>
</html><html xmlns="http://www.w3.org/1999/xhtml"><body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.6 - Point Set Processing
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Point_Set_Processing"></a><a class="anchor" id="chappoint_set_processing_3"></a>  </p><div id="autotoc" class="toc"></div> 
<dl class="section author"><dt>Authors</dt><dd>Pierre Alliez, Simon Giraudot, Clément Jamin, Florent Lafarge, Quentin Mérigot, Jocelyn Meyron, Laurent Saboret, Nader Salman, Shihao Wu, Necip Fazil Yildiran</dd></dl>
<h1><a class="anchor" id="Point_set_processing_3Introduction"></a>
Introduction</h1>
<p>This CGAL component implements methods to analyze and process 3D point sets. The input is an unorganized 3D point set, possibly with normal attributes (unoriented or oriented). The input point set can be analyzed to measure geometric properties such as average spacing between the points and their <code>k</code> nearest neighbors. It can be processed with functions devoted to the simplification, regularization, upsampling, outlier removal, smoothing, normal estimation and normal orientation. The processing of point sets is often needed in applications dealing with measurement data, such as surface reconstruction from laser scanned data (see <a class="el" href="index.html#fig__Point_set_processing_3figintroduction">Figure 80.1</a>).</p>
<p><a class="anchor" id="fig__Point_set_processing_3figintroduction"></a></p><div class="image">
<img src="introduction.jpg" alt="introduction.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figintroduction">Figure 80.1</a> Point set processing. Left: 275K points sampled on the statue of an elephant with a Minolta laser scanner. Right: point set after outlier removal, denoising and simplification to 17K points.  </div> <br /> 
<p>In the context of surface reconstruction we can position the elements of this component along the common surface reconstruction pipeline (<a class="el" href="index.html#fig__Point_set_processing_3figpipeline">Figure 80.2</a>) which involves the following steps:</p><ol type="1">
<li>Scanning and scan registration to produce a set of points or points with normals;</li>
<li>Outlier removal;</li>
<li>Simplification to reduce the number of input points;</li>
<li>Smoothing to reduce noise in the input data;</li>
<li>Normal estimation and orientation when the normals are not already provided by the acquisition device; and</li>
<li>Surface reconstruction. Chapter <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Poisson_surface_reconstruction_3.tag:../Poisson_surface_reconstruction_3/" href="../Poisson_surface_reconstruction_3/index.html#Chapter_Poisson_Surface_Reconstruction">Poisson Surface Reconstruction</a> deals with surface reconstruction from point sets with normal attributes.</li>
</ol>
<p><a class="anchor" id="fig__Point_set_processing_3figpipeline"></a></p><div class="image">
<img src="pipeline.jpg" alt="pipeline.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figpipeline">Figure 80.2</a> Point set processing pipeline for surface reconstruction. The algorithms listed in gray are available from other <a class="el" href="namespaceCGAL.html">CGAL</a> components (bounding volumes and principal component analysis).  </div> <br /> 
<h1><a class="anchor" id="Point_set_processing_3API"></a>
API</h1>
<p>The algorithms of this component take as input parameters ranges of 3D points, or of 3D points with normals. They can be adapted to the user's data structures and make extensive use of <a class="el" href="index.html#Point_set_processing_3NamedParameters">named parameters</a> and of <a class="el" href="index.html#Point_set_processing_3PropertyMaps">property maps</a>:</p>
<div class="fragment"><div class="line">std::vector&lt;PointVectorPair&gt; points;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a> Point_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a> Vector_map;</div><div class="line"></div><div class="line"><a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga078e25209373cab0e1f3524202489771">CGAL::jet_estimate_normals</a></div><div class="line">&lt;<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__tag.html">CGAL::Parallel_tag</a>&gt;           <span class="comment">// concurrency tag</span></div><div class="line">  (points,                     <span class="comment">// input range of points</span></div><div class="line">   12,                         <span class="comment">// parameter: number of neighbors</span></div><div class="line">   <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL_1_1parameters.html">CGAL::parameters</a>::          <span class="comment">// named parameters:</span></div><div class="line">   point_map (Point_map()).    <span class="comment">//  * point map</span></div><div class="line">   normal_map (Vector_map())); <span class="comment">//  * normal map</span></div></div><!-- fragment --><p>This API was introduced in CGAL 4.12. Please refer to the <a class="el" href="index.html#Point_set_processing_3Outdated">dedicated section</a> on how to upgrade from the outdated API.</p>
<h2><a class="anchor" id="Point_set_processing_3NamedParameters"></a>
Named Parameters</h2>
<p>Named parameters are used to deal with optional parameters. The page <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/index.html#BGLNamedParameters">Named Parameters</a> explains the rationale and API in general. The page <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__bgl__namedparameters.html">Named Parameters</a> describes their usage.</p>
<h2><a class="anchor" id="Point_set_processing_3PropertyMaps"></a>
Property Maps</h2>
<p>The property maps are used to access the point or normal information from the input data, so as to let the user decide upon the implementation of a point with normal. The latter can be represented as, e.g., a class derived from the CGAL 3D point, or as a <code>std::pair&lt;<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__3.html">Point_3</a>&lt;K&gt;, <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Vector__3.html">Vector_3</a>&lt;K&gt;&gt;</code>, or as a <code>boost::tuple&lt;..,<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__3.html">Point_3</a>&lt;K&gt;, ..., <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Vector__3.html">Vector_3</a>&lt;K&gt; &gt;</code>.</p>
<p>The following classes described in Chapter <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgPropertyMap">CGAL and Boost Property Maps</a> provide property maps for the implementations of points with normals listed above:</p>
<ul>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Identity__property__map.html">Identity_property_map</a>&lt;T&gt;</code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">First_of_pair_property_map</a>&lt;Pair&gt;</code> and <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">Second_of_pair_property_map</a>&lt;Pair&gt;</code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">Nth_of_tuple_property_map</a>&lt;N, Tuple&gt;</code></li>
</ul>
<p><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Identity__property__map.html">Identity_property_map</a>&lt;<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__3.html">Point_3</a>&gt;</code> is the default value of the position property map expected by all functions in this component.</p>
<p>See below examples using pair and tuple property maps.</p>
<p>Users of this package may use other types to represent positions and normals if they implement the corresponding property maps.</p>
<p>Points and normals can even be stored in separate containers and accessed by their index, as any built-in vector is also a property map.</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2grid_simplify_indices_8cpp-example.html">Point_set_processing_3/grid_simplify_indices.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/grid_simplify_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/fin90_with_PCA_normals.xyz"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Reads a .xyz point set file in points[].</span></div><div class="line">  std::vector&lt;Point&gt; points;</div><div class="line">  std::vector&lt;Vector&gt; normals;</div><div class="line">  std::ifstream stream(fname);</div><div class="line">  Point p;</div><div class="line">  Vector v;</div><div class="line">  <span class="keywordflow">while</span>(stream &gt;&gt; p &gt;&gt; v)</div><div class="line">  {</div><div class="line">    points.push_back(p);</div><div class="line">    normals.push_back(v);</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; points.size() &lt;&lt; <span class="stringliteral">" input points"</span> &lt;&lt; std::endl;</div><div class="line">  std::vector&lt;std::size_t&gt; indices(points.size());</div><div class="line">  <span class="keywordflow">for</span>(std::size_t i = 0; i &lt; points.size(); ++i){</div><div class="line">    indices[i] = i;</div><div class="line">  }</div><div class="line">  <span class="comment">// simplification by clustering using erase-remove idiom</span></div><div class="line">  <span class="keywordtype">double</span> cell_size = 0.05;</div><div class="line">  std::vector&lt;std::size_t&gt;::iterator end;</div><div class="line">  end = <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga7757ef9b3900e42fde26f5a0ac56e20f">CGAL::grid_simplify_point_set</a>(indices,</div><div class="line">                                      cell_size,</div><div class="line">                                      CGAL::parameters::point_map (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/group__PkgPropertyMapRef.html#ga44ae71cce5987f3970443868a129752a">CGAL::make_property_map</a>(points)));</div><div class="line"></div><div class="line">  std::size_t k = end - indices.begin();</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Keep "</span> &lt;&lt; k &lt;&lt; <span class="stringliteral">" of "</span> &lt;&lt; indices.size() &lt;&lt;  <span class="stringliteral">" indices"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  {</div><div class="line">    std::vector&lt;Point&gt; tmp_points(k);</div><div class="line">    std::vector&lt;Vector&gt; tmp_normals(k);</div><div class="line">    <span class="keywordflow">for</span>(std::size_t i=0; i&lt;k; ++i){</div><div class="line">      tmp_points[i] = points[indices[i]];</div><div class="line">      tmp_normals[i] = normals[indices[i]];</div><div class="line">    }</div><div class="line">    points.swap(tmp_points);</div><div class="line">    normals.swap(tmp_normals);</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; points.size() &lt;&lt; <span class="stringliteral">" points after the simplification"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h2><a class="anchor" id="Point_set_processing_3Outdated"></a>
Upgrading from pre-CGAL 4.12 API</h2>
<p>The current API based on ranges and named parameters was introduced in CGAL 4.12. The old API that used pairs of iterators along with usual C++ parameters (with some default values and overloads to handle optional parameters) has been removed in CGAL 5.0.</p>
<p>Translating your pre-CGAL 4.12 code using Point Set Processing to the current API is easy. For example, consider this code using the old API:</p>
<div class="fragment"><div class="line">std::vector&lt;PointVectorPair&gt; points;</div><div class="line"></div><div class="line"><span class="comment">// Old pre-CGAL 4.12 API</span></div><div class="line">CGAL::jet_estimate_normals&lt;Concurrency_tag&gt;</div><div class="line">  (points.begin(), points.end(),</div><div class="line">   <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>(),</div><div class="line">   <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>(),</div><div class="line">   12); <span class="comment">// Number of neighbors</span></div></div><!-- fragment --><p>The pair of iterators is replaced by a range and the optional parameters (than can be deduced automatically in simple cases) are moved to the end of the function in a single named parameter object (see <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/index.html#BGLNamedParameters">Named Parameters</a>). The code translated to the current API becomes:</p>
<div class="fragment"><div class="line">std::vector&lt;PointVectorPair&gt; points;</div><div class="line"></div><div class="line"><span class="comment">// New API</span></div><div class="line">CGAL::jet_estimate_normals&lt;Concurrency_tag&gt;</div><div class="line">  (points,</div><div class="line">   12, <span class="comment">// Number of neighbors</span></div><div class="line">   CGAL::parameters::point_map (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>()).</div><div class="line">   normal_map (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>()));</div></div><!-- fragment --><p>Please refer to the <a class="el" href="group__PkgPointSetProcessing3Ref.html">Reference Manual</a> for the detailed API of the Point Set Processing functions.</p>
<h1><a class="anchor" id="Point_set_processing_3InputOutput"></a>
Input/Output</h1>
<h2><a class="anchor" id="Point_set_processing_3Points_io"></a>
Points And Normals</h2>
<p>CGAL provides functions to read and write sets of points (possibly with normals) from the following file formats:</p>
<ul>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/IOStreamSupportedFileFormats.html#IOStreamXYZ">XYZ </a> (ASCII file three point coordinates <code>x y z</code> per line or three point coordinates and three normal vector coordinates <code>x y z nx ny nz</code> per line)</li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/IOStreamSupportedFileFormats.html#IOStreamOFF">OFF (Object File Format) </a> – <a class="el" href="citelist.html#CITEREF_cgal:p-gmgv16-96">[11]</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/IOStreamSupportedFileFormats.html#IOStreamPLY">PLY (Polygon File Format) </a> – <a class="el" href="citelist.html#CITEREF_cgal:b-ply-11">[12]</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/IOStreamSupportedFileFormats.html#IOStreamLAS">LAS (Lidar Format) </a> – <a class="el" href="citelist.html#CITEREF_cgal:asprs-lasf-13">[1]</a> This format does not handle normals and requires the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartyLASlib">LASlib</a> library.</li>
</ul>
<p>All of the functions in <a class="el" href="group__PkgPointSetProcessing3IO.html">I/O Functions</a> (with the exception of the LAS format) can read and write either points alone or points with normals (depending on whether the <code>normal_map</code> named parameter is used by the user or not). Note that the PLY format handles both ASCII and binary formats. In addition, PLY and LAS are extensible formats that can embed additional properties. These can also be read by CGAL (see Section <a class="el" href="index.html#Point_set_processing_3Properties_io">Points With Properties</a>).</p>
<h3><a class="anchor" id="Point_set_processing_3Example_io"></a>
Example</h3>
<p>The following example reads a point set from an input file and writes it to a file, both in the XYZ format. Positions and normals are stored in pairs and accessed through property maps. <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2read_write_xyz_point_set_example_8cpp-example.html">Point_set_processing_3/read_write_xyz_point_set_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_xyz_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_xyz_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span> <span class="comment">// defines std::pair</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"></div><div class="line"><span class="comment">// Point with normal vector stored as a std::pair.</span></div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Point, Vector&gt; Pwn;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/oni.pwn"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Reads a .xyz point set file in points[].</span></div><div class="line">  <span class="comment">// Note: read_points() requires an output iterator</span></div><div class="line">  <span class="comment">// over points and as well as property maps to access each</span></div><div class="line">  <span class="comment">// point position and normal.</span></div><div class="line">  std::vector&lt;Pwn&gt; points;</div><div class="line">  <span class="keywordflow">if</span>(!CGAL::IO::read_XYZ(fname,</div><div class="line">                         std::back_inserter(points),</div><div class="line">                         CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Pwn&gt;</a>())</div><div class="line">                                          .normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;Pwn&gt;</a>())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Saves point set.</span></div><div class="line">  <span class="comment">// Note: write_XYZ() requires property maps to access each</span></div><div class="line">  <span class="comment">// point position and normal.</span></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IOXyz.html#ga1991ab8d312de62ddd907f81890ed039">CGAL::IO::write_XYZ</a>(<span class="stringliteral">"oni_copy.xyz"</span>, points,</div><div class="line">                          CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Pwn&gt;</a>())</div><div class="line">                                           .normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;Pwn&gt;</a>())</div><div class="line">                                           .stream_precision(17)))</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Point_set_processing_3Properties_io"></a>
Points With Properties</h2>
<p>PLY files are designed to embed an arbitrary number of additional attributes. More specifically, point sets may contain visibility vectors, RGB colors, intensity, etc. As it is not possible to provide dedicated functions to every possible combination of PLY properties, CGAL provides a simple way to read PLY properties and store them in any structure the user needs. Handling of LAS files works similarly with the difference that the property names and types are fixed and defined by the LAS standard.</p>
<p>Functions <code><a class="el" href="group__PkgPointSetProcessing3IOPly.html#gad9785e7191ba94d81fac841798aa1ddb" title="reads user-selected points properties from a .ply stream (ASCII or binary). ">read_PLY_with_properties()</a></code> and <code><a class="el" href="group__PkgPointSetProcessing3IOLas.html#ga5187fc18430a5e3c811f75da57a057ad" title="reads user-selected points properties from a .las or .laz stream. ">read_LAS_with_properties()</a></code> allow the user to read any property needed. The user must provide a set of property handlers that are used to instantiate number types and complex objects from PLY/LAS properties. This handlers are either:</p>
<ul>
<li>a pair consisting of a property map and of a single PLY/LAS property descriptor</li>
<li>a tuple consisting of a property map, a functor to construct the objects wanted and multiple PLY/LAS property descriptors</li>
</ul>
<p>Output functions <code><a class="el" href="group__PkgPointSetProcessing3IOPly.html#gac1fd90a9d5266e631c68cb31bfe31516" title="writes the range of points with properties using Polygon File Format (PLY). ">write_PLY_with_properties()</a></code> and <code><a class="el" href="group__PkgPointSetProcessing3IOLas.html#gafaeb3b48279532412ec422c90a7f05fc" title="writes the range of points with properties to a .las stream. ">write_LAS_with_properties()</a></code> work similarly.</p>
<h3><a class="anchor" id="Point_set_processing_3Example_ply_write"></a>
PLY Writing Example</h3>
<p>The following example shows how to call <code><a class="el" href="group__PkgPointSetProcessing3IOPly.html#gac1fd90a9d5266e631c68cb31bfe31516" title="writes the range of points with properties using Polygon File Format (PLY). ">write_PLY_with_properties()</a></code> to write a point set with points, RGB colors and intensity. Notice that in order to write a complex object, users need to provide an overload of <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1Output__rep.html">CGAL::Output_rep</a></code>.</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2write_ply_points_example_8cpp-example.html">Point_set_processing_3/write_ply_points_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_ply_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"><span class="keyword">typedef</span> std::array&lt;unsigned char, 4&gt; Color;</div><div class="line"></div><div class="line"><span class="comment">// Point with normal, color and intensity</span></div><div class="line"><span class="keyword">typedef</span> std::tuple&lt;Point, Color, int&gt; PCI;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;0, PCI&gt;</a> Point_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;1, PCI&gt;</a> Color_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;2, PCI&gt;</a> Intensity_map;</div><div class="line"></div><div class="line"><span class="comment">// Define how a color should be stored</span></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceCGAL.html">CGAL</a> {</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> F &gt;</div><div class="line"><span class="keyword">struct </span>Output_rep&lt; ::Color, F &gt; {</div><div class="line">  const ::Color&amp; c;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_specialized = <span class="keyword">true</span>;</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1Output__rep.html#a3ecfc0ce6d2e5db55ad05d08c549ce27">Output_rep</a> (const ::Color&amp; c) : c(c)</div><div class="line">  { }</div><div class="line">  std::ostream&amp; <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1Output__rep.html#a022b1af6b20bcd6957908d70b3c9136b">operator() </a>(std::ostream&amp; out)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">if</span> (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#gaf145cf5cbf5e27ebb907a8260002a5f3">IO::is_ascii</a>(out))</div><div class="line">      out &lt;&lt; int(c[0]) &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; int(c[1]) &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; int(c[2]) &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; int(c[3]);</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      out.write(reinterpret_cast&lt;const char*&gt;(&amp;c), <span class="keyword">sizeof</span>(c));</div><div class="line">    <span class="keywordflow">return</span> out;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line">} <span class="comment">// namespace CGAL</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>**)</div><div class="line">{</div><div class="line">  std::vector&lt;PCI&gt; points; <span class="comment">// store points</span></div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 10; ++ i)</div><div class="line">    points.push_back (std::make_tuple (Point (i / 10., i / 20., i / 30.),</div><div class="line">                                               <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__PkgSTLExtensionRef.html#ga6b9a3534a37aeb7d3095ec08801931d7">CGAL::make_array</a> (static_cast&lt;unsigned char&gt;(255 / (i + 1)),</div><div class="line">                                                                 static_cast&lt;unsigned char&gt;(192 / (i + 1)),</div><div class="line">                                                                 static_cast&lt;unsigned char&gt;(128 / (i + 1)),</div><div class="line">                                                                 static_cast&lt;unsigned char&gt;(64 / (i + 1))),</div><div class="line">                                               i));</div><div class="line"></div><div class="line">  std::ofstream f(<span class="stringliteral">"out.ply"</span>, std::ios::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a>(f); <span class="comment">// The PLY file will be written in the binary format</span></div><div class="line"></div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3IOPly.html#gac1fd90a9d5266e631c68cb31bfe31516">CGAL::IO::write_PLY_with_properties</a>(f, points,</div><div class="line">                                      <a class="code" href="group__PkgPointSetProcessing3IOPly.html#ga241c6df9d93e26ec7254ef6366cb7e5b">CGAL::make_ply_point_writer</a> (Point_map()),</div><div class="line">                                      std::make_tuple(Color_map(),</div><div class="line">                                                      <a class="code" href="structCGAL_1_1IO_1_1PLY__property.html">CGAL::IO::PLY_property&lt;unsigned char&gt;</a>(<span class="stringliteral">"red"</span>),</div><div class="line">                                                      <a class="code" href="structCGAL_1_1IO_1_1PLY__property.html">CGAL::IO::PLY_property&lt;unsigned char&gt;</a>(<span class="stringliteral">"green"</span>),</div><div class="line">                                                      <a class="code" href="structCGAL_1_1IO_1_1PLY__property.html">CGAL::IO::PLY_property&lt;unsigned char&gt;</a>(<span class="stringliteral">"blue"</span>),</div><div class="line">                                                      <a class="code" href="structCGAL_1_1IO_1_1PLY__property.html">CGAL::IO::PLY_property&lt;unsigned char&gt;</a>(<span class="stringliteral">"alpha"</span>)),</div><div class="line">                                  std::make_pair(Intensity_map(), <a class="code" href="structCGAL_1_1IO_1_1PLY__property.html">CGAL::IO::PLY_property&lt;int&gt;</a>(<span class="stringliteral">"intensity"</span>)));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="Point_set_processing_3Example_ply_read"></a>
PLY Reading Example</h3>
<p>The following example shows how to call <code><a class="el" href="group__PkgPointSetProcessing3IOPly.html#gad9785e7191ba94d81fac841798aa1ddb" title="reads user-selected points properties from a .ply stream (ASCII or binary). ">read_PLY_with_properties()</a></code> to read a point set with points, normals, RGB colors and intensity and stores these attributes in a user-defined container.</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2read_ply_points_with_colors_example_8cpp-example.html">Point_set_processing_3/read_ply_points_with_colors_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_ply_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"><span class="keyword">typedef</span> std::array&lt;unsigned char, 3&gt; Color;</div><div class="line"></div><div class="line"><span class="comment">// Point with normal, color and intensity</span></div><div class="line"><span class="keyword">typedef</span> std::tuple&lt;Point, Vector, Color, int&gt; PNCI;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;0, PNCI&gt;</a> Point_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;1, PNCI&gt;</a> Normal_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;2, PNCI&gt;</a> Color_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;3, PNCI&gt;</a> Intensity_map;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/colors.ply"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Reads a .ply point set file with normal vectors and colors</span></div><div class="line">  std::vector&lt;PNCI&gt; points; <span class="comment">// store points</span></div><div class="line">  std::ifstream in(fname);</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IOPly.html#gad9785e7191ba94d81fac841798aa1ddb">CGAL::IO::read_PLY_with_properties</a>(in, std::back_inserter(points),</div><div class="line">                                         <a class="code" href="group__PkgPointSetProcessing3IOPly.html#ga3a744d1f9a1c46955cf58866286166ff">CGAL::make_ply_point_reader</a>(Point_map()),</div><div class="line">                                         std::make_pair(Intensity_map(), CGAL::PLY_property&lt;int&gt;(<span class="stringliteral">"intensity"</span>)),</div><div class="line">                                         std::make_tuple(Color_map(),</div><div class="line">                                                         <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Construct__array.html">CGAL::Construct_array</a>(),</div><div class="line">                                                         <a class="code" href="structCGAL_1_1IO_1_1PLY__property.html">CGAL::IO::PLY_property&lt;unsigned char&gt;</a>(<span class="stringliteral">"red"</span>),</div><div class="line">                                                         <a class="code" href="structCGAL_1_1IO_1_1PLY__property.html">CGAL::IO::PLY_property&lt;unsigned char&gt;</a>(<span class="stringliteral">"green"</span>),</div><div class="line">                                                         <a class="code" href="structCGAL_1_1IO_1_1PLY__property.html">CGAL::IO::PLY_property&lt;unsigned char&gt;</a>(<span class="stringliteral">"blue"</span>)),</div><div class="line">                                         <a class="code" href="group__PkgPointSetProcessing3IOPly.html#gaab9a3f1eba6de91187b82af3087afe67">CGAL::IO::make_ply_normal_reader</a>(Normal_map())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Display points read</span></div><div class="line">  <span class="keywordflow">for</span>(std::size_t i = 0; i &lt; points.size (); ++ i)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> Point&amp; p = get&lt;0&gt;(points[i]);</div><div class="line">    <span class="keyword">const</span> Vector&amp; n = get&lt;1&gt;(points[i]);</div><div class="line">    <span class="keyword">const</span> Color&amp; c = get&lt;2&gt;(points[i]);</div><div class="line">    <span class="keywordtype">int</span> I = get&lt;3&gt;(points[i]);</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Point ("</span> &lt;&lt; p</div><div class="line">              &lt;&lt; <span class="stringliteral">") with normal ("</span> &lt;&lt; n</div><div class="line">              &lt;&lt; <span class="stringliteral">"), color ("</span> &lt;&lt; int(c[0]) &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; int(c[1]) &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; int(c[2])</div><div class="line">              &lt;&lt; <span class="stringliteral">") and intensity "</span> &lt;&lt; I &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="Point_set_processing_3Example_las_read"></a>
LAS Reading Example</h3>
<p>The following example shows how to call <code><a class="el" href="group__PkgPointSetProcessing3IOLas.html#ga5187fc18430a5e3c811f75da57a057ad" title="reads user-selected points properties from a .las or .laz stream. ">read_LAS_with_properties()</a></code> to read a point set with points and RGBI colors and stores these attributes in a user-defined container.</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2read_las_example_8cpp-example.html">Point_set_processing_3/read_las_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_las_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> std::array&lt;unsigned short, 4&gt; Color;</div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Point, Color&gt; PointWithColor;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* fname = (argc&gt;1) ? argv[1] : <span class="stringliteral">"data/pig_points.las"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Reads a .las point set file with normal vectors and colors</span></div><div class="line">  std::ifstream in(fname, std::ios_base::binary);</div><div class="line">  std::vector&lt;PointWithColor&gt; points; <span class="comment">// store points</span></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IOLas.html#ga5187fc18430a5e3c811f75da57a057ad">CGAL::IO::read_LAS_with_properties</a>(in, std::back_inserter (points),</div><div class="line">                                         <a class="code" href="group__PkgPointSetProcessing3IOLas.html#gac807a7bbde008f9707a1cf697e3eb64c">CGAL::IO::make_las_point_reader</a>(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointWithColor&gt;</a>()),</div><div class="line">                                         std::make_tuple(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointWithColor&gt;</a>(),</div><div class="line">                                                         <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Construct__array.html">CGAL::Construct_array</a>(),</div><div class="line">                                                         CGAL::IO::LAS_property::R(),</div><div class="line">                                                         CGAL::IO::LAS_property::G(),</div><div class="line">                                                         CGAL::IO::LAS_property::B(),</div><div class="line">                                                         CGAL::IO::LAS_property::I())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(std::size_t i = 0; i &lt; points.size(); ++ i)</div><div class="line">    std::cout &lt;&lt; points[i].first &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/index.html#IOstreamPointSetIO">Point Set IO</a></dd></dl>
<h1><a class="anchor" id="Point_set_processing_3Spacing"></a>
Average Spacing</h1>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga8b330397a3fb68176c851fd7d214b513" title="Computes average spacing from k nearest neighbors. ">compute_average_spacing()</a></code> computes the average spacing of all input points to their <code>k</code> nearest neighbor points, <code>k</code> being specified by the user. As it provides an order of a point set density, this function is used downstream the surface reconstruction pipeline to automatically determine some parameters such as output mesh sizing for surface reconstruction.</p>
<h2><a class="anchor" id="Point_set_processing_3Example_average_spacing"></a>
Example</h2>
<p>The following example reads a point set in the <code>xyz</code> format and computes the average spacing. <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classIndex.html">Index</a>, position and color are stored in a tuple and accessed through property maps. <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2average_spacing_example_8cpp-example.html">Point_set_processing_3/average_spacing_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/compute_average_spacing.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/tuple/tuple.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"></div><div class="line"><span class="comment">// Data type := index, followed by the point, followed by three integers that</span></div><div class="line"><span class="comment">// define the Red Green Blue color of the point.</span></div><div class="line"><span class="keyword">typedef</span> boost::tuple&lt;int, Point, int, int, int&gt; IndexedPointWithColorTuple;</div><div class="line"></div><div class="line"><span class="comment">// Concurrency</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a> Concurrency_tag;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname = (argc&gt;1)?argv[1]:<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/sphere_20k.xyz"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Reads a file in points.</span></div><div class="line">  <span class="comment">// As the point is the second element of the tuple (that is with index 1)</span></div><div class="line">  <span class="comment">// we use a property map that accesses the 1st element of the tuple.</span></div><div class="line"></div><div class="line">  std::vector&lt;IndexedPointWithColorTuple&gt; points;</div><div class="line">  <span class="keywordflow">if</span> (!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname, std::back_inserter(points),</div><div class="line">                             CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;1, IndexedPointWithColorTuple&gt;</a>())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Initialize index and RGB color fields in tuple.</span></div><div class="line">  <span class="comment">// As the index and RGB color are respectively the first and third-fifth elements</span></div><div class="line">  <span class="comment">// of the tuple we use a get function from the property map that accesses the 0</span></div><div class="line">  <span class="comment">// and 2-4th elements of the tuple.</span></div><div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; points.size(); i++)</div><div class="line">  {</div><div class="line">    points[i].get&lt;0&gt;() = i; <span class="comment">// set index value of tuple to i</span></div><div class="line"></div><div class="line">    points[i].get&lt;2&gt;() = 0; <span class="comment">// set RGB color to black</span></div><div class="line">    points[i].get&lt;3&gt;() = 0;</div><div class="line">    points[i].get&lt;4&gt;() = 0;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Computes average spacing.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nb_neighbors = 6; <span class="comment">// 1 ring</span></div><div class="line">  FT average_spacing = CGAL::compute_average_spacing&lt;Concurrency_tag&gt;(</div><div class="line">                         points, nb_neighbors,</div><div class="line">                         CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;1,IndexedPointWithColorTuple&gt;</a>()));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Average spacing: "</span> &lt;&lt; average_spacing &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>Note that other functions such as centroid or bounding volumes are found in other CGAL components:</p>
<ul>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__centroid__grp.html#gacc395064255dfefdb1420309db234210">centroid()</a></code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Principal_component_analysis.tag:../Principal_component_analysis/" href="../Principal_component_analysis/group__PkgPrincipalComponentAnalysisDbb.html#ga7674a40dcf2ee64bebc89d97bf801c1d">bounding_box()</a></code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Bounding_volumes.tag:../Bounding_volumes/" href="../Bounding_volumes/classCGAL_1_1Min__sphere__of__spheres__d.html">Min_sphere_of_spheres_d</a>&lt;Traits&gt;</code></li>
</ul>
<h1><a class="anchor" id="Point_set_processing_3Scale"></a>
Automatic Scale Estimation</h1>
<p>Point sets are often used to sample objects with a higher dimension, typically a curve in 2D or a surface in 3D. In such cases, finding the scale of the object is crucial, that is to say finding the minimal number of points (or the minimal local range) such that the subset of points has the appearance of a curve in 2D or a surface in 3D <a class="el" href="citelist.html#CITEREF_cgal:gcsa-nasr-13">[2]</a>.</p>
<p>CGAL provides two functions that automatically estimate the scale of a 2D point set sampling a curve or a 3D point set sampling a surface:</p>
<ul>
<li><code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga8c6af1df54e336bd0b9a2de6b909bccf" title="Estimates the global scale in a K nearest neighbors sense. ">estimate_global_k_neighbor_scale()</a></code></li>
<li><code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga28fe6443638647be0874b283085eb2cd" title="Estimates the global scale in a range sense. ">estimate_global_range_scale()</a></code></li>
</ul>
<p>Functions such as <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga7757ef9b3900e42fde26f5a0ac56e20f" title="Merges points which belong to the same cell of a grid of cell size = epsilon. ">grid_simplify_point_set()</a></code> require a range scale while <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga078e25209373cab0e1f3524202489771" title="Estimates normal directions of the range of points using jet fitting on the nearest neighbors...">jet_estimate_normals()</a></code>, <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga50c708584a8219847ce04f636dcad4b3" title="Removes outliers: ">remove_outliers()</a></code> or <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gaab0fd78ef3e46c4256e9a1145a9d118e" title="Estimates normal directions of the range of points using the Voronoi Covariance Measure with a radius...">vcm_estimate_normals()</a></code> are examples of functions that accepts both a K neighbor scale or a range scale.</p>
<p>In some specific cases, the scale of a point set might not be homogeneous (for example if the point set contains variable noise). CGAL also provides two functions that automatically estimate the scales of a point set at a set of user-defined query points:</p>
<ul>
<li><code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga6e2493a424482f07d766f12fedefedd0" title="Estimates the local scale in a K nearest neighbors sense on a set of user-defined query points...">estimate_local_k_neighbor_scales()</a></code></li>
<li><code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gaf45220685eff6649d29f600eb66fb6c1" title="Estimates the local scale in a range sense on a set of user-defined query points. ...">estimate_local_range_scales()</a></code></li>
</ul>
<p>The 4 functions presented here work both with 2D points and 3D points and they shouldn't be used if the point sets do not sample a curve in 2D or a surface in 3D.</p>
<h2><a class="anchor" id="Point_set_processing_3Example_scale_estimation_global"></a>
Global Scale Example</h2>
<p>The following example reads a 3D point set in the <code>xyz</code> format and:</p>
<ul>
<li>Estimates the K neighbor global scale</li>
<li>Uses it to smooth the point set</li>
<li>Estimates the range global scale</li>
<li>Uses it to simplify the point set</li>
</ul>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2scale_estimation_example_8cpp-example.html">Point_set_processing_3/scale_estimation_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/estimate_scale.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/jet_smooth_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/grid_simplify_point_set.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Timer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Memory_sizer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Concurrency</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a> Concurrency_tag;</div><div class="line"></div><div class="line"><span class="comment">// Types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point_3;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname = (argc&gt;1)?argv[1]:<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/sphere_20k.xyz"</span>);</div><div class="line"></div><div class="line">  CGAL::Timer task_timer;</div><div class="line"></div><div class="line">  <span class="comment">// read input</span></div><div class="line">  std::vector&lt;Point_3&gt; points;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname, std::back_inserter(points)))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: can't read input file"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// estimate k scale</span></div><div class="line">  task_timer.start();</div><div class="line">  std::size_t k_scale = <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga8c6af1df54e336bd0b9a2de6b909bccf">CGAL::estimate_global_k_neighbor_scale</a> (points);</div><div class="line">  task_timer.stop();</div><div class="line"></div><div class="line">  <span class="comment">// Example: use estimated k as scale for jet smoothing</span></div><div class="line">  CGAL::jet_smooth_point_set&lt;Concurrency_tag&gt;(points, <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(k_scale));</div><div class="line"></div><div class="line">  <span class="comment">// estimate range scale</span></div><div class="line">  task_timer.start();</div><div class="line">  FT range_scale = <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga28fe6443638647be0874b283085eb2cd">CGAL::estimate_global_range_scale</a> (points);</div><div class="line">  task_timer.stop();</div><div class="line"></div><div class="line">  <span class="comment">// Example: use estimated range for grid simplification</span></div><div class="line">  points.erase(<a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga7757ef9b3900e42fde26f5a0ac56e20f">CGAL::grid_simplify_point_set</a>(points, range_scale), points.end());</div><div class="line"></div><div class="line">  <span class="comment">// print some information on runtime</span></div><div class="line">  std::size_t memory = CGAL::Memory_sizer().virtual_size();</div><div class="line">  <span class="keywordtype">double</span> time = task_timer.time();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Scales computed in "</span> &lt;&lt; time &lt;&lt; <span class="stringliteral">" second(s) using "</span></div><div class="line">            &lt;&lt; (memory&gt;&gt;20) &lt;&lt; <span class="stringliteral">" MiB of memory:"</span> &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">" * Global K scale: "</span> &lt;&lt; k_scale &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">" * Global range scale: "</span> &lt;&lt; range_scale &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h2><a class="anchor" id="Point_set_processing_3Example_scale_estimation_local"></a>
Local Scales Example</h2>
<p>This second example generates a 2D point set sampling a circle with variable noise. It then estimates the scale at 3 different query points in the domain.</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2scale_estimation_2d_example_8cpp-example.html">Point_set_processing_3/scale_estimation_2d_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/estimate_scale.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Random.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a> Point_2;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span>, <span class="keywordtype">char</span>**)</div><div class="line">{</div><div class="line">  std::vector&lt;Point_2&gt; samples;</div><div class="line">  samples.reserve (100000);</div><div class="line"></div><div class="line">  <span class="comment">// Generate circle with gradually variable noise</span></div><div class="line">  <span class="comment">//  - noise-free for points with x close to (-1)</span></div><div class="line">  <span class="comment">//  - noisy for points with x close to (+1)</span></div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; 100000; ++ i)</div><div class="line">    {</div><div class="line">      FT theta = CGAL::get_default_random().get_double(0, 2. * CGAL_PI);</div><div class="line">      FT noise = 0.5 * (std::cos(theta) + 1.) * CGAL::get_default_random().get_double(0., 0.2);</div><div class="line">      <span class="keywordtype">int</span> mult = (CGAL::get_default_random().get_bool() ? 1 : -1);</div><div class="line">      samples.push_back (Point_2 (std::cos(theta) * (1. + mult * noise * noise),</div><div class="line">                                  std::sin(theta) * (1. + mult * noise * noise)));</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="comment">// Search for local scales on 3 different locations</span></div><div class="line">  std::vector&lt;Point_2&gt; queries;</div><div class="line">  queries.reserve (3);</div><div class="line">  queries.push_back (Point_2 (-1., 0.));</div><div class="line">  queries.push_back (Point_2 (0., 1.));</div><div class="line">  queries.push_back (Point_2 (1., 0.));</div><div class="line"></div><div class="line">  std::vector&lt;std::size_t&gt; k_scales;</div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga6e2493a424482f07d766f12fedefedd0">CGAL::estimate_local_k_neighbor_scales</a> (samples,</div><div class="line">                                          queries,</div><div class="line">                                          std::back_inserter (k_scales));</div><div class="line"></div><div class="line">  <span class="comment">// Display results</span></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"K-Scales found:"</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">" - On noise-free region: "</span> &lt;&lt; k_scales[0] &lt;&lt; std::endl <span class="comment">// Should be small</span></div><div class="line">            &lt;&lt; <span class="stringliteral">" - On moderately noisy region: "</span> &lt;&lt; k_scales[1] &lt;&lt; std::endl <span class="comment">// Should be higher</span></div><div class="line">            &lt;&lt; <span class="stringliteral">" - On very noisy region: "</span> &lt;&lt; k_scales[2] &lt;&lt; std::endl; <span class="comment">// Should be even higher</span></div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h1><a class="anchor" id="Point_set_processing_3Registration"></a>
Registration</h1>
<p>CGAL provides two functions as wrapper for the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartyOpenGR">OpenGR</a> library <a class="el" href="citelist.html#CITEREF_cgal:m-ogr-17">[7]</a>, and two functions as wrapper for the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartylibpointmatcher">PointMatcher</a> library :</p>
<ul>
<li><code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga1a077db2cedb624e4b4b0ed492598db0" title="Computes the registration of point_set_2 with respect to point_set_1 and returns the corresponding af...">CGAL::OpenGR::compute_registration_transformation()</a></code> computes the registration of one point set w.r.t. another in the form of a <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Aff__transformation__3.html">CGAL::Aff_transformation_3</a></code> object, using the Super4PCS algorithm <a class="el" href="citelist.html#CITEREF_cgal:mam-sffgp-14">[8]</a>;</li>
<li><code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga2d2e21a8a49472a5ed1254f42978608e" title="Computes the registration of point_set_2 with respect to point_set_1 and applies it. ">CGAL::OpenGR::register_point_sets()</a></code> computes the registration of one point set w.r.t. another and directly aligns it to it;</li>
<li><code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga365997b9b06c6576452ec6493b743f52" title="Computes the registration of point_set_2 with respect to point_set_1 and returns the corresponding af...">CGAL::pointmatcher::compute_registration_transformation()</a></code> computes the registration of one point set w.r.t. another in the form of a <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Aff__transformation__3.html">CGAL::Aff_transformation_3</a></code> object, using the ICP (Iterative Closest Point) algorithm;</li>
<li><code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gaa849870cbc74cee3f2f536c70aadf976" title="Computes the registration of point_set_2 with respect to point_set_1 and applies it. ">CGAL::pointmatcher::register_point_sets()</a></code> computes the registration of one point set w.r.t. another and directly aligns it to it.</li>
</ul>
<h2><a class="anchor" id="Point_set_processing_3Examples_registration_OpenGR"></a>
OpenGR Example</h2>
<p>The following example reads two point sets and aligns them using the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartyOpenGR">OpenGR</a> library, using the Super4PCS algorithm: <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2registration_with_OpenGR_8cpp-example.html">Point_set_processing_3/registration_with_OpenGR.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/OpenGR/compute_registration_transformation.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/OpenGR/register_point_sets.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> K;</div><div class="line"><span class="keyword">typedef</span> K::Point_3 Point_3;</div><div class="line"><span class="keyword">typedef</span> K::Vector_3 Vector_3;</div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Point_3, Vector_3&gt; Pwn;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Pwn&gt;</a> Point_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;Pwn&gt;</a> Normal_map;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>params = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL_1_1parameters.html">CGAL::parameters</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname1 = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/hippo1.ply"</span>);</div><div class="line">  <span class="keyword">const</span> std::string fname2 = (argc&gt;2) ? argv[2] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/hippo2.ply"</span>);</div><div class="line"></div><div class="line">  std::vector&lt;Pwn&gt; pwns1, pwns2;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname1, std::back_inserter(pwns1),</div><div class="line">                            CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Pwn&gt;</a>())</div><div class="line">                                             .normal_map(Normal_map())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname1 &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname2, std::back_inserter(pwns2),</div><div class="line">                            CGAL::parameters::point_map(Point_map())</div><div class="line">                                             .normal_map(Normal_map())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname2 &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// EITHER call the registration method Super4PCS from OpenGR to get the transformation to apply to pwns2</span></div><div class="line">  <span class="comment">// std::pair&lt;K::Aff_transformation_3, double&gt; res =</span></div><div class="line">    <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga1a077db2cedb624e4b4b0ed492598db0">CGAL::OpenGR::compute_registration_transformation</a>(pwns1, pwns2,</div><div class="line">                                                      params::point_map(Point_map())</div><div class="line">                                                             .normal_map(Normal_map())</div><div class="line">                                                             .number_of_samples(200)</div><div class="line">                                                             .maximum_running_time(60)</div><div class="line">                                                             .accuracy(0.01),</div><div class="line">                                                      params::point_map(Point_map())</div><div class="line">                                                             .normal_map(Normal_map()));</div><div class="line"></div><div class="line">  <span class="comment">// OR call the registration method Super4PCS from OpenGR and apply the transformation to pwn2</span></div><div class="line">  <span class="keywordtype">double</span> score =</div><div class="line">    <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga2d2e21a8a49472a5ed1254f42978608e">CGAL::OpenGR::register_point_sets</a>(pwns1, pwns2,</div><div class="line">                                      params::point_map(Point_map())</div><div class="line">                                             .normal_map(Normal_map())</div><div class="line">                                             .number_of_samples(200)</div><div class="line">                                             .maximum_running_time(60)</div><div class="line">                                             .accuracy(0.01),</div><div class="line">                                      params::point_map(Point_map())</div><div class="line">                                             .normal_map(Normal_map()));</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga5822feba4449f0492363611620b877c0">CGAL::IO::write_points</a>(<span class="stringliteral">"pwns2_aligned.ply"</span>, pwns2,</div><div class="line">                             CGAL::parameters::point_map(Point_map())</div><div class="line">                                              .normal_map(Normal_map())</div><div class="line">                                              .stream_precision(17)))</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Registration score: "</span> &lt;&lt; score &lt;&lt; <span class="stringliteral">".\n"</span></div><div class="line">            &lt;&lt; <span class="stringliteral">"Transformed version of "</span> &lt;&lt; fname2</div><div class="line">            &lt;&lt; <span class="stringliteral">" written to pwn2_aligned.ply.\n"</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><p><a class="el" href="index.html#fig__Point_set_processing_3tableRegistrationRegistration_visualization_table">Figure 80.4</a> demonstrates visualization of a scan data before and after different registration methods are applied, including the OpenGR registration method. To obtain the results for OpenGR registration in the visualization table, above-mentioned example was used.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_OpenGR_parameter_number_of_samples"></a>
Parameter: number_of_samples</h3>
<p>Input clouds are sub-sampled prior exploration, to ensure fast computations. Super4PCS has a linear complexity w.r.t. the number of input samples, allowing to use larger values than 4PCS. Simple geometry with large overlap can be matched with only 200 samples. However, with Super4PCS, smaller details can be used during the process by using up to thousands of points. There is no theoretical limit to this parameter; however, using too large values leads to very a large congruent set, which requires more time and memory to be explored.</p>
<p>Using a large number of samples is recommended when:</p>
<ul>
<li>geometrical details are required to perform the matching, for instance to disambiguate between several similar configurations,</li>
<li>the clouds have a very low overlap: using a too sparse sampling can result in an empty overlapping area, causing the algorithm to fail,</li>
<li>the clouds are very noisy, and require a dense sampling.</li>
</ul>
<p>Note that Super4PCS is a global registration algorithm, which finds a good approximate of the rigid transformation aligning two clouds. Increasing the number of samples in order to get a fine registration is not optimal: it is usually faster to use fewer samples, and refine the transformation using a local algorithm, like the ICP, or its variant SparseICP.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_OpenGR_parameter_accuracy"></a>
Parameter: accuracy</h3>
<p>This parameter controls the registration accuracy: setting a small value means that the two clouds need to be very close to be considered as well aligned. It is expressed in scene units.</p>
<p>A simple way to understand its impact is to consider the computation of the Largest Common Pointset (LCP), the metric used to verify how aligned the clouds are. For each transformation matrix produced by Super4PCS, <a class="el" href="namespaceCGAL_1_1OpenGR.html">OpenGR</a> computes the LCP measure by considering a shell around the reference cloud, and count the percentage of points of the target cloud lying in the shell. The thickness of the shell is defined by the parameter delta (accuracy).</p>
<p>Using too wide values will slow down the algorithm by increasing the size of the congruent set, while using to small values prevents to find a solution. This parameter impacts other steps of the algorithm, see the paper <a class="el" href="citelist.html#CITEREF_cgal:mam-sffgp-14">[8]</a> for more details.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_OpenGR_parameter_normal"></a>
Parameter: maximum normal deviation</h3>
<p>This parameter sets an angle threshold above which two pairs of points are discarded as candidates for matching. It is expressed in degrees.</p>
<p>The default value is 90° (no filtering). Decreasing this value allows to decrease the computation time by being more selective on candidates. Using too small values might result in ignoring candidates that should indeed have been matched and may thus result in a quality decrease.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_OpenGR_parameter_overlap"></a>
Parameter: overlap</h3>
<p>Ratio of expected overlap between the two point sets: it is ranging between 0 (no overlap) to 1 (100% overlap).</p>
<p>The overlap parameter controls the size of the basis used for registration, as shown below:</p>
<p><a class="anchor" id="fig__Point_set_processing_3figOpenGR_parameter_overlap"></a></p><div class="image">
<img src="super4PCS_overlap.png" alt="super4PCS_overlap.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figOpenGR_parameter_overlap">Figure 80.3</a> The effect of varying overlap parameter on the size of the basis used for registration. The overlap is smaller for left (a) than right (b).  </div> <br /> 
<p>Usually, the larger the overlap, the faster the algorithm. When the overlap is unknown, a simple way to set this parameter is to start from 100% overlap, and decrease the value until obtaining a good result. Using too small values will slow down the algorithm, and reduce the accuracy of the result.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_OpenGR_parameter_maximum_running_time"></a>
Parameter: maximum_running_time</h3>
<p>Maximum number of seconds after which the algorithm stops. Super4PCS explores the transformation space to align the two input clouds. Since the exploration is performed randomly, it is recommended to use a large time value to explore the whole space.</p>
<h2><a class="anchor" id="Point_set_processing_3Examples_registration_PointMatcher"></a>
PointMatcher Example</h2>
<p>The following example reads two point sets and aligns them using the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartylibpointmatcher">PointMatcher</a> library, using the ICP algorithm. It also shows how to customize ICP algorithm by using possible configurations: <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2registration_with_pointmatcher_8cpp-example.html">Point_set_processing_3/registration_with_pointmatcher.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Aff_transformation_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/aff_transformation_tags.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/pointmatcher/compute_registration_transformation.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/pointmatcher/register_point_sets.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> K;</div><div class="line"><span class="keyword">typedef</span> K::Point_3 Point_3;</div><div class="line"><span class="keyword">typedef</span> K::Vector_3 Vector_3;</div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Point_3, Vector_3&gt; Pwn;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Pwn&gt;</a> Point_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;Pwn&gt;</a> Normal_map;</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Weight_map</div><div class="line">{</div><div class="line">  <span class="keyword">typedef</span> Pwn key_type;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> K::FT value_type;</div><div class="line">  <span class="keyword">typedef</span> value_type reference;</div><div class="line">  <span class="keyword">typedef</span> boost::readable_property_map_tag category;</div><div class="line"></div><div class="line">  <span class="keyword">typedef</span> Weight_map Self;</div><div class="line">  <span class="keyword">friend</span> reference <span class="keyword">get</span>(<span class="keyword">const</span> Self&amp;, <span class="keyword">const</span> key_type&amp;) { <span class="keywordflow">return</span> value_type(1); }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>params = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL_1_1parameters.html">CGAL::parameters</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname1 = (argc&gt;1)?argv[1]:<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/hippo1.ply"</span>);</div><div class="line">  <span class="keyword">const</span> std::string fname2 = (argc&gt;2)?argv[2]:<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/hippo2.ply"</span>);</div><div class="line"></div><div class="line">  std::vector&lt;Pwn&gt; pwns1, pwns2;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname1, std::back_inserter(pwns1),</div><div class="line">                            CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Pwn&gt;</a>())</div><div class="line">                                             .normal_map(Normal_map())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname1 &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname2, std::back_inserter(pwns2),</div><div class="line">                            CGAL::parameters::point_map(Point_map())</div><div class="line">                                             .normal_map(Normal_map())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname2 &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="comment">// Prepare ICP config</span></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="keyword">using</span> <a class="code" href="structCGAL_1_1pointmatcher_1_1ICP__config.html">CGAL::pointmatcher::ICP_config</a>;</div><div class="line"></div><div class="line">  <span class="comment">// Possible config modules/components: https://libpointmatcher.readthedocs.io/en/latest/Configuration/#configuration-of-an-icp-chain</span></div><div class="line">  <span class="comment">// See documentation of optional named parameters for CGAL PM ICP configuration / pointmatcher config module mapping</span></div><div class="line"></div><div class="line">  <span class="comment">// Prepare point set 1 filters (PM::ReferenceDataPointsFilters)</span></div><div class="line">  std::vector&lt;ICP_config&gt; point_set_1_filters;</div><div class="line">  point_set_1_filters.push_back( ICP_config { <span class="comment">/*.name=*/</span><span class="stringliteral">"MinDistDataPointsFilter"</span>       , <span class="comment">/*.params=*/</span>{ {<span class="stringliteral">"minDist"</span>, <span class="stringliteral">"0.5"</span> }}  } );</div><div class="line">  point_set_1_filters.push_back( ICP_config { <span class="comment">/*.name=*/</span><span class="stringliteral">"RandomSamplingDataPointsFilter"</span>, <span class="comment">/*.params=*/</span>{ {<span class="stringliteral">"prob"</span>   , <span class="stringliteral">"0.05"</span>}}  } );</div><div class="line"></div><div class="line">  <span class="comment">// Prepare point set 2 filters (PM::ReadingDataPointsFilters)</span></div><div class="line">  std::vector&lt;ICP_config&gt; point_set_2_filters;</div><div class="line">  point_set_2_filters.push_back( ICP_config { <span class="comment">/*.name=*/</span><span class="stringliteral">"MinDistDataPointsFilter"</span>       , <span class="comment">/*.params=*/</span>{ {<span class="stringliteral">"minDist"</span>, <span class="stringliteral">"0.5"</span> }}  } );</div><div class="line">  point_set_2_filters.push_back( ICP_config { <span class="comment">/*.name=*/</span><span class="stringliteral">"RandomSamplingDataPointsFilter"</span>, <span class="comment">/*.params=*/</span>{ {<span class="stringliteral">"prob"</span>   , <span class="stringliteral">"0.05"</span>}}  } );</div><div class="line"></div><div class="line">  <span class="comment">// Prepare matcher function</span></div><div class="line">  ICP_config matcher { <span class="comment">/*.name=*/</span><span class="stringliteral">"KDTreeMatcher"</span>, <span class="comment">/*.params=*/</span>{ {<span class="stringliteral">"knn"</span>, <span class="stringliteral">"1"</span>}, {<span class="stringliteral">"epsilon"</span>, <span class="stringliteral">"3.16"</span>} } };</div><div class="line"></div><div class="line">  <span class="comment">// Prepare outlier filters</span></div><div class="line">  <span class="comment">// NOTE: `GenericDescriptorOutlierFilter` supports only one `descName` that is `weights`!</span></div><div class="line">  std::vector&lt;ICP_config&gt; outlier_filters;</div><div class="line">  outlier_filters.push_back( ICP_config { <span class="comment">/*.name=*/</span><span class="stringliteral">"TrimmedDistOutlierFilter"</span>, <span class="comment">/*.params=*/</span>{ {<span class="stringliteral">"ratio"</span>, <span class="stringliteral">"0.75"</span> }}  } );</div><div class="line">  outlier_filters.push_back( ICP_config { <span class="comment">/*.name=*/</span><span class="stringliteral">"GenericDescriptorOutlierFilter"</span>, <span class="comment">/*.params=*/</span>{ {<span class="stringliteral">"descName"</span>, <span class="stringliteral">"weights"</span> }}  } );</div><div class="line"></div><div class="line">  <span class="comment">// Prepare error minimizer</span></div><div class="line">  ICP_config error_minimizer { <span class="comment">/*.name=*/</span><span class="stringliteral">"PointToPointErrorMinimizer"</span>, <span class="comment">/*.params=*/</span>{ } };</div><div class="line"></div><div class="line">  <span class="comment">// Prepare transformation checker</span></div><div class="line">  std::vector&lt;ICP_config&gt; transformation_checkers;</div><div class="line">  transformation_checkers.push_back( ICP_config { <span class="comment">/*.name=*/</span><span class="stringliteral">"CounterTransformationChecker"</span>, <span class="comment">/*.params=*/</span>{ {<span class="stringliteral">"maxIterationCount"</span>, <span class="stringliteral">"150"</span> }}  } );</div><div class="line">  transformation_checkers.push_back( ICP_config { <span class="comment">/*.name=*/</span><span class="stringliteral">"DifferentialTransformationChecker"</span>, <span class="comment">/*.params=*/</span>{ {<span class="stringliteral">"minDiffRotErr"</span>  , <span class="stringliteral">"0.001"</span> },</div><div class="line">                                                                                                       {<span class="stringliteral">"minDiffTransErr"</span>, <span class="stringliteral">"0.01"</span>  },</div><div class="line">                                                                                                       {<span class="stringliteral">"smoothLength"</span>   , <span class="stringliteral">"4"</span>     } }</div><div class="line">                                                } );</div><div class="line">  <span class="comment">// Prepare inspector</span></div><div class="line">  ICP_config inspector { <span class="comment">/*.name=*/</span><span class="stringliteral">"NullInspector"</span>, <span class="comment">/*.params=*/</span>{ } };</div><div class="line"></div><div class="line">  <span class="comment">// Prepare logger</span></div><div class="line">  ICP_config logger { <span class="comment">/*.name=*/</span><span class="stringliteral">"FileLogger"</span>, <span class="comment">/*.params=*/</span>{ } };</div><div class="line"></div><div class="line">  <span class="keyword">const</span> K::Aff_transformation_3 identity_transform = K::Aff_transformation_3(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Identity__transformation.html">CGAL::Identity_transformation</a>());</div><div class="line"></div><div class="line">  <span class="comment">// EITHER call the ICP registration method pointmatcher to get the transformation to apply to pwns2</span></div><div class="line">  std::pair&lt;K::Aff_transformation_3, bool&gt; res =</div><div class="line">    <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga365997b9b06c6576452ec6493b743f52">CGAL::pointmatcher::compute_registration_transformation</a></div><div class="line">      (pwns1, pwns2,</div><div class="line">       params::point_map(Point_map()).normal_map(Normal_map()).scalar_map(Weight_map())</div><div class="line">                                     .point_set_filters(point_set_1_filters)</div><div class="line">                                     .matcher(matcher)</div><div class="line">                                     .outlier_filters(outlier_filters)</div><div class="line">                                     .error_minimizer(error_minimizer)</div><div class="line">                                     .transformation_checkers(transformation_checkers)</div><div class="line">                                     .inspector(inspector)</div><div class="line">                                     .logger(logger),</div><div class="line">       params::point_map(Point_map()).normal_map(Normal_map()).scalar_map(Weight_map())</div><div class="line">                                     .point_set_filters(point_set_2_filters)</div><div class="line">                                     .transformation(identity_transform) <span class="comment">/* initial transform for pwns2.</span></div><div class="line"><span class="comment">                                                                          * default value is already identity transform.</span></div><div class="line"><span class="comment">                                                                          * a proper initial transform could be given, for example,</span></div><div class="line"><span class="comment">                                                                          * a transform returned from a coarse registration algorithm.</span></div><div class="line"><span class="comment">                                                                          * */</span></div><div class="line">       );</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> converged = <span class="keyword">false</span>;</div><div class="line">  <span class="keywordflow">do</span></div><div class="line">  {</div><div class="line">    <span class="comment">// OR call the ICP registration method from pointmatcher and apply the transformation to pwn2</span></div><div class="line">    converged =</div><div class="line">      <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#gaa849870cbc74cee3f2f536c70aadf976">CGAL::pointmatcher::register_point_sets</a></div><div class="line">      (pwns1, pwns2,</div><div class="line">       params::point_map(Point_map()).normal_map(Normal_map())</div><div class="line">       .point_set_filters(point_set_1_filters)</div><div class="line">       .matcher(matcher)</div><div class="line">       .outlier_filters(outlier_filters)</div><div class="line">       .error_minimizer(error_minimizer)</div><div class="line">       .transformation_checkers(transformation_checkers)</div><div class="line">       .inspector(inspector)</div><div class="line">       .logger(logger),</div><div class="line">       params::point_map(Point_map()).normal_map(Normal_map())</div><div class="line">       .point_set_filters(point_set_2_filters)</div><div class="line">       .transformation(res.first) <span class="comment">/* pass the above computed transformation as initial transformation.</span></div><div class="line"><span class="comment">                                   * as a result, the registration will require less iterations to converge.</span></div><div class="line"><span class="comment">                                   * */</span></div><div class="line">        );</div><div class="line"></div><div class="line">    <span class="comment">// Algorithm may randomly not converge, repeat until it does</span></div><div class="line">    <span class="keywordflow">if</span> (converged)</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">"Success"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">"Did not converge, try again"</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">while</span> (!converged);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga5822feba4449f0492363611620b877c0">CGAL::IO::write_points</a>(<span class="stringliteral">"pwns2_aligned.ply"</span>, pwns2,</div><div class="line">                             CGAL::parameters::point_map(Point_map()).normal_map(Normal_map())))</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Transformed version of "</span> &lt;&lt; fname2 &lt;&lt; <span class="stringliteral">" written to pwn2_aligned.ply.\n"</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><p><a class="el" href="index.html#fig__Point_set_processing_3tableRegistrationRegistration_visualization_table">Figure 80.4</a> demonstrates visualization of a scan data before and after different registration methods are applied, including the PointMatcher registration method. To obtain the results for PointMatcher registration in the visualization table, above-mentioned example was used.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_PointMatcher_parameter_point_set_filters"></a>
Parameter: point_set_filters</h3>
<p>The chain of filters to be applied to the point cloud. The point cloud is processed into an intermediate point cloud with the given chain of filters to be used in the alignment procedure. The chain is organized with the forward traversal order of the point set filters range.</p>
<p>The chain of point set filters are applied only once at the beginning of the ICP procedure, i.e., before the first iteration of the ICP algorithm.</p>
<p>The filters can have several purposes, including but not limited to:</p>
<ul>
<li>removal of noisy points which render alignment of point clouds difficult,</li>
<li>removal of redundant points so as to speed up alignment,</li>
<li>addition of descriptive information to the points such as a surface normal vector or the direction from the point to the sensor.</li>
</ul>
<p>In registration, there are two point clouds in consideration, one of which is the reference point cloud while the other one is the point cloud to register. The point set filters corresponds to <code>readingDataPointsFilters</code> configuration module of <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartylibpointmatcher">PointMatcher</a> library while it corresponds to the <code>referenceDataPointsFilters</code> for the other point cloud. The filters should be chosen and set from possible components of those configuration modules.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_PointMatcher_parameter_matcher"></a>
Parameter: matcher</h3>
<p>The method used for matching (linking) the points from to the points in the reference cloud.</p>
<p>Corresponds to <code>matcher</code> configuration module of <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartylibpointmatcher">PointMatcher</a> library. The matcher should be chosen and set from possible components of the <code>matcher</code> configuration module. See <a href="https://libpointmatcher.readthedocs.io/en/latest/Configuration/#configuration-of-an-icp-chain">libpointmatcher documentation</a> for possible configurations.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_PointMatcher_parameter_outlier_filters"></a>
Parameter: outlier_filters</h3>
<p>The chain of filters to be applied to the matched (linked) point clouds after each processing iteration of the ICP algorithm to remove the links which do not correspond to true point correspondences. The outliers are rejected. Points with no link are ignored in the subsequent error minimization step. The chain is organized with the forward traversal order of the outlier filters range.</p>
<p>Corresponds to <code>outlierFilters</code> configuration module of <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartylibpointmatcher">PointMatcher</a> library. The filters should be chosen and set from possible components of the <code>outlierFilters</code> configuration module. See <a href="https://libpointmatcher.readthedocs.io/en/latest/Configuration/#configuration-of-an-icp-chain">libpointmatcher documentation</a> for possible configurations.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_PointMatcher_parameter_error_minimizer"></a>
Parameter: error_minimizer</h3>
<p>The error minimizer that computes a transformation matrix such as to minimize the error between the point sets.</p>
<p>Corresponds to <code>errorMinimizer</code> configuration module of <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartylibpointmatcher">PointMatcher</a> library. The error minimizer should be chosen and set from possible components of the <code>errorMinimizer</code> configuration module. See <a href="https://libpointmatcher.readthedocs.io/en/latest/Configuration/#configuration-of-an-icp-chain">libpointmatcher documentation</a> for possible configurations.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_PointMatcher_parameter_inspector"></a>
Parameter: inspector</h3>
<p>The inspector allows to log data at different steps for analysis. Inspectors typically provide deeper scrutiny than the logger.</p>
<p>Corresponds to <code>inspector</code> configuration module of <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartylibpointmatcher">PointMatcher</a> library. The inspector should be chosen and set from possible components of the <code>inspector</code> configuration module. See <a href="https://libpointmatcher.readthedocs.io/en/latest/Configuration/#configuration-of-an-icp-chain">libpointmatcher documentation</a> for possible configurations.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_PointMatcher_parameter_logger"></a>
Parameter: logger</h3>
<p>The method for logging information regarding the registration process outputted by <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartylibpointmatcher">PointMatcher</a> library. The logs generated by <a class="el" href="namespaceCGAL.html">CGAL</a> library does not get effected by this configuration.</p>
<p>Corresponds to <code>logger</code> configuration module of <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartylibpointmatcher">PointMatcher</a> library. The logger should be chosen and set from possible components of the <code>logger</code> configuration module. See <a href="https://libpointmatcher.readthedocs.io/en/latest/Configuration/#configuration-of-an-icp-chain">libpointmatcher documentation</a> for possible configurations.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_PointMatcher_parameter_transformation"></a>
Parameter: transformation</h3>
<p>The affine transformation that is used as the initial transformation for the reference point cloud.</p>
<h2><a class="anchor" id="Point_set_processing_3Examples_registration_OpenGR_PointMatcher_Pipeline"></a>
OpenGR/PointMatcher Pipeline Example</h2>
<p>The following example reads two point sets and aligns them by using both <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartyOpenGR">OpenGR</a> and <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartylibpointmatcher">PointMatcher</a> libraries, respectively. It depicts a use case where a coarse estimation of a registration transformation is done using the Super4PCS algorithm. Then, a fine registration from this coarse registration using the ICP algorithm. <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2registration_with_opengr_pointmatcher_pipeline_8cpp-example.html">Point_set_processing_3/registration_with_opengr_pointmatcher_pipeline.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Aff_transformation_3.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/pointmatcher/register_point_sets.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/OpenGR/compute_registration_transformation.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> K;</div><div class="line"><span class="keyword">typedef</span> K::Point_3 Point_3;</div><div class="line"><span class="keyword">typedef</span> K::Vector_3 Vector_3;</div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Point_3, Vector_3&gt; Pwn;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Pwn&gt;</a> Point_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;Pwn&gt;</a> Normal_map;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>params = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL_1_1parameters.html">CGAL::parameters</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname1 = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/hippo1.ply"</span>);</div><div class="line">  <span class="keyword">const</span> std::string fname2 = (argc&gt;2) ? argv[2] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/hippo2.ply"</span>);</div><div class="line"></div><div class="line">  std::vector&lt;Pwn&gt; pwns1, pwns2;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname1, std::back_inserter(pwns1),</div><div class="line">                            CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Pwn&gt;</a>())</div><div class="line">                                             .normal_map (Normal_map())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname1 &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname2, std::back_inserter(pwns2),</div><div class="line">                            CGAL::parameters::point_map(Point_map())</div><div class="line">                                             .normal_map(Normal_map())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname2 &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Computing registration transformation using OpenGR Super4PCS.."</span> &lt;&lt; std::endl;</div><div class="line">  <span class="comment">// First, compute registration transformation using OpenGR Super4PCS</span></div><div class="line">  K::Aff_transformation_3 res =</div><div class="line">    std::get&lt;0&gt;( <span class="comment">// get first of pair, which is the transformation</span></div><div class="line">      <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga1a077db2cedb624e4b4b0ed492598db0">CGAL::OpenGR::compute_registration_transformation</a></div><div class="line">        (pwns1, pwns2,</div><div class="line">         params::point_map(Point_map()).normal_map(Normal_map()),</div><div class="line">         params::point_map(Point_map()).normal_map(Normal_map())));</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Computing registration transformation using PointMatcher ICP, "</span></div><div class="line">            &lt;&lt; <span class="stringliteral">"taking transformation computed by OpenGR Super4PCS as initial transformation.."</span> &lt;&lt; std::endl;</div><div class="line">  <span class="comment">// Then, compute registration transformation using PointMatcher ICP, taking transformation computed</span></div><div class="line">  <span class="comment">// by OpenGR as initial transformation, and apply the transformation to pwns2</span></div><div class="line">  <span class="comment">// bool converged =</span></div><div class="line">    <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#gaa849870cbc74cee3f2f536c70aadf976">CGAL::pointmatcher::register_point_sets</a></div><div class="line">      (pwns1, pwns2,</div><div class="line">       params::point_map(Point_map()).normal_map(Normal_map()),</div><div class="line">       params::point_map(Point_map()).normal_map(Normal_map()).transformation(res));</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga5822feba4449f0492363611620b877c0">CGAL::IO::write_points</a>(<span class="stringliteral">"pwns2_aligned.ply"</span>, pwns2,</div><div class="line">                             CGAL::parameters::point_map(Point_map())</div><div class="line">                                              .normal_map(Normal_map())))</div><div class="line">  {</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Transformed version of "</span> &lt;&lt; fname2</div><div class="line">            &lt;&lt; <span class="stringliteral">" written to pwn2_aligned.ply.\n"</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><p><a class="el" href="index.html#fig__Point_set_processing_3tableRegistrationRegistration_visualization_table">Figure 80.4</a> demonstrates visualization of a scan data before and after different registration methods are applied, including the pipeline of OpenGR and PointMatcher registration methods. To obtain the results for the pipeline of OpenGR and PointMatcher registration methods in the visualization table, above-mentioned example was used.</p>
<p><a class="anchor" id="fig__Point_set_processing_3tableRegistrationRegistration_visualization_table"></a></p><table class="doxtable">
<tr>
<th></th><th>Scan 1  </th><th>Scan 1 (possibly transformed, green) and Scan 2 (the reference, red)  </th></tr>
<tr>
<th>Unregistered </th><td><a class="anchor" id="fig__Point_set_processing_3figRegistrationUnregistered_hippo2_view1"></a><div class="image">
<img src="registration_view1_hippo2_unregistered.png" alt="registration_view1_hippo2_unregistered.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figRegistrationUnregistered_hippo2_view1">Figure 80.5</a>  </div> <br />   </td><td><a class="anchor" id="fig__Point_set_processing_3figRegistrationUnregistered_hippo1_hippo2_view1"></a><div class="image">
<img src="registration_view1_hippo1_hippo2_unregistered.png" alt="registration_view1_hippo1_hippo2_unregistered.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figRegistrationUnregistered_hippo1_hippo2_view1">Figure 80.6</a>  </div> <br />    </td></tr>
<tr>
<th>Registered using OpenGR  </th><td><a class="anchor" id="fig__Point_set_processing_3figRegistrationOpenGR_hippo2_view1"></a><div class="image">
<img src="registration_view1_hippo2_opengr.png" alt="registration_view1_hippo2_opengr.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figRegistrationOpenGR_hippo2_view1">Figure 80.7</a>  </div> <br />   </td><td><a class="anchor" id="fig__Point_set_processing_3figRegistrationOpenGR_hippo1_hippo2_view1"></a><div class="image">
<img src="registration_view1_hippo1_hippo2_opengr.png" alt="registration_view1_hippo1_hippo2_opengr.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figRegistrationOpenGR_hippo1_hippo2_view1">Figure 80.8</a>  </div> <br />    </td></tr>
<tr>
<th>Registered using PointMatcher  </th><td><a class="anchor" id="fig__Point_set_processing_3figRegistrationPointMatcher_hippo2_view1"></a><div class="image">
<img src="registration_view1_hippo2_pointmatcher.png" alt="registration_view1_hippo2_pointmatcher.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figRegistrationPointMatcher_hippo2_view1">Figure 80.9</a>  </div> <br />   </td><td><a class="anchor" id="fig__Point_set_processing_3figRegistrationPointMatcher_hippo1_hippo2_view1"></a><div class="image">
<img src="registration_view1_hippo1_hippo2_pointmatcher.png" alt="registration_view1_hippo1_hippo2_pointmatcher.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figRegistrationPointMatcher_hippo1_hippo2_view1">Figure 80.10</a>  </div> <br />    </td></tr>
<tr>
<th>Registered using OpenGR+PointMatcher Pipeline  </th><td><a class="anchor" id="fig__Point_set_processing_3figRegistrationPipeline_hippo2_view1"></a><div class="image">
<img src="registration_view1_hippo2_opengr_pointmatcher_pipeline.png" alt="registration_view1_hippo2_opengr_pointmatcher_pipeline.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figRegistrationPipeline_hippo2_view1">Figure 80.11</a>  </div> <br />   </td><td><a class="anchor" id="fig__Point_set_processing_3figRegistrationPipeline_hippo1_hippo2_view1"></a><div class="image">
<img src="registration_view1_hippo1_hippo2_opengr_pointmatcher_pipeline.png" alt="registration_view1_hippo1_hippo2_opengr_pointmatcher_pipeline.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figRegistrationPipeline_hippo1_hippo2_view1">Figure 80.12</a>  </div> <br />    </td></tr>
</table>
<p> </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3tableRegistrationRegistration_visualization_table">Figure 80.4</a> Visualization of registered hippo scans with different registration methods. Two scans are used: red as the reference, green as the one for which the transformation is computed and applied. To obtain the results, the example code given in <a class="el" href="index.html#Point_set_processing_3Examples_registration_OpenGR">OpenGR Example</a> , <a class="el" href="index.html#Point_set_processing_3Examples_registration_PointMatcher">PointMatcher Example</a> , <a class="el" href="index.html#Point_set_processing_3Examples_registration_OpenGR_PointMatcher_Pipeline">OpenGR/PointMatcher Pipeline Example</a> were applied, respectively. The parameters of the algorithms used to obtain those results are not optimized for the shown scans; therefore, better parameter choice might result in better results in terms of registration accuracy for each algorithm individually.  </div> <br /> 
<h1><a class="anchor" id="Point_set_processing_3Clustering"></a>
Clustering</h1>
<p>If an input point set represents several objects which are spatially separated, a clustering algorithm can be applied to identify connected components on a nearest neighbor graph built using a query sphere of fixed radius centered on each point.</p>
<p>The clustering is stored in a cluster map which associates each input point with the index of the cluster it belongs to: users can then use this map however they find it relevant to their use case, for example segmenting the input point set into one point set per cluster. <a class="el" href="index.html#fig__Point_set_processing_3figclustering">Figure 80.13</a> shows different clustering outputs.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figclustering"></a></p><div class="image">
<img src="clustering.png" alt="clustering.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figclustering">Figure 80.13</a> Point Set Clustering outputs (one color per cluster). Top: input point set and clustering using a neighbor radius of 1.5 (147 clusters extracted). Bottom: clustering with neighbor radius 3.0 (37 clusters extracted), and with neighbor radius 6.0 (5 clusters extracted).  </div> <br /> 
<h2><a class="anchor" id="Point_set_processing_3Example_clustering"></a>
Example</h2>
<p>In the following example, clusters (and adjacencies between them) are computed and stored as colors in a PLY file:</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2clustering_example_8cpp-example.html">Point_set_processing_3/clustering_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3/IO.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/cluster_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/compute_average_spacing.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Random.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> Kernel = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div><div class="line"><span class="keyword">using</span> Point_3 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ae82b7f4be77dd5b8819ebe419e4ae753">Kernel::Point_3</a>;</div><div class="line"><span class="keyword">using</span> Point_set = CGAL::Point_set_3&lt;Point_3&gt;;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="comment">// Read input file</span></div><div class="line">  std::ifstream ifile((argc &gt; 1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/hippo1.ply"</span>), std::ios_base::binary);</div><div class="line">  Point_set points;</div><div class="line">  ifile &gt;&gt; points;</div><div class="line"></div><div class="line">  <span class="comment">// Add a cluster map</span></div><div class="line">  Point_set::Property_map&lt;int&gt; cluster_map = points.add_property_map&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">"cluster"</span>, -1).first;</div><div class="line"></div><div class="line">  <span class="comment">// Compute average spacing</span></div><div class="line">  <span class="keywordtype">double</span> spacing = CGAL::compute_average_spacing&lt;CGAL::Parallel_if_available_tag&gt; (points, 12);</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Spacing = "</span> &lt;&lt; spacing &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Adjacencies stored in vector</span></div><div class="line">  std::vector&lt;std::pair&lt;std::size_t, std::size_t&gt; &gt; adjacencies;</div><div class="line"></div><div class="line">  <span class="comment">// Compute clusters</span></div><div class="line">  CGAL::Real_timer t;</div><div class="line">  t.start();</div><div class="line">  std::size_t nb_clusters</div><div class="line">    = <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga2531a1366bea67edef99e87d6b8819ec">CGAL::cluster_point_set</a>(points, cluster_map,</div><div class="line">                              points.parameters().neighbor_radius(spacing)</div><div class="line">                                                 .adjacencies(std::back_inserter(adjacencies)));</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Found "</span> &lt;&lt; nb_clusters &lt;&lt; <span class="stringliteral">" clusters with "</span> &lt;&lt; adjacencies.size()</div><div class="line">            &lt;&lt; <span class="stringliteral">" adjacencies in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" seconds"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Output a colored PLY file</span></div><div class="line">  Point_set::Property_map&lt;unsigned char&gt; red = points.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"red"</span>, 0).first;</div><div class="line">  Point_set::Property_map&lt;unsigned char&gt; green = points.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"green"</span>, 0).first;</div><div class="line">  Point_set::Property_map&lt;unsigned char&gt; blue = points.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"blue"</span>, 0).first;</div><div class="line">  <span class="keywordflow">for</span>(Point_set::Index idx : points)</div><div class="line">  {</div><div class="line">    <span class="comment">// One color per cluster</span></div><div class="line">    CGAL::Random rand (cluster_map[idx]);</div><div class="line">    red[idx] = rand.get_int(64, 192);</div><div class="line">    green[idx] = rand.get_int(64, 192);</div><div class="line">    blue[idx] = rand.get_int(64, 192);</div><div class="line">  }</div><div class="line"></div><div class="line">  std::ofstream ofile(<span class="stringliteral">"out.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a>(ofile);</div><div class="line">  ofile &lt;&lt; points;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Point_set_processing_3OutlierRemoval"></a>
Outlier Removal</h1>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga50c708584a8219847ce04f636dcad4b3" title="Removes outliers: ">remove_outliers()</a></code> deletes a user-specified fraction of outliers from an input point set. More specifically, it partitions the input points with respect to the average squared distances to their nearest neighbors and deletes the points with largest value, either partitioning with a threshold or removing a fixed percentage. The user can either specify a fixed number of nearest neighbors or a fixed spherical neighborhood radius.</p>
<h2><a class="anchor" id="Point_set_processing_3Example_outlier_removal"></a>
Example</h2>
<p>The following example reads a point set and removes 5% of the points. It uses the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Identity__property__map.html">Identity_property_map</a>&lt;<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__3.html">Point_3</a>&gt;</code> property map (optional as it is the default position property map of all functions in this component.) <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2remove_outliers_example_8cpp-example.html">Point_set_processing_3/remove_outliers_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/compute_average_spacing.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/remove_outliers.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname = (argc&gt;1)?argv[1]:<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/oni.pwn"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Reads a point set file in points[].</span></div><div class="line">  <span class="comment">// The Identity_property_map property map can be omitted here as it is the default value.</span></div><div class="line">  std::vector&lt;Point&gt; points;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname, std::back_inserter(points),</div><div class="line">                            CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map&lt;Point&gt;</a>())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Removes outliers using erase-remove idiom.</span></div><div class="line">  <span class="comment">// The Identity_property_map property map can be omitted here as it is the default value.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_neighbors = 24; <span class="comment">// considers 24 nearest neighbor points</span></div><div class="line"></div><div class="line">  <span class="comment">// Estimate scale of the point set with average spacing</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> average_spacing = CGAL::compute_average_spacing&lt;CGAL::Sequential_tag&gt;(points, nb_neighbors);</div><div class="line"></div><div class="line">  <span class="comment">// FIRST OPTION //</span></div><div class="line">  <span class="comment">// I don't know the ratio of outliers present in the point set</span></div><div class="line">  std::vector&lt;Point&gt;::iterator first_to_remove</div><div class="line">    = CGAL::remove_outliers&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (points,</div><div class="line">     nb_neighbors,</div><div class="line">     CGAL::parameters::threshold_percent (100.). <span class="comment">// No limit on the number of outliers to remove</span></div><div class="line">     threshold_distance (2. * average_spacing)); <span class="comment">// Point with distance above 2*average_spacing are considered outliers</span></div><div class="line"></div><div class="line">  std::cerr &lt;&lt; (100. * std::distance(first_to_remove, points.end()) / static_cast&lt;double&gt;(points.size()))</div><div class="line">            &lt;&lt; <span class="stringliteral">"% of the points are considered outliers when using a distance threshold of "</span></div><div class="line">            &lt;&lt; 2. * average_spacing &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// SECOND OPTION //</span></div><div class="line">  <span class="comment">// I know the ratio of outliers present in the point set</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> removed_percentage = 5.0; <span class="comment">// percentage of points to remove</span></div><div class="line"></div><div class="line">  points.erase(CGAL::remove_outliers&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">               (points,</div><div class="line">                nb_neighbors,</div><div class="line">                CGAL::parameters::threshold_percent(removed_percentage). <span class="comment">// Minimum percentage to remove</span></div><div class="line">                threshold_distance(0.)), <span class="comment">// No distance threshold (can be omitted)</span></div><div class="line">               points.end());</div><div class="line"></div><div class="line">  <span class="comment">// Optional: after erase(), use Scott Meyer's "swap trick" to trim excess capacity</span></div><div class="line">  std::vector&lt;Point&gt;(points).swap(points);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Point_set_processing_3Simplification"></a>
Simplification</h1>
<p>Four simplification functions are devised to reduce an input point set.</p>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga4be2d94f1791d24b8ba0107bc33ad6dc" title="Randomly deletes a user-specified fraction of the input points. ">random_simplify_point_set()</a></code> randomly deletes a user-specified fraction of points from the input point set. This algorithm is the fastest.</p>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga7757ef9b3900e42fde26f5a0ac56e20f" title="Merges points which belong to the same cell of a grid of cell size = epsilon. ">grid_simplify_point_set()</a></code> considers a regular grid covering the bounding box of the input point set, and clusters all points sharing the same cell of the grid by picking as representative one arbitrarily chosen point: representatives may only be retained in cells that have more than a user-defined minimum number of points in order to also filter out low density areas and outliers. This algorithm is still fast, although slower than <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga4be2d94f1791d24b8ba0107bc33ad6dc" title="Randomly deletes a user-specified fraction of the input points. ">random_simplify_point_set()</a></code>.</p>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga3420351b6d3fad079d13f894f42e9d03" title="Recursively split the point set in smaller clusters until the clusters have fewer than size elements ...">hierarchy_simplify_point_set()</a></code> provides an adaptive simplification of the point set through local clusters <a class="el" href="citelist.html#CITEREF_cgal:pgk-esops-02">[10]</a>. The size of the clusters is either directly selected by the user or it automatically adapts to the local variation of the point set.</p>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga79ee6fb524ec53b9b85eb32e7ae56ca8" title="This is an implementation of the Weighted Locally Optimal Projection (WLOP) simplification algorithm...">wlop_simplify_and_regularize_point_set()</a></code> not only simplifies, but also regularizes downsampled points. This is an implementation of the Weighted Locally Optimal Projection (WLOP) algorithm <a class="el" href="citelist.html#CITEREF_wlop-2009">[4]</a>.</p>
<h2><a class="anchor" id="Point_set_processing_3Example_grid_simplification"></a>
Grid Simplification Example</h2>
<p>The following example reads a point set and simplifies it by clustering. To filter out outliers, at least 3 points must lie in a cell so that a point from this cell is kept. <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2grid_simplification_example_8cpp-example.html">Point_set_processing_3/grid_simplification_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/grid_simplify_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/oni.pwn"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Reads a point set file in points[].</span></div><div class="line">  std::vector&lt;Point&gt; points;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname, std::back_inserter(points)))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// simplification by clustering using erase-remove idiom</span></div><div class="line">  <span class="keywordtype">double</span> cell_size = 0.03;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> min_points_per_cell = 3;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> iterator_to_first_to_remove</div><div class="line">    = <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga7757ef9b3900e42fde26f5a0ac56e20f">CGAL::grid_simplify_point_set</a></div><div class="line">    (points, cell_size,</div><div class="line">     CGAL::parameters::min_points_per_cell(min_points_per_cell)); <span class="comment">// optional</span></div><div class="line"></div><div class="line">  points.erase(iterator_to_first_to_remove, points.end());</div><div class="line"></div><div class="line">  <span class="comment">// Optional: after erase(), shrink_to_fit to trim excess capacity</span></div><div class="line">  points.shrink_to_fit();</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="fig__Point_set_processing_3figgrid_simplification"></a></p><div class="image">
<img src="grid_simplification.jpg" alt="grid_simplification.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figgrid_simplification">Figure 80.14</a> Point set simplification through grid-based clustering. Removed points are depicted in red. Notice how low-density areas (in green) are not simplified.  </div> <br /> 
<h2><a class="anchor" id="Point_set_processing_3Example_hierarchy_simplication"></a>
Hierarchy Simplification Example</h2>
<p>The following example reads a point set and produces a set of clusters.</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2hierarchy_simplification_example_8cpp-example.html">Point_set_processing_3/hierarchy_simplification_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/hierarchy_simplify_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Memory_sizer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/oni.pwn"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Reads a point set file in points[].</span></div><div class="line">  std::vector&lt;Point&gt; points;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname, std::back_inserter(points)))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Read "</span> &lt;&lt; points.size () &lt;&lt; <span class="stringliteral">" point(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  CGAL::Timer task_timer; task_timer.start();</div><div class="line"></div><div class="line">  <span class="comment">// simplification by clustering using erase-remove idiom</span></div><div class="line">  points.erase(<a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga3420351b6d3fad079d13f894f42e9d03">CGAL::hierarchy_simplify_point_set</a>(points,</div><div class="line">                                                  CGAL::parameters::size(100)<span class="comment">// Max cluster size</span></div><div class="line">                                                                   .maximum_variation(0.01)), <span class="comment">// Max surface variation</span></div><div class="line">               points.end());</div><div class="line"></div><div class="line">  std::size_t memory = CGAL::Memory_sizer().virtual_size();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; points.size () &lt;&lt; <span class="stringliteral">" point(s) kept, computed in "</span></div><div class="line">            &lt;&lt; task_timer.time() &lt;&lt; <span class="stringliteral">" seconds, "</span></div><div class="line">            &lt;&lt; (memory&gt;&gt;20) &lt;&lt; <span class="stringliteral">" Mib allocated."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3IO.html#ga5822feba4449f0492363611620b877c0">CGAL::IO::write_points</a>(<span class="stringliteral">"out.xyz"</span>, points, CGAL::parameters::stream_precision(17));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h3><a class="anchor" id="Point_set_processing_3Hierarchy_simplification_parameter_size"></a>
Parameter: size</h3>
<p>The hierarchy simplification algorithm recursively split the point set in two until each cluster's size is less than the parameter <code>size</code>.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figHierarchy_simplification_size"></a></p><div class="image">
<img src="hierarchical_clustering_size.jpg" alt="hierarchical_clustering_size.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figHierarchy_simplification_size">Figure 80.15</a> Input point set and hierarchy simplification with different <code>size</code> parameter: \(10\), \(100\) and \(1000\). In the 3 cases, <code>var_max</code> \(=1/3\). </div> <br /> 
<h3><a class="anchor" id="Point_set_processing_3Hierarchy_simplification_parameter_var_max"></a>
Parameter: var_max</h3>
<p>In addition to the size parameter, a variation parameter allows to increase simplification in monotonous regions. For each cluster, a surface variation measure is computed using the sorted eigenvalues of the covariance matrix: </p><p class="formulaDsp">
\[ \sigma(p) = \frac{\lambda_0}{\lambda_0 + \lambda_1 + \lambda_2}. \]
</p>
<p>This function goes from \(0\) if the cluster is coplanar to \(1/3\) if it is fully isotropic. If a cluster's variation is above <code>var_max</code>, it is split. If <code>var_max</code> is equal to \(1/3\), this parameter has no effect and the clustering is regular on the whole point set.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figHierarchical_clustering_var_max"></a></p><div class="image">
<img src="hierarchical_clustering_var_max.jpg" alt="hierarchical_clustering_var_max.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figHierarchical_clustering_var_max">Figure 80.16</a> Input point set and hierarchy simplification with different <code>var_max</code> parameter: \(0.00001\), \(0.001\) and \(0.1\). In the 3 cases, <code>size</code> \(=1000\). </div> <br /> 
<h2><a class="anchor" id="Point_set_processing_3Example_wlop"></a>
WLOP Simplification Example</h2>
<p>The following example reads a point set, simplifies and regularizes it by WLOP.</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2wlop_simplify_and_regularize_point_set_example_8cpp-example.html">Point_set_processing_3/wlop_simplify_and_regularize_point_set_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/wlop_simplify_and_regularize_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"></div><div class="line"><span class="comment">// Concurrency</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a> Concurrency_tag;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string input_filename = (argc&gt;1)?argv[1]:<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/sphere_20k.xyz"</span>);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* output_filename = (argc&gt;2)?argv[2]:<span class="stringliteral">"data/sphere_20k_WLOPED.xyz"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Reads a .xyz point set file in points[]</span></div><div class="line">  std::vector&lt;Point&gt; points;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(input_filename, std::back_inserter(points)))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; input_filename  &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::vector&lt;Point&gt; output;</div><div class="line"></div><div class="line">  <span class="comment">//parameters</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> retain_percentage = 2;   <span class="comment">// percentage of points to retain.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> neighbor_radius = 0.5;   <span class="comment">// neighbors size.</span></div><div class="line"></div><div class="line">  CGAL::wlop_simplify_and_regularize_point_set&lt;Concurrency_tag&gt;</div><div class="line">    (points, std::back_inserter(output),</div><div class="line">     CGAL::parameters::select_percentage(retain_percentage).</div><div class="line">     neighbor_radius (neighbor_radius));</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga5822feba4449f0492363611620b877c0">CGAL::IO::write_points</a>(output_filename, output, CGAL::parameters::stream_precision(17)))</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="fig__Point_set_processing_3figsimplification_comparison"></a></p><div class="image">
<img src="simplification_comparison.jpg" alt="simplification_comparison.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figsimplification_comparison">Figure 80.17</a> Comparison for three simplification methods: Left: Random simplification result. Middle: Grid simplification result. Right: WLOP simplification result.  </div> <br /> 
<h3><a class="anchor" id="Point_set_processing_3WLOP_Parameter"></a>
Parameter: require_uniform_sampling</h3>
<p>Computing density weights for each point is an optional preprocessing. For example, as shown in the following figure, when require_uniform_sampling is set to false, WLOP preserves the intrinsic non-uniform sampling of the original points; if require_uniform_sampling is set to true, WLOP is resilient to non-uniform sampling and generates sample points with more uniform distribution, at the expense of computational time.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figWLOP_parameter_density"></a></p><div class="image">
<img src="WLOP_parameter_density.jpg" alt="WLOP_parameter_density.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figWLOP_parameter_density">Figure 80.18</a> Comparison between with and without density: Left: input. Middle: <code>require_uniform_sampling = false</code>. Right: <code>require_uniform_sampling=true</code>.  </div> <br /> 
<h3><a class="anchor" id="Point_set_processing_3WLOP_parameter_neighborhood_size"></a>
Parameter: neighbor_radius</h3>
<p>Usually, the neighborhood of sample points should include at least two rings of neighboring sample points. Using a small neighborhood size may not be able to generate regularized result, while using big neighborhood size will make the sample points shrink into the interior of the local surface (under-fitting). The function will use a neighborhood size estimation if this parameter value is set to default or smaller that zero.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figWLOP_parameter_neighborhood_size"></a></p><div class="image">
<img src="WLOP_parameter_neighborhood_size.jpg" alt="WLOP_parameter_neighborhood_size.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figWLOP_parameter_neighborhood_size">Figure 80.19</a> Comparison between different sizes of neighbor radius.  </div> <br /> 
<h3><a class="anchor" id="Point_set_processing_3WLOP_parallel_performance"></a>
Parallel Performance</h3>
<p>A parallel version of WLOP is provided and requires the executable to be linked against the <a href="https://github.com/oneapi-src/oneTBB">Intel TBB library</a>. To control the number of threads used, the user may use the tbb::task_scheduler_init class. See the <a href="https://software.intel.com/content/www/us/en/develop/documentation/onetbb-documentation/top.html">TBB documentation</a> for more details. We provide below a speed-up chart generated using the parallel version of the WLOP algorithm. The machine used is a PC running Windows 7 64-bits with a 4-core <a href="#" onclick="location.href='mai'+'lto:'+'i7-'+'47'+'00H'+'Q@'+'2.4'+'0G'+'Hz'; return false;">i7-47<span style="display: none;">.nosp@m.</span>00HQ<span style="display: none;">.nosp@m.</span>@2.40<span style="display: none;">.nosp@m.</span>GHz</a> CPU with 8GB of RAM.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figWLOP_parallel_performance"></a></p><div class="image">
<img src="parallel_WLOP_performance.jpg" alt="parallel_WLOP_performance.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figWLOP_parallel_performance">Figure 80.20</a> Parallel WLOP speed-up, compared to the sequential version of the algorithm.  </div> <br /> 
<h1><a class="anchor" id="Point_set_processing_3Smoothing"></a>
Smoothing</h1>
<p>Two smoothing functions are devised to smooth an input point set.</p>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga96a3738be3b2b9bd1587af78ae10e67a" title="Smoothes the range of points using jet fitting on the nearest neighbors and reprojection onto the jet...">jet_smooth_point_set()</a></code> smooths the input point set by projecting each point onto a smooth parametric surface patch (so-called jet surface) fitted over its nearest neighbors.</p>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga01192a227578fee0c5676ba6a5e88931" title="This function smooths an input point set by iteratively projecting each point onto the implicit surfa...">bilateral_smooth_point_set()</a></code> smooths the input point set by iteratively projecting each point onto the implicit surface patch fitted over its nearest neighbors. Bilateral projection preserves sharp features according to the normal (gradient) information. Normals are thus required as input. For more details, see section 4 of <a class="el" href="citelist.html#CITEREF_ear-2013">[5]</a>.</p>
<p>For both functions, the user can either specify a fixed number of nearest neighbors or a fixed spherical neighborhood radius.</p>
<h2><a class="anchor" id="Point_set_processing_3Example_jet_smoothing"></a>
Jet Smoothing Example</h2>
<p>The following example generates a set of 9 points close to the <code>xy</code> plane and smooths them using 8 nearest neighbors: <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2jet_smoothing_example_8cpp-example.html">Point_set_processing_3/jet_smoothing_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/jet_smooth_point_set.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"></div><div class="line"><span class="comment">// Concurrency</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a> Concurrency_tag;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">  <span class="comment">// generate point set</span></div><div class="line">  std::vector&lt;Point&gt; points;</div><div class="line">  points.push_back(Point( 0.0, 0.0, 0.001));</div><div class="line">  points.push_back(Point(-0.1,-0.1, 0.002));</div><div class="line">  points.push_back(Point(-0.1,-0.2, 0.001));</div><div class="line">  points.push_back(Point(-0.1, 0.1, 0.002));</div><div class="line">  points.push_back(Point( 0.1,-0.1, 0.000));</div><div class="line">  points.push_back(Point( 0.1, 0.2, 0.001));</div><div class="line">  points.push_back(Point( 0.2, 0.0, 0.002));</div><div class="line">  points.push_back(Point( 0.2, 0.1, 0.000));</div><div class="line">  points.push_back(Point( 0.0,-0.1, 0.001));</div><div class="line"></div><div class="line">  <span class="comment">// Smoothing.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nb_neighbors = 8; <span class="comment">// default is 24 for real-life point sets</span></div><div class="line">  CGAL::jet_smooth_point_set&lt;Concurrency_tag&gt;(points, nb_neighbors);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Point_set_processing_3Example_bilateral_smoothing"></a>
Bilateral Smoothing Example</h2>
<p>The following example reads a set of points with normals and smooths them via bilateral smoothing: <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2bilateral_smooth_point_set_example_8cpp-example.html">Point_set_processing_3/bilateral_smooth_point_set_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/bilateral_smooth_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/tags.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span> <span class="comment">// defines std::pair</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"></div><div class="line"><span class="comment">// Point with normal vector stored in a std::pair.</span></div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Point, Vector&gt; PointVectorPair;</div><div class="line"></div><div class="line"><span class="comment">// Concurrency</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a> Concurrency_tag;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string input_filename = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/fin90_with_PCA_normals.xyz"</span>);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* output_filename = (argc&gt;2) ? argv[2] : <span class="stringliteral">"data/fin90_with_PCA_normals_bilateral_smoothed.xyz"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Reads a point set file in points[] * with normals *.</span></div><div class="line">  std::vector&lt;PointVectorPair&gt; points;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(input_filename, std::back_inserter(points),</div><div class="line">                            CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                                             .normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>())))</div><div class="line">  {</div><div class="line">     std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; input_filename &lt;&lt; std::endl;</div><div class="line">     <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Algorithm parameters</span></div><div class="line">  <span class="keywordtype">int</span> k = 120;                 <span class="comment">// size of neighborhood. The bigger the smoother the result will be.</span></div><div class="line">                               <span class="comment">// This value should bigger than 1.</span></div><div class="line">  <span class="keywordtype">double</span> sharpness_angle = 25; <span class="comment">// control sharpness of the result.</span></div><div class="line">                               <span class="comment">// The bigger the smoother the result will be</span></div><div class="line">  <span class="keywordtype">int</span> iter_number = 3;         <span class="comment">// number of times the projection is applied</span></div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; iter_number; ++i)</div><div class="line">  {</div><div class="line">    <span class="comment">/* double error = */</span></div><div class="line">    CGAL::bilateral_smooth_point_set &lt;Concurrency_tag&gt;(</div><div class="line">      points,</div><div class="line">      k,</div><div class="line">      CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                       .normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                       .sharpness_angle(sharpness_angle));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IOXyz.html#ga1991ab8d312de62ddd907f81890ed039">CGAL::IO::write_XYZ</a>(output_filename, points,</div><div class="line">                          CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                                           .normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                                           .stream_precision(17)))</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p><a class="anchor" id="fig__Point_set_processing_3figsmoothing_comparison"></a></p><div class="image">
<img src="smoothing_comparison.jpg" alt="smoothing_comparison.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figsmoothing_comparison">Figure 80.21</a> Comparison for two smoothing methods: Left: Input, 250K points, normal-color mapping. Middle: Jet smoothing result, 197 seconds. Right: Bilateral smoothing result, 110 seconds.  </div> <br /> 
<h3><a class="anchor" id="Point_set_processing_3Bilateral_smoothing_parallel_performance"></a>
Parallel</h3>
<p>Performance: A parallel version of bilateral smoothing is provided and requires the executable to be linked against the <a href="https://github.com/oneapi-src/oneTBB">Intel TBB library</a>. The number of threads used is controlled through the tbb::task_scheduler_init class. See the <a href="https://software.intel.com/content/www/us/en/develop/documentation/onetbb-documentation/top.html">TBB documentation</a> for more details. We provide below a speed-up chart generated using the parallel version of the bilateral smoothing algorithm. The machine used is a PC running Windows 7 64-bits with a 4-core <a href="#" onclick="location.href='mai'+'lto:'+'i7-'+'47'+'00H'+'Q@'+'2.4'+'0G'+'Hz'; return false;">i7-47<span style="display: none;">.nosp@m.</span>00HQ<span style="display: none;">.nosp@m.</span>@2.40<span style="display: none;">.nosp@m.</span>GHz</a> CPU with 8GB of RAM.</p>
<p><a class="anchor" id="fig__Point_set_processing_3Bilateral_smoothing_parallel_performance"></a></p><div class="image">
<img src="parallel_bilateral_smooth_point_set_performance.jpg" alt="parallel_bilateral_smooth_point_set_performance.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3Bilateral_smoothing_parallel_performance">Figure 80.22</a> Parallel bilateral smoothing speed-up, compared to the sequential version of the algorithm.  </div> <br /> 
<h1><a class="anchor" id="Point_set_processing_3NormalEstimation"></a>
Normal Estimation</h1>
<p>Assuming a point set sampled over an inferred surface <b>S</b>, two functions provide an estimate of the normal to <b>S</b> at each point. The result is an unoriented normal vector for each input point.</p>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga078e25209373cab0e1f3524202489771" title="Estimates normal directions of the range of points using jet fitting on the nearest neighbors...">jet_estimate_normals()</a></code> estimates the normal direction at each point from the input set by fitting a jet surface over its nearest neighbors. The default jet is a quadric surface. This algorithm is well suited to point sets scattered over curved surfaces.</p>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga721aeb7af4b2d31e08e75bc5d53303cf" title="Estimates normal directions of the range of points by linear least squares fitting of a plane over th...">pca_estimate_normals()</a></code> estimates the normal direction at each point from the set by linear least squares fitting of a plane over its nearest neighbors. This algorithm is simpler and faster than <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga078e25209373cab0e1f3524202489771" title="Estimates normal directions of the range of points using jet fitting on the nearest neighbors...">jet_estimate_normals()</a></code>.</p>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gaab0fd78ef3e46c4256e9a1145a9d118e" title="Estimates normal directions of the range of points using the Voronoi Covariance Measure with a radius...">vcm_estimate_normals()</a></code> estimates the normal direction at each point from the set by using the Voronoi Covariance Measure of the point set. This algorithm is more complex and slower than the previous algorithms. It is based on the article <a class="el" href="citelist.html#CITEREF_cgal:mog-vbcfe-11">[9]</a>.</p>
<p>For these three functions, the user can either specify a fixed number of nearest neighbors or a fixed spherical neighborhood radius.</p>
<h1><a class="anchor" id="Point_set_processing_3NormalOrientation"></a>
Normal Orientation</h1>
<h2><a class="anchor" id="Point_set_processing_3Mst_orient_normals"></a>
Minimum Spanning Tree</h2>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga17c3c558c3799b65bd23fba971a82a5c" title="Orients the normals of the range of points using the propagation of a seed orientation through a mini...">mst_orient_normals()</a></code> orients the normals of a set of points with unoriented normals using the method described by Hoppe et al. in <em>Surface reconstruction from unorganized points</em> <a class="el" href="citelist.html#CITEREF_cgal:hddms-srup-92">[3]</a>. More specifically, this method constructs a Riemannian graph over the input points (the graph of the nearest neighbor points) and propagates a seed normal orientation within a minimum spanning tree computed over this graph. The result is an oriented normal vector for each input unoriented normal, except for the normals which cannot be successfully oriented.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figmst_orient_normals"></a></p><div class="image">
<img src="mst_orient_normals.jpg" alt="mst_orient_normals.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figmst_orient_normals">Figure 80.23</a> Normal orientation of a sampled cube surface. Left: unoriented normals. Right: orientation of right face normals is propagated to bottom face.  </div> <br /> 
<h3><a class="anchor" id="Point_set_processing_3Example_normals"></a>
Example</h3>
<p>The following example reads a point set from a file, estimates the normals through PCA (either over the 18 nearest neighbors or using a spherical neighborhood radius of twice the average spacing) and orients the normals: <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2normals_example_8cpp-example.html">Point_set_processing_3/normals_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/compute_average_spacing.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/pca_estimate_normals.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/mst_orient_normals.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span> <span class="comment">// defines std::pair</span></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"></div><div class="line"><span class="comment">// Point with normal vector stored in a std::pair.</span></div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Point, Vector&gt; PointVectorPair;</div><div class="line"></div><div class="line"><span class="comment">// Concurrency</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a> Concurrency_tag;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/sphere_1k.xyz"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Reads a point set file in points[].</span></div><div class="line">  std::list&lt;PointVectorPair&gt; points;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname,</div><div class="line">                            std::back_inserter(points),</div><div class="line">                            CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname&lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Estimates normals direction.</span></div><div class="line">  <span class="comment">// Note: pca_estimate_normals() requiresa range of points</span></div><div class="line">  <span class="comment">// as well as property maps to access each point's position and normal.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_neighbors = 18; <span class="comment">// K-nearest neighbors = 3 rings</span></div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 2 &amp;&amp; std::strcmp(argv[2], <span class="stringliteral">"-r"</span>) == 0) <span class="comment">// Use a fixed neighborhood radius</span></div><div class="line">  {</div><div class="line">    <span class="comment">// First compute a spacing using the K parameter</span></div><div class="line">    <span class="keywordtype">double</span> spacing</div><div class="line">        = CGAL::compute_average_spacing&lt;Concurrency_tag&gt;</div><div class="line">          (points, nb_neighbors,</div><div class="line">           CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>()));</div><div class="line"></div><div class="line">    <span class="comment">// Then, estimate normals with a fixed radius</span></div><div class="line">    CGAL::pca_estimate_normals&lt;Concurrency_tag&gt;</div><div class="line">        (points,</div><div class="line">         0, <span class="comment">// when using a neighborhood radius, K=0 means no limit on the number of neighbors returns</span></div><div class="line">         CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                          .normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                          .neighbor_radius(2. * spacing)); <span class="comment">// use 2*spacing as neighborhood radius</span></div><div class="line">  }</div><div class="line">  <span class="keywordflow">else</span> <span class="comment">// Use a fixed number of neighbors</span></div><div class="line">  {</div><div class="line">    CGAL::pca_estimate_normals&lt;Concurrency_tag&gt;</div><div class="line">        (points, nb_neighbors,</div><div class="line">         CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                          .normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>()));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Orients normals.</span></div><div class="line">  <span class="comment">// Note: mst_orient_normals() requires a range of points</span></div><div class="line">  <span class="comment">// as well as property maps to access each point's position and normal.</span></div><div class="line">  std::list&lt;PointVectorPair&gt;::iterator unoriented_points_begin =</div><div class="line">      <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga17c3c558c3799b65bd23fba971a82a5c">CGAL::mst_orient_normals</a>(points, nb_neighbors,</div><div class="line">                               CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                                                .normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>()));</div><div class="line"></div><div class="line">  <span class="comment">// Optional: delete points with an unoriented normal</span></div><div class="line">  <span class="comment">// if you plan to call a reconstruction algorithm that expects oriented normals.</span></div><div class="line">  points.erase(unoriented_points_begin, points.end());</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Point_set_processing_3Scanline_orient_normals"></a>
Scanline</h2>
<p>The minimum spanning tree results can give suboptimal results on point clouds with many sharp features and occlusions, which typically happens on airborne acquired urban datasets.</p>
<p><code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gafc3627234666e1fb458e9387e9d5f3c6" title="orients the normals of the range of points by estimating a line of sight and checking its consistency...">scanline_orient_normals()</a></code> is an alternative method specialized for point sets which are ordered in scanline aligned on the XY-plane. It can take advantage of LAS properties provided by some LIDAR scanner and is the best choice of normal orientation when dealing with 2.5D urban scenes.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figmst_scanline_orient_normals"></a></p><div class="image">
<img src="scanline_orient_normals.png" alt="scanline_orient_normals.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figmst_scanline_orient_normals">Figure 80.24</a> Normal orientation of a LIDAR scanline. The point cloud is a typical airborne LIDAR input, sampling a building without normal information and with many occlusions (especially on vertical walls).  </div> <br /> 
<h3><a class="anchor" id="Point_set_processing_3Example_scanline_normals"></a>
Example</h3>
<p>The following example reads a point set from a LAS file, estimates the normals through Jet Fitting and outputs in PLY format the orientation results of all the variants of <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gafc3627234666e1fb458e9387e9d5f3c6" title="orients the normals of the range of points by estimating a line of sight and checking its consistency...">scanline_orient_normals()</a></code>:</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2orient_scanlines_example_8cpp-example.html">Point_set_processing_3/orient_scanlines_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_las_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_ply_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/jet_estimate_normals.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/scanline_orient_normals.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> Kernel = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> Point_3 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ae82b7f4be77dd5b8819ebe419e4ae753">Kernel::Point_3</a>;</div><div class="line"><span class="keyword">using</span> Vector_3 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a39fb0222695ae5e7e32f4e570ea28225">Kernel::Vector_3</a>;</div><div class="line"><span class="keyword">using</span> Point_with_info = std::tuple&lt;Point_3, Vector_3, float, unsigned char&gt;;</div><div class="line"><span class="keyword">using</span> Point_map = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;0, Point_with_info&gt;</a>;</div><div class="line"><span class="keyword">using</span> Normal_map = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;1, Point_with_info&gt;</a>;</div><div class="line"><span class="keyword">using</span> Scan_angle_map = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;2, Point_with_info&gt;</a>;</div><div class="line"><span class="keyword">using</span> Scanline_id_map = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;3, Point_with_info&gt;</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> dump (<span class="keyword">const</span> <span class="keywordtype">char</span>* filename, <span class="keyword">const</span> std::vector&lt;Point_with_info&gt;&amp; points)</div><div class="line">{</div><div class="line">  std::ofstream ofile (filename, std::ios::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a>(ofile);</div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3IOPly.html#ga615f4420ce82b5ceb1b584b506d714ad">CGAL::IO::write_PLY</a></div><div class="line">    (ofile, points,</div><div class="line">     CGAL::parameters::point_map (Point_map()).</div><div class="line">     normal_map (Normal_map()));</div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::string fname (argc &gt; 1 ? argv[1] : <span class="stringliteral">"data/urban.las"</span>);</div><div class="line"></div><div class="line">  std::vector&lt;Point_with_info&gt; points;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Reading input file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">  std::ifstream ifile (fname, std::ios::binary);</div><div class="line">  <span class="keywordflow">if</span> (!ifile ||</div><div class="line">      !<a class="code" href="group__PkgPointSetProcessing3IOLas.html#ga5187fc18430a5e3c811f75da57a057ad">CGAL::IO::read_LAS_with_properties</a></div><div class="line">      (ifile, std::back_inserter (points),</div><div class="line">       <a class="code" href="group__PkgPointSetProcessing3IOLas.html#gac807a7bbde008f9707a1cf697e3eb64c">CGAL::IO::make_las_point_reader</a> (Point_map()),</div><div class="line">       std::make_pair (Scan_angle_map(),</div><div class="line">                       CGAL::IO::LAS_property::Scan_angle()),</div><div class="line">       std::make_pair (Scanline_id_map(),</div><div class="line">                       CGAL::IO::LAS_property::Scan_direction_flag())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Can't read "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Estimating normals"</span> &lt;&lt; std::endl;</div><div class="line">  CGAL::jet_estimate_normals&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (points, 12,</div><div class="line">     CGAL::parameters::point_map (Point_map()).</div><div class="line">     normal_map (Normal_map()));</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Orienting normals using scan angle and direction flag"</span> &lt;&lt; std::endl;</div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#gafc3627234666e1fb458e9387e9d5f3c6">CGAL::scanline_orient_normals</a></div><div class="line">    (points,</div><div class="line">     CGAL::parameters::point_map (Point_map()).</div><div class="line">     normal_map (Normal_map()).</div><div class="line">     scan_angle_map (Scan_angle_map()).</div><div class="line">     scanline_id_map (Scanline_id_map()));</div><div class="line">  dump(<span class="stringliteral">"out_angle_and_flag.ply"</span>, points);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Orienting normals using scan direction flag only"</span> &lt;&lt; std::endl;</div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#gafc3627234666e1fb458e9387e9d5f3c6">CGAL::scanline_orient_normals</a></div><div class="line">    (points,</div><div class="line">     CGAL::parameters::point_map (Point_map()).</div><div class="line">     normal_map (Normal_map()).</div><div class="line">     scanline_id_map (Scanline_id_map()));</div><div class="line">  dump(<span class="stringliteral">"out_flag.ply"</span>, points);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Orienting normals using scan angle only"</span> &lt;&lt; std::endl;</div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#gafc3627234666e1fb458e9387e9d5f3c6">CGAL::scanline_orient_normals</a></div><div class="line">    (points,</div><div class="line">     CGAL::parameters::point_map (Point_map()).</div><div class="line">     normal_map (Normal_map()).</div><div class="line">     scan_angle_map (Scan_angle_map()));</div><div class="line">  dump(<span class="stringliteral">"out_angle.ply"</span>, points);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Orienting normals using no additional info"</span> &lt;&lt; std::endl;</div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#gafc3627234666e1fb458e9387e9d5f3c6">CGAL::scanline_orient_normals</a></div><div class="line">    (points,</div><div class="line">     CGAL::parameters::point_map (Point_map()).</div><div class="line">     normal_map (Normal_map()));</div><div class="line">  dump(<span class="stringliteral">"out_nothing.ply"</span>, points);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Point_set_processing_3Upsampling"></a>
Upsampling</h1>
<p>The function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga8712cbc64f1cfd4dd2f61049a24b90f4" title="This method progressively upsamples the point set while approaching the edge singularities (detected ...">edge_aware_upsample_point_set()</a></code> generates a denser point set from an input point set. This has applications in point-based rendering, hole filling, and sparse surface reconstruction. The algorithm can progressively upsample the point set while approaching the edge singularities. See <a class="el" href="citelist.html#CITEREF_ear-2013">[5]</a> for more details.</p>
<h2><a class="anchor" id="Point_set_processing_3Example_upsampling"></a>
Example</h2>
<p>The following example reads a point set from a file, upsamples it to get a denser result.</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2edge_aware_upsample_point_set_example_8cpp-example.html">Point_set_processing_3/edge_aware_upsample_point_set_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/edge_aware_upsample_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"></div><div class="line"><span class="comment">// Point with normal vector stored in a std::pair.</span></div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Point, Vector&gt; PointVectorPair;</div><div class="line"></div><div class="line"><span class="comment">// Concurrency</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a> Concurrency_tag;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string input_filename = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/before_upsample.xyz"</span>);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* output_filename = (argc&gt;2) ? argv[2] : <span class="stringliteral">"data/before_upsample_UPSAMPLED.xyz"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Reads a .xyz point set file in points[], *with normals*.</span></div><div class="line">  std::vector&lt;PointVectorPair&gt; points;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(input_filename,</div><div class="line">                            std::back_inserter(points),</div><div class="line">                            CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                                             .normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; input_filename &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">//Algorithm parameters</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> sharpness_angle = 25;   <span class="comment">// control sharpness of the result.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> edge_sensitivity = 0;    <span class="comment">// higher values will sample more points near the edges</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> neighbor_radius = 0.25;  <span class="comment">// initial size of neighborhood.</span></div><div class="line">  <span class="keyword">const</span> std::size_t number_of_output_points = points.size() * 4;</div><div class="line"></div><div class="line">   <span class="comment">//Run algorithm</span></div><div class="line">  CGAL::edge_aware_upsample_point_set&lt;Concurrency_tag&gt;(</div><div class="line">    points,</div><div class="line">    std::back_inserter(points),</div><div class="line">    CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>()).</div><div class="line">    normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>()).</div><div class="line">    sharpness_angle(sharpness_angle).</div><div class="line">    edge_sensitivity(edge_sensitivity).</div><div class="line">    neighbor_radius(neighbor_radius).</div><div class="line">    number_of_output_points(number_of_output_points));</div><div class="line"></div><div class="line">  <span class="comment">// Saves point set.</span></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga5822feba4449f0492363611620b877c0">CGAL::IO::write_points</a>(output_filename, points,</div><div class="line">                             CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                                              .normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                                              .stream_precision(17)))</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="Point_set_processing_3Upsample_Parameter1"></a>
Parameter: edge_sensitivity</h3>
<p>This parameter controls where the new points are inserted. Larger values of edge-sensitivity give higher priority to inserting points along the sharp features. For example, as shown in the following figure, high value is preferable when one wants to insert more points on sharp features, where the local gradient is high, e.g., darts, cusps, creases and corners. In contrast, points are evenly inserted when edge_sensitivity is set to 0. The range of possible value is [0, 1].</p>
<p><a class="anchor" id="fig__Point_set_processing_3figUpsample_edge_sensitivity"></a></p><div class="image">
<img src="upsample_edge_sensitivity.jpg" alt="upsample_edge_sensitivity.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figUpsample_edge_sensitivity">Figure 80.25</a> Upsampling for different edge-sensitivity parameter values. The input containing 850 points is upsampled to 1,500 points in all cases depicted.  </div> <br /> 
<h3><a class="anchor" id="Point_set_processing_3Upsample_Parameter2"></a>
Parameter: sharpness_angle</h3>
<p>This parameter controls the preservation of sharp features.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figUpsample_sharpness_angle"></a></p><div class="image">
<img src="upsample_sharpness_angle.jpg" alt="upsample_sharpness_angle.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figUpsample_sharpness_angle">Figure 80.26</a> Upsampling for different sharpness_angle parameter values. The input containing 850 points is upsampled to 425K points in all cases depicted.  </div> <br /> 
<h3><a class="anchor" id="Point_set_processing_3upsample_neighborhood_size"></a>
Parameter: neighbor_radius</h3>
<p>Usually, the neighborhood of sample points should include at least one ring of neighboring sample points. Using small neighborhood size may not be able to insert new points. Using big neighborhood size can fill small holes, but points inserted on the edges could be irregular. The function will use a neighborhood size estimation if this parameter value is set to default or smaller than zero.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figupsample_neighborhood_size"></a></p><div class="image">
<img src="upsample_neighborhood_size.jpg" alt="upsample_neighborhood_size.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figupsample_neighborhood_size">Figure 80.27</a> Comparison between different sizes of neighbor radius.  </div> <br /> 
<h1><a class="anchor" id="Point_set_processing_3FeaturesEstimation"></a>
Feature Edges Estimation</h1>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gac57ce53e3249a66e4c19e85f439ff01e" title="determines if a point is on a sharp feature edge from a point set for which the Voronoi covariance Me...">vcm_is_on_feature_edge()</a></code> indicates if a points belong to a feature edges of the point set using its Voronoi Covariance Measure. It is based on the article <a class="el" href="citelist.html#CITEREF_cgal:mog-vbcfe-11">[9]</a>.</p>
<p>It first computes the VCM of the points set using <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga258a9b3a40d10533f8f01d64b4e91eca" title="computes the Voronoi Covariance Measure (VCM) of a point cloud, a construction that can be used for n...">compute_vcm()</a></code>. Then, it estimates which points belong to a sharp edge by testing if a ratio of eigenvalues is greater than a given threshold.</p>
<h2><a class="anchor" id="Point_set_processing_3Example_sharp_edges"></a>
Example</h2>
<p>The following example reads a point set from a file, estimates the points that are on sharp edges: <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2edges_example_8cpp-example.html">Point_set_processing_3/edges_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/vcm_estimate_edges.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span> <span class="comment">// defines std::pair</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"></div><div class="line"><span class="comment">// Point with normal vector stored in a std::pair.</span></div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Point, Vector&gt; PointVectorPair;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;PointVectorPair&gt; PointList;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::array&lt;double,6&gt; Covariance;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> , <span class="keywordtype">char</span>**)</div><div class="line">{</div><div class="line">  <span class="comment">// Reads a polygon mesh file in points[].</span></div><div class="line">  std::list&lt;PointVectorPair&gt; points;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/fandisk_large.off"</span>),</div><div class="line">                            std::back_inserter(points),</div><div class="line">                            CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file data/fandisk_large.off"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Estimates covariance matrices per points.</span></div><div class="line">  <span class="keywordtype">double</span> R = 0.2,</div><div class="line">         r = 0.1;</div><div class="line">  std::vector&lt;Covariance&gt; cov;</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a> point_map;</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga258a9b3a40d10533f8f01d64b4e91eca">CGAL::compute_vcm</a>(points, cov, R, r,</div><div class="line">                    CGAL::parameters::point_map (point_map).geom_traits (Kernel()));</div><div class="line"></div><div class="line">  <span class="comment">// Find the points on the edges.</span></div><div class="line">  <span class="comment">// Note that this step is not expensive and can be done several time to get better results</span></div><div class="line">  <span class="keywordtype">double</span> threshold = 0.16;</div><div class="line">  std::ofstream output(<span class="stringliteral">"points_on_edges.xyz"</span>);</div><div class="line">  <span class="keywordtype">int</span> i = 0;</div><div class="line">  <span class="keywordflow">for</span>(<span class="keyword">const</span> PointVectorPair&amp; p : points)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__PkgPointSetProcessing3Algorithms.html#gac57ce53e3249a66e4c19e85f439ff01e">CGAL::vcm_is_on_feature_edge</a>(cov[i], threshold))</div><div class="line">      output &lt;&lt; p.first &lt;&lt; <span class="stringliteral">"\n"</span>;</div><div class="line">    ++i;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h1><a class="anchor" id="Point_set_processing_3Structuring"></a>
Structuring</h1>
<p>The function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gaebbc04909dfd575a94f932c8d3bacdce" title="This is an implementation of the Point Set Structuring algorithm. ">structure_point_set()</a></code> generates a structured version of the input point set assigned to a set of planes. Such an input can be produced by a shape detection algorithm (see <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/group__PkgShapeDetectionRef.html">Shape Detection Reference</a>). Point set structuring is based on the article <a class="el" href="citelist.html#CITEREF_cgal:la-srpss-13">[6]</a>.</p>
<ul>
<li><b>Planes</b>: inliers of each detected plane are replaced by sets of noise-free points sampled at the vertices of a regular grid: this is achieved by filling an occupancy grid aligned on the principal components of the inlier sets with a spacing lower than \(\sqrt{2}\) times the user-defined tolerance.</li>
<li><b>Creases</b>: adjacencies between 2 planes are detected and regularly resampled on an occupancy array along the edge with a spacing equal to twice the user-defined tolerance.</li>
<li><b>Corners</b>: 3-cycles are detected from the primitive adjacency graph and sampled using the exact intersection point of the 3 planes (provided it exists and remains in the given tolerance). These corners are also locally clustered to former corners of degree higher than 3.</li>
</ul>
<p>This algorithm is well suited to point sets sampled on surfaces with planar sections and sharp edges.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figstructuring"></a></p><div class="image">
<img src="structuring.png" alt="structuring.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figstructuring">Figure 80.28</a> Point set structuring. Left: input raw point set. Right: structured point set.  </div> <br /> 
<p>Structure information of points can be used to perform feature preserving reconstruction (see <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Advancing_front_surface_reconstruction.tag:../Advancing_front_surface_reconstruction/" href="../Advancing_front_surface_reconstruction/index.html#AFSR_Example_sharp_features">Advancing Front Surface Reconstruction</a> for example). More specifically, the class storing a point set with structure provides the user with a method <code><a class="el" href="classCGAL_1_1Point__set__with__structure.html#ae8890334744d8d7efd17917c62fc1513" title="Computes the coherence of a facet between the 3 points indexed by f with respect to the underlying st...">Point_set_with_structure::facet_coherence()</a></code> that estimates if a triplet of points form a coherent facet.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figstructuring_coherence"></a></p><div class="image">
<img src="structuring_coherence.png" alt="structuring_coherence.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figstructuring_coherence">Figure 80.29</a> (a) Input point set (and structured output); (b) output with many incoherent facets; (c) output with all facets coherent. i, j and k each corresponds to a primitive index.  </div> <br /> 
<h2><a class="anchor" id="Point_set_processing_3Example_9"></a>
Example</h2>
<p>The following example applies shape detection followed by structuring to a point set: <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2structuring_example_8cpp-example.html">Point_set_processing_3/structuring_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Shape_detection/Efficient_RANSAC.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/structure_point_set.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Type declarations</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>  Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                                      Point;</div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Kernel::Point_3, Kernel::Vector_3&gt;         Point_with_normal;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point_with_normal&gt;                       Pwn_vector;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Point_with_normal&gt;</a>  Point_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;Point_with_normal&gt;</a> Normal_map;</div><div class="line"></div><div class="line"><span class="comment">// Efficient RANSAC types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/structCGAL_1_1Shape__detection_1_1Efficient__RANSAC__traits.html">CGAL::Shape_detection::Efficient_RANSAC_traits</a></div><div class="line">  &lt;Kernel, Pwn_vector, Point_map, Normal_map&gt;              Traits;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Efficient__RANSAC.html">CGAL::Shape_detection::Efficient_RANSAC&lt;Traits&gt;</a>    Efficient_ransac;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Plane.html">CGAL::Shape_detection::Plane&lt;Traits&gt;</a>               Plane;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string filename = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/cube.pwn"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Points with normals.</span></div><div class="line">  Pwn_vector points;</div><div class="line"></div><div class="line">  <span class="comment">// Loading point set from a file.</span></div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(filename, std::back_inserter(points),</div><div class="line">                            CGAL::parameters::point_map(Point_map())</div><div class="line">                                             .normal_map(Normal_map())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file cube.pwn"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; points.size() &lt;&lt; <span class="stringliteral">" point(s) read."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Shape detection</span></div><div class="line">  Efficient_ransac ransac;</div><div class="line">  ransac.set_input(points);</div><div class="line">  ransac.add_shape_factory&lt;Plane&gt;();</div><div class="line">  ransac.detect();</div><div class="line"></div><div class="line">  Efficient_ransac::Plane_range planes = ransac.planes();</div><div class="line"></div><div class="line">  Pwn_vector structured_pts;</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#gaebbc04909dfd575a94f932c8d3bacdce">CGAL::structure_point_set</a>(points,</div><div class="line">                            planes,</div><div class="line">                            std::back_inserter(structured_pts),</div><div class="line">                            0.015, <span class="comment">// epsilon for structuring points</span></div><div class="line">                            CGAL::parameters::point_map(Point_map())</div><div class="line">                                             .normal_map(Normal_map())</div><div class="line">                                             .plane_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Plane__map.html">CGAL::Shape_detection::Plane_map&lt;Traits&gt;</a>())</div><div class="line">                                             .plane_index_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Point__to__shape__index__map.html">CGAL::Shape_detection::Point_to_shape_index_map&lt;Traits&gt;</a>(points, planes)));</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; structured_pts.size ()</div><div class="line">            &lt;&lt; <span class="stringliteral">" structured point(s) generated."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3IO.html#ga5822feba4449f0492363611620b877c0">CGAL::IO::write_points</a>(<span class="stringliteral">"out.pwn"</span>, structured_pts,</div><div class="line">                         CGAL::parameters::point_map(Point_map())</div><div class="line">                                          .normal_map(Normal_map())</div><div class="line">                                          .stream_precision(17));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Point_set_processing_3Callbacks"></a>
Callbacks</h1>
<p>Several functions of this package provide a callback mechanism that enables the user to track the progress of the algorithms and to interrupt them if needed. A callback, in this package, is an instance of <code>std::function&lt;bool(double)&gt;</code> that takes the advancement as a parameter (between 0. when the algorithm begins to 1. when the algorithm is completed) and that returns <code>true</code> if the algorithm should carry on, <code>false</code> otherwise. It is passed as a named parameter with an empty function as default.</p>
<p>Algorithms that support this mechanism are detailed in the <a class="el" href="group__PkgPointSetProcessing3Ref.html">Reference Manual</a>, along with the effect that an early interruption has on the output.</p>
<h2><a class="anchor" id="Point_set_processing_3Example_callbacks"></a>
Example</h2>
<p>The following example defines a callback that displays the name of the current algorithm along with the progress (as a percentage) updated every \(1/10th\) of a second. While the algorithm is running, the console output will typically look like this:</p>
<div class="fragment"><div class="line">Computing average spacing: 100%</div><div class="line">Grid simplification: 100%</div><div class="line">Jet smoothing: 54%</div></div><!-- fragment --><p>Thanks to the carriage return character <code>\r</code>, the lines are overwritten and the user sees the percentage increasing on each line.</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2callback_example_8cpp-example.html">Point_set_processing_3/callback_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/point_generators_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/compute_average_spacing.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/grid_simplify_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/jet_smooth_point_set.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/lexical_cast.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> CGAL::Random_points_on_sphere_3&lt;Point&gt; Generator;</div><div class="line"></div><div class="line"><span class="comment">// Concurrency</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a> Concurrency_tag;</div><div class="line"></div><div class="line"><span class="comment">// instance of std::function&lt;bool(double)&gt;</span></div><div class="line"><span class="keyword">struct </span>Progress_to_std_cerr_callback</div><div class="line">{</div><div class="line">  <span class="keyword">mutable</span> std::size_t nb;</div><div class="line">  CGAL::Real_timer timer;</div><div class="line">  <span class="keywordtype">double</span> t_start;</div><div class="line">  <span class="keyword">mutable</span> <span class="keywordtype">double</span> t_latest;</div><div class="line">  <span class="keyword">const</span> std::string name;</div><div class="line"></div><div class="line">  Progress_to_std_cerr_callback (<span class="keyword">const</span> <span class="keywordtype">char</span>* name)</div><div class="line">    : name (name)</div><div class="line">  {</div><div class="line">    timer.start();</div><div class="line">    t_start = timer.time();</div><div class="line">    t_latest = t_start;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> operator()(<span class="keywordtype">double</span> advancement)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="comment">// Avoid calling time() at every single iteration, which could</span></div><div class="line">    <span class="comment">// impact performances very badly</span></div><div class="line">    ++ nb;</div><div class="line">    <span class="keywordflow">if</span> (advancement != 1 &amp;&amp; nb % 100 != 0)</div><div class="line">      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> t = timer.time();</div><div class="line">    <span class="keywordflow">if</span> (advancement == 1 || (t - t_latest) &gt; 0.1) <span class="comment">// Update every 1/10th of second</span></div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">"\r"</span> <span class="comment">// Return at the beginning of same line and overwrite</span></div><div class="line">                &lt;&lt; name &lt;&lt; <span class="stringliteral">": "</span> &lt;&lt; int(advancement * 100) &lt;&lt; <span class="stringliteral">"%"</span>;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (advancement == 1)</div><div class="line">        std::cerr &lt;&lt; std::endl;</div><div class="line">      t_latest = t;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">  <span class="keywordtype">int</span> N = (argc &gt; 1) ? boost::lexical_cast&lt;int&gt;(argv[1]) : 1000;</div><div class="line"></div><div class="line">  <span class="comment">// Generate N points on a sphere of radius 100.</span></div><div class="line">  std::vector&lt;Point&gt; points;</div><div class="line">  points.reserve(N);</div><div class="line">  Generator generator(100.);</div><div class="line">  std::copy_n(generator, N, std::back_inserter(points));</div><div class="line"></div><div class="line">  <span class="comment">// Compute average spacing</span></div><div class="line">  FT average_spacing = CGAL::compute_average_spacing&lt;Concurrency_tag&gt;</div><div class="line">    (points, 6,</div><div class="line">     CGAL::parameters::callback(Progress_to_std_cerr_callback(<span class="stringliteral">"Computing average spacing"</span>)));</div><div class="line"></div><div class="line">  <span class="comment">// Simplify on a grid with a size of twice the average spacing</span></div><div class="line">  points.erase(<a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga7757ef9b3900e42fde26f5a0ac56e20f">CGAL::grid_simplify_point_set</a>(points, 2. * average_spacing,</div><div class="line">                                             CGAL::parameters::callback(Progress_to_std_cerr_callback(<span class="stringliteral">"Grid simplification"</span>))),</div><div class="line">               points.end());</div><div class="line"></div><div class="line">  <span class="comment">// Smooth simplified point set</span></div><div class="line">  CGAL::jet_smooth_point_set&lt;Concurrency_tag&gt;(points, 6,</div><div class="line">                                              CGAL::parameters::callback(Progress_to_std_cerr_callback(<span class="stringliteral">"Jet smoothing"</span>)));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h1><a class="anchor" id="Point_set_processing_3ImplementationHistory"></a>
Implementation History</h1>
<p>Pierre Alliez and Laurent Saboret contributed the initial component. Nader Salman contributed the grid simplification. Started from GSoC'2013, three new algorithms were implemented by Shihao Wu and Clément Jamin: WLOP, bilateral smoothing and upsampling. Started from GSoC'2014, Jocelyn Meyron with the help of Quentin Mérigot introduced the computation of the Voronoi covariance measure of a point set, as well as the normal and feature edge estimation functions based on it. Florent Lafarge with the help of Simon Giraudot contributed the point set structuring algorithm. Started from GSoC'2019, Necip Fazil Yildiran with the help of Nicolas Mellado and Simon Giraudot introduced the wrappers for <a class="el" href="namespaceCGAL_1_1OpenGR.html">OpenGR</a> and PointMatcher libraries that perform registration on two point sets. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jan 30 2023 13:47:22 for CGAL 5.6 - Point Set Processing by
    <a href="https://www.doxygen.nl/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>
</html>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.6 - Point Set Processing
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Point_Set_Processing"></a><a class="anchor" id="chappoint_set_processing_3"></a>  </p><div id="autotoc" class="toc"></div> 
<dl class="section author"><dt>Authors</dt><dd>Pierre Alliez, Simon Giraudot, Clément Jamin, Florent Lafarge, Quentin Mérigot, Jocelyn Meyron, Laurent Saboret, Nader Salman, Shihao Wu, Necip Fazil Yildiran</dd></dl>
<h1><a class="anchor" id="Point_set_processing_3Introduction"></a>
Introduction</h1>
<p>This CGAL component implements methods to analyze and process 3D point sets. The input is an unorganized 3D point set, possibly with normal attributes (unoriented or oriented). The input point set can be analyzed to measure geometric properties such as average spacing between the points and their <code>k</code> nearest neighbors. It can be processed with functions devoted to the simplification, regularization, upsampling, outlier removal, smoothing, normal estimation and normal orientation. The processing of point sets is often needed in applications dealing with measurement data, such as surface reconstruction from laser scanned data (see <a class="el" href="index.html#fig__Point_set_processing_3figintroduction">Figure 80.1</a>).</p>
<p><a class="anchor" id="fig__Point_set_processing_3figintroduction"></a></p><div class="image">
<img src="introduction.jpg" alt="introduction.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figintroduction">Figure 80.1</a> Point set processing. Left: 275K points sampled on the statue of an elephant with a Minolta laser scanner. Right: point set after outlier removal, denoising and simplification to 17K points.  </div> <br /> 
<p>In the context of surface reconstruction we can position the elements of this component along the common surface reconstruction pipeline (<a class="el" href="index.html#fig__Point_set_processing_3figpipeline">Figure 80.2</a>) which involves the following steps:</p><ol type="1">
<li>Scanning and scan registration to produce a set of points or points with normals;</li>
<li>Outlier removal;</li>
<li>Simplification to reduce the number of input points;</li>
<li>Smoothing to reduce noise in the input data;</li>
<li>Normal estimation and orientation when the normals are not already provided by the acquisition device; and</li>
<li>Surface reconstruction. Chapter <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Poisson_surface_reconstruction_3.tag:../Poisson_surface_reconstruction_3/" href="../Poisson_surface_reconstruction_3/index.html#Chapter_Poisson_Surface_Reconstruction">Poisson Surface Reconstruction</a> deals with surface reconstruction from point sets with normal attributes.</li>
</ol>
<p><a class="anchor" id="fig__Point_set_processing_3figpipeline"></a></p><div class="image">
<img src="pipeline.jpg" alt="pipeline.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figpipeline">Figure 80.2</a> Point set processing pipeline for surface reconstruction. The algorithms listed in gray are available from other <a class="el" href="namespaceCGAL.html">CGAL</a> components (bounding volumes and principal component analysis).  </div> <br /> 
<h1><a class="anchor" id="Point_set_processing_3API"></a>
API</h1>
<p>The algorithms of this component take as input parameters ranges of 3D points, or of 3D points with normals. They can be adapted to the user's data structures and make extensive use of <a class="el" href="index.html#Point_set_processing_3NamedParameters">named parameters</a> and of <a class="el" href="index.html#Point_set_processing_3PropertyMaps">property maps</a>:</p>
<div class="fragment"><div class="line">std::vector&lt;PointVectorPair&gt; points;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a> Point_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a> Vector_map;</div><div class="line"></div><div class="line"><a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga078e25209373cab0e1f3524202489771">CGAL::jet_estimate_normals</a></div><div class="line">&lt;<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__tag.html">CGAL::Parallel_tag</a>&gt;           <span class="comment">// concurrency tag</span></div><div class="line">  (points,                     <span class="comment">// input range of points</span></div><div class="line">   12,                         <span class="comment">// parameter: number of neighbors</span></div><div class="line">   <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL_1_1parameters.html">CGAL::parameters</a>::          <span class="comment">// named parameters:</span></div><div class="line">   point_map (Point_map()).    <span class="comment">//  * point map</span></div><div class="line">   normal_map (Vector_map())); <span class="comment">//  * normal map</span></div></div><!-- fragment --><p>This API was introduced in CGAL 4.12. Please refer to the <a class="el" href="index.html#Point_set_processing_3Outdated">dedicated section</a> on how to upgrade from the outdated API.</p>
<h2><a class="anchor" id="Point_set_processing_3NamedParameters"></a>
Named Parameters</h2>
<p>Named parameters are used to deal with optional parameters. The page <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/index.html#BGLNamedParameters">Named Parameters</a> explains the rationale and API in general. The page <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__bgl__namedparameters.html">Named Parameters</a> describes their usage.</p>
<h2><a class="anchor" id="Point_set_processing_3PropertyMaps"></a>
Property Maps</h2>
<p>The property maps are used to access the point or normal information from the input data, so as to let the user decide upon the implementation of a point with normal. The latter can be represented as, e.g., a class derived from the CGAL 3D point, or as a <code>std::pair&lt;<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__3.html">Point_3</a>&lt;K&gt;, <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Vector__3.html">Vector_3</a>&lt;K&gt;&gt;</code>, or as a <code>boost::tuple&lt;..,<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__3.html">Point_3</a>&lt;K&gt;, ..., <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Vector__3.html">Vector_3</a>&lt;K&gt; &gt;</code>.</p>
<p>The following classes described in Chapter <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgPropertyMap">CGAL and Boost Property Maps</a> provide property maps for the implementations of points with normals listed above:</p>
<ul>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Identity__property__map.html">Identity_property_map</a>&lt;T&gt;</code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">First_of_pair_property_map</a>&lt;Pair&gt;</code> and <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">Second_of_pair_property_map</a>&lt;Pair&gt;</code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">Nth_of_tuple_property_map</a>&lt;N, Tuple&gt;</code></li>
</ul>
<p><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Identity__property__map.html">Identity_property_map</a>&lt;<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__3.html">Point_3</a>&gt;</code> is the default value of the position property map expected by all functions in this component.</p>
<p>See below examples using pair and tuple property maps.</p>
<p>Users of this package may use other types to represent positions and normals if they implement the corresponding property maps.</p>
<p>Points and normals can even be stored in separate containers and accessed by their index, as any built-in vector is also a property map.</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2grid_simplify_indices_8cpp-example.html">Point_set_processing_3/grid_simplify_indices.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/grid_simplify_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/fin90_with_PCA_normals.xyz"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Reads a .xyz point set file in points[].</span></div><div class="line">  std::vector&lt;Point&gt; points;</div><div class="line">  std::vector&lt;Vector&gt; normals;</div><div class="line">  std::ifstream stream(fname);</div><div class="line">  Point p;</div><div class="line">  Vector v;</div><div class="line">  <span class="keywordflow">while</span>(stream &gt;&gt; p &gt;&gt; v)</div><div class="line">  {</div><div class="line">    points.push_back(p);</div><div class="line">    normals.push_back(v);</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; points.size() &lt;&lt; <span class="stringliteral">" input points"</span> &lt;&lt; std::endl;</div><div class="line">  std::vector&lt;std::size_t&gt; indices(points.size());</div><div class="line">  <span class="keywordflow">for</span>(std::size_t i = 0; i &lt; points.size(); ++i){</div><div class="line">    indices[i] = i;</div><div class="line">  }</div><div class="line">  <span class="comment">// simplification by clustering using erase-remove idiom</span></div><div class="line">  <span class="keywordtype">double</span> cell_size = 0.05;</div><div class="line">  std::vector&lt;std::size_t&gt;::iterator end;</div><div class="line">  end = <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga7757ef9b3900e42fde26f5a0ac56e20f">CGAL::grid_simplify_point_set</a>(indices,</div><div class="line">                                      cell_size,</div><div class="line">                                      CGAL::parameters::point_map (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/group__PkgPropertyMapRef.html#ga44ae71cce5987f3970443868a129752a">CGAL::make_property_map</a>(points)));</div><div class="line"></div><div class="line">  std::size_t k = end - indices.begin();</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Keep "</span> &lt;&lt; k &lt;&lt; <span class="stringliteral">" of "</span> &lt;&lt; indices.size() &lt;&lt;  <span class="stringliteral">" indices"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  {</div><div class="line">    std::vector&lt;Point&gt; tmp_points(k);</div><div class="line">    std::vector&lt;Vector&gt; tmp_normals(k);</div><div class="line">    <span class="keywordflow">for</span>(std::size_t i=0; i&lt;k; ++i){</div><div class="line">      tmp_points[i] = points[indices[i]];</div><div class="line">      tmp_normals[i] = normals[indices[i]];</div><div class="line">    }</div><div class="line">    points.swap(tmp_points);</div><div class="line">    normals.swap(tmp_normals);</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; points.size() &lt;&lt; <span class="stringliteral">" points after the simplification"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h2><a class="anchor" id="Point_set_processing_3Outdated"></a>
Upgrading from pre-CGAL 4.12 API</h2>
<p>The current API based on ranges and named parameters was introduced in CGAL 4.12. The old API that used pairs of iterators along with usual C++ parameters (with some default values and overloads to handle optional parameters) has been removed in CGAL 5.0.</p>
<p>Translating your pre-CGAL 4.12 code using Point Set Processing to the current API is easy. For example, consider this code using the old API:</p>
<div class="fragment"><div class="line">std::vector&lt;PointVectorPair&gt; points;</div><div class="line"></div><div class="line"><span class="comment">// Old pre-CGAL 4.12 API</span></div><div class="line">CGAL::jet_estimate_normals&lt;Concurrency_tag&gt;</div><div class="line">  (points.begin(), points.end(),</div><div class="line">   <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>(),</div><div class="line">   <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>(),</div><div class="line">   12); <span class="comment">// Number of neighbors</span></div></div><!-- fragment --><p>The pair of iterators is replaced by a range and the optional parameters (than can be deduced automatically in simple cases) are moved to the end of the function in a single named parameter object (see <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/index.html#BGLNamedParameters">Named Parameters</a>). The code translated to the current API becomes:</p>
<div class="fragment"><div class="line">std::vector&lt;PointVectorPair&gt; points;</div><div class="line"></div><div class="line"><span class="comment">// New API</span></div><div class="line">CGAL::jet_estimate_normals&lt;Concurrency_tag&gt;</div><div class="line">  (points,</div><div class="line">   12, <span class="comment">// Number of neighbors</span></div><div class="line">   CGAL::parameters::point_map (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>()).</div><div class="line">   normal_map (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>()));</div></div><!-- fragment --><p>Please refer to the <a class="el" href="group__PkgPointSetProcessing3Ref.html">Reference Manual</a> for the detailed API of the Point Set Processing functions.</p>
<h1><a class="anchor" id="Point_set_processing_3InputOutput"></a>
Input/Output</h1>
<h2><a class="anchor" id="Point_set_processing_3Points_io"></a>
Points And Normals</h2>
<p>CGAL provides functions to read and write sets of points (possibly with normals) from the following file formats:</p>
<ul>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/IOStreamSupportedFileFormats.html#IOStreamXYZ">XYZ </a> (ASCII file three point coordinates <code>x y z</code> per line or three point coordinates and three normal vector coordinates <code>x y z nx ny nz</code> per line)</li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/IOStreamSupportedFileFormats.html#IOStreamOFF">OFF (Object File Format) </a> – <a class="el" href="citelist.html#CITEREF_cgal:p-gmgv16-96">[11]</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/IOStreamSupportedFileFormats.html#IOStreamPLY">PLY (Polygon File Format) </a> – <a class="el" href="citelist.html#CITEREF_cgal:b-ply-11">[12]</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/IOStreamSupportedFileFormats.html#IOStreamLAS">LAS (Lidar Format) </a> – <a class="el" href="citelist.html#CITEREF_cgal:asprs-lasf-13">[1]</a> This format does not handle normals and requires the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartyLASlib">LASlib</a> library.</li>
</ul>
<p>All of the functions in <a class="el" href="group__PkgPointSetProcessing3IO.html">I/O Functions</a> (with the exception of the LAS format) can read and write either points alone or points with normals (depending on whether the <code>normal_map</code> named parameter is used by the user or not). Note that the PLY format handles both ASCII and binary formats. In addition, PLY and LAS are extensible formats that can embed additional properties. These can also be read by CGAL (see Section <a class="el" href="index.html#Point_set_processing_3Properties_io">Points With Properties</a>).</p>
<h3><a class="anchor" id="Point_set_processing_3Example_io"></a>
Example</h3>
<p>The following example reads a point set from an input file and writes it to a file, both in the XYZ format. Positions and normals are stored in pairs and accessed through property maps. <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2read_write_xyz_point_set_example_8cpp-example.html">Point_set_processing_3/read_write_xyz_point_set_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_xyz_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_xyz_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span> <span class="comment">// defines std::pair</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"></div><div class="line"><span class="comment">// Point with normal vector stored as a std::pair.</span></div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Point, Vector&gt; Pwn;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/oni.pwn"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Reads a .xyz point set file in points[].</span></div><div class="line">  <span class="comment">// Note: read_points() requires an output iterator</span></div><div class="line">  <span class="comment">// over points and as well as property maps to access each</span></div><div class="line">  <span class="comment">// point position and normal.</span></div><div class="line">  std::vector&lt;Pwn&gt; points;</div><div class="line">  <span class="keywordflow">if</span>(!CGAL::IO::read_XYZ(fname,</div><div class="line">                         std::back_inserter(points),</div><div class="line">                         CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Pwn&gt;</a>())</div><div class="line">                                          .normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;Pwn&gt;</a>())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Saves point set.</span></div><div class="line">  <span class="comment">// Note: write_XYZ() requires property maps to access each</span></div><div class="line">  <span class="comment">// point position and normal.</span></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IOXyz.html#ga1991ab8d312de62ddd907f81890ed039">CGAL::IO::write_XYZ</a>(<span class="stringliteral">"oni_copy.xyz"</span>, points,</div><div class="line">                          CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Pwn&gt;</a>())</div><div class="line">                                           .normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;Pwn&gt;</a>())</div><div class="line">                                           .stream_precision(17)))</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Point_set_processing_3Properties_io"></a>
Points With Properties</h2>
<p>PLY files are designed to embed an arbitrary number of additional attributes. More specifically, point sets may contain visibility vectors, RGB colors, intensity, etc. As it is not possible to provide dedicated functions to every possible combination of PLY properties, CGAL provides a simple way to read PLY properties and store them in any structure the user needs. Handling of LAS files works similarly with the difference that the property names and types are fixed and defined by the LAS standard.</p>
<p>Functions <code><a class="el" href="group__PkgPointSetProcessing3IOPly.html#gad9785e7191ba94d81fac841798aa1ddb" title="reads user-selected points properties from a .ply stream (ASCII or binary). ">read_PLY_with_properties()</a></code> and <code><a class="el" href="group__PkgPointSetProcessing3IOLas.html#ga5187fc18430a5e3c811f75da57a057ad" title="reads user-selected points properties from a .las or .laz stream. ">read_LAS_with_properties()</a></code> allow the user to read any property needed. The user must provide a set of property handlers that are used to instantiate number types and complex objects from PLY/LAS properties. This handlers are either:</p>
<ul>
<li>a pair consisting of a property map and of a single PLY/LAS property descriptor</li>
<li>a tuple consisting of a property map, a functor to construct the objects wanted and multiple PLY/LAS property descriptors</li>
</ul>
<p>Output functions <code><a class="el" href="group__PkgPointSetProcessing3IOPly.html#gac1fd90a9d5266e631c68cb31bfe31516" title="writes the range of points with properties using Polygon File Format (PLY). ">write_PLY_with_properties()</a></code> and <code><a class="el" href="group__PkgPointSetProcessing3IOLas.html#gafaeb3b48279532412ec422c90a7f05fc" title="writes the range of points with properties to a .las stream. ">write_LAS_with_properties()</a></code> work similarly.</p>
<h3><a class="anchor" id="Point_set_processing_3Example_ply_write"></a>
PLY Writing Example</h3>
<p>The following example shows how to call <code><a class="el" href="group__PkgPointSetProcessing3IOPly.html#gac1fd90a9d5266e631c68cb31bfe31516" title="writes the range of points with properties using Polygon File Format (PLY). ">write_PLY_with_properties()</a></code> to write a point set with points, RGB colors and intensity. Notice that in order to write a complex object, users need to provide an overload of <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1Output__rep.html">CGAL::Output_rep</a></code>.</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2write_ply_points_example_8cpp-example.html">Point_set_processing_3/write_ply_points_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_ply_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"><span class="keyword">typedef</span> std::array&lt;unsigned char, 4&gt; Color;</div><div class="line"></div><div class="line"><span class="comment">// Point with normal, color and intensity</span></div><div class="line"><span class="keyword">typedef</span> std::tuple&lt;Point, Color, int&gt; PCI;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;0, PCI&gt;</a> Point_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;1, PCI&gt;</a> Color_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;2, PCI&gt;</a> Intensity_map;</div><div class="line"></div><div class="line"><span class="comment">// Define how a color should be stored</span></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceCGAL.html">CGAL</a> {</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> F &gt;</div><div class="line"><span class="keyword">struct </span>Output_rep&lt; ::Color, F &gt; {</div><div class="line">  const ::Color&amp; c;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_specialized = <span class="keyword">true</span>;</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1Output__rep.html#a3ecfc0ce6d2e5db55ad05d08c549ce27">Output_rep</a> (const ::Color&amp; c) : c(c)</div><div class="line">  { }</div><div class="line">  std::ostream&amp; <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1Output__rep.html#a022b1af6b20bcd6957908d70b3c9136b">operator() </a>(std::ostream&amp; out)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">if</span> (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#gaf145cf5cbf5e27ebb907a8260002a5f3">IO::is_ascii</a>(out))</div><div class="line">      out &lt;&lt; int(c[0]) &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; int(c[1]) &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; int(c[2]) &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; int(c[3]);</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      out.write(reinterpret_cast&lt;const char*&gt;(&amp;c), <span class="keyword">sizeof</span>(c));</div><div class="line">    <span class="keywordflow">return</span> out;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line">} <span class="comment">// namespace CGAL</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>**)</div><div class="line">{</div><div class="line">  std::vector&lt;PCI&gt; points; <span class="comment">// store points</span></div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 10; ++ i)</div><div class="line">    points.push_back (std::make_tuple (Point (i / 10., i / 20., i / 30.),</div><div class="line">                                               <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__PkgSTLExtensionRef.html#ga6b9a3534a37aeb7d3095ec08801931d7">CGAL::make_array</a> (static_cast&lt;unsigned char&gt;(255 / (i + 1)),</div><div class="line">                                                                 static_cast&lt;unsigned char&gt;(192 / (i + 1)),</div><div class="line">                                                                 static_cast&lt;unsigned char&gt;(128 / (i + 1)),</div><div class="line">                                                                 static_cast&lt;unsigned char&gt;(64 / (i + 1))),</div><div class="line">                                               i));</div><div class="line"></div><div class="line">  std::ofstream f(<span class="stringliteral">"out.ply"</span>, std::ios::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a>(f); <span class="comment">// The PLY file will be written in the binary format</span></div><div class="line"></div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3IOPly.html#gac1fd90a9d5266e631c68cb31bfe31516">CGAL::IO::write_PLY_with_properties</a>(f, points,</div><div class="line">                                      <a class="code" href="group__PkgPointSetProcessing3IOPly.html#ga241c6df9d93e26ec7254ef6366cb7e5b">CGAL::make_ply_point_writer</a> (Point_map()),</div><div class="line">                                      std::make_tuple(Color_map(),</div><div class="line">                                                      <a class="code" href="structCGAL_1_1IO_1_1PLY__property.html">CGAL::IO::PLY_property&lt;unsigned char&gt;</a>(<span class="stringliteral">"red"</span>),</div><div class="line">                                                      <a class="code" href="structCGAL_1_1IO_1_1PLY__property.html">CGAL::IO::PLY_property&lt;unsigned char&gt;</a>(<span class="stringliteral">"green"</span>),</div><div class="line">                                                      <a class="code" href="structCGAL_1_1IO_1_1PLY__property.html">CGAL::IO::PLY_property&lt;unsigned char&gt;</a>(<span class="stringliteral">"blue"</span>),</div><div class="line">                                                      <a class="code" href="structCGAL_1_1IO_1_1PLY__property.html">CGAL::IO::PLY_property&lt;unsigned char&gt;</a>(<span class="stringliteral">"alpha"</span>)),</div><div class="line">                                  std::make_pair(Intensity_map(), <a class="code" href="structCGAL_1_1IO_1_1PLY__property.html">CGAL::IO::PLY_property&lt;int&gt;</a>(<span class="stringliteral">"intensity"</span>)));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="Point_set_processing_3Example_ply_read"></a>
PLY Reading Example</h3>
<p>The following example shows how to call <code><a class="el" href="group__PkgPointSetProcessing3IOPly.html#gad9785e7191ba94d81fac841798aa1ddb" title="reads user-selected points properties from a .ply stream (ASCII or binary). ">read_PLY_with_properties()</a></code> to read a point set with points, normals, RGB colors and intensity and stores these attributes in a user-defined container.</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2read_ply_points_with_colors_example_8cpp-example.html">Point_set_processing_3/read_ply_points_with_colors_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_ply_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"><span class="keyword">typedef</span> std::array&lt;unsigned char, 3&gt; Color;</div><div class="line"></div><div class="line"><span class="comment">// Point with normal, color and intensity</span></div><div class="line"><span class="keyword">typedef</span> std::tuple&lt;Point, Vector, Color, int&gt; PNCI;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;0, PNCI&gt;</a> Point_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;1, PNCI&gt;</a> Normal_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;2, PNCI&gt;</a> Color_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;3, PNCI&gt;</a> Intensity_map;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/colors.ply"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Reads a .ply point set file with normal vectors and colors</span></div><div class="line">  std::vector&lt;PNCI&gt; points; <span class="comment">// store points</span></div><div class="line">  std::ifstream in(fname);</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IOPly.html#gad9785e7191ba94d81fac841798aa1ddb">CGAL::IO::read_PLY_with_properties</a>(in, std::back_inserter(points),</div><div class="line">                                         <a class="code" href="group__PkgPointSetProcessing3IOPly.html#ga3a744d1f9a1c46955cf58866286166ff">CGAL::make_ply_point_reader</a>(Point_map()),</div><div class="line">                                         std::make_pair(Intensity_map(), CGAL::PLY_property&lt;int&gt;(<span class="stringliteral">"intensity"</span>)),</div><div class="line">                                         std::make_tuple(Color_map(),</div><div class="line">                                                         <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Construct__array.html">CGAL::Construct_array</a>(),</div><div class="line">                                                         <a class="code" href="structCGAL_1_1IO_1_1PLY__property.html">CGAL::IO::PLY_property&lt;unsigned char&gt;</a>(<span class="stringliteral">"red"</span>),</div><div class="line">                                                         <a class="code" href="structCGAL_1_1IO_1_1PLY__property.html">CGAL::IO::PLY_property&lt;unsigned char&gt;</a>(<span class="stringliteral">"green"</span>),</div><div class="line">                                                         <a class="code" href="structCGAL_1_1IO_1_1PLY__property.html">CGAL::IO::PLY_property&lt;unsigned char&gt;</a>(<span class="stringliteral">"blue"</span>)),</div><div class="line">                                         <a class="code" href="group__PkgPointSetProcessing3IOPly.html#gaab9a3f1eba6de91187b82af3087afe67">CGAL::IO::make_ply_normal_reader</a>(Normal_map())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Display points read</span></div><div class="line">  <span class="keywordflow">for</span>(std::size_t i = 0; i &lt; points.size (); ++ i)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> Point&amp; p = get&lt;0&gt;(points[i]);</div><div class="line">    <span class="keyword">const</span> Vector&amp; n = get&lt;1&gt;(points[i]);</div><div class="line">    <span class="keyword">const</span> Color&amp; c = get&lt;2&gt;(points[i]);</div><div class="line">    <span class="keywordtype">int</span> I = get&lt;3&gt;(points[i]);</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Point ("</span> &lt;&lt; p</div><div class="line">              &lt;&lt; <span class="stringliteral">") with normal ("</span> &lt;&lt; n</div><div class="line">              &lt;&lt; <span class="stringliteral">"), color ("</span> &lt;&lt; int(c[0]) &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; int(c[1]) &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; int(c[2])</div><div class="line">              &lt;&lt; <span class="stringliteral">") and intensity "</span> &lt;&lt; I &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="Point_set_processing_3Example_las_read"></a>
LAS Reading Example</h3>
<p>The following example shows how to call <code><a class="el" href="group__PkgPointSetProcessing3IOLas.html#ga5187fc18430a5e3c811f75da57a057ad" title="reads user-selected points properties from a .las or .laz stream. ">read_LAS_with_properties()</a></code> to read a point set with points and RGBI colors and stores these attributes in a user-defined container.</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2read_las_example_8cpp-example.html">Point_set_processing_3/read_las_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_las_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> std::array&lt;unsigned short, 4&gt; Color;</div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Point, Color&gt; PointWithColor;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* fname = (argc&gt;1) ? argv[1] : <span class="stringliteral">"data/pig_points.las"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Reads a .las point set file with normal vectors and colors</span></div><div class="line">  std::ifstream in(fname, std::ios_base::binary);</div><div class="line">  std::vector&lt;PointWithColor&gt; points; <span class="comment">// store points</span></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IOLas.html#ga5187fc18430a5e3c811f75da57a057ad">CGAL::IO::read_LAS_with_properties</a>(in, std::back_inserter (points),</div><div class="line">                                         <a class="code" href="group__PkgPointSetProcessing3IOLas.html#gac807a7bbde008f9707a1cf697e3eb64c">CGAL::IO::make_las_point_reader</a>(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointWithColor&gt;</a>()),</div><div class="line">                                         std::make_tuple(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointWithColor&gt;</a>(),</div><div class="line">                                                         <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Construct__array.html">CGAL::Construct_array</a>(),</div><div class="line">                                                         CGAL::IO::LAS_property::R(),</div><div class="line">                                                         CGAL::IO::LAS_property::G(),</div><div class="line">                                                         CGAL::IO::LAS_property::B(),</div><div class="line">                                                         CGAL::IO::LAS_property::I())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(std::size_t i = 0; i &lt; points.size(); ++ i)</div><div class="line">    std::cout &lt;&lt; points[i].first &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/index.html#IOstreamPointSetIO">Point Set IO</a></dd></dl>
<h1><a class="anchor" id="Point_set_processing_3Spacing"></a>
Average Spacing</h1>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga8b330397a3fb68176c851fd7d214b513" title="Computes average spacing from k nearest neighbors. ">compute_average_spacing()</a></code> computes the average spacing of all input points to their <code>k</code> nearest neighbor points, <code>k</code> being specified by the user. As it provides an order of a point set density, this function is used downstream the surface reconstruction pipeline to automatically determine some parameters such as output mesh sizing for surface reconstruction.</p>
<h2><a class="anchor" id="Point_set_processing_3Example_average_spacing"></a>
Example</h2>
<p>The following example reads a point set in the <code>xyz</code> format and computes the average spacing. <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classIndex.html">Index</a>, position and color are stored in a tuple and accessed through property maps. <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2average_spacing_example_8cpp-example.html">Point_set_processing_3/average_spacing_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/compute_average_spacing.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/tuple/tuple.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"></div><div class="line"><span class="comment">// Data type := index, followed by the point, followed by three integers that</span></div><div class="line"><span class="comment">// define the Red Green Blue color of the point.</span></div><div class="line"><span class="keyword">typedef</span> boost::tuple&lt;int, Point, int, int, int&gt; IndexedPointWithColorTuple;</div><div class="line"></div><div class="line"><span class="comment">// Concurrency</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a> Concurrency_tag;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname = (argc&gt;1)?argv[1]:<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/sphere_20k.xyz"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Reads a file in points.</span></div><div class="line">  <span class="comment">// As the point is the second element of the tuple (that is with index 1)</span></div><div class="line">  <span class="comment">// we use a property map that accesses the 1st element of the tuple.</span></div><div class="line"></div><div class="line">  std::vector&lt;IndexedPointWithColorTuple&gt; points;</div><div class="line">  <span class="keywordflow">if</span> (!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname, std::back_inserter(points),</div><div class="line">                             CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;1, IndexedPointWithColorTuple&gt;</a>())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Initialize index and RGB color fields in tuple.</span></div><div class="line">  <span class="comment">// As the index and RGB color are respectively the first and third-fifth elements</span></div><div class="line">  <span class="comment">// of the tuple we use a get function from the property map that accesses the 0</span></div><div class="line">  <span class="comment">// and 2-4th elements of the tuple.</span></div><div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; points.size(); i++)</div><div class="line">  {</div><div class="line">    points[i].get&lt;0&gt;() = i; <span class="comment">// set index value of tuple to i</span></div><div class="line"></div><div class="line">    points[i].get&lt;2&gt;() = 0; <span class="comment">// set RGB color to black</span></div><div class="line">    points[i].get&lt;3&gt;() = 0;</div><div class="line">    points[i].get&lt;4&gt;() = 0;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Computes average spacing.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nb_neighbors = 6; <span class="comment">// 1 ring</span></div><div class="line">  FT average_spacing = CGAL::compute_average_spacing&lt;Concurrency_tag&gt;(</div><div class="line">                         points, nb_neighbors,</div><div class="line">                         CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;1,IndexedPointWithColorTuple&gt;</a>()));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Average spacing: "</span> &lt;&lt; average_spacing &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>Note that other functions such as centroid or bounding volumes are found in other CGAL components:</p>
<ul>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__centroid__grp.html#gacc395064255dfefdb1420309db234210">centroid()</a></code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Principal_component_analysis.tag:../Principal_component_analysis/" href="../Principal_component_analysis/group__PkgPrincipalComponentAnalysisDbb.html#ga7674a40dcf2ee64bebc89d97bf801c1d">bounding_box()</a></code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Bounding_volumes.tag:../Bounding_volumes/" href="../Bounding_volumes/classCGAL_1_1Min__sphere__of__spheres__d.html">Min_sphere_of_spheres_d</a>&lt;Traits&gt;</code></li>
</ul>
<h1><a class="anchor" id="Point_set_processing_3Scale"></a>
Automatic Scale Estimation</h1>
<p>Point sets are often used to sample objects with a higher dimension, typically a curve in 2D or a surface in 3D. In such cases, finding the scale of the object is crucial, that is to say finding the minimal number of points (or the minimal local range) such that the subset of points has the appearance of a curve in 2D or a surface in 3D <a class="el" href="citelist.html#CITEREF_cgal:gcsa-nasr-13">[2]</a>.</p>
<p>CGAL provides two functions that automatically estimate the scale of a 2D point set sampling a curve or a 3D point set sampling a surface:</p>
<ul>
<li><code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga8c6af1df54e336bd0b9a2de6b909bccf" title="Estimates the global scale in a K nearest neighbors sense. ">estimate_global_k_neighbor_scale()</a></code></li>
<li><code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga28fe6443638647be0874b283085eb2cd" title="Estimates the global scale in a range sense. ">estimate_global_range_scale()</a></code></li>
</ul>
<p>Functions such as <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga7757ef9b3900e42fde26f5a0ac56e20f" title="Merges points which belong to the same cell of a grid of cell size = epsilon. ">grid_simplify_point_set()</a></code> require a range scale while <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga078e25209373cab0e1f3524202489771" title="Estimates normal directions of the range of points using jet fitting on the nearest neighbors...">jet_estimate_normals()</a></code>, <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga50c708584a8219847ce04f636dcad4b3" title="Removes outliers: ">remove_outliers()</a></code> or <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gaab0fd78ef3e46c4256e9a1145a9d118e" title="Estimates normal directions of the range of points using the Voronoi Covariance Measure with a radius...">vcm_estimate_normals()</a></code> are examples of functions that accepts both a K neighbor scale or a range scale.</p>
<p>In some specific cases, the scale of a point set might not be homogeneous (for example if the point set contains variable noise). CGAL also provides two functions that automatically estimate the scales of a point set at a set of user-defined query points:</p>
<ul>
<li><code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga6e2493a424482f07d766f12fedefedd0" title="Estimates the local scale in a K nearest neighbors sense on a set of user-defined query points...">estimate_local_k_neighbor_scales()</a></code></li>
<li><code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gaf45220685eff6649d29f600eb66fb6c1" title="Estimates the local scale in a range sense on a set of user-defined query points. ...">estimate_local_range_scales()</a></code></li>
</ul>
<p>The 4 functions presented here work both with 2D points and 3D points and they shouldn't be used if the point sets do not sample a curve in 2D or a surface in 3D.</p>
<h2><a class="anchor" id="Point_set_processing_3Example_scale_estimation_global"></a>
Global Scale Example</h2>
<p>The following example reads a 3D point set in the <code>xyz</code> format and:</p>
<ul>
<li>Estimates the K neighbor global scale</li>
<li>Uses it to smooth the point set</li>
<li>Estimates the range global scale</li>
<li>Uses it to simplify the point set</li>
</ul>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2scale_estimation_example_8cpp-example.html">Point_set_processing_3/scale_estimation_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/estimate_scale.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/jet_smooth_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/grid_simplify_point_set.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Timer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Memory_sizer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Concurrency</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a> Concurrency_tag;</div><div class="line"></div><div class="line"><span class="comment">// Types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point_3;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname = (argc&gt;1)?argv[1]:<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/sphere_20k.xyz"</span>);</div><div class="line"></div><div class="line">  CGAL::Timer task_timer;</div><div class="line"></div><div class="line">  <span class="comment">// read input</span></div><div class="line">  std::vector&lt;Point_3&gt; points;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname, std::back_inserter(points)))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: can't read input file"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// estimate k scale</span></div><div class="line">  task_timer.start();</div><div class="line">  std::size_t k_scale = <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga8c6af1df54e336bd0b9a2de6b909bccf">CGAL::estimate_global_k_neighbor_scale</a> (points);</div><div class="line">  task_timer.stop();</div><div class="line"></div><div class="line">  <span class="comment">// Example: use estimated k as scale for jet smoothing</span></div><div class="line">  CGAL::jet_smooth_point_set&lt;Concurrency_tag&gt;(points, <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(k_scale));</div><div class="line"></div><div class="line">  <span class="comment">// estimate range scale</span></div><div class="line">  task_timer.start();</div><div class="line">  FT range_scale = <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga28fe6443638647be0874b283085eb2cd">CGAL::estimate_global_range_scale</a> (points);</div><div class="line">  task_timer.stop();</div><div class="line"></div><div class="line">  <span class="comment">// Example: use estimated range for grid simplification</span></div><div class="line">  points.erase(<a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga7757ef9b3900e42fde26f5a0ac56e20f">CGAL::grid_simplify_point_set</a>(points, range_scale), points.end());</div><div class="line"></div><div class="line">  <span class="comment">// print some information on runtime</span></div><div class="line">  std::size_t memory = CGAL::Memory_sizer().virtual_size();</div><div class="line">  <span class="keywordtype">double</span> time = task_timer.time();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Scales computed in "</span> &lt;&lt; time &lt;&lt; <span class="stringliteral">" second(s) using "</span></div><div class="line">            &lt;&lt; (memory&gt;&gt;20) &lt;&lt; <span class="stringliteral">" MiB of memory:"</span> &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">" * Global K scale: "</span> &lt;&lt; k_scale &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">" * Global range scale: "</span> &lt;&lt; range_scale &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h2><a class="anchor" id="Point_set_processing_3Example_scale_estimation_local"></a>
Local Scales Example</h2>
<p>This second example generates a 2D point set sampling a circle with variable noise. It then estimates the scale at 3 different query points in the domain.</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2scale_estimation_2d_example_8cpp-example.html">Point_set_processing_3/scale_estimation_2d_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/estimate_scale.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Random.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a> Point_2;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span>, <span class="keywordtype">char</span>**)</div><div class="line">{</div><div class="line">  std::vector&lt;Point_2&gt; samples;</div><div class="line">  samples.reserve (100000);</div><div class="line"></div><div class="line">  <span class="comment">// Generate circle with gradually variable noise</span></div><div class="line">  <span class="comment">//  - noise-free for points with x close to (-1)</span></div><div class="line">  <span class="comment">//  - noisy for points with x close to (+1)</span></div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; 100000; ++ i)</div><div class="line">    {</div><div class="line">      FT theta = CGAL::get_default_random().get_double(0, 2. * CGAL_PI);</div><div class="line">      FT noise = 0.5 * (std::cos(theta) + 1.) * CGAL::get_default_random().get_double(0., 0.2);</div><div class="line">      <span class="keywordtype">int</span> mult = (CGAL::get_default_random().get_bool() ? 1 : -1);</div><div class="line">      samples.push_back (Point_2 (std::cos(theta) * (1. + mult * noise * noise),</div><div class="line">                                  std::sin(theta) * (1. + mult * noise * noise)));</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="comment">// Search for local scales on 3 different locations</span></div><div class="line">  std::vector&lt;Point_2&gt; queries;</div><div class="line">  queries.reserve (3);</div><div class="line">  queries.push_back (Point_2 (-1., 0.));</div><div class="line">  queries.push_back (Point_2 (0., 1.));</div><div class="line">  queries.push_back (Point_2 (1., 0.));</div><div class="line"></div><div class="line">  std::vector&lt;std::size_t&gt; k_scales;</div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga6e2493a424482f07d766f12fedefedd0">CGAL::estimate_local_k_neighbor_scales</a> (samples,</div><div class="line">                                          queries,</div><div class="line">                                          std::back_inserter (k_scales));</div><div class="line"></div><div class="line">  <span class="comment">// Display results</span></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"K-Scales found:"</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">" - On noise-free region: "</span> &lt;&lt; k_scales[0] &lt;&lt; std::endl <span class="comment">// Should be small</span></div><div class="line">            &lt;&lt; <span class="stringliteral">" - On moderately noisy region: "</span> &lt;&lt; k_scales[1] &lt;&lt; std::endl <span class="comment">// Should be higher</span></div><div class="line">            &lt;&lt; <span class="stringliteral">" - On very noisy region: "</span> &lt;&lt; k_scales[2] &lt;&lt; std::endl; <span class="comment">// Should be even higher</span></div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h1><a class="anchor" id="Point_set_processing_3Registration"></a>
Registration</h1>
<p>CGAL provides two functions as wrapper for the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartyOpenGR">OpenGR</a> library <a class="el" href="citelist.html#CITEREF_cgal:m-ogr-17">[7]</a>, and two functions as wrapper for the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartylibpointmatcher">PointMatcher</a> library :</p>
<ul>
<li><code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga1a077db2cedb624e4b4b0ed492598db0" title="Computes the registration of point_set_2 with respect to point_set_1 and returns the corresponding af...">CGAL::OpenGR::compute_registration_transformation()</a></code> computes the registration of one point set w.r.t. another in the form of a <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Aff__transformation__3.html">CGAL::Aff_transformation_3</a></code> object, using the Super4PCS algorithm <a class="el" href="citelist.html#CITEREF_cgal:mam-sffgp-14">[8]</a>;</li>
<li><code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga2d2e21a8a49472a5ed1254f42978608e" title="Computes the registration of point_set_2 with respect to point_set_1 and applies it. ">CGAL::OpenGR::register_point_sets()</a></code> computes the registration of one point set w.r.t. another and directly aligns it to it;</li>
<li><code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga365997b9b06c6576452ec6493b743f52" title="Computes the registration of point_set_2 with respect to point_set_1 and returns the corresponding af...">CGAL::pointmatcher::compute_registration_transformation()</a></code> computes the registration of one point set w.r.t. another in the form of a <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Aff__transformation__3.html">CGAL::Aff_transformation_3</a></code> object, using the ICP (Iterative Closest Point) algorithm;</li>
<li><code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gaa849870cbc74cee3f2f536c70aadf976" title="Computes the registration of point_set_2 with respect to point_set_1 and applies it. ">CGAL::pointmatcher::register_point_sets()</a></code> computes the registration of one point set w.r.t. another and directly aligns it to it.</li>
</ul>
<h2><a class="anchor" id="Point_set_processing_3Examples_registration_OpenGR"></a>
OpenGR Example</h2>
<p>The following example reads two point sets and aligns them using the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartyOpenGR">OpenGR</a> library, using the Super4PCS algorithm: <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2registration_with_OpenGR_8cpp-example.html">Point_set_processing_3/registration_with_OpenGR.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/OpenGR/compute_registration_transformation.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/OpenGR/register_point_sets.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> K;</div><div class="line"><span class="keyword">typedef</span> K::Point_3 Point_3;</div><div class="line"><span class="keyword">typedef</span> K::Vector_3 Vector_3;</div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Point_3, Vector_3&gt; Pwn;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Pwn&gt;</a> Point_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;Pwn&gt;</a> Normal_map;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>params = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL_1_1parameters.html">CGAL::parameters</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname1 = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/hippo1.ply"</span>);</div><div class="line">  <span class="keyword">const</span> std::string fname2 = (argc&gt;2) ? argv[2] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/hippo2.ply"</span>);</div><div class="line"></div><div class="line">  std::vector&lt;Pwn&gt; pwns1, pwns2;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname1, std::back_inserter(pwns1),</div><div class="line">                            CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Pwn&gt;</a>())</div><div class="line">                                             .normal_map(Normal_map())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname1 &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname2, std::back_inserter(pwns2),</div><div class="line">                            CGAL::parameters::point_map(Point_map())</div><div class="line">                                             .normal_map(Normal_map())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname2 &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// EITHER call the registration method Super4PCS from OpenGR to get the transformation to apply to pwns2</span></div><div class="line">  <span class="comment">// std::pair&lt;K::Aff_transformation_3, double&gt; res =</span></div><div class="line">    <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga1a077db2cedb624e4b4b0ed492598db0">CGAL::OpenGR::compute_registration_transformation</a>(pwns1, pwns2,</div><div class="line">                                                      params::point_map(Point_map())</div><div class="line">                                                             .normal_map(Normal_map())</div><div class="line">                                                             .number_of_samples(200)</div><div class="line">                                                             .maximum_running_time(60)</div><div class="line">                                                             .accuracy(0.01),</div><div class="line">                                                      params::point_map(Point_map())</div><div class="line">                                                             .normal_map(Normal_map()));</div><div class="line"></div><div class="line">  <span class="comment">// OR call the registration method Super4PCS from OpenGR and apply the transformation to pwn2</span></div><div class="line">  <span class="keywordtype">double</span> score =</div><div class="line">    <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga2d2e21a8a49472a5ed1254f42978608e">CGAL::OpenGR::register_point_sets</a>(pwns1, pwns2,</div><div class="line">                                      params::point_map(Point_map())</div><div class="line">                                             .normal_map(Normal_map())</div><div class="line">                                             .number_of_samples(200)</div><div class="line">                                             .maximum_running_time(60)</div><div class="line">                                             .accuracy(0.01),</div><div class="line">                                      params::point_map(Point_map())</div><div class="line">                                             .normal_map(Normal_map()));</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga5822feba4449f0492363611620b877c0">CGAL::IO::write_points</a>(<span class="stringliteral">"pwns2_aligned.ply"</span>, pwns2,</div><div class="line">                             CGAL::parameters::point_map(Point_map())</div><div class="line">                                              .normal_map(Normal_map())</div><div class="line">                                              .stream_precision(17)))</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Registration score: "</span> &lt;&lt; score &lt;&lt; <span class="stringliteral">".\n"</span></div><div class="line">            &lt;&lt; <span class="stringliteral">"Transformed version of "</span> &lt;&lt; fname2</div><div class="line">            &lt;&lt; <span class="stringliteral">" written to pwn2_aligned.ply.\n"</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><p><a class="el" href="index.html#fig__Point_set_processing_3tableRegistrationRegistration_visualization_table">Figure 80.4</a> demonstrates visualization of a scan data before and after different registration methods are applied, including the OpenGR registration method. To obtain the results for OpenGR registration in the visualization table, above-mentioned example was used.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_OpenGR_parameter_number_of_samples"></a>
Parameter: number_of_samples</h3>
<p>Input clouds are sub-sampled prior exploration, to ensure fast computations. Super4PCS has a linear complexity w.r.t. the number of input samples, allowing to use larger values than 4PCS. Simple geometry with large overlap can be matched with only 200 samples. However, with Super4PCS, smaller details can be used during the process by using up to thousands of points. There is no theoretical limit to this parameter; however, using too large values leads to very a large congruent set, which requires more time and memory to be explored.</p>
<p>Using a large number of samples is recommended when:</p>
<ul>
<li>geometrical details are required to perform the matching, for instance to disambiguate between several similar configurations,</li>
<li>the clouds have a very low overlap: using a too sparse sampling can result in an empty overlapping area, causing the algorithm to fail,</li>
<li>the clouds are very noisy, and require a dense sampling.</li>
</ul>
<p>Note that Super4PCS is a global registration algorithm, which finds a good approximate of the rigid transformation aligning two clouds. Increasing the number of samples in order to get a fine registration is not optimal: it is usually faster to use fewer samples, and refine the transformation using a local algorithm, like the ICP, or its variant SparseICP.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_OpenGR_parameter_accuracy"></a>
Parameter: accuracy</h3>
<p>This parameter controls the registration accuracy: setting a small value means that the two clouds need to be very close to be considered as well aligned. It is expressed in scene units.</p>
<p>A simple way to understand its impact is to consider the computation of the Largest Common Pointset (LCP), the metric used to verify how aligned the clouds are. For each transformation matrix produced by Super4PCS, <a class="el" href="namespaceCGAL_1_1OpenGR.html">OpenGR</a> computes the LCP measure by considering a shell around the reference cloud, and count the percentage of points of the target cloud lying in the shell. The thickness of the shell is defined by the parameter delta (accuracy).</p>
<p>Using too wide values will slow down the algorithm by increasing the size of the congruent set, while using to small values prevents to find a solution. This parameter impacts other steps of the algorithm, see the paper <a class="el" href="citelist.html#CITEREF_cgal:mam-sffgp-14">[8]</a> for more details.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_OpenGR_parameter_normal"></a>
Parameter: maximum normal deviation</h3>
<p>This parameter sets an angle threshold above which two pairs of points are discarded as candidates for matching. It is expressed in degrees.</p>
<p>The default value is 90° (no filtering). Decreasing this value allows to decrease the computation time by being more selective on candidates. Using too small values might result in ignoring candidates that should indeed have been matched and may thus result in a quality decrease.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_OpenGR_parameter_overlap"></a>
Parameter: overlap</h3>
<p>Ratio of expected overlap between the two point sets: it is ranging between 0 (no overlap) to 1 (100% overlap).</p>
<p>The overlap parameter controls the size of the basis used for registration, as shown below:</p>
<p><a class="anchor" id="fig__Point_set_processing_3figOpenGR_parameter_overlap"></a></p><div class="image">
<img src="super4PCS_overlap.png" alt="super4PCS_overlap.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figOpenGR_parameter_overlap">Figure 80.3</a> The effect of varying overlap parameter on the size of the basis used for registration. The overlap is smaller for left (a) than right (b).  </div> <br /> 
<p>Usually, the larger the overlap, the faster the algorithm. When the overlap is unknown, a simple way to set this parameter is to start from 100% overlap, and decrease the value until obtaining a good result. Using too small values will slow down the algorithm, and reduce the accuracy of the result.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_OpenGR_parameter_maximum_running_time"></a>
Parameter: maximum_running_time</h3>
<p>Maximum number of seconds after which the algorithm stops. Super4PCS explores the transformation space to align the two input clouds. Since the exploration is performed randomly, it is recommended to use a large time value to explore the whole space.</p>
<h2><a class="anchor" id="Point_set_processing_3Examples_registration_PointMatcher"></a>
PointMatcher Example</h2>
<p>The following example reads two point sets and aligns them using the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartylibpointmatcher">PointMatcher</a> library, using the ICP algorithm. It also shows how to customize ICP algorithm by using possible configurations: <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2registration_with_pointmatcher_8cpp-example.html">Point_set_processing_3/registration_with_pointmatcher.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Aff_transformation_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/aff_transformation_tags.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/pointmatcher/compute_registration_transformation.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/pointmatcher/register_point_sets.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> K;</div><div class="line"><span class="keyword">typedef</span> K::Point_3 Point_3;</div><div class="line"><span class="keyword">typedef</span> K::Vector_3 Vector_3;</div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Point_3, Vector_3&gt; Pwn;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Pwn&gt;</a> Point_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;Pwn&gt;</a> Normal_map;</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Weight_map</div><div class="line">{</div><div class="line">  <span class="keyword">typedef</span> Pwn key_type;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> K::FT value_type;</div><div class="line">  <span class="keyword">typedef</span> value_type reference;</div><div class="line">  <span class="keyword">typedef</span> boost::readable_property_map_tag category;</div><div class="line"></div><div class="line">  <span class="keyword">typedef</span> Weight_map Self;</div><div class="line">  <span class="keyword">friend</span> reference <span class="keyword">get</span>(<span class="keyword">const</span> Self&amp;, <span class="keyword">const</span> key_type&amp;) { <span class="keywordflow">return</span> value_type(1); }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>params = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL_1_1parameters.html">CGAL::parameters</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname1 = (argc&gt;1)?argv[1]:<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/hippo1.ply"</span>);</div><div class="line">  <span class="keyword">const</span> std::string fname2 = (argc&gt;2)?argv[2]:<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/hippo2.ply"</span>);</div><div class="line"></div><div class="line">  std::vector&lt;Pwn&gt; pwns1, pwns2;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname1, std::back_inserter(pwns1),</div><div class="line">                            CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Pwn&gt;</a>())</div><div class="line">                                             .normal_map(Normal_map())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname1 &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname2, std::back_inserter(pwns2),</div><div class="line">                            CGAL::parameters::point_map(Point_map())</div><div class="line">                                             .normal_map(Normal_map())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname2 &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="comment">// Prepare ICP config</span></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="keyword">using</span> <a class="code" href="structCGAL_1_1pointmatcher_1_1ICP__config.html">CGAL::pointmatcher::ICP_config</a>;</div><div class="line"></div><div class="line">  <span class="comment">// Possible config modules/components: https://libpointmatcher.readthedocs.io/en/latest/Configuration/#configuration-of-an-icp-chain</span></div><div class="line">  <span class="comment">// See documentation of optional named parameters for CGAL PM ICP configuration / pointmatcher config module mapping</span></div><div class="line"></div><div class="line">  <span class="comment">// Prepare point set 1 filters (PM::ReferenceDataPointsFilters)</span></div><div class="line">  std::vector&lt;ICP_config&gt; point_set_1_filters;</div><div class="line">  point_set_1_filters.push_back( ICP_config { <span class="comment">/*.name=*/</span><span class="stringliteral">"MinDistDataPointsFilter"</span>       , <span class="comment">/*.params=*/</span>{ {<span class="stringliteral">"minDist"</span>, <span class="stringliteral">"0.5"</span> }}  } );</div><div class="line">  point_set_1_filters.push_back( ICP_config { <span class="comment">/*.name=*/</span><span class="stringliteral">"RandomSamplingDataPointsFilter"</span>, <span class="comment">/*.params=*/</span>{ {<span class="stringliteral">"prob"</span>   , <span class="stringliteral">"0.05"</span>}}  } );</div><div class="line"></div><div class="line">  <span class="comment">// Prepare point set 2 filters (PM::ReadingDataPointsFilters)</span></div><div class="line">  std::vector&lt;ICP_config&gt; point_set_2_filters;</div><div class="line">  point_set_2_filters.push_back( ICP_config { <span class="comment">/*.name=*/</span><span class="stringliteral">"MinDistDataPointsFilter"</span>       , <span class="comment">/*.params=*/</span>{ {<span class="stringliteral">"minDist"</span>, <span class="stringliteral">"0.5"</span> }}  } );</div><div class="line">  point_set_2_filters.push_back( ICP_config { <span class="comment">/*.name=*/</span><span class="stringliteral">"RandomSamplingDataPointsFilter"</span>, <span class="comment">/*.params=*/</span>{ {<span class="stringliteral">"prob"</span>   , <span class="stringliteral">"0.05"</span>}}  } );</div><div class="line"></div><div class="line">  <span class="comment">// Prepare matcher function</span></div><div class="line">  ICP_config matcher { <span class="comment">/*.name=*/</span><span class="stringliteral">"KDTreeMatcher"</span>, <span class="comment">/*.params=*/</span>{ {<span class="stringliteral">"knn"</span>, <span class="stringliteral">"1"</span>}, {<span class="stringliteral">"epsilon"</span>, <span class="stringliteral">"3.16"</span>} } };</div><div class="line"></div><div class="line">  <span class="comment">// Prepare outlier filters</span></div><div class="line">  <span class="comment">// NOTE: `GenericDescriptorOutlierFilter` supports only one `descName` that is `weights`!</span></div><div class="line">  std::vector&lt;ICP_config&gt; outlier_filters;</div><div class="line">  outlier_filters.push_back( ICP_config { <span class="comment">/*.name=*/</span><span class="stringliteral">"TrimmedDistOutlierFilter"</span>, <span class="comment">/*.params=*/</span>{ {<span class="stringliteral">"ratio"</span>, <span class="stringliteral">"0.75"</span> }}  } );</div><div class="line">  outlier_filters.push_back( ICP_config { <span class="comment">/*.name=*/</span><span class="stringliteral">"GenericDescriptorOutlierFilter"</span>, <span class="comment">/*.params=*/</span>{ {<span class="stringliteral">"descName"</span>, <span class="stringliteral">"weights"</span> }}  } );</div><div class="line"></div><div class="line">  <span class="comment">// Prepare error minimizer</span></div><div class="line">  ICP_config error_minimizer { <span class="comment">/*.name=*/</span><span class="stringliteral">"PointToPointErrorMinimizer"</span>, <span class="comment">/*.params=*/</span>{ } };</div><div class="line"></div><div class="line">  <span class="comment">// Prepare transformation checker</span></div><div class="line">  std::vector&lt;ICP_config&gt; transformation_checkers;</div><div class="line">  transformation_checkers.push_back( ICP_config { <span class="comment">/*.name=*/</span><span class="stringliteral">"CounterTransformationChecker"</span>, <span class="comment">/*.params=*/</span>{ {<span class="stringliteral">"maxIterationCount"</span>, <span class="stringliteral">"150"</span> }}  } );</div><div class="line">  transformation_checkers.push_back( ICP_config { <span class="comment">/*.name=*/</span><span class="stringliteral">"DifferentialTransformationChecker"</span>, <span class="comment">/*.params=*/</span>{ {<span class="stringliteral">"minDiffRotErr"</span>  , <span class="stringliteral">"0.001"</span> },</div><div class="line">                                                                                                       {<span class="stringliteral">"minDiffTransErr"</span>, <span class="stringliteral">"0.01"</span>  },</div><div class="line">                                                                                                       {<span class="stringliteral">"smoothLength"</span>   , <span class="stringliteral">"4"</span>     } }</div><div class="line">                                                } );</div><div class="line">  <span class="comment">// Prepare inspector</span></div><div class="line">  ICP_config inspector { <span class="comment">/*.name=*/</span><span class="stringliteral">"NullInspector"</span>, <span class="comment">/*.params=*/</span>{ } };</div><div class="line"></div><div class="line">  <span class="comment">// Prepare logger</span></div><div class="line">  ICP_config logger { <span class="comment">/*.name=*/</span><span class="stringliteral">"FileLogger"</span>, <span class="comment">/*.params=*/</span>{ } };</div><div class="line"></div><div class="line">  <span class="keyword">const</span> K::Aff_transformation_3 identity_transform = K::Aff_transformation_3(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Identity__transformation.html">CGAL::Identity_transformation</a>());</div><div class="line"></div><div class="line">  <span class="comment">// EITHER call the ICP registration method pointmatcher to get the transformation to apply to pwns2</span></div><div class="line">  std::pair&lt;K::Aff_transformation_3, bool&gt; res =</div><div class="line">    <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga365997b9b06c6576452ec6493b743f52">CGAL::pointmatcher::compute_registration_transformation</a></div><div class="line">      (pwns1, pwns2,</div><div class="line">       params::point_map(Point_map()).normal_map(Normal_map()).scalar_map(Weight_map())</div><div class="line">                                     .point_set_filters(point_set_1_filters)</div><div class="line">                                     .matcher(matcher)</div><div class="line">                                     .outlier_filters(outlier_filters)</div><div class="line">                                     .error_minimizer(error_minimizer)</div><div class="line">                                     .transformation_checkers(transformation_checkers)</div><div class="line">                                     .inspector(inspector)</div><div class="line">                                     .logger(logger),</div><div class="line">       params::point_map(Point_map()).normal_map(Normal_map()).scalar_map(Weight_map())</div><div class="line">                                     .point_set_filters(point_set_2_filters)</div><div class="line">                                     .transformation(identity_transform) <span class="comment">/* initial transform for pwns2.</span></div><div class="line"><span class="comment">                                                                          * default value is already identity transform.</span></div><div class="line"><span class="comment">                                                                          * a proper initial transform could be given, for example,</span></div><div class="line"><span class="comment">                                                                          * a transform returned from a coarse registration algorithm.</span></div><div class="line"><span class="comment">                                                                          * */</span></div><div class="line">       );</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> converged = <span class="keyword">false</span>;</div><div class="line">  <span class="keywordflow">do</span></div><div class="line">  {</div><div class="line">    <span class="comment">// OR call the ICP registration method from pointmatcher and apply the transformation to pwn2</span></div><div class="line">    converged =</div><div class="line">      <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#gaa849870cbc74cee3f2f536c70aadf976">CGAL::pointmatcher::register_point_sets</a></div><div class="line">      (pwns1, pwns2,</div><div class="line">       params::point_map(Point_map()).normal_map(Normal_map())</div><div class="line">       .point_set_filters(point_set_1_filters)</div><div class="line">       .matcher(matcher)</div><div class="line">       .outlier_filters(outlier_filters)</div><div class="line">       .error_minimizer(error_minimizer)</div><div class="line">       .transformation_checkers(transformation_checkers)</div><div class="line">       .inspector(inspector)</div><div class="line">       .logger(logger),</div><div class="line">       params::point_map(Point_map()).normal_map(Normal_map())</div><div class="line">       .point_set_filters(point_set_2_filters)</div><div class="line">       .transformation(res.first) <span class="comment">/* pass the above computed transformation as initial transformation.</span></div><div class="line"><span class="comment">                                   * as a result, the registration will require less iterations to converge.</span></div><div class="line"><span class="comment">                                   * */</span></div><div class="line">        );</div><div class="line"></div><div class="line">    <span class="comment">// Algorithm may randomly not converge, repeat until it does</span></div><div class="line">    <span class="keywordflow">if</span> (converged)</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">"Success"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">"Did not converge, try again"</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">while</span> (!converged);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga5822feba4449f0492363611620b877c0">CGAL::IO::write_points</a>(<span class="stringliteral">"pwns2_aligned.ply"</span>, pwns2,</div><div class="line">                             CGAL::parameters::point_map(Point_map()).normal_map(Normal_map())))</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Transformed version of "</span> &lt;&lt; fname2 &lt;&lt; <span class="stringliteral">" written to pwn2_aligned.ply.\n"</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><p><a class="el" href="index.html#fig__Point_set_processing_3tableRegistrationRegistration_visualization_table">Figure 80.4</a> demonstrates visualization of a scan data before and after different registration methods are applied, including the PointMatcher registration method. To obtain the results for PointMatcher registration in the visualization table, above-mentioned example was used.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_PointMatcher_parameter_point_set_filters"></a>
Parameter: point_set_filters</h3>
<p>The chain of filters to be applied to the point cloud. The point cloud is processed into an intermediate point cloud with the given chain of filters to be used in the alignment procedure. The chain is organized with the forward traversal order of the point set filters range.</p>
<p>The chain of point set filters are applied only once at the beginning of the ICP procedure, i.e., before the first iteration of the ICP algorithm.</p>
<p>The filters can have several purposes, including but not limited to:</p>
<ul>
<li>removal of noisy points which render alignment of point clouds difficult,</li>
<li>removal of redundant points so as to speed up alignment,</li>
<li>addition of descriptive information to the points such as a surface normal vector or the direction from the point to the sensor.</li>
</ul>
<p>In registration, there are two point clouds in consideration, one of which is the reference point cloud while the other one is the point cloud to register. The point set filters corresponds to <code>readingDataPointsFilters</code> configuration module of <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartylibpointmatcher">PointMatcher</a> library while it corresponds to the <code>referenceDataPointsFilters</code> for the other point cloud. The filters should be chosen and set from possible components of those configuration modules.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_PointMatcher_parameter_matcher"></a>
Parameter: matcher</h3>
<p>The method used for matching (linking) the points from to the points in the reference cloud.</p>
<p>Corresponds to <code>matcher</code> configuration module of <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartylibpointmatcher">PointMatcher</a> library. The matcher should be chosen and set from possible components of the <code>matcher</code> configuration module. See <a href="https://libpointmatcher.readthedocs.io/en/latest/Configuration/#configuration-of-an-icp-chain">libpointmatcher documentation</a> for possible configurations.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_PointMatcher_parameter_outlier_filters"></a>
Parameter: outlier_filters</h3>
<p>The chain of filters to be applied to the matched (linked) point clouds after each processing iteration of the ICP algorithm to remove the links which do not correspond to true point correspondences. The outliers are rejected. Points with no link are ignored in the subsequent error minimization step. The chain is organized with the forward traversal order of the outlier filters range.</p>
<p>Corresponds to <code>outlierFilters</code> configuration module of <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartylibpointmatcher">PointMatcher</a> library. The filters should be chosen and set from possible components of the <code>outlierFilters</code> configuration module. See <a href="https://libpointmatcher.readthedocs.io/en/latest/Configuration/#configuration-of-an-icp-chain">libpointmatcher documentation</a> for possible configurations.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_PointMatcher_parameter_error_minimizer"></a>
Parameter: error_minimizer</h3>
<p>The error minimizer that computes a transformation matrix such as to minimize the error between the point sets.</p>
<p>Corresponds to <code>errorMinimizer</code> configuration module of <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartylibpointmatcher">PointMatcher</a> library. The error minimizer should be chosen and set from possible components of the <code>errorMinimizer</code> configuration module. See <a href="https://libpointmatcher.readthedocs.io/en/latest/Configuration/#configuration-of-an-icp-chain">libpointmatcher documentation</a> for possible configurations.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_PointMatcher_parameter_inspector"></a>
Parameter: inspector</h3>
<p>The inspector allows to log data at different steps for analysis. Inspectors typically provide deeper scrutiny than the logger.</p>
<p>Corresponds to <code>inspector</code> configuration module of <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartylibpointmatcher">PointMatcher</a> library. The inspector should be chosen and set from possible components of the <code>inspector</code> configuration module. See <a href="https://libpointmatcher.readthedocs.io/en/latest/Configuration/#configuration-of-an-icp-chain">libpointmatcher documentation</a> for possible configurations.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_PointMatcher_parameter_logger"></a>
Parameter: logger</h3>
<p>The method for logging information regarding the registration process outputted by <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartylibpointmatcher">PointMatcher</a> library. The logs generated by <a class="el" href="namespaceCGAL.html">CGAL</a> library does not get effected by this configuration.</p>
<p>Corresponds to <code>logger</code> configuration module of <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartylibpointmatcher">PointMatcher</a> library. The logger should be chosen and set from possible components of the <code>logger</code> configuration module. See <a href="https://libpointmatcher.readthedocs.io/en/latest/Configuration/#configuration-of-an-icp-chain">libpointmatcher documentation</a> for possible configurations.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_PointMatcher_parameter_transformation"></a>
Parameter: transformation</h3>
<p>The affine transformation that is used as the initial transformation for the reference point cloud.</p>
<h2><a class="anchor" id="Point_set_processing_3Examples_registration_OpenGR_PointMatcher_Pipeline"></a>
OpenGR/PointMatcher Pipeline Example</h2>
<p>The following example reads two point sets and aligns them by using both <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartyOpenGR">OpenGR</a> and <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartylibpointmatcher">PointMatcher</a> libraries, respectively. It depicts a use case where a coarse estimation of a registration transformation is done using the Super4PCS algorithm. Then, a fine registration from this coarse registration using the ICP algorithm. <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2registration_with_opengr_pointmatcher_pipeline_8cpp-example.html">Point_set_processing_3/registration_with_opengr_pointmatcher_pipeline.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Aff_transformation_3.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/pointmatcher/register_point_sets.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/OpenGR/compute_registration_transformation.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> K;</div><div class="line"><span class="keyword">typedef</span> K::Point_3 Point_3;</div><div class="line"><span class="keyword">typedef</span> K::Vector_3 Vector_3;</div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Point_3, Vector_3&gt; Pwn;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Pwn&gt;</a> Point_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;Pwn&gt;</a> Normal_map;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>params = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL_1_1parameters.html">CGAL::parameters</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname1 = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/hippo1.ply"</span>);</div><div class="line">  <span class="keyword">const</span> std::string fname2 = (argc&gt;2) ? argv[2] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/hippo2.ply"</span>);</div><div class="line"></div><div class="line">  std::vector&lt;Pwn&gt; pwns1, pwns2;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname1, std::back_inserter(pwns1),</div><div class="line">                            CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Pwn&gt;</a>())</div><div class="line">                                             .normal_map (Normal_map())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname1 &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname2, std::back_inserter(pwns2),</div><div class="line">                            CGAL::parameters::point_map(Point_map())</div><div class="line">                                             .normal_map(Normal_map())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname2 &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Computing registration transformation using OpenGR Super4PCS.."</span> &lt;&lt; std::endl;</div><div class="line">  <span class="comment">// First, compute registration transformation using OpenGR Super4PCS</span></div><div class="line">  K::Aff_transformation_3 res =</div><div class="line">    std::get&lt;0&gt;( <span class="comment">// get first of pair, which is the transformation</span></div><div class="line">      <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga1a077db2cedb624e4b4b0ed492598db0">CGAL::OpenGR::compute_registration_transformation</a></div><div class="line">        (pwns1, pwns2,</div><div class="line">         params::point_map(Point_map()).normal_map(Normal_map()),</div><div class="line">         params::point_map(Point_map()).normal_map(Normal_map())));</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Computing registration transformation using PointMatcher ICP, "</span></div><div class="line">            &lt;&lt; <span class="stringliteral">"taking transformation computed by OpenGR Super4PCS as initial transformation.."</span> &lt;&lt; std::endl;</div><div class="line">  <span class="comment">// Then, compute registration transformation using PointMatcher ICP, taking transformation computed</span></div><div class="line">  <span class="comment">// by OpenGR as initial transformation, and apply the transformation to pwns2</span></div><div class="line">  <span class="comment">// bool converged =</span></div><div class="line">    <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#gaa849870cbc74cee3f2f536c70aadf976">CGAL::pointmatcher::register_point_sets</a></div><div class="line">      (pwns1, pwns2,</div><div class="line">       params::point_map(Point_map()).normal_map(Normal_map()),</div><div class="line">       params::point_map(Point_map()).normal_map(Normal_map()).transformation(res));</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga5822feba4449f0492363611620b877c0">CGAL::IO::write_points</a>(<span class="stringliteral">"pwns2_aligned.ply"</span>, pwns2,</div><div class="line">                             CGAL::parameters::point_map(Point_map())</div><div class="line">                                              .normal_map(Normal_map())))</div><div class="line">  {</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Transformed version of "</span> &lt;&lt; fname2</div><div class="line">            &lt;&lt; <span class="stringliteral">" written to pwn2_aligned.ply.\n"</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><p><a class="el" href="index.html#fig__Point_set_processing_3tableRegistrationRegistration_visualization_table">Figure 80.4</a> demonstrates visualization of a scan data before and after different registration methods are applied, including the pipeline of OpenGR and PointMatcher registration methods. To obtain the results for the pipeline of OpenGR and PointMatcher registration methods in the visualization table, above-mentioned example was used.</p>
<p><a class="anchor" id="fig__Point_set_processing_3tableRegistrationRegistration_visualization_table"></a></p><table class="doxtable">
<tr>
<th></th><th>Scan 1  </th><th>Scan 1 (possibly transformed, green) and Scan 2 (the reference, red)  </th></tr>
<tr>
<th>Unregistered </th><td><a class="anchor" id="fig__Point_set_processing_3figRegistrationUnregistered_hippo2_view1"></a><div class="image">
<img src="registration_view1_hippo2_unregistered.png" alt="registration_view1_hippo2_unregistered.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figRegistrationUnregistered_hippo2_view1">Figure 80.5</a>  </div> <br />   </td><td><a class="anchor" id="fig__Point_set_processing_3figRegistrationUnregistered_hippo1_hippo2_view1"></a><div class="image">
<img src="registration_view1_hippo1_hippo2_unregistered.png" alt="registration_view1_hippo1_hippo2_unregistered.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figRegistrationUnregistered_hippo1_hippo2_view1">Figure 80.6</a>  </div> <br />    </td></tr>
<tr>
<th>Registered using OpenGR  </th><td><a class="anchor" id="fig__Point_set_processing_3figRegistrationOpenGR_hippo2_view1"></a><div class="image">
<img src="registration_view1_hippo2_opengr.png" alt="registration_view1_hippo2_opengr.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figRegistrationOpenGR_hippo2_view1">Figure 80.7</a>  </div> <br />   </td><td><a class="anchor" id="fig__Point_set_processing_3figRegistrationOpenGR_hippo1_hippo2_view1"></a><div class="image">
<img src="registration_view1_hippo1_hippo2_opengr.png" alt="registration_view1_hippo1_hippo2_opengr.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figRegistrationOpenGR_hippo1_hippo2_view1">Figure 80.8</a>  </div> <br />    </td></tr>
<tr>
<th>Registered using PointMatcher  </th><td><a class="anchor" id="fig__Point_set_processing_3figRegistrationPointMatcher_hippo2_view1"></a><div class="image">
<img src="registration_view1_hippo2_pointmatcher.png" alt="registration_view1_hippo2_pointmatcher.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figRegistrationPointMatcher_hippo2_view1">Figure 80.9</a>  </div> <br />   </td><td><a class="anchor" id="fig__Point_set_processing_3figRegistrationPointMatcher_hippo1_hippo2_view1"></a><div class="image">
<img src="registration_view1_hippo1_hippo2_pointmatcher.png" alt="registration_view1_hippo1_hippo2_pointmatcher.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figRegistrationPointMatcher_hippo1_hippo2_view1">Figure 80.10</a>  </div> <br />    </td></tr>
<tr>
<th>Registered using OpenGR+PointMatcher Pipeline  </th><td><a class="anchor" id="fig__Point_set_processing_3figRegistrationPipeline_hippo2_view1"></a><div class="image">
<img src="registration_view1_hippo2_opengr_pointmatcher_pipeline.png" alt="registration_view1_hippo2_opengr_pointmatcher_pipeline.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figRegistrationPipeline_hippo2_view1">Figure 80.11</a>  </div> <br />   </td><td><a class="anchor" id="fig__Point_set_processing_3figRegistrationPipeline_hippo1_hippo2_view1"></a><div class="image">
<img src="registration_view1_hippo1_hippo2_opengr_pointmatcher_pipeline.png" alt="registration_view1_hippo1_hippo2_opengr_pointmatcher_pipeline.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figRegistrationPipeline_hippo1_hippo2_view1">Figure 80.12</a>  </div> <br />    </td></tr>
</table>
<p> </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3tableRegistrationRegistration_visualization_table">Figure 80.4</a> Visualization of registered hippo scans with different registration methods. Two scans are used: red as the reference, green as the one for which the transformation is computed and applied. To obtain the results, the example code given in <a class="el" href="index.html#Point_set_processing_3Examples_registration_OpenGR">OpenGR Example</a> , <a class="el" href="index.html#Point_set_processing_3Examples_registration_PointMatcher">PointMatcher Example</a> , <a class="el" href="index.html#Point_set_processing_3Examples_registration_OpenGR_PointMatcher_Pipeline">OpenGR/PointMatcher Pipeline Example</a> were applied, respectively. The parameters of the algorithms used to obtain those results are not optimized for the shown scans; therefore, better parameter choice might result in better results in terms of registration accuracy for each algorithm individually.  </div> <br /> 
<h1><a class="anchor" id="Point_set_processing_3Clustering"></a>
Clustering</h1>
<p>If an input point set represents several objects which are spatially separated, a clustering algorithm can be applied to identify connected components on a nearest neighbor graph built using a query sphere of fixed radius centered on each point.</p>
<p>The clustering is stored in a cluster map which associates each input point with the index of the cluster it belongs to: users can then use this map however they find it relevant to their use case, for example segmenting the input point set into one point set per cluster. <a class="el" href="index.html#fig__Point_set_processing_3figclustering">Figure 80.13</a> shows different clustering outputs.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figclustering"></a></p><div class="image">
<img src="clustering.png" alt="clustering.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figclustering">Figure 80.13</a> Point Set Clustering outputs (one color per cluster). Top: input point set and clustering using a neighbor radius of 1.5 (147 clusters extracted). Bottom: clustering with neighbor radius 3.0 (37 clusters extracted), and with neighbor radius 6.0 (5 clusters extracted).  </div> <br /> 
<h2><a class="anchor" id="Point_set_processing_3Example_clustering"></a>
Example</h2>
<p>In the following example, clusters (and adjacencies between them) are computed and stored as colors in a PLY file:</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2clustering_example_8cpp-example.html">Point_set_processing_3/clustering_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3/IO.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/cluster_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/compute_average_spacing.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Random.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> Kernel = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div><div class="line"><span class="keyword">using</span> Point_3 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ae82b7f4be77dd5b8819ebe419e4ae753">Kernel::Point_3</a>;</div><div class="line"><span class="keyword">using</span> Point_set = CGAL::Point_set_3&lt;Point_3&gt;;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="comment">// Read input file</span></div><div class="line">  std::ifstream ifile((argc &gt; 1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/hippo1.ply"</span>), std::ios_base::binary);</div><div class="line">  Point_set points;</div><div class="line">  ifile &gt;&gt; points;</div><div class="line"></div><div class="line">  <span class="comment">// Add a cluster map</span></div><div class="line">  Point_set::Property_map&lt;int&gt; cluster_map = points.add_property_map&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">"cluster"</span>, -1).first;</div><div class="line"></div><div class="line">  <span class="comment">// Compute average spacing</span></div><div class="line">  <span class="keywordtype">double</span> spacing = CGAL::compute_average_spacing&lt;CGAL::Parallel_if_available_tag&gt; (points, 12);</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Spacing = "</span> &lt;&lt; spacing &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Adjacencies stored in vector</span></div><div class="line">  std::vector&lt;std::pair&lt;std::size_t, std::size_t&gt; &gt; adjacencies;</div><div class="line"></div><div class="line">  <span class="comment">// Compute clusters</span></div><div class="line">  CGAL::Real_timer t;</div><div class="line">  t.start();</div><div class="line">  std::size_t nb_clusters</div><div class="line">    = <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga2531a1366bea67edef99e87d6b8819ec">CGAL::cluster_point_set</a>(points, cluster_map,</div><div class="line">                              points.parameters().neighbor_radius(spacing)</div><div class="line">                                                 .adjacencies(std::back_inserter(adjacencies)));</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Found "</span> &lt;&lt; nb_clusters &lt;&lt; <span class="stringliteral">" clusters with "</span> &lt;&lt; adjacencies.size()</div><div class="line">            &lt;&lt; <span class="stringliteral">" adjacencies in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" seconds"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Output a colored PLY file</span></div><div class="line">  Point_set::Property_map&lt;unsigned char&gt; red = points.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"red"</span>, 0).first;</div><div class="line">  Point_set::Property_map&lt;unsigned char&gt; green = points.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"green"</span>, 0).first;</div><div class="line">  Point_set::Property_map&lt;unsigned char&gt; blue = points.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"blue"</span>, 0).first;</div><div class="line">  <span class="keywordflow">for</span>(Point_set::Index idx : points)</div><div class="line">  {</div><div class="line">    <span class="comment">// One color per cluster</span></div><div class="line">    CGAL::Random rand (cluster_map[idx]);</div><div class="line">    red[idx] = rand.get_int(64, 192);</div><div class="line">    green[idx] = rand.get_int(64, 192);</div><div class="line">    blue[idx] = rand.get_int(64, 192);</div><div class="line">  }</div><div class="line"></div><div class="line">  std::ofstream ofile(<span class="stringliteral">"out.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a>(ofile);</div><div class="line">  ofile &lt;&lt; points;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Point_set_processing_3OutlierRemoval"></a>
Outlier Removal</h1>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga50c708584a8219847ce04f636dcad4b3" title="Removes outliers: ">remove_outliers()</a></code> deletes a user-specified fraction of outliers from an input point set. More specifically, it partitions the input points with respect to the average squared distances to their nearest neighbors and deletes the points with largest value, either partitioning with a threshold or removing a fixed percentage. The user can either specify a fixed number of nearest neighbors or a fixed spherical neighborhood radius.</p>
<h2><a class="anchor" id="Point_set_processing_3Example_outlier_removal"></a>
Example</h2>
<p>The following example reads a point set and removes 5% of the points. It uses the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Identity__property__map.html">Identity_property_map</a>&lt;<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__3.html">Point_3</a>&gt;</code> property map (optional as it is the default position property map of all functions in this component.) <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2remove_outliers_example_8cpp-example.html">Point_set_processing_3/remove_outliers_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/compute_average_spacing.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/remove_outliers.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname = (argc&gt;1)?argv[1]:<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/oni.pwn"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Reads a point set file in points[].</span></div><div class="line">  <span class="comment">// The Identity_property_map property map can be omitted here as it is the default value.</span></div><div class="line">  std::vector&lt;Point&gt; points;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname, std::back_inserter(points),</div><div class="line">                            CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map&lt;Point&gt;</a>())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Removes outliers using erase-remove idiom.</span></div><div class="line">  <span class="comment">// The Identity_property_map property map can be omitted here as it is the default value.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_neighbors = 24; <span class="comment">// considers 24 nearest neighbor points</span></div><div class="line"></div><div class="line">  <span class="comment">// Estimate scale of the point set with average spacing</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> average_spacing = CGAL::compute_average_spacing&lt;CGAL::Sequential_tag&gt;(points, nb_neighbors);</div><div class="line"></div><div class="line">  <span class="comment">// FIRST OPTION //</span></div><div class="line">  <span class="comment">// I don't know the ratio of outliers present in the point set</span></div><div class="line">  std::vector&lt;Point&gt;::iterator first_to_remove</div><div class="line">    = CGAL::remove_outliers&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (points,</div><div class="line">     nb_neighbors,</div><div class="line">     CGAL::parameters::threshold_percent (100.). <span class="comment">// No limit on the number of outliers to remove</span></div><div class="line">     threshold_distance (2. * average_spacing)); <span class="comment">// Point with distance above 2*average_spacing are considered outliers</span></div><div class="line"></div><div class="line">  std::cerr &lt;&lt; (100. * std::distance(first_to_remove, points.end()) / static_cast&lt;double&gt;(points.size()))</div><div class="line">            &lt;&lt; <span class="stringliteral">"% of the points are considered outliers when using a distance threshold of "</span></div><div class="line">            &lt;&lt; 2. * average_spacing &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// SECOND OPTION //</span></div><div class="line">  <span class="comment">// I know the ratio of outliers present in the point set</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> removed_percentage = 5.0; <span class="comment">// percentage of points to remove</span></div><div class="line"></div><div class="line">  points.erase(CGAL::remove_outliers&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">               (points,</div><div class="line">                nb_neighbors,</div><div class="line">                CGAL::parameters::threshold_percent(removed_percentage). <span class="comment">// Minimum percentage to remove</span></div><div class="line">                threshold_distance(0.)), <span class="comment">// No distance threshold (can be omitted)</span></div><div class="line">               points.end());</div><div class="line"></div><div class="line">  <span class="comment">// Optional: after erase(), use Scott Meyer's "swap trick" to trim excess capacity</span></div><div class="line">  std::vector&lt;Point&gt;(points).swap(points);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Point_set_processing_3Simplification"></a>
Simplification</h1>
<p>Four simplification functions are devised to reduce an input point set.</p>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga4be2d94f1791d24b8ba0107bc33ad6dc" title="Randomly deletes a user-specified fraction of the input points. ">random_simplify_point_set()</a></code> randomly deletes a user-specified fraction of points from the input point set. This algorithm is the fastest.</p>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga7757ef9b3900e42fde26f5a0ac56e20f" title="Merges points which belong to the same cell of a grid of cell size = epsilon. ">grid_simplify_point_set()</a></code> considers a regular grid covering the bounding box of the input point set, and clusters all points sharing the same cell of the grid by picking as representative one arbitrarily chosen point: representatives may only be retained in cells that have more than a user-defined minimum number of points in order to also filter out low density areas and outliers. This algorithm is still fast, although slower than <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga4be2d94f1791d24b8ba0107bc33ad6dc" title="Randomly deletes a user-specified fraction of the input points. ">random_simplify_point_set()</a></code>.</p>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga3420351b6d3fad079d13f894f42e9d03" title="Recursively split the point set in smaller clusters until the clusters have fewer than size elements ...">hierarchy_simplify_point_set()</a></code> provides an adaptive simplification of the point set through local clusters <a class="el" href="citelist.html#CITEREF_cgal:pgk-esops-02">[10]</a>. The size of the clusters is either directly selected by the user or it automatically adapts to the local variation of the point set.</p>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga79ee6fb524ec53b9b85eb32e7ae56ca8" title="This is an implementation of the Weighted Locally Optimal Projection (WLOP) simplification algorithm...">wlop_simplify_and_regularize_point_set()</a></code> not only simplifies, but also regularizes downsampled points. This is an implementation of the Weighted Locally Optimal Projection (WLOP) algorithm <a class="el" href="citelist.html#CITEREF_wlop-2009">[4]</a>.</p>
<h2><a class="anchor" id="Point_set_processing_3Example_grid_simplification"></a>
Grid Simplification Example</h2>
<p>The following example reads a point set and simplifies it by clustering. To filter out outliers, at least 3 points must lie in a cell so that a point from this cell is kept. <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2grid_simplification_example_8cpp-example.html">Point_set_processing_3/grid_simplification_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/grid_simplify_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/oni.pwn"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Reads a point set file in points[].</span></div><div class="line">  std::vector&lt;Point&gt; points;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname, std::back_inserter(points)))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// simplification by clustering using erase-remove idiom</span></div><div class="line">  <span class="keywordtype">double</span> cell_size = 0.03;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> min_points_per_cell = 3;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> iterator_to_first_to_remove</div><div class="line">    = <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga7757ef9b3900e42fde26f5a0ac56e20f">CGAL::grid_simplify_point_set</a></div><div class="line">    (points, cell_size,</div><div class="line">     CGAL::parameters::min_points_per_cell(min_points_per_cell)); <span class="comment">// optional</span></div><div class="line"></div><div class="line">  points.erase(iterator_to_first_to_remove, points.end());</div><div class="line"></div><div class="line">  <span class="comment">// Optional: after erase(), shrink_to_fit to trim excess capacity</span></div><div class="line">  points.shrink_to_fit();</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="fig__Point_set_processing_3figgrid_simplification"></a></p><div class="image">
<img src="grid_simplification.jpg" alt="grid_simplification.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figgrid_simplification">Figure 80.14</a> Point set simplification through grid-based clustering. Removed points are depicted in red. Notice how low-density areas (in green) are not simplified.  </div> <br /> 
<h2><a class="anchor" id="Point_set_processing_3Example_hierarchy_simplication"></a>
Hierarchy Simplification Example</h2>
<p>The following example reads a point set and produces a set of clusters.</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2hierarchy_simplification_example_8cpp-example.html">Point_set_processing_3/hierarchy_simplification_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/hierarchy_simplify_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Memory_sizer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/oni.pwn"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Reads a point set file in points[].</span></div><div class="line">  std::vector&lt;Point&gt; points;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname, std::back_inserter(points)))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Read "</span> &lt;&lt; points.size () &lt;&lt; <span class="stringliteral">" point(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  CGAL::Timer task_timer; task_timer.start();</div><div class="line"></div><div class="line">  <span class="comment">// simplification by clustering using erase-remove idiom</span></div><div class="line">  points.erase(<a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga3420351b6d3fad079d13f894f42e9d03">CGAL::hierarchy_simplify_point_set</a>(points,</div><div class="line">                                                  CGAL::parameters::size(100)<span class="comment">// Max cluster size</span></div><div class="line">                                                                   .maximum_variation(0.01)), <span class="comment">// Max surface variation</span></div><div class="line">               points.end());</div><div class="line"></div><div class="line">  std::size_t memory = CGAL::Memory_sizer().virtual_size();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; points.size () &lt;&lt; <span class="stringliteral">" point(s) kept, computed in "</span></div><div class="line">            &lt;&lt; task_timer.time() &lt;&lt; <span class="stringliteral">" seconds, "</span></div><div class="line">            &lt;&lt; (memory&gt;&gt;20) &lt;&lt; <span class="stringliteral">" Mib allocated."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3IO.html#ga5822feba4449f0492363611620b877c0">CGAL::IO::write_points</a>(<span class="stringliteral">"out.xyz"</span>, points, CGAL::parameters::stream_precision(17));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h3><a class="anchor" id="Point_set_processing_3Hierarchy_simplification_parameter_size"></a>
Parameter: size</h3>
<p>The hierarchy simplification algorithm recursively split the point set in two until each cluster's size is less than the parameter <code>size</code>.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figHierarchy_simplification_size"></a></p><div class="image">
<img src="hierarchical_clustering_size.jpg" alt="hierarchical_clustering_size.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figHierarchy_simplification_size">Figure 80.15</a> Input point set and hierarchy simplification with different <code>size</code> parameter: \(10\), \(100\) and \(1000\). In the 3 cases, <code>var_max</code> \(=1/3\). </div> <br /> 
<h3><a class="anchor" id="Point_set_processing_3Hierarchy_simplification_parameter_var_max"></a>
Parameter: var_max</h3>
<p>In addition to the size parameter, a variation parameter allows to increase simplification in monotonous regions. For each cluster, a surface variation measure is computed using the sorted eigenvalues of the covariance matrix: </p><p class="formulaDsp">
\[ \sigma(p) = \frac{\lambda_0}{\lambda_0 + \lambda_1 + \lambda_2}. \]
</p>
<p>This function goes from \(0\) if the cluster is coplanar to \(1/3\) if it is fully isotropic. If a cluster's variation is above <code>var_max</code>, it is split. If <code>var_max</code> is equal to \(1/3\), this parameter has no effect and the clustering is regular on the whole point set.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figHierarchical_clustering_var_max"></a></p><div class="image">
<img src="hierarchical_clustering_var_max.jpg" alt="hierarchical_clustering_var_max.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figHierarchical_clustering_var_max">Figure 80.16</a> Input point set and hierarchy simplification with different <code>var_max</code> parameter: \(0.00001\), \(0.001\) and \(0.1\). In the 3 cases, <code>size</code> \(=1000\). </div> <br /> 
<h2><a class="anchor" id="Point_set_processing_3Example_wlop"></a>
WLOP Simplification Example</h2>
<p>The following example reads a point set, simplifies and regularizes it by WLOP.</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2wlop_simplify_and_regularize_point_set_example_8cpp-example.html">Point_set_processing_3/wlop_simplify_and_regularize_point_set_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/wlop_simplify_and_regularize_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"></div><div class="line"><span class="comment">// Concurrency</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a> Concurrency_tag;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string input_filename = (argc&gt;1)?argv[1]:<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/sphere_20k.xyz"</span>);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* output_filename = (argc&gt;2)?argv[2]:<span class="stringliteral">"data/sphere_20k_WLOPED.xyz"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Reads a .xyz point set file in points[]</span></div><div class="line">  std::vector&lt;Point&gt; points;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(input_filename, std::back_inserter(points)))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; input_filename  &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::vector&lt;Point&gt; output;</div><div class="line"></div><div class="line">  <span class="comment">//parameters</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> retain_percentage = 2;   <span class="comment">// percentage of points to retain.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> neighbor_radius = 0.5;   <span class="comment">// neighbors size.</span></div><div class="line"></div><div class="line">  CGAL::wlop_simplify_and_regularize_point_set&lt;Concurrency_tag&gt;</div><div class="line">    (points, std::back_inserter(output),</div><div class="line">     CGAL::parameters::select_percentage(retain_percentage).</div><div class="line">     neighbor_radius (neighbor_radius));</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga5822feba4449f0492363611620b877c0">CGAL::IO::write_points</a>(output_filename, output, CGAL::parameters::stream_precision(17)))</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="fig__Point_set_processing_3figsimplification_comparison"></a></p><div class="image">
<img src="simplification_comparison.jpg" alt="simplification_comparison.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figsimplification_comparison">Figure 80.17</a> Comparison for three simplification methods: Left: Random simplification result. Middle: Grid simplification result. Right: WLOP simplification result.  </div> <br /> 
<h3><a class="anchor" id="Point_set_processing_3WLOP_Parameter"></a>
Parameter: require_uniform_sampling</h3>
<p>Computing density weights for each point is an optional preprocessing. For example, as shown in the following figure, when require_uniform_sampling is set to false, WLOP preserves the intrinsic non-uniform sampling of the original points; if require_uniform_sampling is set to true, WLOP is resilient to non-uniform sampling and generates sample points with more uniform distribution, at the expense of computational time.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figWLOP_parameter_density"></a></p><div class="image">
<img src="WLOP_parameter_density.jpg" alt="WLOP_parameter_density.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figWLOP_parameter_density">Figure 80.18</a> Comparison between with and without density: Left: input. Middle: <code>require_uniform_sampling = false</code>. Right: <code>require_uniform_sampling=true</code>.  </div> <br /> 
<h3><a class="anchor" id="Point_set_processing_3WLOP_parameter_neighborhood_size"></a>
Parameter: neighbor_radius</h3>
<p>Usually, the neighborhood of sample points should include at least two rings of neighboring sample points. Using a small neighborhood size may not be able to generate regularized result, while using big neighborhood size will make the sample points shrink into the interior of the local surface (under-fitting). The function will use a neighborhood size estimation if this parameter value is set to default or smaller that zero.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figWLOP_parameter_neighborhood_size"></a></p><div class="image">
<img src="WLOP_parameter_neighborhood_size.jpg" alt="WLOP_parameter_neighborhood_size.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figWLOP_parameter_neighborhood_size">Figure 80.19</a> Comparison between different sizes of neighbor radius.  </div> <br /> 
<h3><a class="anchor" id="Point_set_processing_3WLOP_parallel_performance"></a>
Parallel Performance</h3>
<p>A parallel version of WLOP is provided and requires the executable to be linked against the <a href="https://github.com/oneapi-src/oneTBB">Intel TBB library</a>. To control the number of threads used, the user may use the tbb::task_scheduler_init class. See the <a href="https://software.intel.com/content/www/us/en/develop/documentation/onetbb-documentation/top.html">TBB documentation</a> for more details. We provide below a speed-up chart generated using the parallel version of the WLOP algorithm. The machine used is a PC running Windows 7 64-bits with a 4-core <a href="#" onclick="location.href='mai'+'lto:'+'i7-'+'47'+'00H'+'Q@'+'2.4'+'0G'+'Hz'; return false;">i7-47<span style="display: none;">.nosp@m.</span>00HQ<span style="display: none;">.nosp@m.</span>@2.40<span style="display: none;">.nosp@m.</span>GHz</a> CPU with 8GB of RAM.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figWLOP_parallel_performance"></a></p><div class="image">
<img src="parallel_WLOP_performance.jpg" alt="parallel_WLOP_performance.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figWLOP_parallel_performance">Figure 80.20</a> Parallel WLOP speed-up, compared to the sequential version of the algorithm.  </div> <br /> 
<h1><a class="anchor" id="Point_set_processing_3Smoothing"></a>
Smoothing</h1>
<p>Two smoothing functions are devised to smooth an input point set.</p>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga96a3738be3b2b9bd1587af78ae10e67a" title="Smoothes the range of points using jet fitting on the nearest neighbors and reprojection onto the jet...">jet_smooth_point_set()</a></code> smooths the input point set by projecting each point onto a smooth parametric surface patch (so-called jet surface) fitted over its nearest neighbors.</p>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga01192a227578fee0c5676ba6a5e88931" title="This function smooths an input point set by iteratively projecting each point onto the implicit surfa...">bilateral_smooth_point_set()</a></code> smooths the input point set by iteratively projecting each point onto the implicit surface patch fitted over its nearest neighbors. Bilateral projection preserves sharp features according to the normal (gradient) information. Normals are thus required as input. For more details, see section 4 of <a class="el" href="citelist.html#CITEREF_ear-2013">[5]</a>.</p>
<p>For both functions, the user can either specify a fixed number of nearest neighbors or a fixed spherical neighborhood radius.</p>
<h2><a class="anchor" id="Point_set_processing_3Example_jet_smoothing"></a>
Jet Smoothing Example</h2>
<p>The following example generates a set of 9 points close to the <code>xy</code> plane and smooths them using 8 nearest neighbors: <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2jet_smoothing_example_8cpp-example.html">Point_set_processing_3/jet_smoothing_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/jet_smooth_point_set.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"></div><div class="line"><span class="comment">// Concurrency</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a> Concurrency_tag;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">  <span class="comment">// generate point set</span></div><div class="line">  std::vector&lt;Point&gt; points;</div><div class="line">  points.push_back(Point( 0.0, 0.0, 0.001));</div><div class="line">  points.push_back(Point(-0.1,-0.1, 0.002));</div><div class="line">  points.push_back(Point(-0.1,-0.2, 0.001));</div><div class="line">  points.push_back(Point(-0.1, 0.1, 0.002));</div><div class="line">  points.push_back(Point( 0.1,-0.1, 0.000));</div><div class="line">  points.push_back(Point( 0.1, 0.2, 0.001));</div><div class="line">  points.push_back(Point( 0.2, 0.0, 0.002));</div><div class="line">  points.push_back(Point( 0.2, 0.1, 0.000));</div><div class="line">  points.push_back(Point( 0.0,-0.1, 0.001));</div><div class="line"></div><div class="line">  <span class="comment">// Smoothing.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nb_neighbors = 8; <span class="comment">// default is 24 for real-life point sets</span></div><div class="line">  CGAL::jet_smooth_point_set&lt;Concurrency_tag&gt;(points, nb_neighbors);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Point_set_processing_3Example_bilateral_smoothing"></a>
Bilateral Smoothing Example</h2>
<p>The following example reads a set of points with normals and smooths them via bilateral smoothing: <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2bilateral_smooth_point_set_example_8cpp-example.html">Point_set_processing_3/bilateral_smooth_point_set_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/bilateral_smooth_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/tags.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span> <span class="comment">// defines std::pair</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"></div><div class="line"><span class="comment">// Point with normal vector stored in a std::pair.</span></div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Point, Vector&gt; PointVectorPair;</div><div class="line"></div><div class="line"><span class="comment">// Concurrency</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a> Concurrency_tag;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string input_filename = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/fin90_with_PCA_normals.xyz"</span>);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* output_filename = (argc&gt;2) ? argv[2] : <span class="stringliteral">"data/fin90_with_PCA_normals_bilateral_smoothed.xyz"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Reads a point set file in points[] * with normals *.</span></div><div class="line">  std::vector&lt;PointVectorPair&gt; points;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(input_filename, std::back_inserter(points),</div><div class="line">                            CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                                             .normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>())))</div><div class="line">  {</div><div class="line">     std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; input_filename &lt;&lt; std::endl;</div><div class="line">     <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Algorithm parameters</span></div><div class="line">  <span class="keywordtype">int</span> k = 120;                 <span class="comment">// size of neighborhood. The bigger the smoother the result will be.</span></div><div class="line">                               <span class="comment">// This value should bigger than 1.</span></div><div class="line">  <span class="keywordtype">double</span> sharpness_angle = 25; <span class="comment">// control sharpness of the result.</span></div><div class="line">                               <span class="comment">// The bigger the smoother the result will be</span></div><div class="line">  <span class="keywordtype">int</span> iter_number = 3;         <span class="comment">// number of times the projection is applied</span></div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; iter_number; ++i)</div><div class="line">  {</div><div class="line">    <span class="comment">/* double error = */</span></div><div class="line">    CGAL::bilateral_smooth_point_set &lt;Concurrency_tag&gt;(</div><div class="line">      points,</div><div class="line">      k,</div><div class="line">      CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                       .normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                       .sharpness_angle(sharpness_angle));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IOXyz.html#ga1991ab8d312de62ddd907f81890ed039">CGAL::IO::write_XYZ</a>(output_filename, points,</div><div class="line">                          CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                                           .normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                                           .stream_precision(17)))</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p><a class="anchor" id="fig__Point_set_processing_3figsmoothing_comparison"></a></p><div class="image">
<img src="smoothing_comparison.jpg" alt="smoothing_comparison.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figsmoothing_comparison">Figure 80.21</a> Comparison for two smoothing methods: Left: Input, 250K points, normal-color mapping. Middle: Jet smoothing result, 197 seconds. Right: Bilateral smoothing result, 110 seconds.  </div> <br /> 
<h3><a class="anchor" id="Point_set_processing_3Bilateral_smoothing_parallel_performance"></a>
Parallel</h3>
<p>Performance: A parallel version of bilateral smoothing is provided and requires the executable to be linked against the <a href="https://github.com/oneapi-src/oneTBB">Intel TBB library</a>. The number of threads used is controlled through the tbb::task_scheduler_init class. See the <a href="https://software.intel.com/content/www/us/en/develop/documentation/onetbb-documentation/top.html">TBB documentation</a> for more details. We provide below a speed-up chart generated using the parallel version of the bilateral smoothing algorithm. The machine used is a PC running Windows 7 64-bits with a 4-core <a href="#" onclick="location.href='mai'+'lto:'+'i7-'+'47'+'00H'+'Q@'+'2.4'+'0G'+'Hz'; return false;">i7-47<span style="display: none;">.nosp@m.</span>00HQ<span style="display: none;">.nosp@m.</span>@2.40<span style="display: none;">.nosp@m.</span>GHz</a> CPU with 8GB of RAM.</p>
<p><a class="anchor" id="fig__Point_set_processing_3Bilateral_smoothing_parallel_performance"></a></p><div class="image">
<img src="parallel_bilateral_smooth_point_set_performance.jpg" alt="parallel_bilateral_smooth_point_set_performance.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3Bilateral_smoothing_parallel_performance">Figure 80.22</a> Parallel bilateral smoothing speed-up, compared to the sequential version of the algorithm.  </div> <br /> 
<h1><a class="anchor" id="Point_set_processing_3NormalEstimation"></a>
Normal Estimation</h1>
<p>Assuming a point set sampled over an inferred surface <b>S</b>, two functions provide an estimate of the normal to <b>S</b> at each point. The result is an unoriented normal vector for each input point.</p>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga078e25209373cab0e1f3524202489771" title="Estimates normal directions of the range of points using jet fitting on the nearest neighbors...">jet_estimate_normals()</a></code> estimates the normal direction at each point from the input set by fitting a jet surface over its nearest neighbors. The default jet is a quadric surface. This algorithm is well suited to point sets scattered over curved surfaces.</p>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga721aeb7af4b2d31e08e75bc5d53303cf" title="Estimates normal directions of the range of points by linear least squares fitting of a plane over th...">pca_estimate_normals()</a></code> estimates the normal direction at each point from the set by linear least squares fitting of a plane over its nearest neighbors. This algorithm is simpler and faster than <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga078e25209373cab0e1f3524202489771" title="Estimates normal directions of the range of points using jet fitting on the nearest neighbors...">jet_estimate_normals()</a></code>.</p>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gaab0fd78ef3e46c4256e9a1145a9d118e" title="Estimates normal directions of the range of points using the Voronoi Covariance Measure with a radius...">vcm_estimate_normals()</a></code> estimates the normal direction at each point from the set by using the Voronoi Covariance Measure of the point set. This algorithm is more complex and slower than the previous algorithms. It is based on the article <a class="el" href="citelist.html#CITEREF_cgal:mog-vbcfe-11">[9]</a>.</p>
<p>For these three functions, the user can either specify a fixed number of nearest neighbors or a fixed spherical neighborhood radius.</p>
<h1><a class="anchor" id="Point_set_processing_3NormalOrientation"></a>
Normal Orientation</h1>
<h2><a class="anchor" id="Point_set_processing_3Mst_orient_normals"></a>
Minimum Spanning Tree</h2>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga17c3c558c3799b65bd23fba971a82a5c" title="Orients the normals of the range of points using the propagation of a seed orientation through a mini...">mst_orient_normals()</a></code> orients the normals of a set of points with unoriented normals using the method described by Hoppe et al. in <em>Surface reconstruction from unorganized points</em> <a class="el" href="citelist.html#CITEREF_cgal:hddms-srup-92">[3]</a>. More specifically, this method constructs a Riemannian graph over the input points (the graph of the nearest neighbor points) and propagates a seed normal orientation within a minimum spanning tree computed over this graph. The result is an oriented normal vector for each input unoriented normal, except for the normals which cannot be successfully oriented.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figmst_orient_normals"></a></p><div class="image">
<img src="mst_orient_normals.jpg" alt="mst_orient_normals.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figmst_orient_normals">Figure 80.23</a> Normal orientation of a sampled cube surface. Left: unoriented normals. Right: orientation of right face normals is propagated to bottom face.  </div> <br /> 
<h3><a class="anchor" id="Point_set_processing_3Example_normals"></a>
Example</h3>
<p>The following example reads a point set from a file, estimates the normals through PCA (either over the 18 nearest neighbors or using a spherical neighborhood radius of twice the average spacing) and orients the normals: <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2normals_example_8cpp-example.html">Point_set_processing_3/normals_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/compute_average_spacing.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/pca_estimate_normals.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/mst_orient_normals.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span> <span class="comment">// defines std::pair</span></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"></div><div class="line"><span class="comment">// Point with normal vector stored in a std::pair.</span></div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Point, Vector&gt; PointVectorPair;</div><div class="line"></div><div class="line"><span class="comment">// Concurrency</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a> Concurrency_tag;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/sphere_1k.xyz"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Reads a point set file in points[].</span></div><div class="line">  std::list&lt;PointVectorPair&gt; points;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname,</div><div class="line">                            std::back_inserter(points),</div><div class="line">                            CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname&lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Estimates normals direction.</span></div><div class="line">  <span class="comment">// Note: pca_estimate_normals() requiresa range of points</span></div><div class="line">  <span class="comment">// as well as property maps to access each point's position and normal.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_neighbors = 18; <span class="comment">// K-nearest neighbors = 3 rings</span></div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 2 &amp;&amp; std::strcmp(argv[2], <span class="stringliteral">"-r"</span>) == 0) <span class="comment">// Use a fixed neighborhood radius</span></div><div class="line">  {</div><div class="line">    <span class="comment">// First compute a spacing using the K parameter</span></div><div class="line">    <span class="keywordtype">double</span> spacing</div><div class="line">        = CGAL::compute_average_spacing&lt;Concurrency_tag&gt;</div><div class="line">          (points, nb_neighbors,</div><div class="line">           CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>()));</div><div class="line"></div><div class="line">    <span class="comment">// Then, estimate normals with a fixed radius</span></div><div class="line">    CGAL::pca_estimate_normals&lt;Concurrency_tag&gt;</div><div class="line">        (points,</div><div class="line">         0, <span class="comment">// when using a neighborhood radius, K=0 means no limit on the number of neighbors returns</span></div><div class="line">         CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                          .normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                          .neighbor_radius(2. * spacing)); <span class="comment">// use 2*spacing as neighborhood radius</span></div><div class="line">  }</div><div class="line">  <span class="keywordflow">else</span> <span class="comment">// Use a fixed number of neighbors</span></div><div class="line">  {</div><div class="line">    CGAL::pca_estimate_normals&lt;Concurrency_tag&gt;</div><div class="line">        (points, nb_neighbors,</div><div class="line">         CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                          .normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>()));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Orients normals.</span></div><div class="line">  <span class="comment">// Note: mst_orient_normals() requires a range of points</span></div><div class="line">  <span class="comment">// as well as property maps to access each point's position and normal.</span></div><div class="line">  std::list&lt;PointVectorPair&gt;::iterator unoriented_points_begin =</div><div class="line">      <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga17c3c558c3799b65bd23fba971a82a5c">CGAL::mst_orient_normals</a>(points, nb_neighbors,</div><div class="line">                               CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                                                .normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>()));</div><div class="line"></div><div class="line">  <span class="comment">// Optional: delete points with an unoriented normal</span></div><div class="line">  <span class="comment">// if you plan to call a reconstruction algorithm that expects oriented normals.</span></div><div class="line">  points.erase(unoriented_points_begin, points.end());</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Point_set_processing_3Scanline_orient_normals"></a>
Scanline</h2>
<p>The minimum spanning tree results can give suboptimal results on point clouds with many sharp features and occlusions, which typically happens on airborne acquired urban datasets.</p>
<p><code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gafc3627234666e1fb458e9387e9d5f3c6" title="orients the normals of the range of points by estimating a line of sight and checking its consistency...">scanline_orient_normals()</a></code> is an alternative method specialized for point sets which are ordered in scanline aligned on the XY-plane. It can take advantage of LAS properties provided by some LIDAR scanner and is the best choice of normal orientation when dealing with 2.5D urban scenes.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figmst_scanline_orient_normals"></a></p><div class="image">
<img src="scanline_orient_normals.png" alt="scanline_orient_normals.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figmst_scanline_orient_normals">Figure 80.24</a> Normal orientation of a LIDAR scanline. The point cloud is a typical airborne LIDAR input, sampling a building without normal information and with many occlusions (especially on vertical walls).  </div> <br /> 
<h3><a class="anchor" id="Point_set_processing_3Example_scanline_normals"></a>
Example</h3>
<p>The following example reads a point set from a LAS file, estimates the normals through Jet Fitting and outputs in PLY format the orientation results of all the variants of <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gafc3627234666e1fb458e9387e9d5f3c6" title="orients the normals of the range of points by estimating a line of sight and checking its consistency...">scanline_orient_normals()</a></code>:</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2orient_scanlines_example_8cpp-example.html">Point_set_processing_3/orient_scanlines_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_las_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_ply_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/jet_estimate_normals.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/scanline_orient_normals.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> Kernel = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> Point_3 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ae82b7f4be77dd5b8819ebe419e4ae753">Kernel::Point_3</a>;</div><div class="line"><span class="keyword">using</span> Vector_3 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a39fb0222695ae5e7e32f4e570ea28225">Kernel::Vector_3</a>;</div><div class="line"><span class="keyword">using</span> Point_with_info = std::tuple&lt;Point_3, Vector_3, float, unsigned char&gt;;</div><div class="line"><span class="keyword">using</span> Point_map = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;0, Point_with_info&gt;</a>;</div><div class="line"><span class="keyword">using</span> Normal_map = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;1, Point_with_info&gt;</a>;</div><div class="line"><span class="keyword">using</span> Scan_angle_map = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;2, Point_with_info&gt;</a>;</div><div class="line"><span class="keyword">using</span> Scanline_id_map = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;3, Point_with_info&gt;</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> dump (<span class="keyword">const</span> <span class="keywordtype">char</span>* filename, <span class="keyword">const</span> std::vector&lt;Point_with_info&gt;&amp; points)</div><div class="line">{</div><div class="line">  std::ofstream ofile (filename, std::ios::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a>(ofile);</div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3IOPly.html#ga615f4420ce82b5ceb1b584b506d714ad">CGAL::IO::write_PLY</a></div><div class="line">    (ofile, points,</div><div class="line">     CGAL::parameters::point_map (Point_map()).</div><div class="line">     normal_map (Normal_map()));</div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::string fname (argc &gt; 1 ? argv[1] : <span class="stringliteral">"data/urban.las"</span>);</div><div class="line"></div><div class="line">  std::vector&lt;Point_with_info&gt; points;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Reading input file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">  std::ifstream ifile (fname, std::ios::binary);</div><div class="line">  <span class="keywordflow">if</span> (!ifile ||</div><div class="line">      !<a class="code" href="group__PkgPointSetProcessing3IOLas.html#ga5187fc18430a5e3c811f75da57a057ad">CGAL::IO::read_LAS_with_properties</a></div><div class="line">      (ifile, std::back_inserter (points),</div><div class="line">       <a class="code" href="group__PkgPointSetProcessing3IOLas.html#gac807a7bbde008f9707a1cf697e3eb64c">CGAL::IO::make_las_point_reader</a> (Point_map()),</div><div class="line">       std::make_pair (Scan_angle_map(),</div><div class="line">                       CGAL::IO::LAS_property::Scan_angle()),</div><div class="line">       std::make_pair (Scanline_id_map(),</div><div class="line">                       CGAL::IO::LAS_property::Scan_direction_flag())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Can't read "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Estimating normals"</span> &lt;&lt; std::endl;</div><div class="line">  CGAL::jet_estimate_normals&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (points, 12,</div><div class="line">     CGAL::parameters::point_map (Point_map()).</div><div class="line">     normal_map (Normal_map()));</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Orienting normals using scan angle and direction flag"</span> &lt;&lt; std::endl;</div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#gafc3627234666e1fb458e9387e9d5f3c6">CGAL::scanline_orient_normals</a></div><div class="line">    (points,</div><div class="line">     CGAL::parameters::point_map (Point_map()).</div><div class="line">     normal_map (Normal_map()).</div><div class="line">     scan_angle_map (Scan_angle_map()).</div><div class="line">     scanline_id_map (Scanline_id_map()));</div><div class="line">  dump(<span class="stringliteral">"out_angle_and_flag.ply"</span>, points);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Orienting normals using scan direction flag only"</span> &lt;&lt; std::endl;</div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#gafc3627234666e1fb458e9387e9d5f3c6">CGAL::scanline_orient_normals</a></div><div class="line">    (points,</div><div class="line">     CGAL::parameters::point_map (Point_map()).</div><div class="line">     normal_map (Normal_map()).</div><div class="line">     scanline_id_map (Scanline_id_map()));</div><div class="line">  dump(<span class="stringliteral">"out_flag.ply"</span>, points);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Orienting normals using scan angle only"</span> &lt;&lt; std::endl;</div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#gafc3627234666e1fb458e9387e9d5f3c6">CGAL::scanline_orient_normals</a></div><div class="line">    (points,</div><div class="line">     CGAL::parameters::point_map (Point_map()).</div><div class="line">     normal_map (Normal_map()).</div><div class="line">     scan_angle_map (Scan_angle_map()));</div><div class="line">  dump(<span class="stringliteral">"out_angle.ply"</span>, points);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Orienting normals using no additional info"</span> &lt;&lt; std::endl;</div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#gafc3627234666e1fb458e9387e9d5f3c6">CGAL::scanline_orient_normals</a></div><div class="line">    (points,</div><div class="line">     CGAL::parameters::point_map (Point_map()).</div><div class="line">     normal_map (Normal_map()));</div><div class="line">  dump(<span class="stringliteral">"out_nothing.ply"</span>, points);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Point_set_processing_3Upsampling"></a>
Upsampling</h1>
<p>The function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga8712cbc64f1cfd4dd2f61049a24b90f4" title="This method progressively upsamples the point set while approaching the edge singularities (detected ...">edge_aware_upsample_point_set()</a></code> generates a denser point set from an input point set. This has applications in point-based rendering, hole filling, and sparse surface reconstruction. The algorithm can progressively upsample the point set while approaching the edge singularities. See <a class="el" href="citelist.html#CITEREF_ear-2013">[5]</a> for more details.</p>
<h2><a class="anchor" id="Point_set_processing_3Example_upsampling"></a>
Example</h2>
<p>The following example reads a point set from a file, upsamples it to get a denser result.</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2edge_aware_upsample_point_set_example_8cpp-example.html">Point_set_processing_3/edge_aware_upsample_point_set_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/edge_aware_upsample_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"></div><div class="line"><span class="comment">// Point with normal vector stored in a std::pair.</span></div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Point, Vector&gt; PointVectorPair;</div><div class="line"></div><div class="line"><span class="comment">// Concurrency</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a> Concurrency_tag;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string input_filename = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/before_upsample.xyz"</span>);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* output_filename = (argc&gt;2) ? argv[2] : <span class="stringliteral">"data/before_upsample_UPSAMPLED.xyz"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Reads a .xyz point set file in points[], *with normals*.</span></div><div class="line">  std::vector&lt;PointVectorPair&gt; points;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(input_filename,</div><div class="line">                            std::back_inserter(points),</div><div class="line">                            CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                                             .normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; input_filename &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">//Algorithm parameters</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> sharpness_angle = 25;   <span class="comment">// control sharpness of the result.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> edge_sensitivity = 0;    <span class="comment">// higher values will sample more points near the edges</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> neighbor_radius = 0.25;  <span class="comment">// initial size of neighborhood.</span></div><div class="line">  <span class="keyword">const</span> std::size_t number_of_output_points = points.size() * 4;</div><div class="line"></div><div class="line">   <span class="comment">//Run algorithm</span></div><div class="line">  CGAL::edge_aware_upsample_point_set&lt;Concurrency_tag&gt;(</div><div class="line">    points,</div><div class="line">    std::back_inserter(points),</div><div class="line">    CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>()).</div><div class="line">    normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>()).</div><div class="line">    sharpness_angle(sharpness_angle).</div><div class="line">    edge_sensitivity(edge_sensitivity).</div><div class="line">    neighbor_radius(neighbor_radius).</div><div class="line">    number_of_output_points(number_of_output_points));</div><div class="line"></div><div class="line">  <span class="comment">// Saves point set.</span></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga5822feba4449f0492363611620b877c0">CGAL::IO::write_points</a>(output_filename, points,</div><div class="line">                             CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                                              .normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                                              .stream_precision(17)))</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="Point_set_processing_3Upsample_Parameter1"></a>
Parameter: edge_sensitivity</h3>
<p>This parameter controls where the new points are inserted. Larger values of edge-sensitivity give higher priority to inserting points along the sharp features. For example, as shown in the following figure, high value is preferable when one wants to insert more points on sharp features, where the local gradient is high, e.g., darts, cusps, creases and corners. In contrast, points are evenly inserted when edge_sensitivity is set to 0. The range of possible value is [0, 1].</p>
<p><a class="anchor" id="fig__Point_set_processing_3figUpsample_edge_sensitivity"></a></p><div class="image">
<img src="upsample_edge_sensitivity.jpg" alt="upsample_edge_sensitivity.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figUpsample_edge_sensitivity">Figure 80.25</a> Upsampling for different edge-sensitivity parameter values. The input containing 850 points is upsampled to 1,500 points in all cases depicted.  </div> <br /> 
<h3><a class="anchor" id="Point_set_processing_3Upsample_Parameter2"></a>
Parameter: sharpness_angle</h3>
<p>This parameter controls the preservation of sharp features.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figUpsample_sharpness_angle"></a></p><div class="image">
<img src="upsample_sharpness_angle.jpg" alt="upsample_sharpness_angle.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figUpsample_sharpness_angle">Figure 80.26</a> Upsampling for different sharpness_angle parameter values. The input containing 850 points is upsampled to 425K points in all cases depicted.  </div> <br /> 
<h3><a class="anchor" id="Point_set_processing_3upsample_neighborhood_size"></a>
Parameter: neighbor_radius</h3>
<p>Usually, the neighborhood of sample points should include at least one ring of neighboring sample points. Using small neighborhood size may not be able to insert new points. Using big neighborhood size can fill small holes, but points inserted on the edges could be irregular. The function will use a neighborhood size estimation if this parameter value is set to default or smaller than zero.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figupsample_neighborhood_size"></a></p><div class="image">
<img src="upsample_neighborhood_size.jpg" alt="upsample_neighborhood_size.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figupsample_neighborhood_size">Figure 80.27</a> Comparison between different sizes of neighbor radius.  </div> <br /> 
<h1><a class="anchor" id="Point_set_processing_3FeaturesEstimation"></a>
Feature Edges Estimation</h1>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gac57ce53e3249a66e4c19e85f439ff01e" title="determines if a point is on a sharp feature edge from a point set for which the Voronoi covariance Me...">vcm_is_on_feature_edge()</a></code> indicates if a points belong to a feature edges of the point set using its Voronoi Covariance Measure. It is based on the article <a class="el" href="citelist.html#CITEREF_cgal:mog-vbcfe-11">[9]</a>.</p>
<p>It first computes the VCM of the points set using <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga258a9b3a40d10533f8f01d64b4e91eca" title="computes the Voronoi Covariance Measure (VCM) of a point cloud, a construction that can be used for n...">compute_vcm()</a></code>. Then, it estimates which points belong to a sharp edge by testing if a ratio of eigenvalues is greater than a given threshold.</p>
<h2><a class="anchor" id="Point_set_processing_3Example_sharp_edges"></a>
Example</h2>
<p>The following example reads a point set from a file, estimates the points that are on sharp edges: <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2edges_example_8cpp-example.html">Point_set_processing_3/edges_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/vcm_estimate_edges.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span> <span class="comment">// defines std::pair</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"></div><div class="line"><span class="comment">// Point with normal vector stored in a std::pair.</span></div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Point, Vector&gt; PointVectorPair;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;PointVectorPair&gt; PointList;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::array&lt;double,6&gt; Covariance;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> , <span class="keywordtype">char</span>**)</div><div class="line">{</div><div class="line">  <span class="comment">// Reads a polygon mesh file in points[].</span></div><div class="line">  std::list&lt;PointVectorPair&gt; points;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/fandisk_large.off"</span>),</div><div class="line">                            std::back_inserter(points),</div><div class="line">                            CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file data/fandisk_large.off"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Estimates covariance matrices per points.</span></div><div class="line">  <span class="keywordtype">double</span> R = 0.2,</div><div class="line">         r = 0.1;</div><div class="line">  std::vector&lt;Covariance&gt; cov;</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a> point_map;</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga258a9b3a40d10533f8f01d64b4e91eca">CGAL::compute_vcm</a>(points, cov, R, r,</div><div class="line">                    CGAL::parameters::point_map (point_map).geom_traits (Kernel()));</div><div class="line"></div><div class="line">  <span class="comment">// Find the points on the edges.</span></div><div class="line">  <span class="comment">// Note that this step is not expensive and can be done several time to get better results</span></div><div class="line">  <span class="keywordtype">double</span> threshold = 0.16;</div><div class="line">  std::ofstream output(<span class="stringliteral">"points_on_edges.xyz"</span>);</div><div class="line">  <span class="keywordtype">int</span> i = 0;</div><div class="line">  <span class="keywordflow">for</span>(<span class="keyword">const</span> PointVectorPair&amp; p : points)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__PkgPointSetProcessing3Algorithms.html#gac57ce53e3249a66e4c19e85f439ff01e">CGAL::vcm_is_on_feature_edge</a>(cov[i], threshold))</div><div class="line">      output &lt;&lt; p.first &lt;&lt; <span class="stringliteral">"\n"</span>;</div><div class="line">    ++i;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h1><a class="anchor" id="Point_set_processing_3Structuring"></a>
Structuring</h1>
<p>The function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gaebbc04909dfd575a94f932c8d3bacdce" title="This is an implementation of the Point Set Structuring algorithm. ">structure_point_set()</a></code> generates a structured version of the input point set assigned to a set of planes. Such an input can be produced by a shape detection algorithm (see <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/group__PkgShapeDetectionRef.html">Shape Detection Reference</a>). Point set structuring is based on the article <a class="el" href="citelist.html#CITEREF_cgal:la-srpss-13">[6]</a>.</p>
<ul>
<li><b>Planes</b>: inliers of each detected plane are replaced by sets of noise-free points sampled at the vertices of a regular grid: this is achieved by filling an occupancy grid aligned on the principal components of the inlier sets with a spacing lower than \(\sqrt{2}\) times the user-defined tolerance.</li>
<li><b>Creases</b>: adjacencies between 2 planes are detected and regularly resampled on an occupancy array along the edge with a spacing equal to twice the user-defined tolerance.</li>
<li><b>Corners</b>: 3-cycles are detected from the primitive adjacency graph and sampled using the exact intersection point of the 3 planes (provided it exists and remains in the given tolerance). These corners are also locally clustered to former corners of degree higher than 3.</li>
</ul>
<p>This algorithm is well suited to point sets sampled on surfaces with planar sections and sharp edges.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figstructuring"></a></p><div class="image">
<img src="structuring.png" alt="structuring.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figstructuring">Figure 80.28</a> Point set structuring. Left: input raw point set. Right: structured point set.  </div> <br /> 
<p>Structure information of points can be used to perform feature preserving reconstruction (see <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Advancing_front_surface_reconstruction.tag:../Advancing_front_surface_reconstruction/" href="../Advancing_front_surface_reconstruction/index.html#AFSR_Example_sharp_features">Advancing Front Surface Reconstruction</a> for example). More specifically, the class storing a point set with structure provides the user with a method <code><a class="el" href="classCGAL_1_1Point__set__with__structure.html#ae8890334744d8d7efd17917c62fc1513" title="Computes the coherence of a facet between the 3 points indexed by f with respect to the underlying st...">Point_set_with_structure::facet_coherence()</a></code> that estimates if a triplet of points form a coherent facet.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figstructuring_coherence"></a></p><div class="image">
<img src="structuring_coherence.png" alt="structuring_coherence.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figstructuring_coherence">Figure 80.29</a> (a) Input point set (and structured output); (b) output with many incoherent facets; (c) output with all facets coherent. i, j and k each corresponds to a primitive index.  </div> <br /> 
<h2><a class="anchor" id="Point_set_processing_3Example_9"></a>
Example</h2>
<p>The following example applies shape detection followed by structuring to a point set: <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2structuring_example_8cpp-example.html">Point_set_processing_3/structuring_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Shape_detection/Efficient_RANSAC.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/structure_point_set.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Type declarations</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>  Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                                      Point;</div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Kernel::Point_3, Kernel::Vector_3&gt;         Point_with_normal;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point_with_normal&gt;                       Pwn_vector;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Point_with_normal&gt;</a>  Point_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;Point_with_normal&gt;</a> Normal_map;</div><div class="line"></div><div class="line"><span class="comment">// Efficient RANSAC types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/structCGAL_1_1Shape__detection_1_1Efficient__RANSAC__traits.html">CGAL::Shape_detection::Efficient_RANSAC_traits</a></div><div class="line">  &lt;Kernel, Pwn_vector, Point_map, Normal_map&gt;              Traits;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Efficient__RANSAC.html">CGAL::Shape_detection::Efficient_RANSAC&lt;Traits&gt;</a>    Efficient_ransac;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Plane.html">CGAL::Shape_detection::Plane&lt;Traits&gt;</a>               Plane;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string filename = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/cube.pwn"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Points with normals.</span></div><div class="line">  Pwn_vector points;</div><div class="line"></div><div class="line">  <span class="comment">// Loading point set from a file.</span></div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(filename, std::back_inserter(points),</div><div class="line">                            CGAL::parameters::point_map(Point_map())</div><div class="line">                                             .normal_map(Normal_map())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file cube.pwn"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; points.size() &lt;&lt; <span class="stringliteral">" point(s) read."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Shape detection</span></div><div class="line">  Efficient_ransac ransac;</div><div class="line">  ransac.set_input(points);</div><div class="line">  ransac.add_shape_factory&lt;Plane&gt;();</div><div class="line">  ransac.detect();</div><div class="line"></div><div class="line">  Efficient_ransac::Plane_range planes = ransac.planes();</div><div class="line"></div><div class="line">  Pwn_vector structured_pts;</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#gaebbc04909dfd575a94f932c8d3bacdce">CGAL::structure_point_set</a>(points,</div><div class="line">                            planes,</div><div class="line">                            std::back_inserter(structured_pts),</div><div class="line">                            0.015, <span class="comment">// epsilon for structuring points</span></div><div class="line">                            CGAL::parameters::point_map(Point_map())</div><div class="line">                                             .normal_map(Normal_map())</div><div class="line">                                             .plane_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Plane__map.html">CGAL::Shape_detection::Plane_map&lt;Traits&gt;</a>())</div><div class="line">                                             .plane_index_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Point__to__shape__index__map.html">CGAL::Shape_detection::Point_to_shape_index_map&lt;Traits&gt;</a>(points, planes)));</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; structured_pts.size ()</div><div class="line">            &lt;&lt; <span class="stringliteral">" structured point(s) generated."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3IO.html#ga5822feba4449f0492363611620b877c0">CGAL::IO::write_points</a>(<span class="stringliteral">"out.pwn"</span>, structured_pts,</div><div class="line">                         CGAL::parameters::point_map(Point_map())</div><div class="line">                                          .normal_map(Normal_map())</div><div class="line">                                          .stream_precision(17));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Point_set_processing_3Callbacks"></a>
Callbacks</h1>
<p>Several functions of this package provide a callback mechanism that enables the user to track the progress of the algorithms and to interrupt them if needed. A callback, in this package, is an instance of <code>std::function&lt;bool(double)&gt;</code> that takes the advancement as a parameter (between 0. when the algorithm begins to 1. when the algorithm is completed) and that returns <code>true</code> if the algorithm should carry on, <code>false</code> otherwise. It is passed as a named parameter with an empty function as default.</p>
<p>Algorithms that support this mechanism are detailed in the <a class="el" href="group__PkgPointSetProcessing3Ref.html">Reference Manual</a>, along with the effect that an early interruption has on the output.</p>
<h2><a class="anchor" id="Point_set_processing_3Example_callbacks"></a>
Example</h2>
<p>The following example defines a callback that displays the name of the current algorithm along with the progress (as a percentage) updated every \(1/10th\) of a second. While the algorithm is running, the console output will typically look like this:</p>
<div class="fragment"><div class="line">Computing average spacing: 100%</div><div class="line">Grid simplification: 100%</div><div class="line">Jet smoothing: 54%</div></div><!-- fragment --><p>Thanks to the carriage return character <code>\r</code>, the lines are overwritten and the user sees the percentage increasing on each line.</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2callback_example_8cpp-example.html">Point_set_processing_3/callback_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/point_generators_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/compute_average_spacing.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/grid_simplify_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/jet_smooth_point_set.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/lexical_cast.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> CGAL::Random_points_on_sphere_3&lt;Point&gt; Generator;</div><div class="line"></div><div class="line"><span class="comment">// Concurrency</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a> Concurrency_tag;</div><div class="line"></div><div class="line"><span class="comment">// instance of std::function&lt;bool(double)&gt;</span></div><div class="line"><span class="keyword">struct </span>Progress_to_std_cerr_callback</div><div class="line">{</div><div class="line">  <span class="keyword">mutable</span> std::size_t nb;</div><div class="line">  CGAL::Real_timer timer;</div><div class="line">  <span class="keywordtype">double</span> t_start;</div><div class="line">  <span class="keyword">mutable</span> <span class="keywordtype">double</span> t_latest;</div><div class="line">  <span class="keyword">const</span> std::string name;</div><div class="line"></div><div class="line">  Progress_to_std_cerr_callback (<span class="keyword">const</span> <span class="keywordtype">char</span>* name)</div><div class="line">    : name (name)</div><div class="line">  {</div><div class="line">    timer.start();</div><div class="line">    t_start = timer.time();</div><div class="line">    t_latest = t_start;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> operator()(<span class="keywordtype">double</span> advancement)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="comment">// Avoid calling time() at every single iteration, which could</span></div><div class="line">    <span class="comment">// impact performances very badly</span></div><div class="line">    ++ nb;</div><div class="line">    <span class="keywordflow">if</span> (advancement != 1 &amp;&amp; nb % 100 != 0)</div><div class="line">      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> t = timer.time();</div><div class="line">    <span class="keywordflow">if</span> (advancement == 1 || (t - t_latest) &gt; 0.1) <span class="comment">// Update every 1/10th of second</span></div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">"\r"</span> <span class="comment">// Return at the beginning of same line and overwrite</span></div><div class="line">                &lt;&lt; name &lt;&lt; <span class="stringliteral">": "</span> &lt;&lt; int(advancement * 100) &lt;&lt; <span class="stringliteral">"%"</span>;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (advancement == 1)</div><div class="line">        std::cerr &lt;&lt; std::endl;</div><div class="line">      t_latest = t;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">  <span class="keywordtype">int</span> N = (argc &gt; 1) ? boost::lexical_cast&lt;int&gt;(argv[1]) : 1000;</div><div class="line"></div><div class="line">  <span class="comment">// Generate N points on a sphere of radius 100.</span></div><div class="line">  std::vector&lt;Point&gt; points;</div><div class="line">  points.reserve(N);</div><div class="line">  Generator generator(100.);</div><div class="line">  std::copy_n(generator, N, std::back_inserter(points));</div><div class="line"></div><div class="line">  <span class="comment">// Compute average spacing</span></div><div class="line">  FT average_spacing = CGAL::compute_average_spacing&lt;Concurrency_tag&gt;</div><div class="line">    (points, 6,</div><div class="line">     CGAL::parameters::callback(Progress_to_std_cerr_callback(<span class="stringliteral">"Computing average spacing"</span>)));</div><div class="line"></div><div class="line">  <span class="comment">// Simplify on a grid with a size of twice the average spacing</span></div><div class="line">  points.erase(<a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga7757ef9b3900e42fde26f5a0ac56e20f">CGAL::grid_simplify_point_set</a>(points, 2. * average_spacing,</div><div class="line">                                             CGAL::parameters::callback(Progress_to_std_cerr_callback(<span class="stringliteral">"Grid simplification"</span>))),</div><div class="line">               points.end());</div><div class="line"></div><div class="line">  <span class="comment">// Smooth simplified point set</span></div><div class="line">  CGAL::jet_smooth_point_set&lt;Concurrency_tag&gt;(points, 6,</div><div class="line">                                              CGAL::parameters::callback(Progress_to_std_cerr_callback(<span class="stringliteral">"Jet smoothing"</span>)));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h1><a class="anchor" id="Point_set_processing_3ImplementationHistory"></a>
Implementation History</h1>
<p>Pierre Alliez and Laurent Saboret contributed the initial component. Nader Salman contributed the grid simplification. Started from GSoC'2013, three new algorithms were implemented by Shihao Wu and Clément Jamin: WLOP, bilateral smoothing and upsampling. Started from GSoC'2014, Jocelyn Meyron with the help of Quentin Mérigot introduced the computation of the Voronoi covariance measure of a point set, as well as the normal and feature edge estimation functions based on it. Florent Lafarge with the help of Simon Giraudot contributed the point set structuring algorithm. Started from GSoC'2019, Necip Fazil Yildiran with the help of Nicolas Mellado and Simon Giraudot introduced the wrappers for <a class="el" href="namespaceCGAL_1_1OpenGR.html">OpenGR</a> and PointMatcher libraries that perform registration on two point sets. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jan 30 2023 13:47:22 for CGAL 5.6 - Point Set Processing by
    <a href="https://www.doxygen.nl/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>
</html><html xmlns="http://www.w3.org/1999/xhtml"><body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" alt="" />
      <input type="text" id="MSearchField" value="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)" />
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt="" /></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.6 - Point Set Processing
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Point_Set_Processing"></a><a class="anchor" id="chappoint_set_processing_3"></a>  </p><div id="autotoc" class="toc"></div> 
<dl class="section author"><dt>Authors</dt><dd>Pierre Alliez, Simon Giraudot, Clément Jamin, Florent Lafarge, Quentin Mérigot, Jocelyn Meyron, Laurent Saboret, Nader Salman, Shihao Wu, Necip Fazil Yildiran</dd></dl>
<h1><a class="anchor" id="Point_set_processing_3Introduction"></a>
Introduction</h1>
<p>This CGAL component implements methods to analyze and process 3D point sets. The input is an unorganized 3D point set, possibly with normal attributes (unoriented or oriented). The input point set can be analyzed to measure geometric properties such as average spacing between the points and their <code>k</code> nearest neighbors. It can be processed with functions devoted to the simplification, regularization, upsampling, outlier removal, smoothing, normal estimation and normal orientation. The processing of point sets is often needed in applications dealing with measurement data, such as surface reconstruction from laser scanned data (see <a class="el" href="index.html#fig__Point_set_processing_3figintroduction">Figure 80.1</a>).</p>
<p><a class="anchor" id="fig__Point_set_processing_3figintroduction"></a></p><div class="image">
<img src="introduction.jpg" alt="introduction.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figintroduction">Figure 80.1</a> Point set processing. Left: 275K points sampled on the statue of an elephant with a Minolta laser scanner. Right: point set after outlier removal, denoising and simplification to 17K points.  </div> <br /> 
<p>In the context of surface reconstruction we can position the elements of this component along the common surface reconstruction pipeline (<a class="el" href="index.html#fig__Point_set_processing_3figpipeline">Figure 80.2</a>) which involves the following steps:</p><ol type="1">
<li>Scanning and scan registration to produce a set of points or points with normals;</li>
<li>Outlier removal;</li>
<li>Simplification to reduce the number of input points;</li>
<li>Smoothing to reduce noise in the input data;</li>
<li>Normal estimation and orientation when the normals are not already provided by the acquisition device; and</li>
<li>Surface reconstruction. Chapter <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Poisson_surface_reconstruction_3.tag:../Poisson_surface_reconstruction_3/" href="../Poisson_surface_reconstruction_3/index.html#Chapter_Poisson_Surface_Reconstruction">Poisson Surface Reconstruction</a> deals with surface reconstruction from point sets with normal attributes.</li>
</ol>
<p><a class="anchor" id="fig__Point_set_processing_3figpipeline"></a></p><div class="image">
<img src="pipeline.jpg" alt="pipeline.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figpipeline">Figure 80.2</a> Point set processing pipeline for surface reconstruction. The algorithms listed in gray are available from other <a class="el" href="namespaceCGAL.html">CGAL</a> components (bounding volumes and principal component analysis).  </div> <br /> 
<h1><a class="anchor" id="Point_set_processing_3API"></a>
API</h1>
<p>The algorithms of this component take as input parameters ranges of 3D points, or of 3D points with normals. They can be adapted to the user's data structures and make extensive use of <a class="el" href="index.html#Point_set_processing_3NamedParameters">named parameters</a> and of <a class="el" href="index.html#Point_set_processing_3PropertyMaps">property maps</a>:</p>
<div class="fragment"><div class="line">std::vector&lt;PointVectorPair&gt; points;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a> Point_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a> Vector_map;</div><div class="line"></div><div class="line"><a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga078e25209373cab0e1f3524202489771">CGAL::jet_estimate_normals</a></div><div class="line">&lt;<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__tag.html">CGAL::Parallel_tag</a>&gt;           <span class="comment">// concurrency tag</span></div><div class="line">  (points,                     <span class="comment">// input range of points</span></div><div class="line">   12,                         <span class="comment">// parameter: number of neighbors</span></div><div class="line">   <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL_1_1parameters.html">CGAL::parameters</a>::          <span class="comment">// named parameters:</span></div><div class="line">   point_map (Point_map()).    <span class="comment">//  * point map</span></div><div class="line">   normal_map (Vector_map())); <span class="comment">//  * normal map</span></div></div><!-- fragment --><p>This API was introduced in CGAL 4.12. Please refer to the <a class="el" href="index.html#Point_set_processing_3Outdated">dedicated section</a> on how to upgrade from the outdated API.</p>
<h2><a class="anchor" id="Point_set_processing_3NamedParameters"></a>
Named Parameters</h2>
<p>Named parameters are used to deal with optional parameters. The page <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/index.html#BGLNamedParameters">Named Parameters</a> explains the rationale and API in general. The page <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/group__bgl__namedparameters.html">Named Parameters</a> describes their usage.</p>
<h2><a class="anchor" id="Point_set_processing_3PropertyMaps"></a>
Property Maps</h2>
<p>The property maps are used to access the point or normal information from the input data, so as to let the user decide upon the implementation of a point with normal. The latter can be represented as, e.g., a class derived from the CGAL 3D point, or as a <code>std::pair&lt;<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__3.html">Point_3</a>&lt;K&gt;, <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Vector__3.html">Vector_3</a>&lt;K&gt;&gt;</code>, or as a <code>boost::tuple&lt;..,<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__3.html">Point_3</a>&lt;K&gt;, ..., <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Vector__3.html">Vector_3</a>&lt;K&gt; &gt;</code>.</p>
<p>The following classes described in Chapter <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/packages.html#PkgPropertyMap">CGAL and Boost Property Maps</a> provide property maps for the implementations of points with normals listed above:</p>
<ul>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Identity__property__map.html">Identity_property_map</a>&lt;T&gt;</code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">First_of_pair_property_map</a>&lt;Pair&gt;</code> and <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">Second_of_pair_property_map</a>&lt;Pair&gt;</code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">Nth_of_tuple_property_map</a>&lt;N, Tuple&gt;</code></li>
</ul>
<p><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Identity__property__map.html">Identity_property_map</a>&lt;<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__3.html">Point_3</a>&gt;</code> is the default value of the position property map expected by all functions in this component.</p>
<p>See below examples using pair and tuple property maps.</p>
<p>Users of this package may use other types to represent positions and normals if they implement the corresponding property maps.</p>
<p>Points and normals can even be stored in separate containers and accessed by their index, as any built-in vector is also a property map.</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2grid_simplify_indices_8cpp-example.html">Point_set_processing_3/grid_simplify_indices.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/grid_simplify_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/namespaceKernel.html">Kernel</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/fin90_with_PCA_normals.xyz"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Reads a .xyz point set file in points[].</span></div><div class="line">  std::vector&lt;Point&gt; points;</div><div class="line">  std::vector&lt;Vector&gt; normals;</div><div class="line">  std::ifstream stream(fname);</div><div class="line">  Point p;</div><div class="line">  Vector v;</div><div class="line">  <span class="keywordflow">while</span>(stream &gt;&gt; p &gt;&gt; v)</div><div class="line">  {</div><div class="line">    points.push_back(p);</div><div class="line">    normals.push_back(v);</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; points.size() &lt;&lt; <span class="stringliteral">" input points"</span> &lt;&lt; std::endl;</div><div class="line">  std::vector&lt;std::size_t&gt; indices(points.size());</div><div class="line">  <span class="keywordflow">for</span>(std::size_t i = 0; i &lt; points.size(); ++i){</div><div class="line">    indices[i] = i;</div><div class="line">  }</div><div class="line">  <span class="comment">// simplification by clustering using erase-remove idiom</span></div><div class="line">  <span class="keywordtype">double</span> cell_size = 0.05;</div><div class="line">  std::vector&lt;std::size_t&gt;::iterator end;</div><div class="line">  end = <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga7757ef9b3900e42fde26f5a0ac56e20f">CGAL::grid_simplify_point_set</a>(indices,</div><div class="line">                                      cell_size,</div><div class="line">                                      CGAL::parameters::point_map (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/group__PkgPropertyMapRef.html#ga44ae71cce5987f3970443868a129752a">CGAL::make_property_map</a>(points)));</div><div class="line"></div><div class="line">  std::size_t k = end - indices.begin();</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Keep "</span> &lt;&lt; k &lt;&lt; <span class="stringliteral">" of "</span> &lt;&lt; indices.size() &lt;&lt;  <span class="stringliteral">" indices"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  {</div><div class="line">    std::vector&lt;Point&gt; tmp_points(k);</div><div class="line">    std::vector&lt;Vector&gt; tmp_normals(k);</div><div class="line">    <span class="keywordflow">for</span>(std::size_t i=0; i&lt;k; ++i){</div><div class="line">      tmp_points[i] = points[indices[i]];</div><div class="line">      tmp_normals[i] = normals[indices[i]];</div><div class="line">    }</div><div class="line">    points.swap(tmp_points);</div><div class="line">    normals.swap(tmp_normals);</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; points.size() &lt;&lt; <span class="stringliteral">" points after the simplification"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h2><a class="anchor" id="Point_set_processing_3Outdated"></a>
Upgrading from pre-CGAL 4.12 API</h2>
<p>The current API based on ranges and named parameters was introduced in CGAL 4.12. The old API that used pairs of iterators along with usual C++ parameters (with some default values and overloads to handle optional parameters) has been removed in CGAL 5.0.</p>
<p>Translating your pre-CGAL 4.12 code using Point Set Processing to the current API is easy. For example, consider this code using the old API:</p>
<div class="fragment"><div class="line">std::vector&lt;PointVectorPair&gt; points;</div><div class="line"></div><div class="line"><span class="comment">// Old pre-CGAL 4.12 API</span></div><div class="line">CGAL::jet_estimate_normals&lt;Concurrency_tag&gt;</div><div class="line">  (points.begin(), points.end(),</div><div class="line">   <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>(),</div><div class="line">   <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>(),</div><div class="line">   12); <span class="comment">// Number of neighbors</span></div></div><!-- fragment --><p>The pair of iterators is replaced by a range and the optional parameters (than can be deduced automatically in simple cases) are moved to the end of the function in a single named parameter object (see <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/BGL.tag:../BGL/" href="../BGL/index.html#BGLNamedParameters">Named Parameters</a>). The code translated to the current API becomes:</p>
<div class="fragment"><div class="line">std::vector&lt;PointVectorPair&gt; points;</div><div class="line"></div><div class="line"><span class="comment">// New API</span></div><div class="line">CGAL::jet_estimate_normals&lt;Concurrency_tag&gt;</div><div class="line">  (points,</div><div class="line">   12, <span class="comment">// Number of neighbors</span></div><div class="line">   CGAL::parameters::point_map (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>()).</div><div class="line">   normal_map (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>()));</div></div><!-- fragment --><p>Please refer to the <a class="el" href="group__PkgPointSetProcessing3Ref.html">Reference Manual</a> for the detailed API of the Point Set Processing functions.</p>
<h1><a class="anchor" id="Point_set_processing_3InputOutput"></a>
Input/Output</h1>
<h2><a class="anchor" id="Point_set_processing_3Points_io"></a>
Points And Normals</h2>
<p>CGAL provides functions to read and write sets of points (possibly with normals) from the following file formats:</p>
<ul>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/IOStreamSupportedFileFormats.html#IOStreamXYZ">XYZ </a> (ASCII file three point coordinates <code>x y z</code> per line or three point coordinates and three normal vector coordinates <code>x y z nx ny nz</code> per line)</li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/IOStreamSupportedFileFormats.html#IOStreamOFF">OFF (Object File Format) </a> – <a class="el" href="citelist.html#CITEREF_cgal:p-gmgv16-96">[11]</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/IOStreamSupportedFileFormats.html#IOStreamPLY">PLY (Polygon File Format) </a> – <a class="el" href="citelist.html#CITEREF_cgal:b-ply-11">[12]</a></li>
<li><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/IOStreamSupportedFileFormats.html#IOStreamLAS">LAS (Lidar Format) </a> – <a class="el" href="citelist.html#CITEREF_cgal:asprs-lasf-13">[1]</a> This format does not handle normals and requires the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartyLASlib">LASlib</a> library.</li>
</ul>
<p>All of the functions in <a class="el" href="group__PkgPointSetProcessing3IO.html">I/O Functions</a> (with the exception of the LAS format) can read and write either points alone or points with normals (depending on whether the <code>normal_map</code> named parameter is used by the user or not). Note that the PLY format handles both ASCII and binary formats. In addition, PLY and LAS are extensible formats that can embed additional properties. These can also be read by CGAL (see Section <a class="el" href="index.html#Point_set_processing_3Properties_io">Points With Properties</a>).</p>
<h3><a class="anchor" id="Point_set_processing_3Example_io"></a>
Example</h3>
<p>The following example reads a point set from an input file and writes it to a file, both in the XYZ format. Positions and normals are stored in pairs and accessed through property maps. <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2read_write_xyz_point_set_example_8cpp-example.html">Point_set_processing_3/read_write_xyz_point_set_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_xyz_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_xyz_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span> <span class="comment">// defines std::pair</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"></div><div class="line"><span class="comment">// Point with normal vector stored as a std::pair.</span></div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Point, Vector&gt; Pwn;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/oni.pwn"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Reads a .xyz point set file in points[].</span></div><div class="line">  <span class="comment">// Note: read_points() requires an output iterator</span></div><div class="line">  <span class="comment">// over points and as well as property maps to access each</span></div><div class="line">  <span class="comment">// point position and normal.</span></div><div class="line">  std::vector&lt;Pwn&gt; points;</div><div class="line">  <span class="keywordflow">if</span>(!CGAL::IO::read_XYZ(fname,</div><div class="line">                         std::back_inserter(points),</div><div class="line">                         CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Pwn&gt;</a>())</div><div class="line">                                          .normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;Pwn&gt;</a>())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Saves point set.</span></div><div class="line">  <span class="comment">// Note: write_XYZ() requires property maps to access each</span></div><div class="line">  <span class="comment">// point position and normal.</span></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IOXyz.html#ga1991ab8d312de62ddd907f81890ed039">CGAL::IO::write_XYZ</a>(<span class="stringliteral">"oni_copy.xyz"</span>, points,</div><div class="line">                          CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Pwn&gt;</a>())</div><div class="line">                                           .normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;Pwn&gt;</a>())</div><div class="line">                                           .stream_precision(17)))</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Point_set_processing_3Properties_io"></a>
Points With Properties</h2>
<p>PLY files are designed to embed an arbitrary number of additional attributes. More specifically, point sets may contain visibility vectors, RGB colors, intensity, etc. As it is not possible to provide dedicated functions to every possible combination of PLY properties, CGAL provides a simple way to read PLY properties and store them in any structure the user needs. Handling of LAS files works similarly with the difference that the property names and types are fixed and defined by the LAS standard.</p>
<p>Functions <code><a class="el" href="group__PkgPointSetProcessing3IOPly.html#gad9785e7191ba94d81fac841798aa1ddb" title="reads user-selected points properties from a .ply stream (ASCII or binary). ">read_PLY_with_properties()</a></code> and <code><a class="el" href="group__PkgPointSetProcessing3IOLas.html#ga5187fc18430a5e3c811f75da57a057ad" title="reads user-selected points properties from a .las or .laz stream. ">read_LAS_with_properties()</a></code> allow the user to read any property needed. The user must provide a set of property handlers that are used to instantiate number types and complex objects from PLY/LAS properties. This handlers are either:</p>
<ul>
<li>a pair consisting of a property map and of a single PLY/LAS property descriptor</li>
<li>a tuple consisting of a property map, a functor to construct the objects wanted and multiple PLY/LAS property descriptors</li>
</ul>
<p>Output functions <code><a class="el" href="group__PkgPointSetProcessing3IOPly.html#gac1fd90a9d5266e631c68cb31bfe31516" title="writes the range of points with properties using Polygon File Format (PLY). ">write_PLY_with_properties()</a></code> and <code><a class="el" href="group__PkgPointSetProcessing3IOLas.html#gafaeb3b48279532412ec422c90a7f05fc" title="writes the range of points with properties to a .las stream. ">write_LAS_with_properties()</a></code> work similarly.</p>
<h3><a class="anchor" id="Point_set_processing_3Example_ply_write"></a>
PLY Writing Example</h3>
<p>The following example shows how to call <code><a class="el" href="group__PkgPointSetProcessing3IOPly.html#gac1fd90a9d5266e631c68cb31bfe31516" title="writes the range of points with properties using Polygon File Format (PLY). ">write_PLY_with_properties()</a></code> to write a point set with points, RGB colors and intensity. Notice that in order to write a complex object, users need to provide an overload of <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1Output__rep.html">CGAL::Output_rep</a></code>.</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2write_ply_points_example_8cpp-example.html">Point_set_processing_3/write_ply_points_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_ply_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"><span class="keyword">typedef</span> std::array&lt;unsigned char, 4&gt; Color;</div><div class="line"></div><div class="line"><span class="comment">// Point with normal, color and intensity</span></div><div class="line"><span class="keyword">typedef</span> std::tuple&lt;Point, Color, int&gt; PCI;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;0, PCI&gt;</a> Point_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;1, PCI&gt;</a> Color_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;2, PCI&gt;</a> Intensity_map;</div><div class="line"></div><div class="line"><span class="comment">// Define how a color should be stored</span></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceCGAL.html">CGAL</a> {</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> F &gt;</div><div class="line"><span class="keyword">struct </span>Output_rep&lt; ::Color, F &gt; {</div><div class="line">  const ::Color&amp; c;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> is_specialized = <span class="keyword">true</span>;</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1Output__rep.html#a3ecfc0ce6d2e5db55ad05d08c549ce27">Output_rep</a> (const ::Color&amp; c) : c(c)</div><div class="line">  { }</div><div class="line">  std::ostream&amp; <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/classCGAL_1_1Output__rep.html#a022b1af6b20bcd6957908d70b3c9136b">operator() </a>(std::ostream&amp; out)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">if</span> (<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#gaf145cf5cbf5e27ebb907a8260002a5f3">IO::is_ascii</a>(out))</div><div class="line">      out &lt;&lt; int(c[0]) &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; int(c[1]) &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; int(c[2]) &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; int(c[3]);</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      out.write(reinterpret_cast&lt;const char*&gt;(&amp;c), <span class="keyword">sizeof</span>(c));</div><div class="line">    <span class="keywordflow">return</span> out;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line">} <span class="comment">// namespace CGAL</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>**)</div><div class="line">{</div><div class="line">  std::vector&lt;PCI&gt; points; <span class="comment">// store points</span></div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 10; ++ i)</div><div class="line">    points.push_back (std::make_tuple (Point (i / 10., i / 20., i / 30.),</div><div class="line">                                               <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/group__PkgSTLExtensionRef.html#ga6b9a3534a37aeb7d3095ec08801931d7">CGAL::make_array</a> (static_cast&lt;unsigned char&gt;(255 / (i + 1)),</div><div class="line">                                                                 static_cast&lt;unsigned char&gt;(192 / (i + 1)),</div><div class="line">                                                                 static_cast&lt;unsigned char&gt;(128 / (i + 1)),</div><div class="line">                                                                 static_cast&lt;unsigned char&gt;(64 / (i + 1))),</div><div class="line">                                               i));</div><div class="line"></div><div class="line">  std::ofstream f(<span class="stringliteral">"out.ply"</span>, std::ios::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a>(f); <span class="comment">// The PLY file will be written in the binary format</span></div><div class="line"></div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3IOPly.html#gac1fd90a9d5266e631c68cb31bfe31516">CGAL::IO::write_PLY_with_properties</a>(f, points,</div><div class="line">                                      <a class="code" href="group__PkgPointSetProcessing3IOPly.html#ga241c6df9d93e26ec7254ef6366cb7e5b">CGAL::make_ply_point_writer</a> (Point_map()),</div><div class="line">                                      std::make_tuple(Color_map(),</div><div class="line">                                                      <a class="code" href="structCGAL_1_1IO_1_1PLY__property.html">CGAL::IO::PLY_property&lt;unsigned char&gt;</a>(<span class="stringliteral">"red"</span>),</div><div class="line">                                                      <a class="code" href="structCGAL_1_1IO_1_1PLY__property.html">CGAL::IO::PLY_property&lt;unsigned char&gt;</a>(<span class="stringliteral">"green"</span>),</div><div class="line">                                                      <a class="code" href="structCGAL_1_1IO_1_1PLY__property.html">CGAL::IO::PLY_property&lt;unsigned char&gt;</a>(<span class="stringliteral">"blue"</span>),</div><div class="line">                                                      <a class="code" href="structCGAL_1_1IO_1_1PLY__property.html">CGAL::IO::PLY_property&lt;unsigned char&gt;</a>(<span class="stringliteral">"alpha"</span>)),</div><div class="line">                                  std::make_pair(Intensity_map(), <a class="code" href="structCGAL_1_1IO_1_1PLY__property.html">CGAL::IO::PLY_property&lt;int&gt;</a>(<span class="stringliteral">"intensity"</span>)));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="Point_set_processing_3Example_ply_read"></a>
PLY Reading Example</h3>
<p>The following example shows how to call <code><a class="el" href="group__PkgPointSetProcessing3IOPly.html#gad9785e7191ba94d81fac841798aa1ddb" title="reads user-selected points properties from a .ply stream (ASCII or binary). ">read_PLY_with_properties()</a></code> to read a point set with points, normals, RGB colors and intensity and stores these attributes in a user-defined container.</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2read_ply_points_with_colors_example_8cpp-example.html">Point_set_processing_3/read_ply_points_with_colors_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_ply_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"><span class="keyword">typedef</span> std::array&lt;unsigned char, 3&gt; Color;</div><div class="line"></div><div class="line"><span class="comment">// Point with normal, color and intensity</span></div><div class="line"><span class="keyword">typedef</span> std::tuple&lt;Point, Vector, Color, int&gt; PNCI;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;0, PNCI&gt;</a> Point_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;1, PNCI&gt;</a> Normal_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;2, PNCI&gt;</a> Color_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;3, PNCI&gt;</a> Intensity_map;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/colors.ply"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Reads a .ply point set file with normal vectors and colors</span></div><div class="line">  std::vector&lt;PNCI&gt; points; <span class="comment">// store points</span></div><div class="line">  std::ifstream in(fname);</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IOPly.html#gad9785e7191ba94d81fac841798aa1ddb">CGAL::IO::read_PLY_with_properties</a>(in, std::back_inserter(points),</div><div class="line">                                         <a class="code" href="group__PkgPointSetProcessing3IOPly.html#ga3a744d1f9a1c46955cf58866286166ff">CGAL::make_ply_point_reader</a>(Point_map()),</div><div class="line">                                         std::make_pair(Intensity_map(), CGAL::PLY_property&lt;int&gt;(<span class="stringliteral">"intensity"</span>)),</div><div class="line">                                         std::make_tuple(Color_map(),</div><div class="line">                                                         <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Construct__array.html">CGAL::Construct_array</a>(),</div><div class="line">                                                         <a class="code" href="structCGAL_1_1IO_1_1PLY__property.html">CGAL::IO::PLY_property&lt;unsigned char&gt;</a>(<span class="stringliteral">"red"</span>),</div><div class="line">                                                         <a class="code" href="structCGAL_1_1IO_1_1PLY__property.html">CGAL::IO::PLY_property&lt;unsigned char&gt;</a>(<span class="stringliteral">"green"</span>),</div><div class="line">                                                         <a class="code" href="structCGAL_1_1IO_1_1PLY__property.html">CGAL::IO::PLY_property&lt;unsigned char&gt;</a>(<span class="stringliteral">"blue"</span>)),</div><div class="line">                                         <a class="code" href="group__PkgPointSetProcessing3IOPly.html#gaab9a3f1eba6de91187b82af3087afe67">CGAL::IO::make_ply_normal_reader</a>(Normal_map())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Display points read</span></div><div class="line">  <span class="keywordflow">for</span>(std::size_t i = 0; i &lt; points.size (); ++ i)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> Point&amp; p = get&lt;0&gt;(points[i]);</div><div class="line">    <span class="keyword">const</span> Vector&amp; n = get&lt;1&gt;(points[i]);</div><div class="line">    <span class="keyword">const</span> Color&amp; c = get&lt;2&gt;(points[i]);</div><div class="line">    <span class="keywordtype">int</span> I = get&lt;3&gt;(points[i]);</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Point ("</span> &lt;&lt; p</div><div class="line">              &lt;&lt; <span class="stringliteral">") with normal ("</span> &lt;&lt; n</div><div class="line">              &lt;&lt; <span class="stringliteral">"), color ("</span> &lt;&lt; int(c[0]) &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; int(c[1]) &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; int(c[2])</div><div class="line">              &lt;&lt; <span class="stringliteral">") and intensity "</span> &lt;&lt; I &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="Point_set_processing_3Example_las_read"></a>
LAS Reading Example</h3>
<p>The following example shows how to call <code><a class="el" href="group__PkgPointSetProcessing3IOLas.html#ga5187fc18430a5e3c811f75da57a057ad" title="reads user-selected points properties from a .las or .laz stream. ">read_LAS_with_properties()</a></code> to read a point set with points and RGBI colors and stores these attributes in a user-defined container.</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2read_las_example_8cpp-example.html">Point_set_processing_3/read_las_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_las_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> std::array&lt;unsigned short, 4&gt; Color;</div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Point, Color&gt; PointWithColor;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* fname = (argc&gt;1) ? argv[1] : <span class="stringliteral">"data/pig_points.las"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Reads a .las point set file with normal vectors and colors</span></div><div class="line">  std::ifstream in(fname, std::ios_base::binary);</div><div class="line">  std::vector&lt;PointWithColor&gt; points; <span class="comment">// store points</span></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IOLas.html#ga5187fc18430a5e3c811f75da57a057ad">CGAL::IO::read_LAS_with_properties</a>(in, std::back_inserter (points),</div><div class="line">                                         <a class="code" href="group__PkgPointSetProcessing3IOLas.html#gac807a7bbde008f9707a1cf697e3eb64c">CGAL::IO::make_las_point_reader</a>(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointWithColor&gt;</a>()),</div><div class="line">                                         std::make_tuple(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointWithColor&gt;</a>(),</div><div class="line">                                                         <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Construct__array.html">CGAL::Construct_array</a>(),</div><div class="line">                                                         CGAL::IO::LAS_property::R(),</div><div class="line">                                                         CGAL::IO::LAS_property::G(),</div><div class="line">                                                         CGAL::IO::LAS_property::B(),</div><div class="line">                                                         CGAL::IO::LAS_property::I())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(std::size_t i = 0; i &lt; points.size(); ++ i)</div><div class="line">    std::cout &lt;&lt; points[i].first &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/index.html#IOstreamPointSetIO">Point Set IO</a></dd></dl>
<h1><a class="anchor" id="Point_set_processing_3Spacing"></a>
Average Spacing</h1>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga8b330397a3fb68176c851fd7d214b513" title="Computes average spacing from k nearest neighbors. ">compute_average_spacing()</a></code> computes the average spacing of all input points to their <code>k</code> nearest neighbor points, <code>k</code> being specified by the user. As it provides an order of a point set density, this function is used downstream the surface reconstruction pipeline to automatically determine some parameters such as output mesh sizing for surface reconstruction.</p>
<h2><a class="anchor" id="Point_set_processing_3Example_average_spacing"></a>
Example</h2>
<p>The following example reads a point set in the <code>xyz</code> format and computes the average spacing. <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/classIndex.html">Index</a>, position and color are stored in a tuple and accessed through property maps. <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2average_spacing_example_8cpp-example.html">Point_set_processing_3/average_spacing_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/compute_average_spacing.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/tuple/tuple.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"></div><div class="line"><span class="comment">// Data type := index, followed by the point, followed by three integers that</span></div><div class="line"><span class="comment">// define the Red Green Blue color of the point.</span></div><div class="line"><span class="keyword">typedef</span> boost::tuple&lt;int, Point, int, int, int&gt; IndexedPointWithColorTuple;</div><div class="line"></div><div class="line"><span class="comment">// Concurrency</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a> Concurrency_tag;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname = (argc&gt;1)?argv[1]:<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/sphere_20k.xyz"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Reads a file in points.</span></div><div class="line">  <span class="comment">// As the point is the second element of the tuple (that is with index 1)</span></div><div class="line">  <span class="comment">// we use a property map that accesses the 1st element of the tuple.</span></div><div class="line"></div><div class="line">  std::vector&lt;IndexedPointWithColorTuple&gt; points;</div><div class="line">  <span class="keywordflow">if</span> (!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname, std::back_inserter(points),</div><div class="line">                             CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;1, IndexedPointWithColorTuple&gt;</a>())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Initialize index and RGB color fields in tuple.</span></div><div class="line">  <span class="comment">// As the index and RGB color are respectively the first and third-fifth elements</span></div><div class="line">  <span class="comment">// of the tuple we use a get function from the property map that accesses the 0</span></div><div class="line">  <span class="comment">// and 2-4th elements of the tuple.</span></div><div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; points.size(); i++)</div><div class="line">  {</div><div class="line">    points[i].get&lt;0&gt;() = i; <span class="comment">// set index value of tuple to i</span></div><div class="line"></div><div class="line">    points[i].get&lt;2&gt;() = 0; <span class="comment">// set RGB color to black</span></div><div class="line">    points[i].get&lt;3&gt;() = 0;</div><div class="line">    points[i].get&lt;4&gt;() = 0;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Computes average spacing.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nb_neighbors = 6; <span class="comment">// 1 ring</span></div><div class="line">  FT average_spacing = CGAL::compute_average_spacing&lt;Concurrency_tag&gt;(</div><div class="line">                         points, nb_neighbors,</div><div class="line">                         CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;1,IndexedPointWithColorTuple&gt;</a>()));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Average spacing: "</span> &lt;&lt; average_spacing &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>Note that other functions such as centroid or bounding volumes are found in other CGAL components:</p>
<ul>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/group__centroid__grp.html#gacc395064255dfefdb1420309db234210">centroid()</a></code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Principal_component_analysis.tag:../Principal_component_analysis/" href="../Principal_component_analysis/group__PkgPrincipalComponentAnalysisDbb.html#ga7674a40dcf2ee64bebc89d97bf801c1d">bounding_box()</a></code></li>
<li><code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Bounding_volumes.tag:../Bounding_volumes/" href="../Bounding_volumes/classCGAL_1_1Min__sphere__of__spheres__d.html">Min_sphere_of_spheres_d</a>&lt;Traits&gt;</code></li>
</ul>
<h1><a class="anchor" id="Point_set_processing_3Scale"></a>
Automatic Scale Estimation</h1>
<p>Point sets are often used to sample objects with a higher dimension, typically a curve in 2D or a surface in 3D. In such cases, finding the scale of the object is crucial, that is to say finding the minimal number of points (or the minimal local range) such that the subset of points has the appearance of a curve in 2D or a surface in 3D <a class="el" href="citelist.html#CITEREF_cgal:gcsa-nasr-13">[2]</a>.</p>
<p>CGAL provides two functions that automatically estimate the scale of a 2D point set sampling a curve or a 3D point set sampling a surface:</p>
<ul>
<li><code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga8c6af1df54e336bd0b9a2de6b909bccf" title="Estimates the global scale in a K nearest neighbors sense. ">estimate_global_k_neighbor_scale()</a></code></li>
<li><code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga28fe6443638647be0874b283085eb2cd" title="Estimates the global scale in a range sense. ">estimate_global_range_scale()</a></code></li>
</ul>
<p>Functions such as <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga7757ef9b3900e42fde26f5a0ac56e20f" title="Merges points which belong to the same cell of a grid of cell size = epsilon. ">grid_simplify_point_set()</a></code> require a range scale while <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga078e25209373cab0e1f3524202489771" title="Estimates normal directions of the range of points using jet fitting on the nearest neighbors...">jet_estimate_normals()</a></code>, <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga50c708584a8219847ce04f636dcad4b3" title="Removes outliers: ">remove_outliers()</a></code> or <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gaab0fd78ef3e46c4256e9a1145a9d118e" title="Estimates normal directions of the range of points using the Voronoi Covariance Measure with a radius...">vcm_estimate_normals()</a></code> are examples of functions that accepts both a K neighbor scale or a range scale.</p>
<p>In some specific cases, the scale of a point set might not be homogeneous (for example if the point set contains variable noise). CGAL also provides two functions that automatically estimate the scales of a point set at a set of user-defined query points:</p>
<ul>
<li><code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga6e2493a424482f07d766f12fedefedd0" title="Estimates the local scale in a K nearest neighbors sense on a set of user-defined query points...">estimate_local_k_neighbor_scales()</a></code></li>
<li><code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gaf45220685eff6649d29f600eb66fb6c1" title="Estimates the local scale in a range sense on a set of user-defined query points. ...">estimate_local_range_scales()</a></code></li>
</ul>
<p>The 4 functions presented here work both with 2D points and 3D points and they shouldn't be used if the point sets do not sample a curve in 2D or a surface in 3D.</p>
<h2><a class="anchor" id="Point_set_processing_3Example_scale_estimation_global"></a>
Global Scale Example</h2>
<p>The following example reads a 3D point set in the <code>xyz</code> format and:</p>
<ul>
<li>Estimates the K neighbor global scale</li>
<li>Uses it to smooth the point set</li>
<li>Estimates the range global scale</li>
<li>Uses it to simplify the point set</li>
</ul>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2scale_estimation_example_8cpp-example.html">Point_set_processing_3/scale_estimation_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/estimate_scale.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/jet_smooth_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/grid_simplify_point_set.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Timer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Memory_sizer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Concurrency</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a> Concurrency_tag;</div><div class="line"></div><div class="line"><span class="comment">// Types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point_3;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname = (argc&gt;1)?argv[1]:<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/sphere_20k.xyz"</span>);</div><div class="line"></div><div class="line">  CGAL::Timer task_timer;</div><div class="line"></div><div class="line">  <span class="comment">// read input</span></div><div class="line">  std::vector&lt;Point_3&gt; points;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname, std::back_inserter(points)))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: can't read input file"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// estimate k scale</span></div><div class="line">  task_timer.start();</div><div class="line">  std::size_t k_scale = <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga8c6af1df54e336bd0b9a2de6b909bccf">CGAL::estimate_global_k_neighbor_scale</a> (points);</div><div class="line">  task_timer.stop();</div><div class="line"></div><div class="line">  <span class="comment">// Example: use estimated k as scale for jet smoothing</span></div><div class="line">  CGAL::jet_smooth_point_set&lt;Concurrency_tag&gt;(points, <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(k_scale));</div><div class="line"></div><div class="line">  <span class="comment">// estimate range scale</span></div><div class="line">  task_timer.start();</div><div class="line">  FT range_scale = <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga28fe6443638647be0874b283085eb2cd">CGAL::estimate_global_range_scale</a> (points);</div><div class="line">  task_timer.stop();</div><div class="line"></div><div class="line">  <span class="comment">// Example: use estimated range for grid simplification</span></div><div class="line">  points.erase(<a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga7757ef9b3900e42fde26f5a0ac56e20f">CGAL::grid_simplify_point_set</a>(points, range_scale), points.end());</div><div class="line"></div><div class="line">  <span class="comment">// print some information on runtime</span></div><div class="line">  std::size_t memory = CGAL::Memory_sizer().virtual_size();</div><div class="line">  <span class="keywordtype">double</span> time = task_timer.time();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Scales computed in "</span> &lt;&lt; time &lt;&lt; <span class="stringliteral">" second(s) using "</span></div><div class="line">            &lt;&lt; (memory&gt;&gt;20) &lt;&lt; <span class="stringliteral">" MiB of memory:"</span> &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">" * Global K scale: "</span> &lt;&lt; k_scale &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">" * Global range scale: "</span> &lt;&lt; range_scale &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h2><a class="anchor" id="Point_set_processing_3Example_scale_estimation_local"></a>
Local Scales Example</h2>
<p>This second example generates a 2D point set sampling a circle with variable noise. It then estimates the scale at 3 different query points in the domain.</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2scale_estimation_2d_example_8cpp-example.html">Point_set_processing_3/scale_estimation_2d_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/estimate_scale.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Random.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__2.html">Kernel::Point_2</a> Point_2;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span>, <span class="keywordtype">char</span>**)</div><div class="line">{</div><div class="line">  std::vector&lt;Point_2&gt; samples;</div><div class="line">  samples.reserve (100000);</div><div class="line"></div><div class="line">  <span class="comment">// Generate circle with gradually variable noise</span></div><div class="line">  <span class="comment">//  - noise-free for points with x close to (-1)</span></div><div class="line">  <span class="comment">//  - noisy for points with x close to (+1)</span></div><div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; 100000; ++ i)</div><div class="line">    {</div><div class="line">      FT theta = CGAL::get_default_random().get_double(0, 2. * CGAL_PI);</div><div class="line">      FT noise = 0.5 * (std::cos(theta) + 1.) * CGAL::get_default_random().get_double(0., 0.2);</div><div class="line">      <span class="keywordtype">int</span> mult = (CGAL::get_default_random().get_bool() ? 1 : -1);</div><div class="line">      samples.push_back (Point_2 (std::cos(theta) * (1. + mult * noise * noise),</div><div class="line">                                  std::sin(theta) * (1. + mult * noise * noise)));</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="comment">// Search for local scales on 3 different locations</span></div><div class="line">  std::vector&lt;Point_2&gt; queries;</div><div class="line">  queries.reserve (3);</div><div class="line">  queries.push_back (Point_2 (-1., 0.));</div><div class="line">  queries.push_back (Point_2 (0., 1.));</div><div class="line">  queries.push_back (Point_2 (1., 0.));</div><div class="line"></div><div class="line">  std::vector&lt;std::size_t&gt; k_scales;</div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga6e2493a424482f07d766f12fedefedd0">CGAL::estimate_local_k_neighbor_scales</a> (samples,</div><div class="line">                                          queries,</div><div class="line">                                          std::back_inserter (k_scales));</div><div class="line"></div><div class="line">  <span class="comment">// Display results</span></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"K-Scales found:"</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">" - On noise-free region: "</span> &lt;&lt; k_scales[0] &lt;&lt; std::endl <span class="comment">// Should be small</span></div><div class="line">            &lt;&lt; <span class="stringliteral">" - On moderately noisy region: "</span> &lt;&lt; k_scales[1] &lt;&lt; std::endl <span class="comment">// Should be higher</span></div><div class="line">            &lt;&lt; <span class="stringliteral">" - On very noisy region: "</span> &lt;&lt; k_scales[2] &lt;&lt; std::endl; <span class="comment">// Should be even higher</span></div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h1><a class="anchor" id="Point_set_processing_3Registration"></a>
Registration</h1>
<p>CGAL provides two functions as wrapper for the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartyOpenGR">OpenGR</a> library <a class="el" href="citelist.html#CITEREF_cgal:m-ogr-17">[7]</a>, and two functions as wrapper for the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartylibpointmatcher">PointMatcher</a> library :</p>
<ul>
<li><code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga1a077db2cedb624e4b4b0ed492598db0" title="Computes the registration of point_set_2 with respect to point_set_1 and returns the corresponding af...">CGAL::OpenGR::compute_registration_transformation()</a></code> computes the registration of one point set w.r.t. another in the form of a <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Aff__transformation__3.html">CGAL::Aff_transformation_3</a></code> object, using the Super4PCS algorithm <a class="el" href="citelist.html#CITEREF_cgal:mam-sffgp-14">[8]</a>;</li>
<li><code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga2d2e21a8a49472a5ed1254f42978608e" title="Computes the registration of point_set_2 with respect to point_set_1 and applies it. ">CGAL::OpenGR::register_point_sets()</a></code> computes the registration of one point set w.r.t. another and directly aligns it to it;</li>
<li><code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga365997b9b06c6576452ec6493b743f52" title="Computes the registration of point_set_2 with respect to point_set_1 and returns the corresponding af...">CGAL::pointmatcher::compute_registration_transformation()</a></code> computes the registration of one point set w.r.t. another in the form of a <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Aff__transformation__3.html">CGAL::Aff_transformation_3</a></code> object, using the ICP (Iterative Closest Point) algorithm;</li>
<li><code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gaa849870cbc74cee3f2f536c70aadf976" title="Computes the registration of point_set_2 with respect to point_set_1 and applies it. ">CGAL::pointmatcher::register_point_sets()</a></code> computes the registration of one point set w.r.t. another and directly aligns it to it.</li>
</ul>
<h2><a class="anchor" id="Point_set_processing_3Examples_registration_OpenGR"></a>
OpenGR Example</h2>
<p>The following example reads two point sets and aligns them using the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartyOpenGR">OpenGR</a> library, using the Super4PCS algorithm: <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2registration_with_OpenGR_8cpp-example.html">Point_set_processing_3/registration_with_OpenGR.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/OpenGR/compute_registration_transformation.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/OpenGR/register_point_sets.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> K;</div><div class="line"><span class="keyword">typedef</span> K::Point_3 Point_3;</div><div class="line"><span class="keyword">typedef</span> K::Vector_3 Vector_3;</div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Point_3, Vector_3&gt; Pwn;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Pwn&gt;</a> Point_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;Pwn&gt;</a> Normal_map;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>params = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL_1_1parameters.html">CGAL::parameters</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname1 = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/hippo1.ply"</span>);</div><div class="line">  <span class="keyword">const</span> std::string fname2 = (argc&gt;2) ? argv[2] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/hippo2.ply"</span>);</div><div class="line"></div><div class="line">  std::vector&lt;Pwn&gt; pwns1, pwns2;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname1, std::back_inserter(pwns1),</div><div class="line">                            CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Pwn&gt;</a>())</div><div class="line">                                             .normal_map(Normal_map())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname1 &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname2, std::back_inserter(pwns2),</div><div class="line">                            CGAL::parameters::point_map(Point_map())</div><div class="line">                                             .normal_map(Normal_map())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname2 &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// EITHER call the registration method Super4PCS from OpenGR to get the transformation to apply to pwns2</span></div><div class="line">  <span class="comment">// std::pair&lt;K::Aff_transformation_3, double&gt; res =</span></div><div class="line">    <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga1a077db2cedb624e4b4b0ed492598db0">CGAL::OpenGR::compute_registration_transformation</a>(pwns1, pwns2,</div><div class="line">                                                      params::point_map(Point_map())</div><div class="line">                                                             .normal_map(Normal_map())</div><div class="line">                                                             .number_of_samples(200)</div><div class="line">                                                             .maximum_running_time(60)</div><div class="line">                                                             .accuracy(0.01),</div><div class="line">                                                      params::point_map(Point_map())</div><div class="line">                                                             .normal_map(Normal_map()));</div><div class="line"></div><div class="line">  <span class="comment">// OR call the registration method Super4PCS from OpenGR and apply the transformation to pwn2</span></div><div class="line">  <span class="keywordtype">double</span> score =</div><div class="line">    <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga2d2e21a8a49472a5ed1254f42978608e">CGAL::OpenGR::register_point_sets</a>(pwns1, pwns2,</div><div class="line">                                      params::point_map(Point_map())</div><div class="line">                                             .normal_map(Normal_map())</div><div class="line">                                             .number_of_samples(200)</div><div class="line">                                             .maximum_running_time(60)</div><div class="line">                                             .accuracy(0.01),</div><div class="line">                                      params::point_map(Point_map())</div><div class="line">                                             .normal_map(Normal_map()));</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga5822feba4449f0492363611620b877c0">CGAL::IO::write_points</a>(<span class="stringliteral">"pwns2_aligned.ply"</span>, pwns2,</div><div class="line">                             CGAL::parameters::point_map(Point_map())</div><div class="line">                                              .normal_map(Normal_map())</div><div class="line">                                              .stream_precision(17)))</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Registration score: "</span> &lt;&lt; score &lt;&lt; <span class="stringliteral">".\n"</span></div><div class="line">            &lt;&lt; <span class="stringliteral">"Transformed version of "</span> &lt;&lt; fname2</div><div class="line">            &lt;&lt; <span class="stringliteral">" written to pwn2_aligned.ply.\n"</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><p><a class="el" href="index.html#fig__Point_set_processing_3tableRegistrationRegistration_visualization_table">Figure 80.4</a> demonstrates visualization of a scan data before and after different registration methods are applied, including the OpenGR registration method. To obtain the results for OpenGR registration in the visualization table, above-mentioned example was used.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_OpenGR_parameter_number_of_samples"></a>
Parameter: number_of_samples</h3>
<p>Input clouds are sub-sampled prior exploration, to ensure fast computations. Super4PCS has a linear complexity w.r.t. the number of input samples, allowing to use larger values than 4PCS. Simple geometry with large overlap can be matched with only 200 samples. However, with Super4PCS, smaller details can be used during the process by using up to thousands of points. There is no theoretical limit to this parameter; however, using too large values leads to very a large congruent set, which requires more time and memory to be explored.</p>
<p>Using a large number of samples is recommended when:</p>
<ul>
<li>geometrical details are required to perform the matching, for instance to disambiguate between several similar configurations,</li>
<li>the clouds have a very low overlap: using a too sparse sampling can result in an empty overlapping area, causing the algorithm to fail,</li>
<li>the clouds are very noisy, and require a dense sampling.</li>
</ul>
<p>Note that Super4PCS is a global registration algorithm, which finds a good approximate of the rigid transformation aligning two clouds. Increasing the number of samples in order to get a fine registration is not optimal: it is usually faster to use fewer samples, and refine the transformation using a local algorithm, like the ICP, or its variant SparseICP.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_OpenGR_parameter_accuracy"></a>
Parameter: accuracy</h3>
<p>This parameter controls the registration accuracy: setting a small value means that the two clouds need to be very close to be considered as well aligned. It is expressed in scene units.</p>
<p>A simple way to understand its impact is to consider the computation of the Largest Common Pointset (LCP), the metric used to verify how aligned the clouds are. For each transformation matrix produced by Super4PCS, <a class="el" href="namespaceCGAL_1_1OpenGR.html">OpenGR</a> computes the LCP measure by considering a shell around the reference cloud, and count the percentage of points of the target cloud lying in the shell. The thickness of the shell is defined by the parameter delta (accuracy).</p>
<p>Using too wide values will slow down the algorithm by increasing the size of the congruent set, while using to small values prevents to find a solution. This parameter impacts other steps of the algorithm, see the paper <a class="el" href="citelist.html#CITEREF_cgal:mam-sffgp-14">[8]</a> for more details.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_OpenGR_parameter_normal"></a>
Parameter: maximum normal deviation</h3>
<p>This parameter sets an angle threshold above which two pairs of points are discarded as candidates for matching. It is expressed in degrees.</p>
<p>The default value is 90° (no filtering). Decreasing this value allows to decrease the computation time by being more selective on candidates. Using too small values might result in ignoring candidates that should indeed have been matched and may thus result in a quality decrease.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_OpenGR_parameter_overlap"></a>
Parameter: overlap</h3>
<p>Ratio of expected overlap between the two point sets: it is ranging between 0 (no overlap) to 1 (100% overlap).</p>
<p>The overlap parameter controls the size of the basis used for registration, as shown below:</p>
<p><a class="anchor" id="fig__Point_set_processing_3figOpenGR_parameter_overlap"></a></p><div class="image">
<img src="super4PCS_overlap.png" alt="super4PCS_overlap.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figOpenGR_parameter_overlap">Figure 80.3</a> The effect of varying overlap parameter on the size of the basis used for registration. The overlap is smaller for left (a) than right (b).  </div> <br /> 
<p>Usually, the larger the overlap, the faster the algorithm. When the overlap is unknown, a simple way to set this parameter is to start from 100% overlap, and decrease the value until obtaining a good result. Using too small values will slow down the algorithm, and reduce the accuracy of the result.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_OpenGR_parameter_maximum_running_time"></a>
Parameter: maximum_running_time</h3>
<p>Maximum number of seconds after which the algorithm stops. Super4PCS explores the transformation space to align the two input clouds. Since the exploration is performed randomly, it is recommended to use a large time value to explore the whole space.</p>
<h2><a class="anchor" id="Point_set_processing_3Examples_registration_PointMatcher"></a>
PointMatcher Example</h2>
<p>The following example reads two point sets and aligns them using the <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartylibpointmatcher">PointMatcher</a> library, using the ICP algorithm. It also shows how to customize ICP algorithm by using possible configurations: <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2registration_with_pointmatcher_8cpp-example.html">Point_set_processing_3/registration_with_pointmatcher.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Aff_transformation_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/aff_transformation_tags.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/pointmatcher/compute_registration_transformation.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/pointmatcher/register_point_sets.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> K;</div><div class="line"><span class="keyword">typedef</span> K::Point_3 Point_3;</div><div class="line"><span class="keyword">typedef</span> K::Vector_3 Vector_3;</div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Point_3, Vector_3&gt; Pwn;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Pwn&gt;</a> Point_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;Pwn&gt;</a> Normal_map;</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Weight_map</div><div class="line">{</div><div class="line">  <span class="keyword">typedef</span> Pwn key_type;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> K::FT value_type;</div><div class="line">  <span class="keyword">typedef</span> value_type reference;</div><div class="line">  <span class="keyword">typedef</span> boost::readable_property_map_tag category;</div><div class="line"></div><div class="line">  <span class="keyword">typedef</span> Weight_map Self;</div><div class="line">  <span class="keyword">friend</span> reference <span class="keyword">get</span>(<span class="keyword">const</span> Self&amp;, <span class="keyword">const</span> key_type&amp;) { <span class="keywordflow">return</span> value_type(1); }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>params = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL_1_1parameters.html">CGAL::parameters</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname1 = (argc&gt;1)?argv[1]:<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/hippo1.ply"</span>);</div><div class="line">  <span class="keyword">const</span> std::string fname2 = (argc&gt;2)?argv[2]:<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/hippo2.ply"</span>);</div><div class="line"></div><div class="line">  std::vector&lt;Pwn&gt; pwns1, pwns2;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname1, std::back_inserter(pwns1),</div><div class="line">                            CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Pwn&gt;</a>())</div><div class="line">                                             .normal_map(Normal_map())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname1 &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname2, std::back_inserter(pwns2),</div><div class="line">                            CGAL::parameters::point_map(Point_map())</div><div class="line">                                             .normal_map(Normal_map())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname2 &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="comment">// Prepare ICP config</span></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="keyword">using</span> <a class="code" href="structCGAL_1_1pointmatcher_1_1ICP__config.html">CGAL::pointmatcher::ICP_config</a>;</div><div class="line"></div><div class="line">  <span class="comment">// Possible config modules/components: https://libpointmatcher.readthedocs.io/en/latest/Configuration/#configuration-of-an-icp-chain</span></div><div class="line">  <span class="comment">// See documentation of optional named parameters for CGAL PM ICP configuration / pointmatcher config module mapping</span></div><div class="line"></div><div class="line">  <span class="comment">// Prepare point set 1 filters (PM::ReferenceDataPointsFilters)</span></div><div class="line">  std::vector&lt;ICP_config&gt; point_set_1_filters;</div><div class="line">  point_set_1_filters.push_back( ICP_config { <span class="comment">/*.name=*/</span><span class="stringliteral">"MinDistDataPointsFilter"</span>       , <span class="comment">/*.params=*/</span>{ {<span class="stringliteral">"minDist"</span>, <span class="stringliteral">"0.5"</span> }}  } );</div><div class="line">  point_set_1_filters.push_back( ICP_config { <span class="comment">/*.name=*/</span><span class="stringliteral">"RandomSamplingDataPointsFilter"</span>, <span class="comment">/*.params=*/</span>{ {<span class="stringliteral">"prob"</span>   , <span class="stringliteral">"0.05"</span>}}  } );</div><div class="line"></div><div class="line">  <span class="comment">// Prepare point set 2 filters (PM::ReadingDataPointsFilters)</span></div><div class="line">  std::vector&lt;ICP_config&gt; point_set_2_filters;</div><div class="line">  point_set_2_filters.push_back( ICP_config { <span class="comment">/*.name=*/</span><span class="stringliteral">"MinDistDataPointsFilter"</span>       , <span class="comment">/*.params=*/</span>{ {<span class="stringliteral">"minDist"</span>, <span class="stringliteral">"0.5"</span> }}  } );</div><div class="line">  point_set_2_filters.push_back( ICP_config { <span class="comment">/*.name=*/</span><span class="stringliteral">"RandomSamplingDataPointsFilter"</span>, <span class="comment">/*.params=*/</span>{ {<span class="stringliteral">"prob"</span>   , <span class="stringliteral">"0.05"</span>}}  } );</div><div class="line"></div><div class="line">  <span class="comment">// Prepare matcher function</span></div><div class="line">  ICP_config matcher { <span class="comment">/*.name=*/</span><span class="stringliteral">"KDTreeMatcher"</span>, <span class="comment">/*.params=*/</span>{ {<span class="stringliteral">"knn"</span>, <span class="stringliteral">"1"</span>}, {<span class="stringliteral">"epsilon"</span>, <span class="stringliteral">"3.16"</span>} } };</div><div class="line"></div><div class="line">  <span class="comment">// Prepare outlier filters</span></div><div class="line">  <span class="comment">// NOTE: `GenericDescriptorOutlierFilter` supports only one `descName` that is `weights`!</span></div><div class="line">  std::vector&lt;ICP_config&gt; outlier_filters;</div><div class="line">  outlier_filters.push_back( ICP_config { <span class="comment">/*.name=*/</span><span class="stringliteral">"TrimmedDistOutlierFilter"</span>, <span class="comment">/*.params=*/</span>{ {<span class="stringliteral">"ratio"</span>, <span class="stringliteral">"0.75"</span> }}  } );</div><div class="line">  outlier_filters.push_back( ICP_config { <span class="comment">/*.name=*/</span><span class="stringliteral">"GenericDescriptorOutlierFilter"</span>, <span class="comment">/*.params=*/</span>{ {<span class="stringliteral">"descName"</span>, <span class="stringliteral">"weights"</span> }}  } );</div><div class="line"></div><div class="line">  <span class="comment">// Prepare error minimizer</span></div><div class="line">  ICP_config error_minimizer { <span class="comment">/*.name=*/</span><span class="stringliteral">"PointToPointErrorMinimizer"</span>, <span class="comment">/*.params=*/</span>{ } };</div><div class="line"></div><div class="line">  <span class="comment">// Prepare transformation checker</span></div><div class="line">  std::vector&lt;ICP_config&gt; transformation_checkers;</div><div class="line">  transformation_checkers.push_back( ICP_config { <span class="comment">/*.name=*/</span><span class="stringliteral">"CounterTransformationChecker"</span>, <span class="comment">/*.params=*/</span>{ {<span class="stringliteral">"maxIterationCount"</span>, <span class="stringliteral">"150"</span> }}  } );</div><div class="line">  transformation_checkers.push_back( ICP_config { <span class="comment">/*.name=*/</span><span class="stringliteral">"DifferentialTransformationChecker"</span>, <span class="comment">/*.params=*/</span>{ {<span class="stringliteral">"minDiffRotErr"</span>  , <span class="stringliteral">"0.001"</span> },</div><div class="line">                                                                                                       {<span class="stringliteral">"minDiffTransErr"</span>, <span class="stringliteral">"0.01"</span>  },</div><div class="line">                                                                                                       {<span class="stringliteral">"smoothLength"</span>   , <span class="stringliteral">"4"</span>     } }</div><div class="line">                                                } );</div><div class="line">  <span class="comment">// Prepare inspector</span></div><div class="line">  ICP_config inspector { <span class="comment">/*.name=*/</span><span class="stringliteral">"NullInspector"</span>, <span class="comment">/*.params=*/</span>{ } };</div><div class="line"></div><div class="line">  <span class="comment">// Prepare logger</span></div><div class="line">  ICP_config logger { <span class="comment">/*.name=*/</span><span class="stringliteral">"FileLogger"</span>, <span class="comment">/*.params=*/</span>{ } };</div><div class="line"></div><div class="line">  <span class="keyword">const</span> K::Aff_transformation_3 identity_transform = K::Aff_transformation_3(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Identity__transformation.html">CGAL::Identity_transformation</a>());</div><div class="line"></div><div class="line">  <span class="comment">// EITHER call the ICP registration method pointmatcher to get the transformation to apply to pwns2</span></div><div class="line">  std::pair&lt;K::Aff_transformation_3, bool&gt; res =</div><div class="line">    <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga365997b9b06c6576452ec6493b743f52">CGAL::pointmatcher::compute_registration_transformation</a></div><div class="line">      (pwns1, pwns2,</div><div class="line">       params::point_map(Point_map()).normal_map(Normal_map()).scalar_map(Weight_map())</div><div class="line">                                     .point_set_filters(point_set_1_filters)</div><div class="line">                                     .matcher(matcher)</div><div class="line">                                     .outlier_filters(outlier_filters)</div><div class="line">                                     .error_minimizer(error_minimizer)</div><div class="line">                                     .transformation_checkers(transformation_checkers)</div><div class="line">                                     .inspector(inspector)</div><div class="line">                                     .logger(logger),</div><div class="line">       params::point_map(Point_map()).normal_map(Normal_map()).scalar_map(Weight_map())</div><div class="line">                                     .point_set_filters(point_set_2_filters)</div><div class="line">                                     .transformation(identity_transform) <span class="comment">/* initial transform for pwns2.</span></div><div class="line"><span class="comment">                                                                          * default value is already identity transform.</span></div><div class="line"><span class="comment">                                                                          * a proper initial transform could be given, for example,</span></div><div class="line"><span class="comment">                                                                          * a transform returned from a coarse registration algorithm.</span></div><div class="line"><span class="comment">                                                                          * */</span></div><div class="line">       );</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> converged = <span class="keyword">false</span>;</div><div class="line">  <span class="keywordflow">do</span></div><div class="line">  {</div><div class="line">    <span class="comment">// OR call the ICP registration method from pointmatcher and apply the transformation to pwn2</span></div><div class="line">    converged =</div><div class="line">      <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#gaa849870cbc74cee3f2f536c70aadf976">CGAL::pointmatcher::register_point_sets</a></div><div class="line">      (pwns1, pwns2,</div><div class="line">       params::point_map(Point_map()).normal_map(Normal_map())</div><div class="line">       .point_set_filters(point_set_1_filters)</div><div class="line">       .matcher(matcher)</div><div class="line">       .outlier_filters(outlier_filters)</div><div class="line">       .error_minimizer(error_minimizer)</div><div class="line">       .transformation_checkers(transformation_checkers)</div><div class="line">       .inspector(inspector)</div><div class="line">       .logger(logger),</div><div class="line">       params::point_map(Point_map()).normal_map(Normal_map())</div><div class="line">       .point_set_filters(point_set_2_filters)</div><div class="line">       .transformation(res.first) <span class="comment">/* pass the above computed transformation as initial transformation.</span></div><div class="line"><span class="comment">                                   * as a result, the registration will require less iterations to converge.</span></div><div class="line"><span class="comment">                                   * */</span></div><div class="line">        );</div><div class="line"></div><div class="line">    <span class="comment">// Algorithm may randomly not converge, repeat until it does</span></div><div class="line">    <span class="keywordflow">if</span> (converged)</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">"Success"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">"Did not converge, try again"</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">while</span> (!converged);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga5822feba4449f0492363611620b877c0">CGAL::IO::write_points</a>(<span class="stringliteral">"pwns2_aligned.ply"</span>, pwns2,</div><div class="line">                             CGAL::parameters::point_map(Point_map()).normal_map(Normal_map())))</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Transformed version of "</span> &lt;&lt; fname2 &lt;&lt; <span class="stringliteral">" written to pwn2_aligned.ply.\n"</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><p><a class="el" href="index.html#fig__Point_set_processing_3tableRegistrationRegistration_visualization_table">Figure 80.4</a> demonstrates visualization of a scan data before and after different registration methods are applied, including the PointMatcher registration method. To obtain the results for PointMatcher registration in the visualization table, above-mentioned example was used.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_PointMatcher_parameter_point_set_filters"></a>
Parameter: point_set_filters</h3>
<p>The chain of filters to be applied to the point cloud. The point cloud is processed into an intermediate point cloud with the given chain of filters to be used in the alignment procedure. The chain is organized with the forward traversal order of the point set filters range.</p>
<p>The chain of point set filters are applied only once at the beginning of the ICP procedure, i.e., before the first iteration of the ICP algorithm.</p>
<p>The filters can have several purposes, including but not limited to:</p>
<ul>
<li>removal of noisy points which render alignment of point clouds difficult,</li>
<li>removal of redundant points so as to speed up alignment,</li>
<li>addition of descriptive information to the points such as a surface normal vector or the direction from the point to the sensor.</li>
</ul>
<p>In registration, there are two point clouds in consideration, one of which is the reference point cloud while the other one is the point cloud to register. The point set filters corresponds to <code>readingDataPointsFilters</code> configuration module of <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartylibpointmatcher">PointMatcher</a> library while it corresponds to the <code>referenceDataPointsFilters</code> for the other point cloud. The filters should be chosen and set from possible components of those configuration modules.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_PointMatcher_parameter_matcher"></a>
Parameter: matcher</h3>
<p>The method used for matching (linking) the points from to the points in the reference cloud.</p>
<p>Corresponds to <code>matcher</code> configuration module of <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartylibpointmatcher">PointMatcher</a> library. The matcher should be chosen and set from possible components of the <code>matcher</code> configuration module. See <a href="https://libpointmatcher.readthedocs.io/en/latest/Configuration/#configuration-of-an-icp-chain">libpointmatcher documentation</a> for possible configurations.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_PointMatcher_parameter_outlier_filters"></a>
Parameter: outlier_filters</h3>
<p>The chain of filters to be applied to the matched (linked) point clouds after each processing iteration of the ICP algorithm to remove the links which do not correspond to true point correspondences. The outliers are rejected. Points with no link are ignored in the subsequent error minimization step. The chain is organized with the forward traversal order of the outlier filters range.</p>
<p>Corresponds to <code>outlierFilters</code> configuration module of <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartylibpointmatcher">PointMatcher</a> library. The filters should be chosen and set from possible components of the <code>outlierFilters</code> configuration module. See <a href="https://libpointmatcher.readthedocs.io/en/latest/Configuration/#configuration-of-an-icp-chain">libpointmatcher documentation</a> for possible configurations.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_PointMatcher_parameter_error_minimizer"></a>
Parameter: error_minimizer</h3>
<p>The error minimizer that computes a transformation matrix such as to minimize the error between the point sets.</p>
<p>Corresponds to <code>errorMinimizer</code> configuration module of <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartylibpointmatcher">PointMatcher</a> library. The error minimizer should be chosen and set from possible components of the <code>errorMinimizer</code> configuration module. See <a href="https://libpointmatcher.readthedocs.io/en/latest/Configuration/#configuration-of-an-icp-chain">libpointmatcher documentation</a> for possible configurations.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_PointMatcher_parameter_inspector"></a>
Parameter: inspector</h3>
<p>The inspector allows to log data at different steps for analysis. Inspectors typically provide deeper scrutiny than the logger.</p>
<p>Corresponds to <code>inspector</code> configuration module of <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartylibpointmatcher">PointMatcher</a> library. The inspector should be chosen and set from possible components of the <code>inspector</code> configuration module. See <a href="https://libpointmatcher.readthedocs.io/en/latest/Configuration/#configuration-of-an-icp-chain">libpointmatcher documentation</a> for possible configurations.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_PointMatcher_parameter_logger"></a>
Parameter: logger</h3>
<p>The method for logging information regarding the registration process outputted by <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartylibpointmatcher">PointMatcher</a> library. The logs generated by <a class="el" href="namespaceCGAL.html">CGAL</a> library does not get effected by this configuration.</p>
<p>Corresponds to <code>logger</code> configuration module of <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartylibpointmatcher">PointMatcher</a> library. The logger should be chosen and set from possible components of the <code>logger</code> configuration module. See <a href="https://libpointmatcher.readthedocs.io/en/latest/Configuration/#configuration-of-an-icp-chain">libpointmatcher documentation</a> for possible configurations.</p>
<h3><a class="anchor" id="Point_set_processing_3Examples_registration_PointMatcher_parameter_transformation"></a>
Parameter: transformation</h3>
<p>The affine transformation that is used as the initial transformation for the reference point cloud.</p>
<h2><a class="anchor" id="Point_set_processing_3Examples_registration_OpenGR_PointMatcher_Pipeline"></a>
OpenGR/PointMatcher Pipeline Example</h2>
<p>The following example reads two point sets and aligns them by using both <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartyOpenGR">OpenGR</a> and <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/thirdparty.html#thirdpartylibpointmatcher">PointMatcher</a> libraries, respectively. It depicts a use case where a coarse estimation of a registration transformation is done using the Super4PCS algorithm. Then, a fine registration from this coarse registration using the ICP algorithm. <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2registration_with_opengr_pointmatcher_pipeline_8cpp-example.html">Point_set_processing_3/registration_with_opengr_pointmatcher_pipeline.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Aff_transformation_3.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/pointmatcher/register_point_sets.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/OpenGR/compute_registration_transformation.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> K;</div><div class="line"><span class="keyword">typedef</span> K::Point_3 Point_3;</div><div class="line"><span class="keyword">typedef</span> K::Vector_3 Vector_3;</div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Point_3, Vector_3&gt; Pwn;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Pwn&gt;</a> Point_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;Pwn&gt;</a> Normal_map;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>params = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/namespaceCGAL_1_1parameters.html">CGAL::parameters</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname1 = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/hippo1.ply"</span>);</div><div class="line">  <span class="keyword">const</span> std::string fname2 = (argc&gt;2) ? argv[2] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/hippo2.ply"</span>);</div><div class="line"></div><div class="line">  std::vector&lt;Pwn&gt; pwns1, pwns2;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname1, std::back_inserter(pwns1),</div><div class="line">                            CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Pwn&gt;</a>())</div><div class="line">                                             .normal_map (Normal_map())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname1 &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname2, std::back_inserter(pwns2),</div><div class="line">                            CGAL::parameters::point_map(Point_map())</div><div class="line">                                             .normal_map(Normal_map())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname2 &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Computing registration transformation using OpenGR Super4PCS.."</span> &lt;&lt; std::endl;</div><div class="line">  <span class="comment">// First, compute registration transformation using OpenGR Super4PCS</span></div><div class="line">  K::Aff_transformation_3 res =</div><div class="line">    std::get&lt;0&gt;( <span class="comment">// get first of pair, which is the transformation</span></div><div class="line">      <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga1a077db2cedb624e4b4b0ed492598db0">CGAL::OpenGR::compute_registration_transformation</a></div><div class="line">        (pwns1, pwns2,</div><div class="line">         params::point_map(Point_map()).normal_map(Normal_map()),</div><div class="line">         params::point_map(Point_map()).normal_map(Normal_map())));</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Computing registration transformation using PointMatcher ICP, "</span></div><div class="line">            &lt;&lt; <span class="stringliteral">"taking transformation computed by OpenGR Super4PCS as initial transformation.."</span> &lt;&lt; std::endl;</div><div class="line">  <span class="comment">// Then, compute registration transformation using PointMatcher ICP, taking transformation computed</span></div><div class="line">  <span class="comment">// by OpenGR as initial transformation, and apply the transformation to pwns2</span></div><div class="line">  <span class="comment">// bool converged =</span></div><div class="line">    <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#gaa849870cbc74cee3f2f536c70aadf976">CGAL::pointmatcher::register_point_sets</a></div><div class="line">      (pwns1, pwns2,</div><div class="line">       params::point_map(Point_map()).normal_map(Normal_map()),</div><div class="line">       params::point_map(Point_map()).normal_map(Normal_map()).transformation(res));</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga5822feba4449f0492363611620b877c0">CGAL::IO::write_points</a>(<span class="stringliteral">"pwns2_aligned.ply"</span>, pwns2,</div><div class="line">                             CGAL::parameters::point_map(Point_map())</div><div class="line">                                              .normal_map(Normal_map())))</div><div class="line">  {</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Transformed version of "</span> &lt;&lt; fname2</div><div class="line">            &lt;&lt; <span class="stringliteral">" written to pwn2_aligned.ply.\n"</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><p><a class="el" href="index.html#fig__Point_set_processing_3tableRegistrationRegistration_visualization_table">Figure 80.4</a> demonstrates visualization of a scan data before and after different registration methods are applied, including the pipeline of OpenGR and PointMatcher registration methods. To obtain the results for the pipeline of OpenGR and PointMatcher registration methods in the visualization table, above-mentioned example was used.</p>
<p><a class="anchor" id="fig__Point_set_processing_3tableRegistrationRegistration_visualization_table"></a></p><table class="doxtable">
<tr>
<th></th><th>Scan 1  </th><th>Scan 1 (possibly transformed, green) and Scan 2 (the reference, red)  </th></tr>
<tr>
<th>Unregistered </th><td><a class="anchor" id="fig__Point_set_processing_3figRegistrationUnregistered_hippo2_view1"></a><div class="image">
<img src="registration_view1_hippo2_unregistered.png" alt="registration_view1_hippo2_unregistered.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figRegistrationUnregistered_hippo2_view1">Figure 80.5</a>  </div> <br />   </td><td><a class="anchor" id="fig__Point_set_processing_3figRegistrationUnregistered_hippo1_hippo2_view1"></a><div class="image">
<img src="registration_view1_hippo1_hippo2_unregistered.png" alt="registration_view1_hippo1_hippo2_unregistered.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figRegistrationUnregistered_hippo1_hippo2_view1">Figure 80.6</a>  </div> <br />    </td></tr>
<tr>
<th>Registered using OpenGR  </th><td><a class="anchor" id="fig__Point_set_processing_3figRegistrationOpenGR_hippo2_view1"></a><div class="image">
<img src="registration_view1_hippo2_opengr.png" alt="registration_view1_hippo2_opengr.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figRegistrationOpenGR_hippo2_view1">Figure 80.7</a>  </div> <br />   </td><td><a class="anchor" id="fig__Point_set_processing_3figRegistrationOpenGR_hippo1_hippo2_view1"></a><div class="image">
<img src="registration_view1_hippo1_hippo2_opengr.png" alt="registration_view1_hippo1_hippo2_opengr.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figRegistrationOpenGR_hippo1_hippo2_view1">Figure 80.8</a>  </div> <br />    </td></tr>
<tr>
<th>Registered using PointMatcher  </th><td><a class="anchor" id="fig__Point_set_processing_3figRegistrationPointMatcher_hippo2_view1"></a><div class="image">
<img src="registration_view1_hippo2_pointmatcher.png" alt="registration_view1_hippo2_pointmatcher.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figRegistrationPointMatcher_hippo2_view1">Figure 80.9</a>  </div> <br />   </td><td><a class="anchor" id="fig__Point_set_processing_3figRegistrationPointMatcher_hippo1_hippo2_view1"></a><div class="image">
<img src="registration_view1_hippo1_hippo2_pointmatcher.png" alt="registration_view1_hippo1_hippo2_pointmatcher.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figRegistrationPointMatcher_hippo1_hippo2_view1">Figure 80.10</a>  </div> <br />    </td></tr>
<tr>
<th>Registered using OpenGR+PointMatcher Pipeline  </th><td><a class="anchor" id="fig__Point_set_processing_3figRegistrationPipeline_hippo2_view1"></a><div class="image">
<img src="registration_view1_hippo2_opengr_pointmatcher_pipeline.png" alt="registration_view1_hippo2_opengr_pointmatcher_pipeline.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figRegistrationPipeline_hippo2_view1">Figure 80.11</a>  </div> <br />   </td><td><a class="anchor" id="fig__Point_set_processing_3figRegistrationPipeline_hippo1_hippo2_view1"></a><div class="image">
<img src="registration_view1_hippo1_hippo2_opengr_pointmatcher_pipeline.png" alt="registration_view1_hippo1_hippo2_opengr_pointmatcher_pipeline.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figRegistrationPipeline_hippo1_hippo2_view1">Figure 80.12</a>  </div> <br />    </td></tr>
</table>
<p> </p><div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3tableRegistrationRegistration_visualization_table">Figure 80.4</a> Visualization of registered hippo scans with different registration methods. Two scans are used: red as the reference, green as the one for which the transformation is computed and applied. To obtain the results, the example code given in <a class="el" href="index.html#Point_set_processing_3Examples_registration_OpenGR">OpenGR Example</a> , <a class="el" href="index.html#Point_set_processing_3Examples_registration_PointMatcher">PointMatcher Example</a> , <a class="el" href="index.html#Point_set_processing_3Examples_registration_OpenGR_PointMatcher_Pipeline">OpenGR/PointMatcher Pipeline Example</a> were applied, respectively. The parameters of the algorithms used to obtain those results are not optimized for the shown scans; therefore, better parameter choice might result in better results in terms of registration accuracy for each algorithm individually.  </div> <br /> 
<h1><a class="anchor" id="Point_set_processing_3Clustering"></a>
Clustering</h1>
<p>If an input point set represents several objects which are spatially separated, a clustering algorithm can be applied to identify connected components on a nearest neighbor graph built using a query sphere of fixed radius centered on each point.</p>
<p>The clustering is stored in a cluster map which associates each input point with the index of the cluster it belongs to: users can then use this map however they find it relevant to their use case, for example segmenting the input point set into one point set per cluster. <a class="el" href="index.html#fig__Point_set_processing_3figclustering">Figure 80.13</a> shows different clustering outputs.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figclustering"></a></p><div class="image">
<img src="clustering.png" alt="clustering.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figclustering">Figure 80.13</a> Point Set Clustering outputs (one color per cluster). Top: input point set and clustering using a neighbor radius of 1.5 (147 clusters extracted). Bottom: clustering with neighbor radius 3.0 (37 clusters extracted), and with neighbor radius 6.0 (5 clusters extracted).  </div> <br /> 
<h2><a class="anchor" id="Point_set_processing_3Example_clustering"></a>
Example</h2>
<p>In the following example, clusters (and adjacencies between them) are computed and stored as colors in a PLY file:</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2clustering_example_8cpp-example.html">Point_set_processing_3/clustering_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Point_set_3/IO.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/cluster_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/compute_average_spacing.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Random.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> Kernel = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>;</div><div class="line"><span class="keyword">using</span> Point_3 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ae82b7f4be77dd5b8819ebe419e4ae753">Kernel::Point_3</a>;</div><div class="line"><span class="keyword">using</span> Point_set = CGAL::Point_set_3&lt;Point_3&gt;;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="comment">// Read input file</span></div><div class="line">  std::ifstream ifile((argc &gt; 1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/hippo1.ply"</span>), std::ios_base::binary);</div><div class="line">  Point_set points;</div><div class="line">  ifile &gt;&gt; points;</div><div class="line"></div><div class="line">  <span class="comment">// Add a cluster map</span></div><div class="line">  Point_set::Property_map&lt;int&gt; cluster_map = points.add_property_map&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">"cluster"</span>, -1).first;</div><div class="line"></div><div class="line">  <span class="comment">// Compute average spacing</span></div><div class="line">  <span class="keywordtype">double</span> spacing = CGAL::compute_average_spacing&lt;CGAL::Parallel_if_available_tag&gt; (points, 12);</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Spacing = "</span> &lt;&lt; spacing &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Adjacencies stored in vector</span></div><div class="line">  std::vector&lt;std::pair&lt;std::size_t, std::size_t&gt; &gt; adjacencies;</div><div class="line"></div><div class="line">  <span class="comment">// Compute clusters</span></div><div class="line">  CGAL::Real_timer t;</div><div class="line">  t.start();</div><div class="line">  std::size_t nb_clusters</div><div class="line">    = <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga2531a1366bea67edef99e87d6b8819ec">CGAL::cluster_point_set</a>(points, cluster_map,</div><div class="line">                              points.parameters().neighbor_radius(spacing)</div><div class="line">                                                 .adjacencies(std::back_inserter(adjacencies)));</div><div class="line">  t.stop();</div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Found "</span> &lt;&lt; nb_clusters &lt;&lt; <span class="stringliteral">" clusters with "</span> &lt;&lt; adjacencies.size()</div><div class="line">            &lt;&lt; <span class="stringliteral">" adjacencies in "</span> &lt;&lt; t.time() &lt;&lt; <span class="stringliteral">" seconds"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Output a colored PLY file</span></div><div class="line">  Point_set::Property_map&lt;unsigned char&gt; red = points.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"red"</span>, 0).first;</div><div class="line">  Point_set::Property_map&lt;unsigned char&gt; green = points.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"green"</span>, 0).first;</div><div class="line">  Point_set::Property_map&lt;unsigned char&gt; blue = points.add_property_map&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(<span class="stringliteral">"blue"</span>, 0).first;</div><div class="line">  <span class="keywordflow">for</span>(Point_set::Index idx : points)</div><div class="line">  {</div><div class="line">    <span class="comment">// One color per cluster</span></div><div class="line">    CGAL::Random rand (cluster_map[idx]);</div><div class="line">    red[idx] = rand.get_int(64, 192);</div><div class="line">    green[idx] = rand.get_int(64, 192);</div><div class="line">    blue[idx] = rand.get_int(64, 192);</div><div class="line">  }</div><div class="line"></div><div class="line">  std::ofstream ofile(<span class="stringliteral">"out.ply"</span>, std::ios_base::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a>(ofile);</div><div class="line">  ofile &lt;&lt; points;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Point_set_processing_3OutlierRemoval"></a>
Outlier Removal</h1>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga50c708584a8219847ce04f636dcad4b3" title="Removes outliers: ">remove_outliers()</a></code> deletes a user-specified fraction of outliers from an input point set. More specifically, it partitions the input points with respect to the average squared distances to their nearest neighbors and deletes the points with largest value, either partitioning with a threshold or removing a fixed percentage. The user can either specify a fixed number of nearest neighbors or a fixed spherical neighborhood radius.</p>
<h2><a class="anchor" id="Point_set_processing_3Example_outlier_removal"></a>
Example</h2>
<p>The following example reads a point set and removes 5% of the points. It uses the <code><a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Identity__property__map.html">Identity_property_map</a>&lt;<a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Point__3.html">Point_3</a>&gt;</code> property map (optional as it is the default position property map of all functions in this component.) <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2remove_outliers_example_8cpp-example.html">Point_set_processing_3/remove_outliers_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/compute_average_spacing.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/remove_outliers.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname = (argc&gt;1)?argv[1]:<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/oni.pwn"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Reads a point set file in points[].</span></div><div class="line">  <span class="comment">// The Identity_property_map property map can be omitted here as it is the default value.</span></div><div class="line">  std::vector&lt;Point&gt; points;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname, std::back_inserter(points),</div><div class="line">                            CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Identity__property__map.html">CGAL::Identity_property_map&lt;Point&gt;</a>())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Removes outliers using erase-remove idiom.</span></div><div class="line">  <span class="comment">// The Identity_property_map property map can be omitted here as it is the default value.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_neighbors = 24; <span class="comment">// considers 24 nearest neighbor points</span></div><div class="line"></div><div class="line">  <span class="comment">// Estimate scale of the point set with average spacing</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> average_spacing = CGAL::compute_average_spacing&lt;CGAL::Sequential_tag&gt;(points, nb_neighbors);</div><div class="line"></div><div class="line">  <span class="comment">// FIRST OPTION //</span></div><div class="line">  <span class="comment">// I don't know the ratio of outliers present in the point set</span></div><div class="line">  std::vector&lt;Point&gt;::iterator first_to_remove</div><div class="line">    = CGAL::remove_outliers&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (points,</div><div class="line">     nb_neighbors,</div><div class="line">     CGAL::parameters::threshold_percent (100.). <span class="comment">// No limit on the number of outliers to remove</span></div><div class="line">     threshold_distance (2. * average_spacing)); <span class="comment">// Point with distance above 2*average_spacing are considered outliers</span></div><div class="line"></div><div class="line">  std::cerr &lt;&lt; (100. * std::distance(first_to_remove, points.end()) / static_cast&lt;double&gt;(points.size()))</div><div class="line">            &lt;&lt; <span class="stringliteral">"% of the points are considered outliers when using a distance threshold of "</span></div><div class="line">            &lt;&lt; 2. * average_spacing &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// SECOND OPTION //</span></div><div class="line">  <span class="comment">// I know the ratio of outliers present in the point set</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> removed_percentage = 5.0; <span class="comment">// percentage of points to remove</span></div><div class="line"></div><div class="line">  points.erase(CGAL::remove_outliers&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">               (points,</div><div class="line">                nb_neighbors,</div><div class="line">                CGAL::parameters::threshold_percent(removed_percentage). <span class="comment">// Minimum percentage to remove</span></div><div class="line">                threshold_distance(0.)), <span class="comment">// No distance threshold (can be omitted)</span></div><div class="line">               points.end());</div><div class="line"></div><div class="line">  <span class="comment">// Optional: after erase(), use Scott Meyer's "swap trick" to trim excess capacity</span></div><div class="line">  std::vector&lt;Point&gt;(points).swap(points);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Point_set_processing_3Simplification"></a>
Simplification</h1>
<p>Four simplification functions are devised to reduce an input point set.</p>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga4be2d94f1791d24b8ba0107bc33ad6dc" title="Randomly deletes a user-specified fraction of the input points. ">random_simplify_point_set()</a></code> randomly deletes a user-specified fraction of points from the input point set. This algorithm is the fastest.</p>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga7757ef9b3900e42fde26f5a0ac56e20f" title="Merges points which belong to the same cell of a grid of cell size = epsilon. ">grid_simplify_point_set()</a></code> considers a regular grid covering the bounding box of the input point set, and clusters all points sharing the same cell of the grid by picking as representative one arbitrarily chosen point: representatives may only be retained in cells that have more than a user-defined minimum number of points in order to also filter out low density areas and outliers. This algorithm is still fast, although slower than <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga4be2d94f1791d24b8ba0107bc33ad6dc" title="Randomly deletes a user-specified fraction of the input points. ">random_simplify_point_set()</a></code>.</p>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga3420351b6d3fad079d13f894f42e9d03" title="Recursively split the point set in smaller clusters until the clusters have fewer than size elements ...">hierarchy_simplify_point_set()</a></code> provides an adaptive simplification of the point set through local clusters <a class="el" href="citelist.html#CITEREF_cgal:pgk-esops-02">[10]</a>. The size of the clusters is either directly selected by the user or it automatically adapts to the local variation of the point set.</p>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga79ee6fb524ec53b9b85eb32e7ae56ca8" title="This is an implementation of the Weighted Locally Optimal Projection (WLOP) simplification algorithm...">wlop_simplify_and_regularize_point_set()</a></code> not only simplifies, but also regularizes downsampled points. This is an implementation of the Weighted Locally Optimal Projection (WLOP) algorithm <a class="el" href="citelist.html#CITEREF_wlop-2009">[4]</a>.</p>
<h2><a class="anchor" id="Point_set_processing_3Example_grid_simplification"></a>
Grid Simplification Example</h2>
<p>The following example reads a point set and simplifies it by clustering. To filter out outliers, at least 3 points must lie in a cell so that a point from this cell is kept. <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2grid_simplification_example_8cpp-example.html">Point_set_processing_3/grid_simplification_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/grid_simplify_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/oni.pwn"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Reads a point set file in points[].</span></div><div class="line">  std::vector&lt;Point&gt; points;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname, std::back_inserter(points)))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// simplification by clustering using erase-remove idiom</span></div><div class="line">  <span class="keywordtype">double</span> cell_size = 0.03;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> min_points_per_cell = 3;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> iterator_to_first_to_remove</div><div class="line">    = <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga7757ef9b3900e42fde26f5a0ac56e20f">CGAL::grid_simplify_point_set</a></div><div class="line">    (points, cell_size,</div><div class="line">     CGAL::parameters::min_points_per_cell(min_points_per_cell)); <span class="comment">// optional</span></div><div class="line"></div><div class="line">  points.erase(iterator_to_first_to_remove, points.end());</div><div class="line"></div><div class="line">  <span class="comment">// Optional: after erase(), shrink_to_fit to trim excess capacity</span></div><div class="line">  points.shrink_to_fit();</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="fig__Point_set_processing_3figgrid_simplification"></a></p><div class="image">
<img src="grid_simplification.jpg" alt="grid_simplification.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figgrid_simplification">Figure 80.14</a> Point set simplification through grid-based clustering. Removed points are depicted in red. Notice how low-density areas (in green) are not simplified.  </div> <br /> 
<h2><a class="anchor" id="Point_set_processing_3Example_hierarchy_simplication"></a>
Hierarchy Simplification Example</h2>
<p>The following example reads a point set and produces a set of clusters.</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2hierarchy_simplification_example_8cpp-example.html">Point_set_processing_3/hierarchy_simplification_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/hierarchy_simplify_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Memory_sizer.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/oni.pwn"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Reads a point set file in points[].</span></div><div class="line">  std::vector&lt;Point&gt; points;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname, std::back_inserter(points)))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Read "</span> &lt;&lt; points.size () &lt;&lt; <span class="stringliteral">" point(s)"</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  CGAL::Timer task_timer; task_timer.start();</div><div class="line"></div><div class="line">  <span class="comment">// simplification by clustering using erase-remove idiom</span></div><div class="line">  points.erase(<a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga3420351b6d3fad079d13f894f42e9d03">CGAL::hierarchy_simplify_point_set</a>(points,</div><div class="line">                                                  CGAL::parameters::size(100)<span class="comment">// Max cluster size</span></div><div class="line">                                                                   .maximum_variation(0.01)), <span class="comment">// Max surface variation</span></div><div class="line">               points.end());</div><div class="line"></div><div class="line">  std::size_t memory = CGAL::Memory_sizer().virtual_size();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; points.size () &lt;&lt; <span class="stringliteral">" point(s) kept, computed in "</span></div><div class="line">            &lt;&lt; task_timer.time() &lt;&lt; <span class="stringliteral">" seconds, "</span></div><div class="line">            &lt;&lt; (memory&gt;&gt;20) &lt;&lt; <span class="stringliteral">" Mib allocated."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3IO.html#ga5822feba4449f0492363611620b877c0">CGAL::IO::write_points</a>(<span class="stringliteral">"out.xyz"</span>, points, CGAL::parameters::stream_precision(17));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h3><a class="anchor" id="Point_set_processing_3Hierarchy_simplification_parameter_size"></a>
Parameter: size</h3>
<p>The hierarchy simplification algorithm recursively split the point set in two until each cluster's size is less than the parameter <code>size</code>.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figHierarchy_simplification_size"></a></p><div class="image">
<img src="hierarchical_clustering_size.jpg" alt="hierarchical_clustering_size.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figHierarchy_simplification_size">Figure 80.15</a> Input point set and hierarchy simplification with different <code>size</code> parameter: \(10\), \(100\) and \(1000\). In the 3 cases, <code>var_max</code> \(=1/3\). </div> <br /> 
<h3><a class="anchor" id="Point_set_processing_3Hierarchy_simplification_parameter_var_max"></a>
Parameter: var_max</h3>
<p>In addition to the size parameter, a variation parameter allows to increase simplification in monotonous regions. For each cluster, a surface variation measure is computed using the sorted eigenvalues of the covariance matrix: </p><p class="formulaDsp">
\[ \sigma(p) = \frac{\lambda_0}{\lambda_0 + \lambda_1 + \lambda_2}. \]
</p>
<p>This function goes from \(0\) if the cluster is coplanar to \(1/3\) if it is fully isotropic. If a cluster's variation is above <code>var_max</code>, it is split. If <code>var_max</code> is equal to \(1/3\), this parameter has no effect and the clustering is regular on the whole point set.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figHierarchical_clustering_var_max"></a></p><div class="image">
<img src="hierarchical_clustering_var_max.jpg" alt="hierarchical_clustering_var_max.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figHierarchical_clustering_var_max">Figure 80.16</a> Input point set and hierarchy simplification with different <code>var_max</code> parameter: \(0.00001\), \(0.001\) and \(0.1\). In the 3 cases, <code>size</code> \(=1000\). </div> <br /> 
<h2><a class="anchor" id="Point_set_processing_3Example_wlop"></a>
WLOP Simplification Example</h2>
<p>The following example reads a point set, simplifies and regularizes it by WLOP.</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2wlop_simplify_and_regularize_point_set_example_8cpp-example.html">Point_set_processing_3/wlop_simplify_and_regularize_point_set_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/wlop_simplify_and_regularize_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"></div><div class="line"><span class="comment">// Concurrency</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a> Concurrency_tag;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string input_filename = (argc&gt;1)?argv[1]:<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/sphere_20k.xyz"</span>);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* output_filename = (argc&gt;2)?argv[2]:<span class="stringliteral">"data/sphere_20k_WLOPED.xyz"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Reads a .xyz point set file in points[]</span></div><div class="line">  std::vector&lt;Point&gt; points;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(input_filename, std::back_inserter(points)))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; input_filename  &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::vector&lt;Point&gt; output;</div><div class="line"></div><div class="line">  <span class="comment">//parameters</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> retain_percentage = 2;   <span class="comment">// percentage of points to retain.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> neighbor_radius = 0.5;   <span class="comment">// neighbors size.</span></div><div class="line"></div><div class="line">  CGAL::wlop_simplify_and_regularize_point_set&lt;Concurrency_tag&gt;</div><div class="line">    (points, std::back_inserter(output),</div><div class="line">     CGAL::parameters::select_percentage(retain_percentage).</div><div class="line">     neighbor_radius (neighbor_radius));</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga5822feba4449f0492363611620b877c0">CGAL::IO::write_points</a>(output_filename, output, CGAL::parameters::stream_precision(17)))</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="fig__Point_set_processing_3figsimplification_comparison"></a></p><div class="image">
<img src="simplification_comparison.jpg" alt="simplification_comparison.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figsimplification_comparison">Figure 80.17</a> Comparison for three simplification methods: Left: Random simplification result. Middle: Grid simplification result. Right: WLOP simplification result.  </div> <br /> 
<h3><a class="anchor" id="Point_set_processing_3WLOP_Parameter"></a>
Parameter: require_uniform_sampling</h3>
<p>Computing density weights for each point is an optional preprocessing. For example, as shown in the following figure, when require_uniform_sampling is set to false, WLOP preserves the intrinsic non-uniform sampling of the original points; if require_uniform_sampling is set to true, WLOP is resilient to non-uniform sampling and generates sample points with more uniform distribution, at the expense of computational time.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figWLOP_parameter_density"></a></p><div class="image">
<img src="WLOP_parameter_density.jpg" alt="WLOP_parameter_density.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figWLOP_parameter_density">Figure 80.18</a> Comparison between with and without density: Left: input. Middle: <code>require_uniform_sampling = false</code>. Right: <code>require_uniform_sampling=true</code>.  </div> <br /> 
<h3><a class="anchor" id="Point_set_processing_3WLOP_parameter_neighborhood_size"></a>
Parameter: neighbor_radius</h3>
<p>Usually, the neighborhood of sample points should include at least two rings of neighboring sample points. Using a small neighborhood size may not be able to generate regularized result, while using big neighborhood size will make the sample points shrink into the interior of the local surface (under-fitting). The function will use a neighborhood size estimation if this parameter value is set to default or smaller that zero.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figWLOP_parameter_neighborhood_size"></a></p><div class="image">
<img src="WLOP_parameter_neighborhood_size.jpg" alt="WLOP_parameter_neighborhood_size.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figWLOP_parameter_neighborhood_size">Figure 80.19</a> Comparison between different sizes of neighbor radius.  </div> <br /> 
<h3><a class="anchor" id="Point_set_processing_3WLOP_parallel_performance"></a>
Parallel Performance</h3>
<p>A parallel version of WLOP is provided and requires the executable to be linked against the <a href="https://github.com/oneapi-src/oneTBB">Intel TBB library</a>. To control the number of threads used, the user may use the tbb::task_scheduler_init class. See the <a href="https://software.intel.com/content/www/us/en/develop/documentation/onetbb-documentation/top.html">TBB documentation</a> for more details. We provide below a speed-up chart generated using the parallel version of the WLOP algorithm. The machine used is a PC running Windows 7 64-bits with a 4-core <a href="#" onclick="location.href='mai'+'lto:'+'i7-'+'47'+'00H'+'Q@'+'2.4'+'0G'+'Hz'; return false;">i7-47<span style="display: none;">.nosp@m.</span>00HQ<span style="display: none;">.nosp@m.</span>@2.40<span style="display: none;">.nosp@m.</span>GHz</a> CPU with 8GB of RAM.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figWLOP_parallel_performance"></a></p><div class="image">
<img src="parallel_WLOP_performance.jpg" alt="parallel_WLOP_performance.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figWLOP_parallel_performance">Figure 80.20</a> Parallel WLOP speed-up, compared to the sequential version of the algorithm.  </div> <br /> 
<h1><a class="anchor" id="Point_set_processing_3Smoothing"></a>
Smoothing</h1>
<p>Two smoothing functions are devised to smooth an input point set.</p>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga96a3738be3b2b9bd1587af78ae10e67a" title="Smoothes the range of points using jet fitting on the nearest neighbors and reprojection onto the jet...">jet_smooth_point_set()</a></code> smooths the input point set by projecting each point onto a smooth parametric surface patch (so-called jet surface) fitted over its nearest neighbors.</p>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga01192a227578fee0c5676ba6a5e88931" title="This function smooths an input point set by iteratively projecting each point onto the implicit surfa...">bilateral_smooth_point_set()</a></code> smooths the input point set by iteratively projecting each point onto the implicit surface patch fitted over its nearest neighbors. Bilateral projection preserves sharp features according to the normal (gradient) information. Normals are thus required as input. For more details, see section 4 of <a class="el" href="citelist.html#CITEREF_ear-2013">[5]</a>.</p>
<p>For both functions, the user can either specify a fixed number of nearest neighbors or a fixed spherical neighborhood radius.</p>
<h2><a class="anchor" id="Point_set_processing_3Example_jet_smoothing"></a>
Jet Smoothing Example</h2>
<p>The following example generates a set of 9 points close to the <code>xy</code> plane and smooths them using 8 nearest neighbors: <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2jet_smoothing_example_8cpp-example.html">Point_set_processing_3/jet_smoothing_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/jet_smooth_point_set.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"></div><div class="line"><span class="comment">// Concurrency</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a> Concurrency_tag;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">  <span class="comment">// generate point set</span></div><div class="line">  std::vector&lt;Point&gt; points;</div><div class="line">  points.push_back(Point( 0.0, 0.0, 0.001));</div><div class="line">  points.push_back(Point(-0.1,-0.1, 0.002));</div><div class="line">  points.push_back(Point(-0.1,-0.2, 0.001));</div><div class="line">  points.push_back(Point(-0.1, 0.1, 0.002));</div><div class="line">  points.push_back(Point( 0.1,-0.1, 0.000));</div><div class="line">  points.push_back(Point( 0.1, 0.2, 0.001));</div><div class="line">  points.push_back(Point( 0.2, 0.0, 0.002));</div><div class="line">  points.push_back(Point( 0.2, 0.1, 0.000));</div><div class="line">  points.push_back(Point( 0.0,-0.1, 0.001));</div><div class="line"></div><div class="line">  <span class="comment">// Smoothing.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nb_neighbors = 8; <span class="comment">// default is 24 for real-life point sets</span></div><div class="line">  CGAL::jet_smooth_point_set&lt;Concurrency_tag&gt;(points, nb_neighbors);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Point_set_processing_3Example_bilateral_smoothing"></a>
Bilateral Smoothing Example</h2>
<p>The following example reads a set of points with normals and smooths them via bilateral smoothing: <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2bilateral_smooth_point_set_example_8cpp-example.html">Point_set_processing_3/bilateral_smooth_point_set_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/bilateral_smooth_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/tags.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span> <span class="comment">// defines std::pair</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"></div><div class="line"><span class="comment">// Point with normal vector stored in a std::pair.</span></div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Point, Vector&gt; PointVectorPair;</div><div class="line"></div><div class="line"><span class="comment">// Concurrency</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a> Concurrency_tag;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string input_filename = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/fin90_with_PCA_normals.xyz"</span>);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* output_filename = (argc&gt;2) ? argv[2] : <span class="stringliteral">"data/fin90_with_PCA_normals_bilateral_smoothed.xyz"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Reads a point set file in points[] * with normals *.</span></div><div class="line">  std::vector&lt;PointVectorPair&gt; points;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(input_filename, std::back_inserter(points),</div><div class="line">                            CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                                             .normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>())))</div><div class="line">  {</div><div class="line">     std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; input_filename &lt;&lt; std::endl;</div><div class="line">     <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Algorithm parameters</span></div><div class="line">  <span class="keywordtype">int</span> k = 120;                 <span class="comment">// size of neighborhood. The bigger the smoother the result will be.</span></div><div class="line">                               <span class="comment">// This value should bigger than 1.</span></div><div class="line">  <span class="keywordtype">double</span> sharpness_angle = 25; <span class="comment">// control sharpness of the result.</span></div><div class="line">                               <span class="comment">// The bigger the smoother the result will be</span></div><div class="line">  <span class="keywordtype">int</span> iter_number = 3;         <span class="comment">// number of times the projection is applied</span></div><div class="line"></div><div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; iter_number; ++i)</div><div class="line">  {</div><div class="line">    <span class="comment">/* double error = */</span></div><div class="line">    CGAL::bilateral_smooth_point_set &lt;Concurrency_tag&gt;(</div><div class="line">      points,</div><div class="line">      k,</div><div class="line">      CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                       .normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                       .sharpness_angle(sharpness_angle));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IOXyz.html#ga1991ab8d312de62ddd907f81890ed039">CGAL::IO::write_XYZ</a>(output_filename, points,</div><div class="line">                          CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                                           .normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                                           .stream_precision(17)))</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p><a class="anchor" id="fig__Point_set_processing_3figsmoothing_comparison"></a></p><div class="image">
<img src="smoothing_comparison.jpg" alt="smoothing_comparison.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figsmoothing_comparison">Figure 80.21</a> Comparison for two smoothing methods: Left: Input, 250K points, normal-color mapping. Middle: Jet smoothing result, 197 seconds. Right: Bilateral smoothing result, 110 seconds.  </div> <br /> 
<h3><a class="anchor" id="Point_set_processing_3Bilateral_smoothing_parallel_performance"></a>
Parallel</h3>
<p>Performance: A parallel version of bilateral smoothing is provided and requires the executable to be linked against the <a href="https://github.com/oneapi-src/oneTBB">Intel TBB library</a>. The number of threads used is controlled through the tbb::task_scheduler_init class. See the <a href="https://software.intel.com/content/www/us/en/develop/documentation/onetbb-documentation/top.html">TBB documentation</a> for more details. We provide below a speed-up chart generated using the parallel version of the bilateral smoothing algorithm. The machine used is a PC running Windows 7 64-bits with a 4-core <a href="#" onclick="location.href='mai'+'lto:'+'i7-'+'47'+'00H'+'Q@'+'2.4'+'0G'+'Hz'; return false;">i7-47<span style="display: none;">.nosp@m.</span>00HQ<span style="display: none;">.nosp@m.</span>@2.40<span style="display: none;">.nosp@m.</span>GHz</a> CPU with 8GB of RAM.</p>
<p><a class="anchor" id="fig__Point_set_processing_3Bilateral_smoothing_parallel_performance"></a></p><div class="image">
<img src="parallel_bilateral_smooth_point_set_performance.jpg" alt="parallel_bilateral_smooth_point_set_performance.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3Bilateral_smoothing_parallel_performance">Figure 80.22</a> Parallel bilateral smoothing speed-up, compared to the sequential version of the algorithm.  </div> <br /> 
<h1><a class="anchor" id="Point_set_processing_3NormalEstimation"></a>
Normal Estimation</h1>
<p>Assuming a point set sampled over an inferred surface <b>S</b>, two functions provide an estimate of the normal to <b>S</b> at each point. The result is an unoriented normal vector for each input point.</p>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga078e25209373cab0e1f3524202489771" title="Estimates normal directions of the range of points using jet fitting on the nearest neighbors...">jet_estimate_normals()</a></code> estimates the normal direction at each point from the input set by fitting a jet surface over its nearest neighbors. The default jet is a quadric surface. This algorithm is well suited to point sets scattered over curved surfaces.</p>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga721aeb7af4b2d31e08e75bc5d53303cf" title="Estimates normal directions of the range of points by linear least squares fitting of a plane over th...">pca_estimate_normals()</a></code> estimates the normal direction at each point from the set by linear least squares fitting of a plane over its nearest neighbors. This algorithm is simpler and faster than <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga078e25209373cab0e1f3524202489771" title="Estimates normal directions of the range of points using jet fitting on the nearest neighbors...">jet_estimate_normals()</a></code>.</p>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gaab0fd78ef3e46c4256e9a1145a9d118e" title="Estimates normal directions of the range of points using the Voronoi Covariance Measure with a radius...">vcm_estimate_normals()</a></code> estimates the normal direction at each point from the set by using the Voronoi Covariance Measure of the point set. This algorithm is more complex and slower than the previous algorithms. It is based on the article <a class="el" href="citelist.html#CITEREF_cgal:mog-vbcfe-11">[9]</a>.</p>
<p>For these three functions, the user can either specify a fixed number of nearest neighbors or a fixed spherical neighborhood radius.</p>
<h1><a class="anchor" id="Point_set_processing_3NormalOrientation"></a>
Normal Orientation</h1>
<h2><a class="anchor" id="Point_set_processing_3Mst_orient_normals"></a>
Minimum Spanning Tree</h2>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga17c3c558c3799b65bd23fba971a82a5c" title="Orients the normals of the range of points using the propagation of a seed orientation through a mini...">mst_orient_normals()</a></code> orients the normals of a set of points with unoriented normals using the method described by Hoppe et al. in <em>Surface reconstruction from unorganized points</em> <a class="el" href="citelist.html#CITEREF_cgal:hddms-srup-92">[3]</a>. More specifically, this method constructs a Riemannian graph over the input points (the graph of the nearest neighbor points) and propagates a seed normal orientation within a minimum spanning tree computed over this graph. The result is an oriented normal vector for each input unoriented normal, except for the normals which cannot be successfully oriented.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figmst_orient_normals"></a></p><div class="image">
<img src="mst_orient_normals.jpg" alt="mst_orient_normals.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figmst_orient_normals">Figure 80.23</a> Normal orientation of a sampled cube surface. Left: unoriented normals. Right: orientation of right face normals is propagated to bottom face.  </div> <br /> 
<h3><a class="anchor" id="Point_set_processing_3Example_normals"></a>
Example</h3>
<p>The following example reads a point set from a file, estimates the normals through PCA (either over the 18 nearest neighbors or using a spherical neighborhood radius of twice the average spacing) and orients the normals: <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2normals_example_8cpp-example.html">Point_set_processing_3/normals_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/compute_average_spacing.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/pca_estimate_normals.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/mst_orient_normals.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span> <span class="comment">// defines std::pair</span></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"></div><div class="line"><span class="comment">// Point with normal vector stored in a std::pair.</span></div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Point, Vector&gt; PointVectorPair;</div><div class="line"></div><div class="line"><span class="comment">// Concurrency</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a> Concurrency_tag;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string fname = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/sphere_1k.xyz"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Reads a point set file in points[].</span></div><div class="line">  std::list&lt;PointVectorPair&gt; points;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(fname,</div><div class="line">                            std::back_inserter(points),</div><div class="line">                            CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; fname&lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Estimates normals direction.</span></div><div class="line">  <span class="comment">// Note: pca_estimate_normals() requiresa range of points</span></div><div class="line">  <span class="comment">// as well as property maps to access each point's position and normal.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> nb_neighbors = 18; <span class="comment">// K-nearest neighbors = 3 rings</span></div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 2 &amp;&amp; std::strcmp(argv[2], <span class="stringliteral">"-r"</span>) == 0) <span class="comment">// Use a fixed neighborhood radius</span></div><div class="line">  {</div><div class="line">    <span class="comment">// First compute a spacing using the K parameter</span></div><div class="line">    <span class="keywordtype">double</span> spacing</div><div class="line">        = CGAL::compute_average_spacing&lt;Concurrency_tag&gt;</div><div class="line">          (points, nb_neighbors,</div><div class="line">           CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>()));</div><div class="line"></div><div class="line">    <span class="comment">// Then, estimate normals with a fixed radius</span></div><div class="line">    CGAL::pca_estimate_normals&lt;Concurrency_tag&gt;</div><div class="line">        (points,</div><div class="line">         0, <span class="comment">// when using a neighborhood radius, K=0 means no limit on the number of neighbors returns</span></div><div class="line">         CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                          .normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                          .neighbor_radius(2. * spacing)); <span class="comment">// use 2*spacing as neighborhood radius</span></div><div class="line">  }</div><div class="line">  <span class="keywordflow">else</span> <span class="comment">// Use a fixed number of neighbors</span></div><div class="line">  {</div><div class="line">    CGAL::pca_estimate_normals&lt;Concurrency_tag&gt;</div><div class="line">        (points, nb_neighbors,</div><div class="line">         CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                          .normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>()));</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Orients normals.</span></div><div class="line">  <span class="comment">// Note: mst_orient_normals() requires a range of points</span></div><div class="line">  <span class="comment">// as well as property maps to access each point's position and normal.</span></div><div class="line">  std::list&lt;PointVectorPair&gt;::iterator unoriented_points_begin =</div><div class="line">      <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga17c3c558c3799b65bd23fba971a82a5c">CGAL::mst_orient_normals</a>(points, nb_neighbors,</div><div class="line">                               CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                                                .normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>()));</div><div class="line"></div><div class="line">  <span class="comment">// Optional: delete points with an unoriented normal</span></div><div class="line">  <span class="comment">// if you plan to call a reconstruction algorithm that expects oriented normals.</span></div><div class="line">  points.erase(unoriented_points_begin, points.end());</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Point_set_processing_3Scanline_orient_normals"></a>
Scanline</h2>
<p>The minimum spanning tree results can give suboptimal results on point clouds with many sharp features and occlusions, which typically happens on airborne acquired urban datasets.</p>
<p><code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gafc3627234666e1fb458e9387e9d5f3c6" title="orients the normals of the range of points by estimating a line of sight and checking its consistency...">scanline_orient_normals()</a></code> is an alternative method specialized for point sets which are ordered in scanline aligned on the XY-plane. It can take advantage of LAS properties provided by some LIDAR scanner and is the best choice of normal orientation when dealing with 2.5D urban scenes.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figmst_scanline_orient_normals"></a></p><div class="image">
<img src="scanline_orient_normals.png" alt="scanline_orient_normals.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figmst_scanline_orient_normals">Figure 80.24</a> Normal orientation of a LIDAR scanline. The point cloud is a typical airborne LIDAR input, sampling a building without normal information and with many occlusions (especially on vertical walls).  </div> <br /> 
<h3><a class="anchor" id="Point_set_processing_3Example_scanline_normals"></a>
Example</h3>
<p>The following example reads a point set from a LAS file, estimates the normals through Jet Fitting and outputs in PLY format the orientation results of all the variants of <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gafc3627234666e1fb458e9387e9d5f3c6" title="orients the normals of the range of points by estimating a line of sight and checking its consistency...">scanline_orient_normals()</a></code>:</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2orient_scanlines_example_8cpp-example.html">Point_set_processing_3/orient_scanlines_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_las_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_ply_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/jet_estimate_normals.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/scanline_orient_normals.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> Kernel = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> Point_3 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#ae82b7f4be77dd5b8819ebe419e4ae753">Kernel::Point_3</a>;</div><div class="line"><span class="keyword">using</span> Vector_3 = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel.html#a39fb0222695ae5e7e32f4e570ea28225">Kernel::Vector_3</a>;</div><div class="line"><span class="keyword">using</span> Point_with_info = std::tuple&lt;Point_3, Vector_3, float, unsigned char&gt;;</div><div class="line"><span class="keyword">using</span> Point_map = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;0, Point_with_info&gt;</a>;</div><div class="line"><span class="keyword">using</span> Normal_map = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;1, Point_with_info&gt;</a>;</div><div class="line"><span class="keyword">using</span> Scan_angle_map = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;2, Point_with_info&gt;</a>;</div><div class="line"><span class="keyword">using</span> Scanline_id_map = <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Nth__of__tuple__property__map.html">CGAL::Nth_of_tuple_property_map&lt;3, Point_with_info&gt;</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> dump (<span class="keyword">const</span> <span class="keywordtype">char</span>* filename, <span class="keyword">const</span> std::vector&lt;Point_with_info&gt;&amp; points)</div><div class="line">{</div><div class="line">  std::ofstream ofile (filename, std::ios::binary);</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Stream_support.tag:../Stream_support/" href="../Stream_support/group__PkgStreamSupportRef.html#ga7eb5683e79d8aa69059a453dc44cbaa7">CGAL::IO::set_binary_mode</a>(ofile);</div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3IOPly.html#ga615f4420ce82b5ceb1b584b506d714ad">CGAL::IO::write_PLY</a></div><div class="line">    (ofile, points,</div><div class="line">     CGAL::parameters::point_map (Point_map()).</div><div class="line">     normal_map (Normal_map()));</div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  std::string fname (argc &gt; 1 ? argv[1] : <span class="stringliteral">"data/urban.las"</span>);</div><div class="line"></div><div class="line">  std::vector&lt;Point_with_info&gt; points;</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Reading input file "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">  std::ifstream ifile (fname, std::ios::binary);</div><div class="line">  <span class="keywordflow">if</span> (!ifile ||</div><div class="line">      !<a class="code" href="group__PkgPointSetProcessing3IOLas.html#ga5187fc18430a5e3c811f75da57a057ad">CGAL::IO::read_LAS_with_properties</a></div><div class="line">      (ifile, std::back_inserter (points),</div><div class="line">       <a class="code" href="group__PkgPointSetProcessing3IOLas.html#gac807a7bbde008f9707a1cf697e3eb64c">CGAL::IO::make_las_point_reader</a> (Point_map()),</div><div class="line">       std::make_pair (Scan_angle_map(),</div><div class="line">                       CGAL::IO::LAS_property::Scan_angle()),</div><div class="line">       std::make_pair (Scanline_id_map(),</div><div class="line">                       CGAL::IO::LAS_property::Scan_direction_flag())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Can't read "</span> &lt;&lt; fname &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Estimating normals"</span> &lt;&lt; std::endl;</div><div class="line">  CGAL::jet_estimate_normals&lt;CGAL::Parallel_if_available_tag&gt;</div><div class="line">    (points, 12,</div><div class="line">     CGAL::parameters::point_map (Point_map()).</div><div class="line">     normal_map (Normal_map()));</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Orienting normals using scan angle and direction flag"</span> &lt;&lt; std::endl;</div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#gafc3627234666e1fb458e9387e9d5f3c6">CGAL::scanline_orient_normals</a></div><div class="line">    (points,</div><div class="line">     CGAL::parameters::point_map (Point_map()).</div><div class="line">     normal_map (Normal_map()).</div><div class="line">     scan_angle_map (Scan_angle_map()).</div><div class="line">     scanline_id_map (Scanline_id_map()));</div><div class="line">  dump(<span class="stringliteral">"out_angle_and_flag.ply"</span>, points);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Orienting normals using scan direction flag only"</span> &lt;&lt; std::endl;</div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#gafc3627234666e1fb458e9387e9d5f3c6">CGAL::scanline_orient_normals</a></div><div class="line">    (points,</div><div class="line">     CGAL::parameters::point_map (Point_map()).</div><div class="line">     normal_map (Normal_map()).</div><div class="line">     scanline_id_map (Scanline_id_map()));</div><div class="line">  dump(<span class="stringliteral">"out_flag.ply"</span>, points);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Orienting normals using scan angle only"</span> &lt;&lt; std::endl;</div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#gafc3627234666e1fb458e9387e9d5f3c6">CGAL::scanline_orient_normals</a></div><div class="line">    (points,</div><div class="line">     CGAL::parameters::point_map (Point_map()).</div><div class="line">     normal_map (Normal_map()).</div><div class="line">     scan_angle_map (Scan_angle_map()));</div><div class="line">  dump(<span class="stringliteral">"out_angle.ply"</span>, points);</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; <span class="stringliteral">"Orienting normals using no additional info"</span> &lt;&lt; std::endl;</div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#gafc3627234666e1fb458e9387e9d5f3c6">CGAL::scanline_orient_normals</a></div><div class="line">    (points,</div><div class="line">     CGAL::parameters::point_map (Point_map()).</div><div class="line">     normal_map (Normal_map()));</div><div class="line">  dump(<span class="stringliteral">"out_nothing.ply"</span>, points);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Point_set_processing_3Upsampling"></a>
Upsampling</h1>
<p>The function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga8712cbc64f1cfd4dd2f61049a24b90f4" title="This method progressively upsamples the point set while approaching the edge singularities (detected ...">edge_aware_upsample_point_set()</a></code> generates a denser point set from an input point set. This has applications in point-based rendering, hole filling, and sparse surface reconstruction. The algorithm can progressively upsample the point set while approaching the edge singularities. See <a class="el" href="citelist.html#CITEREF_ear-2013">[5]</a> for more details.</p>
<h2><a class="anchor" id="Point_set_processing_3Example_upsampling"></a>
Example</h2>
<p>The following example reads a point set from a file, upsamples it to get a denser result.</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2edge_aware_upsample_point_set_example_8cpp-example.html">Point_set_processing_3/edge_aware_upsample_point_set_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Simple_cartesian.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/edge_aware_upsample_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/structCGAL_1_1Simple__cartesian.html">CGAL::Simple_cartesian&lt;double&gt;</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"></div><div class="line"><span class="comment">// Point with normal vector stored in a std::pair.</span></div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Point, Vector&gt; PointVectorPair;</div><div class="line"></div><div class="line"><span class="comment">// Concurrency</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a> Concurrency_tag;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string input_filename = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/before_upsample.xyz"</span>);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* output_filename = (argc&gt;2) ? argv[2] : <span class="stringliteral">"data/before_upsample_UPSAMPLED.xyz"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Reads a .xyz point set file in points[], *with normals*.</span></div><div class="line">  std::vector&lt;PointVectorPair&gt; points;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(input_filename,</div><div class="line">                            std::back_inserter(points),</div><div class="line">                            CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                                             .normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file "</span> &lt;&lt; input_filename &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">//Algorithm parameters</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> sharpness_angle = 25;   <span class="comment">// control sharpness of the result.</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> edge_sensitivity = 0;    <span class="comment">// higher values will sample more points near the edges</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> neighbor_radius = 0.25;  <span class="comment">// initial size of neighborhood.</span></div><div class="line">  <span class="keyword">const</span> std::size_t number_of_output_points = points.size() * 4;</div><div class="line"></div><div class="line">   <span class="comment">//Run algorithm</span></div><div class="line">  CGAL::edge_aware_upsample_point_set&lt;Concurrency_tag&gt;(</div><div class="line">    points,</div><div class="line">    std::back_inserter(points),</div><div class="line">    CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>()).</div><div class="line">    normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>()).</div><div class="line">    sharpness_angle(sharpness_angle).</div><div class="line">    edge_sensitivity(edge_sensitivity).</div><div class="line">    neighbor_radius(neighbor_radius).</div><div class="line">    number_of_output_points(number_of_output_points));</div><div class="line"></div><div class="line">  <span class="comment">// Saves point set.</span></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga5822feba4449f0492363611620b877c0">CGAL::IO::write_points</a>(output_filename, points,</div><div class="line">                             CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                                              .normal_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;PointVectorPair&gt;</a>())</div><div class="line">                                              .stream_precision(17)))</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="Point_set_processing_3Upsample_Parameter1"></a>
Parameter: edge_sensitivity</h3>
<p>This parameter controls where the new points are inserted. Larger values of edge-sensitivity give higher priority to inserting points along the sharp features. For example, as shown in the following figure, high value is preferable when one wants to insert more points on sharp features, where the local gradient is high, e.g., darts, cusps, creases and corners. In contrast, points are evenly inserted when edge_sensitivity is set to 0. The range of possible value is [0, 1].</p>
<p><a class="anchor" id="fig__Point_set_processing_3figUpsample_edge_sensitivity"></a></p><div class="image">
<img src="upsample_edge_sensitivity.jpg" alt="upsample_edge_sensitivity.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figUpsample_edge_sensitivity">Figure 80.25</a> Upsampling for different edge-sensitivity parameter values. The input containing 850 points is upsampled to 1,500 points in all cases depicted.  </div> <br /> 
<h3><a class="anchor" id="Point_set_processing_3Upsample_Parameter2"></a>
Parameter: sharpness_angle</h3>
<p>This parameter controls the preservation of sharp features.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figUpsample_sharpness_angle"></a></p><div class="image">
<img src="upsample_sharpness_angle.jpg" alt="upsample_sharpness_angle.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figUpsample_sharpness_angle">Figure 80.26</a> Upsampling for different sharpness_angle parameter values. The input containing 850 points is upsampled to 425K points in all cases depicted.  </div> <br /> 
<h3><a class="anchor" id="Point_set_processing_3upsample_neighborhood_size"></a>
Parameter: neighbor_radius</h3>
<p>Usually, the neighborhood of sample points should include at least one ring of neighboring sample points. Using small neighborhood size may not be able to insert new points. Using big neighborhood size can fill small holes, but points inserted on the edges could be irregular. The function will use a neighborhood size estimation if this parameter value is set to default or smaller than zero.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figupsample_neighborhood_size"></a></p><div class="image">
<img src="upsample_neighborhood_size.jpg" alt="upsample_neighborhood_size.jpg" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figupsample_neighborhood_size">Figure 80.27</a> Comparison between different sizes of neighbor radius.  </div> <br /> 
<h1><a class="anchor" id="Point_set_processing_3FeaturesEstimation"></a>
Feature Edges Estimation</h1>
<p>Function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gac57ce53e3249a66e4c19e85f439ff01e" title="determines if a point is on a sharp feature edge from a point set for which the Voronoi covariance Me...">vcm_is_on_feature_edge()</a></code> indicates if a points belong to a feature edges of the point set using its Voronoi Covariance Measure. It is based on the article <a class="el" href="citelist.html#CITEREF_cgal:mog-vbcfe-11">[9]</a>.</p>
<p>It first computes the VCM of the points set using <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#ga258a9b3a40d10533f8f01d64b4e91eca" title="computes the Voronoi Covariance Measure (VCM) of a point cloud, a construction that can be used for n...">compute_vcm()</a></code>. Then, it estimates which points belong to a sharp edge by testing if a ratio of eigenvalues is greater than a given threshold.</p>
<h2><a class="anchor" id="Point_set_processing_3Example_sharp_edges"></a>
Example</h2>
<p>The following example reads a point set from a file, estimates the points that are on sharp edges: <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2edges_example_8cpp-example.html">Point_set_processing_3/edges_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/vcm_estimate_edges.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;utility&gt;</span> <span class="comment">// defines std::pair</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Vector__3.html">Kernel::Vector_3</a> Vector;</div><div class="line"></div><div class="line"><span class="comment">// Point with normal vector stored in a std::pair.</span></div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Point, Vector&gt; PointVectorPair;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;PointVectorPair&gt; PointList;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> std::array&lt;double,6&gt; Covariance;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> , <span class="keywordtype">char</span>**)</div><div class="line">{</div><div class="line">  <span class="comment">// Reads a polygon mesh file in points[].</span></div><div class="line">  std::list&lt;PointVectorPair&gt; points;</div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"meshes/fandisk_large.off"</span>),</div><div class="line">                            std::back_inserter(points),</div><div class="line">                            CGAL::parameters::point_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a>())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file data/fandisk_large.off"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Estimates covariance matrices per points.</span></div><div class="line">  <span class="keywordtype">double</span> R = 0.2,</div><div class="line">         r = 0.1;</div><div class="line">  std::vector&lt;Covariance&gt; cov;</div><div class="line">  <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;PointVectorPair&gt;</a> point_map;</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga258a9b3a40d10533f8f01d64b4e91eca">CGAL::compute_vcm</a>(points, cov, R, r,</div><div class="line">                    CGAL::parameters::point_map (point_map).geom_traits (Kernel()));</div><div class="line"></div><div class="line">  <span class="comment">// Find the points on the edges.</span></div><div class="line">  <span class="comment">// Note that this step is not expensive and can be done several time to get better results</span></div><div class="line">  <span class="keywordtype">double</span> threshold = 0.16;</div><div class="line">  std::ofstream output(<span class="stringliteral">"points_on_edges.xyz"</span>);</div><div class="line">  <span class="keywordtype">int</span> i = 0;</div><div class="line">  <span class="keywordflow">for</span>(<span class="keyword">const</span> PointVectorPair&amp; p : points)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__PkgPointSetProcessing3Algorithms.html#gac57ce53e3249a66e4c19e85f439ff01e">CGAL::vcm_is_on_feature_edge</a>(cov[i], threshold))</div><div class="line">      output &lt;&lt; p.first &lt;&lt; <span class="stringliteral">"\n"</span>;</div><div class="line">    ++i;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h1><a class="anchor" id="Point_set_processing_3Structuring"></a>
Structuring</h1>
<p>The function <code><a class="el" href="group__PkgPointSetProcessing3Algorithms.html#gaebbc04909dfd575a94f932c8d3bacdce" title="This is an implementation of the Point Set Structuring algorithm. ">structure_point_set()</a></code> generates a structured version of the input point set assigned to a set of planes. Such an input can be produced by a shape detection algorithm (see <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/group__PkgShapeDetectionRef.html">Shape Detection Reference</a>). Point set structuring is based on the article <a class="el" href="citelist.html#CITEREF_cgal:la-srpss-13">[6]</a>.</p>
<ul>
<li><b>Planes</b>: inliers of each detected plane are replaced by sets of noise-free points sampled at the vertices of a regular grid: this is achieved by filling an occupancy grid aligned on the principal components of the inlier sets with a spacing lower than \(\sqrt{2}\) times the user-defined tolerance.</li>
<li><b>Creases</b>: adjacencies between 2 planes are detected and regularly resampled on an occupancy array along the edge with a spacing equal to twice the user-defined tolerance.</li>
<li><b>Corners</b>: 3-cycles are detected from the primitive adjacency graph and sampled using the exact intersection point of the 3 planes (provided it exists and remains in the given tolerance). These corners are also locally clustered to former corners of degree higher than 3.</li>
</ul>
<p>This algorithm is well suited to point sets sampled on surfaces with planar sections and sharp edges.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figstructuring"></a></p><div class="image">
<img src="structuring.png" alt="structuring.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figstructuring">Figure 80.28</a> Point set structuring. Left: input raw point set. Right: structured point set.  </div> <br /> 
<p>Structure information of points can be used to perform feature preserving reconstruction (see <a class="elRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Advancing_front_surface_reconstruction.tag:../Advancing_front_surface_reconstruction/" href="../Advancing_front_surface_reconstruction/index.html#AFSR_Example_sharp_features">Advancing Front Surface Reconstruction</a> for example). More specifically, the class storing a point set with structure provides the user with a method <code><a class="el" href="classCGAL_1_1Point__set__with__structure.html#ae8890334744d8d7efd17917c62fc1513" title="Computes the coherence of a facet between the 3 points indexed by f with respect to the underlying st...">Point_set_with_structure::facet_coherence()</a></code> that estimates if a triplet of points form a coherent facet.</p>
<p><a class="anchor" id="fig__Point_set_processing_3figstructuring_coherence"></a></p><div class="image">
<img src="structuring_coherence.png" alt="structuring_coherence.png" />
</div>
   <div class="cgal_figure_caption">  <a class="el" href="index.html#fig__Point_set_processing_3figstructuring_coherence">Figure 80.29</a> (a) Input point set (and structured output); (b) output with many incoherent facets; (c) output with all facets coherent. i, j and k each corresponds to a primitive index.  </div> <br /> 
<h2><a class="anchor" id="Point_set_processing_3Example_9"></a>
Example</h2>
<p>The following example applies shape detection followed by structuring to a point set: <br />
<b>File</b> <a class="el" href="Point_set_processing_3_2structuring_example_8cpp-example.html">Point_set_processing_3/structuring_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/read_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/IO/write_points.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/property_map.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Shape_detection/Efficient_RANSAC.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/structure_point_set.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Type declarations</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>  Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a>                                      Point;</div><div class="line"><span class="keyword">typedef</span> std::pair&lt;Kernel::Point_3, Kernel::Vector_3&gt;         Point_with_normal;</div><div class="line"><span class="keyword">typedef</span> std::vector&lt;Point_with_normal&gt;                       Pwn_vector;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1First__of__pair__property__map.html">CGAL::First_of_pair_property_map&lt;Point_with_normal&gt;</a>  Point_map;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Property_map.tag:../Property_map/" href="../Property_map/structCGAL_1_1Second__of__pair__property__map.html">CGAL::Second_of_pair_property_map&lt;Point_with_normal&gt;</a> Normal_map;</div><div class="line"></div><div class="line"><span class="comment">// Efficient RANSAC types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/structCGAL_1_1Shape__detection_1_1Efficient__RANSAC__traits.html">CGAL::Shape_detection::Efficient_RANSAC_traits</a></div><div class="line">  &lt;Kernel, Pwn_vector, Point_map, Normal_map&gt;              Traits;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Efficient__RANSAC.html">CGAL::Shape_detection::Efficient_RANSAC&lt;Traits&gt;</a>    Efficient_ransac;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Plane.html">CGAL::Shape_detection::Plane&lt;Traits&gt;</a>               Plane;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> std::string filename = (argc&gt;1) ? argv[1] : <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/namespaceCGAL.html#acdae9a147ad2a3998cc21f88bc292dac">CGAL::data_file_path</a>(<span class="stringliteral">"points_3/cube.pwn"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Points with normals.</span></div><div class="line">  Pwn_vector points;</div><div class="line"></div><div class="line">  <span class="comment">// Loading point set from a file.</span></div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(!<a class="code" href="group__PkgPointSetProcessing3IO.html#ga8fac388459c5cf96bf11ce3b4e0459c1">CGAL::IO::read_points</a>(filename, std::back_inserter(points),</div><div class="line">                            CGAL::parameters::point_map(Point_map())</div><div class="line">                                             .normal_map(Normal_map())))</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot read file cube.pwn"</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; points.size() &lt;&lt; <span class="stringliteral">" point(s) read."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// Shape detection</span></div><div class="line">  Efficient_ransac ransac;</div><div class="line">  ransac.set_input(points);</div><div class="line">  ransac.add_shape_factory&lt;Plane&gt;();</div><div class="line">  ransac.detect();</div><div class="line"></div><div class="line">  Efficient_ransac::Plane_range planes = ransac.planes();</div><div class="line"></div><div class="line">  Pwn_vector structured_pts;</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3Algorithms.html#gaebbc04909dfd575a94f932c8d3bacdce">CGAL::structure_point_set</a>(points,</div><div class="line">                            planes,</div><div class="line">                            std::back_inserter(structured_pts),</div><div class="line">                            0.015, <span class="comment">// epsilon for structuring points</span></div><div class="line">                            CGAL::parameters::point_map(Point_map())</div><div class="line">                                             .normal_map(Normal_map())</div><div class="line">                                             .plane_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Plane__map.html">CGAL::Shape_detection::Plane_map&lt;Traits&gt;</a>())</div><div class="line">                                             .plane_index_map(<a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Shape_detection.tag:../Shape_detection/" href="../Shape_detection/classCGAL_1_1Shape__detection_1_1Point__to__shape__index__map.html">CGAL::Shape_detection::Point_to_shape_index_map&lt;Traits&gt;</a>(points, planes)));</div><div class="line"></div><div class="line">  std::cerr &lt;&lt; structured_pts.size ()</div><div class="line">            &lt;&lt; <span class="stringliteral">" structured point(s) generated."</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="group__PkgPointSetProcessing3IO.html#ga5822feba4449f0492363611620b877c0">CGAL::IO::write_points</a>(<span class="stringliteral">"out.pwn"</span>, structured_pts,</div><div class="line">                         CGAL::parameters::point_map(Point_map())</div><div class="line">                                          .normal_map(Normal_map())</div><div class="line">                                          .stream_precision(17));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Point_set_processing_3Callbacks"></a>
Callbacks</h1>
<p>Several functions of this package provide a callback mechanism that enables the user to track the progress of the algorithms and to interrupt them if needed. A callback, in this package, is an instance of <code>std::function&lt;bool(double)&gt;</code> that takes the advancement as a parameter (between 0. when the algorithm begins to 1. when the algorithm is completed) and that returns <code>true</code> if the algorithm should carry on, <code>false</code> otherwise. It is passed as a named parameter with an empty function as default.</p>
<p>Algorithms that support this mechanism are detailed in the <a class="el" href="group__PkgPointSetProcessing3Ref.html">Reference Manual</a>, along with the effect that an early interruption has on the output.</p>
<h2><a class="anchor" id="Point_set_processing_3Example_callbacks"></a>
Example</h2>
<p>The following example defines a callback that displays the name of the current algorithm along with the progress (as a percentage) updated every \(1/10th\) of a second. While the algorithm is running, the console output will typically look like this:</p>
<div class="fragment"><div class="line">Computing average spacing: 100%</div><div class="line">Grid simplification: 100%</div><div class="line">Jet smoothing: 54%</div></div><!-- fragment --><p>Thanks to the carriage return character <code>\r</code>, the lines are overwritten and the user sees the percentage increasing on each line.</p>
<p><br />
<b>File</b> <a class="el" href="Point_set_processing_3_2callback_example_8cpp-example.html">Point_set_processing_3/callback_example.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/point_generators_3.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/Real_timer.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;CGAL/compute_average_spacing.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/grid_simplify_point_set.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;CGAL/jet_smooth_point_set.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/lexical_cast.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Types</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classCGAL_1_1Exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> Kernel;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Manual.tag:../Manual/" href="../Manual/classunspecified__type.html">Kernel::FT</a> FT;</div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/Kernel_23.tag:../Kernel_23/" href="../Kernel_23/classKernel_1_1Point__3.html">Kernel::Point_3</a> Point;</div><div class="line"><span class="keyword">typedef</span> CGAL::Random_points_on_sphere_3&lt;Point&gt; Generator;</div><div class="line"></div><div class="line"><span class="comment">// Concurrency</span></div><div class="line"><span class="keyword">typedef</span> <a class="codeRef" doxygen="/home/runner/work/cgal/cgal/build_doc/doc_tags/STL_Extension.tag:../STL_Extension/" href="../STL_Extension/structCGAL_1_1Parallel__if__available__tag.html">CGAL::Parallel_if_available_tag</a> Concurrency_tag;</div><div class="line"></div><div class="line"><span class="comment">// instance of std::function&lt;bool(double)&gt;</span></div><div class="line"><span class="keyword">struct </span>Progress_to_std_cerr_callback</div><div class="line">{</div><div class="line">  <span class="keyword">mutable</span> std::size_t nb;</div><div class="line">  CGAL::Real_timer timer;</div><div class="line">  <span class="keywordtype">double</span> t_start;</div><div class="line">  <span class="keyword">mutable</span> <span class="keywordtype">double</span> t_latest;</div><div class="line">  <span class="keyword">const</span> std::string name;</div><div class="line"></div><div class="line">  Progress_to_std_cerr_callback (<span class="keyword">const</span> <span class="keywordtype">char</span>* name)</div><div class="line">    : name (name)</div><div class="line">  {</div><div class="line">    timer.start();</div><div class="line">    t_start = timer.time();</div><div class="line">    t_latest = t_start;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> operator()(<span class="keywordtype">double</span> advancement)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="comment">// Avoid calling time() at every single iteration, which could</span></div><div class="line">    <span class="comment">// impact performances very badly</span></div><div class="line">    ++ nb;</div><div class="line">    <span class="keywordflow">if</span> (advancement != 1 &amp;&amp; nb % 100 != 0)</div><div class="line">      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> t = timer.time();</div><div class="line">    <span class="keywordflow">if</span> (advancement == 1 || (t - t_latest) &gt; 0.1) <span class="comment">// Update every 1/10th of second</span></div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">"\r"</span> <span class="comment">// Return at the beginning of same line and overwrite</span></div><div class="line">                &lt;&lt; name &lt;&lt; <span class="stringliteral">": "</span> &lt;&lt; int(advancement * 100) &lt;&lt; <span class="stringliteral">"%"</span>;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (advancement == 1)</div><div class="line">        std::cerr &lt;&lt; std::endl;</div><div class="line">      t_latest = t;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line">  <span class="keywordtype">int</span> N = (argc &gt; 1) ? boost::lexical_cast&lt;int&gt;(argv[1]) : 1000;</div><div class="line"></div><div class="line">  <span class="comment">// Generate N points on a sphere of radius 100.</span></div><div class="line">  std::vector&lt;Point&gt; points;</div><div class="line">  points.reserve(N);</div><div class="line">  Generator generator(100.);</div><div class="line">  std::copy_n(generator, N, std::back_inserter(points));</div><div class="line"></div><div class="line">  <span class="comment">// Compute average spacing</span></div><div class="line">  FT average_spacing = CGAL::compute_average_spacing&lt;Concurrency_tag&gt;</div><div class="line">    (points, 6,</div><div class="line">     CGAL::parameters::callback(Progress_to_std_cerr_callback(<span class="stringliteral">"Computing average spacing"</span>)));</div><div class="line"></div><div class="line">  <span class="comment">// Simplify on a grid with a size of twice the average spacing</span></div><div class="line">  points.erase(<a class="code" href="group__PkgPointSetProcessing3Algorithms.html#ga7757ef9b3900e42fde26f5a0ac56e20f">CGAL::grid_simplify_point_set</a>(points, 2. * average_spacing,</div><div class="line">                                             CGAL::parameters::callback(Progress_to_std_cerr_callback(<span class="stringliteral">"Grid simplification"</span>))),</div><div class="line">               points.end());</div><div class="line"></div><div class="line">  <span class="comment">// Smooth simplified point set</span></div><div class="line">  CGAL::jet_smooth_point_set&lt;Concurrency_tag&gt;(points, 6,</div><div class="line">                                              CGAL::parameters::callback(Progress_to_std_cerr_callback(<span class="stringliteral">"Jet smoothing"</span>)));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><h1><a class="anchor" id="Point_set_processing_3ImplementationHistory"></a>
Implementation History</h1>
<p>Pierre Alliez and Laurent Saboret contributed the initial component. Nader Salman contributed the grid simplification. Started from GSoC'2013, three new algorithms were implemented by Shihao Wu and Clément Jamin: WLOP, bilateral smoothing and upsampling. Started from GSoC'2014, Jocelyn Meyron with the help of Quentin Mérigot introduced the computation of the Voronoi covariance measure of a point set, as well as the normal and feature edge estimation functions based on it. Florent Lafarge with the help of Simon Giraudot contributed the point set structuring algorithm. Started from GSoC'2019, Necip Fazil Yildiran with the help of Nicolas Mellado and Simon Giraudot introduced the wrappers for <a class="el" href="namespaceCGAL_1_1OpenGR.html">OpenGR</a> and PointMatcher libraries that perform registration on two point sets. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jan 30 2023 13:47:22 for CGAL 5.6 - Point Set Processing by
    <a href="https://www.doxygen.nl/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen" /></a> 1.8.13 </li>
  </ul>
</div>
</div>
</body>
</html>

</html>
